[{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode rightExpression = SLinkOperations.getTarget(node, \"rightExpression\", true);\n      SNodeOperations.replaceWithAnother(node, rightExpression);\n      editorContext.flushEvents();\n      EditorComponent editor = editorContext.getNodeEditorComponent();\n      EditorCell cell = editor.findNodeCell(rightExpression);\n      EditorCell firstLeaf = cell.getFirstLeaf(CellConditions.SELECTABLE);\n      editor.changeSelection(firstLeaf);\n      if (firstLeaf instanceof EditorCell_Label) {\n        ((EditorCell_Label)firstLeaf).home();\n      }\n    }","id":84000,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode rightExpression = SLinkOperations.getTarget(node, \"rightExpression\", true);\n      SNodeOperations.replaceWithAnother(node, rightExpression);\n      editorContext.flushEvents();\n      EditorComponent editor = editorContext.getNodeEditorComponent();\n      EditorCell cell = editor.findNodeCell(rightExpression);\n      if (cell != null) {\n        EditorCell firstLeaf = cell.getFirstLeaf(CellConditions.SELECTABLE);\n        editor.changeSelection(firstLeaf);\n        if (firstLeaf instanceof EditorCell_Label) {\n          ((EditorCell_Label)firstLeaf).home();\n        }\n      }\n    }","commit_id":"e9ad1e1aefa1d884ba02cd8c3f85bfe7ee58ad79","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparatorCell(EditorContext context) {\n      {\n        EditorCell_Constant editorCell = new EditorCell_Constant(context, this.getOwner(), \",\");\n        editorCell.setSelectable(false);\n        editorCell.getStyle().set(StyleAttributes.LAYOUT_CONSTRAINT, \"\");\n        return editorCell;\n      }\n    }","id":84001,"modified_method":"public EditorCell createSeparatorCell(EditorContext context) {\n      {\n        EditorCell_Constant editorCell = new EditorCell_Constant(context, this.getOwner(), \",\");\n        editorCell.setSelectable(false);\n        editorCell.getStyle().set(StyleAttributes.LAYOUT_CONSTRAINT, \"\");\n        editorCell.getStyle().set(StyleAttributes.PUNCTUATION_CELL, true);\n        return editorCell;\n      }\n    }","commit_id":"e9ad1e1aefa1d884ba02cd8c3f85bfe7ee58ad79","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparatorCell(EditorContext context) {\n      {\n        EditorCell_Constant editorCell = new EditorCell_Constant(context, this.getOwner(), \",\");\n        editorCell.setSelectable(false);\n        editorCell.getStyle().set(StyleAttributes.LAYOUT_CONSTRAINT, \"\");\n        return editorCell;\n      }\n    }","id":84002,"modified_method":"public EditorCell createSeparatorCell(EditorContext context) {\n      {\n        EditorCell_Constant editorCell = new EditorCell_Constant(context, this.getOwner(), \",\");\n        editorCell.setSelectable(false);\n        editorCell.getStyle().set(StyleAttributes.LAYOUT_CONSTRAINT, \"\");\n        editorCell.getStyle().set(StyleAttributes.PUNCTUATION_CELL, true);\n        return editorCell;\n      }\n    }","commit_id":"e9ad1e1aefa1d884ba02cd8c3f85bfe7ee58ad79","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode attributedNode = SNodeOperations.getParent(node);\n      SNode propertyDeclaration = AttributeOperations.getPropertyDeclaration(SNodeOperations.as(node, \"jetbrains.mps.lang.core.structure.PropertyAttribute\"));\n      EditorCell cell = editorContext.getNodeEditorComponent().findCellWithId(attributedNode, PropertyDeclaration_Behavior.call_getCellId_1216822951265(propertyDeclaration));\n      editorContext.getNodeEditorComponent().changeSelection(cell);\n      SNodeOperations.deleteNode(node);\n    }","id":84003,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode attributedNode = SNodeOperations.getParent(node);\n      SNode propertyDeclaration = AttributeOperations.getPropertyDeclaration(SNodeOperations.as(node, \"jetbrains.mps.lang.core.structure.PropertyAttribute\"));\n      EditorCell cell = editorContext.getNodeEditorComponent().findCellWithId(attributedNode, PropertyDeclaration_Behavior.call_getCellId_1216822951265(propertyDeclaration));\n      if (cell != null) {\n        editorContext.getNodeEditorComponent().changeSelection(cell);\n      }\n      SNodeOperations.deleteNode(node);\n    }","commit_id":"5c07816190429f622f00254ac1f1df28beca1268","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode leftExpression = SLinkOperations.getTarget(node, \"leftExpression\", true);\n      SNodeOperations.replaceWithAnother(node, leftExpression);\n      editorContext.flushEvents();\n      EditorComponent editor = editorContext.getNodeEditorComponent();\n      EditorCell cell = editor.findNodeCell(leftExpression);\n      EditorCell lastLeaf = cell.getLastLeaf(CellConditions.SELECTABLE);\n      editor.changeSelection(lastLeaf);\n      if (lastLeaf instanceof EditorCell_Label) {\n        ((EditorCell_Label)lastLeaf).end();\n      }\n    }","id":84004,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode leftExpression = SLinkOperations.getTarget(node, \"leftExpression\", true);\n      SNodeOperations.replaceWithAnother(node, leftExpression);\n      editorContext.flushEvents();\n      EditorComponent editor = editorContext.getNodeEditorComponent();\n      EditorCell cell = editor.findNodeCell(leftExpression);\n      if (cell != null) {\n        EditorCell lastLeaf = cell.getLastLeaf(CellConditions.SELECTABLE);\n        editor.changeSelection(lastLeaf);\n        if (lastLeaf instanceof EditorCell_Label) {\n          ((EditorCell_Label)lastLeaf).end();\n        }\n      }\n    }","commit_id":"fc8b2b7a6790771c7638f3a83ec48f14ba6d4a11","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Creates a {@link LinkBlock} suitable to be placed in the parent document.\n     * \n     * @param block the {@link Block} that has just been split into a separate document.\n     * @param target name of the target wiki document.\n     * @return a {@link LinkBlock} representing the link from the parent document to new document.\n     */\n    private LinkBlock createLink(Block block, String target)\n    {\n        Block firstBlock = block.getChildren().get(0);\n        if (firstBlock instanceof HeaderBlock) {\n            Link link = new Link();\n            link.setType(LinkType.DOCUMENT);\n            link.setReference(target);\n            // Clone the header block and remove any unwanted stuff\n            Block clonedHeaderBlock = firstBlock.clone(new BlockFilter()\n            {\n                public List<Block> filter(Block block)\n                {\n                    List<Block> blocks = new ArrayList<Block>();\n                    if (block instanceof WordBlock || block instanceof SpaceBlock\n                        || block instanceof SpecialSymbolBlock) {\n                        blocks.add(block);\n                    }\n                    return blocks;\n                }\n            });\n            return new LinkBlock(clonedHeaderBlock.getChildren(), link, false);\n        } else if (firstBlock instanceof SectionBlock) {\n            return createLink(firstBlock, target);\n        } else {\n            throw new IllegalArgumentException(\n                \"A SectionBlock should either begin with a HeaderBlock or another SectionBlock.\");\n        }\n    }","id":84005,"modified_method":"/**\n     * Creates a {@link LinkBlock} suitable to be placed in the parent document.\n     * \n     * @param block the {@link Block} that has just been split into a separate document.\n     * @param target name of the target wiki document.\n     * @return a {@link LinkBlock} representing the link from the parent document to new document.\n     */\n    private LinkBlock createLink(Block block, String target)\n    {\n        Block firstBlock = block.getChildren().get(0);\n        if (firstBlock instanceof HeaderBlock) {\n            DocumentLink link = new DocumentLink();\n            link.setReference(target);\n            // Clone the header block and remove any unwanted stuff\n            Block clonedHeaderBlock = firstBlock.clone(new BlockFilter()\n            {\n                public List<Block> filter(Block block)\n                {\n                    List<Block> blocks = new ArrayList<Block>();\n                    if (block instanceof WordBlock || block instanceof SpaceBlock\n                        || block instanceof SpecialSymbolBlock) {\n                        blocks.add(block);\n                    }\n                    return blocks;\n                }\n            });\n            return new LinkBlock(clonedHeaderBlock.getChildren(), link, false);\n        } else if (firstBlock instanceof SectionBlock) {\n            return createLink(firstBlock, target);\n        } else {\n            throw new IllegalArgumentException(\n                \"A SectionBlock should either begin with a HeaderBlock or another SectionBlock.\");\n        }\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the anchor name pointing to an anchor defined in the referenced link or null if no anchor has been\n     *         specified (in which case the link points to the top of the page). Note that in XWiki anchors are\n     *         automatically created for titles. Example: \"TableOfContentAnchor\"\n     */\n    public String getAnchor()\n    {\n        return this.anchor;\n    }","id":84006,"modified_method":"/**\n     * @return the anchor name pointing to an anchor defined in the referenced link or null if no anchor has been\n     *         specified (in which case the link points to the top of the page). Note that in XWiki anchors are\n     *         automatically created for titles. Example: \"TableOfContentAnchor\"\n     */\n    public String getAnchor()\n    {\n        return (String) getParameter(ANCHOR);\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param anchor see {@link #getAnchor()}\n     */\n    public void setAnchor(String anchor)\n    {\n        this.anchor = anchor;\n    }","id":84007,"modified_method":"/**\n     * @param anchor see {@link #getAnchor()}\n     */\n    public void setAnchor(String anchor)\n    {\n        setParameter(ANCHOR, anchor);\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the query string for specifying parameters that will be used in the rendered URL or null if no query\n     *         string has been specified. Example: \"mydata1=5&mydata2=Hello\"\n     */\n    public String getQueryString()\n    {\n        return this.queryString;\n    }","id":84008,"modified_method":"/**\n     * @return the query string for specifying parameters that will be used in the rendered URL or null if no query\n     *         string has been specified. Example: \"mydata1=5&mydata2=Hello\"\n     */\n    public String getQueryString()\n    {\n        return (String) getParameter(QUERY_STRING);\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param queryString see {@link #getQueryString()}\n     */\n    public void setQueryString(String queryString)\n    {\n        this.queryString = queryString;\n    }","id":84009,"modified_method":"/**\n     * @param queryString see {@link #getQueryString()}\n     */\n    public void setQueryString(String queryString)\n    {\n        setParameter(QUERY_STRING, queryString);\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the <a href=\"http://en.wikipedia.org/wiki/InterWiki\">Inter Wiki<\/a> alias to which the link is pointing\n     *         to or null if not defined. Mappings between Inter Wiki aliases and actual locations are defined in the\n     *         Inter Wiki Map. Example: \"wikipedia\"\n     */\n    public String getInterWikiAlias()\n    {\n        return this.interWikiAlias;\n    }","id":84010,"modified_method":"/**\n     * @return the <a href=\"http://en.wikipedia.org/wiki/InterWiki\">Inter Wiki<\/a> alias to which the link is pointing\n     *         to or null if not defined. Mappings between Inter Wiki aliases and actual locations are defined in the\n     *         Inter Wiki Map. Example: \"wikipedia\"\n     */\n    public String getInterWikiAlias()\n    {\n        return (String) getParameter(INTERWIKI_ALIAS);\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param interWikiAlias see {@link #getInterWikiAlias()}\n     */\n    public void setInterWikiAlias(String interWikiAlias)\n    {\n        this.interWikiAlias = interWikiAlias;\n    }","id":84011,"modified_method":"/**\n     * @param interWikiAlias see {@link #getInterWikiAlias()}\n     */\n    public void setInterWikiAlias(String interWikiAlias)\n    {\n        setParameter(INTERWIKI_ALIAS, interWikiAlias);\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc} <p> The output is syntax independent since this class is used for all syntaxes. Specific syntaxes\n     * should extend this class and override this method to perform syntax-dependent formatting.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString()\n    {\n        boolean shouldAddSpace = false;\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"Typed = [\").append(isTyped()).append(\"]\");\n        sb.append(\" \");\n        sb.append(\"Type = [\").append(getType().getScheme()).append(\"]\");\n        shouldAddSpace = true;\n        if (getReference() != null) {\n            sb.append(shouldAddSpace ? \" \" : \"\");\n            sb.append(\"Reference = [\").append(getReference()).append(\"]\");\n            shouldAddSpace = true;\n        }\n\n        return sb.toString();\n    }","id":84012,"modified_method":"/**\n     * {@inheritDoc} <p> The output is syntax independent since this class is used for all syntaxes. Specific syntaxes\n     * should extend this class and override this method to perform syntax-dependent formatting.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString()\n    {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"Typed = [\").append(isTyped()).append(\"]\");\n        sb.append(\" \");\n        sb.append(\"Type = [\").append(getType().getScheme()).append(\"]\");\n        if (getReference() != null) {\n            sb.append(\" \");\n            sb.append(\"Reference = [\").append(getReference()).append(\"]\");\n        }\n        Map<String, Object> params = getParameters();\n        if (!params.isEmpty()) {\n            sb.append(\" \");\n            sb.append(\"Parameters = [\");\n            Iterator<Map.Entry<String, Object>> it = params.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry<String, Object> entry = it.next();\n                sb.append(\"[\").append(entry.getKey()).append(\"] = [\").append(entry.getValue()).append(\"]\");\n                if (it.hasNext()) {\n                    sb.append(\", \");\n                }\n            }\n            sb.append(\"]\");\n        }\n\n        return sb.toString();\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testBeginLinkWhenLinkLabelGeneratorIsNull() throws Exception\n    {\n        DefaultWikiPrinter printer = new DefaultWikiPrinter();\n        this.renderer.setPrinter(printer);\n\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(\"anchor\");\n        link.setQueryString(\"param=value\");\n        link.setReference(\"reference\");\n        link.setType(LinkType.DOCUMENT);\n\n        this.renderer.beginLink(link, false, Collections.<String, String> emptyMap());\n        this.renderer.endLink(link, false, Collections.<String, String> emptyMap());\n\n        Assert.assertEquals(\"reference\", printer.toString());\n    }","id":84013,"modified_method":"@Test\n    public void testBeginLinkWhenLinkLabelGeneratorIsNull() throws Exception\n    {\n        DefaultWikiPrinter printer = new DefaultWikiPrinter();\n        this.renderer.setPrinter(printer);\n\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(\"anchor\");\n        link.setQueryString(\"param=value\");\n        link.setReference(\"reference\");\n\n        this.renderer.beginLink(link, false, Collections.<String, String> emptyMap());\n        this.renderer.endLink(link, false, Collections.<String, String> emptyMap());\n\n        Assert.assertEquals(\"reference\", printer.toString());\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Generate the footnote block, a numbered list item containing a backlink to the footnote's reference, and the\n     * actual footnote text, parsed into XDOM.\n     * \n     * @param content the string representation of the actual footnote text; the content of the macro\n     * @param counter the current footnote counter\n     * @param context the macro transformation context, used for obtaining the correct parser for parsing the content\n     * @return the generated footnote block\n     * @throws MacroExecutionException if parsing the content fails\n     */\n    private ListItemBlock createFootnoteBlock(String content, int counter, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        Parser parser = getSyntaxParser(context);\n        List<Block> parsedContent = Collections.emptyList();\n        try {\n            parsedContent = parser.parse(new StringReader(content)).getChildren();\n            if (parsedContent.size() > 0 && parsedContent.get(0) instanceof ParagraphBlock) {\n                Block firstBlock = parsedContent.remove(0);\n                parsedContent.addAll(0, firstBlock.getChildren());\n            }\n        } catch (ParseException e) {\n            parsedContent = Collections.<Block> singletonList(new WordBlock(content));\n        }\n        Block result = new WordBlock(\"^\");\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(FOOTNOTE_REFERENCE_ID_PREFIX + counter);\n        link.setType(LinkType.DOCUMENT);\n        result = new LinkBlock(Collections.singletonList(result), link, false);\n        ((LinkBlock) result).setParameter(ID_ATTRIBUTE_NAME, FOOTNOTE_ID_PREFIX + counter);\n        ((LinkBlock) result).setParameter(CLASS_ATTRIBUTE_NAME, \"footnoteBackRef\");\n        result = new ListItemBlock(Collections.singletonList(result));\n        result.addChild(SpaceBlock.SPACE_BLOCK);\n        result.addChildren(parsedContent);\n        ((ListItemBlock) result).setParameter(CLASS_ATTRIBUTE_NAME, FootnoteMacro.MACRO_NAME);\n        return (ListItemBlock) result;\n    }","id":84014,"modified_method":"/**\n     * Generate the footnote block, a numbered list item containing a backlink to the footnote's reference, and the\n     * actual footnote text, parsed into XDOM.\n     * \n     * @param content the string representation of the actual footnote text; the content of the macro\n     * @param counter the current footnote counter\n     * @param context the macro transformation context, used for obtaining the correct parser for parsing the content\n     * @return the generated footnote block\n     * @throws MacroExecutionException if parsing the content fails\n     */\n    private ListItemBlock createFootnoteBlock(String content, int counter, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        Parser parser = getSyntaxParser(context);\n        List<Block> parsedContent = Collections.emptyList();\n        try {\n            parsedContent = parser.parse(new StringReader(content)).getChildren();\n            if (parsedContent.size() > 0 && parsedContent.get(0) instanceof ParagraphBlock) {\n                Block firstBlock = parsedContent.remove(0);\n                parsedContent.addAll(0, firstBlock.getChildren());\n            }\n        } catch (ParseException e) {\n            parsedContent = Collections.<Block> singletonList(new WordBlock(content));\n        }\n        Block result = new WordBlock(\"^\");\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(FOOTNOTE_REFERENCE_ID_PREFIX + counter);\n        result = new LinkBlock(Collections.singletonList(result), link, false);\n        ((LinkBlock) result).setParameter(ID_ATTRIBUTE_NAME, FOOTNOTE_ID_PREFIX + counter);\n        ((LinkBlock) result).setParameter(CLASS_ATTRIBUTE_NAME, \"footnoteBackRef\");\n        result = new ListItemBlock(Collections.singletonList(result));\n        result.addChild(SpaceBlock.SPACE_BLOCK);\n        result.addChildren(parsedContent);\n        ((ListItemBlock) result).setParameter(CLASS_ATTRIBUTE_NAME, FootnoteMacro.MACRO_NAME);\n        return (ListItemBlock) result;\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Generate the footnote reference (link) that should be inserted at the location of the macro, and should point to\n     * the actual footnote at the end of the document.\n     * \n     * @param counter the current footnote counter\n     * @return the generated reference element, displayed as {@code (superscript(link(footnote index)))}\n     */\n    private Block createFootnoteReferenceBlock(int counter)\n    {\n        Block result = new WordBlock(counter + \"\");\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(FOOTNOTE_ID_PREFIX + counter);\n        link.setType(LinkType.DOCUMENT);\n        result = new LinkBlock(Collections.singletonList(result), link, false);\n        result = new FormatBlock(Collections.singletonList(result), Format.SUPERSCRIPT);\n        ((FormatBlock) result).setParameter(ID_ATTRIBUTE_NAME, FOOTNOTE_REFERENCE_ID_PREFIX + counter);\n        ((FormatBlock) result).setParameter(CLASS_ATTRIBUTE_NAME, \"footnoteRef\");\n        return result;\n    }","id":84015,"modified_method":"/**\n     * Generate the footnote reference (link) that should be inserted at the location of the macro, and should point to\n     * the actual footnote at the end of the document.\n     * \n     * @param counter the current footnote counter\n     * @return the generated reference element, displayed as {@code (superscript(link(footnote index)))}\n     */\n    private Block createFootnoteReferenceBlock(int counter)\n    {\n        Block result = new WordBlock(counter + \"\");\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(FOOTNOTE_ID_PREFIX + counter);\n        result = new LinkBlock(Collections.singletonList(result), link, false);\n        result = new FormatBlock(Collections.singletonList(result), Format.SUPERSCRIPT);\n        ((FormatBlock) result).setParameter(ID_ATTRIBUTE_NAME, FOOTNOTE_REFERENCE_ID_PREFIX + counter);\n        ((FormatBlock) result).setParameter(CLASS_ATTRIBUTE_NAME, \"footnoteRef\");\n        return result;\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create a new toc list item based on section title.\n     * \n     * @param headerBlock the {@link HeaderBlock}.\n     * @return the new list item block.\n     */\n    private ListItemBlock createTocEntry(HeaderBlock headerBlock)\n    {\n        // Create the link to target the header anchor\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(headerBlock.getId());\n        link.setType(LinkType.DOCUMENT);\n        LinkBlock linkBlock = new LinkBlock(this.tocBlockFilter.generateLabel(headerBlock), link, false);\n\n        return new ListItemBlock(Collections.<Block> singletonList(linkBlock));\n    }","id":84016,"modified_method":"/**\n     * Create a new toc list item based on section title.\n     * \n     * @param headerBlock the {@link HeaderBlock}.\n     * @return the new list item block.\n     */\n    private ListItemBlock createTocEntry(HeaderBlock headerBlock)\n    {\n        // Create the link to target the header anchor\n        DocumentLink link = new DocumentLink();\n        link.setAnchor(headerBlock.getId());\n        LinkBlock linkBlock = new LinkBlock(this.tocBlockFilter.generateLabel(headerBlock), link, false);\n\n        return new ListItemBlock(Collections.<Block> singletonList(linkBlock));\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Check if the passed link references is an interwiki link reference.\n     *\n     * @param content the original content to parse\n     * @return the parsed Link object or null if the passed reference is not an interwiki link reference\n     */\n    private Link parseInterWikiLinks(StringBuffer content)\n    {\n        Link result = null;\n        String interWikiAlias = parseElementAfterString(content, SEPARATOR_INTERWIKI);\n        if (interWikiAlias != null) {\n            InterWikiLink link = new InterWikiLink();\n            link.setType(LinkType.INTERWIKI);\n            link.setTyped(true);\n            link.setInterWikiAlias(removeEscapes(interWikiAlias));\n            link.setReference(removeEscapes(content.toString()));\n            result = link;\n        }\n        return result;\n    }","id":84017,"modified_method":"/**\n     * Check if the passed link references is an interwiki link reference.\n     *\n     * @param content the original content to parse\n     * @return the parsed Link object or null if the passed reference is not an interwiki link reference\n     */\n    private Link parseInterWikiLinks(StringBuffer content)\n    {\n        Link result = null;\n        String interWikiAlias = parseElementAfterString(content, SEPARATOR_INTERWIKI);\n        if (interWikiAlias != null) {\n            InterWikiLink link = new InterWikiLink();\n            link.setInterWikiAlias(removeEscapes(interWikiAlias));\n            link.setReference(removeEscapes(content.toString()));\n            result = link;\n        }\n        return result;\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Construct a Document Link reference out of the passed content.\n     *\n     * @param content the string containing the Document link reference\n     * @return the parsed Link Object corresponding to the Document link reference\n     */\n    private Link parseDocumentLink(StringBuffer content)\n    {\n        DocumentLink documentLink = new DocumentLink();\n        documentLink.setType(LinkType.DOCUMENT);\n        documentLink.setQueryString(removeEscapesFromExtraParts(\n            parseElementAfterString(content, LinkParser.SEPARATOR_QUERYSTRING)));\n        documentLink.setAnchor(removeEscapesFromExtraParts(parseElementAfterString(content,\n            LinkParser.SEPARATOR_ANCHOR)));\n        documentLink.setReference(removeEscapesFromReferencePart(content.toString()));\n        return documentLink;\n    }","id":84018,"modified_method":"/**\n     * Construct a Document Link reference out of the passed content.\n     *\n     * @param content the string containing the Document link reference\n     * @return the parsed Link Object corresponding to the Document link reference\n     */\n    private Link parseDocumentLink(StringBuffer content)\n    {\n        DocumentLink documentLink = new DocumentLink();\n\n        String text = parseElementAfterString(content, LinkParser.SEPARATOR_QUERYSTRING);\n        if (text != null) {\n            documentLink.setQueryString(removeEscapesFromExtraParts(text));\n        }\n\n        text = parseElementAfterString(content, LinkParser.SEPARATOR_ANCHOR);\n        if (text != null) {\n            documentLink.setAnchor(removeEscapesFromExtraParts(text));\n        }\n\n        documentLink.setReference(removeEscapesFromReferencePart(content.toString()));\n        return documentLink;\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testParseLinksWhenInWikiMode() throws Exception\n    {\n        // Test Query Strings in links to document\n        Link link = parser.parse(\"Hello World?xredirect=../whatever\");\n        Assert.assertEquals(\"Hello World\", link.getReference());\n        Assert.assertEquals(\"xredirect=../whatever\", ((DocumentLink) link).getQueryString());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [Hello World] QueryString = [xredirect=../whatever]\", link.toString());\n\n        link = parser.parse(\"HelloWorld?xredirect=http://xwiki.org\");\n        Assert.assertEquals(\"HelloWorld\", link.getReference());\n        Assert.assertEquals(\"xredirect=http://xwiki.org\", ((DocumentLink) link).getQueryString());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [HelloWorld] QueryString = [xredirect=http://xwiki.org]\", link.toString());\n\n        // Test Anchors in links to documents\n        link = parser.parse(\"#anchor\");\n        Assert.assertEquals(\"anchor\", ((DocumentLink) link).getAnchor());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [] Anchor = [anchor]\", link.toString());\n\n        link = parser.parse(\"Hello#anchor\");\n        Assert.assertEquals(\"Hello\", link.getReference());\n        Assert.assertEquals(\"anchor\", ((DocumentLink) link).getAnchor());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [Hello] Anchor = [anchor]\", link.toString());\n\n        // Test InterWiki links\n        link = parser.parse(\"HelloWorld#anchor?param1=1&param2=2@wikipedia\");\n        Assert.assertEquals(\"HelloWorld#anchor?param1=1&param2=2\", link.getReference());\n        Assert.assertEquals(\"wikipedia\", ((InterWikiLink) link).getInterWikiAlias());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(LinkType.INTERWIKI, link.getType());\n        Assert.assertEquals(\"Typed = [true] Type = [interwiki] Reference = [HelloWorld#anchor?param1=1&param2=2] \"\n            + \"InterWikiAlias = [wikipedia]\", link.toString());\n\n        // Verify in XWiki Syntax 2.0 the \"doc\" prefix is not meaningful\n        link = parser.parse(\"doc:whatever\");\n        Assert.assertEquals(\"doc:whatever\", link.getReference());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [doc:whatever]\", link.toString());\n    }","id":84019,"modified_method":"@Test\n    public void testParseLinksWhenInWikiMode() throws Exception\n    {\n        // Test Query Strings in links to document\n        Link link = parser.parse(\"Hello World?xredirect=../whatever\");\n        Assert.assertEquals(\"Hello World\", link.getReference());\n        Assert.assertEquals(\"xredirect=../whatever\", ((DocumentLink) link).getQueryString());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [Hello World] \"\n            + \"Parameters = [[queryString] = [xredirect=../whatever]]\", link.toString());\n\n        link = parser.parse(\"HelloWorld?xredirect=http://xwiki.org\");\n        Assert.assertEquals(\"HelloWorld\", link.getReference());\n        Assert.assertEquals(\"xredirect=http://xwiki.org\", ((DocumentLink) link).getQueryString());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [HelloWorld] \"\n            + \"Parameters = [[queryString] = [xredirect=http://xwiki.org]]\", link.toString());\n\n        // Test Anchors in links to documents\n        link = parser.parse(\"#anchor\");\n        Assert.assertEquals(\"anchor\", ((DocumentLink) link).getAnchor());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [] Parameters = [[anchor] = [anchor]]\",\n            link.toString());\n\n        link = parser.parse(\"Hello#anchor\");\n        Assert.assertEquals(\"Hello\", link.getReference());\n        Assert.assertEquals(\"anchor\", ((DocumentLink) link).getAnchor());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [Hello] Parameters = [[anchor] = [anchor]]\",\n            link.toString());\n\n        // Test InterWiki links\n        link = parser.parse(\"HelloWorld#anchor?param1=1&param2=2@wikipedia\");\n        Assert.assertEquals(\"HelloWorld#anchor?param1=1&param2=2\", link.getReference());\n        Assert.assertEquals(\"wikipedia\", ((InterWikiLink) link).getInterWikiAlias());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(LinkType.INTERWIKI, link.getType());\n        Assert.assertEquals(\"Typed = [true] Type = [interwiki] Reference = [HelloWorld#anchor?param1=1&param2=2] \"\n            + \"Parameters = [[interWikiAlias] = [wikipedia]]\", link.toString());\n\n        // Verify in XWiki Syntax 2.0 the \"doc\" prefix is not meaningful\n        link = parser.parse(\"doc:whatever\");\n        Assert.assertEquals(\"doc:whatever\", link.getReference());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [doc:whatever]\", link.toString());\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testParseLinks() throws Exception\n    {\n        Link link = parser.parse(\"doc:wiki:space.page\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"wiki:space.page\", link.getReference());\n        Assert.assertEquals(\"Typed = [true] Type = [doc] Reference = [wiki:space.page]\", link.toString());\n        Assert.assertTrue(link.isTyped());\n\n        // Verify InterWiki links work\n        link = parser.parse(\"interwiki:alias:content\");\n        Assert.assertEquals(LinkType.INTERWIKI, link.getType());\n        Assert.assertEquals(\"content\", link.getReference());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(\"alias\", ((InterWikiLink) link).getInterWikiAlias());\n        Assert.assertEquals(\"Typed = [true] Type = [interwiki] Reference = [content] InterWikiAlias = [alias]\",\n            link.toString());\n\n        // Verify that an invalid InterWiki link is considered as Document link\n        link = parser.parse(\"interwiki:invalid_since_doesnt_have_colon\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"interwiki:invalid_since_doesnt_have_colon\", link.getReference());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [interwiki:invalid_since_doesnt_have_colon]\",\n            link.toString());\n\n        // Verify typed URLs\n        link = parser.parse(\"url:http://xwiki.org\");\n        Assert.assertEquals(LinkType.URL, link.getType());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(\"http://xwiki.org\", link.getReference());\n        Assert.assertEquals(\"Typed = [true] Type = [url] Reference = [http://xwiki.org]\", link.toString());\n\n        // Verify query string and anchors have no meaning in link reference to documents.\n        link = parser.parse(\"Hello World?no=queryString#notAnAnchor\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Hello World?no=queryString#notAnAnchor\", link.getReference());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertNull(((DocumentLink) link).getAnchor());\n        Assert.assertNull(((DocumentLink) link).getQueryString());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [Hello World?no=queryString#notAnAnchor]\",\n                link.toString());\n\n        // Verify that the interwiki separator from XWiki Syntax 2.0 has not meaning in link references to documents\n        link = parser.parse(\"page@alias\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(\"page@alias\", link.getReference());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [page@alias]\", link.toString());\n\n        // Verify path link types\n        link = parser.parse(\"path:/some/path\");\n        Assert.assertEquals(LinkType.PATH, link.getType());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(\"/some/path\", link.getReference());\n        Assert.assertEquals(\"Typed = [true] Type = [path] Reference = [/some/path]\", link.toString());\n    }","id":84020,"modified_method":"@Test\n    public void testParseLinks() throws Exception\n    {\n        Link link = parser.parse(\"doc:wiki:space.page\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"wiki:space.page\", link.getReference());\n        Assert.assertEquals(\"Typed = [true] Type = [doc] Reference = [wiki:space.page]\", link.toString());\n        Assert.assertTrue(link.isTyped());\n\n        // Verify InterWiki links work\n        link = parser.parse(\"interwiki:alias:content\");\n        Assert.assertEquals(LinkType.INTERWIKI, link.getType());\n        Assert.assertEquals(\"content\", link.getReference());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(\"alias\", ((InterWikiLink) link).getInterWikiAlias());\n        Assert.assertEquals(\"Typed = [true] Type = [interwiki] Reference = [content] \"\n            + \"Parameters = [[interWikiAlias] = [alias]]\", link.toString());\n\n        // Verify that an invalid InterWiki link is considered as Document link\n        link = parser.parse(\"interwiki:invalid_since_doesnt_have_colon\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"interwiki:invalid_since_doesnt_have_colon\", link.getReference());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [interwiki:invalid_since_doesnt_have_colon]\",\n            link.toString());\n\n        // Verify typed URLs\n        link = parser.parse(\"url:http://xwiki.org\");\n        Assert.assertEquals(LinkType.URL, link.getType());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(\"http://xwiki.org\", link.getReference());\n        Assert.assertEquals(\"Typed = [true] Type = [url] Reference = [http://xwiki.org]\", link.toString());\n\n        // Verify query string and anchors have no meaning in link reference to documents.\n        link = parser.parse(\"Hello World?no=queryString#notAnAnchor\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertEquals(\"Hello World?no=queryString#notAnAnchor\", link.getReference());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertNull(((DocumentLink) link).getAnchor());\n        Assert.assertNull(((DocumentLink) link).getQueryString());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [Hello World?no=queryString#notAnAnchor]\",\n                link.toString());\n\n        // Verify that the interwiki separator from XWiki Syntax 2.0 has not meaning in link references to documents\n        link = parser.parse(\"page@alias\");\n        Assert.assertEquals(LinkType.DOCUMENT, link.getType());\n        Assert.assertFalse(link.isTyped());\n        Assert.assertEquals(\"page@alias\", link.getReference());\n        Assert.assertEquals(\"Typed = [false] Type = [doc] Reference = [page@alias]\", link.toString());\n\n        // Verify path link types\n        link = parser.parse(\"path:/some/path\");\n        Assert.assertEquals(LinkType.PATH, link.getType());\n        Assert.assertTrue(link.isTyped());\n        Assert.assertEquals(\"/some/path\", link.getReference());\n        Assert.assertEquals(\"Typed = [true] Type = [path] Reference = [/some/path]\", link.toString());\n    }","commit_id":"bdebcd81cf6e4298baff920e1886e877c654a0b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getInterWikiAlias()\n    {\n        return this.interWikiAlias;\n    }","id":84021,"modified_method":"/**\n     * @return the <a href=\"http://en.wikipedia.org/wiki/InterWiki\">Inter Wiki<\/a> alias to which\n     *         the link is pointing to or null if not defined. Mappings between Inter Wiki aliases\n     *         and actual locations are defined in the Inter Wiki Map. Example: \"wikipedia\"\n     */\n    public String getInterWikiAlias()\n    {\n        return this.interWikiAlias;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setInterWikiAlias(String interWikiAlias)\n    {\n        this.interWikiAlias = interWikiAlias;\n    }","id":84022,"modified_method":"/**\n     * @param interWikiAlias see {@link #getInterWikiAlias()}\n     */\n    public void setInterWikiAlias(String interWikiAlias)\n    {\n        this.interWikiAlias = interWikiAlias;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getAnchor()\n    {\n        return this.anchor;\n    }","id":84023,"modified_method":"/**\n     * @return the anchor name pointing to an anchor defined in the referenced link or null if no\n     *         anchor has been specified (in which case the link points to the top of the page).\n     *         Note that in XWiki anchors are automatically created for titles.\n     *         Example: \"TableOfContentAnchor\"\n     */\n    public String getAnchor()\n    {\n        return this.anchor;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getLabel()\n    {\n        return this.label;\n    }","id":84024,"modified_method":"/**\n     * @return the string which will be displayed to the user when the link is rendered or null\n     *         if no label has been specified (in that case the page name or the URI will be\n     *         displayed. Example: \"My Page\"\n     */\n    public String getLabel()\n    {\n        return this.label;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getTarget()\n    {\n        return this.target;\n    }","id":84025,"modified_method":"/**\n     * @return the browser window in which the link should be opened into or null if not defined.\n     *         This element corresponds to the HTML <code>target<\/code> attribute for the\n     *         <code>a<\/code> element. It is used when rendering the link and defauts to opening\n     *         the link in the current page. Example: \"_self\", \"_blank\".\n     */\n    public String getTarget()\n    {\n        return this.target;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getQueryString()\n    {\n        return this.queryString;\n    }","id":84026,"modified_method":"/**\n     * @return the query string for specifying parameters that will be used in the rendered URL or\n     *         null if no query string has been specified. Example: \"mydata1=5&mydata2=Hello\"\n     */\n    public String getQueryString()\n    {\n        return this.queryString;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setQueryString(String queryString)\n    {\n        this.queryString = queryString;\n    }","id":84027,"modified_method":"/**\n     * @param queryString see {@link #getQueryString()}\n     */\n    public void setQueryString(String queryString)\n    {\n        this.queryString = queryString;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setLabel(String label)\n    {\n        this.label = label;\n    }","id":84028,"modified_method":"/**\n     * @param label see {@link #getLabel()}\n     */\n    public void setLabel(String label)\n    {\n        this.label = label;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * The output is syntax independent since this class is used for all syntaxes. Specific\n     * syntaxes should extend this class and override this method to perform syntax-dependent\n     * formatting.\n     */\n    public String toString()\n    {\n        boolean shouldAddSpace = false;\n        StringBuffer sb = new StringBuffer();\n        if (getLabel() != null) {\n            sb.append(\"Label = [\").append(getLabel()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getDocumentNameOrUri() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"DocumentNameOrUri = [\").append(getDocumentNameOrUri()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getQueryString() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"QueryString = [\").append(getQueryString()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getAnchor() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"Anchor = [\").append(getAnchor()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getInterWikiAlias() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"InterWikiAlias = [\").append(getInterWikiAlias()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getTarget() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"Target = [\").append(getTarget()).append(\"]\");\n        }\n\n        return sb.toString();\n    }","id":84029,"modified_method":"/**\n     * The output is syntax independent since this class is used for all syntaxes. Specific\n     * syntaxes should extend this class and override this method to perform syntax-dependent\n     * formatting.\n     */\n    public String toString()\n    {\n        boolean shouldAddSpace = false;\n        StringBuffer sb = new StringBuffer();\n        if (getLabel() != null) {\n            sb.append(\"Label = [\").append(getLabel()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getReference() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"Reference = [\").append(getReference()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getQueryString() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"QueryString = [\").append(getQueryString()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getAnchor() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"Anchor = [\").append(getAnchor()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getInterWikiAlias() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"InterWikiAlias = [\").append(getInterWikiAlias()).append(\"]\");\n            shouldAddSpace = true;\n        }\n        if (getTarget() != null) {\n            sb.append(shouldAddSpace ? \" \": \"\");\n            sb.append(\"Target = [\").append(getTarget()).append(\"]\");\n        }\n\n        return sb.toString();\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setAnchor(String anchor)\n    {\n        this.anchor = anchor;\n    }","id":84030,"modified_method":"/**\n     * @param anchor see {@link #getAnchor()}\n     */\n    public void setAnchor(String anchor)\n    {\n        this.anchor = anchor;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setTarget(String target)\n    {\n        this.target = target;\n    }","id":84031,"modified_method":"/**\n     * @param target see {@link #getTarget()}\n     */\n    public void setTarget(String target)\n    {\n        this.target = target;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Link parse(String rawLink) throws ParseException\n    {\n        StringBuffer content = new StringBuffer(rawLink.trim());\n\n        Link link = new Link();\n\n        // Note: It's important to parse the label and the target in that order. See\n        // {@link #parseLabel} for more details as to why.\n        link.setLabel(parseLabel(content));\n        link.setTarget(parseTarget(content));\n\n        // Parse the link reference itself.\n        String uri = parseURI(content);\n        if (uri != null) {\n            link.setDocumentNameOrUri(uri);\n            link.setContainsDocumentName(false);\n        } else {\n            // Note: the order here is also very important.\n            // We parse the query string early as it can contain our special delimiter characters\n            // (like \".\"). Note: This means that \"@\" characters are forbidden in the query string...\n            link.setInterWikiAlias(parseElementAfterString(content, \"@\"));\n            link.setQueryString(parseElementAfterString(content, \"?\"));\n        }\n\n        link.setAnchor(parseElementAfterString(content, \"#\"));\n\n        // What remains in the content buffer is the page name if any. If the content is empty then\n        // it means no page was specified. This is allowed and in that case when the link is\n        // rendered it'll be pointing to WebHome.\n        if (content.length() > 0) {\n\n            // TODO: Check for invalid characters in a page\n\n            link.setDocumentNameOrUri(content.toString());\n            link.setContainsDocumentName(true);\n        }\n\n        return link;\n    }","id":84032,"modified_method":"public Link parse(String rawLink) throws ParseException\n    {\n        StringBuffer content = new StringBuffer(rawLink.trim());\n\n        Link link = new Link();\n\n        // Let's default the link to be a document link. If instead it's a link to a URI or to\n        // an interwiki location it'll be overriden.\n        link.setType(LinkType.DOCUMENT);\n\n        // Note: It's important to parse the label and the target in that order. See\n        // {@link #parseLabel} for more details as to why.\n        link.setLabel(parseLabel(content));\n        link.setTarget(parseTarget(content));\n\n        // Parse the link reference itself.\n        String uri = parseURI(content);\n        if (uri != null) {\n            link.setReference(uri);\n            link.setType(LinkType.URI);\n        } else {\n            // Note: the order here is also very important.\n            // We parse the query string early as it can contain our special delimiter characters\n            // (like \".\"). Note: This means that \"@\" characters are forbidden in the query string...\n\n            String interwikiAlias = parseElementAfterString(content, \"@\");\n            if (interwikiAlias != null) {\n                link.setInterWikiAlias(interwikiAlias);\n                link.setType(LinkType.INTERWIKI);\n            }\n\n            link.setQueryString(parseElementAfterString(content, \"?\"));\n        }\n\n        link.setAnchor(parseElementAfterString(content, \"#\"));\n\n        // What remains in the content buffer is the page name or the interwiki reference if any.\n        // If the content is empty then it means no page was specified. This is allowed and in that\n        // case when the link is rendered it'll be pointing to WebHome.\n\n        // TODO: Check for invalid characters in a page\n\n        if (link.getReference() == null) {\n            link.setReference(content.toString());\n        } else if (content.length() > 0) {\n            throw new ParseException(\"Invalid link format [\" + rawLink + \"]\");\n        }\n\n        return link;\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testParseLinkWhenValidLabelSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"label|reference\");\n\n        assertEquals(\"label\", link.getLabel());\n        assertEquals(\"reference\", link.getDocumentNameOrUri());\n        assertTrue(link.isDocumentName());\n        assertEquals(\"Label = [label] DocumentNameOrUri = [reference]\", link.toString());\n\n        link = parser.parse(\"label>reference\");\n\n        assertEquals(\"label\", link.getLabel());\n        assertEquals(\"reference\", link.getDocumentNameOrUri());\n        assertTrue(link.isDocumentName());\n        assertEquals(\"Label = [label] DocumentNameOrUri = [reference]\", link.toString());\n    }","id":84033,"modified_method":"public void testParseLinkWhenValidLabelSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"label|reference\");\n\n        assertEquals(\"label\", link.getLabel());\n        assertEquals(\"reference\", link.getReference());\n        assertEquals(LinkType.DOCUMENT, link.getType());\n        assertEquals(\"Label = [label] Reference = [reference]\", link.toString());\n\n        link = parser.parse(\"label>reference\");\n\n        assertEquals(\"label\", link.getLabel());\n        assertEquals(\"reference\", link.getReference());\n        assertEquals(LinkType.DOCUMENT, link.getType());\n        assertEquals(\"Label = [label] Reference = [reference]\", link.toString());\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testParseLinkVariations() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n\n        Link link = parser.parse(\"\");\n        assertNull(link.getLabel());\n        assertNull(link.getDocumentNameOrUri());\n        assertEquals(\"\", link.toString());\n\n        link = parser.parse(\"Hello World\");\n        assertNull(link.getLabel());\n        assertEquals(\"Hello World\", link.getDocumentNameOrUri());\n        assertEquals(\"DocumentNameOrUri = [Hello World]\", link.toString());\n\n        link = parser.parse(\"Hello World>HelloWorld\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"HelloWorld\", link.getDocumentNameOrUri());\n        assertEquals(\"Label = [Hello World] DocumentNameOrUri = [HelloWorld]\", link.toString());\n\n        link = parser.parse(\"Hello World>HelloWorld>_target\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"HelloWorld\", link.getDocumentNameOrUri());\n        assertEquals(\"_target\", link.getTarget());\n        assertEquals(\"Label = [Hello World] DocumentNameOrUri = [HelloWorld] Target = [_target]\",\n            link.toString());\n\n        link = parser.parse(\"HelloWorld#anchor?param1=1&param2=2@wikipedia\");\n        assertEquals(\"HelloWorld\", link.getDocumentNameOrUri());\n        assertEquals(\"anchor\", link.getAnchor());\n        assertEquals(\"param1=1&param2=2\", link.getQueryString());\n        assertEquals(\"wikipedia\", link.getInterWikiAlias());\n        assertEquals(\"DocumentNameOrUri = [HelloWorld] QueryString = [param1=1&param2=2] \"\n            + \"Anchor = [anchor] InterWikiAlias = [wikipedia]\", link.toString());\n\n        link = parser.parse(\"Hello World?xredirect=../whatever\");\n        assertEquals(\"Hello World\", link.getDocumentNameOrUri());\n        assertEquals(\"xredirect=../whatever\", link.getQueryString());\n        assertEquals(\"DocumentNameOrUri = [Hello World] QueryString = [xredirect=../whatever]\",\n            link.toString());\n\n        link = parser.parse(\"Hello World>http://xwiki.org\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"http://xwiki.org\", link.getDocumentNameOrUri());\n        assertEquals(\"Label = [Hello World] DocumentNameOrUri = [http://xwiki.org]\",\n            link.toString());\n\n        // We consider that myxwiki is the wiki name and http://xwiki.org is the page name\n        link = parser.parse(\"mywiki:http://xwiki.org\");\n        assertEquals(\"mywiki:http://xwiki.org\", link.getDocumentNameOrUri());\n        assertEquals(\"DocumentNameOrUri = [mywiki:http://xwiki.org]\", link.toString());\n\n        link = parser.parse(\"Hello World>HelloWorld?xredirect=http://xwiki.org\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"HelloWorld\", link.getDocumentNameOrUri());\n        assertEquals(\"xredirect=http://xwiki.org\", link.getQueryString());\n        assertEquals(\"Label = [Hello World] DocumentNameOrUri = [HelloWorld] \"\n            + \"QueryString = [xredirect=http://xwiki.org]\", link.toString());\n\n        link = parser.parse(\"http://xwiki.org\");\n        assertEquals(\"http://xwiki.org\", link.getDocumentNameOrUri());\n        assertFalse(link.isDocumentName());\n        assertEquals(\"DocumentNameOrUri = [http://xwiki.org]\", link.toString());\n\n        link = parser.parse(\"#anchor\");\n        assertEquals(\"anchor\", link.getAnchor());\n        assertEquals(\"Anchor = [anchor]\", link.toString());\n\n        link = parser.parse(\"Hello#anchor\");\n        assertEquals(\"Hello\", link.getDocumentNameOrUri());\n        assertEquals(\"anchor\", link.getAnchor());\n        assertEquals(\"DocumentNameOrUri = [Hello] Anchor = [anchor]\", link.toString());\n    }","id":84034,"modified_method":"public void testParseLinkVariations() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n\n        Link link = parser.parse(\"\");\n        assertNull(link.getLabel());\n        assertEquals(\"\", link.getReference());\n        assertEquals(\"Reference = []\", link.toString());\n\n        link = parser.parse(\"Hello World\");\n        assertNull(link.getLabel());\n        assertEquals(\"Hello World\", link.getReference());\n        assertEquals(\"Reference = [Hello World]\", link.toString());\n\n        link = parser.parse(\"Hello World>HelloWorld\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"HelloWorld\", link.getReference());\n        assertEquals(\"Label = [Hello World] Reference = [HelloWorld]\", link.toString());\n\n        link = parser.parse(\"Hello World>HelloWorld>_target\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"HelloWorld\", link.getReference());\n        assertEquals(\"_target\", link.getTarget());\n        assertEquals(\"Label = [Hello World] Reference = [HelloWorld] Target = [_target]\",\n            link.toString());\n\n        link = parser.parse(\"HelloWorld#anchor?param1=1&param2=2@wikipedia\");\n        assertEquals(\"HelloWorld\", link.getReference());\n        assertEquals(\"anchor\", link.getAnchor());\n        assertEquals(\"param1=1&param2=2\", link.getQueryString());\n        assertEquals(\"wikipedia\", link.getInterWikiAlias());\n        assertEquals(\"Reference = [HelloWorld] QueryString = [param1=1&param2=2] \"\n            + \"Anchor = [anchor] InterWikiAlias = [wikipedia]\", link.toString());\n\n        link = parser.parse(\"Hello World?xredirect=../whatever\");\n        assertEquals(\"Hello World\", link.getReference());\n        assertEquals(\"xredirect=../whatever\", link.getQueryString());\n        assertEquals(\"Reference = [Hello World] QueryString = [xredirect=../whatever]\",\n            link.toString());\n\n        link = parser.parse(\"Hello World>http://xwiki.org\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"http://xwiki.org\", link.getReference());\n        assertEquals(\"Label = [Hello World] Reference = [http://xwiki.org]\",\n            link.toString());\n\n        // We consider that myxwiki is the wiki name and http://xwiki.org is the page name\n        link = parser.parse(\"mywiki:http://xwiki.org\");\n        assertEquals(\"mywiki:http://xwiki.org\", link.getReference());\n        assertEquals(\"Reference = [mywiki:http://xwiki.org]\", link.toString());\n\n        link = parser.parse(\"Hello World>HelloWorld?xredirect=http://xwiki.org\");\n        assertEquals(\"Hello World\", link.getLabel());\n        assertEquals(\"HelloWorld\", link.getReference());\n        assertEquals(\"xredirect=http://xwiki.org\", link.getQueryString());\n        assertEquals(\"Label = [Hello World] Reference = [HelloWorld] \"\n            + \"QueryString = [xredirect=http://xwiki.org]\", link.toString());\n\n        link = parser.parse(\"http://xwiki.org\");\n        assertEquals(\"http://xwiki.org\", link.getReference());\n        assertEquals(LinkType.URI, link.getType());\n        assertEquals(\"Reference = [http://xwiki.org]\", link.toString());\n\n        link = parser.parse(\"#anchor\");\n        assertEquals(\"anchor\", link.getAnchor());\n        assertEquals(\"Reference = [] Anchor = [anchor]\", link.toString());\n\n        link = parser.parse(\"Hello#anchor\");\n        assertEquals(\"Hello\", link.getReference());\n        assertEquals(\"anchor\", link.getAnchor());\n        assertEquals(\"Reference = [Hello] Anchor = [anchor]\", link.toString());\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testParseLinkWhenOnlyReferenceIsSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"reference\");\n\n        assertNull(link.getLabel());\n        assertEquals(\"reference\", link.getDocumentNameOrUri());\n        assertTrue(link.isDocumentName());\n        assertEquals(\"DocumentNameOrUri = [reference]\", link.toString());\n    }","id":84035,"modified_method":"public void testParseLinkWhenOnlyReferenceIsSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"reference\");\n\n        assertNull(link.getLabel());\n        assertEquals(\"reference\", link.getReference());\n        assertEquals(LinkType.DOCUMENT, link.getType());\n        assertEquals(\"Reference = [reference]\", link.toString());\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testParseLinkWhenTargetSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"reference|_target\");\n\n        assertNull(link.getLabel());\n        assertEquals(\"_target\", link.getTarget());\n        assertEquals(\"DocumentNameOrUri = [reference] Target = [_target]\", link.toString());\n\n        link = parser.parse(\"reference>_target\");\n\n        assertNull(link.getLabel());\n        assertEquals(\"_target\", link.getTarget());\n        assertEquals(\"DocumentNameOrUri = [reference] Target = [_target]\", link.toString());\n    }","id":84036,"modified_method":"public void testParseLinkWhenTargetSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"reference|_target\");\n\n        assertNull(link.getLabel());\n        assertEquals(\"_target\", link.getTarget());\n        assertEquals(\"Reference = [reference] Target = [_target]\", link.toString());\n\n        link = parser.parse(\"reference>_target\");\n\n        assertNull(link.getLabel());\n        assertEquals(\"_target\", link.getTarget());\n        assertEquals(\"Reference = [reference] Target = [_target]\", link.toString());\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testParseLinkWhenMailUriSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"mailto:john@smith.com\");\n\n        assertEquals(\"mailto:john@smith.com\", link.getDocumentNameOrUri());\n        assertFalse(link.isDocumentName());\n        assertEquals(\"DocumentNameOrUri = [mailto:john@smith.com]\", link.toString());\n    }","id":84037,"modified_method":"public void testParseLinkWhenMailUriSpecified() throws Exception\n    {\n        LinkParser parser = new XWikiLinkParser();\n        Link link = parser.parse(\"mailto:john@smith.com\");\n\n        assertEquals(\"mailto:john@smith.com\", link.getReference());\n        assertEquals(LinkType.URI, link.getType());\n        assertEquals(\"Reference = [mailto:john@smith.com]\", link.toString());\n    }","commit_id":"e7c299d7f075bd61035b8bcdd3ab7a88e91fb20f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Used to create a fake failure, when Hudson fails to load data from XML files.\n     */\n    CaseResult(SuiteResult parent, String testName, String errorStackTrace) {\n        this( parent, (parent==null? \"unnamed\" : parent.getName()), testName, errorStackTrace, \"\", null, null, 0.0f, false );\n    }","id":84038,"modified_method":"/**\n     * Used to create a fake failure, when Hudson fails to load data from XML files.\n     */\n    CaseResult(SuiteResult parent, String testName, String errorStackTrace) {\n        this.className = parent == null ? \"unnamed\" : parent.getName();\n        this.testName = testName;\n        this.errorStackTrace = errorStackTrace;\n        this.errorDetails = \"\";\n        this.parent = parent;\n        this.stdout = null;\n        this.stderr = null;\n        this.duration = 0.0f;\n        this.skipped = false;\n    }","commit_id":"f4cc4245da8946caaf64f33865c1f5d07f14187e","url":"https://github.com/kohsuke/hudson"},{"original_method":"CaseResult(SuiteResult parent, Element testCase, String testClassName) {\n        // schema for JUnit report XML format is not available in Ant,\n        // so I don't know for sure what means what.\n        // reports in http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700\n        // indicates that maybe I shouldn't use @classname altogether.\n\n        //String cn = testCase.attributeValue(\"classname\");\n        //if(cn==null)\n        //    // Maven seems to skip classname, and that shows up in testSuite/@name\n        //    cn = parent.getName();\n\n\n        /*\n            According to http://www.nabble.com/NPE-(Fatal%3A-Null)-in-recording-junit-test-results-td23562964.html\n            there's some odd-ball cases where testClassName is null but\n            @name contains fully qualified name.\n         */\n        String nameAttr = testCase.attributeValue(\"name\");\n        if(testClassName==null && nameAttr.contains(\".\")) {\n            testClassName = nameAttr.substring(0,nameAttr.lastIndexOf('.'));\n            nameAttr = nameAttr.substring(nameAttr.lastIndexOf('.')+1);\n        }\n\n        className = testClassName;\n        testName = nameAttr;\n        errorStackTrace = getError(testCase);\n        errorDetails = getErrorMessage(testCase);\n        this.parent = parent;\n        duration = parseTime(testCase);\n        skipped = isMarkedAsSkipped(testCase);\n        stdout = testCase.elementText(\"system-out\");\n        stderr = testCase.elementText(\"system-err\");\n    }","id":84039,"modified_method":"CaseResult(SuiteResult parent, Element testCase, String testClassName) {\n        // schema for JUnit report XML format is not available in Ant,\n        // so I don't know for sure what means what.\n        // reports in http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700\n        // indicates that maybe I shouldn't use @classname altogether.\n\n        //String cn = testCase.attributeValue(\"classname\");\n        //if(cn==null)\n        //    // Maven seems to skip classname, and that shows up in testSuite/@name\n        //    cn = parent.getName();\n\n\n        /*\n            According to http://www.nabble.com/NPE-(Fatal%3A-Null)-in-recording-junit-test-results-td23562964.html\n            there's some odd-ball cases where testClassName is null but\n            @name contains fully qualified name.\n         */\n        String nameAttr = testCase.attributeValue(\"name\");\n        if(testClassName==null && nameAttr.contains(\".\")) {\n            testClassName = nameAttr.substring(0,nameAttr.lastIndexOf('.'));\n            nameAttr = nameAttr.substring(nameAttr.lastIndexOf('.')+1);\n        }\n\n        className = testClassName;\n        testName = nameAttr;\n        errorStackTrace = getError(testCase);\n        errorDetails = getErrorMessage(testCase);\n        this.parent = parent;\n        duration = parseTime(testCase);\n        skipped = isMarkedAsSkipped(testCase);\n        @SuppressWarnings(\"LeakingThisInConstructor\")\n        Collection<CaseResult> _this = Collections.singleton(this);\n        stdout = possiblyTrimStdio(_this, testCase.elementText(\"system-out\"));\n        stderr = possiblyTrimStdio(_this, testCase.elementText(\"system-err\"));\n    }","commit_id":"f4cc4245da8946caaf64f33865c1f5d07f14187e","url":"https://github.com/kohsuke/hudson"},{"original_method":"private SuiteResult(File xmlReport, Element suite) throws DocumentException {\n    \tthis.file = xmlReport.getAbsolutePath();\n        String name = suite.attributeValue(\"name\");\n        if(name==null)\n            // some user reported that name is null in their environment.\n            // see http://www.nabble.com/Unexpected-Null-Pointer-Exception-in-Hudson-1.131-tf4314802.html\n            name = '('+xmlReport.getName()+')';\n        else {\n            String pkg = suite.attributeValue(\"package\");\n            if(pkg!=null&& pkg.length()>0)   name=pkg+'.'+name;\n        }\n        this.name = TestObject.safe(name);\n        this.timestamp = suite.attributeValue(\"timestamp\");\n\n        stdout = suite.elementText(\"system-out\");\n        stderr = suite.elementText(\"system-err\");\n\n        Element ex = suite.element(\"error\");\n        if(ex!=null) {\n            // according to junit-noframes.xsl l.229, this happens when the test class failed to load\n            addCase(new CaseResult(this,suite,\"<init>\"));\n        }\n\n        for (Element e : (List<Element>)suite.elements(\"testcase\")) {\n            // https://hudson.dev.java.net/issues/show_bug.cgi?id=1233 indicates that\n            // when <testsuites> is present, we are better off using @classname on the\n            // individual testcase class.\n\n            // https://hudson.dev.java.net/issues/show_bug.cgi?id=1463 indicates that\n            // @classname may not exist in individual testcase elements. We now\n            // also test if the testsuite element has a package name that can be used\n            // as the class name instead of the file name which is default.\n            String classname = e.attributeValue(\"classname\");\n            if (classname == null) {\n                classname = suite.attributeValue(\"name\");\n            }\n\n            // https://hudson.dev.java.net/issues/show_bug.cgi?id=1233 and\n            // http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700\n            // are at odds with each other --- when both are present,\n            // one wants to use @name from <testsuite>,\n            // the other wants to use @classname from <testcase>.\n\n            addCase(new CaseResult(this, e, classname));\n        }\n    }","id":84040,"modified_method":"private SuiteResult(File xmlReport, Element suite) throws DocumentException {\n    \tthis.file = xmlReport.getAbsolutePath();\n        String name = suite.attributeValue(\"name\");\n        if(name==null)\n            // some user reported that name is null in their environment.\n            // see http://www.nabble.com/Unexpected-Null-Pointer-Exception-in-Hudson-1.131-tf4314802.html\n            name = '('+xmlReport.getName()+')';\n        else {\n            String pkg = suite.attributeValue(\"package\");\n            if(pkg!=null&& pkg.length()>0)   name=pkg+'.'+name;\n        }\n        this.name = TestObject.safe(name);\n        this.timestamp = suite.attributeValue(\"timestamp\");\n\n        Element ex = suite.element(\"error\");\n        if(ex!=null) {\n            // according to junit-noframes.xsl l.229, this happens when the test class failed to load\n            addCase(new CaseResult(this,suite,\"<init>\"));\n        }\n\n        for (Element e : (List<Element>)suite.elements(\"testcase\")) {\n            // https://hudson.dev.java.net/issues/show_bug.cgi?id=1233 indicates that\n            // when <testsuites> is present, we are better off using @classname on the\n            // individual testcase class.\n\n            // https://hudson.dev.java.net/issues/show_bug.cgi?id=1463 indicates that\n            // @classname may not exist in individual testcase elements. We now\n            // also test if the testsuite element has a package name that can be used\n            // as the class name instead of the file name which is default.\n            String classname = e.attributeValue(\"classname\");\n            if (classname == null) {\n                classname = suite.attributeValue(\"name\");\n            }\n\n            // https://hudson.dev.java.net/issues/show_bug.cgi?id=1233 and\n            // http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700\n            // are at odds with each other --- when both are present,\n            // one wants to use @name from <testsuite>,\n            // the other wants to use @classname from <testcase>.\n\n            addCase(new CaseResult(this, e, classname));\n        }\n\n        stdout = CaseResult.possiblyTrimStdio(cases, suite.elementText(\"system-out\"));\n        stderr = CaseResult.possiblyTrimStdio(cases, suite.elementText(\"system-err\"));\n    }","commit_id":"f4cc4245da8946caaf64f33865c1f5d07f14187e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Handle a mouse pressed event over the contact list.\n     *\n     * The main thing done when the mouse is pressed over the contact list is,\n     * simply select the <tt>MetaContact<\/tt> on which the event has occured.\n     *\n     * A <tt>ContactListDraggable<\/tt> object is also built, based on the\n     * element on which the mouse has been pressed. If the user is iniating\n     * a drag'n drop operation, the <tt>ContactListDraggable<\/tt> object will\n     * be monitored in <tt>mouseDragged<\/tt> and the dnd operation will be\n     * completed in <tt>mouseReleased<\/tt>.\n     */\n    public void mousePressed(MouseEvent e)\n    {\n        // Request the focus in the meta contact list when user clicks on it.\n        this.requestFocus();\n\n        draggedElement = null;\n\n        // Select the meta contact under the right button click.\n        if ((e.getModifiers() & InputEvent.BUTTON2_MASK) != 0\n            || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n            || (e.isControlDown() && !e.isMetaDown()))\n        {\n            int index = this.locationToIndex(e.getPoint());\n\n            this.setSelectedIndex(index);\n        }\n\n        int selectedIndex = this.getSelectedIndex();\n        Object selectedValue = this.getSelectedValue();\n\n        ContactListCellRenderer renderer = (ContactListCellRenderer) this\n            .getCellRenderer().getListCellRendererComponent(this,\n                                                            selectedValue,\n                                                            selectedIndex,\n                                                            true,\n                                                            true);\n\n        Point selectedCellPoint = this.indexToLocation(selectedIndex);\n\n        int translatedX = e.getX() - selectedCellPoint.x;\n\n        if (selectedValue instanceof MetaContact\n            && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n        {\n            MetaContact mContact = (MetaContact) selectedValue;\n\n            // get the component under the mouse\n            Component component\n                = this.getHorizontalComponent(renderer, translatedX);\n\n            if (component instanceof JLabel)\n            {\n                Image image = new BufferedImage(component.getWidth(),\n                    component.getHeight(),\n                    BufferedImage.TYPE_INT_ARGB);\n\n                Graphics g = image.getGraphics();\n\n                g.setColor(getBackground());\n                g.fillRect(0, 0, image.getWidth(null), image.getHeight(null));\n\n                component.paint(image.getGraphics());\n                draggedElement = new ContactListDraggable(  this,\n                                                            mContact,\n                                                            null,\n                                                            image);\n            }\n        }\n\n        if (draggedElement != null)\n        {\n            mainFrame.setGlassPane(draggedElement);\n\n            Point p = (Point) e.getPoint().clone();\n\n            p = SwingUtilities.convertPoint(e.getComponent(), p, draggedElement);\n            draggedElement.setLocation(p);\n        }\n    }","id":84041,"modified_method":"/**\n     * Handle a mouse pressed event over the contact list.\n     *\n     * The main thing done when the mouse is pressed over the contact list is,\n     * simply select the <tt>MetaContact<\/tt> on which the event has occured.\n     *\n     * A <tt>ContactListDraggable<\/tt> object is also built, based on the\n     * element on which the mouse has been pressed. If the user is iniating\n     * a drag'n drop operation, the <tt>ContactListDraggable<\/tt> object will\n     * be monitored in <tt>mouseDragged<\/tt> and the dnd operation will be\n     * completed in <tt>mouseReleased<\/tt>.\n     */\n    public void mousePressed(MouseEvent e)\n    {\n        // Request the focus in the meta contact list when user clicks on it.\n        this.requestFocus();\n\n        draggedElement = null;\n\n        // Select the meta contact under the right button click.\n        if ((e.getModifiers() & InputEvent.BUTTON2_MASK) != 0\n            || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n            || (e.isControlDown() && !e.isMetaDown()))\n        {\n            int index = this.locationToIndex(e.getPoint());\n\n            if (index != -1)\n                this.setSelectedIndex(index);\n        }\n\n        int selectedIndex = this.getSelectedIndex();\n        Object selectedValue = this.getSelectedValue();\n\n        // If there's no index selected we have nothing to do here.\n        if (selectedIndex < 0)\n            return;\n\n        ContactListCellRenderer renderer = (ContactListCellRenderer) this\n            .getCellRenderer().getListCellRendererComponent(this,\n                                                            selectedValue,\n                                                            selectedIndex,\n                                                            true,\n                                                            true);\n\n        Point selectedCellPoint = this.indexToLocation(selectedIndex);\n\n        int translatedX = e.getX() - selectedCellPoint.x;\n\n        if (selectedValue instanceof MetaContact\n            && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n        {\n            MetaContact mContact = (MetaContact) selectedValue;\n\n            // get the component under the mouse\n            Component component\n                = this.getHorizontalComponent(renderer, translatedX);\n\n            if (component instanceof JLabel)\n            {\n                Image image = new BufferedImage(component.getWidth(),\n                    component.getHeight(),\n                    BufferedImage.TYPE_INT_ARGB);\n\n                Graphics g = image.getGraphics();\n\n                g.setColor(getBackground());\n                g.fillRect(0, 0, image.getWidth(null), image.getHeight(null));\n\n                component.paint(image.getGraphics());\n                draggedElement = new ContactListDraggable(  this,\n                                                            mContact,\n                                                            null,\n                                                            image);\n            }\n        }\n\n        if (draggedElement != null)\n        {\n            mainFrame.setGlassPane(draggedElement);\n\n            Point p = (Point) e.getPoint().clone();\n\n            p = SwingUtilities.convertPoint(e.getComponent(), p, draggedElement);\n            draggedElement.setLocation(p);\n        }\n    }","commit_id":"c995a490b11034bd39e4b6179b5fc59406010c33","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Manages a mouse click over the contact list.\n     *\n     * When the left mouse button is clicked on a contact cell different things\n     * may happen depending on the contained component under the mouse. If the\n     * mouse is double clicked on the \"contact name\" the chat window is opened,\n     * configured to use the default protocol contact for the selected\n     * MetaContact. If the mouse is clicked on one of the protocol icons, the\n     * chat window is opened, configured to use the protocol contact\n     * corresponding to the given icon.\n     *\n     * When the right mouse button is clicked on a contact cell, the cell is\n     * selected and the <tt>ContactRightButtonMenu<\/tt> is opened.\n     *\n     * When the right mouse button is clicked on a group cell, the cell is\n     * selected and the <tt>GroupRightButtonMenu<\/tt> is opened.\n     *\n     * When the middle mouse button is clicked on a cell, the cell is selected.\n     */\n    public void mouseClicked(MouseEvent e)\n    {\n        int selectedIndex = this.getSelectedIndex();\n        Object selectedValue = this.getSelectedValue();\n\n        ContactListCellRenderer renderer\n            = (ContactListCellRenderer) this.getCellRenderer()\n                .getListCellRendererComponent(  this,\n                                                selectedValue,\n                                                selectedIndex,\n                                                true,\n                                                true);\n\n        Point selectedCellPoint = this.indexToLocation(selectedIndex);\n\n        int translatedX = e.getX() - selectedCellPoint.x;\n\n        if (selectedValue instanceof MetaContactGroup)\n        {\n            MetaContactGroup group = (MetaContactGroup) selectedValue;\n\n            // Closes or opens a group on a double click.\n            if (e.getClickCount() > 1)\n            {\n                if (listModel.isGroupClosed(group))\n                {\n                    listModel.openGroup(group);\n                }\n                else\n                {\n                    listModel.closeGroup(group);\n                }\n            }\n\n            if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n                || (e.isControlDown() && !e.isMetaDown()))\n            {\n\n                groupRightButtonMenu = new GroupRightButtonMenu(mainFrame,\n                    group);\n\n                SwingUtilities.convertPointToScreen(selectedCellPoint, this);\n\n                groupRightButtonMenu.setInvoker(this);\n\n                groupRightButtonMenu.setLocation(selectedCellPoint.x,\n                    selectedCellPoint.y + renderer.getHeight());\n\n                groupRightButtonMenu.setVisible(true);\n            }\n            else if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n            {\n                fireContactListEvent(   group,\n                                        ContactListEvent.GROUP_SELECTED,\n                                        e.getClickCount());\n\n                // get the component under the mouse\n                Component component = this.getHorizontalComponent(renderer,\n                    translatedX);\n\n                if (component instanceof JPanel)\n                {\n                    if (component.getName() != null\n                        && component.getName().equals(\"buttonsPanel\"))\n                    {\n                        JPanel panel = (JPanel) component;\n\n                        int internalX = translatedX\n                            - (renderer.getWidth() - panel.getWidth() - 2);\n\n                        Component c = getHorizontalComponent(panel, internalX);\n\n                        if (c instanceof JLabel)\n                        {\n                            if (listModel.isGroupClosed(group))\n                            {\n                                listModel.openGroup(group);\n                            }\n                            else\n                            {\n                                listModel.closeGroup(group);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Open message window, right button menu or contact info when\n        // mouse is pressed. Distinguish on which component was pressed\n        // the mouse and make the appropriate work.\n        if (selectedValue instanceof MetaContact)\n        {\n            MetaContact contact = (MetaContact) selectedValue;\n\n            // get the component under the mouse\n            Component component = this.getHorizontalComponent(renderer,\n                translatedX);\n\n            if (component instanceof JLabel)\n            {\n                // Right click and Ctrl+LeftClick on the contact label opens\n                // Popup menu\n                if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n                    || (e.isControlDown() && !e.isMetaDown()))\n                {\n\n                    contactRightButtonMenu = new ContactRightButtonMenu(this,\n                        contact);\n\n                    SwingUtilities\n                        .convertPointToScreen(selectedCellPoint, this);\n\n                    contactRightButtonMenu.setInvoker(this);\n\n                    contactRightButtonMenu.setLocation(selectedCellPoint.x,\n                        selectedCellPoint.y + renderer.getHeight());\n\n                    contactRightButtonMenu.setVisible(true);\n                }\n                // Left click on the contact label opens Chat window\n                else if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0\n                    && e.getClickCount() > 1)\n                {\n                    fireContactListEvent(contact,\n                        ContactListEvent.CONTACT_SELECTED, e.getClickCount());\n                }\n            }\n            else if (component instanceof JButton)\n            {\n                // Click on the info button opens the info popup panel\n                SwingUtilities.invokeLater(new RunInfoWindow(selectedCellPoint,\n                    contact));\n            }\n            else if (component instanceof JPanel)\n            {\n                if (component.getName() != null\n                    && component.getName().equals(\"buttonsPanel\"))\n                {\n                    JPanel panel = (JPanel) component;\n\n                    int internalX = translatedX\n                        - (renderer.getWidth() - panel.getWidth() - 2);\n\n                    Component c = getHorizontalComponent(panel, internalX);\n\n                    if (c instanceof ContactProtocolButton)\n                    {\n                        fireContactListEvent(contact,\n                            ((ContactProtocolButton) c).getProtocolContact(),\n                            ContactListEvent.PROTOCOL_CONTACT_SELECTED);\n                    }\n                }\n            }\n        }\n    }","id":84042,"modified_method":"/**\n     * Manages a mouse click over the contact list.\n     *\n     * When the left mouse button is clicked on a contact cell different things\n     * may happen depending on the contained component under the mouse. If the\n     * mouse is double clicked on the \"contact name\" the chat window is opened,\n     * configured to use the default protocol contact for the selected\n     * MetaContact. If the mouse is clicked on one of the protocol icons, the\n     * chat window is opened, configured to use the protocol contact\n     * corresponding to the given icon.\n     *\n     * When the right mouse button is clicked on a contact cell, the cell is\n     * selected and the <tt>ContactRightButtonMenu<\/tt> is opened.\n     *\n     * When the right mouse button is clicked on a group cell, the cell is\n     * selected and the <tt>GroupRightButtonMenu<\/tt> is opened.\n     *\n     * When the middle mouse button is clicked on a cell, the cell is selected.\n     */\n    public void mouseClicked(MouseEvent e)\n    {\n        int selectedIndex = this.getSelectedIndex();\n        Object selectedValue = this.getSelectedValue();\n\n        // If there's no index selected we have nothing to do here.\n        if (selectedIndex < 0)\n            return;\n\n        ContactListCellRenderer renderer\n            = (ContactListCellRenderer) this.getCellRenderer()\n                .getListCellRendererComponent(  this,\n                                                selectedValue,\n                                                selectedIndex,\n                                                true,\n                                                true);\n\n        Point selectedCellPoint = this.indexToLocation(selectedIndex);\n\n        int translatedX = e.getX() - selectedCellPoint.x;\n\n        if (selectedValue instanceof MetaContactGroup)\n        {\n            MetaContactGroup group = (MetaContactGroup) selectedValue;\n\n            // Closes or opens a group on a double click.\n            if (e.getClickCount() > 1)\n            {\n                if (listModel.isGroupClosed(group))\n                {\n                    listModel.openGroup(group);\n                }\n                else\n                {\n                    listModel.closeGroup(group);\n                }\n            }\n\n            if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n                || (e.isControlDown() && !e.isMetaDown()))\n            {\n\n                groupRightButtonMenu = new GroupRightButtonMenu(mainFrame,\n                    group);\n\n                SwingUtilities.convertPointToScreen(selectedCellPoint, this);\n\n                groupRightButtonMenu.setInvoker(this);\n\n                groupRightButtonMenu.setLocation(selectedCellPoint.x,\n                    selectedCellPoint.y + renderer.getHeight());\n\n                groupRightButtonMenu.setVisible(true);\n            }\n            else if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n            {\n                fireContactListEvent(   group,\n                                        ContactListEvent.GROUP_SELECTED,\n                                        e.getClickCount());\n\n                // get the component under the mouse\n                Component component = this.getHorizontalComponent(renderer,\n                    translatedX);\n\n                if (component instanceof JPanel)\n                {\n                    if (component.getName() != null\n                        && component.getName().equals(\"buttonsPanel\"))\n                    {\n                        JPanel panel = (JPanel) component;\n\n                        int internalX = translatedX\n                            - (renderer.getWidth() - panel.getWidth() - 2);\n\n                        Component c = getHorizontalComponent(panel, internalX);\n\n                        if (c instanceof JLabel)\n                        {\n                            if (listModel.isGroupClosed(group))\n                            {\n                                listModel.openGroup(group);\n                            }\n                            else\n                            {\n                                listModel.closeGroup(group);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Open message window, right button menu or contact info when\n        // mouse is pressed. Distinguish on which component was pressed\n        // the mouse and make the appropriate work.\n        if (selectedValue instanceof MetaContact)\n        {\n            MetaContact contact = (MetaContact) selectedValue;\n\n            // get the component under the mouse\n            Component component = this.getHorizontalComponent(renderer,\n                translatedX);\n\n            if (component instanceof JLabel)\n            {\n                // Right click and Ctrl+LeftClick on the contact label opens\n                // Popup menu\n                if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n                    || (e.isControlDown() && !e.isMetaDown()))\n                {\n\n                    contactRightButtonMenu = new ContactRightButtonMenu(this,\n                        contact);\n\n                    SwingUtilities\n                        .convertPointToScreen(selectedCellPoint, this);\n\n                    contactRightButtonMenu.setInvoker(this);\n\n                    contactRightButtonMenu.setLocation(selectedCellPoint.x,\n                        selectedCellPoint.y + renderer.getHeight());\n\n                    contactRightButtonMenu.setVisible(true);\n                }\n                // Left click on the contact label opens Chat window\n                else if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0\n                    && e.getClickCount() > 1)\n                {\n                    fireContactListEvent(contact,\n                        ContactListEvent.CONTACT_SELECTED, e.getClickCount());\n                }\n            }\n            else if (component instanceof JButton)\n            {\n                // Click on the info button opens the info popup panel\n                SwingUtilities.invokeLater(new RunInfoWindow(selectedCellPoint,\n                    contact));\n            }\n            else if (component instanceof JPanel)\n            {\n                if (component.getName() != null\n                    && component.getName().equals(\"buttonsPanel\"))\n                {\n                    JPanel panel = (JPanel) component;\n\n                    int internalX = translatedX\n                        - (renderer.getWidth() - panel.getWidth() - 2);\n\n                    Component c = getHorizontalComponent(panel, internalX);\n\n                    if (c instanceof ContactProtocolButton)\n                    {\n                        fireContactListEvent(contact,\n                            ((ContactProtocolButton) c).getProtocolContact(),\n                            ContactListEvent.PROTOCOL_CONTACT_SELECTED);\n                    }\n                }\n            }\n        }\n    }","commit_id":"c995a490b11034bd39e4b6179b5fc59406010c33","url":"https://github.com/jitsi/jitsi"},{"original_method":"public ImportChooserStep(final ProjectImportProvider[] providers, final StepSequence sequence, final WizardContext context) {\n    super(context);\n    mySequence = sequence;\n    myPanel = new JPanel(new BorderLayout());\n    final DefaultListModel model = new DefaultListModel();\n    myList = new JList(model);\n\n    for (ProjectImportProvider provider : sorted(providers)) {\n      model.addElement(provider);\n    }\n    \n    myList.setCellRenderer(new DefaultListCellRenderer(){\n      public Component getListCellRendererComponent(final JList list,\n                                                    final Object value,\n                                                    final int index, final boolean isSelected, final boolean cellHasFocus) {\n        final Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        setText(((ProjectImportProvider)value).getName());\n        setIcon(((ProjectImportProvider)value).getIcon());\n        return rendererComponent;\n      }\n    });\n    myPanel.add(ScrollPaneFactory.createScrollPane(myList), BorderLayout.CENTER);\n    myList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        final ProjectImportProvider provider = (ProjectImportProvider)myList.getSelectedValue();\n        if (provider != null) {\n          mySequence.setType(provider.getId());\n        }\n      }\n    });\n    myList.setSelectedIndex(0);\n  }","id":84043,"modified_method":"public ImportChooserStep(final ProjectImportProvider[] providers, final StepSequence sequence, final WizardContext context) {\n    super(context);\n    mySequence = sequence;\n    myPanel = new JPanel(new BorderLayout());\n    final DefaultListModel model = new DefaultListModel();\n    myList = new JList(model);\n\n    for (ProjectImportProvider provider : sorted(providers)) {\n      model.addElement(provider);\n    }\n    \n    myList.setCellRenderer(new DefaultListCellRenderer(){\n      public Component getListCellRendererComponent(final JList list,\n                                                    final Object value,\n                                                    final int index, final boolean isSelected, final boolean cellHasFocus) {\n        final Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        setText(((ProjectImportProvider)value).getName());\n        setIcon(((ProjectImportProvider)value).getIcon());\n        return rendererComponent;\n      }\n    });\n    myPanel.add(ScrollPaneFactory.createScrollPane(myList), BorderLayout.CENTER);\n    myList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        final ProjectImportProvider provider = (ProjectImportProvider)myList.getSelectedValue();\n        if (provider != null) {\n          mySequence.setType(provider.getId());\n        }\n      }\n    });\n    final String id = PropertiesComponent.getInstance().getValue(PREFFERED);\n    if (id == null) {\n      myList.setSelectedIndex(0);\n    } else {\n      for (ProjectImportProvider provider : providers) {\n        if (Comparing.strEqual(provider.getId(), id)) {\n          myList.setSelectedValue(provider, true);\n          break;\n        }\n      }\n    }\n  }","commit_id":"ea7ee09dfbe8dcc9747fcfd1b489de2f41d3fd5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateDataModel() {\n    final Object selectedValue = myList.getSelectedValue();\n    if (selectedValue instanceof ProjectImportProvider) {\n      mySequence.setType(((ProjectImportProvider)selectedValue).getId());\n      final ProjectImportBuilder builder = ((ProjectImportProvider)selectedValue).getBuilder();\n      getWizardContext().setProjectBuilder(builder);\n      builder.setUpdate(getWizardContext().getProject() != null);\n    }\n  }","id":84044,"modified_method":"public void updateDataModel() {\n    final Object selectedValue = myList.getSelectedValue();\n    if (selectedValue instanceof ProjectImportProvider) {\n      mySequence.setType(((ProjectImportProvider)selectedValue).getId());\n      final ProjectImportBuilder builder = ((ProjectImportProvider)selectedValue).getBuilder();\n      getWizardContext().setProjectBuilder(builder);\n      builder.setUpdate(getWizardContext().getProject() != null);\n      PropertiesComponent.getInstance().setValue(PREFFERED, ((ProjectImportProvider)selectedValue).getId());\n    }\n  }","commit_id":"ea7ee09dfbe8dcc9747fcfd1b489de2f41d3fd5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setTypes(PsiType[] types) {\n    if(myComboBoxModel == null) return;\n    PsiType oldType;\n    if (myComboBoxModel.getSize() > 0) {\n      oldType = (PsiType) myComboBoxModel.getSelectedItem();\n    } else {\n      oldType = null;\n    }\n    myComboBoxModel.setSuggestions(types);\n    if(oldType != null) {\n      for (int i = 0; i < types.length; i++) {\n        PsiType type = types[i];\n        if(type.equals(oldType)) {\n          ((JComboBox) myComponent).setSelectedIndex(i);\n          return;\n        }\n      }\n    }\n    ((JComboBox) myComponent).setSelectedIndex(0);\n  }","id":84045,"modified_method":"public void setTypes(PsiType[] types) {\n    if(myComboBoxModel == null) return;\n    PsiType oldType;\n    if (myComboBoxModel.getSize() > 0) {\n      oldType = (PsiType) myComboBoxModel.getSelectedItem();\n    } else {\n      oldType = null;\n    }\n    myComboBoxModel.setSuggestions(types);\n    if(oldType != null) {\n      for (int i = 0; i < types.length; i++) {\n        PsiType type = types[i];\n        if(type.equals(oldType)) {\n          ((JComboBox) myComponent).setSelectedIndex(i);\n          return;\n        }\n      }\n    }\n    if (types.length > 0) {\n      ((JComboBox) myComponent).setSelectedIndex(0);\n    }\n  }","commit_id":"710b6cfc8edc9a4d6f8ce0463d40614b27f64d92","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reset() {\n    final List<String> savedUrls = getSavedLogFileUrls();\n    myLogFile.setHistory(savedUrls);\n\n    String lastUrl = getLastUsedLogUrl();\n    if (lastUrl == null && savedUrls.size() != 0) {\n      lastUrl = savedUrls.get(savedUrls.size() - 1);\n    }\n    if (lastUrl != null) {\n      myLogFile.setText(lastUrl);\n      myLogFile.setSelectedItem(lastUrl);\n    }\n    final UnscrambleSupport selectedUnscrambler = getSavedUnscrambler();\n\n    final int count = myUnscrambleChooser.getItemCount();\n    int index = 0;\n    if (selectedUnscrambler != null) {\n      for (int i = 0; i < count; i++) {\n        final UnscrambleSupport unscrambleSupport = (UnscrambleSupport)myUnscrambleChooser.getItemAt(i);\n        if (unscrambleSupport != null && Comparing.strEqual(unscrambleSupport.getPresentableName(), selectedUnscrambler.getPresentableName())) {\n          index = i;\n          break;\n        }\n      }\n    }\n    myUnscrambleChooser.setSelectedIndex(index);\n    myUseUnscrambler.setSelected(selectedUnscrambler != null);\n    useUnscramblerChanged();\n    pasteTextFromClipboard();\n  }","id":84046,"modified_method":"private void reset() {\n    final List<String> savedUrls = getSavedLogFileUrls();\n    myLogFile.setHistory(savedUrls);\n\n    String lastUrl = getLastUsedLogUrl();\n    if (lastUrl == null && savedUrls.size() != 0) {\n      lastUrl = savedUrls.get(savedUrls.size() - 1);\n    }\n    if (lastUrl != null) {\n      myLogFile.setText(lastUrl);\n      myLogFile.setSelectedItem(lastUrl);\n    }\n    final UnscrambleSupport selectedUnscrambler = getSavedUnscrambler();\n\n    final int count = myUnscrambleChooser.getItemCount();\n    int index = 0;\n    if (selectedUnscrambler != null) {\n      for (int i = 0; i < count; i++) {\n        final UnscrambleSupport unscrambleSupport = (UnscrambleSupport)myUnscrambleChooser.getItemAt(i);\n        if (unscrambleSupport != null && Comparing.strEqual(unscrambleSupport.getPresentableName(), selectedUnscrambler.getPresentableName())) {\n          index = i;\n          break;\n        }\n      }\n    }\n    if (count > 0) {\n      myUseUnscrambler.setEnabled(true);\n      myUnscrambleChooser.setSelectedIndex(index);\n      myUseUnscrambler.setSelected(selectedUnscrambler != null);\n    }\n    else {\n      myUseUnscrambler.setEnabled(false);\n    }\n    \n    useUnscramblerChanged();\n    pasteTextFromClipboard();\n  }","commit_id":"feb66e9b9347b3a16bc44cea7850cda5bd981fe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setSelectedIndex(final int index){\n      super.setSelectedIndex(index);\n      scrollTabToVisible(index);\n      doLayout();\n    }","id":84047,"modified_method":"public void setSelectedIndex(final int index){\n      if (index >= getTabCount()) return;\n\n      try {\n        super.setSelectedIndex(index);\n      }\n      catch (ArrayIndexOutOfBoundsException e) {\n        //http://www.jetbrains.net/jira/browse/IDEADEV-22331\n        //may happen on Mac OSX 10.5\n        return;\n      }\n\n      scrollTabToVisible(index);\n      doLayout();\n    }","commit_id":"c48dd19cf37f90292bb20cbbceea1f454ee7b0c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SourceLineAnnotation getSourceLines() {\n\t\tif (sourceLines == null) {\n\t\t\t// Create source line annotation for class on demand\n\t\t\t\n\t\t\tSourceInfoMap.SourceLineRange classLine = AnalysisContext.currentAnalysisContext()\n\t\t\t\t.getSourceInfoMap()\n\t\t\t\t.getClassLine(className);\n\t\t\t\n\t\t\tif (classLine == null)\n\t\t\t\tsourceLines = new SourceLineAnnotation(\n\t\t\t\t\t\tclassName, sourceFileName, -1,-1, -1, -1);\n\t\t\telse sourceLines = new SourceLineAnnotation(\n\t\t\t\t\tclassName, sourceFileName, classLine.getStart(), classLine.getEnd(), -1, -1);\n\t\t}\n\t\treturn sourceLines;\n\t}","id":84048,"modified_method":"public SourceLineAnnotation getSourceLines() {\n\t\tif (sourceLines == null) {\n\t\t\t// Create source line annotation for class on demand\n\t\t\t\n\t\t\tAnalysisContext currentAnalysisContext = AnalysisContext.currentAnalysisContext();\n\t\t\tif (currentAnalysisContext == null)\n\t\t\t\tsourceLines = new SourceLineAnnotation(className, sourceFileName, -1, -1, -1, -1);\n\t\t\telse {\n\t\t\tSourceInfoMap.SourceLineRange classLine = currentAnalysisContext\n\t\t\t\t.getSourceInfoMap()\n\t\t\t\t.getClassLine(className);\n\t\t\t\n\t\t\tif (classLine == null)\n\t\t\t\tsourceLines = new SourceLineAnnotation(\n\t\t\t\t\t\tclassName, sourceFileName, -1,-1, -1, -1);\n\t\t\telse sourceLines = new SourceLineAnnotation(\n\t\t\t\t\tclassName, sourceFileName, classLine.getStart(), classLine.getEnd(), -1, -1);\n\t\t\t}\n\t\t}\n\t\treturn sourceLines;\n\t}","commit_id":"56108ce866836dae84425001cd52429995832d03","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public SourceLineAnnotation getSourceLines() {\n\t\tif (sourceLines == null) {\n\t\t\t// Create source line annotation for field on demand\n\t\t\t\n\t\t\tSourceInfoMap.SourceLineRange fieldLine = AnalysisContext.currentAnalysisContext()\n\t\t\t\t.getSourceInfoMap()\n\t\t\t\t.getFieldLine(className, fieldName);\n\t\t\tif (fieldLine == null) \tsourceLines = new SourceLineAnnotation(\n\t\t\t\t\tclassName, sourceFileName, -1, -1, -1, -1);\n\t\t\telse sourceLines = new SourceLineAnnotation(\n\t\t\t\t\tclassName, sourceFileName, fieldLine.getStart(), fieldLine.getEnd(), -1, -1);\n\t\t}\n\t\treturn sourceLines;\n\t}","id":84049,"modified_method":"public SourceLineAnnotation getSourceLines() {\n\t\tif (sourceLines == null) {\n\t\t\t// Create source line annotation for field on demand\n\t\t\tAnalysisContext currentAnalysisContext = AnalysisContext.currentAnalysisContext();\n\t\t\tif (currentAnalysisContext == null)\n\t\t\t\tsourceLines = new SourceLineAnnotation(className, sourceFileName, -1, -1, -1, -1);\n\t\t\telse {\n\t\t\tSourceInfoMap.SourceLineRange fieldLine = currentAnalysisContext\n\t\t\t\t.getSourceInfoMap()\n\t\t\t\t.getFieldLine(className, fieldName);\n\t\t\tif (fieldLine == null) \tsourceLines = new SourceLineAnnotation(\n\t\t\t\t\tclassName, sourceFileName, -1, -1, -1, -1);\n\t\t\telse sourceLines = new SourceLineAnnotation(\n\t\t\t\t\tclassName, sourceFileName, fieldLine.getStart(), fieldLine.getEnd(), -1, -1);\n\t\t\t}\n\t\t}\n\t\treturn sourceLines;\n\t}","commit_id":"56108ce866836dae84425001cd52429995832d03","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * file a ClassNotFoundException with the lookupFailureCallback\n\t * @see #getLookupFailureCallback()\n\t */\n\tstatic public void reportMissingClass(ClassNotFoundException e) {\n\t\tcurrentAnalysisContext().getLookupFailureCallback().reportMissingClass(e);\n\t}","id":84050,"modified_method":"/**\n\t * file a ClassNotFoundException with the lookupFailureCallback\n\t * @see #getLookupFailureCallback()\n\t */\n\tstatic public void reportMissingClass(ClassNotFoundException e) {\n\t\tAnalysisContext currentAnalysisContext2 = currentAnalysisContext();\n\t\tif (currentAnalysisContext2 == null) return;\n\t\tRepositoryLookupFailureCallback lookupFailureCallback = currentAnalysisContext2.getLookupFailureCallback();\n\t\tif (lookupFailureCallback != null) lookupFailureCallback.reportMissingClass(e);\n\t}","commit_id":"b897f2b88d7bc8ef0e0968c38e44e7c2fe2834ac","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * @param f\n\t * @return\n\t */\n\tprivate @NonNull XField resolve(XField f) {\n\t\tif (f.isResolved()) return f;\n\t\tif (f.isStatic()) return f;\n\t\tXField f2 = f;\n\t\tString classname = f.getClassName();\n\t\ttry {\n\t\t\tJavaClass javaClass = Repository.lookupClass(classname);\n\t\t\twhile (true) {\n\t\t\t\tjavaClass = javaClass.getSuperClass();\n\t\t\t\tif (javaClass == null) return f2;\n\t\t\t\tf2 = createXField(javaClass.getClassName(), f.getName(), f.getSignature(), f.isStatic());\n\t\t\t\tf2 = intern(f2);\n\t\t\t\tif (f2.isResolved()) return f2;\t\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t\treturn f2;\n\t}","id":84051,"modified_method":"/**\n\t * @param f\n\t * @return\n\t */\n\tprivate @NonNull XField resolve(XField f) {\n\t\tif (f.isResolved()) return f;\n\t\tif (f.isStatic()) return f;\n\t\tXField f2 = f;\n\t\tString classname = f.getClassName();\n\t\ttry {\n\t\t\tJavaClass javaClass = Repository.lookupClass(classname);\n\t\t\twhile (true) {\n\t\t\t\tjavaClass = javaClass.getSuperClass();\n\t\t\t\tif (javaClass == null) return f;\n\t\t\t\tf2 = createXField(javaClass.getClassName(), f.getName(), f.getSignature(), f.isStatic());\n\t\t\t\tf2 = intern(f2);\n\t\t\t\tif (f2.isResolved()) return f2;\t\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t\treturn f;\n\t}","commit_id":"b897f2b88d7bc8ef0e0968c38e44e7c2fe2834ac","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private @NonNull XMethod resolve(XMethod m) {\n\t\tif (m.isResolved()) return m;\n\t\tif (m.isStatic()) return m;\n\t\tXMethod m2 = m;\n\t\tString classname = m.getClassName();\n\t\tif (classname.charAt(0)=='[') return m;\n\t\t\n\t\ttry {\n\t\t\tJavaClass javaClass = Repository.lookupClass(classname);\n\t\t\twhile (true) {\n\t\t\t\tjavaClass = javaClass.getSuperClass();\n\t\t\t\tif (javaClass == null) return m2;\n\t\t\t\tm2 = createXMethod(javaClass.getClassName(), m.getName(), m.getSignature(), m.isStatic());\n\t\t\t\tm2 = intern(m2);\n\t\t\t\tif (m2.isResolved()) return m2;\t\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t\treturn m2;\n\t}","id":84052,"modified_method":"private @NonNull XMethod resolve(XMethod m) {\n\t\tif (m.isResolved()) return m;\n\t\tif (m.isStatic()) return m;\n\t\tXMethod m2 = m;\n\t\tString classname = m.getClassName();\n\t\tif (classname.charAt(0)=='[') return m;\n\t\t\n\t\ttry {\n\t\t\tJavaClass javaClass = Repository.lookupClass(classname);\n\t\t\twhile (true) {\n\t\t\t\tjavaClass = javaClass.getSuperClass();\n\t\t\t\tif (javaClass == null) return m;\n\t\t\t\tm2 = createXMethod(javaClass.getClassName(), m.getName(), m.getSignature(), m.isStatic());\n\t\t\t\tm2 = intern(m2);\n\t\t\t\tif (m2.isResolved()) return m2;\t\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t\treturn m;\n\t}","commit_id":"b897f2b88d7bc8ef0e0968c38e44e7c2fe2834ac","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"void constructQueueState(QueueConsumer consumer, QueueConfig config, QueueState queueState,\n                               ReadPointer readPointer) throws OperationException;","id":84053,"modified_method":"QueueState constructQueueState(QueueConsumer consumer, QueueConfig config,\n                               ReadPointer readPointer) throws OperationException;","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void invalidate(QueueEntryPointer entryPointer, long cleanWriteVersion) throws OperationException {\n    final byte [] rowName = makeRowKey(GLOBAL_DATA_PREFIX, entryPointer.getEntryId());\n    // Change meta data to INVALID\n    this.table.put(rowName, ENTRY_META,\n                   cleanWriteVersion, new EntryMeta(EntryMeta.EntryState.INVALID).getBytes());\n    // Delete data since it's invalidated\n    this.table.delete(rowName, ENTRY_DATA, cleanWriteVersion);\n    if (TRACE) log(\"Invalidated \" + entryPointer);\n  }","id":84054,"modified_method":"@Override\n  public void invalidate(QueueEntryPointer entryPointer, long cleanWriteVersion) throws OperationException {\n    final byte [] rowName = makeRowKey(GLOBAL_DATA_PREFIX, entryPointer.getEntryId());\n    // Change meta data to INVALID\n    this.table.put(rowName, ENTRY_META,\n                   cleanWriteVersion, new EntryMeta(EntryMeta.EntryState.INVALID).getBytes());\n    // Delete data since it's invalidated\n    this.table.delete(rowName, ENTRY_DATA, cleanWriteVersion);\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Invalidated \" + entryPointer);\n    }\n  }","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    return dequeueInternal(consumer, consumer.getQueueConfig(), readPointer);\n  }","id":84055,"modified_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isTraceEnabled())\n      LOG.trace(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final QueuePartitioner queuePartitioner = config.getPartitionerType().getPartitioner();\n    DequeueStrategy dequeueStrategy;\n    if(queuePartitioner instanceof QueuePartitioner.HashPartitioner) {\n      dequeueStrategy = new HashDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.RoundRobinPartitioner) {\n      dequeueStrategy = new RoundRobinDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.FifoPartitioner) {\n      dequeueStrategy = new FifoDequeueStrategy();\n    } else {\n      throw new IllegalStateException(\n        String.format(\"Cannot figure out the dequeue strategy to use for partitioner %s\", queuePartitioner.getClass()));\n    }\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueState queueState = consumer.getQueueState();\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"private void readEntries(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer,\n                            List<Long> entryIds) throws OperationException{\n    if(entryIds.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n      return;\n    }\n\n    final byte[][] entryRowKeys = new byte[entryIds.size()][];\n    for(int i = 0; i < entryIds.size(); ++i) {\n      entryRowKeys[i] = makeRowKey(GLOBAL_DATA_PREFIX, entryIds.get(i));\n    }\n\n    final byte[][] entryColKeys = new byte[][]{ ENTRY_META, ENTRY_DATA };\n    OperationResult<Map<byte[], Map<byte[], byte[]>>> entriesResult =\n                                                          this.table.get(entryRowKeys, entryColKeys, readPointer);\n    if(entriesResult.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n    } else {\n      List<QueueStateEntry> entries = new ArrayList<QueueStateEntry>(entryIds.size());\n      for(int i = 0; i < entryIds.size(); ++i) {\n        Map<byte[], byte[]> entryMap = entriesResult.getValue().get(entryRowKeys[i]);\n        if(entryMap == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        byte[] entryMetaBytes = entryMap.get(ENTRY_META);\n        if(entryMetaBytes == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        EntryMeta entryMeta = EntryMeta.fromBytes(entryMetaBytes);\n        if (TRACE) log(\"entryId:\" +  entryIds.get(i) + \". entryMeta : \" + entryMeta.toString());\n\n        // Check if entry has been invalidated or evicted\n        if (entryMeta.isInvalid() || entryMeta.isEvicted()) {\n          if (TRACE) log(\"Found invalidated or evicted entry at \" + entryIds.get(i) +\n                           \" (\" + entryMeta.toString() + \")\");\n        } else {\n          // Entry is visible and valid!\n          assert(entryMeta.isValid());\n          byte [] entryData = entryMap.get(ENTRY_DATA);\n          entries.add(new QueueStateEntry(entryData, entryIds.get(i)));\n        }\n      }\n      queueState.setCachedEntries(new CachedList<QueueStateEntry>(entries));\n    }\n  }","id":84056,"modified_method":"private void readEntries(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer,\n                            List<Long> entryIds) throws OperationException{\n    if(entryIds.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n      return;\n    }\n\n    final byte[][] entryRowKeys = new byte[entryIds.size()][];\n    for(int i = 0; i < entryIds.size(); ++i) {\n      entryRowKeys[i] = makeRowKey(GLOBAL_DATA_PREFIX, entryIds.get(i));\n    }\n\n    final byte[][] entryColKeys = new byte[][]{ ENTRY_META, ENTRY_DATA };\n    OperationResult<Map<byte[], Map<byte[], byte[]>>> entriesResult =\n                                                          this.table.get(entryRowKeys, entryColKeys, readPointer);\n    if(entriesResult.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n    } else {\n      List<QueueStateEntry> entries = new ArrayList<QueueStateEntry>(entryIds.size());\n      for(int i = 0; i < entryIds.size(); ++i) {\n        Map<byte[], byte[]> entryMap = entriesResult.getValue().get(entryRowKeys[i]);\n        if(entryMap == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        byte[] entryMetaBytes = entryMap.get(ENTRY_META);\n        if(entryMetaBytes == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        EntryMeta entryMeta = EntryMeta.fromBytes(entryMetaBytes);\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"entryId:\" + entryIds.get(i) + \". entryMeta : \" + entryMeta.toString());\n        }\n\n        // Check if entry has been invalidated or evicted\n        if (entryMeta.isInvalid() || entryMeta.isEvicted()) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Found invalidated or evicted entry at \" + entryIds.get(i) +\n                        \" (\" + entryMeta.toString() + \")\");\n          }\n        } else {\n          // Entry is visible and valid!\n          assert(entryMeta.isValid());\n          byte [] entryData = entryMap.get(ENTRY_DATA);\n          entries.add(new QueueStateEntry(entryData, entryIds.get(i)));\n        }\n      }\n      queueState.setCachedEntries(new CachedList<QueueStateEntry>(entries));\n    }\n  }","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public List<Long> fetchNextEntries(\n      QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      outerLoop:\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                    startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n        final String partitioningKey = consumer.getPartitioningKey();\n        final byte [][] rowKeys = new byte[cacheSize][];\n        for(int id = 0; id < cacheSize; ++id) {\n          rowKeys[id] = makeRowKey(GLOBAL_DATA_PREFIX, startEntryId + id);\n        }\n        final byte[][] columnKeys = new byte[1][];\n        columnKeys[0] = makeColumnName(ENTRY_HEADER, partitioningKey);\n        OperationResult<Map<byte[], Map<byte[], byte[]>>> headerResult = table.get(rowKeys, columnKeys, readPointer);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if (!headerResult.isEmpty()) {\n            Map<byte[], Map<byte[], byte[]>> headerValue = headerResult.getValue();\n            Map<byte[], byte[]> headerMap = headerValue.get(rowKeys[id]);\n            if(headerMap == null) {\n              break outerLoop;\n            }\n            byte[] hashBytes = headerMap.get(columnKeys[0]);\n            if(hashBytes == null) {\n              break outerLoop;\n            }\n            int hashValue = Bytes.toInt(hashBytes);\n            if(partitioner.shouldEmit(consumer, currentEntryId, hashValue)) {\n              newEntryIds.add(currentEntryId);\n            }\n          } else {\n            // Not able to read header\n            break outerLoop;\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","id":84057,"modified_method":"@Override\n    public List<Long> fetchNextEntries(\n      QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      outerLoop:\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          if(LOG.isTraceEnabled()) {\n            LOG.trace(String.format(\"New queueWritePointer = %d\", queueWritePointer));\n          }\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                    startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n        final String partitioningKey = consumer.getPartitioningKey();\n        final byte [][] rowKeys = new byte[cacheSize][];\n        for(int id = 0; id < cacheSize; ++id) {\n          rowKeys[id] = makeRowKey(GLOBAL_DATA_PREFIX, startEntryId + id);\n        }\n        final byte[][] columnKeys = new byte[1][];\n        columnKeys[0] = makeColumnName(ENTRY_HEADER, partitioningKey);\n        OperationResult<Map<byte[], Map<byte[], byte[]>>> headerResult = table.get(rowKeys, columnKeys, readPointer);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if (!headerResult.isEmpty()) {\n            Map<byte[], Map<byte[], byte[]>> headerValue = headerResult.getValue();\n            Map<byte[], byte[]> headerMap = headerValue.get(rowKeys[id]);\n            if(headerMap == null) {\n              break outerLoop;\n            }\n            byte[] hashBytes = headerMap.get(columnKeys[0]);\n            if(hashBytes == null) {\n              break outerLoop;\n            }\n            int hashValue = Bytes.toInt(hashBytes);\n            if(partitioner.shouldEmit(consumer, currentEntryId, hashValue)) {\n              newEntryIds.add(currentEntryId);\n            }\n          } else {\n            // Not able to read header\n            break outerLoop;\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public EnqueueResult enqueue(QueueEntry entry, long cleanWriteVersion) throws OperationException {\n    byte[] data = entry.getData();\n    if (TRACE)\n      log(\"Enqueueing (data.len=\" + data.length + \", writeVersion=\" +\n            cleanWriteVersion + \")\");\n\n    // Get our unique entry id\n    long entryId;\n    try {\n      // Make sure the increment below uses increment operation of the underlying implementation directly\n      // so that it is atomic (Eg. HBase increment operation)\n      entryId = this.table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 1);\n    } catch (OperationException e) {\n      throw new OperationException(StatusCode.INTERNAL_ERROR, \"Increment \" +\n        \"of global entry id failed with status code \" + e.getStatus() +\n        \": \" + e.getMessage(), e);\n    }\n    if (TRACE) log(\"New enqueue got entry id \" + entryId);\n\n    /*\n    Insert entry with version=<cleanWriteVersion> and\n    row-key = <queueName>20<entryId> , column/value 20/<data> and 10/EntryState.VALID\n    */\n\n    final int size = entry.getPartitioningMap().size() + 2;\n    byte[][] colKeys = new byte[size][];\n    byte[][] colValues = new byte[size][];\n\n    int colKeyIndex = 0;\n    int colValueIndex = 0;\n    colKeys[colKeyIndex++] = ENTRY_DATA;\n    colKeys[colKeyIndex++] = ENTRY_META;\n    colValues[colValueIndex++] = data;\n    colValues[colValueIndex++] = new EntryMeta(EntryMeta.EntryState.VALID).getBytes();\n    for(Map.Entry<String, Integer> e : entry.getPartitioningMap().entrySet()) {\n      colKeys[colKeyIndex++] = makeColumnName(ENTRY_HEADER, e.getKey());\n      colValues[colValueIndex++] = Bytes.toBytes(e.getValue());\n    }\n\n    this.table.put(makeRowKey(GLOBAL_DATA_PREFIX, entryId),\n                   colKeys,\n                   cleanWriteVersion,\n                   colValues);\n\n    // Return success with pointer to entry\n    return new EnqueueResult(EnqueueResult.EnqueueStatus.SUCCESS, new QueueEntryPointer(this.queueName, entryId));\n  }","id":84058,"modified_method":"@Override\n  public EnqueueResult enqueue(QueueEntry entry, long cleanWriteVersion) throws OperationException {\n    byte[] data = entry.getData();\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Enqueueing (data.len=\" + data.length + \", writeVersion=\" +\n            cleanWriteVersion + \")\");\n    }\n\n    // Get our unique entry id\n    long entryId;\n    try {\n      // Make sure the increment below uses increment operation of the underlying implementation directly\n      // so that it is atomic (Eg. HBase increment operation)\n      entryId = this.table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 1);\n    } catch (OperationException e) {\n      throw new OperationException(StatusCode.INTERNAL_ERROR, \"Increment \" +\n        \"of global entry id failed with status code \" + e.getStatus() +\n        \": \" + e.getMessage(), e);\n    }\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"New enqueue got entry id \" + entryId);\n    }\n\n    /*\n    Insert entry with version=<cleanWriteVersion> and\n    row-key = <queueName>20<entryId> , column/value 20/<data> and 10/EntryState.VALID\n    */\n\n    final int size = entry.getPartitioningMap().size() + 2;\n    byte[][] colKeys = new byte[size][];\n    byte[][] colValues = new byte[size][];\n\n    int colKeyIndex = 0;\n    int colValueIndex = 0;\n    colKeys[colKeyIndex++] = ENTRY_DATA;\n    colKeys[colKeyIndex++] = ENTRY_META;\n    colValues[colValueIndex++] = data;\n    colValues[colValueIndex++] = new EntryMeta(EntryMeta.EntryState.VALID).getBytes();\n    for(Map.Entry<String, Integer> e : entry.getPartitioningMap().entrySet()) {\n      colKeys[colKeyIndex++] = makeColumnName(ENTRY_HEADER, e.getKey());\n      colValues[colValueIndex++] = Bytes.toBytes(e.getValue());\n    }\n\n    this.table.put(makeRowKey(GLOBAL_DATA_PREFIX, entryId),\n                   colKeys,\n                   cleanWriteVersion,\n                   colValues);\n\n    // Return success with pointer to entry\n    return new EnqueueResult(EnqueueResult.EnqueueStatus.SUCCESS, new QueueEntryPointer(this.queueName, entryId));\n  }","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void constructQueueState(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      OperationResult<Map<byte[], byte[]>> stateBytes =\n        table.get(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                       new byte[][] {ACTIVE_ENTRY, CONSUMER_READ_POINTER}, readPointer);\n      if(!stateBytes.isEmpty()) {\n        long activeEntryId = Bytes.toLong(stateBytes.getValue().get(ACTIVE_ENTRY));\n        // TODO: check max tries\n        queueState.setActiveEntryId(activeEntryId);\n\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If active entry is present, read that from storage\n      if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n        readEntries(consumer, config, queueState, readPointer, Collections.singletonList(queueState.getActiveEntryId()));\n        // Set the active entry as the current entry\n        queueState.getCachedEntries().getNext();\n      }\n    }","id":84059,"modified_method":"@Override\n    public QueueState constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      // ACTIVE_ENTRY contains the entry if any that is dequeued, but not acked\n      // CONSUMER_READ_POINTER + 1 points to the next entry that can be read by this queue consuemr\n      QueueState queueState = new QueueStateImpl();\n      OperationResult<Map<byte[], byte[]>> stateBytes =\n        table.get(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                       new byte[][] {ACTIVE_ENTRY, CONSUMER_READ_POINTER}, readPointer);\n      if(!stateBytes.isEmpty()) {\n        long activeEntryId = Bytes.toLong(stateBytes.getValue().get(ACTIVE_ENTRY));\n        // TODO: check max tries\n        queueState.setActiveEntryId(activeEntryId);\n\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If active entry is present, read that from storage\n      if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n        readEntries(consumer, config, queueState, readPointer, Collections.singletonList(queueState.getActiveEntryId()));\n        // Set the active entry as the current entry\n        queueState.getCachedEntries().getNext();\n      }\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(String.format(\"Constructed new QueueState - %s\", queueState));\n      }\n      return queueState;\n    }","commit_id":"217c49a8c550422f0685099aa797aaa77e513605","url":"https://github.com/caskdata/cdap"},{"original_method":"private void _testGitRepoBuildScripts(\n\t\t\tPath dirPath, String buildGradleTemplate,\n\t\t\tString gradlePropertiesTemplate, String settingsGradleTemplate)\n\t\tthrows IOException {\n\n\t\tPath buildGradlePath = dirPath.resolve(\"build.gradle\");\n\t\tPath gradlePropertiesPath = dirPath.resolve(\"gradle.properties\");\n\t\tPath settingsGradlePath = dirPath.resolve(\"settings.gradle\");\n\n\t\tboolean buildGradleExists = Files.exists(buildGradlePath);\n\t\tboolean gradlePropertiesExists = Files.exists(gradlePropertiesPath);\n\t\tboolean settingsGradleExists = Files.exists(settingsGradlePath);\n\n\t\tif (!buildGradleExists) {\n\t\t\tAssert.fail(\"Missing \" + buildGradlePath);\n\t\t}\n\n\t\tString buildGradle = _read(buildGradlePath);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Incorrect \" + buildGradlePath,\n\t\t\t_getGitRepoBuildGradle(dirPath, buildGradleTemplate), buildGradle);\n\n\t\tif (!gradlePropertiesExists) {\n\t\t\tAssert.fail(\"Missing \" + gradlePropertiesPath);\n\t\t}\n\n\t\tString gradleProperties = _read(gradlePropertiesPath);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Incorrect \" + gradlePropertiesPath,\n\t\t\t_getGitRepoGradleProperties(dirPath, gradlePropertiesTemplate),\n\t\t\tgradleProperties);\n\n\t\tif (!settingsGradleExists) {\n\t\t\tAssert.fail(\"Missing \" + settingsGradlePath);\n\t\t}\n\n\t\tString settingsGradle = _read(settingsGradlePath);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Incorrect \" + settingsGradlePath, settingsGradleTemplate,\n\t\t\tsettingsGradle);\n\n\t\t// LPS-67772\n\n\t\tPath gitAttributesPath = dirPath.resolve(\".gitattributes\");\n\n\t\tboolean gitAttributesExists = Files.exists(gitAttributesPath);\n\n\t\tif (_containsFile(dirPath, \"**/src/main/resources/**/*.soy\")) {\n\t\t\tAssert.assertTrue(\n\t\t\t\t\"Missing \" + gitAttributesPath, gitAttributesExists);\n\t\t\tAssert.assertEquals(\"*.soy\\ttext eol=lf\", _read(gitAttributesPath));\n\t\t}\n\t\telse {\n\t\t\tAssert.assertFalse(\n\t\t\t\t\"Forbidden \" + gitAttributesPath, gitAttributesExists);\n\t\t}\n\t}","id":84060,"modified_method":"private void _testGitRepoBuildScripts(\n\t\t\tPath dirPath, String buildGradleTemplate,\n\t\t\tString gradlePropertiesTemplate, String settingsGradleTemplate)\n\t\tthrows IOException {\n\n\t\tPath buildGradlePath = dirPath.resolve(\"build.gradle\");\n\t\tPath gradlePropertiesPath = dirPath.resolve(\"gradle.properties\");\n\t\tPath settingsGradlePath = dirPath.resolve(\"settings.gradle\");\n\n\t\tboolean buildGradleExists = Files.exists(buildGradlePath);\n\t\tboolean gradlePropertiesExists = Files.exists(gradlePropertiesPath);\n\t\tboolean settingsGradleExists = Files.exists(settingsGradlePath);\n\n\t\tAssert.assertTrue(\"Missing \" + buildGradlePath, buildGradleExists);\n\n\t\tString buildGradle = _read(buildGradlePath);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Incorrect \" + buildGradlePath,\n\t\t\t_getGitRepoBuildGradle(dirPath, buildGradleTemplate), buildGradle);\n\n\t\tAssert.assertTrue(\n\t\t\t\"Missing \" + gradlePropertiesPath, gradlePropertiesExists);\n\n\t\tString gradleProperties = _read(gradlePropertiesPath);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Incorrect \" + gradlePropertiesPath,\n\t\t\t_getGitRepoGradleProperties(dirPath, gradlePropertiesTemplate),\n\t\t\tgradleProperties);\n\n\t\tAssert.assertTrue(\n\t\t\t\"Missing \" + settingsGradlePath, settingsGradleExists);\n\n\t\tString settingsGradle = _read(settingsGradlePath);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Incorrect \" + settingsGradlePath, settingsGradleTemplate,\n\t\t\tsettingsGradle);\n\n\t\t// LPS-67772\n\n\t\tPath gitAttributesPath = dirPath.resolve(\".gitattributes\");\n\n\t\tboolean gitAttributesExists = Files.exists(gitAttributesPath);\n\n\t\tif (_containsFile(dirPath, \"**/src/main/resources/**/*.soy\")) {\n\t\t\tAssert.assertTrue(\n\t\t\t\t\"Missing \" + gitAttributesPath, gitAttributesExists);\n\t\t\tAssert.assertEquals(\"*.soy\\ttext eol=lf\", _read(gitAttributesPath));\n\t\t}\n\t\telse {\n\t\t\tAssert.assertFalse(\n\t\t\t\t\"Forbidden \" + gitAttributesPath, gitAttributesExists);\n\t\t}\n\t}","commit_id":"d3bd66142c3ac85cd595a04b5c7e72f3a4c00a3d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testScanBuildScripts() throws IOException {\n\t\tClassLoader classLoader = ModulesStructureTest.class.getClassLoader();\n\n\t\tfinal String gitRepoBuildGradleTemplate = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/modules/dependencies/\" +\n\t\t\t\t\"git_repo_build_gradle.tmpl\");\n\t\tfinal String gitRepoGradlePropertiesTemplate = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/modules/dependencies/\" +\n\t\t\t\t\"git_repo_gradle_properties.tmpl\");\n\t\tfinal String gitRepoSettingsGradleTemplate = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/modules/dependencies/\" +\n\t\t\t\t\"git_repo_settings_gradle.tmpl\");\n\n\t\tFiles.walkFileTree(\n\t\t\t_modulesDirPath,\n\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult preVisitDirectory(\n\t\t\t\t\t\tPath dirPath, BasicFileAttributes basicFileAttributes)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\tif (dirPath.equals(_modulesDirPath)) {\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tPath dirNamePath = dirPath.getFileName();\n\n\t\t\t\t\tString dirName = dirNamePath.toString();\n\n\t\t\t\t\tif (dirName.charAt(0) == '.') {\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\n\t\t\t\t\tPath buildGradlePath = dirPath.resolve(\"build.gradle\");\n\t\t\t\t\tPath buildXMLPath = dirPath.resolve(\"build.xml\");\n\n\t\t\t\t\tif (Files.exists(dirPath.resolve(\".gitrepo\"))) {\n\t\t\t\t\t\t_testGitRepoBuildScripts(\n\t\t\t\t\t\t\tdirPath, gitRepoBuildGradleTemplate,\n\t\t\t\t\t\t\tgitRepoGradlePropertiesTemplate,\n\t\t\t\t\t\t\tgitRepoSettingsGradleTemplate);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(dirPath.resolve(\"app.bnd\"))) {\n\t\t\t\t\t\t_testAppBuildScripts(dirPath);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(dirPath.resolve(\"bnd.bnd\"))) {\n\t\t\t\t\t\tif (Files.notExists(buildGradlePath)) {\n\t\t\t\t\t\t\tAssert.fail(\"Missing \" + buildGradlePath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Files.exists(buildXMLPath)) {\n\t\t\t\t\t\t\tAssert.fail(\"Forbidden \" + buildXMLPath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPath ivyXmlPath = dirPath.resolve(\"ivy.xml\");\n\n\t\t\t\t\t\tif (Files.exists(ivyXmlPath)) {\n\t\t\t\t\t\t\tAssert.fail(\"Forbidden \" + ivyXmlPath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(buildXMLPath)) {\n\t\t\t\t\t\tif (Files.exists(buildGradlePath)) {\n\t\t\t\t\t\t\tAssert.fail(\"Forbidden \" + buildGradlePath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(dirPath.resolve(\"package.json\"))) {\n\t\t\t\t\t\t_testThemeBuildScripts(dirPath);\n\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":84061,"modified_method":"@Test\n\tpublic void testScanBuildScripts() throws IOException {\n\t\tClassLoader classLoader = ModulesStructureTest.class.getClassLoader();\n\n\t\tfinal String gitRepoBuildGradleTemplate = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/modules/dependencies/\" +\n\t\t\t\t\"git_repo_build_gradle.tmpl\");\n\t\tfinal String gitRepoGradlePropertiesTemplate = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/modules/dependencies/\" +\n\t\t\t\t\"git_repo_gradle_properties.tmpl\");\n\t\tfinal String gitRepoSettingsGradleTemplate = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/modules/dependencies/\" +\n\t\t\t\t\"git_repo_settings_gradle.tmpl\");\n\n\t\tFiles.walkFileTree(\n\t\t\t_modulesDirPath,\n\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult preVisitDirectory(\n\t\t\t\t\t\tPath dirPath, BasicFileAttributes basicFileAttributes)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\tif (dirPath.equals(_modulesDirPath)) {\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tPath dirNamePath = dirPath.getFileName();\n\n\t\t\t\t\tString dirName = dirNamePath.toString();\n\n\t\t\t\t\tif (dirName.charAt(0) == '.') {\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\n\t\t\t\t\tPath buildGradlePath = dirPath.resolve(\"build.gradle\");\n\t\t\t\t\tPath buildXMLPath = dirPath.resolve(\"build.xml\");\n\n\t\t\t\t\tif (Files.exists(dirPath.resolve(\".gitrepo\"))) {\n\t\t\t\t\t\t_testGitRepoBuildScripts(\n\t\t\t\t\t\t\tdirPath, gitRepoBuildGradleTemplate,\n\t\t\t\t\t\t\tgitRepoGradlePropertiesTemplate,\n\t\t\t\t\t\t\tgitRepoSettingsGradleTemplate);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(dirPath.resolve(\"app.bnd\"))) {\n\t\t\t\t\t\t_testAppBuildScripts(dirPath);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(dirPath.resolve(\"bnd.bnd\"))) {\n\t\t\t\t\t\tAssert.assertTrue(\n\t\t\t\t\t\t\t\"Missing \" + buildGradlePath,\n\t\t\t\t\t\t\tFiles.exists(buildGradlePath));\n\n\t\t\t\t\t\tAssert.assertFalse(\n\t\t\t\t\t\t\t\"Forbidden \" + buildXMLPath,\n\t\t\t\t\t\t\tFiles.exists(buildXMLPath));\n\n\t\t\t\t\t\tPath ivyXmlPath = dirPath.resolve(\"ivy.xml\");\n\n\t\t\t\t\t\tAssert.assertFalse(\n\t\t\t\t\t\t\t\"Forbidden \" + ivyXmlPath,\n\t\t\t\t\t\t\tFiles.exists(ivyXmlPath));\n\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(buildXMLPath)) {\n\t\t\t\t\t\tAssert.assertFalse(\n\t\t\t\t\t\t\t\"Forbidden \" + buildGradlePath,\n\t\t\t\t\t\t\tFiles.exists(buildGradlePath));\n\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\t\t\t\t\telse if (Files.exists(dirPath.resolve(\"package.json\"))) {\n\t\t\t\t\t\t_testThemeBuildScripts(dirPath);\n\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"d3bd66142c3ac85cd595a04b5c7e72f3a4c00a3d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _testThemeBuildScripts(Path dirPath) throws IOException {\n\t\tif (!_contains(\n\t\t\t\tdirPath.resolve(\"package.json\"), \"\\\"liferay-theme-tasks\\\":\")) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath gulpfileJsPath = dirPath.resolve(\"gulpfile.js\");\n\n\t\tif (Files.notExists(gulpfileJsPath)) {\n\t\t\tAssert.fail(\"Missing \" + gulpfileJsPath);\n\t\t}\n\t}","id":84062,"modified_method":"private void _testThemeBuildScripts(Path dirPath) throws IOException {\n\t\tif (!_contains(\n\t\t\t\tdirPath.resolve(\"package.json\"), \"\\\"liferay-theme-tasks\\\":\")) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath gulpfileJsPath = dirPath.resolve(\"gulpfile.js\");\n\n\t\tAssert.assertTrue(\n\t\t\t\"Missing \" + gulpfileJsPath, Files.exists(gulpfileJsPath));\n\t}","commit_id":"d3bd66142c3ac85cd595a04b5c7e72f3a4c00a3d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private int getMaximumChars(String s, FontMetrics metrics, int maxWidth) {\n    int minChar = 0;\n    int maxChar = s.length();\n    int chars;\n    while(minChar < maxChar) {\n      chars = (minChar + maxChar + 1) / 2;\n      int width = metrics.stringWidth(s.substring(0,  chars));\n      if(width <= maxWidth) {\n        minChar = chars;\n      } else {\n        maxChar = chars - 1;\n      }\n    }\n    return minChar;\n  }","id":84063,"modified_method":"private int getMaximumChars(final String s, final FontMetrics metrics, final int maxWidth) {\n    int minChar = 0;\n    int maxChar = s.length();\n    int chars;\n    while(minChar < maxChar) {\n      chars = (minChar + maxChar + 1) / 2;\n      final int width = metrics.stringWidth(s.substring(0,  chars));\n      if(width <= maxWidth) {\n        minChar = chars;\n      }\n      else {\n        maxChar = chars - 1;\n      }\n    }\n    return minChar;\n  }","commit_id":"f84fc150c2881235d163385f1fcce8af09959ac2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createTipContent(String tipText) {\n    JToolTip tooltip = new JToolTip();\n\n    if(tipText == null) {\n      tooltip.setTipText(tipText);\n    } else {\n      Dimension rootSize = getVisibleRect().getSize();\n      Insets borderInsets = tooltip.getBorder().getBorderInsets(tooltip);\n      rootSize.width -= (borderInsets.left + borderInsets.right) * 2;\n      rootSize.height -= (borderInsets.top + borderInsets.bottom) * 2;\n\n      StringBuffer tipBuffer = new StringBuffer(tipText.length());\n      StringTokenizer tokenizer = new StringTokenizer(tipText, \"\\n\");\n      while(tokenizer.hasMoreElements()) {\n        String line = tokenizer.nextToken();\n        for (;;) {\n          int maximumChars = getMaximumChars(line, tooltip.getFontMetrics(tooltip.getFont()), rootSize.width);\n          if(maximumChars == line.length()) {\n            tipBuffer.append(line.substring(0, maximumChars));\n            tipBuffer.append('\\n');\n            break;\n          } else {\n\n            int chars;\n            for(chars = maximumChars - 2; chars > 1; chars --) {\n              if(getMaximumChars(line.substring(0, chars), tooltip.getFontMetrics(tooltip.getFont()), rootSize.width) < maximumChars) break;\n            }\n            tipBuffer.append(line.substring(0, chars));\n            tipBuffer.append('\\\\');\n            tipBuffer.append('\\n');\n            line = line.substring(maximumChars - 2);\n          }\n        }\n      }\n\n      //noinspection HardCodedStringLiteral\n      Element html = new Element(\"html\");\n\n      String text = tipBuffer.toString();\n\n      //noinspection HardCodedStringLiteral\n      Element p = new Element(\"pre\");\n      html.addContent(p);\n      p.setText(text);\n\n      XMLOutputter outputter = JDOMUtil.createOutputter(\"\\n\");\n      Format format = outputter.getFormat().setTextMode(Format.TextMode.PRESERVE);\n      outputter.setFormat(format);\n      tooltip.setTipText(outputter.outputString(html));\n    }\n\n    tooltip.setBorder(null);\n\n    return tooltip;\n  }","id":84064,"modified_method":"private JComponent createTipContent(String tipText) {\n    final JToolTip tooltip = new JToolTip();\n\n    if(tipText == null) {\n      tooltip.setTipText(tipText);\n    }\n    else {\n      Dimension rootSize = getVisibleRect().getSize();\n      Insets borderInsets = tooltip.getBorder().getBorderInsets(tooltip);\n      rootSize.width -= (borderInsets.left + borderInsets.right) * 2;\n      rootSize.height -= (borderInsets.top + borderInsets.bottom) * 2;\n\n      //noinspection HardCodedStringLiteral\n      final Element html = new Element(\"html\");\n\n      final StringBuilder tipBuilder = StringBuilderSpinAllocator.alloc();\n      try {\n        final StringTokenizer tokenizer = new StringTokenizer(tipText, \"\\n\");\n        final FontMetrics metrics = tooltip.getFontMetrics(tooltip.getFont());\n        while(tokenizer.hasMoreElements()) {\n          String line = tokenizer.nextToken();\n          while (line.length() > 0) {\n            if(getMaximumChars(line, metrics, rootSize.width) == line.length()) {\n              tipBuilder.append(line).append('\\n');\n              break;\n            }\n            else { // maxChars < line.length()\n              final String delimiterString = \"\\\\\\n\";\n              final int chars = getMaximumChars(line, metrics, rootSize.width - metrics.stringWidth(delimiterString));\n              tipBuilder.append(line.substring(0, chars));\n              tipBuilder.append(delimiterString);\n              line = line.substring(chars);\n            }\n          }\n        }\n        //noinspection HardCodedStringLiteral\n        Element p = new Element(\"pre\");\n        html.addContent(p);\n        p.setText(tipBuilder.toString());\n      }\n      finally {\n        StringBuilderSpinAllocator.dispose(tipBuilder);\n      }\n\n      XMLOutputter outputter = JDOMUtil.createOutputter(\"\\n\");\n      Format format = outputter.getFormat().setTextMode(Format.TextMode.PRESERVE);\n      outputter.setFormat(format);\n      tooltip.setTipText(outputter.outputString(html));\n    }\n\n    tooltip.setBorder(null);\n\n    return tooltip;\n  }","commit_id":"f84fc150c2881235d163385f1fcce8af09959ac2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static JVMName getJVMQualifiedName(PsiClass psiClass) {\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      return new JVMClassAt(SourcePosition.createFromElement(psiClass));\n    }\n    else {\n      return getJVMRawText(getNonAnonymousClassName(psiClass));\n    }\n  }","id":84065,"modified_method":"public static JVMName getJVMQualifiedName(PsiClass psiClass) {\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      return new JVMClassAt(SourcePosition.createFromElement(psiClass));\n    }\n    else {\n      final String name = getNonAnonymousClassName(psiClass);\n      return getJVMRawText(name != null? name : \"\");\n    }\n  }","commit_id":"f84fc150c2881235d163385f1fcce8af09959ac2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<ReferenceType> getAllClasses(final SourcePosition classPosition) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<List<ReferenceType>> () {\n      public List<ReferenceType> compute() {\n        final PsiClass psiClass = JVMNameUtil.getClassAt(classPosition);\n\n        if(psiClass == null) {\n          return Collections.emptyList();\n        }\n\n        if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n          final PsiClass parentNonLocal = JVMNameUtil.getTopLevelParentClass(psiClass);\n          if(parentNonLocal == null) {\n            LOG.assertTrue(false, \"Local class has no non-local parent\");\n            return Collections.emptyList();\n          }\n          final String parentClassName = JVMNameUtil.getNonAnonymousClassName(parentNonLocal);\n          final List<ReferenceType> outer = myDebugProcess.getVirtualMachineProxy().classesByName(parentClassName);\n          final List<ReferenceType> result = new ArrayList<ReferenceType>();\n          findNested(outer, classPosition, result);\n          if (result.size() == 0) {\n            // no executable code found at this line in any class\n            for (ReferenceType refType : outer) {\n              final ReferenceType closest = findClosestClassAt(refType, classPosition);\n              if (closest != null) {\n                result.add(closest);\n              }\n            }\n          }\n          return result;\n        }\n        else {\n          final String className = JVMNameUtil.getNonAnonymousClassName(psiClass);\n          return myDebugProcess.getVirtualMachineProxy().classesByName(className);\n        }\n      }\n    });\n  }","id":84066,"modified_method":"public List<ReferenceType> getAllClasses(final SourcePosition classPosition) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<List<ReferenceType>> () {\n      public List<ReferenceType> compute() {\n        final PsiClass psiClass = JVMNameUtil.getClassAt(classPosition);\n\n        if(psiClass == null) {\n          return Collections.emptyList();\n        }\n\n        if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n          final PsiClass parentNonLocal = JVMNameUtil.getTopLevelParentClass(psiClass);\n          if(parentNonLocal == null) {\n            LOG.assertTrue(false, \"Local class has no non-local parent\");\n            return Collections.emptyList();\n          }\n          final String parentClassName = JVMNameUtil.getNonAnonymousClassName(parentNonLocal);\n          final List<ReferenceType> outer = myDebugProcess.getVirtualMachineProxy().classesByName(parentClassName);\n          final List<ReferenceType> result = new ArrayList<ReferenceType>();\n          findNested(outer, classPosition, result);\n          if (result.size() == 0) {\n            // no executable code found at this line in any class\n            for (ReferenceType refType : outer) {\n              final ReferenceType closest = findClosestClassAt(refType, classPosition);\n              if (closest != null) {\n                result.add(closest);\n              }\n            }\n          }\n          return result;\n        }\n        else {\n          final String className = JVMNameUtil.getNonAnonymousClassName(psiClass);\n          if (className == null) {\n            return Collections.emptyList();\n          }\n          return myDebugProcess.getVirtualMachineProxy().classesByName(className);\n        }\n      }\n    });\n  }","commit_id":"f84fc150c2881235d163385f1fcce8af09959ac2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClassPrepareRequest createPrepareRequest(final ClassPrepareRequestor requestor, final SourcePosition position) {\n    PsiClass psiClass = JVMNameUtil.getClassAt(position);\n    if(psiClass == null) {\n      return null;\n    }\n\n    String waitPrepareFor;\n    ClassPrepareRequestor waitRequestor;\n\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      PsiClass parent = JVMNameUtil.getTopLevelParentClass(psiClass);\n\n      if(parent == null) {\n        return null;\n      }\n\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(parent) + \"$*\";\n      waitRequestor = new ClassPrepareRequestor() {\n        public void processClassPrepare(DebugProcess debuggerProcess, ReferenceType referenceType) {\n          final CompoundPositionManager positionManager = ((DebugProcessImpl)debuggerProcess).getPositionManager();\n          if (positionManager.locationsOfLine(referenceType, position).size() > 0) {\n            requestor.processClassPrepare(debuggerProcess, referenceType);\n          }\n          else {\n            final List<ReferenceType> positionClasses = positionManager.getAllClasses(position);\n            if (positionClasses.contains(referenceType)) {\n              requestor.processClassPrepare(debuggerProcess, referenceType);\n            }\n          }\n        }\n      };\n    }\n    else {\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(psiClass);\n      waitRequestor = requestor;\n    }\n    return myDebugProcess.getRequestsManager().createClassPrepareRequest(waitRequestor, waitPrepareFor);\n  }","id":84067,"modified_method":"public ClassPrepareRequest createPrepareRequest(final ClassPrepareRequestor requestor, final SourcePosition position) {\n    PsiClass psiClass = JVMNameUtil.getClassAt(position);\n    if(psiClass == null) {\n      return null;\n    }\n\n    String waitPrepareFor;\n    ClassPrepareRequestor waitRequestor;\n\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      PsiClass parent = JVMNameUtil.getTopLevelParentClass(psiClass);\n\n      if(parent == null) {\n        return null;\n      }\n\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(parent) + \"$*\";\n      waitRequestor = new ClassPrepareRequestor() {\n        public void processClassPrepare(DebugProcess debuggerProcess, ReferenceType referenceType) {\n          final CompoundPositionManager positionManager = ((DebugProcessImpl)debuggerProcess).getPositionManager();\n          if (positionManager.locationsOfLine(referenceType, position).size() > 0) {\n            requestor.processClassPrepare(debuggerProcess, referenceType);\n          }\n          else {\n            final List<ReferenceType> positionClasses = positionManager.getAllClasses(position);\n            if (positionClasses.contains(referenceType)) {\n              requestor.processClassPrepare(debuggerProcess, referenceType);\n            }\n          }\n        }\n      };\n    }\n    else {\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(psiClass);\n      waitRequestor = requestor;\n    }\n    if (waitPrepareFor == null) {\n      return null;  // no suitable class found for this name\n    }\n    return myDebugProcess.getRequestsManager().createClassPrepareRequest(waitRequestor, waitPrepareFor);\n  }","commit_id":"f84fc150c2881235d163385f1fcce8af09959ac2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReferenceExpression(PsiReferenceExpression expression) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"visitReferenceExpression \" + expression);\n      }\n      PsiExpression qualifier = expression.getQualifierExpression();\n      PsiElement element = expression.resolve();\n\n      if (element instanceof PsiLocalVariable || element instanceof PsiParameter) {\n        //synthetic variable\n        final PsiFile containingFile = element.getContainingFile();\n        if(containingFile instanceof PsiCodeFragment && myCurrentFragmentEvaluator != null && myVisitedFragments.contains(((PsiCodeFragment)containingFile))) {\n          // psiVariable may live in PsiCodeFragment not only in debugger editors, for example Fabrique has such variables.\n          // So treat it as synthetic var only when this code fragment is located in DebuggerEditor,\n          // that's why we need to check that containing code fragment is the one we visited\n          myResult = new SyntheticVariableEvaluator(myCurrentFragmentEvaluator, ((PsiVariable)element).getName());\n          return;\n        }\n        // local variable\n        PsiVariable psiVar = (PsiVariable)element;\n        String localName = psiVar.getName();\n        PsiClass variableClass = getContainingClass(psiVar);\n        if (getContextPsiClass() == null || getContextPsiClass().equals(variableClass)) {\n          myResult = new LocalVariableEvaluator(localName, ContextUtil.isJspImplicit(element));\n          return;\n        }\n        // the expression references final var outside the context's class (in some of the outer classes)\n        int iterationCount = 0;\n        PsiClass aClass = getOuterClass(getContextPsiClass());\n        while (aClass != null && !aClass.equals(variableClass)) {\n          iterationCount++;\n          aClass = getOuterClass(aClass);\n        }\n        if (aClass != null) {\n          if(psiVar.getInitializer() != null) {\n            Object value = psiVar.getManager().getConstantEvaluationHelper().computeConstantExpression(psiVar.getInitializer());\n            if(value != null) {\n              myResult = new LiteralEvaluator(value, psiVar.getType().getCanonicalText());\n              return;\n            }\n          }\n          Evaluator objectEvaluator = new ThisEvaluator(iterationCount);\n          //noinspection HardCodedStringLiteral\n          myResult = new FieldEvaluator(objectEvaluator, getContextPsiClass().getQualifiedName(), \"val$\" + localName);\n          return;\n        }\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n          DebuggerBundle.message(\"evaluation.error.local.variable.missing.from.class.closure\", localName))\n        );\n      }\n      else if (element instanceof PsiField) {\n        PsiField psiField = (PsiField)element;\n        PsiClass fieldClass = psiField.getContainingClass();\n        if(fieldClass == null) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.cannot.resolve.field.class\", psiField.getName())));\n        }\n        Evaluator objectEvaluator;\n        if (psiField.hasModifierProperty(PsiModifier.STATIC)) {\n          objectEvaluator = new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(fieldClass));\n        }\n        else if(qualifier != null) {\n          qualifier.accept(this);\n          objectEvaluator = myResult;\n        }\n        else if (fieldClass.equals(getContextPsiClass()) || getContextPsiClass().isInheritor(fieldClass, true)) {\n            objectEvaluator = new ThisEvaluator();\n        }\n        else {  // myContextPsiClass != fieldClass && myContextPsiClass is not a subclass of fieldClass\n          int iterationCount = 0;\n          PsiClass aClass = getContextPsiClass();\n          while (aClass != null && !(aClass.equals(fieldClass) || aClass.isInheritor(fieldClass, true))) {\n            iterationCount++;\n            aClass = getOuterClass(aClass);\n          }\n          if (aClass == null) {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n              DebuggerBundle.message(\"evaluation.error.cannot.sources.for.field.class\", psiField.getName())));\n          }\n          objectEvaluator = new ThisEvaluator(iterationCount);\n        }\n        myResult = new FieldEvaluator(objectEvaluator, fieldClass.getQualifiedName(), psiField.getName());\n      } else {\n        //let's guess what this could be\n        PsiElement nameElement = expression.getReferenceNameElement(); // get \"b\" part\n        String name;\n        if (nameElement instanceof PsiIdentifier) {\n          name = nameElement.getText();\n        }\n        else {\n          //noinspection HardCodedStringLiteral\n          final String elementDisplayString = (nameElement != null ? nameElement.getText() : \"(null)\");\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.identifier.expected\", elementDisplayString)));\n        }\n\n        if(qualifier != null) {\n          final PsiElement qualifierTarget = (qualifier instanceof PsiReferenceExpression) ? ((PsiReferenceExpression)qualifier).resolve() : null;\n          if (qualifierTarget instanceof PsiClass) {\n            // this is a call to a 'static' field\n            PsiClass psiClass = (PsiClass)qualifierTarget;\n            myResult = new FieldEvaluator(new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(psiClass)), psiClass.getQualifiedName(), name);\n          }\n          else {\n            PsiType type = qualifier.getType();\n            if(type == null)\n              throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n                DebuggerBundle.message(\"evaluation.error.qualifier.type.unknown\", qualifier.getText()))\n              );\n\n            qualifier.accept(this);\n            if (myResult == null) {\n              throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n                DebuggerBundle.message(\"evaluation.error.cannot.evaluate.qualifier\", qualifier.getText()))\n              );\n            }\n\n            myResult = new FieldEvaluator(myResult, type.getCanonicalText(), name);\n          }\n        }\n        else {\n          myResult = new LocalVariableEvaluator(name, false);\n        }\n      }\n    }","id":84068,"modified_method":"public void visitReferenceExpression(PsiReferenceExpression expression) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"visitReferenceExpression \" + expression);\n      }\n      PsiExpression qualifier = expression.getQualifierExpression();\n      PsiElement element = expression.resolve();\n\n      if (element instanceof PsiLocalVariable || element instanceof PsiParameter) {\n        //synthetic variable\n        final PsiFile containingFile = element.getContainingFile();\n        if(containingFile instanceof PsiCodeFragment && myCurrentFragmentEvaluator != null && myVisitedFragments.contains(((PsiCodeFragment)containingFile))) {\n          // psiVariable may live in PsiCodeFragment not only in debugger editors, for example Fabrique has such variables.\n          // So treat it as synthetic var only when this code fragment is located in DebuggerEditor,\n          // that's why we need to check that containing code fragment is the one we visited\n          myResult = new SyntheticVariableEvaluator(myCurrentFragmentEvaluator, ((PsiVariable)element).getName());\n          return;\n        }\n        // local variable\n        PsiVariable psiVar = (PsiVariable)element;\n        String localName = psiVar.getName();\n        PsiClass variableClass = getContainingClass(psiVar);\n        if (getContextPsiClass() == null || getContextPsiClass().equals(variableClass)) {\n          myResult = new LocalVariableEvaluator(localName, ContextUtil.isJspImplicit(element));\n          return;\n        }\n        // the expression references final var outside the context's class (in some of the outer classes)\n        int iterationCount = 0;\n        PsiClass aClass = getOuterClass(getContextPsiClass());\n        while (aClass != null && !aClass.equals(variableClass)) {\n          iterationCount++;\n          aClass = getOuterClass(aClass);\n        }\n        if (aClass != null) {\n          if(psiVar.getInitializer() != null) {\n            Object value = psiVar.getManager().getConstantEvaluationHelper().computeConstantExpression(psiVar.getInitializer());\n            if(value != null) {\n              myResult = new LiteralEvaluator(value, psiVar.getType().getCanonicalText());\n              return;\n            }\n          }\n          Evaluator objectEvaluator = new ThisEvaluator(iterationCount);\n          //noinspection HardCodedStringLiteral\n          myResult = new FieldEvaluator(objectEvaluator, JVMNameUtil.getJVMQualifiedName(getContextPsiClass()), \"val$\" + localName);\n          return;\n        }\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n          DebuggerBundle.message(\"evaluation.error.local.variable.missing.from.class.closure\", localName))\n        );\n      }\n      else if (element instanceof PsiField) {\n        PsiField psiField = (PsiField)element;\n        PsiClass fieldClass = psiField.getContainingClass();\n        if(fieldClass == null) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.cannot.resolve.field.class\", psiField.getName())));\n        }\n        Evaluator objectEvaluator;\n        if (psiField.hasModifierProperty(PsiModifier.STATIC)) {\n          objectEvaluator = new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(fieldClass));\n        }\n        else if(qualifier != null) {\n          qualifier.accept(this);\n          objectEvaluator = myResult;\n        }\n        else if (fieldClass.equals(getContextPsiClass()) || getContextPsiClass().isInheritor(fieldClass, true)) {\n            objectEvaluator = new ThisEvaluator();\n        }\n        else {  // myContextPsiClass != fieldClass && myContextPsiClass is not a subclass of fieldClass\n          int iterationCount = 0;\n          PsiClass aClass = getContextPsiClass();\n          while (aClass != null && !(aClass.equals(fieldClass) || aClass.isInheritor(fieldClass, true))) {\n            iterationCount++;\n            aClass = getOuterClass(aClass);\n          }\n          if (aClass == null) {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n              DebuggerBundle.message(\"evaluation.error.cannot.sources.for.field.class\", psiField.getName())));\n          }\n          objectEvaluator = new ThisEvaluator(iterationCount);\n        }\n        myResult = new FieldEvaluator(objectEvaluator, JVMNameUtil.getJVMQualifiedName(fieldClass), psiField.getName());\n      } else {\n        //let's guess what this could be\n        PsiElement nameElement = expression.getReferenceNameElement(); // get \"b\" part\n        String name;\n        if (nameElement instanceof PsiIdentifier) {\n          name = nameElement.getText();\n        }\n        else {\n          //noinspection HardCodedStringLiteral\n          final String elementDisplayString = (nameElement != null ? nameElement.getText() : \"(null)\");\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.identifier.expected\", elementDisplayString)));\n        }\n\n        if(qualifier != null) {\n          final PsiElement qualifierTarget = (qualifier instanceof PsiReferenceExpression) ? ((PsiReferenceExpression)qualifier).resolve() : null;\n          if (qualifierTarget instanceof PsiClass) {\n            // this is a call to a 'static' field\n            PsiClass psiClass = (PsiClass)qualifierTarget;\n            final JVMName typeName = JVMNameUtil.getJVMQualifiedName(psiClass);\n            myResult = new FieldEvaluator(new TypeEvaluator(typeName), typeName, name);\n          }\n          else {\n            PsiType type = qualifier.getType();\n            if(type == null)\n              throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n                DebuggerBundle.message(\"evaluation.error.qualifier.type.unknown\", qualifier.getText()))\n              );\n\n            qualifier.accept(this);\n            if (myResult == null) {\n              throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n                DebuggerBundle.message(\"evaluation.error.cannot.evaluate.qualifier\", qualifier.getText()))\n              );\n            }\n\n            myResult = new FieldEvaluator(myResult, JVMNameUtil.getJVMQualifiedName(type), name);\n          }\n        }\n        else {\n          myResult = new LocalVariableEvaluator(name, false);\n        }\n      }\n    }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object evaluateField(Object object, EvaluationContextImpl context) throws EvaluateException {\n    if (object instanceof ReferenceType) {\n      ReferenceType refType = (ReferenceType)object;\n      Field field = findField(refType);\n      if (field == null || !field.isStatic()) {\n        field = refType.fieldByName(myFieldName);\n      }\n      if (field == null || !field.isStatic()) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.no.static.field\", myFieldName));\n      }\n      myEvaluatedField = field;\n      myEvaluatedQualifier = refType;\n      return refType.getValue(field);\n    }\n\n    if (object instanceof ObjectReference) {\n      ObjectReference objRef = (ObjectReference)object;\n      ReferenceType refType = objRef.referenceType();\n      if (!(refType instanceof ClassType || refType instanceof ArrayType)) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.class.or.array.expected\", myFieldName));\n      }\n\n      // expressions like 'array.length' must be treated separately\n      //noinspection HardCodedStringLiteral\n      if (objRef instanceof ArrayReference && \"length\".equals(myFieldName)) {\n        //noinspection HardCodedStringLiteral\n        return DebuggerUtilsEx.createValue(\n          context.getDebugProcess().getVirtualMachineProxy(),\n          \"int\",\n          ((ArrayReference)objRef).length()\n        );\n      }\n\n      Field field = findField(refType);\n      if (field == null) {\n        field = refType.fieldByName(myFieldName);\n      }\n\n      if (field == null) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.no.instance.field\", myFieldName));\n      }\n      myEvaluatedQualifier = field.isStatic()? (Object)refType : (Object)objRef;\n      myEvaluatedField = field;\n      return field.isStatic()? refType.getValue(field) : objRef.getValue(field);\n    }\n\n    if(object == null) {\n      throw EvaluateExceptionUtil.createEvaluateException(new NullPointerException());\n    }\n\n    throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.evaluating.field\", myFieldName));\n  }","id":84069,"modified_method":"private Object evaluateField(Object object, EvaluationContextImpl context) throws EvaluateException {\n    if (object instanceof ReferenceType) {\n      ReferenceType refType = (ReferenceType)object;\n      Field field = findField(refType, context);\n      if (field == null || !field.isStatic()) {\n        field = refType.fieldByName(myFieldName);\n      }\n      if (field == null || !field.isStatic()) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.no.static.field\", myFieldName));\n      }\n      myEvaluatedField = field;\n      myEvaluatedQualifier = refType;\n      return refType.getValue(field);\n    }\n\n    if (object instanceof ObjectReference) {\n      ObjectReference objRef = (ObjectReference)object;\n      ReferenceType refType = objRef.referenceType();\n      if (!(refType instanceof ClassType || refType instanceof ArrayType)) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.class.or.array.expected\", myFieldName));\n      }\n\n      // expressions like 'array.length' must be treated separately\n      //noinspection HardCodedStringLiteral\n      if (objRef instanceof ArrayReference && \"length\".equals(myFieldName)) {\n        //noinspection HardCodedStringLiteral\n        return DebuggerUtilsEx.createValue(\n          context.getDebugProcess().getVirtualMachineProxy(),\n          \"int\",\n          ((ArrayReference)objRef).length()\n        );\n      }\n\n      Field field = findField(refType, context);\n      if (field == null) {\n        field = refType.fieldByName(myFieldName);\n      }\n\n      if (field == null) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.no.instance.field\", myFieldName));\n      }\n      myEvaluatedQualifier = field.isStatic()? (Object)refType : (Object)objRef;\n      myEvaluatedField = field;\n      return field.isStatic()? refType.getValue(field) : objRef.getValue(field);\n    }\n\n    if(object == null) {\n      throw EvaluateExceptionUtil.createEvaluateException(new NullPointerException());\n    }\n\n    throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.evaluating.field\", myFieldName));\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FieldEvaluator(Evaluator objectEvaluator, String contextClass, String fieldName) {\n    myObjectEvaluator = objectEvaluator;\n    myClassName = contextClass;\n    myFieldName = fieldName;\n  }","id":84070,"modified_method":"public FieldEvaluator(Evaluator objectEvaluator, JVMName contextClass, String fieldName) {\n    myObjectEvaluator = objectEvaluator;\n    myClassName = contextClass;\n    myFieldName = fieldName;\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getNonAnonymousClassName(PsiClass aClass) {\n    PsiClass parentClass = PsiTreeUtil.getParentOfType(aClass, PsiClass.class, true);\n    if(parentClass != null) {\n      return getNonAnonymousClassName(parentClass) + \"$\" + aClass.getName();\n    }\n    else {\n      return aClass.getQualifiedName();\n    }\n  }","id":84071,"modified_method":"@Nullable\n  public static String getNonAnonymousClassName(PsiClass aClass) {\n    PsiClass parentClass = PsiTreeUtil.getParentOfType(aClass, PsiClass.class, true);\n    if(parentClass != null) {\n      final String parentName = getNonAnonymousClassName(parentClass);\n      if (parentName == null) {\n        return null;\n      }\n      return parentName + \"$\" + aClass.getName();\n    }\n    return aClass.getQualifiedName();\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static JVMName getJVMQualifiedName(PsiClass psiClass) {\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      return new JVMClassAt(SourcePosition.createFromElement(psiClass));\n    }\n    else {\n      final String name = getNonAnonymousClassName(psiClass);\n      return getJVMRawText(name != null? name : \"\");\n    }\n  }","id":84072,"modified_method":"public static JVMName getJVMQualifiedName(PsiClass psiClass) {\n    if (!PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      final String name = getNonAnonymousClassName(psiClass);\n      if (name != null) {\n        return getJVMRawText(name);\n      }\n    }\n    return new JVMClassAt(SourcePosition.createFromElement(psiClass));\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClassPrepareRequest createPrepareRequest(final ClassPrepareRequestor requestor, final SourcePosition position) {\n    PsiClass psiClass = JVMNameUtil.getClassAt(position);\n    if(psiClass == null) {\n      return null;\n    }\n\n    String waitPrepareFor;\n    ClassPrepareRequestor waitRequestor;\n\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      PsiClass parent = JVMNameUtil.getTopLevelParentClass(psiClass);\n\n      if(parent == null) {\n        return null;\n      }\n\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(parent) + \"$*\";\n      waitRequestor = new ClassPrepareRequestor() {\n        public void processClassPrepare(DebugProcess debuggerProcess, ReferenceType referenceType) {\n          final CompoundPositionManager positionManager = ((DebugProcessImpl)debuggerProcess).getPositionManager();\n          if (positionManager.locationsOfLine(referenceType, position).size() > 0) {\n            requestor.processClassPrepare(debuggerProcess, referenceType);\n          }\n          else {\n            final List<ReferenceType> positionClasses = positionManager.getAllClasses(position);\n            if (positionClasses.contains(referenceType)) {\n              requestor.processClassPrepare(debuggerProcess, referenceType);\n            }\n          }\n        }\n      };\n    }\n    else {\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(psiClass);\n      waitRequestor = requestor;\n    }\n    if (waitPrepareFor == null) {\n      return null;  // no suitable class found for this name\n    }\n    return myDebugProcess.getRequestsManager().createClassPrepareRequest(waitRequestor, waitPrepareFor);\n  }","id":84073,"modified_method":"public ClassPrepareRequest createPrepareRequest(final ClassPrepareRequestor requestor, final SourcePosition position) {\n    PsiClass psiClass = JVMNameUtil.getClassAt(position);\n    if(psiClass == null) {\n      return null;\n    }\n\n    String waitPrepareFor;\n    ClassPrepareRequestor waitRequestor;\n\n    if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n      PsiClass parent = JVMNameUtil.getTopLevelParentClass(psiClass);\n\n      if(parent == null) {\n        return null;\n      }\n\n      final String parentQName = JVMNameUtil.getNonAnonymousClassName(parent);\n      if (parentQName == null) {\n        return null;\n      }\n      waitPrepareFor = parentQName + \"$*\";\n      waitRequestor = new ClassPrepareRequestor() {\n        public void processClassPrepare(DebugProcess debuggerProcess, ReferenceType referenceType) {\n          final CompoundPositionManager positionManager = ((DebugProcessImpl)debuggerProcess).getPositionManager();\n          if (positionManager.locationsOfLine(referenceType, position).size() > 0) {\n            requestor.processClassPrepare(debuggerProcess, referenceType);\n          }\n          else {\n            final List<ReferenceType> positionClasses = positionManager.getAllClasses(position);\n            if (positionClasses.contains(referenceType)) {\n              requestor.processClassPrepare(debuggerProcess, referenceType);\n            }\n          }\n        }\n      };\n    }\n    else {\n      waitPrepareFor = JVMNameUtil.getNonAnonymousClassName(psiClass);\n      waitRequestor = requestor;\n    }\n    if (waitPrepareFor == null) {\n      return null;  // no suitable class found for this name\n    }\n    return myDebugProcess.getRequestsManager().createClassPrepareRequest(waitRequestor, waitPrepareFor);\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<ReferenceType> getAllClasses(final SourcePosition classPosition) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<List<ReferenceType>> () {\n      public List<ReferenceType> compute() {\n        final PsiClass psiClass = JVMNameUtil.getClassAt(classPosition);\n\n        if(psiClass == null) {\n          return Collections.emptyList();\n        }\n\n        if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n          final PsiClass parentNonLocal = JVMNameUtil.getTopLevelParentClass(psiClass);\n          if(parentNonLocal == null) {\n            LOG.assertTrue(false, \"Local class has no non-local parent\");\n            return Collections.emptyList();\n          }\n          final String parentClassName = JVMNameUtil.getNonAnonymousClassName(parentNonLocal);\n          final List<ReferenceType> outer = myDebugProcess.getVirtualMachineProxy().classesByName(parentClassName);\n          final List<ReferenceType> result = new ArrayList<ReferenceType>();\n          findNested(outer, classPosition, result);\n          if (result.size() == 0) {\n            // no executable code found at this line in any class\n            for (ReferenceType refType : outer) {\n              final ReferenceType closest = findClosestClassAt(refType, classPosition, psiClass);\n              if (closest != null) {\n                result.add(closest);\n              }\n            }\n          }\n          return result;\n        }\n        else {\n          final String className = JVMNameUtil.getNonAnonymousClassName(psiClass);\n          if (className == null) {\n            return Collections.emptyList();\n          }\n          return myDebugProcess.getVirtualMachineProxy().classesByName(className);\n        }\n      }\n    });\n  }","id":84074,"modified_method":"public List<ReferenceType> getAllClasses(final SourcePosition classPosition) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<List<ReferenceType>> () {\n      public List<ReferenceType> compute() {\n        final PsiClass psiClass = JVMNameUtil.getClassAt(classPosition);\n\n        if(psiClass == null) {\n          return Collections.emptyList();\n        }\n\n        if(PsiUtil.isLocalOrAnonymousClass(psiClass)) {\n          final PsiClass parentNonLocal = JVMNameUtil.getTopLevelParentClass(psiClass);\n          if(parentNonLocal == null) {\n            LOG.assertTrue(false, \"Local or anonymous class has no non-local parent\");\n            return Collections.emptyList();\n          }\n          final String parentClassName = JVMNameUtil.getNonAnonymousClassName(parentNonLocal);\n          if(parentClassName == null) {\n            LOG.assertTrue(false, \"The name of a parent of a local (anonymous) class is null\");\n            return Collections.emptyList();\n          }\n          final List<ReferenceType> outer = myDebugProcess.getVirtualMachineProxy().classesByName(parentClassName);\n          final List<ReferenceType> result = new ArrayList<ReferenceType>();\n          findNested(outer, classPosition, result);\n          if (result.size() == 0) {\n            // no executable code found at this line in any class\n            for (ReferenceType refType : outer) {\n              final ReferenceType closest = findClosestClassAt(refType, classPosition, psiClass);\n              if (closest != null) {\n                result.add(closest);\n              }\n            }\n          }\n          return result;\n        }\n        else {\n          final String className = JVMNameUtil.getNonAnonymousClassName(psiClass);\n          if (className == null) {\n            return Collections.emptyList();\n          }\n          return myDebugProcess.getVirtualMachineProxy().classesByName(className);\n        }\n      }\n    });\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static SourcePosition createFromElement(PsiElement element) {\n    PsiElement navigationElement = element.getNavigationElement();\n    return createFromOffset(navigationElement.getContainingFile(), navigationElement.getTextOffset());\n  }","id":84075,"modified_method":"public static SourcePosition createFromElement(PsiElement element) {\n    PsiElement navigationElement = element.getNavigationElement();\n    final PsiFile psiFile;\n    if (PsiUtil.isInJspFile(navigationElement)) {\n      psiFile = PsiUtil.getJspFile(navigationElement);\n    }\n    else {\n      psiFile = navigationElement.getContainingFile();\n    }\n    return createFromOffset(psiFile, navigationElement.getTextOffset());\n  }","commit_id":"d9d82a5455e33c5fbaa5b9ebd016d08c54249284","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void acceptStaticImport(JvmMember member) {\n\t\t\tfinal JvmDeclaredType declaringType = member.getDeclaringType();\n\t\t\tJvmDeclaredType currentlyChecked = thisType;\n\t\t\twhile (currentlyChecked != null) {\n\t\t\t\tif (currentlyChecked == declaringType)\n\t\t\t\t\treturn;\n\t\t\t\tfinal JvmTypeReference typeRefToSuperClass = IterableExtensions.findFirst(currentlyChecked.getSuperTypes(), new Function1<JvmTypeReference, Boolean>(){\n\t\t\t\t\tpublic Boolean apply(JvmTypeReference type) {\n\t\t\t\t\t\tif (type.getType() instanceof JvmGenericType) {\n\t\t\t\t\t\t\tJvmGenericType genericType = (JvmGenericType) type.getType();\n\t\t\t\t\t\t\treturn !genericType.isInterface();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcurrentlyChecked = typeRefToSuperClass==null?null: (JvmDeclaredType) typeRefToSuperClass.getType();\n\t\t\t}\n\t\t\t\n\t\t\tstaticMembers.add(declaringType);\n\t\t}","id":84076,"modified_method":"public void acceptStaticImport(JvmMember member) {\n\t\t\tif (thisType == member.getDeclaringType())\n\t\t\t\treturn;\n\t\t\tif (knownTypesForStaticImports == null) {\n\t\t\t\tJvmParameterizedTypeReference reference = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();\n\t\t\t\treference.setType(thisType);\n\t\t\t\tknownTypesForStaticImports = superTypeCollector.collectSuperTypesAsRawTypes(reference);\n\t\t\t}\n\t\t\tif (knownTypesForStaticImports.contains(member.getDeclaringType()))\n\t\t\t\treturn;\n\t\t\tstaticMembers.add(member.getDeclaringType());\n\t\t}","commit_id":"5c040e2144f30b44f112d382e94b0977b31b8cf1","url":"https://github.com/eclipse/xtext"},{"original_method":"public void setThisType(JvmDeclaredType declaredType) {\n\t\t\tthis.thisType = declaredType;\n\t\t}","id":84077,"modified_method":"public void setThisType(JvmDeclaredType declaredType) {\n\t\t\tthis.thisType = declaredType;\n\t\t\tknownTypesForStaticImports = null;\n\t\t}","commit_id":"5c040e2144f30b44f112d382e94b0977b31b8cf1","url":"https://github.com/eclipse/xtext"},{"original_method":"public void acceptType(JvmTypeReference ref) {\n\t\t\tif (ref instanceof XFunctionTypeRef || ref instanceof WildcardTypeReference)\n\t\t\t\treturn;\n\t\t\tif (ref.eContainer() instanceof XFunctionTypeRef && ref.eContainmentFeature() == TypesPackage.Literals.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT)\n\t\t\t\treturn;\n\t\t\tacceptType(ref.getType());\n\t\t\tif (ref instanceof JvmParameterizedTypeReference) {\n\t\t\t\tEList<JvmTypeReference> list = ((JvmParameterizedTypeReference) ref).getArguments();\n\t\t\t\tfor (JvmTypeReference jvmTypeReference : list) {\n\t\t\t\t\tacceptType(jvmTypeReference);\n\t\t\t\t}\n\t\t\t} else if (ref instanceof JvmWildcardTypeReference) {\n\t\t\t\tEList<JvmTypeConstraint> constraints = ((JvmWildcardTypeReference) ref).getConstraints();\n\t\t\t\tfor (JvmTypeConstraint jvmTypeConstraint : constraints) {\n\t\t\t\t\tacceptType(jvmTypeConstraint.getTypeReference());\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":84078,"modified_method":"public void acceptType(JvmTypeReference ref) {\n\t\t\tif (ref instanceof XFunctionTypeRef)\n\t\t\t\treturn;\n\t\t\tif (ref.eContainer() instanceof XFunctionTypeRef && ref.eContainmentFeature() == TypesPackage.Literals.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT)\n\t\t\t\treturn;\n\t\t\tacceptType(ref.getType());\n\t\t\tif (ref instanceof JvmParameterizedTypeReference) {\n\t\t\t\tEList<JvmTypeReference> list = ((JvmParameterizedTypeReference) ref).getArguments();\n\t\t\t\tfor (JvmTypeReference jvmTypeReference : list) {\n\t\t\t\t\tacceptType(jvmTypeReference);\n\t\t\t\t}\n\t\t\t} else if (ref instanceof JvmWildcardTypeReference) {\n\t\t\t\tEList<JvmTypeConstraint> constraints = ((JvmWildcardTypeReference) ref).getConstraints();\n\t\t\t\tfor (JvmTypeConstraint jvmTypeConstraint : constraints) {\n\t\t\t\t\tacceptType(jvmTypeConstraint.getTypeReference());\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"5c040e2144f30b44f112d382e94b0977b31b8cf1","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test public void testBug380637() throws Exception {\n\t\tString model =  \"class MyExtensionLib {\\n\" + \n\t\t\t\t\t\t\"    def static func1 (String a, int b) { \" +\n\t\t\t\t\t\t\"       func1(a,b)\" +\n\t\t\t\t\t\t\"    }\\n\" + \n\t\t\t\t\t\t\"}\";\n\t\tXtendFile file = file(model, false);\n\t\tString section = organizeImports.getOrganizedImportSection((XtextResource) file.eResource());\n\t\t\n\t\tassertEquals(\"\", section);\n\t}","id":84079,"modified_method":"@Test public void testBug380637_02() throws Exception {\n\t\tString model =  \n\t\t\t\t\"abstract class MyClass implements org.eclipse.xtext.scoping.IScope {\\n\" + \n\t\t\t\t\"    org.eclipse.xtext.scoping.IScope scope = NULLSCOPE\" + \n\t\t\t\t\"}\";\n\t\tXtendFile file = file(model, false);\n\t\tString section = organizeImports.getOrganizedImportSection((XtextResource) file.eResource());\n\t\t\n\t\tassertEquals(\"\\n\\nimport org.eclipse.xtext.scoping.IScope\", section);\n\t}","commit_id":"5c040e2144f30b44f112d382e94b0977b31b8cf1","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean isVisible(final JvmMember jvmMember, JvmDeclaredType contextType) {\n\t\tif (jvmMember.getVisibility() == JvmVisibility.PUBLIC)\n\t\t\treturn true;\n\t\tif (contextType == null) {\n\t\t\treturn false;\n\t\t} else if (jvmMember.getVisibility() == JvmVisibility.DEFAULT) {\n\t\t\tif (jvmMember instanceof JvmDeclaredType) {\n\t\t\t\treturn equal(((JvmDeclaredType) jvmMember).getPackageName(), contextType.getPackageName());\n\t\t\t} else {\n\t\t\t\treturn equal(jvmMember.getDeclaringType().getPackageName(), contextType.getPackageName());\n\t\t\t}\n\t\t} else if (contextType.equals(jvmMember.getDeclaringType())) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tJvmParameterizedTypeReference typeReference = typesFactory.createJvmParameterizedTypeReference();\n\t\t\ttypeReference.setType(contextType);\n\t\t\tSet<JvmType> rawTypes = superTypeCollector.collectSuperTypesAsRawTypes(typeReference);\n\t\t\tif (rawTypes.contains(jvmMember.getDeclaringType())) {\n\t\t\t\treturn jvmMember.getVisibility() == JvmVisibility.PROTECTED;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}","id":84080,"modified_method":"public boolean isVisible(final JvmMember jvmMember, JvmDeclaredType contextType) {\n\t\tif (jvmMember.getVisibility() == JvmVisibility.PUBLIC)\n\t\t\treturn true;\n\t\tif (contextType == null) {\n\t\t\treturn false;\n\t\t} else if (jvmMember.getVisibility() == JvmVisibility.DEFAULT) {\n\t\t\tif (jvmMember instanceof JvmDeclaredType) {\n\t\t\t\treturn equal(((JvmDeclaredType) jvmMember).getPackageName(), contextType.getPackageName());\n\t\t\t} else {\n\t\t\t\tJvmDeclaredType declaringType = jvmMember.getDeclaringType();\n\t\t\t\tif (declaringType != null)\n\t\t\t\t\treturn equal(declaringType.getPackageName(), contextType.getPackageName());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (contextType.equals(jvmMember.getDeclaringType())) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tJvmParameterizedTypeReference typeReference = typesFactory.createJvmParameterizedTypeReference();\n\t\t\ttypeReference.setType(contextType);\n\t\t\tSet<JvmType> rawTypes = superTypeCollector.collectSuperTypesAsRawTypes(typeReference);\n\t\t\tif (rawTypes.contains(jvmMember.getDeclaringType())) {\n\t\t\t\treturn jvmMember.getVisibility() == JvmVisibility.PROTECTED;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"dad04f72f010ef9165e6a4bb9453d1098bcdbe9b","url":"https://github.com/eclipse/xtext"},{"original_method":"public void acceptType(JvmType type) {\n\t\t\ttypes.add(type);\n\t\t}","id":84081,"modified_method":"public void acceptType(JvmType type) {\n\t\t\tif (type != null && !type.equals(this.thisType)) {\n\t\t\t\ttypes.add(type);\n\t\t\t}\n\t\t}","commit_id":"e59336ec643a9892a20bfa197defecc2c989404f","url":"https://github.com/eclipse/xtext"},{"original_method":"public void collectAllReferences(XtextResource resource, ReferenceAcceptor acceptor) {\n\t\tXtendFile xtendFile = getXtendFile(resource);\n\t\tTreeIterator<EObject> contents = EcoreUtil.getAllContents(xtendFile, true);\n\t\twhile (contents.hasNext()) {\n\t\t\tEObject next = contents.next();\n\t\t\tif (next instanceof JvmTypeReference) {\n\t\t\t\tacceptor.acceptType((JvmTypeReference) next);\n\t\t\t} else if (next instanceof XAnnotation) {\n\t\t\t\tacceptor.acceptType(((XAnnotation) next).getAnnotationType());\n\t\t\t} else if (next instanceof XInstanceOfExpression) {\n\t\t\t\tacceptor.acceptType(((XInstanceOfExpression) next).getType());\n\t\t\t} else if (next instanceof XConstructorCall) {\n\t\t\t\tacceptor.acceptType(((XConstructorCall) next).getConstructor().getDeclaringType());\n\t\t\t} else if (next instanceof XTypeLiteral) {\n\t\t\t\tacceptor.acceptType(((XTypeLiteral) next).getType());\n\t\t\t} else if (next instanceof XFeatureCall) {\n\t\t\t\tfinal XFeatureCall featureCall = (XFeatureCall) next;\n\t\t\t\tif (featureCall.getDeclaringType() == null) {\n\t\t\t\t\tfinal JvmIdentifiableElement member = featureCall.getFeature();\n\t\t\t\t\tif (member instanceof JvmOperation) {\n\t\t\t\t\t\tJvmOperation operation = (JvmOperation) member;\n\t\t\t\t\t\tif (operation.isStatic()) {\n\t\t\t\t\t\t\tif (operation.getParameters().size() > featureCall.getExplicitArguments().size()) {\n\t\t\t\t\t\t\t\tacceptor.acceptStaticExtensionImport(operation);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tacceptor.acceptStaticImport(operation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (member instanceof JvmField) {\n\t\t\t\t\t\tif (((JvmField) member).isStatic()) {\n\t\t\t\t\t\t\tacceptor.acceptStaticImport((JvmMember) member);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tacceptor.acceptType(featureCall.getDeclaringType());\n\t\t\t\t}\n\t\t\t} else if (next instanceof XMemberFeatureCall || next instanceof XBinaryOperation || next instanceof XUnaryOperation || next instanceof XAssignment) {\n\t\t\t\tfinal XAbstractFeatureCall featureCall = (XAbstractFeatureCall) next;\n\t\t\t\tfinal JvmIdentifiableElement member = featureCall.getFeature();\n\t\t\t\tif (member instanceof JvmOperation) {\n\t\t\t\t\tif (((JvmOperation) member).isStatic())\n\t\t\t\t\t\tacceptor.acceptStaticExtensionImport((JvmMember) member);\n\t\t\t\t}\n\t\t\t\tif (member instanceof JvmField) {\n\t\t\t\t\tif (((JvmField) member).isStatic())\n\t\t\t\t\t\tacceptor.acceptStaticExtensionImport((JvmMember) member);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":84082,"modified_method":"public void collectAllReferences(XtextResource resource, ReferenceAcceptor acceptor) {\n\t\tXtendFile xtendFile = getXtendFile(resource);\n\t\tTreeIterator<EObject> contents = EcoreUtil.getAllContents(xtendFile, true);\n\t\twhile (contents.hasNext()) {\n\t\t\tEObject next = contents.next();\n\t\t\tif (next instanceof XtendTypeDeclaration) {\n\t\t\t\tSet<EObject> elements = associations.getJvmElements(next);\n\t\t\t\tif (!elements.isEmpty()) {\n\t\t\t\t\tEObject type = elements.iterator().next();\n\t\t\t\t\tif (type instanceof JvmDeclaredType) {\n\t\t\t\t\t\tacceptor.setThisType((JvmDeclaredType) type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (next instanceof JvmTypeReference) {\n\t\t\t\tacceptor.acceptType((JvmTypeReference) next);\n\t\t\t} else if (next instanceof XAnnotation) {\n\t\t\t\tacceptor.acceptType(((XAnnotation) next).getAnnotationType());\n\t\t\t} else if (next instanceof XInstanceOfExpression) {\n\t\t\t\tacceptor.acceptType(((XInstanceOfExpression) next).getType());\n\t\t\t} else if (next instanceof XConstructorCall) {\n\t\t\t\tacceptor.acceptType(((XConstructorCall) next).getConstructor().getDeclaringType());\n\t\t\t} else if (next instanceof XTypeLiteral) {\n\t\t\t\tacceptor.acceptType(((XTypeLiteral) next).getType());\n\t\t\t} else if (next instanceof XFeatureCall) {\n\t\t\t\tfinal XFeatureCall featureCall = (XFeatureCall) next;\n\t\t\t\tif (featureCall.getDeclaringType() == null) {\n\t\t\t\t\tfinal JvmIdentifiableElement member = featureCall.getFeature();\n\t\t\t\t\tif (member instanceof JvmOperation) {\n\t\t\t\t\t\tJvmOperation operation = (JvmOperation) member;\n\t\t\t\t\t\tif (operation.isStatic()) {\n\t\t\t\t\t\t\tif (operation.getParameters().size() > featureCall.getExplicitArguments().size()) {\n\t\t\t\t\t\t\t\tacceptor.acceptStaticExtensionImport(operation);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tacceptor.acceptStaticImport(operation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (member instanceof JvmField) {\n\t\t\t\t\t\tif (((JvmField) member).isStatic()) {\n\t\t\t\t\t\t\tacceptor.acceptStaticImport((JvmMember) member);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tacceptor.acceptType(featureCall.getDeclaringType());\n\t\t\t\t}\n\t\t\t} else if (next instanceof XMemberFeatureCall || next instanceof XBinaryOperation || next instanceof XUnaryOperation || next instanceof XAssignment) {\n\t\t\t\tfinal XAbstractFeatureCall featureCall = (XAbstractFeatureCall) next;\n\t\t\t\tfinal JvmIdentifiableElement member = featureCall.getFeature();\n\t\t\t\tif (member instanceof JvmOperation) {\n\t\t\t\t\tif (((JvmOperation) member).isStatic())\n\t\t\t\t\t\tacceptor.acceptStaticExtensionImport((JvmMember) member);\n\t\t\t\t}\n\t\t\t\tif (member instanceof JvmField) {\n\t\t\t\t\tif (((JvmField) member).isStatic())\n\t\t\t\t\t\tacceptor.acceptStaticExtensionImport((JvmMember) member);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"e59336ec643a9892a20bfa197defecc2c989404f","url":"https://github.com/eclipse/xtext"},{"original_method":"public void acceptStaticImport(JvmMember member) {\n\t\t\tstaticMembers.add(member.getDeclaringType());\n\t\t}","id":84083,"modified_method":"public void acceptStaticImport(JvmMember member) {\n\t\t\tfinal JvmDeclaredType declaringType = member.getDeclaringType();\n\t\t\tJvmDeclaredType currentlyChecked = thisType;\n\t\t\twhile (currentlyChecked != null) {\n\t\t\t\tif (currentlyChecked == declaringType)\n\t\t\t\t\treturn;\n\t\t\t\tfinal JvmTypeReference typeRefToSuperClass = IterableExtensions.findFirst(currentlyChecked.getSuperTypes(), new Function1<JvmTypeReference, Boolean>(){\n\t\t\t\t\tpublic Boolean apply(JvmTypeReference type) {\n\t\t\t\t\t\tif (type.getType() instanceof JvmGenericType) {\n\t\t\t\t\t\t\tJvmGenericType genericType = (JvmGenericType) type.getType();\n\t\t\t\t\t\t\treturn !genericType.isInterface();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcurrentlyChecked = typeRefToSuperClass==null?null: (JvmDeclaredType) typeRefToSuperClass.getType();\n\t\t\t}\n\t\t\t\n\t\t\tstaticMembers.add(declaringType);\n\t\t}","commit_id":"e59336ec643a9892a20bfa197defecc2c989404f","url":"https://github.com/eclipse/xtext"},{"original_method":"public void acceptType(JvmTypeReference ref) {\n\t\t\tif (ref instanceof XFunctionTypeRef)\n\t\t\t\treturn;\n\t\t\tif (ref.eContainer() instanceof XFunctionTypeRef && ref.eContainmentFeature() == TypesPackage.Literals.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT)\n\t\t\t\treturn;\n\t\t\tacceptType(ref.getType());\n\t\t\tif (ref instanceof JvmParameterizedTypeReference) {\n\t\t\t\tEList<JvmTypeReference> list = ((JvmParameterizedTypeReference) ref).getArguments();\n\t\t\t\tfor (JvmTypeReference jvmTypeReference : list) {\n\t\t\t\t\tacceptType(jvmTypeReference);\n\t\t\t\t}\n\t\t\t} else if (ref instanceof JvmWildcardTypeReference) {\n\t\t\t\tEList<JvmTypeConstraint> constraints = ((JvmWildcardTypeReference) ref).getConstraints();\n\t\t\t\tfor (JvmTypeConstraint jvmTypeConstraint : constraints) {\n\t\t\t\t\tacceptType(jvmTypeConstraint.getTypeReference());\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":84084,"modified_method":"public void acceptType(JvmTypeReference ref) {\n\t\t\tif (ref instanceof XFunctionTypeRef || ref instanceof WildcardTypeReference)\n\t\t\t\treturn;\n\t\t\tif (ref.eContainer() instanceof XFunctionTypeRef && ref.eContainmentFeature() == TypesPackage.Literals.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT)\n\t\t\t\treturn;\n\t\t\tacceptType(ref.getType());\n\t\t\tif (ref instanceof JvmParameterizedTypeReference) {\n\t\t\t\tEList<JvmTypeReference> list = ((JvmParameterizedTypeReference) ref).getArguments();\n\t\t\t\tfor (JvmTypeReference jvmTypeReference : list) {\n\t\t\t\t\tacceptType(jvmTypeReference);\n\t\t\t\t}\n\t\t\t} else if (ref instanceof JvmWildcardTypeReference) {\n\t\t\t\tEList<JvmTypeConstraint> constraints = ((JvmWildcardTypeReference) ref).getConstraints();\n\t\t\t\tfor (JvmTypeConstraint jvmTypeConstraint : constraints) {\n\t\t\t\t\tacceptType(jvmTypeConstraint.getTypeReference());\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"e59336ec643a9892a20bfa197defecc2c989404f","url":"https://github.com/eclipse/xtext"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n        throws XPathException {\n        int arg = 0;\n        if (args[arg].isEmpty()) {\n            return Sequence.EMPTY_SEQUENCE;\n        }\n        NodeSet nodes = args[arg++].toNodeSet();\n        DocumentSet docs = nodes.getDocumentSet();\n        QName[] qnames = null;\n        if (args.length == 5) {\n            qnames = new QName[args[arg].getItemCount()];\n            int q = 0;\n            for (SequenceIterator i = args[arg].iterate(); i.hasNext(); q++) {\n                QNameValue qnv = (QNameValue) i.nextItem();\n                qnames[q] = qnv.getQName();\n            }\n            ++arg;\n        }\n        String start = null;\n        if (!args[arg].isEmpty())\n            start = args[arg].getStringValue();\n        FunctionReference ref = (FunctionReference) args[++arg].itemAt(0);\n        int max = ((IntegerValue) args[++arg].itemAt(0)).getInt();\n        FunctionCall call = ref.getFunctionCall();\n        Sequence result = new ValueSequence();\n        try {\n            Occurrences occur[];\n            if (qnames == null)\n                occur = context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, start, null);\n            else\n                occur = context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, qnames, start, null);\n            int len = (occur.length > max ? max : occur.length);\n            Sequence params[] = new Sequence[2];\n            ValueSequence data = new ValueSequence();\n\n            Vector list = new Vector(len);\n            for (int j = 0; j < len; j++) {\n                if (!list.contains(new Integer(occur[j].getOccurrences()))) {\n                    list.add(new Integer(occur[j].getOccurrences()));\n                }\n            }\n            Collections.sort(list);\n            Collections.reverse(list);\n            HashMap map = new HashMap(list.size() * 2);\n            for (int j = 0; j < list.size(); j++) {\n                map.put(list.get(j), new Integer(j + 1));\n            }\n\n            for (int j = 0; j < len; j++) {\n                params[0] = new StringValue(occur[j].getTerm().toString());\n                data.add(new IntegerValue(occur[j].getOccurrences(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(occur[j].getDocuments(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(j + 1, Type.UNSIGNED_INT));\n                data.add(new IntegerValue(((Integer) map.get(new Integer(occur[j].getOccurrences()))).intValue(), Type.UNSIGNED_INT));\n\n                params[1] = data;\n\n                result.addAll(call.evalFunction(contextSequence, null, params));\n                data.clear();\n            }\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Returning: \" + result.getItemCount());\n            return result;\n        } catch (PermissionDeniedException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        }\n    }","id":84085,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n        throws XPathException {\n        int arg = 0;\n        if (args[arg].isEmpty()) {\n            return Sequence.EMPTY_SEQUENCE;\n        }\n        NodeSet nodes = args[arg++].toNodeSet();\n        DocumentSet docs = nodes.getDocumentSet();\n        QName[] qnames = null;\n        if (args.length == 5) {\n            qnames = new QName[args[arg].getItemCount()];\n            int q = 0;\n            for (SequenceIterator i = args[arg].iterate(); i.hasNext(); q++) {\n                QNameValue qnv = (QNameValue) i.nextItem();\n                qnames[q] = qnv.getQName();\n            }\n            ++arg;\n        } else\n            qnames = getDefinedIndexes(context.getBroker(), docs);\n        String start = null;\n        if (!args[arg].isEmpty())\n            start = args[arg].getStringValue();\n        FunctionReference ref = (FunctionReference) args[++arg].itemAt(0);\n        int max = ((IntegerValue) args[++arg].itemAt(0)).getInt();\n        FunctionCall call = ref.getFunctionCall();\n        Sequence result = new ValueSequence();\n        try {\n            Occurrences occur[] = context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, qnames, start, null);\n            if (args.length == 4) {\n                Occurrences occur2[] = context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, start, null);\n                if (occur == null || occur.length == 0)\n                    occur = occur2;\n                else {\n                    Occurrences t[] = new Occurrences[occur.length + occur2.length];\n                    System.arraycopy(occur, 0, t, 0, occur.length);\n                    System.arraycopy(occur2, 0, t, occur.length, occur2.length);\n                    occur = t;\n                }\n            }\n            int len = (occur.length > max ? max : occur.length);\n            Sequence params[] = new Sequence[2];\n            ValueSequence data = new ValueSequence();\n\n            Vector list = new Vector(len);\n            for (int j = 0; j < len; j++) {\n                if (!list.contains(new Integer(occur[j].getOccurrences()))) {\n                    list.add(new Integer(occur[j].getOccurrences()));\n                }\n            }\n            Collections.sort(list);\n            Collections.reverse(list);\n            HashMap map = new HashMap(list.size() * 2);\n            for (int j = 0; j < list.size(); j++) {\n                map.put(list.get(j), new Integer(j + 1));\n            }\n\n            for (int j = 0; j < len; j++) {\n                params[0] = new StringValue(occur[j].getTerm().toString());\n                data.add(new IntegerValue(occur[j].getOccurrences(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(occur[j].getDocuments(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(j + 1, Type.UNSIGNED_INT));\n                data.add(new IntegerValue(((Integer) map.get(new Integer(occur[j].getOccurrences()))).intValue(), Type.UNSIGNED_INT));\n\n                params[1] = data;\n\n                result.addAll(call.evalFunction(contextSequence, null, params));\n                data.clear();\n            }\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Returning: \" + result.getItemCount());\n            return result;\n        } catch (PermissionDeniedException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        }\n    }","commit_id":"217832f364842e3989e091fdf858e0fcb29cfcd6","url":"https://github.com/eXist-db/exist"},{"original_method":"public IndexTerms(XQueryContext context) {\n        super(context, signature);\n    }","id":84086,"modified_method":"public IndexTerms(XQueryContext context, FunctionSignature signature) {\n        super(context, signature);\n    }","commit_id":"0e82f18babefef3b937ec6175da2ea816621a819","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n            throws XPathException {\n        if(args[0].isEmpty())\n            return Sequence.EMPTY_SEQUENCE;\n        NodeSet nodes = args[0].toNodeSet();\n        DocumentSet docs = nodes.getDocumentSet();\n        String start = null;\n        if (!args[1].isEmpty())\n            start = args[1].getStringValue();\n        FunctionReference ref = (FunctionReference) args[2].itemAt(0);\n        int max = ((IntegerValue) args[3].itemAt(0)).getInt();\n        FunctionCall call = ref.getFunctionCall();\n        Sequence result = new ValueSequence();\n        try {\n            Occurrences occur[] = \n                context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, start, null);\n            int len = (occur.length > max ? max : occur.length);\n            Sequence params[] = new Sequence[2];\n            ValueSequence data = new ValueSequence();\n\n\t    Vector list = new Vector(len);\n\t    for (int j = 0; j < len; j++) {\n\t\tif (!list.contains(new Integer(occur[j].getOccurrences()))) {\n\t\t    list.add(new Integer(occur[j].getOccurrences()));\n\t\t}\n\t    }\n\t    Collections.sort(list);\n\t    Collections.reverse(list);\n\t    HashMap map = new HashMap(list.size() * 2);\n\t    for (int j = 0; j < list.size(); j++) {\n\t\tmap.put((Integer) list.get(j), new Integer(j + 1));\n\t    }\n\n            for (int j = 0; j < len; j++) {\n                params[0] = new StringValue(occur[j].getTerm().toString());\n                data.add(new IntegerValue(occur[j].getOccurrences(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(occur[j].getDocuments(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(j + 1, Type.UNSIGNED_INT));\n                data.add(new IntegerValue(((Integer) map.get(new Integer(occur[j].getOccurrences()))).intValue(), Type.UNSIGNED_INT));\n\n                params[1] = data;\n                \n                result.addAll(call.evalFunction(contextSequence, null, params));\n                data.clear();\n            }\n            if (LOG.isDebugEnabled()) \n            \tLOG.debug(\"Returning: \" + result.getItemCount());\n            return result;\n        } catch (PermissionDeniedException e) {\n        \tthrow new XPathException(getASTNode(), e.getMessage(), e);\n        }\n    }","id":84087,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n        throws XPathException {\n        int arg = 0;\n        if (args[arg].isEmpty()) {\n            return Sequence.EMPTY_SEQUENCE;\n        }\n        NodeSet nodes = args[arg++].toNodeSet();\n        DocumentSet docs = nodes.getDocumentSet();\n        QName[] qnames = null;\n        if (args.length == 5) {\n            qnames = new QName[args[arg].getItemCount()];\n            int q = 0;\n            for (SequenceIterator i = args[arg].iterate(); i.hasNext(); q++) {\n                QNameValue qnv = (QNameValue) i.nextItem();\n                qnames[q] = qnv.getQName();\n            }\n            ++arg;\n        }\n        String start = null;\n        if (!args[arg].isEmpty())\n            start = args[arg].getStringValue();\n        FunctionReference ref = (FunctionReference) args[++arg].itemAt(0);\n        int max = ((IntegerValue) args[++arg].itemAt(0)).getInt();\n        FunctionCall call = ref.getFunctionCall();\n        Sequence result = new ValueSequence();\n        try {\n            Occurrences occur[];\n            if (qnames == null)\n                occur = context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, start, null);\n            else\n                occur = context.getBroker().getTextEngine().scanIndexTerms(docs, nodes, qnames, start, null);\n            int len = (occur.length > max ? max : occur.length);\n            Sequence params[] = new Sequence[2];\n            ValueSequence data = new ValueSequence();\n\n            Vector list = new Vector(len);\n            for (int j = 0; j < len; j++) {\n                if (!list.contains(new Integer(occur[j].getOccurrences()))) {\n                    list.add(new Integer(occur[j].getOccurrences()));\n                }\n            }\n            Collections.sort(list);\n            Collections.reverse(list);\n            HashMap map = new HashMap(list.size() * 2);\n            for (int j = 0; j < list.size(); j++) {\n                map.put(list.get(j), new Integer(j + 1));\n            }\n\n            for (int j = 0; j < len; j++) {\n                params[0] = new StringValue(occur[j].getTerm().toString());\n                data.add(new IntegerValue(occur[j].getOccurrences(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(occur[j].getDocuments(), Type.UNSIGNED_INT));\n                data.add(new IntegerValue(j + 1, Type.UNSIGNED_INT));\n                data.add(new IntegerValue(((Integer) map.get(new Integer(occur[j].getOccurrences()))).intValue(), Type.UNSIGNED_INT));\n\n                params[1] = data;\n\n                result.addAll(call.evalFunction(contextSequence, null, params));\n                data.clear();\n            }\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Returning: \" + result.getItemCount());\n            return result;\n        } catch (PermissionDeniedException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        }\n    }","commit_id":"0e82f18babefef3b937ec6175da2ea816621a819","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tpublic void onDetach() {\n\t\tsuper.onDetach();\n\t\tplugin.setGroupsActivity(null);\n\t}","id":84088,"modified_method":"@Override\n\tpublic void onDetach() {\n\t\tsuper.onDetach();\n\t\tif (plugin != null) {\n\t\t\tplugin.setGroupsActivity(null);\n\t\t}\n\t}","commit_id":"d5a7da07e5924cf5b04364cd24c4920fc58b6fd7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onOpenDash() {\n\t\tplugin = OsmandPlugin.getEnabledPlugin(OsMoPlugin.class);\n\t\tif (plugin != null) {\n\t\t\tplugin.getGroups().addUiListeners(this);\n\t\t}\n\t\tsetupOsMoView();\n\t\tplugin.setGroupsActivity(getActivity());\n\t}","id":84089,"modified_method":"@Override\n\tpublic void onOpenDash() {\n\t\tplugin = OsmandPlugin.getEnabledPlugin(OsMoPlugin.class);\n\t\tif (plugin != null) {\n\t\t\tplugin.getGroups().addUiListeners(this);\n\t\t\tplugin.setGroupsActivity(getActivity());\n\t\t}\n\t\tsetupOsMoView();\n\t\t\n\t}","commit_id":"d5a7da07e5924cf5b04364cd24c4920fc58b6fd7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updateStatus() {\n\n\t\tView header = getView();\n\t\tif (getView() == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tView cardContent = header.findViewById(R.id.card_content);\n\t\tView enableOsmo = header.findViewById(R.id.header_layout).findViewById(R.id.check_item);\n\t\tView manage = header.findViewById(R.id.manage);\n\t\tif (plugin == null || plugin.getService().isEnabled() ) {\n\t\t\tcardContent.setVisibility(View.VISIBLE);\n\t\t\tenableOsmo.setVisibility(View.GONE);\n\t\t\tmanage.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tcardContent.setVisibility(View.GONE);\n\t\t\tenableOsmo.setVisibility(View.VISIBLE);\n\t\t\tmanage.setVisibility(View.GONE);\n\t\t\tgetClearContentList(header);\n\t\t\treturn;\n\t\t}\n\n\t\tCompoundButton trackr = (CompoundButton) header.findViewById(R.id.check_item);\n\t\tif (plugin != null && plugin.getTracker() != null) {\n\t\t\ttrackr.setChecked(plugin.getTracker().isEnabledTracker());\n\t\t}\n\n\t\tupdateConnectedDevices(header);\n\t}","id":84090,"modified_method":"private void updateStatus() {\n\n\t\tView header = getView();\n\t\tif (getView() == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tView cardContent = header.findViewById(R.id.card_content);\n\t\tView enableOsmo = header.findViewById(R.id.header_layout).findViewById(R.id.check_item);\n\t\tView manage = header.findViewById(R.id.manage);\n\t\tif (plugin != null && plugin.getService().isEnabled() ) {\n\t\t\tcardContent.setVisibility(View.VISIBLE);\n\t\t\tenableOsmo.setVisibility(View.GONE);\n\t\t\tmanage.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tcardContent.setVisibility(View.GONE);\n\t\t\tenableOsmo.setVisibility(View.VISIBLE);\n\t\t\tmanage.setVisibility(View.GONE);\n\t\t\tgetClearContentList(header);\n\t\t\treturn;\n\t\t}\n\n\t\tCompoundButton trackr = (CompoundButton) header.findViewById(R.id.check_item);\n\t\tif (plugin != null && plugin.getTracker() != null) {\n\t\t\ttrackr.setChecked(plugin.getTracker().isEnabledTracker());\n\t\t}\n\n\t\tupdateConnectedDevices(header);\n\t}","commit_id":"1b0451aca5ba05a191a3be027999f0edc2ab9d9c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\t\tplugin = OsmandPlugin.getEnabledPlugin(OsMoPlugin.class);\n\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_osmo_fragment, container, false);\n\t\tview.findViewById(R.id.manage).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tlaunchOsMoGroupsActivity();\n\t\t\t}\n\t\t});\n\t\tplugin.setGroupsActivity(getActivity());\n\t\tsetupHader(view);\n\t\treturn view;\n\t}","id":84091,"modified_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\t\tplugin = OsmandPlugin.getEnabledPlugin(OsMoPlugin.class);\n\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_osmo_fragment, container, false);\n\t\tview.findViewById(R.id.manage).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tlaunchOsMoGroupsActivity();\n\t\t\t}\n\t\t});\n\t\tif(plugin != null) {\n\t\t\tplugin.setGroupsActivity(getActivity());\n\t\t}\n\t\tsetupHader(view);\n\t\treturn view;\n\t}","commit_id":"1b0451aca5ba05a191a3be027999f0edc2ab9d9c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onDestroy() {\n\t\tsuper.onDestroy();\n\t\tplugin.setGroupsActivity(null);\n\t}","id":84092,"modified_method":"@Override\n\tpublic void onDestroy() {\n\t\tsuper.onDestroy();\n\t\tif (plugin != null) {\n\t\t\tplugin.setGroupsActivity(null);\n\t\t}\n\t}","commit_id":"f971f17b8b198b03a75189589768bdf23a8b7eea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updateStatus() {\n\n\t\tView header = getView();\n\t\tif (getView() == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tView cardContent = header.findViewById(R.id.card_content);\n\t\tView enableOsmo = header.findViewById(R.id.header_layout).findViewById(R.id.check_item);\n\t\tView manage = header.findViewById(R.id.manage);\n\t\tif (plugin.getService().isEnabled()) {\n\t\t\tcardContent.setVisibility(View.VISIBLE);\n\t\t\tenableOsmo.setVisibility(View.GONE);\n\t\t\tmanage.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tcardContent.setVisibility(View.GONE);\n\t\t\tenableOsmo.setVisibility(View.VISIBLE);\n\t\t\tmanage.setVisibility(View.GONE);\n\t\t\tgetClearContentList(header);\n\t\t\treturn;\n\t\t}\n\n\t\tCompoundButton trackr = (CompoundButton) header.findViewById(R.id.check_item);\n\t\tif (plugin != null && plugin.getTracker() != null) {\n\t\t\ttrackr.setChecked(plugin.getTracker().isEnabledTracker());\n\t\t}\n\n\t\tupdateConnectedDevices(header);\n\t}","id":84093,"modified_method":"private void updateStatus() {\n\n\t\tView header = getView();\n\t\tif (getView() == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tView cardContent = header.findViewById(R.id.card_content);\n\t\tView enableOsmo = header.findViewById(R.id.header_layout).findViewById(R.id.check_item);\n\t\tView manage = header.findViewById(R.id.manage);\n\t\tif (plugin == null || plugin.getService().isEnabled() ) {\n\t\t\tcardContent.setVisibility(View.VISIBLE);\n\t\t\tenableOsmo.setVisibility(View.GONE);\n\t\t\tmanage.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tcardContent.setVisibility(View.GONE);\n\t\t\tenableOsmo.setVisibility(View.VISIBLE);\n\t\t\tmanage.setVisibility(View.GONE);\n\t\t\tgetClearContentList(header);\n\t\t\treturn;\n\t\t}\n\n\t\tCompoundButton trackr = (CompoundButton) header.findViewById(R.id.check_item);\n\t\tif (plugin != null && plugin.getTracker() != null) {\n\t\t\ttrackr.setChecked(plugin.getTracker().isEnabledTracker());\n\t\t}\n\n\t\tupdateConnectedDevices(header);\n\t}","commit_id":"f971f17b8b198b03a75189589768bdf23a8b7eea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * Forward the request up the chain.\n\t */\n\n\tpublic void forwardResponse()\n\t\tthrows IOException\n\t{\nSystem.out.println(\"Forwarding request CT=\"+contentType+\" CL=\"+contentLength);\n\t\tsuper.setContentType(contentType);\n\t\tif ( contentLength > 0 ) super.setContentLength(contentLength);\n\t\tServletOutputStream output = super.getOutputStream();\n\t\toutStream.getContent().writeTo(output);\n\t}","id":84094,"modified_method":"/**\n\t * Forward the request up the chain.\n\t */\n\n\tpublic void forwardResponse()\n\t\tthrows IOException\n\t{\n\t\t// System.out.println(\"Forwarding request CT=\"+contentType+\" CL=\"+contentLength);\n\t\tsuper.setContentType(contentType);\n\t\tif ( contentLength > 0 ) super.setContentLength(contentLength);\n\t\tServletOutputStream output = super.getOutputStream();\n\t\toutStream.getContent().writeTo(output);\n\t}","commit_id":"128a2148b770e654424ae77aa092d6bd88ff7e5a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean doToolBuffer(HttpServletRequest req, HttpServletResponse res,\n\t\t\tSession session, String placementId, String toolContextPath,\n\t\t\tString toolPathInfo) throws ToolException, IOException\n\t{\n\n\t\tif (portal.redirectIfLoggedOut(res)) return false;\n\n\t\t// find the tool from some site\n\t\tToolConfiguration siteTool = SiteService.findTool(placementId);\n\t\tif (siteTool == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Reset the tool state if requested\n\t\tif (portalService.isResetRequested(req))\n\t\t{\n\t\t\tSession s = SessionManager.getCurrentSession();\n\t\t\tToolSession ts = s.getToolSession(placementId);\n\t\t\tts.clearAttributes();\n\t\t}\n\n\t\t// find the tool registered for this\n\t\tActiveTool tool = ActiveToolManager.getActiveTool(siteTool.getToolId());\n\t\tif (tool == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// permission check - visit the site (unless the tool is configured to\n\t\t// bypass)\n\t\tif (tool.getAccessSecurity() == Tool.AccessSecurity.PORTAL)\n\t\t{\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSiteService.getSiteVisit(siteTool.getSiteId());\n\t\t\t}\n\t\t\tcatch (IdUnusedException e)\n\t\t\t{\n\t\t\t\tportal.doError(req, res, session, Portal.ERROR_WORKSITE);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (PermissionException e)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\nSystem.out.println(\"portal.forwardTool siteTool=\"+siteTool+\" TCP=\"+toolContextPath+\" TPI=\"+toolPathInfo);\n\n\t\tportal.forwardTool(tool, req, res, siteTool, siteTool.getSkin(), toolContextPath,\n\t\t\t\ttoolPathInfo);\n\n\t\treturn true;\n\t}","id":84095,"modified_method":"public boolean doToolBuffer(HttpServletRequest req, HttpServletResponse res,\n\t\t\tSession session, String placementId, String toolContextPath,\n\t\t\tString toolPathInfo) throws ToolException, IOException\n\t{\n\n\t\tif (portal.redirectIfLoggedOut(res)) return false;\n\n\t\t// find the tool from some site\n\t\tToolConfiguration siteTool = SiteService.findTool(placementId);\n\t\tif (siteTool == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Reset the tool state if requested\n\t\tif (portalService.isResetRequested(req))\n\t\t{\n\t\t\tSession s = SessionManager.getCurrentSession();\n\t\t\tToolSession ts = s.getToolSession(placementId);\n\t\t\tts.clearAttributes();\n\t\t}\n\n\t\t// find the tool registered for this\n\t\tActiveTool tool = ActiveToolManager.getActiveTool(siteTool.getToolId());\n\t\tif (tool == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// permission check - visit the site (unless the tool is configured to\n\t\t// bypass)\n\t\tif (tool.getAccessSecurity() == Tool.AccessSecurity.PORTAL)\n\t\t{\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSiteService.getSiteVisit(siteTool.getSiteId());\n\t\t\t}\n\t\t\tcatch (IdUnusedException e)\n\t\t\t{\n\t\t\t\tportal.doError(req, res, session, Portal.ERROR_WORKSITE);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (PermissionException e)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlog.debug(\"doToolBuffer siteTool=\"+siteTool+\" TCP=\"+toolContextPath+\" TPI=\"+toolPathInfo);\n\n\t\tportal.forwardTool(tool, req, res, siteTool, siteTool.getSkin(), toolContextPath,\n\t\t\t\ttoolPathInfo);\n\n\t\treturn true;\n\t}","commit_id":"128a2148b770e654424ae77aa092d6bd88ff7e5a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic int doGet(String[] parts, HttpServletRequest req, HttpServletResponse res,\n\t\t\tSession session) throws PortalHandlerException\n\t\t\t{\n\t\tif ((parts.length == 3) && parts[1].equals(PDAHandler.URL_FRAGMENT) && parts[2].equals(XLoginHandler.URL_FRAGMENT))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tportal.doLogin(req, res, session, \"/pda\", true);\n\t\t\t\treturn END;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new PortalHandlerException(ex);\n\t\t\t}\n\t\t} else if ((parts.length >= 2) && (parts[1].equals(\"pda\")))\n\t\t{\n\t\t\t// Indicate that we are the controlling portal\n\t\t\tsession.setAttribute(\"sakai-controlling-portal\",PDAHandler.URL_FRAGMENT);\n\t\t\ttry\n\t\t\t{\n\n\t\t\t\t//check if we want to force back to the classic view\n\t\t\t\tString forceClassic = req.getParameter(Portal.FORCE_CLASSIC_REQ_PARAM);\n\t\t\t\tif(StringUtils.equals(forceClassic, \"yes\")){\n\n\t\t\t\t\tlog.debug(\"PDAHandler - force.classic\");\n\n\t\t\t\t\t//set the portal mode cookie to force classic\n\t\t\t\t\tCookie c = new Cookie(Portal.PORTAL_MODE_COOKIE_NAME, Portal.FORCE_CLASSIC_COOKIE_VALUE);\n\t\t\t\t\tc.setPath(\"/\");\n\t\t\t\t\tc.setMaxAge(-1);\n\n\t\t\t\t\t//need to set domain and https as per RequestFilter\n\t\t\t\t\tif (System.getProperty(SAKAI_COOKIE_DOMAIN) != null) {\n\t\t\t\t\t\tc.setDomain(System.getProperty(SAKAI_COOKIE_DOMAIN));\n\t\t\t\t\t}\n\t\t\t\t\tif (req.isSecure() == true) {\n\t\t\t\t\t\tc.setSecure(true);\n\t\t\t\t\t}\n\t\t\t\t\tres.addCookie(c);\n\n\t\t\t\t\t//redirect to classic view\n\t\t\t\t\tres.sendRedirect(req.getContextPath());\n\t\t\t\t}\n\n\n\t\t\t\t// /portal/pda/site-id\n\t\t\t\tString siteId = null;\n\t\t\t\tif (parts.length >= 3)\n\t\t\t\t{\n\t\t\t\t\tsiteId = parts[2];\n\t\t\t\t}\n\n\t\t\t\t// SAK-12873\n\t\t\t\t// If we have no site at all and are not logged in - and there is \n\t\t\t\t// only one gateway site, go directly to the gateway site\n\t\t\t\tif ( siteId == null && session.getUserId() == null) \n\t\t\t\t{\n\t\t\t\t\tString siteList = ServerConfigurationService\n\t\t\t\t\t.getString(\"gatewaySiteList\");\n\t\t\t\t\tString gatewaySiteId = ServerConfigurationService.getGatewaySiteId();\n\t\t\t\t\tif ( siteList.trim().length() == 0  && gatewaySiteId.trim().length() != 0 ) {\n\t\t\t\t\t\tsiteId = gatewaySiteId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tool resetting URL - clear state and forward to the real tool\n\t\t\t\t// URL\n\t\t\t\t// /portal/pda/site-id/tool-reset/toolId\n\t\t\t\t// 0 1 2 3 4\n\t\t\t\tString toolId = null;\n\t\t\t\tif ((siteId != null) && (parts.length == 5)\n\t\t\t\t\t\t&& (parts[3].equals(\"tool-reset\")))\n\t\t\t\t{\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t\tString toolUrl = req.getContextPath() + \"/pda/\" + siteId + \"/tool\"\n\t\t\t\t\t+ Web.makePath(parts, 4, parts.length);\n\t\t\t\t\tString queryString = Validator.generateQueryString(req);\n\t\t\t\t\tif (queryString != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttoolUrl = toolUrl + \"?\" + queryString;\n\t\t\t\t\t}\n\t\t\t\t\tportalService.setResetState(\"true\");\n\t\t\t\t\tres.sendRedirect(toolUrl);\n\t\t\t\t\treturn RESET_DONE;\n\t\t\t\t}\n\n\t\t\t\t// Tool after the reset\n\t\t\t\t// /portal/pda/site-id/tool/toolId\n\t\t\t\tif ((parts.length > 4) && (parts[3].equals(\"tool\")))\n\t\t\t\t{\n\t\t\t\t\t// look for page and pick up the top-left tool to show\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t}\n\n\t\t\t\tString forceLogout = req.getParameter(Portal.PARAM_FORCE_LOGOUT);\n\t\t\t\tif (\"yes\".equalsIgnoreCase(forceLogout)\n\t\t\t\t\t\t|| \"true\".equalsIgnoreCase(forceLogout))\n\t\t\t\t{\n\t\t\t\t\tportal.doLogout(req, res, session, \"/pda\");\n\t\t\t\t\treturn END;\n\t\t\t\t}\n\n\t\t\t\tif (session.getUserId() == null)\n\t\t\t\t{\n\t\t\t\t\tString forceLogin = req.getParameter(Portal.PARAM_FORCE_LOGIN);\n\t\t\t\t\tif (\"yes\".equalsIgnoreCase(forceLogin)\n\t\t\t\t\t\t\t|| \"true\".equalsIgnoreCase(forceLogin))\n\t\t\t\t\t{\n\t\t\t\t\t\tportal.doLogin(req, res, session, URLUtils.getSafePathInfo(req), false);\n\t\t\t\t\t\treturn END;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSitePage page = null;\n\t\t\t\t// /portal/site/site-id/page/page-id\n\t\t\t\t// /portal/pda/site-id/page/page-id\n\t\t\t\t// 1 2 3 4\n\t\t\t\tif ((parts.length == 5) && (parts[3].equals(\"page\")))\n\t\t\t\t{\n\t\t\t\t\t// look for page and pick up the top-left tool to show\n\t\t\t\t\tString pageId = parts[4];\n\t\t\t\t\tpage = SiteService.findPage(pageId);\n\t\t\t\t\tif (page == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tportal.doError(req, res, session, Portal.ERROR_WORKSITE);\n\t\t\t\t\t\treturn END;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tList<ToolConfiguration> tools = page.getTools(0);\n\t\t\t\t\t\tif (tools != null && !tools.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttoolId = tools.get(0).getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts[3]=\"tool\";\n\t\t\t\t\t\tparts[4]=toolId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set the site language\n\t\t\t\tSite site = null;\n\t\t\t\tif (siteId == null && session.getUserId() != null) {\n\t\t\t\t\tsite = portal.getSiteHelper().getMyWorkspace(session);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSet<SecurityAdvisor> advisors = (Set<SecurityAdvisor>) session.getAttribute(\"sitevisit.security.advisor\");\n\t\t\t\t\t\tif (advisors != null) {\n\t\t\t\t\t\t\tfor (SecurityAdvisor advisor : advisors) {\n\t\t\t\t\t\t\t\tSecurityService.pushAdvisor(advisor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This should understand aliases as well as IDs\n\t\t\t\t\t\tsite = portal.getSiteHelper().getSiteVisit(siteId);\n\t\t\t\t\t} catch (IdUnusedException e) {\n\t\t\t\t\t} catch (PermissionException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (site != null) {\n\t\t\t\t\tsuper.setSiteLanguage(site);\n\t\t\t\t}\n\n\t\t\t\t// See if we can buffer the content, if not, pass the request through\n\t\t\t\tToolConfiguration siteTool = SiteService.findTool(toolId);\n\t\t\t\tString toolContextPath = null;\n\t\t\t\tString toolPathInfo = null;\n\t\t\t\tboolean allowBuffer = false;\n\n\t\t\t\tObject BC = null;\n\t\t\t\tif ( siteTool != null && parts.length >= 5 ) {\n\t\t\t\t\tString commonToolId = siteTool.getToolId();\n\n\t\t\t\t\t// Does the tool allow us to buffer?\n\t\t\t\t\tallowBuffer = allowBufferContent(req, siteTool);\n\n\t\t\t\t\tif ( allowBuffer ) {\n\t\t\t\t\t\ttoolContextPath = req.getContextPath() + req.getServletPath() + Web.makePath(parts, 1, 5);\n\t\t\t\t\t\ttoolPathInfo = Web.makePath(parts, 5, parts.length);\n\n\t\t\t\t\t\t// Should we bypass buffering based on the request?\n\t\t\t\t\t\tboolean matched = checkBufferBypass(req, siteTool);\n\n\t\t\t\t\t\tif ( matched ) {\n\t\t\t\t\t\t\tActiveTool tool = ActiveToolManager.getActiveTool(commonToolId);\n\t\t\t\t\t\t\tportal.forwardTool(tool, req, res, siteTool, \n\t\t\t\t\t\t\t\tsiteTool.getSkin(), toolContextPath, toolPathInfo);\n\t\t\t\t\t\t\treturn END;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prepare for the full output...\n\t\t\t\tPortalRenderContext rcontext = portal.includePortal(req, res, session,\n\t\t\t\t\t\tsiteId, toolId, req.getContextPath() + req.getServletPath(),\n\t\t\t\t\t\t\"pda\",\n\t\t\t\t\t\t/* doPages */false, /* resetTools */true,\n\t\t\t\t\t\t/* includeSummary */false, /* expandSite */false);\n\n\t\t\t\tif ( allowBuffer ) {\n\t\t\t\t\tBC = bufferContent(req, res, session, toolId, \n\t\t\t\t\t\t\ttoolContextPath, toolPathInfo, siteTool);\n\n\t\t\t\t\t// If the buffered response was not parseable\n\t\t\t\t\tif ( BC instanceof ByteArrayServletResponse ) {\nSystem.out.println(\"The output could not be be buffered...\");\n\t\t\t\t\t\tByteArrayServletResponse bufferResponse = (ByteArrayServletResponse) BC;\n\t\t\t\t\t\tbufferResponse.forwardResponse();\n\t\t\t\t\t\treturn END;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//  TODO: Should this be a property?  Probably because it does cause an \n\t\t\t\t// uncached SQL query\n\t\t\t\tportal.includeSubSites(rcontext, req, session,\n\t\t\t\t\t\tsiteId,  req.getContextPath() + req.getServletPath(), \"pda\",\n\t\t\t\t\t\t/* resetTools */ true );\n\n\t\t\t\t// Add the buttons\n\t\t\t\tif ( siteTool != null ) {\n\t\t\t\t\tboolean showResetButton = !\"false\".equals(siteTool.getConfig().getProperty(\n\t\t\t\t\t\t\t\tTOOLCONFIG_SHOW_RESET_BUTTON));\n\t\t\t\t\trcontext.put(\"showResetButton\", Boolean.valueOf(showResetButton));\n\t\t\t\t\tif (showResetButton)\n\t\t\t\t\t{\n\t\t\t\t\t\trcontext.put(\"resetActionUrl\", toolContextPath.replace(\"/tool/\", \"/tool-reset/\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Include the buffered content if we have it\n\t\t\t\tif ( BC instanceof Map ) {\n\t\t\t\t\trcontext.put(\"bufferedResponse\", Boolean.TRUE);\n\t\t\t\t\tMap<String,String> bufferMap = (Map<String,String>) BC;\n\t\t\t\t\trcontext.put(\"responseHead\", (String) bufferMap.get(\"responseHead\"));\n\t\t\t\t\trcontext.put(\"responseBody\", (String) bufferMap.get(\"responseBody\"));\n\t\t\t\t}\n\n\t\t\t\t// Add any device specific information to the context\n\t\t\t\tportal.setupMobileDevice(req, rcontext);\n\t\t\t\t\n\t\t\t\taddLocale(rcontext,site);\n\n\t\t\t\tportal.sendResponse(rcontext, res, \"pda\", null);\n\t\t\t\t\n\t\t\t\ttry{\n\t\t\t\t\tboolean presenceEvents = ServerConfigurationService.getBoolean(\"presence.events.log\", true);\n\t\t\t\t\tif (presenceEvents)\n\t\t\t\t\t\torg.sakaiproject.presence.cover.PresenceService.setPresence(siteId + \"-presence\");\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\treturn END;\n\t\t\t\t}\n\t\t\t\treturn END;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new PortalHandlerException(ex);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NEXT;\n\t\t}\n\t}","id":84096,"modified_method":"@Override\n\tpublic int doGet(String[] parts, HttpServletRequest req, HttpServletResponse res,\n\t\t\tSession session) throws PortalHandlerException\n\t\t\t{\n\t\tif ((parts.length == 3) && parts[1].equals(PDAHandler.URL_FRAGMENT) && parts[2].equals(XLoginHandler.URL_FRAGMENT))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tportal.doLogin(req, res, session, \"/pda\", true);\n\t\t\t\treturn END;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new PortalHandlerException(ex);\n\t\t\t}\n\t\t} else if ((parts.length >= 2) && (parts[1].equals(\"pda\")))\n\t\t{\n\t\t\t// Indicate that we are the controlling portal\n\t\t\tsession.setAttribute(\"sakai-controlling-portal\",PDAHandler.URL_FRAGMENT);\n\t\t\ttry\n\t\t\t{\n\n\t\t\t\t//check if we want to force back to the classic view\n\t\t\t\tString forceClassic = req.getParameter(Portal.FORCE_CLASSIC_REQ_PARAM);\n\t\t\t\tif(StringUtils.equals(forceClassic, \"yes\")){\n\n\t\t\t\t\tlog.debug(\"PDAHandler - force.classic\");\n\n\t\t\t\t\t//set the portal mode cookie to force classic\n\t\t\t\t\tCookie c = new Cookie(Portal.PORTAL_MODE_COOKIE_NAME, Portal.FORCE_CLASSIC_COOKIE_VALUE);\n\t\t\t\t\tc.setPath(\"/\");\n\t\t\t\t\tc.setMaxAge(-1);\n\n\t\t\t\t\t//need to set domain and https as per RequestFilter\n\t\t\t\t\tif (System.getProperty(SAKAI_COOKIE_DOMAIN) != null) {\n\t\t\t\t\t\tc.setDomain(System.getProperty(SAKAI_COOKIE_DOMAIN));\n\t\t\t\t\t}\n\t\t\t\t\tif (req.isSecure() == true) {\n\t\t\t\t\t\tc.setSecure(true);\n\t\t\t\t\t}\n\t\t\t\t\tres.addCookie(c);\n\n\t\t\t\t\t//redirect to classic view\n\t\t\t\t\tres.sendRedirect(req.getContextPath());\n\t\t\t\t}\n\n\n\t\t\t\t// /portal/pda/site-id\n\t\t\t\tString siteId = null;\n\t\t\t\tif (parts.length >= 3)\n\t\t\t\t{\n\t\t\t\t\tsiteId = parts[2];\n\t\t\t\t}\n\n\t\t\t\t// SAK-12873\n\t\t\t\t// If we have no site at all and are not logged in - and there is \n\t\t\t\t// only one gateway site, go directly to the gateway site\n\t\t\t\tif ( siteId == null && session.getUserId() == null) \n\t\t\t\t{\n\t\t\t\t\tString siteList = ServerConfigurationService\n\t\t\t\t\t.getString(\"gatewaySiteList\");\n\t\t\t\t\tString gatewaySiteId = ServerConfigurationService.getGatewaySiteId();\n\t\t\t\t\tif ( siteList.trim().length() == 0  && gatewaySiteId.trim().length() != 0 ) {\n\t\t\t\t\t\tsiteId = gatewaySiteId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tool resetting URL - clear state and forward to the real tool\n\t\t\t\t// URL\n\t\t\t\t// /portal/pda/site-id/tool-reset/toolId\n\t\t\t\t// 0 1 2 3 4\n\t\t\t\tString toolId = null;\n\t\t\t\tif ((siteId != null) && (parts.length == 5)\n\t\t\t\t\t\t&& (parts[3].equals(\"tool-reset\")))\n\t\t\t\t{\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t\tString toolUrl = req.getContextPath() + \"/pda/\" + siteId + \"/tool\"\n\t\t\t\t\t+ Web.makePath(parts, 4, parts.length);\n\t\t\t\t\tString queryString = Validator.generateQueryString(req);\n\t\t\t\t\tif (queryString != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttoolUrl = toolUrl + \"?\" + queryString;\n\t\t\t\t\t}\n\t\t\t\t\tportalService.setResetState(\"true\");\n\t\t\t\t\tres.sendRedirect(toolUrl);\n\t\t\t\t\treturn RESET_DONE;\n\t\t\t\t}\n\n\t\t\t\t// Tool after the reset\n\t\t\t\t// /portal/pda/site-id/tool/toolId\n\t\t\t\tif ((parts.length > 4) && (parts[3].equals(\"tool\")))\n\t\t\t\t{\n\t\t\t\t\t// look for page and pick up the top-left tool to show\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t}\n\n\t\t\t\tString forceLogout = req.getParameter(Portal.PARAM_FORCE_LOGOUT);\n\t\t\t\tif (\"yes\".equalsIgnoreCase(forceLogout)\n\t\t\t\t\t\t|| \"true\".equalsIgnoreCase(forceLogout))\n\t\t\t\t{\n\t\t\t\t\tportal.doLogout(req, res, session, \"/pda\");\n\t\t\t\t\treturn END;\n\t\t\t\t}\n\n\t\t\t\tif (session.getUserId() == null)\n\t\t\t\t{\n\t\t\t\t\tString forceLogin = req.getParameter(Portal.PARAM_FORCE_LOGIN);\n\t\t\t\t\tif (\"yes\".equalsIgnoreCase(forceLogin)\n\t\t\t\t\t\t\t|| \"true\".equalsIgnoreCase(forceLogin))\n\t\t\t\t\t{\n\t\t\t\t\t\tportal.doLogin(req, res, session, URLUtils.getSafePathInfo(req), false);\n\t\t\t\t\t\treturn END;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSitePage page = null;\n\t\t\t\t// /portal/site/site-id/page/page-id\n\t\t\t\t// /portal/pda/site-id/page/page-id\n\t\t\t\t// 1 2 3 4\n\t\t\t\tif ((parts.length == 5) && (parts[3].equals(\"page\")))\n\t\t\t\t{\n\t\t\t\t\t// look for page and pick up the top-left tool to show\n\t\t\t\t\tString pageId = parts[4];\n\t\t\t\t\tpage = SiteService.findPage(pageId);\n\t\t\t\t\tif (page == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tportal.doError(req, res, session, Portal.ERROR_WORKSITE);\n\t\t\t\t\t\treturn END;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tList<ToolConfiguration> tools = page.getTools(0);\n\t\t\t\t\t\tif (tools != null && !tools.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttoolId = tools.get(0).getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts[3]=\"tool\";\n\t\t\t\t\t\tparts[4]=toolId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set the site language\n\t\t\t\tSite site = null;\n\t\t\t\tif (siteId == null && session.getUserId() != null) {\n\t\t\t\t\tsite = portal.getSiteHelper().getMyWorkspace(session);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSet<SecurityAdvisor> advisors = (Set<SecurityAdvisor>) session.getAttribute(\"sitevisit.security.advisor\");\n\t\t\t\t\t\tif (advisors != null) {\n\t\t\t\t\t\t\tfor (SecurityAdvisor advisor : advisors) {\n\t\t\t\t\t\t\t\tSecurityService.pushAdvisor(advisor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This should understand aliases as well as IDs\n\t\t\t\t\t\tsite = portal.getSiteHelper().getSiteVisit(siteId);\n\t\t\t\t\t} catch (IdUnusedException e) {\n\t\t\t\t\t} catch (PermissionException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (site != null) {\n\t\t\t\t\tsuper.setSiteLanguage(site);\n\t\t\t\t}\n\n\t\t\t\t// See if we can buffer the content, if not, pass the request through\n\t\t\t\tToolConfiguration siteTool = SiteService.findTool(toolId);\n\t\t\t\tString commonToolId = null;\n\t\t\t\tString toolContextPath = null;\n\t\t\t\tString toolPathInfo = null;\n\t\t\t\tboolean allowBuffer = false;\n\n\t\t\t\tObject BC = null;\n\t\t\t\tif ( siteTool != null && parts.length >= 5 ) {\n\t\t\t\t\tcommonToolId = siteTool.getToolId();\n\n\t\t\t\t\t// Does the tool allow us to buffer?\n\t\t\t\t\tallowBuffer = allowBufferContent(req, siteTool);\n\n\t\t\t\t\tif ( allowBuffer ) {\n\t\t\t\t\t\ttoolContextPath = req.getContextPath() + req.getServletPath() + Web.makePath(parts, 1, 5);\n\t\t\t\t\t\ttoolPathInfo = Web.makePath(parts, 5, parts.length);\n\n\t\t\t\t\t\t// Should we bypass buffering based on the request?\n\t\t\t\t\t\tboolean matched = checkBufferBypass(req, siteTool);\n\n\t\t\t\t\t\tif ( matched ) {\n\t\t\t\t\t\t\tActiveTool tool = ActiveToolManager.getActiveTool(commonToolId);\n\t\t\t\t\t\t\tportal.forwardTool(tool, req, res, siteTool, \n\t\t\t\t\t\t\t\tsiteTool.getSkin(), toolContextPath, toolPathInfo);\n\t\t\t\t\t\t\treturn END;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prepare for the full output...\n\t\t\t\tPortalRenderContext rcontext = portal.includePortal(req, res, session,\n\t\t\t\t\t\tsiteId, toolId, req.getContextPath() + req.getServletPath(),\n\t\t\t\t\t\t\"pda\",\n\t\t\t\t\t\t/* doPages */false, /* resetTools */true,\n\t\t\t\t\t\t/* includeSummary */false, /* expandSite */false);\n\n\t\t\t\tif ( allowBuffer ) {\n\t\t\t\t\tBC = bufferContent(req, res, session, toolId, \n\t\t\t\t\t\t\ttoolContextPath, toolPathInfo, siteTool);\n\n\t\t\t\t\t// If the buffered response was not parseable\n\t\t\t\t\tif ( BC instanceof ByteArrayServletResponse ) {\n\t\t\t\t\t\tStringBuffer queryUrl = req.getRequestURL();\n\t\t\t\t\t\tString queryString = req.getQueryString();\n\t\t\t\t\t\tif ( queryString != null ) queryUrl.append('?').append(queryString);\n\t\t\t\t\t\tlog.debug(\"Post buffer bypass CTI=\"+commonToolId+\" URL=\"+queryUrl);\nSystem.out.println(\"Post buffer bypass CTI=\"+commonToolId+\" URL=\"+queryUrl);\n\t\t\t\t\t\tByteArrayServletResponse bufferResponse = (ByteArrayServletResponse) BC;\n\t\t\t\t\t\tbufferResponse.forwardResponse();\n\t\t\t\t\t\treturn END;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//  TODO: Should this be a property?  Probably because it does cause an \n\t\t\t\t// uncached SQL query\n\t\t\t\tportal.includeSubSites(rcontext, req, session,\n\t\t\t\t\t\tsiteId,  req.getContextPath() + req.getServletPath(), \"pda\",\n\t\t\t\t\t\t/* resetTools */ true );\n\n\t\t\t\t// Add the buttons\n\t\t\t\tif ( siteTool != null ) {\n\t\t\t\t\tboolean showResetButton = !\"false\".equals(siteTool.getConfig().getProperty(\n\t\t\t\t\t\t\t\tTOOLCONFIG_SHOW_RESET_BUTTON));\n\t\t\t\t\trcontext.put(\"showResetButton\", Boolean.valueOf(showResetButton));\n\t\t\t\t\tif (showResetButton)\n\t\t\t\t\t{\n\t\t\t\t\t\trcontext.put(\"resetActionUrl\", toolContextPath.replace(\"/tool/\", \"/tool-reset/\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Include the buffered content if we have it\n\t\t\t\tif ( BC instanceof Map ) {\n\t\t\t\t\trcontext.put(\"bufferedResponse\", Boolean.TRUE);\n\t\t\t\t\tMap<String,String> bufferMap = (Map<String,String>) BC;\n\t\t\t\t\trcontext.put(\"responseHead\", (String) bufferMap.get(\"responseHead\"));\n\t\t\t\t\trcontext.put(\"responseBody\", (String) bufferMap.get(\"responseBody\"));\n\t\t\t\t}\n\n\t\t\t\t// Add any device specific information to the context\n\t\t\t\tportal.setupMobileDevice(req, rcontext);\n\t\t\t\t\n\t\t\t\taddLocale(rcontext,site);\n\n\t\t\t\tportal.sendResponse(rcontext, res, \"pda\", null);\n\t\t\t\t\n\t\t\t\ttry{\n\t\t\t\t\tboolean presenceEvents = ServerConfigurationService.getBoolean(\"presence.events.log\", true);\n\t\t\t\t\tif (presenceEvents)\n\t\t\t\t\t\torg.sakaiproject.presence.cover.PresenceService.setPresence(siteId + \"-presence\");\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\treturn END;\n\t\t\t\t}\n\t\t\t\treturn END;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new PortalHandlerException(ex);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NEXT;\n\t\t}\n\t}","commit_id":"128a2148b770e654424ae77aa092d6bd88ff7e5a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Produce a page and/or a tool list doPage = true is best for the\n\t * tabs-based portal and for RSS - these think in terms of pages doPage =\n\t * false is best for the portlet-style - it unrolls all of the tools unless\n\t * a page is marked as a popup. If the page is a popup - it is left a page\n\t * and marked as such. restTools = true - generate resetting tool URLs.\n\t * \n\t * @see org.sakaiproject.portal.api.PortalSiteHelper#pageListToMap(javax.servlet.http.HttpServletRequest,\n\t *      boolean, org.sakaiproject.site.api.Site,\n\t *      org.sakaiproject.site.api.SitePage, java.lang.String,\n\t *      java.lang.String, boolean, boolean, boolean)\n\t */\n\tpublic Map pageListToMap(HttpServletRequest req, boolean loggedIn, Site site,\n\t\t\tSitePage page, String toolContextPath, String portalPrefix, boolean doPages,\n\t\t\tboolean resetTools, boolean includeSummary)\n\t{\n\n\t\tMap<String, Object> theMap = new HashMap<String, Object>();\n\n\t\tString pageUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)) + \"/page/\");\n\t\tString toolUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)));\n\t\tif (resetTools)\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool-reset/\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool/\";\n\t\t}\n\n\t\tString pagePopupUrl = Web.returnUrl(req, \"/page/\");\n\t\t\n\t\t// Should be pushed up to the API, similar to server configiuration service, but supporting an Enum(always, never, true, false).\n\t\tboolean showHelp = true;\n\t\t// Supports true, false, never, always\n\t\tString showHelpGlobal = ServerConfigurationService.getString(\"display.help.menu\", \"true\");\n\t\t\n\t\tif (\"never\".equals(showHelp))\n\t\t{\n\t\t\tshowHelp = false;\n\t\t}\n\t\telse if (\"always\".equals(showHelpGlobal))\n\t\t{\n\t\t\tshowHelp = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshowHelp = Boolean.valueOf(showHelpGlobal).booleanValue();\n\t\t\tString showHelpSite = site.getProperties().getProperty(\"display-help-menu\");\n\t\t\tif (showHelpSite != null)\n\t\t\t{\n\t\t\t\tshowHelp = Boolean.valueOf(showHelpSite).booleanValue();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString iconUrl = \"\";\n\t\ttry { \n\t\t\tif (site.getIconUrlFull() != null)\n\t\t\t\ticonUrl = new URI(site.getIconUrlFull()).toString();\n\t\t} catch (URISyntaxException uex) {\n\t\t\tlog.debug(\"Icon URL is invalid: \" + site.getIconUrlFull());\n\t\t}\n\n\t\tboolean published = site.isPublished();\n\t\tString type = site.getType();\n\n\t\ttheMap.put(\"siteId\", site.getId());\n\t\ttheMap.put(\"pageNavPublished\", Boolean.valueOf(published));\n\t\ttheMap.put(\"pageNavType\", type);\n\t\ttheMap.put(\"pageNavIconUrl\", iconUrl);\n\t\tString htmlInclude = site.getProperties().getProperty(PROP_HTML_INCLUDE);\n\t\tif (htmlInclude != null) theMap.put(\"siteHTMLInclude\", htmlInclude);\n\n\t\t// theMap.put(\"pageNavSitToolsHead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_toolshead\")));\n\n\t\t// order the pages based on their tools and the tool order for the\n\t\t// site type\n\t\t// List pages = site.getOrderedPages();\n\t\tList pages = getPermittedPagesInOrder(site);\n\n\t\tList<Map> l = new ArrayList<Map>();\n\n\t\tString addMoreToolsUrl = null;\n\t\tfor (Iterator i = pages.iterator(); i.hasNext();)\n\t\t{\n\n\t\t\tSitePage p = (SitePage) i.next();\n\t\t\t// check if current user has permission to see page\n\t\t\t// we will draw page button if it have permission to see at least\n\t\t\t// one tool on the page\n\t\t\tList<ToolConfiguration> pTools = p.getTools();\n\t\t\tToolConfiguration firstTool = null;\n\t\t\tString toolsOnPage = null;\n\n\t\t\t// Check the tools that indicate the portal is to do the popup\n\t\t\tIterator<ToolConfiguration> toolz = pTools.iterator();\n\t\t\tString source = null;\n\t\t\tboolean toolPopup = false;\t\n\t\t\tint count = 0;\n\t\t\twhile(toolz.hasNext()){\n\t\t\t\tToolConfiguration tc = toolz.next();\n\t\t\t\tcount++;\n\t\t\t\tTool to = tc.getTool();\n\t\t\t\tProperties pro = tc.getConfig();\n\t\t\t\tif ( \"sakai.web.168\".equals(tc.getToolId()) ) {\n\t\t\t\t\tsource = pro.getProperty(\"source\");\n\t\t\t\t\ttoolPopup = \"true\".equals(pro.getProperty(\"popup\"));\n\t\t\t\t} else if ( \"sakai.iframe\".equals(tc.getToolId()) ) {\n\t\t\t\t\tsource = pro.getProperty(\"source\");\n\t\t\t\t\ttoolPopup = \"true\".equals(pro.getProperty(\"popup\"));\n\t\t\t\t} else if ( \"sakai.basiclti\".equals(tc.getToolId()) ) {\n\t\t\t\t\ttoolPopup = \"on\".equals(pro.getProperty(\"imsti.newpage\"));\n\t\t\t\t\tsource = \"/access/basiclti/site/\"+tc.getContext()+\"/\"+tc.getId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( count != 1 ) toolPopup = false;\n\n\t\t\tboolean current = (page != null && p.getId().equals(page.getId()) && !p\n\t\t\t\t\t.isPopUp());\n\t\t\tString alias = lookupPageToAlias(site.getId(), p);\n\t\t\tString pagerefUrl = pageUrl + Web.escapeUrl((alias != null)?alias:p.getId());\n\n\t\t\tif (doPages || p.isPopUp())\n\t\t\t{\n\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\tStringBuffer desc = new StringBuffer();\n\n\t\t\t\tboolean hidden = false;\n\t\t\t\tif (pTools != null && pTools.size() > 0) {\n\t\t\t\t\tfirstTool = pTools.get(0);\n\t\t\t\t\thidden = true; // Only set the page to hidden when we have tools that might un-hide it.\n\t\t\t\t\tIterator<ToolConfiguration> tools = pTools.iterator();\n\t\t\t\t\t//get the tool descriptions for this page, typically only one per page, execpt for the Home page\n\t\t\t\t\tint tCount = 0;\n\t\t\t\t\twhile(tools.hasNext()){\n\t\t\t\t\t\tToolConfiguration t = tools.next();\n\t\t\t\t\t\tif (hidden && !isHidden(t))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thidden = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tCount > 0){\n\t\t\t\t\t\t\tdesc.append(\" | \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( t.getTool() == null ) continue;\n\t\t\t\t\t\tdesc.append(t.getTool().getDescription());\n\t\t\t\t\t\ttCount++;\n\t\t\t\t\t\tif ( \"sakai.siteinfo\".equals(t.getToolId()) ) {\n\t\t\t\t\t\t\taddMoreToolsUrl = Web.returnUrl(req, \"/site/\" + Web.escapeUrl(site.getId()) + \"/page/\" + Web.escapeUrl(p.getId()) + \"?sakai_action=doMenu_edit_site_tools&panel=Shortcut\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Won't work with mutliple tools per page\n\t\t\t\t\tif ( tCount > 1 ) addMoreToolsUrl = null; \n\t\t\t\t}\n\n\t\t\t\tboolean siteUpdate = SecurityService.unlock(\"site.upd\", site.getReference());\n\t\t\t\tif ( ! siteUpdate ) addMoreToolsUrl = null;\n\n\t\t\t\tif ( ! ServerConfigurationService.getBoolean(\"portal.experimental.addmoretools\", false) ) addMoreToolsUrl = null;\n\n\t\t\t\tm.put(\"isPage\", Boolean.valueOf(true));\n\t\t\t\tm.put(\"current\", Boolean.valueOf(current));\n\t\t\t\tm.put(\"ispopup\", Boolean.valueOf(p.isPopUp()));\n\t\t\t\tm.put(\"pagePopupUrl\", pagePopupUrl);\n\t\t\t\tm.put(\"pageTitle\", Web.escapeHtml(p.getTitle()));\n\t\t\t\tm.put(\"jsPageTitle\", Web.escapeJavascript(p.getTitle()));\n\t\t\t\tm.put(\"pageId\", Web.escapeUrl(p.getId()));\n\t\t\t\tm.put(\"jsPageId\", Web.escapeJavascript(p.getId()));\n\t\t\t\tm.put(\"pageRefUrl\", pagerefUrl);\n\t\t\t\tm.put(\"toolpopup\", Boolean.valueOf(toolPopup));\n\t\t\t\tm.put(\"toolpopupurl\", source);\n\t\t\t\t\n\t\t\t\t// TODO: Should have Web.escapeHtmlAttribute()\n\t\t\t\tString description = desc.toString().replace(\"\\\"\",\"&quot;\");\n\t\t\t\tm.put(\"description\",  description);\n\t\t\t\tm.put(\"hidden\", Boolean.valueOf(hidden));\n\t\t\t\t// toolsOnPage is always null\n\t\t\t\t//if (toolsOnPage != null) m.put(\"toolsOnPage\", toolsOnPage);\n\t\t\t\tif (includeSummary) summarizePage(m, site, p);\n\t\t\t\tif (firstTool != null)\n\t\t\t\t{\n\t\t\t\t\tString menuClass = firstTool.getToolId();\n\t\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t\tProperties tmp = firstTool.getConfig();\n\t\t\t\t\tif ( tmp != null ) {\n\t\t\t\t\t\tString mc = tmp.getProperty(PROP_MENU_CLASS);\n\t\t\t\t\t\tif ( mc != null && mc.length() > 0 ) m.put(\"menuClassOverride\", mc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.put(\"menuClass\", \"icon-default-tool\");\n\t\t\t\t}\n\t\t\t\tm.put(\"pageProps\", createPageProps(p));\n\t\t\t\t// this is here to allow the tool reorder to work\n\t\t\t\tm.put(\"_sitePage\", p);\n\t\t\t\tl.add(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Loop through the tools again and Unroll the tools\n\t\t\tIterator iPt = pTools.iterator();\n\n\t\t\twhile (iPt.hasNext())\n\t\t\t{\n\t\t\t\tToolConfiguration placement = (ToolConfiguration) iPt.next();\n\n\t\t\t\tTool tool = placement.getTool();\n\t\t\t\tif (tool != null)\n\t\t\t\t{\n\t\t\t\t\tString toolrefUrl = toolUrl + Web.escapeUrl(placement.getId());\n\t\t\t\t\t\n\t\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\t\tm.put(\"isPage\", Boolean.valueOf(false));\n\t\t\t\t\tm.put(\"toolId\", Web.escapeUrl(placement.getId()));\n\t\t\t\t\tm.put(\"jsToolId\", Web.escapeJavascript(placement.getId()));\n\t\t\t\t\tm.put(\"toolRegistryId\", placement.getToolId());\n\t\t\t\t\tm.put(\"toolTitle\", Web.escapeHtml(placement.getTitle()));\n\t\t\t\t\tm.put(\"jsToolTitle\", Web.escapeJavascript(placement.getTitle()));\n\t\t\t\t\tm.put(\"toolrefUrl\", toolrefUrl);\n\t\t\t\t\tm.put(\"toolpopup\", Boolean.valueOf(toolPopup));\n\t\t\t\t\tm.put(\"toolpopupurl\", source);\n\t\t\t\t\tString menuClass = placement.getToolId();\n\t\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t\tProperties tmp = placement.getConfig();\n\t\t\t\t\tif ( tmp != null ) {\n\t\t\t\t\t\tString mc = tmp.getProperty(PROP_MENU_CLASS);\n\t\t\t\t\t\tif ( mc != null && mc.length() > 0 ) m.put(\"menuClassOverride\", mc);\n\t\t\t\t\t}\n\t\t\t\t\t// this is here to allow the tool reorder to work if requried.\n\t\t\t\t\tm.put(\"_placement\", placement);\n\t\t\t\t\tl.add(m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tPageFilter pageFilter = portal.getPageFilter();\n\t\tif (pageFilter != null)\n\t\t{\n\t\t\tl = pageFilter.filterPlacements(l, site);\n\t\t}\n\n\t\tif ( addMoreToolsUrl != null ) {\n\t\t\ttheMap.put(\"pageNavAddMoreToolsUrl\", addMoreToolsUrl);\n\t\t\ttheMap.put(\"pageNavCanAddMoreTools\", true);\n\t\t} else {\n\t\t\ttheMap.put(\"pageNavCanAddMoreTools\", false);\n\t\t}\n\n\t\ttheMap.put(\"pageNavTools\", l);\n\t\ttheMap.put(\"pageMaxIfSingle\", ServerConfigurationService.getBoolean(\n\t\t\t\t\"portal.experimental.maximizesinglepage\", false));\n\t\ttheMap.put(\"pageNavToolsCount\", Integer.valueOf(l.size()));\n\n\t\tString helpUrl = ServerConfigurationService.getHelpUrl(null);\n\t\ttheMap.put(\"pageNavShowHelp\", Boolean.valueOf(showHelp));\n\t\ttheMap.put(\"pageNavHelpUrl\", helpUrl);\n\t\ttheMap.put(\"helpMenuClass\", \"icon-sakai-help\");\n\t\ttheMap.put(\"subsiteClass\", \"icon-sakai-subsite\");\n\n\t\t// theMap.put(\"pageNavSitContentshead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_contentshead\")));\n\n\t\t// Display presence? Global property display.users.present may be always / never / true / false\n\t\t// If true or false, the value may be overriden by the site property display-users-present\n\t\t// which may be true or false.\n\t\t\t\t\n\t\tboolean showPresence;\n\t\tString globalShowPresence = ServerConfigurationService.getString(\"display.users.present\",\"true\");\n\t\t\t\t\n\t\tif (\"never\".equals(globalShowPresence)) {\n\t\t\tshowPresence = false;\n\t\t} else if (\"always\".equals(globalShowPresence)) {\n\t\t\tshowPresence = true;\n\t\t} else {\n\t\t\tshowPresence = Boolean.valueOf(globalShowPresence).booleanValue();\n\t\t\tString showPresenceSite = site.getProperties().getProperty(\"display-users-present\");\n\t\t\tif (showPresenceSite != null)\n\t\t\t{\n\t\t\t\tshowPresence = Boolean.valueOf(showPresenceSite).booleanValue();\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t// Check to see if this is a my workspace site, and if so, whether presence is disabled\n\t\tif (showPresence && SiteService.isUserSite(site.getId()) && !ServerConfigurationService.getBoolean(\"display.users.present.myworkspace\", false))\n\t\t\tshowPresence = false;\n\t\t\n\t\tString presenceUrl = Web.returnUrl(req, \"/presence/\"\n\t\t\t\t+ Web.escapeUrl(site.getId()));\n\n\t\t// theMap.put(\"pageNavSitPresenceTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presencetitle\")));\n\t\t// theMap.put(\"pageNavSitPresenceFrameTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presenceiframetit\")));\n\t\ttheMap.put(\"pageNavShowPresenceLoggedIn\", Boolean.valueOf(showPresence\n\t\t\t\t&& loggedIn));\n\t\ttheMap.put(\"pageNavPresenceUrl\", presenceUrl);\n\n\t\t//add softly deleted status\n\t\ttheMap.put(\"softlyDeleted\", site.isSoftlyDeleted());\n\n\t\t// Retrieve whether or not we are to put presence in a frame\n\t\ttheMap.put(\"pageNavPresenceIframe\", Boolean.valueOf(\n\t\t\tServerConfigurationService.getBoolean(\"display.users.present.iframe\", false)) );\n\t\ttheMap.put(\"sakaiPresenceTimeDelay\", Integer.valueOf(\n\t\t\tServerConfigurationService.getInt(\"display.users.present.time.delay\", 3000)) );\n\n\t\treturn theMap;\n\t}","id":84097,"modified_method":"/**\n\t * Produce a page and/or a tool list doPage = true is best for the\n\t * tabs-based portal and for RSS - these think in terms of pages doPage =\n\t * false is best for the portlet-style - it unrolls all of the tools unless\n\t * a page is marked as a popup. If the page is a popup - it is left a page\n\t * and marked as such. restTools = true - generate resetting tool URLs.\n\t * \n\t * @see org.sakaiproject.portal.api.PortalSiteHelper#pageListToMap(javax.servlet.http.HttpServletRequest,\n\t *      boolean, org.sakaiproject.site.api.Site,\n\t *      org.sakaiproject.site.api.SitePage, java.lang.String,\n\t *      java.lang.String, boolean, boolean, boolean)\n\t */\n\tpublic Map pageListToMap(HttpServletRequest req, boolean loggedIn, Site site,\n\t\t\tSitePage page, String toolContextPath, String portalPrefix, boolean doPages,\n\t\t\tboolean resetTools, boolean includeSummary)\n\t{\n\n\t\tMap<String, Object> theMap = new HashMap<String, Object>();\n\n\t\tString pageUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)) + \"/page/\");\n\t\tString toolUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)));\n\t\tif (resetTools)\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool-reset/\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool/\";\n\t\t}\n\n\t\tString pagePopupUrl = Web.returnUrl(req, \"/page/\");\n\t\t\n\t\t// Should be pushed up to the API, similar to server configiuration service, but supporting an Enum(always, never, true, false).\n\t\tboolean showHelp = true;\n\t\t// Supports true, false, never, always\n\t\tString showHelpGlobal = ServerConfigurationService.getString(\"display.help.menu\", \"true\");\n\t\t\n\t\tif (\"never\".equals(showHelp))\n\t\t{\n\t\t\tshowHelp = false;\n\t\t}\n\t\telse if (\"always\".equals(showHelpGlobal))\n\t\t{\n\t\t\tshowHelp = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshowHelp = Boolean.valueOf(showHelpGlobal).booleanValue();\n\t\t\tString showHelpSite = site.getProperties().getProperty(\"display-help-menu\");\n\t\t\tif (showHelpSite != null)\n\t\t\t{\n\t\t\t\tshowHelp = Boolean.valueOf(showHelpSite).booleanValue();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString iconUrl = \"\";\n\t\ttry { \n\t\t\tif (site.getIconUrlFull() != null)\n\t\t\t\ticonUrl = new URI(site.getIconUrlFull()).toString();\n\t\t} catch (URISyntaxException uex) {\n\t\t\tlog.debug(\"Icon URL is invalid: \" + site.getIconUrlFull());\n\t\t}\n\n\t\tboolean published = site.isPublished();\n\t\tString type = site.getType();\n\n\t\ttheMap.put(\"siteId\", site.getId());\n\t\ttheMap.put(\"pageNavPublished\", Boolean.valueOf(published));\n\t\ttheMap.put(\"pageNavType\", type);\n\t\ttheMap.put(\"pageNavIconUrl\", iconUrl);\n\t\tString htmlInclude = site.getProperties().getProperty(PROP_HTML_INCLUDE);\n\t\tif (htmlInclude != null) theMap.put(\"siteHTMLInclude\", htmlInclude);\n\n\t\t// theMap.put(\"pageNavSitToolsHead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_toolshead\")));\n\n\t\t// order the pages based on their tools and the tool order for the\n\t\t// site type\n\t\t// List pages = site.getOrderedPages();\n\t\tList pages = getPermittedPagesInOrder(site);\n\n\t\tList<Map> l = new ArrayList<Map>();\n\n\t\tString addMoreToolsUrl = null;\n\t\tfor (Iterator i = pages.iterator(); i.hasNext();)\n\t\t{\n\n\t\t\tSitePage p = (SitePage) i.next();\n\t\t\t// check if current user has permission to see page\n\t\t\t// we will draw page button if it have permission to see at least\n\t\t\t// one tool on the page\n\t\t\tList<ToolConfiguration> pTools = p.getTools();\n\t\t\tToolConfiguration firstTool = null;\n\t\t\tString toolsOnPage = null;\n\n\t\t\t// Check the tools that indicate the portal is to do the popup\n\t\t\tIterator<ToolConfiguration> toolz = pTools.iterator();\n\t\t\tString source = null;\n\t\t\tboolean toolPopup = false;\t\n\t\t\tint count = 0;\n\t\t\tToolConfiguration pageTool = null;\n\t\t\twhile(toolz.hasNext()){\n\t\t\t\tcount++;\n\t\t\t\tpageTool = toolz.next();\n\t\t\t\tProperties pro = pageTool.getConfig();\n\t\t\t\tif ( \"sakai.web.168\".equals(pageTool.getToolId()) ) {\n\t\t\t\t\tsource = pro.getProperty(\"source\");\n\t\t\t\t\ttoolPopup = \"true\".equals(pro.getProperty(\"popup\"));\n\t\t\t\t} else if ( \"sakai.iframe\".equals(pageTool.getToolId()) ) {\n\t\t\t\t\tsource = pro.getProperty(\"source\");\n\t\t\t\t\ttoolPopup = \"true\".equals(pro.getProperty(\"popup\"));\n\t\t\t\t} else if ( \"sakai.basiclti\".equals(pageTool.getToolId()) ) {\n\t\t\t\t\ttoolPopup = \"on\".equals(pro.getProperty(\"imsti.newpage\"));\n\t\t\t\t\tsource = \"/access/basiclti/site/\"+pageTool.getContext()+\"/\"+pageTool.getId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( count != 1 ) {\n\t\t\t\ttoolPopup = false;\n\t\t\t\tpageTool = null;\n\t\t\t}\n\n\t\t\tboolean current = (page != null && p.getId().equals(page.getId()) && !p\n\t\t\t\t\t.isPopUp());\n\t\t\tString alias = lookupPageToAlias(site.getId(), p);\n\t\t\tString pagerefUrl = pageUrl + Web.escapeUrl((alias != null)?alias:p.getId());\n\t\t\t\n\t\t\tString trinity = ServerConfigurationService.getString(\"portal.inline.experimental\", \"false\");\n\t\t\tif ( \"true\".equals(trinity) && pageTool != null ) {\n\t\t\t\tpageUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\" + Web.escapeUrl(getSiteEffectiveId(site)) );\n\t\t\t\tif (resetTools) {\n\t\t\t\t\tpageUrl = pageUrl + \"/tool-reset/\";\n\t\t\t\t} else {\n\t\t\t\t\tpageUrl = pageUrl + \"/tool/\";\n\t\t\t\t}\n\t\t\t\tpagerefUrl = pageUrl + Web.escapeUrl(pageTool.getId());\n\t\t\t}\n\n\t\t\tif (doPages || p.isPopUp())\n\t\t\t{\n\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\tStringBuffer desc = new StringBuffer();\n\n\t\t\t\tboolean hidden = false;\n\t\t\t\tif (pTools != null && pTools.size() > 0) {\n\t\t\t\t\tfirstTool = pTools.get(0);\n\t\t\t\t\thidden = true; // Only set the page to hidden when we have tools that might un-hide it.\n\t\t\t\t\tIterator<ToolConfiguration> tools = pTools.iterator();\n\t\t\t\t\t//get the tool descriptions for this page, typically only one per page, execpt for the Home page\n\t\t\t\t\tint tCount = 0;\n\t\t\t\t\twhile(tools.hasNext()){\n\t\t\t\t\t\tToolConfiguration t = tools.next();\n\t\t\t\t\t\tif (hidden && !isHidden(t))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thidden = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tCount > 0){\n\t\t\t\t\t\t\tdesc.append(\" | \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( t.getTool() == null ) continue;\n\t\t\t\t\t\tdesc.append(t.getTool().getDescription());\n\t\t\t\t\t\ttCount++;\n\t\t\t\t\t\tif ( \"sakai.siteinfo\".equals(t.getToolId()) ) {\n\t\t\t\t\t\t\tif ( \"true\".equals(trinity) && pageTool != null ) {\n\t\t\t\t\t\t\t\taddMoreToolsUrl = pageUrl + Web.escapeUrl(p.getId());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddMoreToolsUrl = pageUrl + Web.escapeUrl(t.getId());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taddMoreToolsUrl += \"?sakai_action=doMenu_edit_site_tools&panel=Shortcut\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Won't work with mutliple tools per page\n\t\t\t\t\tif ( tCount > 1 ) addMoreToolsUrl = null; \n\t\t\t\t}\n\n\t\t\t\tboolean siteUpdate = SecurityService.unlock(\"site.upd\", site.getReference());\n\t\t\t\tif ( ! siteUpdate ) addMoreToolsUrl = null;\n\n\t\t\t\tif ( ! ServerConfigurationService.getBoolean(\"portal.experimental.addmoretools\", false) ) addMoreToolsUrl = null;\n\n\t\t\t\tm.put(\"isPage\", Boolean.valueOf(true));\n\t\t\t\tm.put(\"current\", Boolean.valueOf(current));\n\t\t\t\tm.put(\"ispopup\", Boolean.valueOf(p.isPopUp()));\n\t\t\t\tm.put(\"pagePopupUrl\", pagePopupUrl);\n\t\t\t\tm.put(\"pageTitle\", Web.escapeHtml(p.getTitle()));\n\t\t\t\tm.put(\"jsPageTitle\", Web.escapeJavascript(p.getTitle()));\n\t\t\t\tm.put(\"pageId\", Web.escapeUrl(p.getId()));\n\t\t\t\tm.put(\"jsPageId\", Web.escapeJavascript(p.getId()));\n\t\t\t\tm.put(\"pageRefUrl\", pagerefUrl);\n\t\t\t\tm.put(\"toolpopup\", Boolean.valueOf(toolPopup));\n\t\t\t\tm.put(\"toolpopupurl\", source);\n\t\t\t\t\n\t\t\t\t// TODO: Should have Web.escapeHtmlAttribute()\n\t\t\t\tString description = desc.toString().replace(\"\\\"\",\"&quot;\");\n\t\t\t\tm.put(\"description\",  description);\n\t\t\t\tm.put(\"hidden\", Boolean.valueOf(hidden));\n\t\t\t\t// toolsOnPage is always null\n\t\t\t\t//if (toolsOnPage != null) m.put(\"toolsOnPage\", toolsOnPage);\n\t\t\t\tif (includeSummary) summarizePage(m, site, p);\n\t\t\t\tif (firstTool != null)\n\t\t\t\t{\n\t\t\t\t\tString menuClass = firstTool.getToolId();\n\t\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t\tProperties tmp = firstTool.getConfig();\n\t\t\t\t\tif ( tmp != null ) {\n\t\t\t\t\t\tString mc = tmp.getProperty(PROP_MENU_CLASS);\n\t\t\t\t\t\tif ( mc != null && mc.length() > 0 ) m.put(\"menuClassOverride\", mc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.put(\"menuClass\", \"icon-default-tool\");\n\t\t\t\t}\n\t\t\t\tm.put(\"pageProps\", createPageProps(p));\n\t\t\t\t// this is here to allow the tool reorder to work\n\t\t\t\tm.put(\"_sitePage\", p);\n\t\t\t\tl.add(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Loop through the tools again and Unroll the tools\n\t\t\tIterator iPt = pTools.iterator();\n\n\t\t\twhile (iPt.hasNext())\n\t\t\t{\n\t\t\t\tToolConfiguration placement = (ToolConfiguration) iPt.next();\n\n\t\t\t\tTool tool = placement.getTool();\n\t\t\t\tif (tool != null)\n\t\t\t\t{\n\t\t\t\t\tString toolrefUrl = toolUrl + Web.escapeUrl(placement.getId());\n\t\t\t\t\t\n\t\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\t\tm.put(\"isPage\", Boolean.valueOf(false));\n\t\t\t\t\tm.put(\"toolId\", Web.escapeUrl(placement.getId()));\n\t\t\t\t\tm.put(\"jsToolId\", Web.escapeJavascript(placement.getId()));\n\t\t\t\t\tm.put(\"toolRegistryId\", placement.getToolId());\n\t\t\t\t\tm.put(\"toolTitle\", Web.escapeHtml(placement.getTitle()));\n\t\t\t\t\tm.put(\"jsToolTitle\", Web.escapeJavascript(placement.getTitle()));\n\t\t\t\t\tm.put(\"toolrefUrl\", toolrefUrl);\n\t\t\t\t\tm.put(\"toolpopup\", Boolean.valueOf(toolPopup));\n\t\t\t\t\tm.put(\"toolpopupurl\", source);\n\t\t\t\t\tString menuClass = placement.getToolId();\n\t\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t\tProperties tmp = placement.getConfig();\n\t\t\t\t\tif ( tmp != null ) {\n\t\t\t\t\t\tString mc = tmp.getProperty(PROP_MENU_CLASS);\n\t\t\t\t\t\tif ( mc != null && mc.length() > 0 ) m.put(\"menuClassOverride\", mc);\n\t\t\t\t\t}\n\t\t\t\t\t// this is here to allow the tool reorder to work if requried.\n\t\t\t\t\tm.put(\"_placement\", placement);\n\t\t\t\t\tl.add(m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tPageFilter pageFilter = portal.getPageFilter();\n\t\tif (pageFilter != null)\n\t\t{\n\t\t\tl = pageFilter.filterPlacements(l, site);\n\t\t}\n\n\t\tif ( addMoreToolsUrl != null ) {\n\t\t\ttheMap.put(\"pageNavAddMoreToolsUrl\", addMoreToolsUrl);\n\t\t\ttheMap.put(\"pageNavCanAddMoreTools\", true);\n\t\t} else {\n\t\t\ttheMap.put(\"pageNavCanAddMoreTools\", false);\n\t\t}\n\n\t\ttheMap.put(\"pageNavTools\", l);\n\t\ttheMap.put(\"pageMaxIfSingle\", ServerConfigurationService.getBoolean(\n\t\t\t\t\"portal.experimental.maximizesinglepage\", false));\n\t\ttheMap.put(\"pageNavToolsCount\", Integer.valueOf(l.size()));\n\n\t\tString helpUrl = ServerConfigurationService.getHelpUrl(null);\n\t\ttheMap.put(\"pageNavShowHelp\", Boolean.valueOf(showHelp));\n\t\ttheMap.put(\"pageNavHelpUrl\", helpUrl);\n\t\ttheMap.put(\"helpMenuClass\", \"icon-sakai-help\");\n\t\ttheMap.put(\"subsiteClass\", \"icon-sakai-subsite\");\n\n\t\t// theMap.put(\"pageNavSitContentshead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_contentshead\")));\n\n\t\t// Display presence? Global property display.users.present may be always / never / true / false\n\t\t// If true or false, the value may be overriden by the site property display-users-present\n\t\t// which may be true or false.\n\t\t\t\t\n\t\tboolean showPresence;\n\t\tString globalShowPresence = ServerConfigurationService.getString(\"display.users.present\",\"true\");\n\t\t\t\t\n\t\tif (\"never\".equals(globalShowPresence)) {\n\t\t\tshowPresence = false;\n\t\t} else if (\"always\".equals(globalShowPresence)) {\n\t\t\tshowPresence = true;\n\t\t} else {\n\t\t\tshowPresence = Boolean.valueOf(globalShowPresence).booleanValue();\n\t\t\tString showPresenceSite = site.getProperties().getProperty(\"display-users-present\");\n\t\t\tif (showPresenceSite != null)\n\t\t\t{\n\t\t\t\tshowPresence = Boolean.valueOf(showPresenceSite).booleanValue();\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t// Check to see if this is a my workspace site, and if so, whether presence is disabled\n\t\tif (showPresence && SiteService.isUserSite(site.getId()) && !ServerConfigurationService.getBoolean(\"display.users.present.myworkspace\", false))\n\t\t\tshowPresence = false;\n\t\t\n\t\tString presenceUrl = Web.returnUrl(req, \"/presence/\"\n\t\t\t\t+ Web.escapeUrl(site.getId()));\n\n\t\t// theMap.put(\"pageNavSitPresenceTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presencetitle\")));\n\t\t// theMap.put(\"pageNavSitPresenceFrameTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presenceiframetit\")));\n\t\ttheMap.put(\"pageNavShowPresenceLoggedIn\", Boolean.valueOf(showPresence\n\t\t\t\t&& loggedIn));\n\t\ttheMap.put(\"pageNavPresenceUrl\", presenceUrl);\n\n\t\t//add softly deleted status\n\t\ttheMap.put(\"softlyDeleted\", site.isSoftlyDeleted());\n\n\t\t// Retrieve whether or not we are to put presence in a frame\n\t\ttheMap.put(\"pageNavPresenceIframe\", Boolean.valueOf(\n\t\t\tServerConfigurationService.getBoolean(\"display.users.present.iframe\", false)) );\n\t\ttheMap.put(\"sakaiPresenceTimeDelay\", Integer.valueOf(\n\t\t\tServerConfigurationService.getInt(\"display.users.present.time.delay\", 3000)) );\n\n\t\treturn theMap;\n\t}","commit_id":"128a2148b770e654424ae77aa092d6bd88ff7e5a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic int doGet(String[] parts, HttpServletRequest req, HttpServletResponse res,\n\t\t\tSession session) throws PortalHandlerException\n\t{\n\t\tif ((parts.length >= 2) && (parts[1].equals(SiteHandler.URL_FRAGMENT)))\n\t\t{\n\t\t\t// This is part of the main portal so we simply remove the attribute\n\t\t\tsession.setAttribute(\"sakai-controlling-portal\", null);\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// recognize an optional page/pageid\n\t\t\t\tString pageId = null;\n\t\t\t\tString toolId = null;\n\n\t\t\t\t// may also have the tool part, so check that length is 5 or greater.\n\t\t\t\tif ((parts.length >= 5) && (parts[3].equals(\"page\")))\n\t\t\t\t{\n\t\t\t\t\tpageId = parts[4];\n\t\t\t\t}\n\n\t\t\t\t// may also have the tool part, so check that length is 5 or greater.\n\t\t\t\tif ((parts.length >= 5) && (parts[3].equals(\"tool\")))\n\t\t\t\t{\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t}\n\n\t\t\t\t// site might be specified\n\t\t\t\tString siteId = null;\n\t\t\t\tif (parts.length >= 3)\n\t\t\t\t{\n\t\t\t\t\tsiteId = parts[2];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString commonToolId = null;\n\t\t\t\t\n\t\t\t\tif(parts.length == 4)\n\t\t\t\t{\n\t\t\t\t\tcommonToolId = parts[3];\n\t\t\t\t}\n\n\t\t\t\tdoSite(req, res, session, siteId, pageId, toolId, commonToolId, parts,\n\t\t\t\t\t\treq.getContextPath() + req.getServletPath());\n\t\t\t\treturn END;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new PortalHandlerException(ex);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NEXT;\n\t\t}\n\t}","id":84098,"modified_method":"@Override\n\tpublic int doGet(String[] parts, HttpServletRequest req, HttpServletResponse res,\n\t\t\tSession session) throws PortalHandlerException\n\t{\n\t\tif ((parts.length >= 2) && (parts[1].equals(SiteHandler.URL_FRAGMENT)))\n\t\t{\n\t\t\t// This is part of the main portal so we simply remove the attribute\n\t\t\tsession.setAttribute(\"sakai-controlling-portal\", null);\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// site might be specified\n\t\t\t\tString siteId = null;\n\t\t\t\tif (parts.length >= 3)\n\t\t\t\t{\n\t\t\t\t\tsiteId = parts[2];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// recognize an optional page/pageid\n\t\t\t\tString pageId = null;\n\t\t\t\tString toolId = null;\n\n\t\t\t\t// may also have the tool part, so check that length is 5 or greater.\n\t\t\t\tif ((parts.length >= 5) && (parts[3].equals(\"page\")))\n\t\t\t\t{\n\t\t\t\t\tpageId = parts[4];\n\t\t\t\t}\n\n\t\t\t\t// Tool resetting URL - clear state and forward to the real tool\n\t\t\t\t// URL\n\t\t\t\t// /portal/site/site-id/tool-reset/toolId\n\t\t\t\t// 0 1 2 3 4\n\t\t\t\tif ((siteId != null) && (parts.length == 5) && (parts[3].equals(\"tool-reset\")))\n\t\t\t\t{\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t\tString toolUrl = req.getContextPath() + \"/site/\" + siteId + \"/tool\"\n\t\t\t\t\t\t+ Web.makePath(parts, 4, parts.length);\n\t\t\t\t\tString queryString = Validator.generateQueryString(req);\n\t\t\t\t\tif (queryString != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttoolUrl = toolUrl + \"?\" + queryString;\n\t\t\t\t\t}\n\t\t\t\t\tportalService.setResetState(\"true\");\n\t\t\t\t\tres.sendRedirect(toolUrl);\n\t\t\t\t\treturn RESET_DONE;\n\t\t\t\t}\n\n\t\t\t\t// may also have the tool part, so check that length is 5 or greater.\n\t\t\t\tif ((parts.length >= 5) && (parts[3].equals(\"tool\")))\n\t\t\t\t{\n\t\t\t\t\ttoolId = parts[4];\n\t\t\t\t}\n\n\t\t\t\tString commonToolId = null;\n\t\t\t\t\n\t\t\t\tif(parts.length == 4)\n\t\t\t\t{\n\t\t\t\t\tcommonToolId = parts[3];\n\t\t\t\t}\n\n\t\t\t\tdoSite(req, res, session, siteId, pageId, toolId, commonToolId, parts,\n\t\t\t\t\t\treq.getContextPath() + req.getServletPath());\n\t\t\t\treturn END;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new PortalHandlerException(ex);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NEXT;\n\t\t}\n\t}","commit_id":"128a2148b770e654424ae77aa092d6bd88ff7e5a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void doSite(HttpServletRequest req, HttpServletResponse res, Session session,\n\t\t\tString siteId, String pageId, String toolId,\n\t\t\tString commonToolId, String [] parts, String toolContextPath) throws ToolException,\n\t\t\tIOException\n\t{\t\t\n\t\t\t\t\n\t\t// default site if not set\n\t\tString userId = session.getUserId();\n\t\tif (siteId == null)\n\t\t{\n\t\t\tif (userId == null)\n\t\t\t{\n\t\t\t\tsiteId = portal.getSiteHelper().getGatewaySiteId();\n\t\t\t\tif (siteId == null)\n\t\t\t\t{\n\t\t\t\t\tsiteId = ServerConfigurationService.getGatewaySiteId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO Should maybe switch to portal.getSiteHelper().getMyWorkspace()\n\t\t\t\tAllSitesViewImpl allSites = (AllSitesViewImpl)portal.getSiteHelper().getSitesView(SiteView.View.ALL_SITES_VIEW, req, session, siteId);\n\t\t\t\tList<Map> sites = (List<Map>)allSites.getRenderContextObject();\n\t\t\t\tif (sites.size() > 0) {\n\t\t\t\t\tsiteId = (String)sites.get(0).get(\"siteId\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsiteId = SiteService.getUserSiteId(userId);\n\t\t\t}\n\t\t}\n\n\t\t// Can get a URL like /portal/site/-/page/-/tool/sakai.rwiki.  \n\t\t// The \"mutable\" site and page can not be given specific values since the \n\t\t// final resolution depends on looking up the specific placement of the tool \n\t\t// with this common id in the my workspace for this user.\n\t\t\n\t\t// check for a mutable site to be resolved here\n\t\tif (mutableSitename.equalsIgnoreCase(siteId) && (session.getUserId() != null)) {\n\t\t\tsiteId = SiteService.getUserSiteId(userId);\n\t\t}\n\n\t\t// find the site, for visiting\n\t\tboolean siteDenied = false;\n\t\tSite site = null;\n\t\ttry\n\t\t{\n\t\t\tSet<SecurityAdvisor> advisors = (Set<SecurityAdvisor>)session.getAttribute(\"sitevisit.security.advisor\");\n\t\t\tif (advisors != null) {\n\t\t\t\tfor (SecurityAdvisor advisor:advisors) {\n\t\t\t\t\tSecurityService.pushAdvisor(advisor);\n\t\t\t\t\t//session.removeAttribute(\"sitevisit.security.advisor\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This should understand aliases as well as IDs\n\t\t\tsite = portal.getSiteHelper().getSiteVisit(siteId);\n\t\t\t\n\t\t\t// SAK-20509 remap the siteId from the Site object we now have, since it may have originally been an alias, but has since been translated.\n\t\t\tsiteId = site.getId();\n\t\t\t\n\t\t}\n\t\tcatch (IdUnusedException e)\n\t\t{\n\t\t}\n\t\tcatch (PermissionException e)\n\t\t{\n\t\t\tif (ServerConfigurationService.getBoolean(\"portal.redirectJoin\", true) &&\n\t\t\t\t\tuserId != null && portal.getSiteHelper().isJoinable(siteId, userId))\n\t\t\t{\n\t\t\t\tString redirectUrl = Web.returnUrl(req, \"/join/\"+siteId);\n\t\t\t\tres.sendRedirect(redirectUrl);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsiteDenied = true;\n\t\t}\n\n\t\tif (site == null)\n\t\t{\t\t\t\t\n\t\t\t// if not logged in, give them a chance\n\t\t\tif (userId == null)\n\t\t\t{\n\t\t\t\tStoredState ss = portalService.newStoredState(\"directtool\", \"tool\");\n\t\t\t\tss.setRequest(req);\n\t\t\t\tss.setToolContextPath(toolContextPath);\n\t\t\t\tportalService.setStoredState(ss);\n\t\t\t\tportal.doLogin(req, res, session, URLUtils.getSafePathInfo(req), false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Post an event for denied site visits by known users.\n\t\t\t\t// This can be picked up to check the user state and refresh it if stale,\n\t\t\t\t// such as showing links to sites that are no longer accessible.\n\t\t\t\t// It is also helpful for event log analysis for user trouble or bad behavior.\n\t\t\t\tif (siteDenied)\n\t\t\t\t{\n\t\t\t\t\tEvent event = EventTrackingService.newEvent(SiteService.EVENT_SITE_VISIT_DENIED, siteId, false);\n\t\t\t\t\tEventTrackingService.post(event);\n\t\t\t\t}\n\t\t\t\tportal.doError(req, res, session, Portal.ERROR_SITE);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Supports urls like: /portal/site/{SITEID}/sakai.announcements\n\t\tif(site != null && commonToolId != null)\n\t\t{\n\t\t\tToolConfiguration tc = null;\n\t\t\tif(!commonToolId.startsWith(\"sakai.\"))\n\t\t\t{\n\t\t\t\t// Try the most likely case first, that of common tool ids starting with 'sakai.'\n\t\t\t\ttc = site.getToolForCommonId(\"sakai.\" + commonToolId);\n\t\t\t\tif(tc == null)\n\t\t\t\t{\n\t\t\t\t\t// That failed, try the supplied tool id\n\t\t\t\t\ttc = site.getToolForCommonId(commonToolId);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tc != null)\n\t\t\t{\n\t\t\t\tpageId = tc.getPageId();\n\t\t\t}\n\t\t}\n\n\t\t// Find the pageId looking backwards through the toolId\n\t\tif(site != null && pageId == null && toolId != null ) {\n\t\t\tList pages = site.getOrderedPages();\n\t\t\tfor (Iterator i = pages.iterator(); i.hasNext();)\n\t\t\t{\n\n\t\t\t\tSitePage p = (SitePage) i.next();\n\t\t\t\t// check if current user has permission to see page\n\t\t\t\t// we will draw page button if it have permission to see at least\n\t\t\t\t// one tool on the page\n\t\t\t\tList<ToolConfiguration> pTools = p.getTools();\n\t\t\t\tIterator<ToolConfiguration> toolz = pTools.iterator();\n\t            while(toolz.hasNext()){\n\t\t\t\t\tToolConfiguration tc = toolz.next();\n\t\t\t\t\tTool to = tc.getTool();\n\t\t\t\t\tif ( toolId.equals(tc.getId()) ) {\n\t\t\t\t\t\tpageId = p.getId();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( pageId != null ) break;\n\t\t\t}\n\t\t}\n\n\t\t// if no page id, see if there was a last page visited for this site\n\t\tif (pageId == null)\n\t\t{\n\t\t\tpageId = (String) session.getAttribute(Portal.ATTR_SITE_PAGE + siteId);\n\t\t}\n\n\t\t// If the page is the mutable page name then look up the \n\t\t// real page id from the tool name.\n\t\tif (mutablePagename.equalsIgnoreCase(pageId)) {\n\t\t\tpageId = findPageIdFromToolId(pageId, URLUtils.getSafePathInfo(req), site);\n\t\t}\n\t\t\n\t\t// clear the last page visited\n\t\tsession.removeAttribute(Portal.ATTR_SITE_PAGE + siteId);\n\n\t\t// form a context sensitive title\n\t\tString title = ServerConfigurationService.getString(\"ui.service\",\"Sakai\") + \" : \"\n\t\t\t\t+ site.getTitle();\n\n\t\t// Lookup the page in the site - enforcing access control\n\t\t// business rules\n\t\tSitePage page = portal.getSiteHelper().lookupSitePage(pageId, site);\n\t\tif (page != null)\n\t\t{\n\t\t\t// store the last page visited\n\t\t\tsession.setAttribute(Portal.ATTR_SITE_PAGE + siteId, page.getId());\n\t\t\ttitle += \" : \" + page.getTitle();\n\t\t}\n\n\n\n\n\t\t// Create and initialize a copy of the PDA Handler\n\t\tPDAHandler pdah = new PDAHandler();\n\t\tpdah.register(portal,portalService,servletContext);\n\n       // See if we can buffer the content, if not, pass the request through\n       String TCP = null;\n       String toolPathInfo = null;\n       boolean allowBuffer = false;\n       Object BC = null;\n\n\t\tToolConfiguration siteTool = null;\n\t\tif ( toolId != null ) {\n\t\t\tsiteTool = SiteService.findTool(toolId);\nSystem.out.println(\"toolId=\"+toolId);\n            if ( siteTool != null && parts.length >= 5 ) {\n                commonToolId = siteTool.getToolId();\n\n                // Does the tool allow us to buffer?\n                allowBuffer = pdah.allowBufferContent(req, siteTool);\n\n                if ( allowBuffer ) {\n                    TCP = req.getContextPath() + req.getServletPath() + Web.makePath(parts, 1, 5);\n                    toolPathInfo = Web.makePath(parts, 5, parts.length);\n\n                    // Should we bypass buffering based on the request?\n                    boolean matched = pdah.checkBufferBypass(req, siteTool);\n\n                    if ( matched ) {\nSystem.out.println(\"Forwarded...\");\n                        ActiveTool tool = ActiveToolManager.getActiveTool(commonToolId);\n                        portal.forwardTool(tool, req, res, siteTool,\n                            siteTool.getSkin(), TCP, toolPathInfo);\n                        return;\n                    }\n                }\n           }\n\t\t}\n\n\n\n\n\n\t\t// start the response\n\t\tString siteType = portal.calcSiteType(siteId);\n\t\tPortalRenderContext rcontext = portal.startPageContext(siteType, title, site\n\t\t\t\t.getSkin(), req);\n\n\n        if ( allowBuffer ) {\n            BC = pdah.bufferContent(req, res, session, toolId,\n                    TCP, toolPathInfo, siteTool);\n\nSystem.out.println(\"buffer attempt\");\n            // If the buffered response was not parseable\n            if ( BC instanceof ByteArrayServletResponse ) {\nSystem.out.println(\"The output could not be be buffered...\");\n                ByteArrayServletResponse bufferResponse = (ByteArrayServletResponse) BC;\n                bufferResponse.forwardResponse();\n                return;\n            }\n        }\n\n\n        // Include the buffered content if we have it\n        if ( BC instanceof Map ) {\nSystem.out.println(\"Buffered...\");\n            rcontext.put(\"bufferedResponse\", Boolean.TRUE);\n            Map<String,String> bufferMap = (Map<String,String>) BC;\n            rcontext.put(\"responseHead\", (String) bufferMap.get(\"responseHead\"));\n            rcontext.put(\"responseBody\", (String) bufferMap.get(\"responseBody\"));\n        }\n\n\n\n\n\n\n\t\t\n\t\t// Have we been requested to display minimized and are we logged in?\n\t\tif (session.getUserId() != null ) {\n\t\t\tCookie c = portal.findCookie(req, portal.SAKAI_NAV_MINIMIZED);\n                        String reqParm = req.getParameter(portal.SAKAI_NAV_MINIMIZED);\n                \tString minStr = ServerConfigurationService.getString(\"portal.allow.auto.minimize\",\"true\");\n                \tif ( c != null && \"true\".equals(c.getValue()) ) {\n\t\t\t\trcontext.put(portal.SAKAI_NAV_MINIMIZED, Boolean.TRUE);\n\t\t\t} else if ( reqParm != null &&  \"true\".equals(reqParm) && ! \"false\".equals(minStr) ) {\n\t\t\t\trcontext.put(portal.SAKAI_NAV_MINIMIZED, Boolean.TRUE);\n\t\t\t}\n\t\t}\n\n\t\trcontext.put(\"siteId\", siteId);\n\t\tboolean showShortDescription = Boolean.valueOf(ServerConfigurationService.getBoolean(\"portal.title.shortdescription.show\", false));\n\n\t\tif (showShortDescription) {\n\t\t\trcontext.put(\"shortDescription\", Web.escapeHtml(site.getShortDescription()));\n\t\t}\n\t\trcontext.put(\"siteTitle\", Web.escapeHtml(site.getTitle()));\n\n\t\taddLocale(rcontext, site, session.getUserId());\n\t\t\n\t\tincludeSiteNav(rcontext, req, session, siteId);\n\n\t\tincludeWorksite(rcontext, res, req, session, site, page, toolContextPath,\n\t\t\t\t\tgetUrlFragment());\n\n\t\t// Include sub-sites if appropriate\n\t\t// TODO: Think through whether we want reset tools or not\n\t\tportal.includeSubSites(rcontext, req, session, siteId, req.getContextPath()\n\t\t\t\t+ req.getServletPath(), getUrlFragment(),\n\t\t\t\t/* resetTools */false);\n\n\t\tportal.includeBottom(rcontext);\n\n\t\t//Log the visit into SAKAI_EVENT - begin\n\t\ttry{\n\t\t\tboolean presenceEvents = ServerConfigurationService.getBoolean(\"presence.events.log\", true);\n\t\t\tif (presenceEvents)\n\t\t\t\torg.sakaiproject.presence.cover.PresenceService.setPresence(siteId + \"-presence\");\n\t\t}catch(Exception e){}\n\t\t//End - log the visit into SAKAI_EVENT\t\t\n\n\t\trcontext.put(\"currentUrlPath\", Web.serverUrl(req) + req.getContextPath()\n\t\t\t\t+ URLUtils.getSafePathInfo(req));\n\n\t\tdoSendResponse(rcontext, res, null);\n\n\t\tStoredState ss = portalService.getStoredState();\n\t\tif (ss != null && toolContextPath.equals(ss.getToolContextPath()))\n\t\t{\n\t\t\t// This request is the destination of the request\n\t\t\tportalService.setStoredState(null);\n\t\t}\n\t\t\n\t\t\n\t}","id":84099,"modified_method":"public void doSite(HttpServletRequest req, HttpServletResponse res, Session session,\n\t\t\tString siteId, String pageId, String toolId,\n\t\t\tString commonToolId, String [] parts, String toolContextPath) throws ToolException,\n\t\t\tIOException\n\t{\t\t\n\t\t\t\t\n\t\t// default site if not set\n\t\tString userId = session.getUserId();\n\t\tif (siteId == null)\n\t\t{\n\t\t\tif (userId == null)\n\t\t\t{\n\t\t\t\tsiteId = portal.getSiteHelper().getGatewaySiteId();\n\t\t\t\tif (siteId == null)\n\t\t\t\t{\n\t\t\t\t\tsiteId = ServerConfigurationService.getGatewaySiteId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO Should maybe switch to portal.getSiteHelper().getMyWorkspace()\n\t\t\t\tAllSitesViewImpl allSites = (AllSitesViewImpl)portal.getSiteHelper().getSitesView(SiteView.View.ALL_SITES_VIEW, req, session, siteId);\n\t\t\t\tList<Map> sites = (List<Map>)allSites.getRenderContextObject();\n\t\t\t\tif (sites.size() > 0) {\n\t\t\t\t\tsiteId = (String)sites.get(0).get(\"siteId\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsiteId = SiteService.getUserSiteId(userId);\n\t\t\t}\n\t\t}\n\n\t\t// Can get a URL like /portal/site/-/page/-/tool/sakai.rwiki.  \n\t\t// The \"mutable\" site and page can not be given specific values since the \n\t\t// final resolution depends on looking up the specific placement of the tool \n\t\t// with this common id in the my workspace for this user.\n\t\t\n\t\t// check for a mutable site to be resolved here\n\t\tif (mutableSitename.equalsIgnoreCase(siteId) && (session.getUserId() != null)) {\n\t\t\tsiteId = SiteService.getUserSiteId(userId);\n\t\t}\n\n\t\t// find the site, for visiting\n\t\tboolean siteDenied = false;\n\t\tSite site = null;\n\t\ttry\n\t\t{\n\t\t\tSet<SecurityAdvisor> advisors = (Set<SecurityAdvisor>)session.getAttribute(\"sitevisit.security.advisor\");\n\t\t\tif (advisors != null) {\n\t\t\t\tfor (SecurityAdvisor advisor:advisors) {\n\t\t\t\t\tSecurityService.pushAdvisor(advisor);\n\t\t\t\t\t//session.removeAttribute(\"sitevisit.security.advisor\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This should understand aliases as well as IDs\n\t\t\tsite = portal.getSiteHelper().getSiteVisit(siteId);\n\t\t\t\n\t\t\t// SAK-20509 remap the siteId from the Site object we now have, since it may have originally been an alias, but has since been translated.\n\t\t\tsiteId = site.getId();\n\t\t\t\n\t\t}\n\t\tcatch (IdUnusedException e)\n\t\t{\n\t\t}\n\t\tcatch (PermissionException e)\n\t\t{\n\t\t\tif (ServerConfigurationService.getBoolean(\"portal.redirectJoin\", true) &&\n\t\t\t\t\tuserId != null && portal.getSiteHelper().isJoinable(siteId, userId))\n\t\t\t{\n\t\t\t\tString redirectUrl = Web.returnUrl(req, \"/join/\"+siteId);\n\t\t\t\tres.sendRedirect(redirectUrl);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsiteDenied = true;\n\t\t}\n\n\t\tif (site == null)\n\t\t{\t\t\t\t\n\t\t\t// if not logged in, give them a chance\n\t\t\tif (userId == null)\n\t\t\t{\n\t\t\t\tStoredState ss = portalService.newStoredState(\"directtool\", \"tool\");\n\t\t\t\tss.setRequest(req);\n\t\t\t\tss.setToolContextPath(toolContextPath);\n\t\t\t\tportalService.setStoredState(ss);\n\t\t\t\tportal.doLogin(req, res, session, URLUtils.getSafePathInfo(req), false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Post an event for denied site visits by known users.\n\t\t\t\t// This can be picked up to check the user state and refresh it if stale,\n\t\t\t\t// such as showing links to sites that are no longer accessible.\n\t\t\t\t// It is also helpful for event log analysis for user trouble or bad behavior.\n\t\t\t\tif (siteDenied)\n\t\t\t\t{\n\t\t\t\t\tEvent event = EventTrackingService.newEvent(SiteService.EVENT_SITE_VISIT_DENIED, siteId, false);\n\t\t\t\t\tEventTrackingService.post(event);\n\t\t\t\t}\n\t\t\t\tportal.doError(req, res, session, Portal.ERROR_SITE);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Supports urls like: /portal/site/{SITEID}/sakai.announcements\n\t\tif(site != null && commonToolId != null)\n\t\t{\n\t\t\tToolConfiguration tc = null;\n\t\t\tif(!commonToolId.startsWith(\"sakai.\"))\n\t\t\t{\n\t\t\t\t// Try the most likely case first, that of common tool ids starting with 'sakai.'\n\t\t\t\ttc = site.getToolForCommonId(\"sakai.\" + commonToolId);\n\t\t\t\tif(tc == null)\n\t\t\t\t{\n\t\t\t\t\t// That failed, try the supplied tool id\n\t\t\t\t\ttc = site.getToolForCommonId(commonToolId);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tc != null)\n\t\t\t{\n\t\t\t\tpageId = tc.getPageId();\n\t\t\t}\n\t\t}\n\n\t\t// Find the pageId looking backwards through the toolId\n\t\tif(site != null && pageId == null && toolId != null ) {\n\t\t\tList pages = site.getOrderedPages();\n\t\t\tfor (Iterator i = pages.iterator(); i.hasNext();)\n\t\t\t{\n\n\t\t\t\tSitePage p = (SitePage) i.next();\n\t\t\t\t// check if current user has permission to see page\n\t\t\t\t// we will draw page button if it have permission to see at least\n\t\t\t\t// one tool on the page\n\t\t\t\tList<ToolConfiguration> pTools = p.getTools();\n\t\t\t\tIterator<ToolConfiguration> toolz = pTools.iterator();\n\t\t\t\twhile(toolz.hasNext()){\n\t\t\t\t\tToolConfiguration tc = toolz.next();\n\t\t\t\t\tTool to = tc.getTool();\n\t\t\t\t\tif ( toolId.equals(tc.getId()) ) {\n\t\t\t\t\t\tpageId = p.getId();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( pageId != null ) break;\n\t\t\t}\n\t\t}\n\n\t\t// if no page id, see if there was a last page visited for this site\n\t\tif (pageId == null)\n\t\t{\n\t\t\tpageId = (String) session.getAttribute(Portal.ATTR_SITE_PAGE + siteId);\n\t\t}\n\n\t\t// If the page is the mutable page name then look up the \n\t\t// real page id from the tool name.\n\t\tif (mutablePagename.equalsIgnoreCase(pageId)) {\n\t\t\tpageId = findPageIdFromToolId(pageId, URLUtils.getSafePathInfo(req), site);\n\t\t}\n\t\t\n\t\t// clear the last page visited\n\t\tsession.removeAttribute(Portal.ATTR_SITE_PAGE + siteId);\n\n\t\t// form a context sensitive title\n\t\tString title = ServerConfigurationService.getString(\"ui.service\",\"Sakai\") + \" : \"\n\t\t\t\t+ site.getTitle();\n\n\t\t// Lookup the page in the site - enforcing access control\n\t\t// business rules\n\t\tSitePage page = portal.getSiteHelper().lookupSitePage(pageId, site);\n\t\tif (page != null)\n\t\t{\n\t\t\t// store the last page visited\n\t\t\tsession.setAttribute(Portal.ATTR_SITE_PAGE + siteId, page.getId());\n\t\t\ttitle += \" : \" + page.getTitle();\n\t\t}\n\n\n\n\n\t\t// Create and initialize a copy of the PDA Handler\n\t\tPDAHandler pdah = new PDAHandler();\n\t\tpdah.register(portal,portalService,servletContext);\n\n\t\t// See if we can buffer the content, if not, pass the request through\n\t\tString TCP = null;\n\t\tString toolPathInfo = null;\n\t\tboolean allowBuffer = false;\n\t\tObject BC = null;\n\n\t\tToolConfiguration siteTool = null;\n\t\tif ( toolId != null ) {\n\t\t\tsiteTool = SiteService.findTool(toolId);\n\t\t\tif ( siteTool != null && parts.length >= 5 ) {\n\t\t\t\tcommonToolId = siteTool.getToolId();\n\n\t\t\t\t// Does the tool allow us to buffer?\n\t\t\t\tallowBuffer = pdah.allowBufferContent(req, siteTool);\n\n\t\t\t\tif ( allowBuffer ) {\n\t\t\t\t\tTCP = req.getContextPath() + req.getServletPath() + Web.makePath(parts, 1, 5);\n\t\t\t\t\ttoolPathInfo = Web.makePath(parts, 5, parts.length);\n\n\t\t\t\t\t// Should we bypass buffering based on the request?\n\t\t\t\t\tboolean matched = pdah.checkBufferBypass(req, siteTool);\n\n\t\t\t\t\tif ( matched ) {\n\t\t\t\t\t\tActiveTool tool = ActiveToolManager.getActiveTool(commonToolId);\n\t\t\t\t\t\tportal.forwardTool(tool, req, res, siteTool,\n\t\t\t\t\t\t\tsiteTool.getSkin(), TCP, toolPathInfo);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\n\t\t// start the response\n\t\tString siteType = portal.calcSiteType(siteId);\n\t\tPortalRenderContext rcontext = portal.startPageContext(siteType, title, site\n\t\t\t\t.getSkin(), req);\n\n\n\t\tif ( allowBuffer ) {\n\t\t\tBC = pdah.bufferContent(req, res, session, toolId,\n\t\t\t\t\tTCP, toolPathInfo, siteTool);\n\n\t\t\t// If the buffered response was not parseable\n\t\t\tif ( BC instanceof ByteArrayServletResponse ) {\n\t\t\t\tStringBuffer queryUrl = req.getRequestURL();\n\t\t\t\tString queryString = req.getQueryString();\n\t\t\t\tif ( queryString != null ) queryUrl.append('?').append(queryString);\n\t\t\t\tlog.debug(\"Post buffer bypass CTI=\"+commonToolId+\" URL=\"+queryUrl);\nSystem.out.println(\"Post buffer bypass CTI=\"+commonToolId+\" URL=\"+queryUrl);\n\t\t\t\tByteArrayServletResponse bufferResponse = (ByteArrayServletResponse) BC;\n\t\t\t\tbufferResponse.forwardResponse();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\t// Include the buffered content if we have it\n\t\tif ( BC instanceof Map ) {\n\t\t\trcontext.put(\"bufferedResponse\", Boolean.TRUE);\n\t\t\tMap<String,String> bufferMap = (Map<String,String>) BC;\n\t\t\trcontext.put(\"responseHead\", (String) bufferMap.get(\"responseHead\"));\n\t\t\trcontext.put(\"responseBody\", (String) bufferMap.get(\"responseBody\"));\n\t\t}\n\n\n\n\n\n\n\t\t\n\t\t// Have we been requested to display minimized and are we logged in?\n\t\tif (session.getUserId() != null ) {\n\t\t\tCookie c = portal.findCookie(req, portal.SAKAI_NAV_MINIMIZED);\n                        String reqParm = req.getParameter(portal.SAKAI_NAV_MINIMIZED);\n                \tString minStr = ServerConfigurationService.getString(\"portal.allow.auto.minimize\",\"true\");\n                \tif ( c != null && \"true\".equals(c.getValue()) ) {\n\t\t\t\trcontext.put(portal.SAKAI_NAV_MINIMIZED, Boolean.TRUE);\n\t\t\t} else if ( reqParm != null &&  \"true\".equals(reqParm) && ! \"false\".equals(minStr) ) {\n\t\t\t\trcontext.put(portal.SAKAI_NAV_MINIMIZED, Boolean.TRUE);\n\t\t\t}\n\t\t}\n\n\t\trcontext.put(\"siteId\", siteId);\n\t\tboolean showShortDescription = Boolean.valueOf(ServerConfigurationService.getBoolean(\"portal.title.shortdescription.show\", false));\n\n\t\tif (showShortDescription) {\n\t\t\trcontext.put(\"shortDescription\", Web.escapeHtml(site.getShortDescription()));\n\t\t}\n\t\trcontext.put(\"siteTitle\", Web.escapeHtml(site.getTitle()));\n\n\t\taddLocale(rcontext, site, session.getUserId());\n\t\t\n\t\tincludeSiteNav(rcontext, req, session, siteId);\n\n\t\tincludeWorksite(rcontext, res, req, session, site, page, toolContextPath,\n\t\t\t\t\tgetUrlFragment());\n\n\t\t// Include sub-sites if appropriate\n\t\t// TODO: Think through whether we want reset tools or not\n\t\tportal.includeSubSites(rcontext, req, session, siteId, req.getContextPath()\n\t\t\t\t+ req.getServletPath(), getUrlFragment(),\n\t\t\t\t/* resetTools */false);\n\n\t\tportal.includeBottom(rcontext);\n\n\t\t//Log the visit into SAKAI_EVENT - begin\n\t\ttry{\n\t\t\tboolean presenceEvents = ServerConfigurationService.getBoolean(\"presence.events.log\", true);\n\t\t\tif (presenceEvents)\n\t\t\t\torg.sakaiproject.presence.cover.PresenceService.setPresence(siteId + \"-presence\");\n\t\t}catch(Exception e){}\n\t\t//End - log the visit into SAKAI_EVENT\t\t\n\n\t\trcontext.put(\"currentUrlPath\", Web.serverUrl(req) + req.getContextPath()\n\t\t\t\t+ URLUtils.getSafePathInfo(req));\n\n\t\tdoSendResponse(rcontext, res, null);\n\n\t\tStoredState ss = portalService.getStoredState();\n\t\tif (ss != null && toolContextPath.equals(ss.getToolContextPath()))\n\t\t{\n\t\t\t// This request is the destination of the request\n\t\t\tportalService.setStoredState(null);\n\t\t}\n\t\t\n\t\t\n\t}","commit_id":"128a2148b770e654424ae77aa092d6bd88ff7e5a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@NotNull\n  @Override\n  public String[] getAdditionalParameters() {\n    String[] customProfileArg;\n    if (myUseCustomProfile && myUserDataDirectoryPath != null) {\n      customProfileArg = new String[]{USER_DATA_DIR_ARG + FileUtil.toSystemDependentName(myUserDataDirectoryPath)};\n    }\n    else {\n      customProfileArg = ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    String[] remoteShellArg;\n    if (myEnableRemoteDebug) {\n      remoteShellArg = new String[]{REMOTE_DEBUGGING_PORT_ARG + myRemoteShellPort};\n    }\n    else {\n      remoteShellArg = ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    return ArrayUtil.mergeArrays(ParametersList.parse(myCommandLineOptions), ArrayUtil.mergeArrays(customProfileArg, remoteShellArg));\n  }","id":84100,"modified_method":"@NotNull\n  @Override\n  public String[] getAdditionalParameters() {\n    String[] cliOptions = ParametersList.parse(myCommandLineOptions);\n    if (myUseCustomProfile && myUserDataDirectoryPath != null) {\n      return ArrayUtil.mergeArrays(cliOptions, USER_DATA_DIR_ARG + FileUtil.toSystemDependentName(myUserDataDirectoryPath));\n    }\n    else {\n      return cliOptions;\n    }\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChromeSettingsConfigurable(@NotNull ChromeSettings settings) {\n    mySettings = settings;\n    myUserDataDirField.addBrowseFolderListener(\"Select User Data Directory\", \"Specifies the directory that user data (your \\\"profile\\\") is kept in\", null,\n                                               FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    myUseCustomProfileCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myUserDataDirField.setEnabled(myUseCustomProfileCheckBox.isSelected());\n      }\n    });\n    myDefaultUserDirPath = getDefaultUserDataPath();\n    myEnableRemoteDebugCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myPortField.setEnabled(myEnableRemoteDebugCheckBox.isSelected());\n      }\n    });\n    myCommandLineOptionsEditor.setDialogCaption(\"Chrome Command Line Options\");\n    myCommandLineOptionsLabel.setLabelFor(myCommandLineOptionsEditor.getTextField());\n  }","id":84101,"modified_method":"public ChromeSettingsConfigurable(@NotNull ChromeSettings settings) {\n    mySettings = settings;\n    myUserDataDirField.addBrowseFolderListener(\"Select User Data Directory\", \"Specifies the directory that user data (your \\\"profile\\\") is kept in\", null,\n                                               FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    myUseCustomProfileCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myUserDataDirField.setEnabled(myUseCustomProfileCheckBox.isSelected());\n      }\n    });\n    myDefaultUserDirPath = getDefaultUserDataPath();\n    myCommandLineOptionsEditor.setDialogCaption(\"Chrome Command Line Options\");\n    myCommandLineOptionsLabel.setLabelFor(myCommandLineOptionsEditor.getTextField());\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void enableRecommendedOptions() {\n    if (!myUseCustomProfileCheckBox.isSelected()) {\n      myUseCustomProfileCheckBox.doClick(0);\n    }\n    if (!myEnableRemoteDebugCheckBox.isSelected()) {\n      myEnableRemoteDebugCheckBox.doClick(0);\n    }\n  }","id":84102,"modified_method":"public void enableRecommendedOptions() {\n    if (!myUseCustomProfileCheckBox.isSelected()) {\n      myUseCustomProfileCheckBox.doClick(0);\n    }\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isModified() {\n    if (myEnableRemoteDebugCheckBox.isSelected() != mySettings.isEnableRemoteDebug()\n        || !myPortField.getText().equals(String.valueOf(mySettings.getRemoteShellPort()))\n        || myUseCustomProfileCheckBox.isSelected() != mySettings.isUseCustomProfile()\n        || !myCommandLineOptionsEditor.getText().equals(mySettings.getCommandLineOptions())) {\n      return true;\n    }\n\n    String configuredPath = getConfiguredUserDataDirPath();\n    String storedPath = mySettings.getUserDataDirectoryPath();\n    if (myDefaultUserDirPath.equals(configuredPath) && storedPath == null) return false;\n    return !configuredPath.equals(storedPath);\n  }","id":84103,"modified_method":"@Override\n  public boolean isModified() {\n    if (myUseCustomProfileCheckBox.isSelected() != mySettings.isUseCustomProfile()\n        || !myCommandLineOptionsEditor.getText().equals(mySettings.getCommandLineOptions())) {\n      return true;\n    }\n\n    String configuredPath = getConfiguredUserDataDirPath();\n    String storedPath = mySettings.getUserDataDirectoryPath();\n    if (myDefaultUserDirPath.equals(configuredPath) && storedPath == null) return false;\n    return !configuredPath.equals(storedPath);\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void reset() {\n    myEnableRemoteDebugCheckBox.setSelected(mySettings.isEnableRemoteDebug());\n    myPortField.setText(String.valueOf(mySettings.getRemoteShellPort()));\n    myPortField.setEnabled(mySettings.isEnableRemoteDebug());\n\n    myCommandLineOptionsEditor.setText(mySettings.getCommandLineOptions());\n    myUseCustomProfileCheckBox.setSelected(mySettings.isUseCustomProfile());\n    myUserDataDirField.setEnabled(mySettings.isUseCustomProfile());\n    String path = mySettings.getUserDataDirectoryPath();\n    if (path != null) {\n      myUserDataDirField.setText(FileUtil.toSystemDependentName(path));\n    }\n    else {\n      myUserDataDirField.setText(myDefaultUserDirPath);\n    }\n  }","id":84104,"modified_method":"@Override\n  public void reset() {\n    myCommandLineOptionsEditor.setText(mySettings.getCommandLineOptions());\n    myUseCustomProfileCheckBox.setSelected(mySettings.isUseCustomProfile());\n    myUserDataDirField.setEnabled(mySettings.isUseCustomProfile());\n    String path = mySettings.getUserDataDirectoryPath();\n    if (path != null) {\n      myUserDataDirField.setText(FileUtil.toSystemDependentName(path));\n    }\n    else {\n      myUserDataDirField.setText(myDefaultUserDirPath);\n    }\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void apply() throws ConfigurationException {\n    try {\n      mySettings.setRemoteShellPort(Integer.parseInt(myPortField.getText()));\n    }\n    catch (NumberFormatException ignored) {\n      throw new ConfigurationException(\"Port is not integer!\");\n    }\n    mySettings.setCommandLineOptions(myCommandLineOptionsEditor.getText());\n    mySettings.setUseCustomProfile(myUseCustomProfileCheckBox.isSelected());\n    mySettings.setUserDataDirectoryPath(getConfiguredUserDataDirPath());\n    mySettings.setEnableRemoteDebug(myEnableRemoteDebugCheckBox.isSelected());\n  }","id":84105,"modified_method":"@Override\n  public void apply() throws ConfigurationException {\n    mySettings.setCommandLineOptions(myCommandLineOptionsEditor.getText());\n    mySettings.setUseCustomProfile(myUseCustomProfileCheckBox.isSelected());\n    mySettings.setUserDataDirectoryPath(getConfiguredUserDataDirPath());\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doLaunchBrowser(final BrowsersConfiguration.BrowserFamily family,\n                                     @NotNull String url,\n                                     @NotNull String[] additionalParameters,\n                                     @NotNull Condition<String> browserSpecificParametersFilter,\n                                     final boolean forceOpenNewInstanceOnMac) {\n    final WebBrowserSettings settings = BrowsersConfiguration.getInstance().getBrowserSettings(family);\n    final String path = settings.getPath();\n    String pathCheckResult = BrowsersConfiguration.checkPath(family, path);\n    if (pathCheckResult == null) {\n      try {\n        BrowserSpecificSettings specificSettings = settings.getBrowserSpecificSettings();\n        List<String> parameters = specificSettings == null\n                                  ? (additionalParameters.length == 0 ? Collections.<String>emptyList() : new ArrayList<String>())\n                                  : ContainerUtil.findAll(specificSettings.getAdditionalParameters(), browserSpecificParametersFilter);\n        Collections.addAll(parameters, additionalParameters);\n        launchBrowser(path, BrowserUtil.escapeUrl(url), forceOpenNewInstanceOnMac, parameters);\n      }\n      catch (IOException e) {\n        Messages.showErrorDialog(e.getMessage(), XmlBundle.message(\"browser.error\"));\n      }\n    }\n    else {\n      Messages.showErrorDialog(pathCheckResult, XmlBundle.message(\"browser.path.not.specified.title\"));\n    }\n  }","id":84106,"modified_method":"public static void doLaunchBrowser(final BrowsersConfiguration.BrowserFamily family,\n                                     @Nullable String url,\n                                     @NotNull String[] additionalParameters,\n                                     @NotNull Condition<String> browserSpecificParametersFilter,\n                                     final boolean forceOpenNewInstanceOnMac) {\n    final WebBrowserSettings settings = BrowsersConfiguration.getInstance().getBrowserSettings(family);\n    final String path = settings.getPath();\n    if (StringUtil.isEmpty(path)) {\n      Messages.showErrorDialog(XmlBundle.message(\"browser.path.not.specified\", family.getName()), XmlBundle.message(\"browser.path.not.specified.title\"));\n      return;\n    }\n\n    try {\n      BrowserSpecificSettings specificSettings = settings.getBrowserSpecificSettings();\n      List<String> parameters = specificSettings == null\n                                ? (additionalParameters.length == 0 ? Collections.<String>emptyList() : new ArrayList<String>())\n                                : ContainerUtil.findAll(specificSettings.getAdditionalParameters(), browserSpecificParametersFilter);\n      Collections.addAll(parameters, additionalParameters);\n      launchBrowser(path, url == null ? null : BrowserUtil.escapeUrl(url), forceOpenNewInstanceOnMac, parameters);\n    }\n    catch (IOException e) {\n      Messages.showErrorDialog(e.getMessage(), XmlBundle.message(\"browser.error\"));\n    }\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void launchBrowser(String browserPath, String url, boolean forceOpenNewInstanceOnMac, List<String> browserArgs)\n    throws IOException {\n    final List<String> command = BrowserUtil.getOpenBrowserCommand(browserPath);\n    if (SystemInfo.isMac && ExecUtil.getOpenCommandPath().equals(command.get(0))) {\n      if (forceOpenNewInstanceOnMac) {\n        command.add(\"-n\");\n      }\n      command.add(url);\n\n      if (!browserArgs.isEmpty()) {\n        if (BrowserUtil.isOpenCommandSupportArgs()) {\n          command.add(\"--args\");\n          command.addAll(browserArgs);\n        }\n        else {\n          LOG.warn(\n            \"'open' command doesn't allow to pass command line arguments so they will be ignored: \" + StringUtil.join(browserArgs, \" \"));\n        }\n      }\n    }\n    else {\n      command.add(url);\n      command.addAll(browserArgs);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching browser: \" + StringUtil.join(browserArgs, \" \"));\n    }\n    new ProcessBuilder(command).start();\n  }","id":84107,"modified_method":"private static void launchBrowser(String browserPath, @Nullable String url, boolean forceOpenNewInstanceOnMac, List<String> browserArgs)\n    throws IOException {\n    List<String> command = BrowserUtil.getOpenBrowserCommand(browserPath);\n    addArgs(command, browserArgs, url, forceOpenNewInstanceOnMac);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching browser: \" + StringUtil.join(browserArgs, \" \"));\n    }\n    new ProcessBuilder(command).start();\n  }","commit_id":"4717f5373a55cd2403ff2f574cf0c7d6f2bdc6d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void dumpStatistics() {\n    IOStatistics.dump(\"pagecount:\" + pagesCount + \", height:\" + height + \", movedMembers:\"+movedMembersCount +\n                      \", hash steps:\" + maxStepsSearchedInHash + \", avg search in hash:\" + (totalHashStepsSearched / hashSearchRequests));\n  }","id":84108,"modified_method":"void dumpStatistics() {\n    int leafPages = height == 3 ? pagesCount - (1 + root.getChildrenCount() + 1):height == 2 ? pagesCount - 1:1;\n    long leafNodesCapacity = hashedPagesCount * maxLeafNodesInHash + (leafPages - hashedPagesCount)* maxLeafNodes;\n    long leafNodesCapacity2 = leafPages * maxLeafNodes;\n    int usedPercent = (int)((count * 100L) / leafNodesCapacity);\n    int usedPercent2 = (int)((count * 100L) / leafNodesCapacity2);\n    IOStatistics.dump(\"pagecount:\" + pagesCount + \", height:\" + height + \", movedMembers:\"+movedMembersCount +\n                      \", hash steps:\" + maxStepsSearchedInHash + \", avg search in hash:\" + (totalHashStepsSearched / hashSearchRequests) +\n                      \", leaf pages used:\" + usedPercent + \"%, leaf pages used if max children: \" + usedPercent2 + \"%\" );\n  }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int locate(int valueHC, boolean split) {\n      int searched = 0;\n      int parentAddress = 0;\n\n      while(true) {\n        if (split && isFull()) {\n          parentAddress = splitNode(parentAddress);\n          setAddress(parentAddress);\n          --searched;\n        }\n\n        int i = search(valueHC);\n\n        ++searched;\n\n        if (isIndexLeaf()) {\n          btree.height = Math.max(btree.height, searched);\n          return i;\n        }\n\n        int address = i < 0 ? addressAt(-i - 1):addressAt(i + 1);\n        if (doSanityCheck) myAssert(address != 0);\n        parentAddress = this.address;\n        setAddress(-address);\n      }\n    }","id":84109,"modified_method":"private int locate(int valueHC, boolean split) {\n      int searched = 0;\n      int parentAddress = 0;\n\n      while(true) {\n        if (split && isFull()) {\n          parentAddress = splitNode(parentAddress);\n          if (parentAddress != 0) setAddress(parentAddress);\n          --searched;\n        }\n\n        int i = search(valueHC);\n\n        ++searched;\n\n        if (isIndexLeaf()) {\n          btree.height = Math.max(btree.height, searched);\n          return i;\n        }\n\n        int address = i < 0 ? addressAt(-i - 1):addressAt(i + 1);\n        if (doSanityCheck) myAssert(address != 0);\n        parentAddress = this.address;\n        setAddress(-address);\n      }\n    }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int splitNode(int parentAddress) {\n      if (doSanityCheck) {\n        myAssert(isFull());\n        dump(\"before split:\"+isIndexLeaf());\n      }\n\n      BtreeIndexNodeView parent = null;\n\n      if (parentAddress != 0) {\n        parent = new BtreeIndexNodeView(btree);\n        parent.setAddress(parentAddress);\n        if (btree.offloadToSiblingsBeforeSplit) {\n          if (doOffloadToSiblings(parent)) return parentAddress;\n        }\n      }\n\n      short maxIndex = (short)(getMaxChildrenCount() / 2);\n\n      BtreeIndexNodeView newIndexNode = new BtreeIndexNodeView(btree);\n      newIndexNode.setAddress(btree.nextPage(false));\n\n      boolean indexLeaf = isIndexLeaf();\n      newIndexNode.setIndexLeaf(indexLeaf);\n\n      int nextPage = getNextPage();\n      setNextPage(newIndexNode.address);\n      newIndexNode.setNextPage(nextPage);\n\n      final short recordCount = getChildrenCount();\n\n      int medianKey;\n\n      if (indexLeaf && isHashedLeaf()) {\n        TIntIntHashMap map = new TIntIntHashMap(recordCount);\n        getBytes(indexToOffset(0), btree.buffer, 0, btree.pageSize - btree.metaDataLeafPageLength);\n        int[] keys = new int[recordCount];\n        int keyNumber = 0;\n        \n        for(int i = 0; i < btree.hashPageCapacity; ++i) {\n          if (hashGetState(i) == HASH_FULL) {\n            int key = Bits.getInt(btree.buffer, i * INTERIOR_SIZE + KEY_OFFSET);\n            keys[keyNumber++] = key;\n            map.put(key, Bits.getInt(btree.buffer, i * INTERIOR_SIZE));\n            hashSetState(i, HASH_FREE);\n          }\n        }\n\n        Arrays.sort(keys);\n        final int avg = keys.length / 2;\n        medianKey = keys[avg];\n\n        setChildrenCount((short)0);\n        newIndexNode.setChildrenCount((short)0);\n\n        for(int i = 0; i < avg; ++i) {\n          insert(keys[i], map.get(keys[i]));\n          newIndexNode.insert(keys[avg + i], map.get(keys[avg + i]));\n        }\n      } else {\n        short recordCountInNewNode = (short)(recordCount - maxIndex);\n        newIndexNode.setChildrenCount(recordCountInNewNode);\n        \n        if (btree.isLarge) {\n          final int bytesToMove = recordCountInNewNode * INTERIOR_SIZE;\n          getBytes(indexToOffset(maxIndex), btree.buffer, 0, bytesToMove);\n          newIndexNode.putBytes(newIndexNode.indexToOffset(0), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = 0; i < recordCountInNewNode; ++i) {\n            newIndexNode.setAddressAt(i, addressAt(i + maxIndex));\n            newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n          }\n        }\n        if (indexLeaf) {\n          medianKey = newIndexNode.keyAt(0);\n        } else {\n          newIndexNode.setAddressAt(recordCountInNewNode, addressAt(recordCount));\n          --maxIndex;\n          medianKey = keyAt(maxIndex);     // key count is odd (since children count is even) and middle key goes to parent\n        }\n        setChildrenCount(maxIndex);\n      }\n\n      if (parent != null) {\n        if (doSanityCheck) {\n          int medianKeyInParent = parent.search(medianKey);\n          int ourKey = keyAt(0);\n          int ourKeyInParent = parent.search(ourKey);\n          parent.dump(\"About to insert \"+medianKey + \",\" + newIndexNode.address+\",\" + medianKeyInParent + \" our key \" + ourKey + \", \" + ourKeyInParent);\n\n          myAssert(medianKeyInParent < 0);\n          myAssert(!parent.isFull());\n        }\n\n        parent.insert(medianKey, -newIndexNode.address);\n\n        if (doSanityCheck) {\n          parent.dump(\"After modifying parent\");\n          int search = parent.search(medianKey);\n          myAssert(search >= 0);\n          myAssert(parent.addressAt(search + 1) == -newIndexNode.address);\n\n          dump(\"old node after split:\");\n          newIndexNode.dump(\"new node after split:\");\n        }\n      } else {\n        if (doSanityCheck) {\n          btree.root.dump(\"Splitting root:\"+medianKey);\n        }\n        int newRootAddress = btree.nextPage(true);\n        if (doSanityCheck) {\n          System.out.println(\"Pages:\"+btree.pagesCount+\", elements:\"+btree.count + \", average:\" + (btree.height + 1));\n        }\n        btree.setRootAddress(newRootAddress);\n        parentAddress = newRootAddress;\n        ((BtreePage)btree.root).load();\n        btree.root.setChildrenCount((short)1);\n        btree.root.setKeyAt(0, medianKey);\n        btree.root.setAddressAt(0, -address);\n        btree.root.setAddressAt(1, -newIndexNode.address);\n        btree.root.sync();\n\n        if (doSanityCheck) {\n          btree.root.dump(\"New root\");\n          dump(\"First child\");\n          newIndexNode.dump(\"Second child\");\n        }\n      }\n\n      sync();\n      newIndexNode.sync();\n\n      return parentAddress;\n    }","id":84110,"modified_method":"private int splitNode(int parentAddress) {\n      if (doSanityCheck) {\n        myAssert(isFull());\n        dump(\"before split:\"+isIndexLeaf());\n      }\n\n      BtreeIndexNodeView parent = null;\n\n      if (parentAddress != 0) {\n        parent = new BtreeIndexNodeView(btree);\n        parent.setAddress(parentAddress);\n        if (btree.offloadToSiblingsBeforeSplit) {\n          if (doOffloadToSiblings(parent)) return parentAddress;\n        }\n      }\n\n      short maxIndex = (short)(getMaxChildrenCount() / 2);\n\n      BtreeIndexNodeView newIndexNode = new BtreeIndexNodeView(btree);\n      newIndexNode.setAddress(btree.nextPage(false));\n\n      boolean indexLeaf = isIndexLeaf();\n      newIndexNode.setIndexLeaf(indexLeaf);\n\n      int nextPage = getNextPage();\n      setNextPage(newIndexNode.address);\n      newIndexNode.setNextPage(nextPage);\n\n      final short recordCount = getChildrenCount();\n\n      int medianKey;\n\n      if (indexLeaf && isHashedLeaf()) {\n        TIntIntHashMap map = new TIntIntHashMap(recordCount);\n        getBytes(indexToOffset(0), btree.buffer, 0, btree.pageSize - btree.metaDataLeafPageLength);\n        int[] keys = new int[recordCount];\n        int keyNumber = 0;\n        \n        for(int i = 0; i < btree.hashPageCapacity; ++i) {\n          if (hashGetState(i) == HASH_FULL) {\n            int key = Bits.getInt(btree.buffer, i * INTERIOR_SIZE + KEY_OFFSET);\n            keys[keyNumber++] = key;\n            map.put(key, Bits.getInt(btree.buffer, i * INTERIOR_SIZE));\n            hashSetState(i, HASH_FREE);\n          }\n        }\n\n        Arrays.sort(keys);\n        final int avg = keys.length / 2;\n        medianKey = keys[avg];\n        --btree.hashedPagesCount;\n        setChildrenCount((short)0);\n        newIndexNode.setChildrenCount((short)0);\n\n        for(int i = 0; i < avg; ++i) {\n          insert(keys[i], map.get(keys[i]));\n          newIndexNode.insert(keys[avg + i], map.get(keys[avg + i]));\n        }\n\n        /*setHashedLeaf(false);\n                setChildrenCount((short)keys.length);\n\n                --btree.hashedPagesCount;\n                btree.movedMembersCount += keys.length;\n\n                for(int i = 0; i < keys.length; ++i) {\n                  int key = keys[i];\n                  setKeyAt(i, key);\n                  setAddressAt(i, map.get(key));\n                }\n                return parentAddress;*/\n      } else {\n        short recordCountInNewNode = (short)(recordCount - maxIndex);\n        newIndexNode.setChildrenCount(recordCountInNewNode);\n        \n        if (btree.isLarge) {\n          final int bytesToMove = recordCountInNewNode * INTERIOR_SIZE;\n          getBytes(indexToOffset(maxIndex), btree.buffer, 0, bytesToMove);\n          newIndexNode.putBytes(newIndexNode.indexToOffset(0), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = 0; i < recordCountInNewNode; ++i) {\n            newIndexNode.setAddressAt(i, addressAt(i + maxIndex));\n            newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n          }\n        }\n        if (indexLeaf) {\n          medianKey = newIndexNode.keyAt(0);\n        } else {\n          newIndexNode.setAddressAt(recordCountInNewNode, addressAt(recordCount));\n          --maxIndex;\n          medianKey = keyAt(maxIndex);     // key count is odd (since children count is even) and middle key goes to parent\n        }\n        setChildrenCount(maxIndex);\n      }\n\n      if (parent != null) {\n        if (doSanityCheck) {\n          int medianKeyInParent = parent.search(medianKey);\n          int ourKey = keyAt(0);\n          int ourKeyInParent = parent.search(ourKey);\n          parent.dump(\"About to insert \"+medianKey + \",\" + newIndexNode.address+\",\" + medianKeyInParent + \" our key \" + ourKey + \", \" + ourKeyInParent);\n\n          myAssert(medianKeyInParent < 0);\n          myAssert(!parent.isFull());\n        }\n\n        parent.insert(medianKey, -newIndexNode.address);\n\n        if (doSanityCheck) {\n          parent.dump(\"After modifying parent\");\n          int search = parent.search(medianKey);\n          myAssert(search >= 0);\n          myAssert(parent.addressAt(search + 1) == -newIndexNode.address);\n\n          dump(\"old node after split:\");\n          newIndexNode.dump(\"new node after split:\");\n        }\n      } else {\n        if (doSanityCheck) {\n          btree.root.dump(\"Splitting root:\"+medianKey);\n        }\n        int newRootAddress = btree.nextPage(true);\n        if (doSanityCheck) {\n          System.out.println(\"Pages:\"+btree.pagesCount+\", elements:\"+btree.count + \", average:\" + (btree.height + 1));\n        }\n        btree.setRootAddress(newRootAddress);\n        parentAddress = newRootAddress;\n        ((BtreePage)btree.root).load();\n        btree.root.setChildrenCount((short)1);\n        btree.root.setKeyAt(0, medianKey);\n        btree.root.setAddressAt(0, -address);\n        btree.root.setAddressAt(1, -newIndexNode.address);\n        btree.root.sync();\n\n        if (doSanityCheck) {\n          btree.root.dump(\"New root\");\n          dump(\"First child\");\n          newIndexNode.dump(\"Second child\");\n        }\n      }\n\n      sync();\n      newIndexNode.sync();\n\n      return parentAddress;\n    }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"final short getMaxChildrenCount() {\n      return isIndexLeaf() ? btree.maxLeafNodes:btree.maxInteriorNodes;\n    }","id":84111,"modified_method":"final short getMaxChildrenCount() {\n      return isIndexLeaf() ? isHashedLeaf() ? btree.maxLeafNodesInHash:btree.maxLeafNodes:btree.maxInteriorNodes;\n    }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insert(int valueHC, int newValueId) {\n      if (doSanityCheck) myAssert(!isFull());\n      short recordCount = getChildrenCount();\n      if (doSanityCheck) myAssert(recordCount < getMaxChildrenCount());\n\n      final boolean indexLeaf = isIndexLeaf();\n\n      if (indexLeaf) {\n        if (recordCount == 0 && btree.indexNodeIsHashTable) {\n          setHashedLeaf(true);\n        }\n\n        if (isHashedLeaf()) {\n          int index = hashInsertionIndex(valueHC);\n\n          if (index < 0) {\n            index = -index - 1;\n          }\n\n          setKeyAt(index, valueHC);\n          hashSetState(index, HASH_FULL);\n          setAddressAt(index, newValueId);\n          setChildrenCount((short)(recordCount + 1));\n          sync();\n          return;\n        }\n      }\n\n      int medianKeyInParent = search(valueHC);\n      if (doSanityCheck) myAssert(medianKeyInParent < 0);\n      int index = -medianKeyInParent - 1;\n      setChildrenCount((short)(recordCount + 1));\n\n      final int itemsToMove = recordCount - index;\n      btree.movedMembersCount += itemsToMove;\n\n      if (indexLeaf) {\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          final int bytesToMove = itemsToMove * INTERIOR_SIZE;\n          getBytes(indexToOffset(index), btree.buffer, 0, bytesToMove);\n          putBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = recordCount - 1; i >= index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n        setKeyAt(index, valueHC);\n        setAddressAt(index, newValueId);\n      } else {\n        // <address> (<key><address>) {record_count - 1}\n        //\n        setAddressAt(recordCount + 1, addressAt(recordCount));\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          int elementsAfterIndex = recordCount - index - 1;\n          if (elementsAfterIndex > 0) {\n            int bytesToMove = elementsAfterIndex * INTERIOR_SIZE;\n            getBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n            putBytes(indexToOffset(index + 2), btree.buffer, 0, bytesToMove);\n          }\n        } else {\n          for(int i = recordCount - 1; i > index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n\n        if (index < recordCount) setKeyAt(index + 1, keyAt(index));\n\n        setKeyAt(index, valueHC);\n        setAddressAt(index + 1, newValueId);\n      }\n\n      if (doSanityCheck) {\n        if (index > 0) myAssert(keyAt(index - 1) < keyAt(index));\n        if (index < recordCount) myAssert(keyAt(index) < keyAt(index + 1));\n      }\n\n      sync();\n    }","id":84112,"modified_method":"private void insert(int valueHC, int newValueId) {\n      if (doSanityCheck) myAssert(!isFull());\n      short recordCount = getChildrenCount();\n      if (doSanityCheck) myAssert(recordCount < getMaxChildrenCount());\n\n      final boolean indexLeaf = isIndexLeaf();\n\n      if (indexLeaf) {\n        if (recordCount == 0 && btree.indexNodeIsHashTable) {\n          setHashedLeaf(true);\n          ++btree.hashedPagesCount;\n        }\n\n        if (isHashedLeaf()) {\n          int index = hashInsertionIndex(valueHC);\n\n          if (index < 0) {\n            index = -index - 1;\n          }\n\n          setKeyAt(index, valueHC);\n          hashSetState(index, HASH_FULL);\n          setAddressAt(index, newValueId);\n          setChildrenCount((short)(recordCount + 1));\n          sync();\n          return;\n        }\n      }\n\n      int medianKeyInParent = search(valueHC);\n      if (doSanityCheck) myAssert(medianKeyInParent < 0);\n      int index = -medianKeyInParent - 1;\n      setChildrenCount((short)(recordCount + 1));\n\n      final int itemsToMove = recordCount - index;\n      btree.movedMembersCount += itemsToMove;\n\n      if (indexLeaf) {\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          final int bytesToMove = itemsToMove * INTERIOR_SIZE;\n          getBytes(indexToOffset(index), btree.buffer, 0, bytesToMove);\n          putBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n        } else {\n          for(int i = recordCount - 1; i >= index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n        setKeyAt(index, valueHC);\n        setAddressAt(index, newValueId);\n      } else {\n        // <address> (<key><address>) {record_count - 1}\n        //\n        setAddressAt(recordCount + 1, addressAt(recordCount));\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          int elementsAfterIndex = recordCount - index - 1;\n          if (elementsAfterIndex > 0) {\n            int bytesToMove = elementsAfterIndex * INTERIOR_SIZE;\n            getBytes(indexToOffset(index + 1), btree.buffer, 0, bytesToMove);\n            putBytes(indexToOffset(index + 2), btree.buffer, 0, bytesToMove);\n          }\n        } else {\n          for(int i = recordCount - 1; i > index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n\n        if (index < recordCount) setKeyAt(index + 1, keyAt(index));\n\n        setKeyAt(index, valueHC);\n        setAddressAt(index + 1, newValueId);\n      }\n\n      if (doSanityCheck) {\n        if (index > 0) myAssert(keyAt(index - 1) < keyAt(index));\n        if (index < recordCount) myAssert(keyAt(index) < keyAt(index + 1));\n      }\n\n      sync();\n    }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void persistVars(BtreeDataStorage storage, boolean toDisk) {\n    height = storage.persistInt(0, height, toDisk);\n    pagesCount = storage.persistInt(4, pagesCount, toDisk);\n    movedMembersCount = storage.persistInt(8, movedMembersCount, toDisk);\n    maxStepsSearchedInHash = storage.persistInt(12, maxStepsSearchedInHash, toDisk);\n    count = storage.persistInt(16, count, toDisk);\n    hashSearchRequests = storage.persistInt(20, hashSearchRequests, toDisk);\n    totalHashStepsSearched = storage.persistInt(24, totalHashStepsSearched, toDisk);\n    nextFreePage = storage.persistInt(28, nextFreePage, toDisk);\n    nextFreePageCount = storage.persistInt(32, nextFreePageCount, toDisk);\n  }","id":84113,"modified_method":"public void persistVars(BtreeDataStorage storage, boolean toDisk) {\n    height = storage.persistInt(0, height, toDisk);\n    pagesCount = storage.persistInt(4, pagesCount, toDisk);\n    movedMembersCount = storage.persistInt(8, movedMembersCount, toDisk);\n    maxStepsSearchedInHash = storage.persistInt(12, maxStepsSearchedInHash, toDisk);\n    count = storage.persistInt(16, count, toDisk);\n    hashSearchRequests = storage.persistInt(20, hashSearchRequests, toDisk);\n    totalHashStepsSearched = storage.persistInt(24, totalHashStepsSearched, toDisk);\n    nextFreePage = storage.persistInt(28, nextFreePage, toDisk);\n    nextFreePageCount = storage.persistInt(32, nextFreePageCount, toDisk);\n    hashedPagesCount = storage.persistInt(36, hashedPagesCount, toDisk);\n  }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IntToIntBtree(int _pageSize, int rootAddress, ISimpleStorage _storage, boolean initial) {\n    pageSize = _pageSize;\n    buffer = new byte[_pageSize];\n    storage = _storage;\n\n    root = new BtreeIndexNodeView(this);\n    root.setAddress(rootAddress);\n\n    int i = (pageSize - BtreePage.RESERVED_META_PAGE_LEN) / BtreeIndexNodeView.INTERIOR_SIZE - 1;\n    assert i < Short.MAX_VALUE && i % 2 == 0;\n    maxInteriorNodes = (short)i;\n\n    int metaPageLen = BtreePage.RESERVED_META_PAGE_LEN;\n\n    if (indexNodeIsHashTable) {\n      ++i;\n      final double bitsPerState = BtreeIndexNodeView.haveDeleteState? 2d:1d;\n      while(Math.ceil(bitsPerState * i / 8) + i * BtreeIndexNodeView.INTERIOR_SIZE + BtreePage.RESERVED_META_PAGE_LEN > pageSize ||\n            !isPrime(i)\n           ) {\n        i -= 2;\n      }\n\n      hashPageCapacity = i;\n      metaPageLen = BtreePage.RESERVED_META_PAGE_LEN + (int)Math.ceil(bitsPerState * hashPageCapacity / 8);\n      i = (int)(hashPageCapacity * 0.8);\n      if ((i & 1) == 1) ++i;\n    } else {\n      hashPageCapacity = -1;\n    }\n\n    metaDataLeafPageLength = metaPageLen;\n\n    assert i > 0 && i % 2 == 0;\n    maxLeafNodes = (short) i;\n\n    pagesCount = 1;\n    ((BtreePage)root).load();\n\n    if (initial) {\n      root.setIndexLeaf(true);\n      root.sync();\n    }\n  }","id":84114,"modified_method":"public IntToIntBtree(int _pageSize, int rootAddress, ISimpleStorage _storage, boolean initial) {\n    pageSize = _pageSize;\n    buffer = new byte[_pageSize];\n    storage = _storage;\n\n    root = new BtreeIndexNodeView(this);\n    root.setAddress(rootAddress);\n\n    int i = (pageSize - BtreePage.RESERVED_META_PAGE_LEN) / BtreeIndexNodeView.INTERIOR_SIZE - 1;\n    assert i < Short.MAX_VALUE && i % 2 == 0;\n    maxInteriorNodes = (short)i;\n    maxLeafNodes = (short)i;\n\n    int metaPageLen = BtreePage.RESERVED_META_PAGE_LEN;\n\n    if (indexNodeIsHashTable) {\n      ++i;\n      final double bitsPerState = BtreeIndexNodeView.haveDeleteState? 2d:1d;\n      while(Math.ceil(bitsPerState * i / 8) + i * BtreeIndexNodeView.INTERIOR_SIZE + BtreePage.RESERVED_META_PAGE_LEN > pageSize ||\n            !isPrime(i)\n           ) {\n        i -= 2;\n      }\n\n      hashPageCapacity = i;\n      metaPageLen = BtreePage.RESERVED_META_PAGE_LEN + (int)Math.ceil(bitsPerState * hashPageCapacity / 8);\n      i = (int)(hashPageCapacity * 0.8);\n      if ((i & 1) == 1) ++i;\n    } else {\n      hashPageCapacity = -1;\n    }\n\n    metaDataLeafPageLength = metaPageLen;\n\n    assert i > 0 && i % 2 == 0;\n    maxLeafNodesInHash = (short) i;\n\n    pagesCount = 1;\n    ((BtreePage)root).load();\n\n    if (initial) {\n      root.setIndexLeaf(true);\n      root.sync();\n    }\n  }","commit_id":"218f25a23edcc773b23999e392f33ac778a13133","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final synchronized void update(Map<String, Object> props) {\n        String address = (String)props.get(\"org.apache.cxf.service.ws-discovery.address\");\n        client.setAddress(address);\n        if (udpEndpoint != null && !client.isAdHoc()) {\n            udpEndpoint.stop();\n            udpEndpoint = null;\n            started = false;\n        }\n    }","id":84115,"modified_method":"public final synchronized void update(Map<String, Object> props) {\n        String address = (String)props.get(\"org.apache.cxf.service.ws-discovery.address\");\n        if (address != null) {\n            client.setAddress(address);\n        }\n        if (udpEndpoint != null && !client.isAdHoc()) {\n            udpEndpoint.stop();\n            udpEndpoint = null;\n            started = false;\n        }\n    }","commit_id":"428101a4dd25f8359da156ff06288c7018cd94f1","url":"https://github.com/apache/cxf"},{"original_method":"public Metadata parse(Element element, ParserContext context) {\n        Metadata answer = null;\n        String s = element.getLocalName();\n        // Setting the thread context classloader to workaround the issue BlueprintBus ClassLoader\n        // This line can be removed when CXF 2.4.2 is released.\n        Thread.currentThread().setContextClassLoader(BlueprintBus.class.getClassLoader());\n        if (\"cxfEndpoint\".equals(s)) {\n            LOG.debug(\"parsing the cxfEndpoint element\");\n            answer = new EndpointDefinitionParser().parse(element, context);\n        }\n        \n        return answer;\n    }","id":84116,"modified_method":"public Metadata parse(Element element, ParserContext context) {\n        Metadata answer = null;\n        String s = element.getLocalName();\n        // Setting the thread context classloader to workaround the issue BlueprintBus ClassLoader\n        // This line can be removed when CXF 2.4.2 is released.\n        Thread.currentThread().setContextClassLoader(BlueprintBus.class.getClassLoader());\n        if (\"cxfEndpoint\".equals(s)) {\n            LOG.debug(\"parsing the cxfEndpoint element\");\n            answer = new EndpointDefinitionParser().parse(element, context);\n        }\n        if (\"rsClient\".equals(s)) {\n            LOG.debug(\"parsing the rsClient element\");\n            answer = new RsClientDefinitionParser().parse(element, context);\n        }\n        if (\"rsServer\".equals(s)) {\n            LOG.debug(\"parsing the rsServer element\");\n            answer = new RsServerDefinitionParser().parse(element, context);\n        }\n        \n        return answer;\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        CxfRsEndpoint answer = null;\n        if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {\n            // Get the bean from the Spring context\n            String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());\n            if (beanId.startsWith(\"//\")) {\n                beanId = beanId.substring(2);\n            }\n\n            AbstractJAXRSFactoryBean bean = CamelContextHelper.mandatoryLookup(getCamelContext(), beanId, \n                AbstractJAXRSFactoryBean.class);\n\n            answer = new CxfRsSpringEndpoint(this.getCamelContext(), bean);\n           \n            // Apply Spring bean properties (including # notation referenced bean).  Note that the\n            // Spring bean properties values can be overridden by property defined in URI query.\n            // The super class (DefaultComponent) will invoke \"setProperties\" after this method \n            // with to apply properties defined by URI query. \n            if (bean.getProperties() != null) {\n                Map<String, Object> copy = new HashMap<String, Object>();\n                copy.putAll(bean.getProperties());     \n                setProperties(answer, copy);      \n            }\n            \n        } else {\n            // endpoint URI does not specify a bean\n            answer = new CxfRsEndpoint(remaining, this);\n        }\n        Map<String, String> params = CastUtils.cast(parameters);\n        answer.setParameters(params);\n        setEndpointHeaderFilterStrategy(answer);\n        return answer;\n    }","id":84117,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        CxfRsEndpoint answer = null;\n        if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {\n            // Get the bean from the Spring context\n            String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());\n            if (beanId.startsWith(\"//\")) {\n                beanId = beanId.substring(2);\n            }\n\n            AbstractJAXRSFactoryBean bean = CamelContextHelper.mandatoryLookup(getCamelContext(), beanId, \n                AbstractJAXRSFactoryBean.class);\n            if (bean instanceof BlueprintSupport) {\n                answer = new CxfRsBlueprintEndpoint(this.getCamelContext(), bean);\n            } else {\n                answer = new CxfRsSpringEndpoint(this.getCamelContext(), bean);\n            }\n            // Apply Spring bean properties (including # notation referenced bean).  Note that the\n            // Spring bean properties values can be overridden by property defined in URI query.\n            // The super class (DefaultComponent) will invoke \"setProperties\" after this method \n            // with to apply properties defined by URI query. \n            if (bean.getProperties() != null) {\n                Map<String, Object> copy = new HashMap<String, Object>();\n                copy.putAll(bean.getProperties());     \n                setProperties(answer, copy);      \n            }\n            \n        } else {\n            // endpoint URI does not specify a bean\n            answer = new CxfRsEndpoint(remaining, this);\n        }\n        Map<String, String> params = CastUtils.cast(parameters);\n        answer.setParameters(params);\n        setEndpointHeaderFilterStrategy(answer);\n        return answer;\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"public JAXRSClientFactoryBean createJAXRSClientFactoryBean(String address) {\n        JAXRSClientFactoryBean answer = new SpringJAXRSClientFactoryBean();\n        setupJAXRSClientFactoryBean(answer, address);\n        return answer;\n    }","id":84118,"modified_method":"public JAXRSClientFactoryBean createJAXRSClientFactoryBean(String address) {\n        JAXRSClientFactoryBean answer = newJAXRSClientFactoryBean();\n        setupJAXRSClientFactoryBean(answer, address);\n        return answer;\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"protected void setupJAXRSServerFactoryBean(JAXRSServerFactoryBean sfb) {\n        // address\n        sfb.setAddress(getAddress());\n        sfb.setResourceClasses(CastUtils.cast(getResourceClasses(), Class.class));\n        sfb.setStart(false);\n    }","id":84119,"modified_method":"protected void setupJAXRSServerFactoryBean(JAXRSServerFactoryBean sfb) {\n        // address\n        if (getAddress() != null) {\n            sfb.setAddress(getAddress());\n        }\n        if (getResourceClasses()!= null) {\n            sfb.setResourceClasses(CastUtils.cast(getResourceClasses(), Class.class));\n        }\n        sfb.setStart(false);\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"protected void setupJAXRSClientFactoryBean(JAXRSClientFactoryBean cfb, String address) {\n        // address\n        cfb.setAddress(address);\n        if (getResourceClasses() != null) {\n            cfb.setResourceClass(getResourceClasses().get(0));\n        }\n        cfb.setThreadSafe(true);\n    }","id":84120,"modified_method":"protected void setupJAXRSClientFactoryBean(JAXRSClientFactoryBean cfb, String address) {\n        // address\n        if (address != null) {\n            cfb.setAddress(address);\n        }\n        if (getResourceClasses() != null) {\n            cfb.setResourceClass(getResourceClasses().get(0));\n        }\n        cfb.setThreadSafe(true);\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"public JAXRSServerFactoryBean createJAXRSServerFactoryBean() {\n        JAXRSServerFactoryBean answer = new SpringJAXRSServerFactoryBean();\n        setupJAXRSServerFactoryBean(answer);\n        return answer;\n    }","id":84121,"modified_method":"public JAXRSServerFactoryBean createJAXRSServerFactoryBean() {\n        JAXRSServerFactoryBean answer = newJAXRSServerFactoryBean();\n        setupJAXRSServerFactoryBean(answer);\n        return answer;\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void setupJAXRSServerFactoryBean(JAXRSServerFactoryBean sfb) {\n        checkBeanType(JAXRSServerFactoryBean.class);\n        configure(sfb);\n        \n    }","id":84122,"modified_method":"@Override\n    protected void setupJAXRSServerFactoryBean(JAXRSServerFactoryBean sfb) {\n        checkBeanType(bean, JAXRSServerFactoryBean.class);\n        configure(sfb);\n        \n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void setupJAXRSClientFactoryBean(JAXRSClientFactoryBean cfb, String address) {\n        checkBeanType(JAXRSClientFactoryBean.class);\n        configure(cfb);      \n        cfb.setAddress(address);\n        // Need to enable the option of ThreadSafe\n        cfb.setThreadSafe(true);\n    }","id":84123,"modified_method":"@Override\n    protected void setupJAXRSClientFactoryBean(JAXRSClientFactoryBean cfb, String address) {\n        checkBeanType(bean, JAXRSClientFactoryBean.class);\n        configure(cfb);      \n        cfb.setAddress(address);\n        // Need to enable the option of ThreadSafe\n        cfb.setThreadSafe(true);\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"public Metadata parse(Element element, ParserContext context) {\n        MutableBeanMetadata endpointConfig = context.createMetadata(MutableBeanMetadata.class);\n        endpointConfig.setRuntimeClass(CxfBlueprintEndpoint.class);\n        endpointConfig.addProperty(\"blueprintContainer\", createRef(context, \"blueprintContainer\"));\n        endpointConfig.addProperty(\"bundleContext\", createRef(context, \"blueprintBundleContext\"));\n\n        if (!StringUtils.isEmpty(getIdOrName(element))) {\n            endpointConfig.setId(getIdOrName(element));\n        } else {\n            endpointConfig.setId(\"camel.cxf.endpoint.\" + context.generateId());\n        }\n\n        NamedNodeMap atts = element.getAttributes();\n\n        String bus = null;\n        String address = null;\n\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n            if (\"bus\".equals(name)) {\n                bus = val;\n            } else if (\"address\".equals(name)) {\n                address = val;\n            } else if (isAttribute(pre, name)) {\n                if (\"endpointName\".equals(name) || \"serviceName\".equals(name)) {\n                    QName q = parseQName(element, val);\n                    endpointConfig.addProperty(name, createValue(context, q));\n                } else if (\"depends-on\".equals(name)) {\n                    endpointConfig.addDependsOn(val);\n                } else if (!\"name\".equals(name)) {\n                    endpointConfig.addProperty(name, AbstractBPBeanDefinitionParser.createValue(context, val));\n                }\n            }\n        }\n\n        Element elem = DOMUtils.getFirstElement(element);\n        while (elem != null) {\n            String name = elem.getLocalName();\n            if (\"properties\".equals(name)) {\n                Metadata map = parseMapData(context, endpointConfig, elem);\n                endpointConfig.addProperty(name, map);\n            } else if (\"binding\".equals(name)) {\n                setFirstChildAsProperty(element, context, endpointConfig, \"bindingConfig\");\n            } else if (\"inInterceptors\".equals(name) || \"inFaultInterceptors\".equals(name) || \"outInterceptors\".equals(name)\n                || \"outFaultInterceptors\".equals(name) || \"features\".equals(name) || \"schemaLocations\".equals(name) || \"handlers\".equals(name)) {\n                Metadata list = parseListData(context, endpointConfig, elem);\n                endpointConfig.addProperty(name, list);\n            } else {\n                setFirstChildAsProperty(element, context, endpointConfig, name);\n            }\n\n            elem = DOMUtils.getNextElement(elem);\n        }\n        if (StringUtils.isEmpty(bus)) {\n            bus = \"cxf\";\n        }\n        //Will create a bus if needed...\n\n        endpointConfig.addProperty(\"bus\", getBusRef(context, bus));\n        endpointConfig.setDestroyMethod(\"destroy\");\n        endpointConfig.addArgument(AbstractBPBeanDefinitionParser.createValue(context, address), String.class.getName(), 0);\n        endpointConfig.addArgument(createRef(context, \"blueprintBundleContext\"),\n                                   BundleContext.class.getName(), 1);\n\n        return endpointConfig;\n    }","id":84124,"modified_method":"public Metadata parse(Element element, ParserContext context) {\n        MutableBeanMetadata endpointConfig = createBeanMetadata(element, context, CxfBlueprintEndpoint.class);\n \n        NamedNodeMap atts = element.getAttributes();\n\n        String bus = null;\n        String address = null;\n\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n            if (\"bus\".equals(name)) {\n                bus = val;\n            } else if (\"address\".equals(name)) {\n                address = val;\n            } else if (isAttribute(pre, name)) {\n                if (\"endpointName\".equals(name) || \"serviceName\".equals(name)) {\n                    QName q = parseQName(element, val);\n                    endpointConfig.addProperty(name, createValue(context, q));\n                } else if (\"depends-on\".equals(name)) {\n                    endpointConfig.addDependsOn(val);\n                } else if (!\"name\".equals(name)) {\n                    endpointConfig.addProperty(name, AbstractBPBeanDefinitionParser.createValue(context, val));\n                }\n            }\n        }\n\n        Element elem = DOMUtils.getFirstElement(element);\n        while (elem != null) {\n            String name = elem.getLocalName();\n            if (\"properties\".equals(name)) {\n                Metadata map = parseMapData(context, endpointConfig, elem);\n                endpointConfig.addProperty(name, map);\n            } else if (\"binding\".equals(name)) {\n                setFirstChildAsProperty(element, context, endpointConfig, \"bindingConfig\");\n            } else if (\"inInterceptors\".equals(name) || \"inFaultInterceptors\".equals(name) || \"outInterceptors\".equals(name)\n                || \"outFaultInterceptors\".equals(name) || \"features\".equals(name) || \"schemaLocations\".equals(name) || \"handlers\".equals(name)) {\n                Metadata list = parseListData(context, endpointConfig, elem);\n                endpointConfig.addProperty(name, list);\n            } else {\n                setFirstChildAsProperty(element, context, endpointConfig, name);\n            }\n\n            elem = DOMUtils.getNextElement(elem);\n        }\n        if (StringUtils.isEmpty(bus)) {\n            bus = \"cxf\";\n        }\n        //Will create a bus if needed...\n\n        endpointConfig.addProperty(\"bus\", getBusRef(context, bus));\n        endpointConfig.setDestroyMethod(\"destroy\");\n        endpointConfig.addArgument(AbstractBPBeanDefinitionParser.createValue(context, address), String.class.getName(), 0);\n        endpointConfig.addArgument(createRef(context, \"blueprintBundleContext\"),\n                                   BundleContext.class.getName(), 1);\n\n        return endpointConfig;\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"public Metadata parse(Element element, ParserContext context) {\n        MutableBeanMetadata endpointConfig = context.createMetadata(MutableBeanMetadata.class);\n        endpointConfig.setRuntimeClass(CxfBlueprintEndpoint.class);\n        endpointConfig.addProperty(\"blueprintContainer\", createRef(context, \"blueprintContainer\"));\n        endpointConfig.addProperty(\"bundleContext\", createRef(context, \"blueprintBundleContext\"));\n\n        if (!StringUtils.isEmpty(getIdOrName(element))) {\n            endpointConfig.setId(getIdOrName(element));\n        } else {\n            endpointConfig.setId(\"camel.cxf.endpoint.\" + context.generateId());\n        }\n\n        return null;\n    }","id":84125,"modified_method":"public Metadata parse(Element element, ParserContext context) {\n        MutableBeanMetadata beanMetadata = createBeanMetadata(element, context, RsClientBlueprintBean.class);\n        NamedNodeMap atts = element.getAttributes();\n\n        String bus = null;\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n            if (\"bus\".equals(name)) {\n                bus = val;\n            } else if (isAttribute(pre, name)) {\n                if (\"depends-on\".equals(name)) {\n                    beanMetadata.addDependsOn(val);\n                } else if (!\"name\".equals(name)) {\n                    beanMetadata.addProperty(name, AbstractBPBeanDefinitionParser.createValue(context, val));\n                }\n            }\n        }\n\n        Element elem = DOMUtils.getFirstElement(element);\n        while (elem != null) {\n            String name = elem.getLocalName();\n            if (\"properties\".equals(name) || \"headers\".equals(name)) {\n                Metadata map = parseMapData(context, beanMetadata, elem);\n                beanMetadata.addProperty(name, map);\n            } else if (\"binding\".equals(name)) {\n                setFirstChildAsProperty(element, context, beanMetadata, \"bindingConfig\");\n            } else if (\"inInterceptors\".equals(name) || \"inFaultInterceptors\".equals(name) || \"outInterceptors\".equals(name)\n                || \"outFaultInterceptors\".equals(name) || \"features\".equals(name) || \"schemaLocations\".equals(name) || \"handlers\".equals(name)) {\n                Metadata list = parseListData(context, beanMetadata, elem);\n                beanMetadata.addProperty(name, list);\n            } else if (\"features\".equals(name) || \"providers\".equals(name)\n                || \"schemaLocations\".equals(name) || \"modelBeans\".equals(name)\n                || \"serviceBeans\".equals(name)) {\n                Metadata list = parseListData(context, beanMetadata, elem);\n                beanMetadata.addProperty(name, list);\n            } else if (\"model\".equals(name)) {\n                List<UserResource> resources = ResourceUtils.getResourcesFromElement(elem);\n                MutablePassThroughMetadata value = context.createMetadata(MutablePassThroughMetadata.class);\n                value.setObject(resources);\n                beanMetadata.addProperty(name, value);\n            } else {\n                setFirstChildAsProperty(element, context, beanMetadata, name);\n            }\n        } \n \n        if (StringUtils.isEmpty(bus)) {\n            bus = \"cxf\";\n        }\n        //Will create a bus if needed...\n\n        beanMetadata.addProperty(\"bus\", getBusRef(context, bus));\n        return beanMetadata;\n    }","commit_id":"0bb42ce3cb1613f05716fe95a3f79a935675176a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void execute(RoutingAllocation allocation) throws ElasticSearchException {\n        DiscoveryNode discoNode = allocation.nodes().resolveNode(node);\n\n        MutableShardRouting shardRouting = null;\n        for (MutableShardRouting routing : allocation.routingNodes().unassigned()) {\n            if (routing.shardId().equals(shardId)) {\n                // prefer primaries first to allocate\n                if (shardRouting == null || routing.primary()) {\n                    shardRouting = routing;\n                }\n            }\n        }\n\n        if (shardRouting == null) {\n            throw new ElasticSearchIllegalArgumentException(\"[allocate] failed to find \" + shardId + \" on the list of unassigned shards\");\n        }\n\n        if (shardRouting.primary() && !allowPrimary) {\n            throw new ElasticSearchIllegalArgumentException(\"[allocate] trying to allocate a primary shard \" + shardId + \"], which is disabled\");\n        }\n\n        RoutingNode routingNode = allocation.routingNodes().node(discoNode.id());\n        if (!allocation.deciders().canAllocate(shardRouting, routingNode, allocation).allowed()) {\n            throw new ElasticSearchIllegalArgumentException(\"[allocate] allocation of \" + shardId + \" on node \" + discoNode + \" is not allowed\");\n        }\n        // go over and remove it from the unassigned\n        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {\n            if (it.next() != shardRouting) {\n                continue;\n            }\n            it.remove();\n            routingNode.add(shardRouting);\n            break;\n        }\n    }","id":84126,"modified_method":"@Override\n    public void execute(RoutingAllocation allocation) throws ElasticSearchException {\n        DiscoveryNode discoNode = allocation.nodes().resolveNode(node);\n\n        MutableShardRouting shardRouting = null;\n        for (MutableShardRouting routing : allocation.routingNodes().unassigned()) {\n            if (routing.shardId().equals(shardId)) {\n                // prefer primaries first to allocate\n                if (shardRouting == null || routing.primary()) {\n                    shardRouting = routing;\n                }\n            }\n        }\n\n        if (shardRouting == null) {\n            throw new ElasticSearchIllegalArgumentException(\"[allocate] failed to find \" + shardId + \" on the list of unassigned shards\");\n        }\n\n        if (shardRouting.primary() && !allowPrimary) {\n            throw new ElasticSearchIllegalArgumentException(\"[allocate] trying to allocate a primary shard \" + shardId + \"], which is disabled\");\n        }\n\n        RoutingNode routingNode = allocation.routingNodes().node(discoNode.id());\n        Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);\n        if (decision.type() == Decision.Type.NO) {\n            throw new ElasticSearchIllegalArgumentException(\"[allocate] allocation of \" + shardId + \" on node \" + discoNode + \" is not allowed, reason: \" + decision);\n        }\n        // go over and remove it from the unassigned\n        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {\n            if (it.next() != shardRouting) {\n                continue;\n            }\n            it.remove();\n            routingNode.add(shardRouting);\n            break;\n        }\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        return Decision.YES;\n    }","id":84127,"modified_method":"public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        return Decision.ALWAYS;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        Decision ret = Decision.YES;\n        // first, check if its in the ignored, if so, return NO\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            return Decision.NO;\n        }\n        // now, go over the registered allocations\n        for (AllocationDecider allocation1 : allocations) {\n            Decision decision = allocation1.canAllocate(shardRouting, node, allocation);\n            if (decision == Decision.NO) {\n                return Decision.NO;\n            } else if (decision == Decision.THROTTLE) {\n                ret = Decision.THROTTLE;\n            }\n        }\n        return ret;\n    }","id":84128,"modified_method":"@Override\n    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canAllocate(shardRouting, node, allocation);\n            // the assumption is that a decider that returns the static instance Decision#ALWAYS\n            // does not really implements canAllocate\n            if (decision != Decision.ALWAYS) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public boolean allocateUnassigned(RoutingAllocation allocation) {\n        boolean changed = false;\n\n        DiscoveryNodes nodes = allocation.nodes();\n        RoutingNodes routingNodes = allocation.routingNodes();\n\n        if (nodes.dataNodes().isEmpty()) {\n            return changed;\n        }\n\n        if (!routingNodes.hasUnassigned()) {\n            return changed;\n        }\n\n        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n\n            // pre-check if it can be allocated to any node that currently exists, so we won't list the store for it for nothing\n            boolean canBeAllocatedToAtLeastOneNode = false;\n            for (DiscoveryNode discoNode : nodes.dataNodes().values()) {\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n                // if its THROTTLING, we are not going to allocate it to this node, so ignore it as well\n                if (allocation.deciders().canAllocate(shard, node, allocation).allocate()) {\n                    canBeAllocatedToAtLeastOneNode = true;\n                    break;\n                }\n            }\n\n            if (!canBeAllocatedToAtLeastOneNode) {\n                continue;\n            }\n\n            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);\n\n            long lastSizeMatched = 0;\n            DiscoveryNode lastDiscoNodeMatched = null;\n            RoutingNode lastNodeMatched = null;\n\n            for (Map.Entry<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {\n                DiscoveryNode discoNode = nodeStoreEntry.getKey();\n                TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue();\n                logger.trace(\"{}: checking node [{}]\", shard, discoNode);\n\n                if (storeFilesMetaData == null) {\n                    // already allocated on that node...\n                    continue;\n                }\n\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n\n                // check if we can allocate on that node...\n                // we only check for NO, since if this node is THROTTLING and it has enough \"same data\"\n                // then we will try and assign it next time\n                if (allocation.deciders().canAllocate(shard, node, allocation) == AllocationDecider.Decision.NO) {\n                    continue;\n                }\n\n                // if it is already allocated, we can't assign to it...\n                if (storeFilesMetaData.allocated()) {\n                    continue;\n                }\n\n\n                // if its a primary, it will be recovered from the gateway, find one that is closet to it\n                if (shard.primary()) {\n                    try {\n                        CommitPoint commitPoint = cachedCommitPoints.get(shard.shardId());\n                        if (commitPoint == null) {\n                            commitPoint = ((BlobStoreGateway) ((InternalNode) this.node).injector().getInstance(Gateway.class)).findCommitPoint(shard.index(), shard.id());\n                            if (commitPoint != null) {\n                                cachedCommitPoints.put(shard.shardId(), commitPoint);\n                            } else {\n                                cachedCommitPoints.put(shard.shardId(), CommitPoint.NULL);\n                            }\n                        } else if (commitPoint == CommitPoint.NULL) {\n                            commitPoint = null;\n                        }\n\n                        if (commitPoint == null) {\n                            break;\n                        }\n\n                        long sizeMatched = 0;\n                        for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {\n                            CommitPoint.FileInfo fileInfo = commitPoint.findPhysicalIndexFile(storeFileMetaData.name());\n                            if (fileInfo != null) {\n                                if (fileInfo.isSame(storeFileMetaData)) {\n                                    logger.trace(\"{}: [{}] reusing file since it exists on remote node and on gateway\", shard, storeFileMetaData.name());\n                                    sizeMatched += storeFileMetaData.length();\n                                } else {\n                                    logger.trace(\"{}: [{}] ignore file since it exists on remote node and on gateway but is different\", shard, storeFileMetaData.name());\n                                }\n                            } else {\n                                logger.trace(\"{}: [{}] exists on remote node, does not exists on gateway\", shard, storeFileMetaData.name());\n                            }\n                        }\n                        if (sizeMatched > lastSizeMatched) {\n                            lastSizeMatched = sizeMatched;\n                            lastDiscoNodeMatched = discoNode;\n                            lastNodeMatched = node;\n                            logger.trace(\"{}: node elected for pre_allocation [{}], total_size_matched [{}]\", shard, discoNode, new ByteSizeValue(sizeMatched));\n                        } else {\n                            logger.trace(\"{}: node ignored for pre_allocation [{}], total_size_matched [{}] smaller than last_size_matched [{}]\", shard, discoNode, new ByteSizeValue(sizeMatched), new ByteSizeValue(lastSizeMatched));\n                        }\n                    } catch (Exception e) {\n                        // failed, log and try and allocate based on size\n                        logger.debug(\"Failed to guess allocation of primary based on gateway for \" + shard, e);\n                    }\n                } else {\n                    // if its backup, see if there is a primary that *is* allocated, and try and assign a location that is closest to it\n                    // note, since we replicate operations, this might not be the same (different flush intervals)\n                    MutableShardRouting primaryShard = routingNodes.findPrimaryForReplica(shard);\n                    if (primaryShard != null && primaryShard.active()) {\n                        DiscoveryNode primaryNode = nodes.get(primaryShard.currentNodeId());\n                        if (primaryNode != null) {\n                            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore = shardStores.get(primaryNode);\n                            if (primaryNodeStore != null && primaryNodeStore.allocated()) {\n                                long sizeMatched = 0;\n\n                                for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {\n                                    if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).isSame(storeFileMetaData)) {\n                                        sizeMatched += storeFileMetaData.length();\n                                    }\n                                }\n                                if (sizeMatched > lastSizeMatched) {\n                                    lastSizeMatched = sizeMatched;\n                                    lastDiscoNodeMatched = discoNode;\n                                    lastNodeMatched = node;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (lastNodeMatched != null) {\n                if (allocation.deciders().canAllocate(shard, lastNodeMatched, allocation) == AllocationDecider.Decision.THROTTLE) {\n                    if (logger.isTraceEnabled()) {\n                        logger.debug(\"[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we are throttling this, but we have enough to allocate to this node, ignore it for now\n                    unassignedIterator.remove();\n                    routingNodes.ignoredUnassigned().add(shard);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we found a match\n                    changed = true;\n                    lastNodeMatched.add(shard);\n                    unassignedIterator.remove();\n                }\n            }\n        }\n\n        return changed;\n    }","id":84129,"modified_method":"@Override\n    public boolean allocateUnassigned(RoutingAllocation allocation) {\n        boolean changed = false;\n\n        DiscoveryNodes nodes = allocation.nodes();\n        RoutingNodes routingNodes = allocation.routingNodes();\n\n        if (nodes.dataNodes().isEmpty()) {\n            return changed;\n        }\n\n        if (!routingNodes.hasUnassigned()) {\n            return changed;\n        }\n\n        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n\n            // pre-check if it can be allocated to any node that currently exists, so we won't list the store for it for nothing\n            boolean canBeAllocatedToAtLeastOneNode = false;\n            for (DiscoveryNode discoNode : nodes.dataNodes().values()) {\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n                // if its THROTTLING, we are not going to allocate it to this node, so ignore it as well\n                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);\n                if (decision.type() == Decision.Type.YES) {\n                    canBeAllocatedToAtLeastOneNode = true;\n                    break;\n                }\n            }\n\n            if (!canBeAllocatedToAtLeastOneNode) {\n                continue;\n            }\n\n            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);\n\n            long lastSizeMatched = 0;\n            DiscoveryNode lastDiscoNodeMatched = null;\n            RoutingNode lastNodeMatched = null;\n\n            for (Map.Entry<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {\n                DiscoveryNode discoNode = nodeStoreEntry.getKey();\n                TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue();\n                logger.trace(\"{}: checking node [{}]\", shard, discoNode);\n\n                if (storeFilesMetaData == null) {\n                    // already allocated on that node...\n                    continue;\n                }\n\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n\n                // check if we can allocate on that node...\n                // we only check for NO, since if this node is THROTTLING and it has enough \"same data\"\n                // then we will try and assign it next time\n                if (allocation.deciders().canAllocate(shard, node, allocation).type() == Decision.Type.NO) {\n                    continue;\n                }\n\n                // if it is already allocated, we can't assign to it...\n                if (storeFilesMetaData.allocated()) {\n                    continue;\n                }\n\n\n                // if its a primary, it will be recovered from the gateway, find one that is closet to it\n                if (shard.primary()) {\n                    try {\n                        CommitPoint commitPoint = cachedCommitPoints.get(shard.shardId());\n                        if (commitPoint == null) {\n                            commitPoint = ((BlobStoreGateway) ((InternalNode) this.node).injector().getInstance(Gateway.class)).findCommitPoint(shard.index(), shard.id());\n                            if (commitPoint != null) {\n                                cachedCommitPoints.put(shard.shardId(), commitPoint);\n                            } else {\n                                cachedCommitPoints.put(shard.shardId(), CommitPoint.NULL);\n                            }\n                        } else if (commitPoint == CommitPoint.NULL) {\n                            commitPoint = null;\n                        }\n\n                        if (commitPoint == null) {\n                            break;\n                        }\n\n                        long sizeMatched = 0;\n                        for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {\n                            CommitPoint.FileInfo fileInfo = commitPoint.findPhysicalIndexFile(storeFileMetaData.name());\n                            if (fileInfo != null) {\n                                if (fileInfo.isSame(storeFileMetaData)) {\n                                    logger.trace(\"{}: [{}] reusing file since it exists on remote node and on gateway\", shard, storeFileMetaData.name());\n                                    sizeMatched += storeFileMetaData.length();\n                                } else {\n                                    logger.trace(\"{}: [{}] ignore file since it exists on remote node and on gateway but is different\", shard, storeFileMetaData.name());\n                                }\n                            } else {\n                                logger.trace(\"{}: [{}] exists on remote node, does not exists on gateway\", shard, storeFileMetaData.name());\n                            }\n                        }\n                        if (sizeMatched > lastSizeMatched) {\n                            lastSizeMatched = sizeMatched;\n                            lastDiscoNodeMatched = discoNode;\n                            lastNodeMatched = node;\n                            logger.trace(\"{}: node elected for pre_allocation [{}], total_size_matched [{}]\", shard, discoNode, new ByteSizeValue(sizeMatched));\n                        } else {\n                            logger.trace(\"{}: node ignored for pre_allocation [{}], total_size_matched [{}] smaller than last_size_matched [{}]\", shard, discoNode, new ByteSizeValue(sizeMatched), new ByteSizeValue(lastSizeMatched));\n                        }\n                    } catch (Exception e) {\n                        // failed, log and try and allocate based on size\n                        logger.debug(\"Failed to guess allocation of primary based on gateway for \" + shard, e);\n                    }\n                } else {\n                    // if its backup, see if there is a primary that *is* allocated, and try and assign a location that is closest to it\n                    // note, since we replicate operations, this might not be the same (different flush intervals)\n                    MutableShardRouting primaryShard = routingNodes.findPrimaryForReplica(shard);\n                    if (primaryShard != null && primaryShard.active()) {\n                        DiscoveryNode primaryNode = nodes.get(primaryShard.currentNodeId());\n                        if (primaryNode != null) {\n                            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore = shardStores.get(primaryNode);\n                            if (primaryNodeStore != null && primaryNodeStore.allocated()) {\n                                long sizeMatched = 0;\n\n                                for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {\n                                    if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).isSame(storeFileMetaData)) {\n                                        sizeMatched += storeFileMetaData.length();\n                                    }\n                                }\n                                if (sizeMatched > lastSizeMatched) {\n                                    lastSizeMatched = sizeMatched;\n                                    lastDiscoNodeMatched = discoNode;\n                                    lastNodeMatched = node;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (lastNodeMatched != null) {\n                if (allocation.deciders().canAllocate(shard, lastNodeMatched, allocation).type() == Decision.Type.THROTTLE) {\n                    if (logger.isTraceEnabled()) {\n                        logger.debug(\"[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we are throttling this, but we have enough to allocate to this node, ignore it for now\n                    unassignedIterator.remove();\n                    routingNodes.ignoredUnassigned().add(shard);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we found a match\n                    changed = true;\n                    lastNodeMatched.add(shard);\n                    unassignedIterator.remove();\n                }\n            }\n        }\n\n        return changed;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public boolean allocateUnassigned(RoutingAllocation allocation) {\n        boolean changed = false;\n        RoutingNodes routingNodes = allocation.routingNodes();\n\n\n        RoutingNode[] nodes = sortedNodesLeastToHigh(allocation);\n\n        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();\n        int lastNode = 0;\n\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n            // do the allocation, finding the least \"busy\" node\n            for (int i = 0; i < nodes.length; i++) {\n                RoutingNode node = nodes[lastNode];\n                lastNode++;\n                if (lastNode == nodes.length) {\n                    lastNode = 0;\n                }\n\n                if (allocation.deciders().canAllocate(shard, node, allocation).allocate()) {\n                    int numberOfShardsToAllocate = routingNodes.requiredAverageNumberOfShardsPerNode() - node.shards().size();\n                    if (numberOfShardsToAllocate <= 0) {\n                        continue;\n                    }\n\n                    changed = true;\n                    node.add(shard);\n                    unassignedIterator.remove();\n                    break;\n                }\n            }\n        }\n\n        // allocate all the unassigned shards above the average per node.\n        for (Iterator<MutableShardRouting> it = routingNodes.unassigned().iterator(); it.hasNext(); ) {\n            MutableShardRouting shard = it.next();\n            // go over the nodes and try and allocate the remaining ones\n            for (RoutingNode routingNode : sortedNodesLeastToHigh(allocation)) {\n                if (allocation.deciders().canAllocate(shard, routingNode, allocation).allocate()) {\n                    changed = true;\n                    routingNode.add(shard);\n                    it.remove();\n                    break;\n                }\n            }\n        }\n        return changed;\n    }","id":84130,"modified_method":"@Override\n    public boolean allocateUnassigned(RoutingAllocation allocation) {\n        boolean changed = false;\n        RoutingNodes routingNodes = allocation.routingNodes();\n\n\n        RoutingNode[] nodes = sortedNodesLeastToHigh(allocation);\n\n        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();\n        int lastNode = 0;\n\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n            // do the allocation, finding the least \"busy\" node\n            for (int i = 0; i < nodes.length; i++) {\n                RoutingNode node = nodes[lastNode];\n                lastNode++;\n                if (lastNode == nodes.length) {\n                    lastNode = 0;\n                }\n\n                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);\n                if (decision.type() == Decision.Type.YES) {\n                    int numberOfShardsToAllocate = routingNodes.requiredAverageNumberOfShardsPerNode() - node.shards().size();\n                    if (numberOfShardsToAllocate <= 0) {\n                        continue;\n                    }\n\n                    changed = true;\n                    node.add(shard);\n                    unassignedIterator.remove();\n                    break;\n                }\n            }\n        }\n\n        // allocate all the unassigned shards above the average per node.\n        for (Iterator<MutableShardRouting> it = routingNodes.unassigned().iterator(); it.hasNext(); ) {\n            MutableShardRouting shard = it.next();\n            // go over the nodes and try and allocate the remaining ones\n            for (RoutingNode routingNode : sortedNodesLeastToHigh(allocation)) {\n                Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);\n                if (decision.type() == Decision.Type.YES) {\n                    changed = true;\n                    routingNode.add(shard);\n                    it.remove();\n                    break;\n                }\n            }\n        }\n        return changed;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public boolean rebalance(RoutingAllocation allocation) {\n        boolean changed = false;\n        RoutingNode[] sortedNodesLeastToHigh = sortedNodesLeastToHigh(allocation);\n        if (sortedNodesLeastToHigh.length == 0) {\n            return false;\n        }\n        int lowIndex = 0;\n        int highIndex = sortedNodesLeastToHigh.length - 1;\n        boolean relocationPerformed;\n        do {\n            relocationPerformed = false;\n            while (lowIndex != highIndex) {\n                RoutingNode lowRoutingNode = sortedNodesLeastToHigh[lowIndex];\n                RoutingNode highRoutingNode = sortedNodesLeastToHigh[highIndex];\n                int averageNumOfShards = allocation.routingNodes().requiredAverageNumberOfShardsPerNode();\n\n                // only active shards can be removed so must count only active ones.\n                if (highRoutingNode.numberOfOwningShards() <= averageNumOfShards) {\n                    highIndex--;\n                    continue;\n                }\n\n                if (lowRoutingNode.shards().size() >= averageNumOfShards) {\n                    lowIndex++;\n                    continue;\n                }\n\n                boolean relocated = false;\n                List<MutableShardRouting> startedShards = highRoutingNode.shardsWithState(STARTED);\n                for (MutableShardRouting startedShard : startedShards) {\n                    if (!allocation.deciders().canRebalance(startedShard, allocation)) {\n                        continue;\n                    }\n\n                    if (allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation).allocate()) {\n                        changed = true;\n                        lowRoutingNode.add(new MutableShardRouting(startedShard.index(), startedShard.id(),\n                                lowRoutingNode.nodeId(), startedShard.currentNodeId(),\n                                startedShard.primary(), INITIALIZING, startedShard.version() + 1));\n\n                        startedShard.relocate(lowRoutingNode.nodeId());\n                        relocated = true;\n                        relocationPerformed = true;\n                        break;\n                    }\n                }\n\n                if (!relocated) {\n                    highIndex--;\n                }\n            }\n        } while (relocationPerformed);\n        return changed;\n    }","id":84131,"modified_method":"@Override\n    public boolean rebalance(RoutingAllocation allocation) {\n        boolean changed = false;\n        RoutingNode[] sortedNodesLeastToHigh = sortedNodesLeastToHigh(allocation);\n        if (sortedNodesLeastToHigh.length == 0) {\n            return false;\n        }\n        int lowIndex = 0;\n        int highIndex = sortedNodesLeastToHigh.length - 1;\n        boolean relocationPerformed;\n        do {\n            relocationPerformed = false;\n            while (lowIndex != highIndex) {\n                RoutingNode lowRoutingNode = sortedNodesLeastToHigh[lowIndex];\n                RoutingNode highRoutingNode = sortedNodesLeastToHigh[highIndex];\n                int averageNumOfShards = allocation.routingNodes().requiredAverageNumberOfShardsPerNode();\n\n                // only active shards can be removed so must count only active ones.\n                if (highRoutingNode.numberOfOwningShards() <= averageNumOfShards) {\n                    highIndex--;\n                    continue;\n                }\n\n                if (lowRoutingNode.shards().size() >= averageNumOfShards) {\n                    lowIndex++;\n                    continue;\n                }\n\n                boolean relocated = false;\n                List<MutableShardRouting> startedShards = highRoutingNode.shardsWithState(STARTED);\n                for (MutableShardRouting startedShard : startedShards) {\n                    if (!allocation.deciders().canRebalance(startedShard, allocation)) {\n                        continue;\n                    }\n\n                    Decision decision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);\n                    if (decision.type() == Decision.Type.YES) {\n                        changed = true;\n                        lowRoutingNode.add(new MutableShardRouting(startedShard.index(), startedShard.id(),\n                                lowRoutingNode.nodeId(), startedShard.currentNodeId(),\n                                startedShard.primary(), INITIALIZING, startedShard.version() + 1));\n\n                        startedShard.relocate(lowRoutingNode.nodeId());\n                        relocated = true;\n                        relocationPerformed = true;\n                        break;\n                    }\n                }\n\n                if (!relocated) {\n                    highIndex--;\n                }\n            }\n        } while (relocationPerformed);\n        return changed;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public boolean move(MutableShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (!shardRouting.started()) {\n            return false;\n        }\n        boolean changed = false;\n        RoutingNode[] sortedNodesLeastToHigh = sortedNodesLeastToHigh(allocation);\n        if (sortedNodesLeastToHigh.length == 0) {\n            return false;\n        }\n\n        for (RoutingNode nodeToCheck : sortedNodesLeastToHigh) {\n            // check if its the node we are moving from, no sense to check on it\n            if (nodeToCheck.nodeId().equals(node.nodeId())) {\n                continue;\n            }\n            if (allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation).allocate()) {\n                nodeToCheck.add(new MutableShardRouting(shardRouting.index(), shardRouting.id(),\n                        nodeToCheck.nodeId(), shardRouting.currentNodeId(),\n                        shardRouting.primary(), INITIALIZING, shardRouting.version() + 1));\n\n                shardRouting.relocate(nodeToCheck.nodeId());\n                changed = true;\n                break;\n            }\n        }\n\n        return changed;\n    }","id":84132,"modified_method":"@Override\n    public boolean move(MutableShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (!shardRouting.started()) {\n            return false;\n        }\n        boolean changed = false;\n        RoutingNode[] sortedNodesLeastToHigh = sortedNodesLeastToHigh(allocation);\n        if (sortedNodesLeastToHigh.length == 0) {\n            return false;\n        }\n\n        for (RoutingNode nodeToCheck : sortedNodesLeastToHigh) {\n            // check if its the node we are moving from, no sense to check on it\n            if (nodeToCheck.nodeId().equals(node.nodeId())) {\n                continue;\n            }\n            Decision decision = allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation);\n            if (decision.type() == Decision.Type.YES) {\n                nodeToCheck.add(new MutableShardRouting(shardRouting.index(), shardRouting.id(),\n                        nodeToCheck.nodeId(), shardRouting.currentNodeId(),\n                        shardRouting.primary(), INITIALIZING, shardRouting.version() + 1));\n\n                shardRouting.relocate(nodeToCheck.nodeId());\n                changed = true;\n                break;\n            }\n        }\n\n        return changed;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public boolean allocateUnassigned(RoutingAllocation allocation) {\n        boolean changed = false;\n        DiscoveryNodes nodes = allocation.nodes();\n        RoutingNodes routingNodes = allocation.routingNodes();\n\n        // First, handle primaries, they must find a place to be allocated on here\n        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n\n            if (!shard.primary()) {\n                continue;\n            }\n\n            // this is an API allocation, ignore since we know there is no data...\n            if (!routingNodes.routingTable().index(shard.index()).shard(shard.id()).primaryAllocatedPostApi()) {\n                continue;\n            }\n\n            TObjectLongHashMap<DiscoveryNode> nodesState = buildShardStates(nodes, shard);\n\n            int numberOfAllocationsFound = 0;\n            long highestVersion = -1;\n            Set<DiscoveryNode> nodesWithHighestVersion = Sets.newHashSet();\n            for (TObjectLongIterator<DiscoveryNode> it = nodesState.iterator(); it.hasNext(); ) {\n                it.advance();\n                DiscoveryNode node = it.key();\n                long version = it.value();\n                // since we don't check in NO allocation, we need to double check here\n                if (allocation.shouldIgnoreShardForNode(shard.shardId(), node.id())) {\n                    continue;\n                }\n                if (version != -1) {\n                    numberOfAllocationsFound++;\n                    if (highestVersion == -1) {\n                        nodesWithHighestVersion.add(node);\n                        highestVersion = version;\n                    } else {\n                        if (version > highestVersion) {\n                            nodesWithHighestVersion.clear();\n                            nodesWithHighestVersion.add(node);\n                            highestVersion = version;\n                        } else if (version == highestVersion) {\n                            nodesWithHighestVersion.add(node);\n                        }\n                    }\n                }\n            }\n\n            // check if the counts meets the minimum set\n            int requiredAllocation = 1;\n            try {\n                IndexMetaData indexMetaData = routingNodes.metaData().index(shard.index());\n                String initialShards = indexMetaData.settings().get(\"index.recovery.initial_shards\", settings.get(\"index.recovery.initial_shards\", this.initialShards));\n                if (\"quorum\".equals(initialShards)) {\n                    if (indexMetaData.numberOfReplicas() > 1) {\n                        requiredAllocation = ((1 + indexMetaData.numberOfReplicas()) / 2) + 1;\n                    }\n                } else if (\"quorum-1\".equals(initialShards) || \"half\".equals(initialShards)) {\n                    if (indexMetaData.numberOfReplicas() > 2) {\n                        requiredAllocation = ((1 + indexMetaData.numberOfReplicas()) / 2);\n                    }\n                } else if (\"one\".equals(initialShards)) {\n                    requiredAllocation = 1;\n                } else if (\"full\".equals(initialShards) || \"all\".equals(initialShards)) {\n                    requiredAllocation = indexMetaData.numberOfReplicas() + 1;\n                } else if (\"full-1\".equals(initialShards) || \"all-1\".equals(initialShards)) {\n                    if (indexMetaData.numberOfReplicas() > 1) {\n                        requiredAllocation = indexMetaData.numberOfReplicas();\n                    }\n                } else {\n                    requiredAllocation = Integer.parseInt(initialShards);\n                }\n            } catch (Exception e) {\n                logger.warn(\"[{}][{}] failed to derived initial_shards from value {}, ignore allocation for {}\", shard.index(), shard.id(), initialShards, shard);\n            }\n\n            // not enough found for this shard, continue...\n            if (numberOfAllocationsFound < requiredAllocation) {\n                // we can't really allocate, so ignore it and continue\n                unassignedIterator.remove();\n                routingNodes.ignoredUnassigned().add(shard);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"[{}][{}]: not allocating, number_of_allocated_shards_found [{}], required_number [{}]\", shard.index(), shard.id(), numberOfAllocationsFound, requiredAllocation);\n                }\n                continue;\n            }\n\n            Set<DiscoveryNode> throttledNodes = Sets.newHashSet();\n            Set<DiscoveryNode> noNodes = Sets.newHashSet();\n            for (DiscoveryNode discoNode : nodesWithHighestVersion) {\n                RoutingNode node = routingNodes.node(discoNode.id());\n                AllocationDecider.Decision decision = allocation.deciders().canAllocate(shard, node, allocation);\n                if (decision == AllocationDecider.Decision.THROTTLE) {\n                    throttledNodes.add(discoNode);\n                } else if (decision == AllocationDecider.Decision.NO) {\n                    noNodes.add(discoNode);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: allocating [{}] to [{}] on primary allocation\", shard.index(), shard.id(), shard, discoNode);\n                    }\n                    // we found a match\n                    changed = true;\n                    // make sure we create one with the version from the recovered state\n                    node.add(new MutableShardRouting(shard, highestVersion));\n                    unassignedIterator.remove();\n\n                    // found a node, so no throttling, no \"no\", and break out of the loop\n                    throttledNodes.clear();\n                    noNodes.clear();\n                    break;\n                }\n            }\n            if (throttledNodes.isEmpty()) {\n                // if we have a node that we \"can't\" allocate to, force allocation, since this is our master data!\n                if (!noNodes.isEmpty()) {\n                    DiscoveryNode discoNode = noNodes.iterator().next();\n                    RoutingNode node = routingNodes.node(discoNode.id());\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: forcing allocating [{}] to [{}] on primary allocation\", shard.index(), shard.id(), shard, discoNode);\n                    }\n                    // we found a match\n                    changed = true;\n                    // make sure we create one with the version from the recovered state\n                    node.add(new MutableShardRouting(shard, highestVersion));\n                    unassignedIterator.remove();\n                }\n            } else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"[{}][{}]: throttling allocation [{}] to [{}] on primary allocation\", shard.index(), shard.id(), shard, throttledNodes);\n                }\n                // we are throttling this, but we have enough to allocate to this node, ignore it for now\n                unassignedIterator.remove();\n                routingNodes.ignoredUnassigned().add(shard);\n            }\n        }\n\n        if (!routingNodes.hasUnassigned()) {\n            return changed;\n        }\n\n        // Now, handle replicas, try to assign them to nodes that are similar to the one the primary was allocated on\n        unassignedIterator = routingNodes.unassigned().iterator();\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n\n            // pre-check if it can be allocated to any node that currently exists, so we won't list the store for it for nothing\n            boolean canBeAllocatedToAtLeastOneNode = false;\n            for (DiscoveryNode discoNode : nodes.dataNodes().values()) {\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n                // if we can't allocate it on a node, ignore it, for example, this handles\n                // cases for only allocating a replica after a primary\n                if (allocation.deciders().canAllocate(shard, node, allocation).allocate()) {\n                    canBeAllocatedToAtLeastOneNode = true;\n                    break;\n                }\n            }\n\n            if (!canBeAllocatedToAtLeastOneNode) {\n                continue;\n            }\n\n            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);\n\n            long lastSizeMatched = 0;\n            DiscoveryNode lastDiscoNodeMatched = null;\n            RoutingNode lastNodeMatched = null;\n\n            for (Map.Entry<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {\n                DiscoveryNode discoNode = nodeStoreEntry.getKey();\n                TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue();\n                logger.trace(\"{}: checking node [{}]\", shard, discoNode);\n\n                if (storeFilesMetaData == null) {\n                    // already allocated on that node...\n                    continue;\n                }\n\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n\n                // check if we can allocate on that node...\n                // we only check for NO, since if this node is THROTTLING and it has enough \"same data\"\n                // then we will try and assign it next time\n                if (allocation.deciders().canAllocate(shard, node, allocation) == AllocationDecider.Decision.NO) {\n                    continue;\n                }\n\n                // if it is already allocated, we can't assign to it...\n                if (storeFilesMetaData.allocated()) {\n                    continue;\n                }\n\n                if (!shard.primary()) {\n                    MutableShardRouting primaryShard = routingNodes.findPrimaryForReplica(shard);\n                    if (primaryShard != null && primaryShard.active()) {\n                        DiscoveryNode primaryNode = nodes.get(primaryShard.currentNodeId());\n                        if (primaryNode != null) {\n                            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore = shardStores.get(primaryNode);\n                            if (primaryNodeStore != null && primaryNodeStore.allocated()) {\n                                long sizeMatched = 0;\n\n                                for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {\n                                    if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).isSame(storeFileMetaData)) {\n                                        sizeMatched += storeFileMetaData.length();\n                                    }\n                                }\n                                if (sizeMatched > lastSizeMatched) {\n                                    lastSizeMatched = sizeMatched;\n                                    lastDiscoNodeMatched = discoNode;\n                                    lastNodeMatched = node;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (lastNodeMatched != null) {\n                // we only check on THROTTLE since we checked before before on NO\n                if (allocation.deciders().canAllocate(shard, lastNodeMatched, allocation) == AllocationDecider.Decision.THROTTLE) {\n                    if (logger.isTraceEnabled()) {\n                        logger.debug(\"[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we are throttling this, but we have enough to allocate to this node, ignore it for now\n                    unassignedIterator.remove();\n                    routingNodes.ignoredUnassigned().add(shard);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we found a match\n                    changed = true;\n                    lastNodeMatched.add(shard);\n                    unassignedIterator.remove();\n                }\n            }\n        }\n\n        return changed;\n    }","id":84133,"modified_method":"@Override\n    public boolean allocateUnassigned(RoutingAllocation allocation) {\n        boolean changed = false;\n        DiscoveryNodes nodes = allocation.nodes();\n        RoutingNodes routingNodes = allocation.routingNodes();\n\n        // First, handle primaries, they must find a place to be allocated on here\n        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n\n            if (!shard.primary()) {\n                continue;\n            }\n\n            // this is an API allocation, ignore since we know there is no data...\n            if (!routingNodes.routingTable().index(shard.index()).shard(shard.id()).primaryAllocatedPostApi()) {\n                continue;\n            }\n\n            TObjectLongHashMap<DiscoveryNode> nodesState = buildShardStates(nodes, shard);\n\n            int numberOfAllocationsFound = 0;\n            long highestVersion = -1;\n            Set<DiscoveryNode> nodesWithHighestVersion = Sets.newHashSet();\n            for (TObjectLongIterator<DiscoveryNode> it = nodesState.iterator(); it.hasNext(); ) {\n                it.advance();\n                DiscoveryNode node = it.key();\n                long version = it.value();\n                // since we don't check in NO allocation, we need to double check here\n                if (allocation.shouldIgnoreShardForNode(shard.shardId(), node.id())) {\n                    continue;\n                }\n                if (version != -1) {\n                    numberOfAllocationsFound++;\n                    if (highestVersion == -1) {\n                        nodesWithHighestVersion.add(node);\n                        highestVersion = version;\n                    } else {\n                        if (version > highestVersion) {\n                            nodesWithHighestVersion.clear();\n                            nodesWithHighestVersion.add(node);\n                            highestVersion = version;\n                        } else if (version == highestVersion) {\n                            nodesWithHighestVersion.add(node);\n                        }\n                    }\n                }\n            }\n\n            // check if the counts meets the minimum set\n            int requiredAllocation = 1;\n            try {\n                IndexMetaData indexMetaData = routingNodes.metaData().index(shard.index());\n                String initialShards = indexMetaData.settings().get(\"index.recovery.initial_shards\", settings.get(\"index.recovery.initial_shards\", this.initialShards));\n                if (\"quorum\".equals(initialShards)) {\n                    if (indexMetaData.numberOfReplicas() > 1) {\n                        requiredAllocation = ((1 + indexMetaData.numberOfReplicas()) / 2) + 1;\n                    }\n                } else if (\"quorum-1\".equals(initialShards) || \"half\".equals(initialShards)) {\n                    if (indexMetaData.numberOfReplicas() > 2) {\n                        requiredAllocation = ((1 + indexMetaData.numberOfReplicas()) / 2);\n                    }\n                } else if (\"one\".equals(initialShards)) {\n                    requiredAllocation = 1;\n                } else if (\"full\".equals(initialShards) || \"all\".equals(initialShards)) {\n                    requiredAllocation = indexMetaData.numberOfReplicas() + 1;\n                } else if (\"full-1\".equals(initialShards) || \"all-1\".equals(initialShards)) {\n                    if (indexMetaData.numberOfReplicas() > 1) {\n                        requiredAllocation = indexMetaData.numberOfReplicas();\n                    }\n                } else {\n                    requiredAllocation = Integer.parseInt(initialShards);\n                }\n            } catch (Exception e) {\n                logger.warn(\"[{}][{}] failed to derived initial_shards from value {}, ignore allocation for {}\", shard.index(), shard.id(), initialShards, shard);\n            }\n\n            // not enough found for this shard, continue...\n            if (numberOfAllocationsFound < requiredAllocation) {\n                // we can't really allocate, so ignore it and continue\n                unassignedIterator.remove();\n                routingNodes.ignoredUnassigned().add(shard);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"[{}][{}]: not allocating, number_of_allocated_shards_found [{}], required_number [{}]\", shard.index(), shard.id(), numberOfAllocationsFound, requiredAllocation);\n                }\n                continue;\n            }\n\n            Set<DiscoveryNode> throttledNodes = Sets.newHashSet();\n            Set<DiscoveryNode> noNodes = Sets.newHashSet();\n            for (DiscoveryNode discoNode : nodesWithHighestVersion) {\n                RoutingNode node = routingNodes.node(discoNode.id());\n                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);\n                if (decision.type() == Decision.Type.THROTTLE) {\n                    throttledNodes.add(discoNode);\n                } else if (decision.type() == Decision.Type.NO) {\n                    noNodes.add(discoNode);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: allocating [{}] to [{}] on primary allocation\", shard.index(), shard.id(), shard, discoNode);\n                    }\n                    // we found a match\n                    changed = true;\n                    // make sure we create one with the version from the recovered state\n                    node.add(new MutableShardRouting(shard, highestVersion));\n                    unassignedIterator.remove();\n\n                    // found a node, so no throttling, no \"no\", and break out of the loop\n                    throttledNodes.clear();\n                    noNodes.clear();\n                    break;\n                }\n            }\n            if (throttledNodes.isEmpty()) {\n                // if we have a node that we \"can't\" allocate to, force allocation, since this is our master data!\n                if (!noNodes.isEmpty()) {\n                    DiscoveryNode discoNode = noNodes.iterator().next();\n                    RoutingNode node = routingNodes.node(discoNode.id());\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: forcing allocating [{}] to [{}] on primary allocation\", shard.index(), shard.id(), shard, discoNode);\n                    }\n                    // we found a match\n                    changed = true;\n                    // make sure we create one with the version from the recovered state\n                    node.add(new MutableShardRouting(shard, highestVersion));\n                    unassignedIterator.remove();\n                }\n            } else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"[{}][{}]: throttling allocation [{}] to [{}] on primary allocation\", shard.index(), shard.id(), shard, throttledNodes);\n                }\n                // we are throttling this, but we have enough to allocate to this node, ignore it for now\n                unassignedIterator.remove();\n                routingNodes.ignoredUnassigned().add(shard);\n            }\n        }\n\n        if (!routingNodes.hasUnassigned()) {\n            return changed;\n        }\n\n        // Now, handle replicas, try to assign them to nodes that are similar to the one the primary was allocated on\n        unassignedIterator = routingNodes.unassigned().iterator();\n        while (unassignedIterator.hasNext()) {\n            MutableShardRouting shard = unassignedIterator.next();\n\n            // pre-check if it can be allocated to any node that currently exists, so we won't list the store for it for nothing\n            boolean canBeAllocatedToAtLeastOneNode = false;\n            for (DiscoveryNode discoNode : nodes.dataNodes().values()) {\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n                // if we can't allocate it on a node, ignore it, for example, this handles\n                // cases for only allocating a replica after a primary\n                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);\n                if (decision.type() == Decision.Type.YES) {\n                    canBeAllocatedToAtLeastOneNode = true;\n                    break;\n                }\n            }\n\n            if (!canBeAllocatedToAtLeastOneNode) {\n                continue;\n            }\n\n            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);\n\n            long lastSizeMatched = 0;\n            DiscoveryNode lastDiscoNodeMatched = null;\n            RoutingNode lastNodeMatched = null;\n\n            for (Map.Entry<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {\n                DiscoveryNode discoNode = nodeStoreEntry.getKey();\n                TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue();\n                logger.trace(\"{}: checking node [{}]\", shard, discoNode);\n\n                if (storeFilesMetaData == null) {\n                    // already allocated on that node...\n                    continue;\n                }\n\n                RoutingNode node = routingNodes.node(discoNode.id());\n                if (node == null) {\n                    continue;\n                }\n\n                // check if we can allocate on that node...\n                // we only check for NO, since if this node is THROTTLING and it has enough \"same data\"\n                // then we will try and assign it next time\n                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);\n                if (decision.type() == Decision.Type.NO) {\n                    continue;\n                }\n\n                // if it is already allocated, we can't assign to it...\n                if (storeFilesMetaData.allocated()) {\n                    continue;\n                }\n\n                if (!shard.primary()) {\n                    MutableShardRouting primaryShard = routingNodes.findPrimaryForReplica(shard);\n                    if (primaryShard != null && primaryShard.active()) {\n                        DiscoveryNode primaryNode = nodes.get(primaryShard.currentNodeId());\n                        if (primaryNode != null) {\n                            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore = shardStores.get(primaryNode);\n                            if (primaryNodeStore != null && primaryNodeStore.allocated()) {\n                                long sizeMatched = 0;\n\n                                for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {\n                                    if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).isSame(storeFileMetaData)) {\n                                        sizeMatched += storeFileMetaData.length();\n                                    }\n                                }\n                                if (sizeMatched > lastSizeMatched) {\n                                    lastSizeMatched = sizeMatched;\n                                    lastDiscoNodeMatched = discoNode;\n                                    lastNodeMatched = node;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (lastNodeMatched != null) {\n                // we only check on THROTTLE since we checked before before on NO\n                Decision decision = allocation.deciders().canAllocate(shard, lastNodeMatched, allocation);\n                if (decision.type() == Decision.Type.THROTTLE) {\n                    if (logger.isTraceEnabled()) {\n                        logger.debug(\"[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we are throttling this, but we have enough to allocate to this node, ignore it for now\n                    unassignedIterator.remove();\n                    routingNodes.ignoredUnassigned().add(shard);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]\", shard.index(), shard.id(), shard, lastDiscoNodeMatched, new ByteSizeValue(lastSizeMatched));\n                    }\n                    // we found a match\n                    changed = true;\n                    lastNodeMatched.add(shard);\n                    unassignedIterator.remove();\n                }\n            }\n        }\n\n        return changed;\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void execute(RoutingAllocation allocation) throws ElasticSearchException {\n        DiscoveryNode fromDiscoNode = allocation.nodes().resolveNode(fromNode);\n        DiscoveryNode toDiscoNode = allocation.nodes().resolveNode(toNode);\n\n        boolean found = false;\n        for (MutableShardRouting shardRouting : allocation.routingNodes().node(fromDiscoNode.id())) {\n            if (!shardRouting.shardId().equals(shardId)) {\n                continue;\n            }\n            found = true;\n\n            // TODO we can possibly support also relocating cases, where we cancel relocation and move...\n            if (!shardRouting.started()) {\n                throw new ElasticSearchIllegalArgumentException(\"[move_allocation] can't move \" + shardId + \", shard is not started (state = \" + shardRouting.state() + \"]\");\n            }\n\n            RoutingNode toRoutingNode = allocation.routingNodes().node(toDiscoNode.id());\n            AllocationDecider.Decision decision = allocation.deciders().canAllocate(shardRouting, toRoutingNode, allocation);\n            if (!decision.allowed()) {\n                throw new ElasticSearchIllegalArgumentException(\"[move_allocation] can't move \" + shardId + \", from \" + fromDiscoNode + \", to \" + toDiscoNode + \", since its not allowed\");\n            }\n            if (!decision.allocate()) {\n                // its being throttled, maybe have a flag to take it into account and fail? for now, just do it since the \"user\" wants it...\n            }\n\n            toRoutingNode.add(new MutableShardRouting(shardRouting.index(), shardRouting.id(),\n                    toRoutingNode.nodeId(), shardRouting.currentNodeId(),\n                    shardRouting.primary(), ShardRoutingState.INITIALIZING, shardRouting.version() + 1));\n\n            shardRouting.relocate(toRoutingNode.nodeId());\n        }\n\n        if (!found) {\n            throw new ElasticSearchIllegalArgumentException(\"[move_allocation] can't move \" + shardId + \", failed to find it on node \" + fromDiscoNode);\n        }\n    }","id":84134,"modified_method":"@Override\n    public void execute(RoutingAllocation allocation) throws ElasticSearchException {\n        DiscoveryNode fromDiscoNode = allocation.nodes().resolveNode(fromNode);\n        DiscoveryNode toDiscoNode = allocation.nodes().resolveNode(toNode);\n\n        boolean found = false;\n        for (MutableShardRouting shardRouting : allocation.routingNodes().node(fromDiscoNode.id())) {\n            if (!shardRouting.shardId().equals(shardId)) {\n                continue;\n            }\n            found = true;\n\n            // TODO we can possibly support also relocating cases, where we cancel relocation and move...\n            if (!shardRouting.started()) {\n                throw new ElasticSearchIllegalArgumentException(\"[move_allocation] can't move \" + shardId + \", shard is not started (state = \" + shardRouting.state() + \"]\");\n            }\n\n            RoutingNode toRoutingNode = allocation.routingNodes().node(toDiscoNode.id());\n            Decision decision = allocation.deciders().canAllocate(shardRouting, toRoutingNode, allocation);\n            if (decision.type() == Decision.Type.NO) {\n                throw new ElasticSearchIllegalArgumentException(\"[move_allocation] can't move \" + shardId + \", from \" + fromDiscoNode + \", to \" + toDiscoNode + \", since its not allowed, reason: \" + decision);\n            }\n            if (decision.type() == Decision.Type.THROTTLE) {\n                // its being throttled, maybe have a flag to take it into account and fail? for now, just do it since the \"user\" wants it...\n            }\n\n            toRoutingNode.add(new MutableShardRouting(shardRouting.index(), shardRouting.id(),\n                    toRoutingNode.nodeId(), shardRouting.currentNodeId(),\n                    shardRouting.primary(), ShardRoutingState.INITIALIZING, shardRouting.version() + 1));\n\n            shardRouting.relocate(toRoutingNode.nodeId());\n        }\n\n        if (!found) {\n            throw new ElasticSearchIllegalArgumentException(\"[move_allocation] can't move \" + shardId + \", failed to find it on node \" + fromDiscoNode);\n        }\n    }","commit_id":"c2073c343df39afbe10db22492aaefa23787e4a8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void doCollectInformation(final ProgressIndicator progress) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(myProject).getInspectionProfile();\n    final boolean deadCodeEnabled = profile.isToolEnabled(HighlightDisplayKey.find(GroovyUnusedDeclarationInspection.SHORT_NAME), myFile);\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    VirtualFile virtualFile = myFile.getViewProvider().getVirtualFile();\n    if (!fileIndex.isInContent(virtualFile)) {\n      return;\n    }\n    final InspectionToolWrapper wrapper = (InspectionToolWrapper)profile.getInspectionTool(UnusedDeclarationInspection.SHORT_NAME, myFile);\n    final UnusedDeclarationInspection deadCodeInspection = wrapper != null ? (UnusedDeclarationInspection)wrapper.getTool() : null;\n    final GlobalUsageHelper usageHelper = new GlobalUsageHelper() {\n      public boolean isCurrentFileAlreadyChecked() {\n        return false;\n      }\n\n      public boolean isLocallyUsed(@NotNull PsiNamedElement member) {\n        return false;\n      }\n\n      @Override\n      public boolean shouldCheckUsages(@NotNull PsiMember member) {\n        return deadCodeInspection == null || !deadCodeInspection.isEntryPoint(member);\n      }\n    };\n\n    final List<HighlightInfo> unusedDeclarations = new ArrayList<HighlightInfo>();\n    final Set<GrImportStatement> unusedImports = new HashSet<GrImportStatement>(GroovyImportOptimizer.getValidImportStatements(myFile));\n    myFile.accept(new PsiRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitElement(PsiElement element) {\n        if (element instanceof GrReferenceElement) {\n          for (GroovyResolveResult result : ((GrReferenceElement)element).multiResolve(true)) {\n            GroovyPsiElement context = result.getCurrentFileResolveContext();\n            if (context instanceof GrImportStatement) {\n              GrImportStatement importStatement = (GrImportStatement)context;\n              unusedImports.remove(importStatement);\n            }\n          }\n        }\n\n        if (deadCodeEnabled && element instanceof GrNamedElement && !PostHighlightingPass.isImplicitUsage((GrNamedElement)element, progress)) {\n          PsiElement nameId = ((GrNamedElement)element).getNameIdentifierGroovy();\n          if (nameId.getNode().getElementType() == GroovyTokenTypes.mIDENT) {\n            String name = ((GrNamedElement)element).getName();\n            if (element instanceof GrTypeDefinition && !PostHighlightingPass.isClassUsed((GrTypeDefinition)element, progress, usageHelper)) {\n              unusedDeclarations.add(\n                PostHighlightingPass.createUnusedSymbolInfo(nameId, \"Class \" + name + \" is unused\", HighlightInfoType.UNUSED_SYMBOL));\n            }\n            else if (element instanceof GrMethod) {\n              GrMethod method = (GrMethod)element;\n              if (!GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(method.getName()) &&\n                  !PostHighlightingPass.isMethodReferenced(method, progress, usageHelper)) {\n                unusedDeclarations.add(\n                  PostHighlightingPass.createUnusedSymbolInfo(nameId, (method.isConstructor() ? \"Constructor\" : \"Method\") +\" \" + name + \" is unused\", HighlightInfoType.UNUSED_SYMBOL));\n              }\n            }\n            else if (element instanceof GrField && PostHighlightingPass.isFieldUnused((GrField)element, progress, usageHelper)) {\n              unusedDeclarations.add(\n                PostHighlightingPass.createUnusedSymbolInfo(nameId, \"Property \" + name + \" is unused\", HighlightInfoType.UNUSED_SYMBOL));\n            }\n          }\n        }\n        \n        super.visitElement(element);\n      }\n    });\n    myUnusedImports = unusedImports;\n    myUnusedDeclarations = unusedDeclarations;\n    if (!unusedImports.isEmpty() && CodeInsightSettings.getInstance().OPTIMIZE_IMPORTS_ON_THE_FLY) {\n      final VirtualFile vfile = myFile.getVirtualFile();\n      if (vfile != null && ProjectRootManager.getInstance(myFile.getProject()).getFileIndex().isInSource(vfile)) {\n        final GrImportStatement[] imports = myFile.getImportStatements();\n        if (imports.length > 0) {\n          final int offset = myEditor.getCaretModel().getOffset();\n          if (imports[0].getTextRange().getStartOffset() <= offset && offset <= imports[imports.length - 1].getTextRange().getEndOffset()) {\n            return;\n          }\n        }\n\n        myOptimizeRunnable = new GroovyImportOptimizer().processFile(myFile);\n      }\n    }\n\n  }","id":84135,"modified_method":"public void doCollectInformation(final ProgressIndicator progress) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(myProject).getInspectionProfile();\n    final boolean deadCodeEnabled = profile.isToolEnabled(HighlightDisplayKey.find(GroovyUnusedDeclarationInspection.SHORT_NAME), myFile);\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    VirtualFile virtualFile = myFile.getViewProvider().getVirtualFile();\n    if (!fileIndex.isInContent(virtualFile)) {\n      return;\n    }\n    final UnusedDeclarationInspection deadCodeInspection = (UnusedDeclarationInspection)profile.getUnwrappedTool(UnusedDeclarationInspection.SHORT_NAME, myFile);\n    final GlobalUsageHelper usageHelper = new GlobalUsageHelper() {\n      public boolean isCurrentFileAlreadyChecked() {\n        return false;\n      }\n\n      public boolean isLocallyUsed(@NotNull PsiNamedElement member) {\n        return false;\n      }\n\n      @Override\n      public boolean shouldCheckUsages(@NotNull PsiMember member) {\n        return deadCodeInspection == null || !deadCodeInspection.isEntryPoint(member);\n      }\n    };\n\n    final List<HighlightInfo> unusedDeclarations = new ArrayList<HighlightInfo>();\n    final Set<GrImportStatement> unusedImports = new HashSet<GrImportStatement>(GroovyImportOptimizer.getValidImportStatements(myFile));\n    myFile.accept(new PsiRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitElement(PsiElement element) {\n        if (element instanceof GrReferenceElement) {\n          for (GroovyResolveResult result : ((GrReferenceElement)element).multiResolve(true)) {\n            GroovyPsiElement context = result.getCurrentFileResolveContext();\n            if (context instanceof GrImportStatement) {\n              GrImportStatement importStatement = (GrImportStatement)context;\n              unusedImports.remove(importStatement);\n            }\n          }\n        }\n\n        if (deadCodeEnabled && element instanceof GrNamedElement && !PostHighlightingPass.isImplicitUsage((GrNamedElement)element, progress)) {\n          PsiElement nameId = ((GrNamedElement)element).getNameIdentifierGroovy();\n          if (nameId.getNode().getElementType() == GroovyTokenTypes.mIDENT) {\n            String name = ((GrNamedElement)element).getName();\n            if (element instanceof GrTypeDefinition && !PostHighlightingPass.isClassUsed((GrTypeDefinition)element, progress, usageHelper)) {\n              unusedDeclarations.add(\n                PostHighlightingPass.createUnusedSymbolInfo(nameId, \"Class \" + name + \" is unused\", HighlightInfoType.UNUSED_SYMBOL));\n            }\n            else if (element instanceof GrMethod) {\n              GrMethod method = (GrMethod)element;\n              if (!GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(method.getName()) &&\n                  !PostHighlightingPass.isMethodReferenced(method, progress, usageHelper)) {\n                unusedDeclarations.add(\n                  PostHighlightingPass.createUnusedSymbolInfo(nameId, (method.isConstructor() ? \"Constructor\" : \"Method\") +\" \" + name + \" is unused\", HighlightInfoType.UNUSED_SYMBOL));\n              }\n            }\n            else if (element instanceof GrField && PostHighlightingPass.isFieldUnused((GrField)element, progress, usageHelper)) {\n              unusedDeclarations.add(\n                PostHighlightingPass.createUnusedSymbolInfo(nameId, \"Property \" + name + \" is unused\", HighlightInfoType.UNUSED_SYMBOL));\n            }\n          }\n        }\n        \n        super.visitElement(element);\n      }\n    });\n    myUnusedImports = unusedImports;\n    myUnusedDeclarations = unusedDeclarations;\n    if (!unusedImports.isEmpty() && CodeInsightSettings.getInstance().OPTIMIZE_IMPORTS_ON_THE_FLY) {\n      final VirtualFile vfile = myFile.getVirtualFile();\n      if (vfile != null && ProjectRootManager.getInstance(myFile.getProject()).getFileIndex().isInSource(vfile)) {\n        final GrImportStatement[] imports = myFile.getImportStatements();\n        if (imports.length > 0) {\n          final int offset = myEditor.getCaretModel().getOffset();\n          if (imports[0].getTextRange().getStartOffset() <= offset && offset <= imports[imports.length - 1].getTextRange().getEndOffset()) {\n            return;\n          }\n        }\n\n        myOptimizeRunnable = new GroovyImportOptimizer().processFile(myFile);\n      }\n    }\n\n  }","commit_id":"0d36f69fdfb9219f2ebb3de7adf82d35fb72d6a4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static StringBuilder addRequiredAttributes(XmlElementDescriptor descriptor,\n                                                     @Nullable XmlTag tag,\n                                                     Template template,\n                                                     PsiFile containingFile) {\n\n    boolean htmlCode = HtmlUtil.hasHtml(containingFile);\n    Set<String> notRequiredAttributes = Collections.emptySet();\n\n    if (tag instanceof HtmlTag) {\n      final InspectionProfile profile = InspectionProjectProfileManager.getInstance(tag.getProject()).getInspectionProfile();\n      LocalInspectionToolWrapper localInspectionToolWrapper = (LocalInspectionToolWrapper) profile.getInspectionTool(\n        RequiredAttributesInspection.SHORT_NAME, tag);\n      RequiredAttributesInspection inspection = localInspectionToolWrapper != null ?\n        (RequiredAttributesInspection) localInspectionToolWrapper.getTool(): null;\n\n      if (inspection != null) {\n        StringTokenizer tokenizer = new StringTokenizer(inspection.getAdditionalEntries(0));\n        notRequiredAttributes = new HashSet<String>();\n\n        while(tokenizer.hasMoreElements()) notRequiredAttributes.add(tokenizer.nextToken());\n      }\n    }\n\n    XmlAttributeDescriptor[] attributes = descriptor.getAttributesDescriptors(tag);\n    StringBuilder indirectRequiredAttrs = null;\n\n    if (WebEditorOptions.getInstance().isAutomaticallyInsertRequiredAttributes()) {\n      final XmlExtension extension = XmlExtension.getExtension(containingFile);\n\n      for (XmlAttributeDescriptor attributeDecl : attributes) {\n        String attributeName = attributeDecl.getName(tag);\n\n        if (attributeDecl.isRequired() && (tag == null || tag.getAttributeValue(attributeName) == null)) {\n          if (!notRequiredAttributes.contains(attributeName)) {\n            if (!extension.isIndirectSyntax(attributeDecl)) {\n              template.addTextSegment(\" \" + attributeName + \"=\\\"\");\n              template.addVariable(new MacroCallNode(new CompleteMacro()), true);\n              template.addTextSegment(\"\\\"\");\n            }\n            else {\n              if (indirectRequiredAttrs == null) indirectRequiredAttrs = new StringBuilder();\n              indirectRequiredAttrs.append(\"\\n<jsp:attribute name=\\\"\").append(attributeName).append(\"\\\"><\/jsp:attribute>\\n\");\n            }\n          }\n        }\n        else if (attributeDecl.isRequired() && attributeDecl.isFixed() && attributeDecl.getDefaultValue() != null && !htmlCode) {\n          template.addTextSegment(\" \" + attributeName + \"=\\\"\" + attributeDecl.getDefaultValue() + \"\\\"\");\n        }\n      }\n    }\n    return indirectRequiredAttrs;\n  }","id":84136,"modified_method":"@Nullable\n  private static StringBuilder addRequiredAttributes(XmlElementDescriptor descriptor,\n                                                     @Nullable XmlTag tag,\n                                                     Template template,\n                                                     PsiFile containingFile) {\n\n    boolean htmlCode = HtmlUtil.hasHtml(containingFile);\n    Set<String> notRequiredAttributes = Collections.emptySet();\n\n    if (tag instanceof HtmlTag) {\n      final InspectionProfile profile = InspectionProjectProfileManager.getInstance(tag.getProject()).getInspectionProfile();\n      RequiredAttributesInspection inspection = (RequiredAttributesInspection)profile.getUnwrappedTool(\n        RequiredAttributesInspection.SHORT_NAME, tag);\n\n      if (inspection != null) {\n        StringTokenizer tokenizer = new StringTokenizer(inspection.getAdditionalEntries(0));\n        notRequiredAttributes = new HashSet<String>();\n\n        while(tokenizer.hasMoreElements()) notRequiredAttributes.add(tokenizer.nextToken());\n      }\n    }\n\n    XmlAttributeDescriptor[] attributes = descriptor.getAttributesDescriptors(tag);\n    StringBuilder indirectRequiredAttrs = null;\n\n    if (WebEditorOptions.getInstance().isAutomaticallyInsertRequiredAttributes()) {\n      final XmlExtension extension = XmlExtension.getExtension(containingFile);\n\n      for (XmlAttributeDescriptor attributeDecl : attributes) {\n        String attributeName = attributeDecl.getName(tag);\n\n        if (attributeDecl.isRequired() && (tag == null || tag.getAttributeValue(attributeName) == null)) {\n          if (!notRequiredAttributes.contains(attributeName)) {\n            if (!extension.isIndirectSyntax(attributeDecl)) {\n              template.addTextSegment(\" \" + attributeName + \"=\\\"\");\n              template.addVariable(new MacroCallNode(new CompleteMacro()), true);\n              template.addTextSegment(\"\\\"\");\n            }\n            else {\n              if (indirectRequiredAttrs == null) indirectRequiredAttrs = new StringBuilder();\n              indirectRequiredAttrs.append(\"\\n<jsp:attribute name=\\\"\").append(attributeName).append(\"\\\"><\/jsp:attribute>\\n\");\n            }\n          }\n        }\n        else if (attributeDecl.isRequired() && attributeDecl.isFixed() && attributeDecl.getDefaultValue() != null && !htmlCode) {\n          template.addTextSegment(\" \" + attributeName + \"=\\\"\" + attributeDecl.getDefaultValue() + \"\\\"\");\n        }\n      }\n    }\n    return indirectRequiredAttrs;\n  }","commit_id":"8380366cc2e821e491beb0529b46068932196766","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkRequiredAttributes(XmlTag tag, String name, XmlElementDescriptor elementDescriptor) {\n    XmlAttributeDescriptor[] attributeDescriptors = elementDescriptor.getAttributesDescriptors(tag);\n    Set<String> requiredAttributes = null;\n\n    for (XmlAttributeDescriptor attribute : attributeDescriptors) {\n      if (attribute != null && attribute.isRequired()) {\n        if (requiredAttributes == null) {\n          requiredAttributes = new HashSet<String>();\n        }\n        requiredAttributes.add(attribute.getName(tag));\n      }\n    }\n\n    if (requiredAttributes != null) {\n      for (final String attrName : requiredAttributes) {\n        if (tag.getAttributeValue(attrName) == null &&\n            !XmlExtension.getExtension(tag.getContainingFile()).isRequiredAttributeImplicitlyPresent(tag, attrName)) {\n\n          final InsertRequiredAttributeFix insertRequiredAttributeIntention = new InsertRequiredAttributeFix(\n              tag, attrName, null);\n          final String localizedMessage = XmlErrorMessages.message(\"element.doesnt.have.required.attribute\", name, attrName);\n          final InspectionProfile profile = InspectionProjectProfileManager.getInstance(tag.getProject()).getInspectionProfile();\n          final LocalInspectionToolWrapper toolWrapper =\n            (LocalInspectionToolWrapper)profile.getInspectionTool(RequiredAttributesInspection.SHORT_NAME, tag);\n          if (toolWrapper != null) {\n            RequiredAttributesInspection inspection = (RequiredAttributesInspection)toolWrapper.getTool();\n            reportOneTagProblem(\n              tag,\n              attrName,\n              localizedMessage,\n              insertRequiredAttributeIntention,\n              HighlightDisplayKey.find(RequiredAttributesInspection.SHORT_NAME),\n              inspection,\n              XmlEntitiesInspection.NOT_REQUIRED_ATTRIBUTE\n            );\n          }\n        }\n      }\n    }\n  }","id":84137,"modified_method":"private void checkRequiredAttributes(XmlTag tag, String name, XmlElementDescriptor elementDescriptor) {\n    XmlAttributeDescriptor[] attributeDescriptors = elementDescriptor.getAttributesDescriptors(tag);\n    Set<String> requiredAttributes = null;\n\n    for (XmlAttributeDescriptor attribute : attributeDescriptors) {\n      if (attribute != null && attribute.isRequired()) {\n        if (requiredAttributes == null) {\n          requiredAttributes = new HashSet<String>();\n        }\n        requiredAttributes.add(attribute.getName(tag));\n      }\n    }\n\n    if (requiredAttributes != null) {\n      for (final String attrName : requiredAttributes) {\n        if (tag.getAttributeValue(attrName) == null &&\n            !XmlExtension.getExtension(tag.getContainingFile()).isRequiredAttributeImplicitlyPresent(tag, attrName)) {\n\n          final InsertRequiredAttributeFix insertRequiredAttributeIntention = new InsertRequiredAttributeFix(\n              tag, attrName, null);\n          final String localizedMessage = XmlErrorMessages.message(\"element.doesnt.have.required.attribute\", name, attrName);\n          final InspectionProfile profile = InspectionProjectProfileManager.getInstance(tag.getProject()).getInspectionProfile();\n          RequiredAttributesInspection inspection =\n            (RequiredAttributesInspection)profile.getUnwrappedTool(RequiredAttributesInspection.SHORT_NAME, tag);\n          if (inspection != null) {\n            reportOneTagProblem(\n              tag,\n              attrName,\n              localizedMessage,\n              insertRequiredAttributeIntention,\n              HighlightDisplayKey.find(RequiredAttributesInspection.SHORT_NAME),\n              inspection,\n              XmlEntitiesInspection.NOT_REQUIRED_ATTRIBUTE\n            );\n          }\n        }\n      }\n    }\n  }","commit_id":"8d12aefe5d8eadc4586cebff4031738806f11ec2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Subscribe ingest manager to service monitor events. Cancels ingest\n     * if one of services it's subscribed to goes down.\n     */\n    private void subscribeToServiceMonitorEvents() {\n        PropertyChangeListener propChangeListener = new PropertyChangeListener() {\n            @Override\n            public void propertyChange(PropertyChangeEvent evt) {\n                if (evt.getNewValue().equals(ServicesMonitor.ServiceStatus.DOWN.toString())) {\n                    // one of the services we subscribed to went down                    \n                    String serviceDisplayName = ServicesMonitor.Service.valueOf(evt.getPropertyName()).getDisplayName();\n                    logger.log(Level.SEVERE, \"Service {0} is down! Cancelling all running ingest jobs\", serviceDisplayName); //NON-NLS                  \n\n                    // display notification if running interactively\n                    if (isIngestRunning() && isRunningInteractively()) {\n                        EventQueue.invokeLater(new Runnable() {\n                            @Override\n                            public void run() {\n                                JOptionPane.showMessageDialog(null,\n                                        NbBundle.getMessage(this.getClass(), \"IngestManager.cancellingIngest.msgDlg.text\"),\n                                        NbBundle.getMessage(this.getClass(), \"IngestManager.serviceIsDown.msgDlg.text\", serviceDisplayName),\n                                        JOptionPane.ERROR_MESSAGE);\n                            }\n                        });\n                    }\n\n                    // cancel ingest if running\n                    cancelAllIngestJobs();\n                }\n            }\n        };\n\n        // subscribe to services of interest\n        Set<String> servicesList = new HashSet<>();\n        servicesList.add(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString());\n        servicesList.add(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString());\n        this.servicesMonitor.addSubscriber(servicesList, propChangeListener);\n    }","id":84138,"modified_method":"/**\n     * Subscribe ingest manager to service monitor events. Cancels ingest\n     * if one of services it's subscribed to goes down.\n     */\n    private void subscribeToServiceMonitorEvents() {\n        PropertyChangeListener propChangeListener = new PropertyChangeListener() {\n            @Override\n            public void propertyChange(PropertyChangeEvent evt) {\n                if (evt.getNewValue().equals(ServicesMonitor.ServiceStatus.DOWN.toString())) {\n                    \n                    // check whether a milti-user case is currently being processed\n                    try {\n                        if (!Case.isCaseOpen() || Case.getCurrentCase().getCaseType() != Case.CaseType.MULTI_USER_CASE) {\n                            return;\n                        }\n                    } catch (IllegalStateException ignore) {\n                        // thorown by Case.getCurrentCase() when no case is open\n                        return;\n                    }\n                    \n                    // one of the services we subscribed to went down                    \n                    String serviceDisplayName = ServicesMonitor.Service.valueOf(evt.getPropertyName()).getDisplayName();\n                    logger.log(Level.SEVERE, \"Service {0} is down! Cancelling all running ingest jobs\", serviceDisplayName); //NON-NLS                  \n\n                    // display notification if running interactively\n                    if (isIngestRunning() && isRunningInteractively()) {\n                        EventQueue.invokeLater(new Runnable() {\n                            @Override\n                            public void run() {\n                                JOptionPane.showMessageDialog(null,\n                                        NbBundle.getMessage(this.getClass(), \"IngestManager.cancellingIngest.msgDlg.text\"),\n                                        NbBundle.getMessage(this.getClass(), \"IngestManager.serviceIsDown.msgDlg.text\", serviceDisplayName),\n                                        JOptionPane.ERROR_MESSAGE);\n                            }\n                        });\n                    }\n\n                    // cancel ingest if running\n                    cancelAllIngestJobs();\n                }\n            }\n        };\n\n        // subscribe to services of interest\n        Set<String> servicesList = new HashSet<>();\n        servicesList.add(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString());\n        servicesList.add(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString());\n        this.servicesMonitor.addSubscriber(servicesList, propChangeListener);\n    }","commit_id":"818edd6212843d82800980b47f080ed4adff9a78","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Performs keyword search service availability status check.\n     */\n    private void checkKeywordSearchServerConnectionStatus() {\n        try {\n            KeywordSearchService kwsService = Lookup.getDefault().lookup(KeywordSearchService.class);\n            if (kwsService != null && kwsService.canConnectToRemoteSolrServer()) {\n                setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.UP.toString(), \"\");\n            } else {\n                setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.DOWN.toString(), \"\");\n            }\n        } catch (ServicesMonitorException ex) {\n            logger.log(Level.SEVERE, \"Exception  while checking keyword search server connection status\", ex); //NON-NLS\n        }\n    }","id":84139,"modified_method":"/**\n     * Performs keyword search service availability status check.\n     */\n    private void checkKeywordSearchServerConnectionStatus() {\n        try {\n            KeywordSearchService kwsService = Lookup.getDefault().lookup(KeywordSearchService.class);\n            if (kwsService != null && kwsService.canConnectToRemoteSolrServer()) {\n                setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.UP.toString(), \"\");\n            } else {\n                setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.DOWN.toString(), \"\");\n            }\n        } catch (Exception ex) {\n            logger.log(Level.SEVERE, \"Exception  while checking keyword search server connection status\", ex); //NON-NLS\n        }\n    }","commit_id":"818edd6212843d82800980b47f080ed4adff9a78","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Performs case database service availability status check.\n     */\n    private void checkDatabaseConnectionStatus() {\n        try {\n            if (UserPreferences.getDatabaseConnectionInfo().canConnect()) {\n                setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.UP.toString(), \"\");\n            } else {\n                setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.DOWN.toString(), \"\");\n            }\n        } catch (ServicesMonitorException ex) {\n            logger.log(Level.SEVERE, \"Exception  while checking database connection status\", ex); //NON-NLS\n        }\n    }","id":84140,"modified_method":"/**\n     * Performs case database service availability status check.\n     */\n    private void checkDatabaseConnectionStatus() {\n        try {\n            if (UserPreferences.getDatabaseConnectionInfo().canConnect()) {\n                setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.UP.toString(), \"\");\n            } else {\n                setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.DOWN.toString(), \"\");\n            }\n        } catch (Exception ex) {\n            logger.log(Level.SEVERE, \"Exception  while checking database connection status\", ex); //NON-NLS\n        }\n    }","commit_id":"818edd6212843d82800980b47f080ed4adff9a78","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Performs messaging service availability status check.\n     */\n    private void checkMessagingServerConnectionStatus() {\n        try {\n            if (UserPreferences.getMessageServiceConnectionInfo().canConnect()) {\n                setServiceStatus(Service.MESSAGING.toString(), ServiceStatus.UP.toString(), \"\");\n            } else {\n                setServiceStatus(Service.MESSAGING.toString(), ServiceStatus.DOWN.toString(), \"\");\n            }\n        } catch (ServicesMonitorException ex) {\n            logger.log(Level.SEVERE, \"Exception  while checking messaging server connection status\", ex); //NON-NLS\n        }\n    }","id":84141,"modified_method":"/**\n     * Performs messaging service availability status check.\n     */\n    private void checkMessagingServerConnectionStatus() {\n        try {\n            if (UserPreferences.getMessageServiceConnectionInfo().canConnect()) {\n                setServiceStatus(Service.MESSAGING.toString(), ServiceStatus.UP.toString(), \"\");\n            } else {\n                setServiceStatus(Service.MESSAGING.toString(), ServiceStatus.DOWN.toString(), \"\");\n            }\n        } catch (Exception ex) {\n            logger.log(Level.SEVERE, \"Exception  while checking messaging server connection status\", ex); //NON-NLS\n        }\n    }","commit_id":"818edd6212843d82800980b47f080ed4adff9a78","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void indexArtifact(BlackboardArtifact artifact) throws TskCoreException {\n        if (artifact == null)\n            return;\n        \n        // We only support artifact indexing for Autopsy versions that use\n        // the negative range for artifact ids.\n        long artifactId = artifact.getArtifactID();\n        \n        if (artifactId > 0)\n            return;\n        \n        Case currentCase = Case.getCurrentCase();\n        if (currentCase == null)\n            return;\n        \n        SleuthkitCase sleuthkitCase = currentCase.getSleuthkitCase();\n        if (sleuthkitCase == null)\n            return;\n        \n        Content dataSource;\n        AbstractFile abstractFile = sleuthkitCase.getAbstractFileById(artifact.getObjectID());\n        if (abstractFile != null)\n            dataSource = abstractFile.getDataSource();\n        else\n            dataSource = sleuthkitCase.getContentById(artifact.getObjectID());\n        \n        if (dataSource == null)\n            return;\n        \n        // Concatenate the string values of all attributes into a single \n        // \"content\" string to be indexed.\n        StringBuilder artifactContents = new StringBuilder();\n        \n        for (BlackboardAttribute attribute : artifact.getAttributes()) {\n            artifactContents.append(attribute.getAttributeTypeDisplayName());\n            artifactContents.append(\" : \");\n\n            // This is ugly since it will need to updated any time a new\n            // TSK_DATETIME_* attribute is added. A slightly less ugly \n            // alternative would be to assume that all date time attributes\n            // will have a name of the form \"TSK_DATETIME*\" and check\n            // attribute.getAttributeTypeName().startsWith(\"TSK_DATETIME*\".\n            // The major problem with that approach is that it would require\n            // a round trip to the database to get the type name string.\n            // We have also discussed modifying BlackboardAttribute.getDisplayString()\n            // to magically format datetime attributes but that is complicated by\n            // the fact that BlackboardAttribute exists in Sleuthkit data model\n            // while the utility to determine the timezone to use is in ContentUtils\n            // in the Autopsy datamodel.\n            if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_MODIFIED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_SENT.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID()) {\n\n                artifactContents.append(ContentUtils.getStringTime(attribute.getValueLong(), dataSource));\n            }\n            else\n                artifactContents.append(attribute.getDisplayString());\n            artifactContents.append(System.lineSeparator());\n        }\n        \n        if (artifactContents.length() == 0)\n            return;\n        \n        // To play by the rules of the existing text markup implementations,\n        // we need to (a) index the artifact contents in a \"chunk\" and \n        // (b) create a separate index entry for the base artifact.\n        // We distinguish artifact content from file content by applying a \n        // mask to the artifact id to make its value > 0x8000000000000000 (i.e. negative).\n\n        // First, create an index entry for the base artifact.\n        HashMap<String, String> solrFields = new HashMap<>();\n        String documentId = Long.toString(artifactId);\n\n        solrFields.put(Server.Schema.ID.toString(), documentId);\n        \n        // Set the IMAGE_ID field.\n        solrFields.put(Server.Schema.IMAGE_ID.toString(), Long.toString(dataSource.getId()));\n\n        try {\n            Ingester.getDefault().ingest(new StringStream(\"\"), solrFields, 0);\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n\n        // Next create the index entry for the document content.\n        // The content gets added to a single chunk. We may need to add chunking\n        // support later.\n        long chunkId = 1;\n\n        documentId += \"_\" + Long.toString(chunkId);\n        solrFields.replace(Server.Schema.ID.toString(), documentId);\n        \n        StringStream contentStream = new StringStream(artifactContents.toString());\n        \n        try {\n            Ingester.getDefault().ingest(contentStream, solrFields, contentStream.getSize());\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n    }","id":84142,"modified_method":"@Override\n    public void indexArtifact(BlackboardArtifact artifact) throws TskCoreException {\n        if (artifact == null)\n            return;\n        \n        // We only support artifact indexing for Autopsy versions that use\n        // the negative range for artifact ids.\n        long artifactId = artifact.getArtifactID();\n        \n        if (artifactId > 0)\n            return;\n        \n        Case currentCase;\n        try {\n            currentCase = Case.getCurrentCase();\n        } catch (IllegalStateException ignore) {\n            // thorown by Case.getCurrentCase() if currentCase is null\n            return;\n        }\n        \n        SleuthkitCase sleuthkitCase = currentCase.getSleuthkitCase();\n        if (sleuthkitCase == null)\n            return;\n        \n        Content dataSource;\n        AbstractFile abstractFile = sleuthkitCase.getAbstractFileById(artifact.getObjectID());\n        if (abstractFile != null)\n            dataSource = abstractFile.getDataSource();\n        else\n            dataSource = sleuthkitCase.getContentById(artifact.getObjectID());\n        \n        if (dataSource == null)\n            return;\n        \n        // Concatenate the string values of all attributes into a single \n        // \"content\" string to be indexed.\n        StringBuilder artifactContents = new StringBuilder();\n        \n        for (BlackboardAttribute attribute : artifact.getAttributes()) {\n            artifactContents.append(attribute.getAttributeTypeDisplayName());\n            artifactContents.append(\" : \");\n\n            // This is ugly since it will need to updated any time a new\n            // TSK_DATETIME_* attribute is added. A slightly less ugly \n            // alternative would be to assume that all date time attributes\n            // will have a name of the form \"TSK_DATETIME*\" and check\n            // attribute.getAttributeTypeName().startsWith(\"TSK_DATETIME*\".\n            // The major problem with that approach is that it would require\n            // a round trip to the database to get the type name string.\n            // We have also discussed modifying BlackboardAttribute.getDisplayString()\n            // to magically format datetime attributes but that is complicated by\n            // the fact that BlackboardAttribute exists in Sleuthkit data model\n            // while the utility to determine the timezone to use is in ContentUtils\n            // in the Autopsy datamodel.\n            if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_MODIFIED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_SENT.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID()) {\n\n                artifactContents.append(ContentUtils.getStringTime(attribute.getValueLong(), dataSource));\n            }\n            else\n                artifactContents.append(attribute.getDisplayString());\n            artifactContents.append(System.lineSeparator());\n        }\n        \n        if (artifactContents.length() == 0)\n            return;\n        \n        // To play by the rules of the existing text markup implementations,\n        // we need to (a) index the artifact contents in a \"chunk\" and \n        // (b) create a separate index entry for the base artifact.\n        // We distinguish artifact content from file content by applying a \n        // mask to the artifact id to make its value > 0x8000000000000000 (i.e. negative).\n\n        // First, create an index entry for the base artifact.\n        HashMap<String, String> solrFields = new HashMap<>();\n        String documentId = Long.toString(artifactId);\n\n        solrFields.put(Server.Schema.ID.toString(), documentId);\n        \n        // Set the IMAGE_ID field.\n        solrFields.put(Server.Schema.IMAGE_ID.toString(), Long.toString(dataSource.getId()));\n\n        try {\n            Ingester.getDefault().ingest(new StringStream(\"\"), solrFields, 0);\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n\n        // Next create the index entry for the document content.\n        // The content gets added to a single chunk. We may need to add chunking\n        // support later.\n        long chunkId = 1;\n\n        documentId += \"_\" + Long.toString(chunkId);\n        solrFields.replace(Server.Schema.ID.toString(), documentId);\n        \n        StringStream contentStream = new StringStream(artifactContents.toString());\n        \n        try {\n            Ingester.getDefault().ingest(contentStream, solrFields, contentStream.getSize());\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n    }","commit_id":"818edd6212843d82800980b47f080ed4adff9a78","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public boolean canConnectToRemoteSolrServer() {\n        try {\n            String host = UserPreferences.getIndexingServerHost();\n            String port = UserPreferences.getIndexingServerPort();\n            HttpSolrServer solrServer = new HttpSolrServer(\"http://\" + host + \":\" + port + \"/solr\"); //NON-NLS;\n            KeywordSearch.getServer().connectToSolrServer(solrServer);\n        }\n        catch (SolrServerException | IOException ex) {\n            return false;\n        }\n        \n        return true;\n    }","id":84143,"modified_method":"@Override\n    public boolean canConnectToRemoteSolrServer() {\n        try {\n            String host = UserPreferences.getIndexingServerHost();\n            String port = UserPreferences.getIndexingServerPort();\n            if (host.isEmpty() || port.isEmpty()){\n                return false;\n            }\n            HttpSolrServer solrServer = new HttpSolrServer(\"http://\" + host + \":\" + port + \"/solr\"); //NON-NLS;\n            KeywordSearch.getServer().connectToSolrServer(solrServer);\n        }\n        catch (SolrServerException | IOException ex) {\n            return false;\n        }\n        \n        return true;\n    }","commit_id":"818edd6212843d82800980b47f080ed4adff9a78","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public ProcessResult process(AbstractFile abstractFile) {\n        ThunderbirdEmailParser mbox = new ThunderbirdEmailParser();\n        boolean isMbox = false;\n\n        IngestModuleAbstractFile.ProcessResult hashDBResult = \n                services.getAbstractFileModuleResult(hashDBModuleName);\n\n        if (abstractFile.accept(getIsFileKnown) == true) {\n            return ProcessResult.OK; //file is known, stop processing it\n        } else if (hashDBResult == IngestModuleAbstractFile.ProcessResult.ERROR) {\n            return ProcessResult.ERROR;  //file has read error, stop processing it\n        }\n\n        try {\n            byte[] t = new byte[64];\n            if(abstractFile.getSize() > 64) {\n                int byteRead = abstractFile.read(t, 0, 64);\n                isMbox = mbox.isValidMimeTypeMbox(t);\n            }\n        } catch (TskException ex) {\n            Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n        }\n\n\n        if (isMbox) {\n            services.postMessage(IngestMessage.createMessage(++messageId, MessageType.INFO, this, \"Processing \" + abstractFile.getName()));\n            String mboxName = abstractFile.getName();\n            String msfName = mboxName + \".msf\";\n            Long mboxId = abstractFile.getId();\n            String mboxPath = \"\";\n            Long msfId = 0L;\n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n            try {\n                ResultSet rs = tskCase.runQuery(\"select parent_path from tsk_files where obj_id = '\" + mboxId.toString() + \"'\");\n                mboxPath = rs.getString(\"parent_path\");\n                Statement s = rs.getStatement();\n                rs.close();\n                if (s != null) {\n                    s.close();\n                }\n                rs.close();\n                rs.getStatement().close();\n\n                ResultSet resultset = tskCase.runQuery(\"select obj_id from tsk_files where parent_path = '\" + mboxPath + \"' and name = '\" + msfName + \"'\");\n                msfId = resultset.getLong(\"obj_id\");\n                Statement st = resultset.getStatement();\n                resultset.close();\n                if (st != null) {\n                    st.close();\n                }\n                resultset.close();\n                resultset.getStatement().close();\n\n            } catch (SQLException ex) {\n                logger.log(Level.WARNING, \"Error while trying to get parent path for:\" + this.getClass().getName(), ex);\n            }\n\n            try {\n                Content msfContent = tskCase.getContentById(msfId);\n                ContentUtils.writeToFile(msfContent, new File(currentCase.getTempDirectory() + File.separator + msfName));\n            } catch (IOException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (TskCoreException ex) {\n                logger.log(Level.WARNING, \"Unable to obtain msf file for mbox parsing:\" + this.getClass().getName(), ex);\n            }\n            int index = 0;\n            String replace = \"\";\n            boolean a = mboxPath.indexOf(\"/ImapMail/\") > 0;\n            boolean b = mboxPath.indexOf(\"/Mail/\") > 0;\n            if (b == true) {\n                index = mboxPath.indexOf(\"/Mail/\");\n                replace = \"/Mail\";\n            } else if (a == true) {\n                index = mboxPath.indexOf(\"/ImapMail/\");\n                replace = \"/ImapMail\";\n            } else {\n                replace = \"\";\n\n            }\n            String folderPath = mboxPath.substring(index);\n            folderPath = folderPath.replaceAll(replace, \"\");\n            folderPath = folderPath + mboxName;\n            folderPath = folderPath.replaceAll(\".sbd\", \"\");\n//            Reader reader = null;\n//            try {\n//                reader = new FileReader(currentCase.getTempDirectory() + File.separator + msfName);\n//            } catch (FileNotFoundException ex) {\n//                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n//            }\n//            MorkDocument morkDocument = new MorkDocument(reader);\n//            List<Dict> dicts = morkDocument.getDicts();\n//            for(Dict dict : dicts){\n//            String path = dict.getValue(\"81\").toString();\n//             String account = dict.getValue(\"8D\").toString();\n//                    }\n            String emailId = \"\";\n            String content = \"\";\n            String from = \"\";\n            String to = \"\";\n            String stringDate = \"\";\n            Long date = 0L;\n            String subject = \"\";\n            String cc = \"\";\n            String bcc = \"\";\n            try {\n                ReadContentInputStream contentStream = new ReadContentInputStream(abstractFile);\n                mbox.parse(contentStream);\n                HashMap<String, Map<String, String>> emailMap = new HashMap<String, Map<String, String>>();\n                emailMap = mbox.getAllEmails();\n                for (Entry<String, Map<String, String>> entry : emailMap.entrySet()) {\n                    Map<String, String> propertyMap = new HashMap<String, String>();\n                    emailId = ((entry.getKey() != null) ? entry.getKey() : \"Not Available\");\n                    propertyMap = entry.getValue();\n                    content = ((propertyMap.get(\"content\") != null) ? propertyMap.get(\"content\") : \"\");\n                    from = ((propertyMap.get(Metadata.AUTHOR) != null) ? propertyMap.get(Metadata.AUTHOR) : \"\");\n                    to = ((propertyMap.get(Metadata.MESSAGE_TO) != null) ? propertyMap.get(Metadata.MESSAGE_TO) : \"\");\n                    stringDate = ((propertyMap.get(\"date\") != null) ? propertyMap.get(\"date\") : \"\");\n                    if (!\"\".equals(stringDate)) {\n                        date = mbox.getDateCreated(stringDate);\n                    }\n                    subject = ((propertyMap.get(Metadata.SUBJECT) != null) ? propertyMap.get(Metadata.SUBJECT) : \"\");\n                    cc = ((propertyMap.get(Metadata.MESSAGE_CC) != null) ? propertyMap.get(Metadata.MESSAGE_CC) : \"\");\n                    bcc = ((propertyMap.get(Metadata.MESSAGE_BCC) != null) ? propertyMap.get(Metadata.MESSAGE_BCC) : \"\");\n\n                    Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_TO.getTypeID(), MODULE_NAME, to));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_CC.getTypeID(), MODULE_NAME, cc));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_BCC.getTypeID(), MODULE_NAME, bcc));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_FROM.getTypeID(), MODULE_NAME, from));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_PLAIN.getTypeID(), MODULE_NAME, content.replaceAll(\"\\\\<[^>]*>\", \"\")));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_HTML.getTypeID(), MODULE_NAME, content));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_MSG_ID.getTypeID(), MODULE_NAME, StringEscapeUtils.escapeHtml(emailId)));\n                    //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_MSG_REPLY_ID.getTypeID(), MODULE_NAME, \"\",));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID(), MODULE_NAME, date));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_SENT.getTypeID(), MODULE_NAME, date));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID(), MODULE_NAME, subject));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), MODULE_NAME, folderPath));\n                    BlackboardArtifact bbart;\n                    try {\n                        bbart = abstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG);\n                        bbart.addAttributes(bbattributes);\n                    } catch (TskCoreException ex) {\n                        Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n                    }\n                    services.fireModuleDataEvent(new ModuleDataEvent(MODULE_NAME, BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG));\n                }\n            } catch (FileNotFoundException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (IOException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (SAXException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (TikaException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            }\n        }\n\n        return ProcessResult.OK;\n    }","id":84144,"modified_method":"@Override\n    public ProcessResult process(AbstractFile abstractFile) {\n        ThunderbirdEmailParser mbox = new ThunderbirdEmailParser();\n        boolean isMbox = false;\n\n        IngestModuleAbstractFile.ProcessResult hashDBResult = \n                services.getAbstractFileModuleResult(hashDBModuleName);\n\n        if (abstractFile.accept(getIsFileKnown) == true) {\n            return ProcessResult.OK; //file is known, stop processing it\n        } else if (hashDBResult == IngestModuleAbstractFile.ProcessResult.ERROR) {\n            return ProcessResult.ERROR;  //file has read error, stop processing it\n        }\n        \n        if (abstractFile.isVirtual() ) {\n            return ProcessResult.OK;\n        }\n        \n        final FsContent fsContent = (FsContent) abstractFile;\n\n        try {\n            byte[] t = new byte[64];\n            if(fsContent.getSize() > 64) {\n                int byteRead = fsContent.read(t, 0, 64);\n                isMbox = mbox.isValidMimeTypeMbox(t);\n            }\n        } catch (TskException ex) {\n            logger.log(Level.WARNING, null, ex);\n        }\n\n\n        if (isMbox) {\n            services.postMessage(IngestMessage.createMessage(++messageId, MessageType.INFO, this, \"Processing \" + fsContent.getName()));\n            String mboxName = fsContent.getName();\n            String msfName = mboxName + \".msf\";\n            //Long mboxId = fsContent.getId();\n            String mboxPath = fsContent.getParentPath();\n            Long msfId = 0L;\n            currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n            try {\n                ResultSet resultset = tskCase.runQuery(\"SELECT obj_id FROM tsk_files WHERE parent_path = '\" + mboxPath + \"' and name = '\" + msfName + \"'\");\n                if (! resultset.next()) {\n                    logger.log(Level.WARNING, \"Could not find msf file in mbox dir: \" + mboxPath + \" file: \" + msfName);\n                    tskCase.closeRunQuery(resultset);\n                    return ProcessResult.OK;\n                }\n                else {\n                    msfId = resultset.getLong(1);\n                    tskCase.closeRunQuery(resultset);\n                }\n\n            } catch (SQLException ex) {\n                logger.log(Level.WARNING, \"Could not find msf file in mbox dir: \" + mboxPath + \" file: \" + msfName);\n            }\n\n            try {\n                Content msfContent = tskCase.getContentById(msfId);\n                if (msfContent != null) {\n                    ContentUtils.writeToFile(msfContent, new File(currentCase.getTempDirectory() + File.separator + msfName));\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to obtain msf file for mbox parsing:\" + msfName, ex);\n            } catch (TskCoreException ex) {\n                logger.log(Level.WARNING, \"Unable to obtain msf file for mbox parsing:\" + msfName, ex);\n            }\n            int index = 0;\n            String replace = \"\";\n            boolean a = mboxPath.indexOf(\"/ImapMail/\") > 0;\n            boolean b = mboxPath.indexOf(\"/Mail/\") > 0;\n            if (b == true) {\n                index = mboxPath.indexOf(\"/Mail/\");\n                replace = \"/Mail\";\n            } else if (a == true) {\n                index = mboxPath.indexOf(\"/ImapMail/\");\n                replace = \"/ImapMail\";\n            } else {\n                replace = \"\";\n\n            }\n            String folderPath = mboxPath.substring(index);\n            folderPath = folderPath.replaceAll(replace, \"\");\n            folderPath = folderPath + mboxName;\n            folderPath = folderPath.replaceAll(\".sbd\", \"\");\n//            Reader reader = null;\n//            try {\n//                reader = new FileReader(currentCase.getTempDirectory() + File.separator + msfName);\n//            } catch (FileNotFoundException ex) {\n//                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n//            }\n//            MorkDocument morkDocument = new MorkDocument(reader);\n//            List<Dict> dicts = morkDocument.getDicts();\n//            for(Dict dict : dicts){\n//            String path = dict.getValue(\"81\").toString();\n//             String account = dict.getValue(\"8D\").toString();\n//                    }\n            String emailId = \"\";\n            String content = \"\";\n            String from = \"\";\n            String to = \"\";\n            String stringDate = \"\";\n            Long date = 0L;\n            String subject = \"\";\n            String cc = \"\";\n            String bcc = \"\";\n            try {\n                ReadContentInputStream contentStream = new ReadContentInputStream(abstractFile);\n                mbox.parse(contentStream);\n                HashMap<String, Map<String, String>> emailMap = new HashMap<String, Map<String, String>>();\n                emailMap = mbox.getAllEmails();\n                for (Entry<String, Map<String, String>> entry : emailMap.entrySet()) {\n                    Map<String, String> propertyMap = new HashMap<String, String>();\n                    emailId = ((entry.getKey() != null) ? entry.getKey() : \"Not Available\");\n                    propertyMap = entry.getValue();\n                    content = ((propertyMap.get(\"content\") != null) ? propertyMap.get(\"content\") : \"\");\n                    from = ((propertyMap.get(Metadata.AUTHOR) != null) ? propertyMap.get(Metadata.AUTHOR) : \"\");\n                    to = ((propertyMap.get(Metadata.MESSAGE_TO) != null) ? propertyMap.get(Metadata.MESSAGE_TO) : \"\");\n                    stringDate = ((propertyMap.get(\"date\") != null) ? propertyMap.get(\"date\") : \"\");\n                    if (!\"\".equals(stringDate)) {\n                        date = mbox.getDateCreated(stringDate);\n                    }\n                    subject = ((propertyMap.get(Metadata.SUBJECT) != null) ? propertyMap.get(Metadata.SUBJECT) : \"\");\n                    cc = ((propertyMap.get(Metadata.MESSAGE_CC) != null) ? propertyMap.get(Metadata.MESSAGE_CC) : \"\");\n                    bcc = ((propertyMap.get(Metadata.MESSAGE_BCC) != null) ? propertyMap.get(Metadata.MESSAGE_BCC) : \"\");\n\n                    Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_TO.getTypeID(), MODULE_NAME, to));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_CC.getTypeID(), MODULE_NAME, cc));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_BCC.getTypeID(), MODULE_NAME, bcc));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_FROM.getTypeID(), MODULE_NAME, from));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_PLAIN.getTypeID(), MODULE_NAME, content.replaceAll(\"\\\\<[^>]*>\", \"\")));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_HTML.getTypeID(), MODULE_NAME, content));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_MSG_ID.getTypeID(), MODULE_NAME, StringEscapeUtils.escapeHtml(emailId)));\n                    //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_MSG_REPLY_ID.getTypeID(), MODULE_NAME, \"\",));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID(), MODULE_NAME, date));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_SENT.getTypeID(), MODULE_NAME, date));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID(), MODULE_NAME, subject));\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), MODULE_NAME, folderPath));\n                    BlackboardArtifact bbart;\n                    try {\n                        bbart = abstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG);\n                        bbart.addAttributes(bbattributes);\n                    } catch (TskCoreException ex) {\n                        Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n                    }\n                    services.fireModuleDataEvent(new ModuleDataEvent(MODULE_NAME, BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG));\n                }\n            } catch (FileNotFoundException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (IOException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (SAXException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            } catch (TikaException ex) {\n                Logger.getLogger(ThunderbirdMboxFileIngestModule.class.getName()).log(Level.WARNING, null, ex);\n            }\n        }\n\n        return ProcessResult.OK;\n    }","commit_id":"b534672b278724d3719e8c4a6c46abea7245ab42","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void init(IngestModuleInit initContext) {\n        logger.log(Level.INFO, \"init()\");\n        services = IngestServices.getDefault();\n\n        //module specific initialization here\n    }","id":84145,"modified_method":"@Override\n    public void init(IngestModuleInit initContext) {\n        logger.log(Level.INFO, \"init()\");\n        services = IngestServices.getDefault();\n\n        currentCase = Case.getCurrentCase();\n        //module specific initialization here\n    }","commit_id":"b534672b278724d3719e8c4a6c46abea7245ab42","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Determines the root directory of the case folder for the current case\n         * and sets it as the directory to monitor. If there is no current case,\n         * defaults to the root directory.\n         */\n        private void findRootDirectoryForCurrentCase() {\n            root = new File(File.separator);\n            String caseDir = Case.getCurrentCase().getCaseDirectory();\n            File curDir = new File(caseDir);\n            File parentDir = curDir.getParentFile();\n            while (null != parentDir) {\n                curDir = parentDir;\n                parentDir = curDir.getParentFile();\n            }\n            root = curDir;\n            logger.log(Level.INFO, \"Monitoring disk space of {0}\", curDir.getAbsolutePath()); //NON-NLS\n        }","id":84146,"modified_method":"/**\n         * Determines the root directory of the case folder for the current case\n         * and sets it as the directory to monitor.\n         */\n        private void findRootDirectoryForCurrentCase() {\n            try {\n                Case currentCase = Case.getCurrentCase();\n                findRootDirectoryForCurrentCase(currentCase);\n            } catch (IllegalStateException unused) {\n                /*\n                 * Case.getCurrentCase() throws IllegalStateException when there\n                 * is no case.\n                 */\n                root = new File(File.separator);\n                logMonitoredRootDirectory();\n            }\n        }","commit_id":"967c3d897b6a51f32eb69d898a1ff3915fe4287b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"MonitorTimerAction() {\n            findRootDirectoryForCurrentCase();\n            Case.addPropertyChangeListener((PropertyChangeEvent evt) -> {\n                String changed = evt.getPropertyName();\n                Object newValue = evt.getNewValue();\n                if (changed.equals(Case.Events.CURRENT_CASE.toString())) {\n                    if (newValue != null) {\n                        findRootDirectoryForCurrentCase();\n                    }\n\n                }\n            });\n        }","id":84147,"modified_method":"MonitorTimerAction() {\n            findRootDirectoryForCurrentCase();\n            Case.addEventSubscriber(Case.Events.CURRENT_CASE.toString(), (PropertyChangeEvent evt) -> {\n                if (evt instanceof AutopsyEvent) {\n                    AutopsyEvent event = (AutopsyEvent) evt;\n                    if (AutopsyEvent.SourceType.LOCAL == event.getSourceType() && event.getPropertyName().equals(Case.Events.CURRENT_CASE.toString())) {\n                        /*\n                         * The new value of the event will be non-null if a new\n                         * case has been opened.\n                         */\n                        if (null != evt.getNewValue()) {\n                            findRootDirectoryForCurrentCase((Case) evt.getNewValue());\n                        }\n                    }\n                }\n            });\n        }","commit_id":"967c3d897b6a51f32eb69d898a1ff3915fe4287b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void updateProperties() {\n    if (mySkipUpdate) {\n      return;\n    }\n    mySkipUpdate = true;\n\n    try {\n      if (isEditing()) {\n        cellEditor.stopCellEditing();\n      }\n\n      if (myArea == null) {\n        myComponents = Collections.emptyList();\n        myProperties = Collections.emptyList();\n        myModel.fireTableDataChanged();\n      }\n      else {\n        Property selection = getSelectionProperty();\n        myComponents = new ArrayList<RadComponent>(myArea.getSelection());\n        fillProperties();\n        myModel.fireTableDataChanged();\n\n        if (myInitialSelection != null && !myComponents.isEmpty()) {\n          selection = myInitialSelection;\n          myInitialSelection = null;\n        }\n\n        restoreSelection(selection);\n      }\n    }\n    finally {\n      mySkipUpdate = false;\n    }\n  }","id":84148,"modified_method":"private void updateProperties() {\n    if (mySkipUpdate) {\n      return;\n    }\n    mySkipUpdate = true;\n\n    try {\n      if (isEditing()) {\n        cellEditor.stopCellEditing();\n      }\n\n      if (myArea == null) {\n        myComponents = Collections.emptyList();\n        myProperties = Collections.emptyList();\n        myModel.fireTableDataChanged();\n      }\n      else {\n        Property selection = getSelectionProperty();\n        myComponents = new ArrayList<RadComponent>(myArea.getSelection());\n        fillProperties();\n        myModel.fireTableDataChanged();\n\n        if (myInitialSelection != null && !myComponents.isEmpty()) {\n          selection = myInitialSelection;\n          myInitialSelection = null;\n        }\n\n        restoreSelection(selection);\n      }\n\n      if (myPropertyTablePanel != null) {\n        myPropertyTablePanel.updateActions();\n      }\n    }\n    finally {\n      mySkipUpdate = false;\n    }\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean setValueAtRow(int row, final Object newValue) {\n    final Property property = myProperties.get(row);\n\n    boolean isNewValue;\n    try {\n      isNewValue = !Comparing.equal(getValue(property), newValue);\n    }\n    catch (Throwable e) {\n      isNewValue = true;\n    }\n\n    boolean isSetValue = true;\n\n    if (isNewValue) {\n      isSetValue = myDesigner.getToolProvider().execute(new ThrowableRunnable<Exception>() {\n        @Override\n        public void run() throws Exception {\n          for (RadComponent component : myComponents) {\n            property.setValue(component, newValue);\n          }\n        }\n      }, DesignerBundle.message(\"command.set.property.value\"), false);\n    }\n\n    if (property.needRefreshPropertyList() && isSetValue) {\n      updateProperties();\n    }\n\n    return isSetValue;\n  }","id":84149,"modified_method":"private boolean setValueAtRow(int row, final Object newValue) {\n    final Property property = myProperties.get(row);\n\n    boolean isNewValue;\n    try {\n      isNewValue = !Comparing.equal(getValue(property), newValue);\n    }\n    catch (Throwable e) {\n      isNewValue = true;\n    }\n\n    boolean isSetValue = true;\n\n    if (isNewValue) {\n      isSetValue = myDesigner.getToolProvider().execute(new ThrowableRunnable<Exception>() {\n        @Override\n        public void run() throws Exception {\n          for (RadComponent component : myComponents) {\n            property.setValue(component, newValue);\n          }\n        }\n      }, DesignerBundle.message(\"command.set.property.value\"), false);\n    }\n\n    if (isSetValue) {\n      if (property.needRefreshPropertyList()) {\n        updateProperties();\n      }\n      else if (myPropertyTablePanel != null) {\n        myPropertyTablePanel.updateActions();\n      }\n    }\n\n    return isSetValue;\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean hasFocus, int row, int column) {\n      myPropertyNameRenderer.getTableCellRendererComponent(table, value, selected, hasFocus, row, column);\n\n      column = table.convertColumnIndexToModel(column);\n      Property property = (Property)value;\n      Color background = table.getBackground();\n\n      try {\n        if (isDefault(property)) {\n          background = Gray._240;\n        }\n      }\n      catch (Throwable e) {\n        LOG.debug(e);\n      }\n\n      if (!selected) {\n        myPropertyNameRenderer.setBackground(background);\n      }\n\n      if (column == 0) {\n        SimpleTextAttributes attributes = SimpleTextAttributes.REGULAR_ATTRIBUTES;\n        if (property.isImportant()) {\n          attributes = SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES;\n        }\n        else if (property.isExpert()) {\n          attributes = SimpleTextAttributes.REGULAR_ITALIC_ATTRIBUTES;\n        }\n\n        ErrorInfo errorInfo = getErrorInfoForRow(row);\n        if (errorInfo != null) {\n          Map<HighlightSeverity, SimpleTextAttributes> cache = myRegularAttributes;\n          if (property.isImportant()) {\n            cache = myBoldAttributes;\n          }\n          else if (property.isExpert()) {\n            cache = myItalicAttributes;\n          }\n\n          HighlightSeverity severity = errorInfo.getLevel().getSeverity();\n          SimpleTextAttributes errorAttributes = cache.get(severity);\n\n          if (errorAttributes == null) {\n            TextAttributesKey attributesKey =\n              SeverityRegistrar.getInstance(myDesigner.getProject()).getHighlightInfoTypeBySeverity(severity).getAttributesKey();\n            TextAttributes textAttributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(attributesKey);\n\n            if (property.isImportant()) {\n              textAttributes = textAttributes.clone();\n              textAttributes.setFontType(textAttributes.getFontType() | Font.BOLD);\n            }\n            else if (property.isExpert()) {\n              textAttributes = textAttributes.clone();\n              textAttributes.setFontType(textAttributes.getFontType() | Font.ITALIC);\n            }\n\n            errorAttributes = SimpleTextAttributes.fromTextAttributes(textAttributes);\n            cache.put(severity, errorAttributes);\n          }\n\n          attributes = errorAttributes;\n        }\n\n        if (property.isDeprecated()) {\n          attributes = new SimpleTextAttributes(attributes.getBgColor(), attributes.getFgColor(), attributes.getWaveColor(),\n                                                attributes.getStyle() | SimpleTextAttributes.STYLE_STRIKEOUT);\n        }\n\n        myPropertyNameRenderer.append(property.getName(), attributes);\n\n        if (!getChildren(property).isEmpty()) {\n          if (property.getParent() == null) {\n            if (isExpanded(property)) {\n              myPropertyNameRenderer.setIcon(myCollapseIcon);\n            }\n            else {\n              myPropertyNameRenderer.setIcon(myExpandIcon);\n            }\n          }\n          else {\n            if (isExpanded(property)) {\n              myPropertyNameRenderer.setIcon(myIndentedCollapseIcon);\n            }\n            else {\n              myPropertyNameRenderer.setIcon(myIndentedExpandIcon);\n            }\n          }\n        }\n        else {\n          myPropertyNameRenderer.setIcon(myIndentIcons[property.getIndent()]);\n        }\n\n        if (!selected) {\n          myPropertyNameRenderer.setForeground(property.isExpert() ? Color.LIGHT_GRAY : table.getForeground());\n        }\n      }\n      else {\n        try {\n          PropertyRenderer renderer = property.getRenderer();\n          JComponent component = renderer.getComponent(getCurrentComponent(), getValue(property), selected, hasFocus);\n\n          if (!selected) {\n            component.setBackground(background);\n          }\n\n          component.setFont(table.getFont());\n\n          if (component instanceof JCheckBox) {\n            component.putClientProperty(\"JComponent.sizeVariant\", UIUtil.isUnderAquaLookAndFeel() ? \"small\" : null);\n          }\n\n          return component;\n        }\n        catch (Throwable e) {\n          LOG.debug(e);\n          myErrorRenderer.clear();\n          myErrorRenderer\n            .append(DesignerBundle.message(\"designer.properties.getting.error\", e.getMessage()), SimpleTextAttributes.ERROR_ATTRIBUTES);\n          return myErrorRenderer;\n        }\n      }\n\n      return myPropertyNameRenderer;\n    }","id":84150,"modified_method":"@Override\n    public Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean hasFocus, int row, int column) {\n      myPropertyNameRenderer.getTableCellRendererComponent(table, value, selected, hasFocus, row, column);\n\n      column = table.convertColumnIndexToModel(column);\n      Property property = (Property)value;\n      Color background = table.getBackground();\n      boolean isDefault = true;\n\n      try {\n        isDefault = isDefault(property);\n      }\n      catch (Throwable e) {\n        LOG.debug(e);\n      }\n\n      if (isDefault) {\n        background = Gray._240;\n      }\n\n      if (!selected) {\n        myPropertyNameRenderer.setBackground(background);\n      }\n\n      if (column == 0) {\n        SimpleTextAttributes attributes = SimpleTextAttributes.REGULAR_ATTRIBUTES;\n        if (property.isImportant()) {\n          attributes = SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES;\n        }\n        else if (property.isExpert()) {\n          attributes = SimpleTextAttributes.REGULAR_ITALIC_ATTRIBUTES;\n        }\n\n        ErrorInfo errorInfo = getErrorInfoForRow(row);\n        if (errorInfo != null) {\n          Map<HighlightSeverity, SimpleTextAttributes> cache = myRegularAttributes;\n          if (property.isImportant()) {\n            cache = myBoldAttributes;\n          }\n          else if (property.isExpert()) {\n            cache = myItalicAttributes;\n          }\n\n          HighlightSeverity severity = errorInfo.getLevel().getSeverity();\n          SimpleTextAttributes errorAttributes = cache.get(severity);\n\n          if (errorAttributes == null) {\n            TextAttributesKey attributesKey =\n              SeverityRegistrar.getInstance(myDesigner.getProject()).getHighlightInfoTypeBySeverity(severity).getAttributesKey();\n            TextAttributes textAttributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(attributesKey);\n\n            if (property.isImportant()) {\n              textAttributes = textAttributes.clone();\n              textAttributes.setFontType(textAttributes.getFontType() | Font.BOLD);\n            }\n            else if (property.isExpert()) {\n              textAttributes = textAttributes.clone();\n              textAttributes.setFontType(textAttributes.getFontType() | Font.ITALIC);\n            }\n\n            errorAttributes = SimpleTextAttributes.fromTextAttributes(textAttributes);\n            cache.put(severity, errorAttributes);\n          }\n\n          attributes = errorAttributes;\n        }\n\n        if (property.isDeprecated()) {\n          attributes = new SimpleTextAttributes(attributes.getBgColor(), attributes.getFgColor(), attributes.getWaveColor(),\n                                                attributes.getStyle() | SimpleTextAttributes.STYLE_STRIKEOUT);\n        }\n\n        myPropertyNameRenderer.append(property.getName(), attributes);\n\n        if (!getChildren(property).isEmpty()) {\n          if (property.getParent() == null) {\n            if (isExpanded(property)) {\n              myPropertyNameRenderer.setIcon(myCollapseIcon);\n            }\n            else {\n              myPropertyNameRenderer.setIcon(myExpandIcon);\n            }\n          }\n          else {\n            if (isExpanded(property)) {\n              myPropertyNameRenderer.setIcon(myIndentedCollapseIcon);\n            }\n            else {\n              myPropertyNameRenderer.setIcon(myIndentedExpandIcon);\n            }\n          }\n        }\n        else {\n          myPropertyNameRenderer.setIcon(myIndentIcons[property.getIndent()]);\n        }\n\n        if (!selected) {\n          if (isDefault) {\n            myPropertyNameRenderer.setForeground(property.isExpert() ? Color.LIGHT_GRAY : table.getForeground());\n          }\n          else {\n            myPropertyNameRenderer.setForeground(FileStatus.MODIFIED.getColor());\n          }\n        }\n      }\n      else {\n        try {\n          PropertyRenderer renderer = property.getRenderer();\n          JComponent component = renderer.getComponent(getCurrentComponent(), getValue(property), selected, hasFocus);\n\n          if (!selected) {\n            component.setBackground(background);\n          }\n\n          component.setFont(table.getFont());\n\n          if (component instanceof JCheckBox) {\n            component.putClientProperty(\"JComponent.sizeVariant\", UIUtil.isUnderAquaLookAndFeel() ? \"small\" : null);\n          }\n\n          return component;\n        }\n        catch (Throwable e) {\n          LOG.debug(e);\n          myErrorRenderer.clear();\n          myErrorRenderer\n            .append(DesignerBundle.message(\"designer.properties.getting.error\", e.getMessage()), SimpleTextAttributes.ERROR_ATTRIBUTES);\n          return myErrorRenderer;\n        }\n      }\n\n      return myPropertyNameRenderer;\n    }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void valueChanged(ListSelectionEvent e) {\n    for (AnAction action : myActions) {\n      if (action instanceof IPropertyTableAction) {\n        ((IPropertyTableAction)action).update();\n      }\n    }\n  }","id":84151,"modified_method":"@Override\n  public void valueChanged(ListSelectionEvent e) {\n    updateActions();\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PropertyTablePanel() {\n    setLayout(new GridBagLayout());\n    setBorder(IdeBorderFactory.createBorder(SideBorder.TOP));\n\n    add(new JLabel(DesignerBundle.message(\"designer.properties.title\")),\n        new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(2, 5, 2, 0), 0, 0));\n\n    ActionManager actionManager = ActionManager.getInstance();\n    DefaultActionGroup actionGroup = new DefaultActionGroup();\n\n    ShowJavadoc showJavadoc = new ShowJavadoc(myPropertyTable);\n    showJavadoc.registerCustomShortcutSet(actionManager.getAction(IdeActions.ACTION_QUICK_JAVADOC).getShortcutSet(), myPropertyTable);\n    actionGroup.add(showJavadoc);\n\n    actionGroup.addSeparator();\n\n    RestoreDefault restoreDefault = new RestoreDefault(myPropertyTable);\n    restoreDefault.registerCustomShortcutSet(actionManager.getAction(IdeActions.ACTION_DELETE).getShortcutSet(), myPropertyTable);\n    actionGroup.add(restoreDefault);\n\n    actionGroup.add(new ShowExpert(myPropertyTable));\n\n    myActions = actionGroup.getChildren(null);\n    for (int i = 0; i < myActions.length; i++) {\n      AnAction action = myActions[i];\n      if (!(action instanceof Separator)) {\n        add(new ActionButton(action, action.getTemplatePresentation(), ActionPlaces.UNKNOWN, ActionToolbar.DEFAULT_MINIMUM_BUTTON_SIZE),\n            new GridBagConstraints(i + 1, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,\n                                   new Insets(2, 0, 2, i == myActions.length - 1 ? 2 : 0), 0, 0));\n      }\n    }\n\n    actionGroup.add(new ShowColumns(myPropertyTable));\n\n    PopupHandler.installPopupHandler(myPropertyTable, actionGroup,\n                                     ActionPlaces.GUI_DESIGNER_PROPERTY_INSPECTOR_POPUP,\n                                     actionManager);\n\n    myPropertyTable.getSelectionModel().addListSelectionListener(this);\n    valueChanged(null);\n\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myPropertyTable);\n    scrollPane.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP));\n    myPropertyTable.initQuickFixManager(scrollPane.getViewport());\n    add(scrollPane, new GridBagConstraints(0, 1, myActions.length + 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(0, 0, 0, 0), 0, 0));\n  }","id":84152,"modified_method":"public PropertyTablePanel() {\n    setLayout(new GridBagLayout());\n    setBorder(IdeBorderFactory.createBorder(SideBorder.TOP));\n\n    add(new JLabel(DesignerBundle.message(\"designer.properties.title\")),\n        new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(2, 5, 2, 0), 0, 0));\n\n    ActionManager actionManager = ActionManager.getInstance();\n    DefaultActionGroup actionGroup = new DefaultActionGroup();\n\n    ShowJavadoc showJavadoc = new ShowJavadoc(myPropertyTable);\n    showJavadoc.registerCustomShortcutSet(actionManager.getAction(IdeActions.ACTION_QUICK_JAVADOC).getShortcutSet(), myPropertyTable);\n    actionGroup.add(showJavadoc);\n\n    actionGroup.addSeparator();\n\n    RestoreDefault restoreDefault = new RestoreDefault(myPropertyTable);\n    restoreDefault.registerCustomShortcutSet(actionManager.getAction(IdeActions.ACTION_DELETE).getShortcutSet(), myPropertyTable);\n    actionGroup.add(restoreDefault);\n\n    actionGroup.add(new ShowExpert(myPropertyTable));\n\n    myActions = actionGroup.getChildren(null);\n    for (int i = 0; i < myActions.length; i++) {\n      AnAction action = myActions[i];\n      if (!(action instanceof Separator)) {\n        add(new ActionButton(action, action.getTemplatePresentation(), ActionPlaces.UNKNOWN, ActionToolbar.DEFAULT_MINIMUM_BUTTON_SIZE),\n            new GridBagConstraints(i + 1, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,\n                                   new Insets(2, 0, 2, i == myActions.length - 1 ? 2 : 0), 0, 0));\n      }\n    }\n\n    actionGroup.add(new ShowColumns(myPropertyTable));\n\n    PopupHandler.installPopupHandler(myPropertyTable, actionGroup,\n                                     ActionPlaces.GUI_DESIGNER_PROPERTY_INSPECTOR_POPUP,\n                                     actionManager);\n\n    myPropertyTable.getSelectionModel().addListSelectionListener(this);\n    valueChanged(null);\n\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myPropertyTable);\n    scrollPane.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP));\n    myPropertyTable.initQuickFixManager(scrollPane.getViewport());\n    add(scrollPane, new GridBagConstraints(0, 1, myActions.length + 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(0, 0, 0, 0), 0, 0));\n\n    myPropertyTable.setPropertyTablePanel(this);\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Object getValue() throws Exception {\n    String value = getComboText().getText();\n    return value == StringsComboEditor.UNSET || StringUtil.isEmpty(value) ? null : value;\n  }","id":84153,"modified_method":"@Override\n  public Object getValue() throws Exception {\n    JTextField text = getComboText();\n    if (text == null) {\n      return myBooleanResourceValue == null ? Boolean.toString(myCheckBox.isSelected()) : myBooleanResourceValue;\n    }\n    String value = text.getText();\n    return value == StringsComboEditor.UNSET || StringUtil.isEmpty(value) ? null : value;\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JTextField getComboText() {\n    JComponent component = myEditor.getChildComponent();\n    if (component instanceof JTextField) {\n      return (JTextField)component;\n    }\n    JComboBox combo = (JComboBox)component;\n    return (JTextField)combo.getEditor().getEditorComponent();\n  }","id":84154,"modified_method":"private JTextField getComboText() {\n    JComponent component = myEditor.getChildComponent();\n    if (component instanceof JTextField) {\n      return (JTextField)component;\n    }\n    if (component instanceof JComboBox) {\n      JComboBox combo = (JComboBox)component;\n      return (JTextField)combo.getEditor().getEditorComponent();\n    }\n    return null;\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void showDialog() {\n    ModuleProvider moduleProvider = myRootComponent.getClientProperty(ModelParser.MODULE_KEY);\n    ResourceDialog dialog = new ResourceDialog(moduleProvider.getModule(), myTypes);\n    dialog.show();\n\n    if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n      setValue(dialog.getResourceName());\n    }\n  }","id":84155,"modified_method":"protected void showDialog() {\n    ModuleProvider moduleProvider = myRootComponent.getClientProperty(ModelParser.MODULE_KEY);\n    ResourceDialog dialog = new ResourceDialog(moduleProvider.getModule(), myTypes);\n    dialog.show();\n\n    if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n      setValue(dialog.getResourceName());\n    }\n    else if (myBooleanResourceValue != null) {\n      fireEditingCancelled();\n    }\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent getPreferredFocusedComponent() {\n    return getComboText();\n  }","id":84156,"modified_method":"@Override\n  public JComponent getPreferredFocusedComponent() {\n    JTextField text = getComboText();\n    return text == null ? myCheckBox : text;\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ResourceEditor(ResourceType[] types, Set<AttributeFormat> formats, String[] values) {\n    myTypes = types;\n\n    if (formats.contains(AttributeFormat.Enum) || formats.contains(AttributeFormat.Boolean)) {\n      ComboboxWithBrowseButton editor = new ComboboxWithBrowseButton() {\n        @Override\n        public Dimension getPreferredSize() {\n          return getComponentPreferredSize();\n        }\n      };\n\n      final JComboBox comboBox = editor.getComboBox();\n      DefaultComboBoxModel model;\n      if (formats.contains(AttributeFormat.Boolean)) {\n        model = new DefaultComboBoxModel(new String[]{StringsComboEditor.UNSET, \"true\", \"false\"});\n      }\n      else {\n        model = new DefaultComboBoxModel(values);\n        model.insertElementAt(StringsComboEditor.UNSET, 0);\n      }\n      comboBox.setModel(model);\n      comboBox.setEditable(true);\n      ComboEditor.addEditorSupport(this, comboBox);\n      comboBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          if (comboBox.getSelectedItem() == StringsComboEditor.UNSET) {\n            comboBox.setSelectedItem(null);\n          }\n          fireValueCommitted(true, true);\n        }\n      });\n      myEditor = editor;\n      comboBox.setSelectedIndex(0);\n    }\n    else {\n      myEditor = new TextFieldWithBrowseButton() {\n        @Override\n        public Dimension getPreferredSize() {\n          return getComponentPreferredSize();\n        }\n      };\n      myEditor.registerKeyboardAction(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n        }\n      }, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n      JTextField textField = getComboText();\n      textField.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          fireValueCommitted(true, true);\n        }\n      });\n      textField.getDocument().addDocumentListener(\n        new DocumentAdapter() {\n          protected void textChanged(final DocumentEvent e) {\n            preferredSizeChanged();\n          }\n        }\n      );\n    }\n\n    myEditor.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        showDialog();\n      }\n    });\n    myEditor.addFocusListener(new FocusAdapter() {\n      @Override\n      public void focusGained(FocusEvent e) {\n        myEditor.getChildComponent().requestFocus();\n      }\n    });\n  }","id":84157,"modified_method":"public ResourceEditor(ResourceType[] types, Set<AttributeFormat> formats, String[] values) {\n    myTypes = types;\n\n    if (formats.contains(AttributeFormat.Boolean)) {\n      myCheckBox = new JCheckBox();\n      myEditor = new ComponentWithBrowseButton<JCheckBox>(myCheckBox, null) {\n        @Override\n        public Dimension getPreferredSize() {\n          return getComponentPreferredSize();\n        }\n      };\n      myCheckBox.addItemListener(new ItemListener() {\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          if (!myIgnoreCheckBoxValue) {\n            myBooleanResourceValue = null;\n            fireValueCommitted(true, true);\n          }\n        }\n      });\n    }\n    else if (formats.contains(AttributeFormat.Enum)) {\n      ComboboxWithBrowseButton editor = new ComboboxWithBrowseButton() {\n        @Override\n        public Dimension getPreferredSize() {\n          return getComponentPreferredSize();\n        }\n      };\n\n      final JComboBox comboBox = editor.getComboBox();\n      DefaultComboBoxModel model;\n      if (formats.contains(AttributeFormat.Boolean)) {\n        model = new DefaultComboBoxModel(new String[]{StringsComboEditor.UNSET, \"true\", \"false\"});\n      }\n      else {\n        model = new DefaultComboBoxModel(values);\n        model.insertElementAt(StringsComboEditor.UNSET, 0);\n      }\n      comboBox.setModel(model);\n      comboBox.setEditable(true);\n      ComboEditor.addEditorSupport(this, comboBox);\n      comboBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          if (comboBox.getSelectedItem() == StringsComboEditor.UNSET) {\n            comboBox.setSelectedItem(null);\n          }\n          fireValueCommitted(true, true);\n        }\n      });\n      myEditor = editor;\n      comboBox.setSelectedIndex(0);\n    }\n    else {\n      myEditor = new TextFieldWithBrowseButton() {\n        @Override\n        public Dimension getPreferredSize() {\n          return getComponentPreferredSize();\n        }\n      };\n      myEditor.registerKeyboardAction(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n        }\n      }, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n      JTextField textField = getComboText();\n      textField.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          fireValueCommitted(true, true);\n        }\n      });\n      textField.getDocument().addDocumentListener(\n        new DocumentAdapter() {\n          protected void textChanged(final DocumentEvent e) {\n            preferredSizeChanged();\n          }\n        }\n      );\n    }\n\n    myEditor.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        showDialog();\n      }\n    });\n    myEditor.addFocusListener(new FocusAdapter() {\n      @Override\n      public void focusGained(FocusEvent e) {\n        myEditor.getChildComponent().requestFocus();\n      }\n    });\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void setValue(String value) {\n    getComboText().setText(value);\n    fireValueCommitted(true, true);\n  }","id":84158,"modified_method":"protected final void setValue(String value) {\n    JTextField text = getComboText();\n    if (text == null) {\n      myBooleanResourceValue = value;\n      fireValueCommitted(false, true);\n    }\n    else {\n      text.setText(value);\n      fireValueCommitted(true, true);\n    }\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public JComponent getComponent(@NotNull RadComponent rootComponent,\n                                 @Nullable RadComponent component,\n                                 Object value,\n                                 @Nullable InplaceContext inplaceContext) {\n    myRootComponent = rootComponent;\n    JTextField text = getComboText();\n    text.setText((String)value);\n    if (inplaceContext != null) {\n      text.setColumns(0);\n\n      if (inplaceContext.isStartChar()) {\n        text.setText(inplaceContext.getText(text.getText()));\n      }\n    }\n    return myEditor;\n  }","id":84159,"modified_method":"@NotNull\n  @Override\n  public JComponent getComponent(@NotNull RadComponent rootComponent,\n                                 @Nullable RadComponent component,\n                                 Object object,\n                                 @Nullable InplaceContext inplaceContext) {\n    myRootComponent = rootComponent;\n    String value = (String)object;\n    JTextField text = getComboText();\n\n    if (text == null) {\n      if (StringUtil.isEmpty(value) || value.equals(\"true\") || value.equals(\"false\")) {\n        myBooleanResourceValue = null;\n      }\n      else {\n        myBooleanResourceValue = value;\n      }\n\n      try {\n        myIgnoreCheckBoxValue = true;\n        myCheckBox.setSelected(Boolean.parseBoolean(value));\n      }\n      finally {\n        myIgnoreCheckBoxValue = false;\n      }\n\n      if (inplaceContext == null) {\n        myEditor.setBorder(null);\n        myCheckBox.setText(null);\n      }\n      else {\n        myEditor.setBorder(myCheckBoxBorder);\n        myCheckBox.setText(myBooleanResourceValue);\n      }\n    }\n    else {\n      text.setText(value);\n      if (inplaceContext != null) {\n        text.setColumns(0);\n        if (inplaceContext.isStartChar()) {\n          text.setText(inplaceContext.getText(text.getText()));\n        }\n      }\n    }\n    return myEditor;\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public JComponent getComponent(@Nullable RadComponent component, @Nullable Object object, boolean selected, boolean hasFocus) {\n    String value = (String)object;\n\n    if (myBooleanRenderer != null && (StringUtil.isEmpty(value) || \"false\".equals(value) || \"true\".equals(value))) {\n      myBooleanRenderer.setText(value);\n      return myBooleanRenderer.getComponent(component, \"true\".equals(value), selected, hasFocus);\n    }\n\n    myColoredComponent.clear();\n    PropertyTable.updateRenderer(myColoredComponent, selected);\n    formatValue(value);\n\n    return myColoredComponent;\n  }","id":84160,"modified_method":"@NotNull\n  @Override\n  public JComponent getComponent(@Nullable RadComponent component, @Nullable Object object, boolean selected, boolean hasFocus) {\n    String value = (String)object;\n\n    if (myBooleanRenderer != null && (StringUtil.isEmpty(value) || \"false\".equals(value) || \"true\".equals(value))) {\n      return myBooleanRenderer.getComponent(component, \"true\".equals(value), selected, hasFocus);\n    }\n\n    myColoredComponent.clear();\n    PropertyTable.updateRenderer(myColoredComponent, selected);\n    formatValue(value);\n\n    return myColoredComponent;\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    myTable.restoreDefaultValue();\n  }","id":84161,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    myTable.restoreDefaultValue();\n    setEnabled(myTable, getTemplatePresentation());\n  }","commit_id":"ffd79cd94d317279d7ed23d1e0bcf37d9460c96f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BehaviorDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0a, fqName)) {\n      case 15:\n        return new BuildMps_ModuleDependencyOnModule_BehaviorDescriptor();\n      case 19:\n        return new BuildMps_ModuleJavaSource_BehaviorDescriptor();\n      case 22:\n        return new BuildMps_Solution_BehaviorDescriptor();\n      case 10:\n        return new BuildMps_Language_BehaviorDescriptor();\n      case 17:\n        return new BuildMps_ModuleDependencyUseLanguage_BehaviorDescriptor();\n      case 14:\n        return new BuildMps_ModuleDependencyOnJavaModule_BehaviorDescriptor();\n      case 21:\n        return new BuildMps_ModuleSolutionRuntime_BehaviorDescriptor();\n      case 16:\n        return new BuildMps_ModuleDependencyOnModuleById_BehaviorDescriptor();\n      case 11:\n        return new BuildMps_ModuleDependencyExtendLanguage_BehaviorDescriptor();\n      case 18:\n        return new BuildMps_ModuleJarRuntime_BehaviorDescriptor();\n      case 20:\n        return new BuildMps_ModuleModelRoot_BehaviorDescriptor();\n      case 12:\n        return new BuildMps_ModuleDependencyJar_BehaviorDescriptor();\n      case 4:\n        return new BuildMps_DevKit_BehaviorDescriptor();\n      case 7:\n        return new BuildMps_DevKitRef_BehaviorDescriptor();\n      case 5:\n        return new BuildMps_DevKitExportLanguage_BehaviorDescriptor();\n      case 6:\n        return new BuildMps_DevKitExportSolution_BehaviorDescriptor();\n      case 13:\n        return new BuildMps_ModuleDependencyOnDevKit_BehaviorDescriptor();\n      case 9:\n        return new BuildMps_Group_BehaviorDescriptor();\n      case 3:\n        return new BuildMpsLayout_ModuleSources_BehaviorDescriptor();\n      case 8:\n        return new BuildMps_ExtractedModuleDependency_BehaviorDescriptor();\n      case 2:\n        return new BuildMpsLayout_ModuleOutput_BehaviorDescriptor();\n      case 0:\n        return new BuildMpsLayout_FolderWithSources_BehaviorDescriptor();\n      case 1:\n        return new BuildMpsLayout_ModuleJars_BehaviorDescriptor();\n      default:\n        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);\n    }\n  }","id":84162,"modified_method":"public BehaviorDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0a, fqName)) {\n      case 16:\n        return new BuildMps_ModuleDependencyOnModule_BehaviorDescriptor();\n      case 19:\n        return new BuildMps_ModuleJavaSource_BehaviorDescriptor();\n      case 22:\n        return new BuildMps_Solution_BehaviorDescriptor();\n      case 11:\n        return new BuildMps_Language_BehaviorDescriptor();\n      case 17:\n        return new BuildMps_ModuleDependencyUseLanguage_BehaviorDescriptor();\n      case 15:\n        return new BuildMps_ModuleDependencyOnJavaModule_BehaviorDescriptor();\n      case 21:\n        return new BuildMps_ModuleSolutionRuntime_BehaviorDescriptor();\n      case 12:\n        return new BuildMps_ModuleDependencyExtendLanguage_BehaviorDescriptor();\n      case 18:\n        return new BuildMps_ModuleJarRuntime_BehaviorDescriptor();\n      case 20:\n        return new BuildMps_ModuleModelRoot_BehaviorDescriptor();\n      case 13:\n        return new BuildMps_ModuleDependencyJar_BehaviorDescriptor();\n      case 5:\n        return new BuildMps_DevKit_BehaviorDescriptor();\n      case 8:\n        return new BuildMps_DevKitRef_BehaviorDescriptor();\n      case 6:\n        return new BuildMps_DevKitExportLanguage_BehaviorDescriptor();\n      case 7:\n        return new BuildMps_DevKitExportSolution_BehaviorDescriptor();\n      case 14:\n        return new BuildMps_ModuleDependencyOnDevKit_BehaviorDescriptor();\n      case 10:\n        return new BuildMps_Group_BehaviorDescriptor();\n      case 4:\n        return new BuildMpsLayout_ModuleSources_BehaviorDescriptor();\n      case 9:\n        return new BuildMps_ExtractedModuleDependency_BehaviorDescriptor();\n      case 3:\n        return new BuildMpsLayout_ModuleOutput_BehaviorDescriptor();\n      case 1:\n        return new BuildMpsLayout_FolderWithSources_BehaviorDescriptor();\n      case 2:\n        return new BuildMpsLayout_ModuleJars_BehaviorDescriptor();\n      case 0:\n        return new BuildMPSPlugin_BehaviorDescriptor();\n      default:\n        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void checkDevkit() {\n    DevkitDescriptor descriptor = ((DevkitDescriptor) myModuleDescriptor);\n    SNode devkit = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n\n    for (ModuleReference module : descriptor.getExtendedDevkits()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find devkit in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"extends\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SLinkOperations.getTarget(it, \"devkit\", false) == resolved;\n        }\n      }))) {\n\n        report(\"extends devkit dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n    }\n    for (ModuleReference module : descriptor.getExportedLanguages()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find exported languages in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false) == resolved;\n        }\n      }))) {\n\n        report(\"export language dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n    }\n    for (ModuleReference module : descriptor.getExportedSolutions()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find exported solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false) == resolved;\n        }\n      }))) {\n\n        report(\"export solution dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n    }\n  }","id":84163,"modified_method":"private void checkDevkit() {\n    DevkitDescriptor descriptor = ((DevkitDescriptor) myModuleDescriptor);\n    SNode devkit = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n\n    for (ModuleReference module : descriptor.getExtendedDevkits()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find devkit in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"extends\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return asOriginal(SLinkOperations.getTarget(it, \"devkit\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"extends devkit dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n    }\n    for (ModuleReference module : descriptor.getExportedLanguages()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find exported languages in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"export language dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n\n    }\n    for (ModuleReference module : descriptor.getExportedSolutions()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find exported solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"exports\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"export solution dependency should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectDependencies(boolean checkOnly) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();\n    Set<String> extractedModules = new HashSet<String>();\n    for (SNode dep : SLinkOperations.getTargets(module, \"dependencies\", true)) {\n      boolean extracted = false;\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")) {\n        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n        extracted = true;\n      }\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\")) {\n        SNode onModule = SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\");\n        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) ?\n          usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) :\n          false\n        );\n        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"), SPropertyOperations.getBoolean(onModule, \"reexport\") || existing);\n        if (extracted) {\n          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"));\n        }\n      }\n    }\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    for (Dependency dependency : dependencies) {\n      ModuleReference moduleRef = dependency.getModuleRef();\n      if (moduleRef.getModuleFqName().contains(\"#\")) {\n        report(\"module cannot depend on generator: `\" + moduleRef.getModuleFqName() + \"'\", myOriginalModule);\n      }\n    }\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved = SNodeOperations.as(visible.resolve(moduleRef.getModuleFqName(), moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n      boolean found = false;\n      if (usedModuleIds.containsKey(moduleRef.getModuleId().toString())) {\n        found = true;\n        boolean foundReexport = usedModuleIds.get(moduleRef.getModuleId().toString());\n        if (foundReexport != reexport && extractedModules.contains(moduleRef.getModuleId().toString())) {\n          report(\"wrong reexport status for dependency in build script for: \" + moduleRef.getModuleId().toString(), myOriginalModule);\n        }\n      }\n\n      if (reexport && !(extractedModules.contains(moduleRef.getModuleId().toString()))) {\n        report(\"reexport dependency should be extracted into build script: \" + dep.getModuleRef().toString(), myOriginalModule);\n      }\n      if (!(found)) {\n        if (checkOnly) {\n          continue;\n        }\n\n        if (resolved != null) {\n          SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n          SLinkOperations.setTarget(res, \"module\", resolved, false);\n          SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n        } else {\n          SNode res = SModelOperations.createNewNode(SNodeOperations.getModel(myModule), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModuleById\", null);\n          SPropertyOperations.set(res, \"targetId\", moduleRef.getModuleId().toString());\n          SPropertyOperations.set(res, \"targetName\", moduleRef.getModuleFqName());\n          SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n        }\n      }\n    }\n  }","id":84164,"modified_method":"private void collectDependencies(boolean checkOnly) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();\n    Set<String> extractedModules = new HashSet<String>();\n    for (SNode dep : SLinkOperations.getTargets(module, \"dependencies\", true)) {\n      boolean extracted = false;\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")) {\n        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n        extracted = true;\n      }\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\")) {\n        SNode onModule = SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\");\n        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) ?\n          usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) :\n          false\n        );\n        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"), SPropertyOperations.getBoolean(onModule, \"reexport\") || existing);\n        if (extracted) {\n          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"));\n        }\n      }\n    }\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    for (Dependency dependency : dependencies) {\n      ModuleReference moduleRef = dependency.getModuleRef();\n      if (moduleRef.getModuleFqName().contains(\"#\")) {\n        report(\"module cannot depend on generator: `\" + moduleRef.getModuleFqName() + \"'\", myOriginalModule);\n      }\n    }\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    // resolve all dependencies \n    Map<SNode, Boolean> depsToReexport = new LinkedHashMap<SNode, Boolean>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          if (genContext != null) {\n            genContext.showInformationMessage(myOriginalModule, \"unsatisfied dependency: \" + dep.getModuleRef().toString());\n          }\n          // TODO FIXME \n          // <node> \n          continue;\n        }\n      }\n\n      Boolean alreadyReexport = depsToReexport.get(resolved);\n      if (alreadyReexport != null && alreadyReexport.booleanValue()) {\n        continue;\n      }\n      depsToReexport.put(resolved, reexport);\n    }\n\n    // check & create \n    for (Map.Entry<SNode, Boolean> entry : depsToReexport.entrySet()) {\n      SNode resolved = entry.getKey();\n      boolean reexport = entry.getValue().booleanValue();\n\n      boolean found = false;\n      if (usedModuleIds.containsKey(SPropertyOperations.getString(resolved, \"uuid\"))) {\n        found = true;\n        boolean foundReexport = usedModuleIds.get(SPropertyOperations.getString(resolved, \"uuid\"));\n        if (foundReexport != reexport && extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\"))) {\n          report(\"wrong reexport status for dependency in build script for: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n        }\n      }\n\n      if (reexport && !(extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\")))) {\n        report(\"reexport dependency should be extracted into build script: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n      }\n      if (!(found)) {\n        if (checkOnly) {\n          continue;\n        }\n\n        SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n        SLinkOperations.setTarget(res, \"module\", resolved, false);\n        SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n      }\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void importDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      if (!(reexport)) {\n        continue;\n      }\n\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved = SNodeOperations.as(visible.resolve(moduleRef.getModuleFqName(), moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n      if (resolved != null) {\n        SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n        SLinkOperations.setTarget(res, \"module\", resolved, false);\n        SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n        SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SLinkOperations.setTarget(extr, \"dependency\", res, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n      } else {\n        SNode res = SModelOperations.createNewNode(SNodeOperations.getModel(myModule), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModuleById\", null);\n        SPropertyOperations.set(res, \"targetId\", moduleRef.getModuleId().toString());\n        SPropertyOperations.set(res, \"targetName\", moduleRef.getModuleFqName());\n        SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n        SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SLinkOperations.setTarget(extr, \"dependency\", res, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n      }\n    }\n  }","id":84165,"modified_method":"private void importDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    Set<SNode> seen = new HashSet<SNode>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      if (!(reexport)) {\n        continue;\n      }\n\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          if (genContext != null) {\n            genContext.showInformationMessage(myOriginalModule, \"unsatisfied dependency: \" + dep.getModuleRef().toString());\n          }\n          // TODO FIXME \n          // <node> \n          continue;\n        }\n      }\n\n      if (!(seen.add(resolved))) {\n        continue;\n      }\n\n      SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n      SLinkOperations.setTarget(res, \"module\", resolved, false);\n      SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n      SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n      SLinkOperations.setTarget(extr, \"dependency\", res, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void checkRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false) == resolved;\n        }\n      }))) {\n\n        report(\"runtime solution should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        final String localPath = BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p);\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\") && eq_a6ewnz_a0a0a0a0a0a0b0g0c0n(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)), localPath);\n          }\n        }))) {\n          report(\"runtime jar should be extracted into build script: \" + path, myOriginalModule);\n        }\n\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":84166,"modified_method":"private void checkRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"runtime solution should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        final String localPath = BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p);\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\") && eq_a6ewnz_a0a0a0a0a0a0b0g0c0o(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)), localPath);\n          }\n        }))) {\n          report(\"runtime jar should be extracted into build script: \" + path, myOriginalModule);\n        }\n\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void checkLanguageDeps() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference lang : descriptor.getExtendedLanguages()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find extended language in dependencies: \" + lang.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          SNode em = SNodeOperations.as(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          return em != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false) == resolved;\n        }\n      }))) {\n\n        report(\"extends language dependency should be extracted into build script: \" + lang.toString(), myOriginalModule);\n      }\n    }\n    String langName = myModuleDescriptor.getModuleReference().getModuleFqName();\n    for (GeneratorDescriptor generator : descriptor.getGenerators()) {\n      String generatorName = generator.getGeneratorUID();\n      if (generatorName != null && !(generatorName.startsWith(langName + \"#\"))) {\n        report(\"wrong generator name `\" + generatorName + \"', should start with `\" + langName + \"#'\", myOriginalModule);\n      }\n    }\n  }","id":84167,"modified_method":"private void checkLanguageDeps() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference lang : descriptor.getExtendedLanguages()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find extended language in dependencies: \" + lang.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          SNode em = SNodeOperations.as(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          return em != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"extends language dependency should be extracted into build script: \" + lang.toString(), myOriginalModule);\n      }\n    }\n    String langName = myModuleDescriptor.getModuleReference().getModuleFqName();\n    for (GeneratorDescriptor generator : descriptor.getGenerators()) {\n      String generatorName = generator.getGeneratorUID();\n      if (generatorName != null && !(generatorName.startsWith(langName + \"#\"))) {\n        report(\"wrong generator name `\" + generatorName + \"', should start with `\" + langName + \"#'\", myOriginalModule);\n      }\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a6ewnz_a0a0a0a0a0a0b0g0c0n(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":84168,"modified_method":"private static boolean eq_a6ewnz_a0a0a0a0a0a0b0g0c0o(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_3717132724153192091(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode lang : Sequence.fromIterable(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._2()).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.getContainingRoot(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._0()) == SNodeOperations.getContainingRoot(_context.getNode());\n      }\n    }).sort(new ISelector<SNode, Comparable<?>>() {\n      public Comparable<?> select(SNode it) {\n        return SPropertyOperations.getString(it, \"name\");\n      }\n    }, true)) {\n      for (SNode runtime : SLinkOperations.getTargets(lang, \"runtime\", true)) {\n        if (!(SNodeOperations.isInstanceOf(runtime, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"))) {\n          continue;\n        }\n        ListSequence.fromList(result).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.cast(runtime, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)));\n      }\n    }\n    return result;\n  }","id":84169,"modified_method":"public static Iterable sourceNodesQuery_3717132724153192091(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode lang : Sequence.fromIterable(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._2()).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.getContainingRoot(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._0()) == SNodeOperations.getContainingRoot(it);\n      }\n    }).sort(new ISelector<SNode, Comparable<?>>() {\n      public Comparable<?> select(SNode it) {\n        return SPropertyOperations.getString(it, \"name\");\n      }\n    }, true)) {\n      for (SNode runtime : SLinkOperations.getTargets(lang, \"runtime\", true)) {\n        if (!(SNodeOperations.isInstanceOf(runtime, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"))) {\n          continue;\n        }\n        ListSequence.fromList(result).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.cast(runtime, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)));\n      }\n    }\n    return result;\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_4267986820121149131(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode targetModule = (SNode) _context.getNode().getReferent(\"targetModule\");\n    return _context.getOutputNodeByInputNodeAndMappingLabel(targetModule, \"javaModule\");\n  }","id":84170,"modified_method":"public static Object referenceMacro_GetReferent_4267986820121149131(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode targetModule = (SNode) _context.getNode().getReferent(\"targetModule\");\n    SNode result = _context.getOutputNodeByInputNodeAndMappingLabel(targetModule, \"javaModule\");\n    if (result == null) {\n      _context.showErrorMessage(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._0(), \"cannot get java output for \" + SPropertyOperations.getString(targetModule, \"name\"));\n    }\n    return result;\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_4267986820121149056(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode mod : Sequence.fromIterable(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._1()).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SPropertyOperations.getBoolean(it, \"doNotCompile\") == false && SNodeOperations.getContainingRoot(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._0()) == SNodeOperations.getContainingRoot(_context.getNode());\n      }\n    }).sort(new ISelector<SNode, Comparable<?>>() {\n      public Comparable<?> select(SNode it) {\n        return SPropertyOperations.getString(it, \"name\");\n      }\n    }, true)) {\n      SNode loopnode = SModelOperations.createNewNode(_context.getOutputModel(), \"jetbrains.mps.lang.core.structure.BaseConcept\", null);\n      loopnode.setReferent(\"targetModule\", mod, false);\n      ListSequence.fromList(result).addElement(loopnode);\n    }\n    return result;\n  }","id":84171,"modified_method":"public static Iterable sourceNodesQuery_4267986820121149056(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode mod : Sequence.fromIterable(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._1()).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SPropertyOperations.getBoolean(it, \"doNotCompile\") == false && SNodeOperations.getContainingRoot(((Tuples._3<SNode, Iterable<SNode>, Iterable<SNode>>) _context.getVariable(\"var:mdeps\"))._0()) == SNodeOperations.getContainingRoot(it);\n      }\n    }).sort(new ISelector<SNode, Comparable<?>>() {\n      public Comparable<?> select(SNode it) {\n        return SPropertyOperations.getString(it, \"name\");\n      }\n    }, true)) {\n      SNode loopnode = SModelOperations.createNewNode(_context.getOutputModel(), \"jetbrains.mps.lang.core.structure.BaseConcept\", null);\n      loopnode.setReferent(\"targetModule\", mod, false);\n      ListSequence.fromList(result).addElement(loopnode);\n    }\n    return result;\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_FolderWithSources\", \"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleSources\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleSources\"}, new String[]{}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleJars\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{\"module\"});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleOutput\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{\"module\"});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleSources\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{\"module\"});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{\"uuid\", \"compact\"}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKit\", \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\"}, new String[]{}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\", \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\"}, new String[]{}, new String[]{\"language\"});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\", \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\"}, new String[]{}, new String[]{\"solution\"});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitRef\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"devkit\"});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Group\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Language\", \"jetbrains.mps.build.mps.structure.BuildMps_Module\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_Module\"}, new String[]{}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Module\", \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\"}, new String[]{\"doNotCompile\"}, new String[]{});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{\"language\"});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{});\n      case 17:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{\"devkit\"});\n      case 18:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{\"reexport\"}, new String[]{\"module\"});\n      case 19:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{\"reexport\"}, new String[]{\"module\"});\n      case 20:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModuleById\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{\"targetName\", \"targetId\", \"reexport\"}, new String[]{});\n      case 21:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{\"language\"});\n      case 22:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\"}, new String[]{}, new String[]{});\n      case 23:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJavaSource\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\"}, new String[]{}, new String[]{});\n      case 24:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleModelRoot\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\"}, new String[]{}, new String[]{});\n      case 25:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 26:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\"}, new String[]{}, new String[]{\"solution\"});\n      case 27:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 28:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Solution\", \"jetbrains.mps.build.mps.structure.BuildMps_Module\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_Module\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":84172,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMPSPlugin\", \"jetbrains.mps.build.structure.BuildPlugin\", false, new String[]{\"jetbrains.mps.build.structure.BuildPlugin\"}, new String[]{}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_FolderWithSources\", \"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleSources\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleSources\"}, new String[]{}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleJars\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{\"module\"});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleOutput\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{\"module\"});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMpsLayout_ModuleSources\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{\"module\"});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{\"uuid\", \"compact\"}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKit\", \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\", \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\"}, new String[]{}, new String[]{\"language\"});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\", \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExport\"}, new String[]{}, new String[]{\"solution\"});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitRef\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"devkit\"});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Group\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Language\", \"jetbrains.mps.build.mps.structure.BuildMps_Module\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_Module\"}, new String[]{}, new String[]{});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Module\", \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\"}, new String[]{\"doNotCompile\"}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{\"language\"});\n      case 17:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{});\n      case 18:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{\"devkit\"});\n      case 19:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{\"reexport\"}, new String[]{\"module\"});\n      case 20:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{\"reexport\"}, new String[]{\"module\"});\n      case 21:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependency\"}, new String[]{}, new String[]{\"language\"});\n      case 22:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\"}, new String[]{}, new String[]{});\n      case 23:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJavaSource\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\"}, new String[]{}, new String[]{});\n      case 24:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleModelRoot\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\"}, new String[]{}, new String[]{});\n      case 25:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 26:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", \"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_ModuleRuntime\"}, new String[]{}, new String[]{\"solution\"});\n      case 27:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSource\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 28:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.mps.structure.BuildMps_Solution\", \"jetbrains.mps.build.mps.structure.BuildMps_Module\", false, new String[]{\"jetbrains.mps.build.mps.structure.BuildMps_Module\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"22b2a0bd5a63a10559cfc971331e0adaa8a8a517","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  private static Pair<Collection<Remote>, Collection<Url>> parseRemotes(@NotNull Ini ini, @NotNull ClassLoader classLoader) {\n    Collection<Remote> remotes = new ArrayList<Remote>();\n    Collection<Url> urls = new ArrayList<Url>();\n    for (Map.Entry<String, Profile.Section> stringSectionEntry : ini.entrySet()) {\n      String sectionName = stringSectionEntry.getKey();\n      Profile.Section section = stringSectionEntry.getValue();\n\n      if (sectionName.startsWith(\"remote\") || sectionName.startsWith(\"svn-remote\")) {\n        Remote remote = parseRemoteSection(sectionName, section, classLoader);\n        if (remote != null) {\n          remotes.add(remote);\n        }\n      }\n      else if (sectionName.startsWith(\"url\")) {\n        Url url = parseUrlSection(sectionName, section, classLoader);\n        if (url != null) {\n          urls.add(url);\n        }\n      }\n    }\n    return Pair.create(remotes, urls);\n  }","id":84173,"modified_method":"@NotNull\n  private static Pair<Collection<Remote>, Collection<Url>> parseRemotes(@NotNull Ini ini, @NotNull ClassLoader classLoader) {\n    Collection<Remote> remotes = new ArrayList<Remote>();\n    Collection<Url> urls = new ArrayList<Url>();\n    for (Map.Entry<String, Profile.Section> stringSectionEntry : ini.entrySet()) {\n      String sectionName = stringSectionEntry.getKey();\n      Profile.Section section = stringSectionEntry.getValue();\n\n      Remote remote = parseRemoteSection(sectionName, section, classLoader);\n      if (remote != null) {\n        remotes.add(remote);\n      }\n      else {\n        Url url = parseUrlSection(sectionName, section, classLoader);\n        if (url != null) {\n          urls.add(url);\n        }\n      }\n    }\n    return Pair.create(remotes, urls);\n  }","commit_id":"49354727e9819478e3616d8a2bff505eb350571d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Url parseUrlSection(@NotNull String sectionName, @NotNull Profile.Section section, @NotNull ClassLoader classLoader) {\n    UrlBean urlBean = section.as(UrlBean.class, classLoader);\n    Matcher matcher = URL_SECTION.matcher(sectionName);\n    if (matcher.matches()) {\n      return new Url(matcher.group(1), urlBean);\n    }\n    LOG.error(String.format(\"Invalid url section format in .git/config. sectionName: %s section: %s\", sectionName, section));\n    return null;\n  }","id":84174,"modified_method":"@Nullable\n  private static Url parseUrlSection(@NotNull String sectionName, @NotNull Profile.Section section, @NotNull ClassLoader classLoader) {\n    Matcher matcher = URL_SECTION.matcher(sectionName);\n    if (matcher.matches() && matcher.groupCount() == 1) {\n      return new Url(matcher.group(1), section.as(UrlBean.class, classLoader));\n    }\n    return null;\n  }","commit_id":"49354727e9819478e3616d8a2bff505eb350571d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Remote parseRemoteSection(@NotNull String sectionName,\n                                           @NotNull Profile.Section section,\n                                           @NotNull ClassLoader classLoader) {\n    RemoteBean remoteBean = section.as(RemoteBean.class, classLoader);\n    Matcher matcher = REMOTE_SECTION.matcher(sectionName);\n    if (matcher.matches()) {\n      String remoteName = matcher.group(1);\n      if (remoteName == null) { // e.g. remote.pushdefault generic setting not specific to any remote\n        return null;\n      }\n      return new Remote(remoteName, remoteBean);\n    }\n    LOG.error(String.format(\"Invalid remote section format in .git/config. sectionName: %s section: %s\", sectionName, section));\n    return null;\n  }","id":84175,"modified_method":"@Nullable\n  private static Remote parseRemoteSection(@NotNull String sectionName,\n                                           @NotNull Profile.Section section,\n                                           @NotNull ClassLoader classLoader) {\n    Matcher matcher = REMOTE_SECTION.matcher(sectionName);\n    if (matcher.matches() && matcher.groupCount() == 1) {\n      return new Remote(matcher.group(1), section.as(RemoteBean.class, classLoader));\n    }\n    return null;\n  }","commit_id":"49354727e9819478e3616d8a2bff505eb350571d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void test_branch_with_hash_symbol() throws IOException {\n    GitTestUtil.createRepository(myProject, myProjectPath, true);\n    git(\"remote add origin http://example.git\"); // define a remote to be able to set up tracking\n    git(\"update-ref refs/remotes/origin/a#branch HEAD\");\n    git(\"branch --track a#branch origin/a#branch\");\n\n    File gitDir = new File(myProjectPath, \".git\");\n    GitConfig config = GitConfig.read(myPlatformFacade, new File(gitDir, \"config\"));\n    GitBranchState state = new GitRepositoryReader(gitDir).readState(config.parseRemotes());\n    Collection<GitBranchTrackInfo> trackInfos = config.parseTrackInfos(state.getLocalBranches(), state.getRemoteBranches());\n    assertTrue(\"Couldn't find correct a#branch tracking information among: [\" + trackInfos + \"]\",\n               ContainerUtil.exists(trackInfos, new Condition<GitBranchTrackInfo>() {\n                 @Override\n                 public boolean value(GitBranchTrackInfo info) {\n                   return info.getLocalBranch().getName().equals(\"a#branch\") &&\n                          info.getRemoteBranch().getNameForLocalOperations().equals(\"origin/a#branch\");\n                 }\n               }));\n  }","id":84176,"modified_method":"public void test_branch_with_hash_symbol() throws IOException {\n    createRepository();\n    addRemote(\"http://example.git\");\n    git(\"update-ref refs/remotes/origin/a#branch HEAD\");\n    git(\"branch --track a#branch origin/a#branch\");\n\n    File gitDir = new File(myProjectPath, \".git\");\n    GitConfig config = GitConfig.read(myPlatformFacade, new File(gitDir, \"config\"));\n    GitBranchState state = new GitRepositoryReader(gitDir).readState(config.parseRemotes());\n    Collection<GitBranchTrackInfo> trackInfos = config.parseTrackInfos(state.getLocalBranches(), state.getRemoteBranches());\n    assertTrue(\"Couldn't find correct a#branch tracking information among: [\" + trackInfos + \"]\",\n               ContainerUtil.exists(trackInfos, new Condition<GitBranchTrackInfo>() {\n                 @Override\n                 public boolean value(GitBranchTrackInfo info) {\n                   return info.getLocalBranch().getName().equals(\"a#branch\") &&\n                          info.getRemoteBranch().getNameForLocalOperations().equals(\"origin/a#branch\");\n                 }\n               }));\n  }","commit_id":"49354727e9819478e3616d8a2bff505eb350571d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void test_remote_unspecified_section() throws Exception {\n    GitTestUtil.createRepository(myProject, myProjectPath, true);\n    git(\"remote add origin git@github.com:foo/bar.git\");\n    git(\"config remote.pushdefault origin\");\n\n    File gitDir = new File(myProjectPath, \".git\");\n    GitConfig config = GitConfig.read(myPlatformFacade, new File(gitDir, \"config\"));\n    Collection<GitRemote> remotes = config.parseRemotes();\n    assertEquals(1, remotes.size());\n    GitRemote remote = ContainerUtil.getFirstItem(remotes);\n    assertNotNull(remote);\n    assertEquals(\"origin\", remote.getName());\n    assertEquals(\"git@github.com:foo/bar.git\", remote.getFirstUrl());\n  }","id":84177,"modified_method":"public void test_remote_unspecified_section() throws Exception {\n    createRepository();\n    addRemote(\"git@github.com:foo/bar.git\");\n    git(\"config remote.pushdefault origin\");\n\n    assertSingleRemoteInConfig();\n  }","commit_id":"49354727e9819478e3616d8a2bff505eb350571d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public LeafElement findLeafElementAt(int offset) {\n    TreeElement element = this;\n    startFind:\n    while (true) {\n      TreeElement child = element.getFirstChildNode();\n      while (child != null) {\n        final int textLength = child.getTextLength();\n        if (textLength > offset) {\n          if (child instanceof LeafElement) {\n            if (child instanceof ForeignLeafPsiElement) {\n              child = child.getTreeNext();\n              continue;\n            }\n            return (LeafElement)child;\n          }\n          element = child;\n          continue startFind;\n        }\n        offset -= textLength;\n        child = child.getTreeNext();\n      }\n      return null;\n    }\n  }","id":84178,"modified_method":"@Override\n  public LeafElement findLeafElementAt(int offset) {\n    TreeElement element = this;\n    startFind:\n    while (true) {\n      TreeElement child = element.getFirstChildNode();\n      TreeElement lastChild = element.getLastChildNode();\n      boolean fwd = lastChild == null || (lastChild.getStartOffset() + lastChild.getTextLength() - child.getStartOffset()) / 2 > offset;\n      if (!fwd) {\n        child = lastChild;\n        offset = element.getTextLength() - offset;\n      }\n      while (child != null) {\n        final int textLength = child.getTextLength();\n        if (textLength > offset || !fwd && textLength >= offset) {\n          if (child instanceof LeafElement) {\n            if (child instanceof ForeignLeafPsiElement) {\n              child = fwd ? child.getTreeNext() : child.getTreePrev();\n              continue;\n            }\n            return (LeafElement)child;\n          }\n          offset = fwd ? offset : child.getTextLength() - offset;\n          element = child;\n          continue startFind;\n        }\n        offset -= textLength;\n        child = fwd ? child.getTreeNext() : child.getTreePrev();\n      }\n      return null;\n    }\n  }","commit_id":"94728b736ce6df2dbae6c827fd320569a658e14b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        if (!(file instanceof JetFile)) return;\n        JetType type = QuickFixUtil.getDeclarationReturnType(element);\n        JetProperty newElement = (JetProperty) element.copy();\n        JetPropertyAccessor getter = newElement.getGetter();\n        if (removeGetter && getter != null) {\n            newElement.deleteChildInternal(getter.getNode());\n        }\n        JetPropertyAccessor setter = newElement.getSetter();\n        if (removeSetter && setter != null) {\n            newElement.deleteChildInternal(setter.getNode());\n        }\n        JetExpression initializer = newElement.getInitializer();\n        boolean needImport = false;\n        if (removeInitializer && initializer != null) {\n            PsiElement nameIdentifier = newElement.getNameIdentifier();\n            assert nameIdentifier != null;\n            PsiElement nextSibling = nameIdentifier.getNextSibling();\n            assert nextSibling != null;\n            newElement.deleteChildRange(nextSibling, initializer);\n\n            if (newElement.getPropertyTypeRef() == null && type != null) {\n                newElement = AddReturnTypeFix.addPropertyType(project, newElement, type);\n                needImport = true;\n            }\n        }\n        if (needImport) {\n            ImportInsertHelper.addImportDirectivesIfNeeded(type, (JetFile)file);\n        }\n        element.replace(newElement);\n    }","id":84179,"modified_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        if (!(file instanceof JetFile)) return;\n        JetType type = QuickFixUtil.getDeclarationReturnType(element);\n        JetProperty newElement = (JetProperty) element.copy();\n        JetPropertyAccessor getter = newElement.getGetter();\n        if (removeGetter && getter != null) {\n            newElement.deleteChildInternal(getter.getNode());\n        }\n        JetPropertyAccessor setter = newElement.getSetter();\n        if (removeSetter && setter != null) {\n            newElement.deleteChildInternal(setter.getNode());\n        }\n        JetExpression initializer = newElement.getInitializer();\n        JetType typeToAdd = null;\n        if (removeInitializer && initializer != null) {\n            PsiElement nameIdentifier = newElement.getNameIdentifier();\n            assert nameIdentifier != null;\n            PsiElement nextSibling = nameIdentifier.getNextSibling();\n            assert nextSibling != null;\n            newElement.deleteChildRange(nextSibling, initializer);\n\n            if (newElement.getPropertyTypeRef() == null && type != null) {\n                typeToAdd = type;\n            }\n        }\n        element = (JetProperty) element.replace(newElement);\n        if (typeToAdd != null) {\n            SpecifyTypeExplicitlyAction.addTypeAnnotation(project, element, typeToAdd);\n        }\n    }","commit_id":"22010a5ae0d6aab8d892d56a95059db662499c71","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void addTypeAnnotation(Project project, JetProperty property, @NotNull JetType exprType) {\n        if (property.getPropertyTypeRef() != null) return;\n        PsiElement anchor = property.getNameIdentifier();\n        if (anchor == null) return;\n        anchor = anchor.getNextSibling();\n        if (anchor == null || !(anchor instanceof PsiWhiteSpace)) return;\n        JetTypeReference typeReference = JetPsiFactory.createType(project, DescriptorRenderer.TEXT.renderType(exprType));\n        ASTNode colon = JetPsiFactory.createColonNode(project);\n        ASTNode anchorNode = anchor.getNode().getTreeNext();\n        property.getNode().addChild(colon, anchorNode);\n        property.getNode().addChild(JetPsiFactory.createWhiteSpace(project).getNode(), anchorNode);\n        property.getNode().addChild(typeReference.getNode(), anchorNode);\n        property.getNode().addChild(JetPsiFactory.createWhiteSpace(project).getNode(), anchorNode);\n        anchor.delete();\n        ReferenceToClassesShortening.compactReferenceToClasses(Collections.singletonList(property));\n    }","id":84180,"modified_method":"public static void addTypeAnnotation(Project project, JetProperty property, @NotNull JetType exprType) {\n        if (property.getPropertyTypeRef() != null) return;\n        PsiElement anchor = property.getNameIdentifier();\n        if (anchor == null) return;\n        anchor = anchor.getNextSibling();\n        if (anchor != null) {\n            if (!(anchor instanceof PsiWhiteSpace)) {\n                return;\n            }\n        }\n        JetTypeReference typeReference = JetPsiFactory.createType(project, DescriptorRenderer.TEXT.renderType(exprType));\n        ASTNode colon = JetPsiFactory.createColonNode(project);\n        ASTNode anchorNode = anchor == null ? null : anchor.getNode().getTreeNext();\n        if (anchor == null) {\n            property.getNode().addChild(JetPsiFactory.createWhiteSpace(project).getNode(), anchorNode);\n        }\n        property.getNode().addChild(colon, anchorNode);\n        property.getNode().addChild(JetPsiFactory.createWhiteSpace(project).getNode(), anchorNode);\n        property.getNode().addChild(typeReference.getNode(), anchorNode);\n        property.getNode().addChild(JetPsiFactory.createWhiteSpace(project).getNode(), anchorNode);\n        if (anchor != null) {\n            anchor.delete();\n        }\n        ReferenceToClassesShortening.compactReferenceToClasses(Collections.singletonList(property));\n    }","commit_id":"22010a5ae0d6aab8d892d56a95059db662499c71","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsRt(Grammar grammar) {\n\t\tif (!usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\treturn new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IEvaluationContext\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.DefaultEvaluationContext\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IExpressionInterpreter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter\")\n\t\t\t\t.addTypeToType(IQualifiedNameConverter.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.XbaseQualifiedNameConverter\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.typing.ITypeProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeProvider\")\n\t\t\t\t.addTypeToType(IValueConverterService.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.conversion.XbaseValueConverterService\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\t\"LinkingIScopeProvider\" ,\n\t\t\t\t\t\t\"binder.bind(\" + IScopeProvider.class.getName() + \".class).annotatedWith(\"\n\t\t\t\t\t\t\t\t+ LinkingScopeProviderBinding.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).to(org.eclipse.xtext.xbase.linking.XbaseLinkingScopeProvider.class)\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\tIScopeProvider.class.getName() + \"Delegate\",\n\t\t\t\t\t\t\"binder.bind(\"\n\t\t\t\t\t\t\t\t+ IScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).annotatedWith(Names.named(\"\n\t\t\t\t\t\t\t\t+ AbstractDeclarativeScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".NAMED_DELEGATE)).to(org.eclipse.xtext.xbase.scoping.XbaseImportedNamespaceScopeProvider.class)\")\n\t\t\t\t\t\t\t\t\n\t\t\t\t// obsolete convenience bindings\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\").getBindings();\n\t}","id":84181,"modified_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsRt(Grammar grammar) {\n\t\tif (!usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\treturn new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IEvaluationContext\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.DefaultEvaluationContext\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IExpressionInterpreter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter\")\n\t\t\t\t.addTypeToType(IQualifiedNameConverter.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.XbaseQualifiedNameConverter\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.typing.ITypeProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeProvider\")\n\t\t\t\t.addTypeToType(IValueConverterService.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.conversion.XbaseValueConverterService\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\t\"LinkingIScopeProvider\" ,\n\t\t\t\t\t\t\"binder.bind(\" + IScopeProvider.class.getName() + \".class).annotatedWith(\"\n\t\t\t\t\t\t\t\t+ LinkingScopeProviderBinding.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).to(org.eclipse.xtext.xbase.linking.XbaseLinkingScopeProvider.class)\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\tIScopeProvider.class.getName() + \"Delegate\",\n\t\t\t\t\t\t\"binder.bind(\"\n\t\t\t\t\t\t\t\t+ IScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).annotatedWith(Names.named(\"\n\t\t\t\t\t\t\t\t+ AbstractDeclarativeScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".NAMED_DELEGATE)).to(org.eclipse.xtext.xbase.scoping.XbaseImportedNamespaceScopeProvider.class)\")\n\t\t\n\t\t\t\t.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.jvm.JvmLocationInFileProvider\")\n\t\t\t\t.addTypeToType(EObjectAtOffsetHelper.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.jvm.JvmEObjectAtOffsetHelper\")\n\t\t\t\t.addTypeToType(ILinker.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.jvm.JvmModelXbaseLazyLinker\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.linking.jvm.IJvmModelAssociations\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.jvm.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.linking.jvm.IJvmModelAssociator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.jvm.JvmModelAssociator\")\n\t\t\t\t\t\t\t\t\n\t\t\t\t// obsolete convenience bindings\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\")\n\t\t\t\t.getBindings();\n\t}","commit_id":"c89d20f0bd20426bdaf368db02f23be854912eea","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsRt(Grammar grammar) {\n\t\tif (!XbaseUtil.usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\tBindFactory config = new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IEvaluationContext\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.DefaultEvaluationContext\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IExpressionInterpreter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter\")\n\t\t\t\t.addTypeToType(IQualifiedNameConverter.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.XbaseQualifiedNameConverter\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.typing.ITypeProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeProvider\")\n\t\t\t\t.addTypeToType(IValueConverterService.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.conversion.XbaseValueConverterService\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\t\"LinkingIScopeProvider\",\n\t\t\t\t\t\t\"binder.bind(\" + IScopeProvider.class.getName() + \".class).annotatedWith(\"\n\t\t\t\t\t\t\t\t+ LinkingScopeProviderBinding.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).to(org.eclipse.xtext.xbase.linking.XbaseLinkingScopeProvider.class)\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\tIScopeProvider.class.getName() + \"Delegate\",\n\t\t\t\t\t\t\"binder.bind(\"\n\t\t\t\t\t\t\t\t+ IScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).annotatedWith(Names.named(\"\n\t\t\t\t\t\t\t\t+ AbstractDeclarativeScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".NAMED_DELEGATE)).to(org.eclipse.xtext.xbase.scoping.XbaseImportedNamespaceScopeProvider.class)\")\n\n\t\t\t\t.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmLocationInFileProvider\")\n\t\t\t\t.addTypeToType(EObjectAtOffsetHelper.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmEObjectAtOffsetHelper\")\n\t\t\t\t.addTypeToType(ILinker.class.getName(), \"org.eclipse.xtext.xbase.jvmmodel.JvmModelXbaseLazyLinker\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(IGlobalScopeProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmGlobalScopeProvider\")\n\t\t\t\t// obsolete convenience bindings\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\");\n\t\tif (generateInferrer) {\n\t\t\tconfig = config\n\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer\",\n\t\t\t\t\t\t\tgetJvmModelInferrerName(grammar, getNaming()));\n\t\t}\n\t\treturn config.getBindings();\n\t}","id":84182,"modified_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsRt(Grammar grammar) {\n\t\tif (!XbaseUtil.usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\tBindFactory config = new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IEvaluationContext\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.DefaultEvaluationContext\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IExpressionInterpreter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter\")\n\t\t\t\t.addTypeToType(IQualifiedNameConverter.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.XbaseQualifiedNameConverter\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.typing.ITypeProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeProvider\")\n\t\t\t\t.addTypeToType(IValueConverterService.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.conversion.XbaseValueConverterService\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\t\"LinkingIScopeProvider\",\n\t\t\t\t\t\t\"binder.bind(\" + IScopeProvider.class.getName() + \".class).annotatedWith(\"\n\t\t\t\t\t\t\t\t+ LinkingScopeProviderBinding.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).to(org.eclipse.xtext.xbase.linking.XbaseLinkingScopeProvider.class)\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\tIScopeProvider.class.getName() + \"Delegate\",\n\t\t\t\t\t\t\"binder.bind(\"\n\t\t\t\t\t\t\t\t+ IScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).annotatedWith(Names.named(\"\n\t\t\t\t\t\t\t\t+ AbstractDeclarativeScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".NAMED_DELEGATE)).to(org.eclipse.xtext.xbase.scoping.XbaseImportedNamespaceScopeProvider.class)\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.util.TypeConformanceComputer\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeConformanceComputer\")\n\n\t\t\t\t.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmLocationInFileProvider\")\n\t\t\t\t.addTypeToType(EObjectAtOffsetHelper.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmEObjectAtOffsetHelper\")\n\t\t\t\t.addTypeToType(ILinker.class.getName(), \"org.eclipse.xtext.xbase.jvmmodel.JvmModelXbaseLazyLinker\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(IGlobalScopeProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmGlobalScopeProvider\")\n\t\t\t\t// obsolete convenience bindings\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\");\n\t\tif (generateInferrer) {\n\t\t\tconfig = config\n\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer\",\n\t\t\t\t\t\t\tgetJvmModelInferrerName(grammar, getNaming()));\n\t\t}\n\t\treturn config.getBindings();\n\t}","commit_id":"9258b6a645b48c60f26b22c87cfd3c2ec5979476","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsUi(Grammar grammar) {\n\t\tif(isGenerateStub())\n\t\t\treturn new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.quickfix.IssueResolutionProvider\", getQuickfixProviderName(grammar, getNaming()))\n\t\t\t\t.getBindings();\n\t\telse\n\t\t\treturn emptySet();\n\t}","id":84183,"modified_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsUi(Grammar grammar) {\n\t\tBindFactory bindFactory = new BindFactory();\n\t\tif(isGenerateStub()) {\n\t\t\t bindFactory\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.quickfix.IssueResolutionProvider\", getQuickfixProviderName(grammar, getNaming()));\n\t\t} else {\n\t\t\t bindFactory\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.quickfix.IssueResolutionProvider\", getQuickfixProviderSuperClassName(grammar));\n\t\t}\n\t\treturn bindFactory.getBindings();\n\t}","commit_id":"208285a185e07b5b39d414e4b12cd4785773bb40","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsUi(Grammar grammar) {\n\t\tif (!usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\tBindFactory bindFactory = new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.syntaxcoloring.AbstractAntlrTokenToAttributeIdMapper\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.syntaxcoloring.XbaseTokenToAttributeIdMapper\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.contentassist.AbstractJavaBasedContentProposalProvider.ReferenceProposalCreator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.contentassist.XbaseReferenceProposalCreator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.jface.text.contentassist.IContentAssistProcessor\", \n\t\t\t\t\t\t\"org.eclipse.xtext.ui.editor.contentassist.RepeatedContentAssistProcessor\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.syntaxcoloring.ISemanticHighlightingCalculator\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.highlighting.XbaseHighlightingCalculator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.syntaxcoloring.IHighlightingConfiguration\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.highlighting.XbaseHighlightingConfiguration\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.hover.IEObjectHoverProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.hover.XbaseHoverProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.hover.IEObjectHover\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.hover.XbaseDispatchingEObjectTextHover\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.hover.html.IEObjectHoverDocumentationProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.hover.XbaseHoverDocumentationProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider.CrossRefResolutionConverter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.quickfix.XbaseCrossRefResolutionConverter\")\n\t\t\t\t.addTypeToTypeEagerSingleton(\"org.eclipse.xtext.xbase.ui.validation.XbaseUIValidator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.validation.XbaseUIValidator\");\n\t\tif (useInferredJvmModel) {\n\t\t\t// rename refactoring\n\t\t\tbindFactory = bindFactory\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.findrefs.FindReferencesHandler\", \n\t\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.findrefs.JvmModelFindReferenceHandler\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.findrefs.ReferenceQueryExecutor\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.findrefs.JvmModelReferenceQueryExecutor\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IDependentElementsCalculator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.JvmModelDependentElementsCalculator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IRenameRefactoringProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.jdt.CombinedJvmJdtRenameRefactoringProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IReferenceUpdater\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.refactoring.XbaseReferenceUpdater\")\n\t\t\t\t.addfinalTypeToType(\"org.eclipse.xtext.ui.refactoring.ui.IRenameContextFactory\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.jdt.CombinedJvmJdtRenameContextFactory\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.ui.refactoring.participant.JdtRenameParticipant.ContextFactory\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.JvmModelJdtRenameParticipantContext.ContextFactory\")\n\t\t\t    .addTypeToType(\"org.eclipse.xtext.ui.refactoring.IRenameStrategy\", \n\t\t\t    \t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.DefaultJvmModelRenameStrategy\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.outline.impl.OutlineNodeElementOpener\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.outline.JvmOutlineNodeElementOpener\")\n\t\t\t    .addTypeToType(\"org.eclipse.xtext.ui.editor.GlobalURIEditorOpener\", \n\t\t\t\t\t\t\"org.eclipse.xtext.common.types.ui.navigation.GlobalDerivedMemberAwareURIEditorOpener\")\n\t\t\t    .addTypeToType(\"org.eclipse.xtext.ui.editor.occurrences.IOccurrenceComputer\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.occurrence.JvmModelOccurrenceComputer\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.ui.query.IJavaSearchParticipation\", \n\t\t\t\t\t\t\"org.eclipse.xtext.common.types.ui.query.IJavaSearchParticipation.No\")\n\t\t\t\t// DerivedMemberAwareEditorOpener\n\t\t\t\t.addConfiguredBinding(\"LanguageSpecificURIEditorOpener\", \"if (org.eclipse.ui.PlatformUI.isWorkbenchRunning()) { \\n\"+\n\t\t\t\t\t\t\"\\t\\t\\tbinder.bind(org.eclipse.xtext.ui.editor.IURIEditorOpener.class).annotatedWith(org.eclipse.xtext.ui.LanguageSpecific.class)\" +\n\t\t\t\t\t\t\".to(org.eclipse.xtext.xbase.ui.jvmmodel.navigation.DerivedMemberAwareEditorOpener.class); \\n\" +\n\t\t\t\t\t\t\"\\t\\t\\tbinder.bind(org.eclipse.xtext.common.types.ui.navigation.IDerivedMemberAwareEditorOpener.class).to(org.eclipse.xtext.xbase.ui.jvmmodel.navigation.DerivedMemberAwareEditorOpener.class); \\n\"+\n\t\t\t\t\t\t\"\\t\\t}\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.contentassist.ImportingTypesProposalProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.jface.viewers.ILabelProvider\", \"org.eclipse.xtext.xbase.ui.labeling.XbaseLabelProvider\");\n\n\t\t} else {\n\t\t\tbindFactory =  bindFactory.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IRenameStrategy\", \n\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.refactoring.XbaseRenameStrategy\");\n\t\t}\n\t\tif(usesXImportSection(grammar)) {\n\t\t\tbindFactory.addTypeToType(\"org.eclipse.xtext.xbase.imports.IUnresolvedTypeResolver\", \n\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.imports.InteractiveUnresolvedTypeResolver\");\n\n\t\t}\n\t\treturn bindFactory.getBindings();\n\t}","id":84184,"modified_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsUi(Grammar grammar) {\n\t\tif (!usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\tBindFactory bindFactory = new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.syntaxcoloring.AbstractAntlrTokenToAttributeIdMapper\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.syntaxcoloring.XbaseTokenToAttributeIdMapper\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.contentassist.AbstractJavaBasedContentProposalProvider.ReferenceProposalCreator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.contentassist.XbaseReferenceProposalCreator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.jface.text.contentassist.IContentAssistProcessor\", \n\t\t\t\t\t\t\"org.eclipse.xtext.ui.editor.contentassist.RepeatedContentAssistProcessor\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.syntaxcoloring.ISemanticHighlightingCalculator\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.highlighting.XbaseHighlightingCalculator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.syntaxcoloring.IHighlightingConfiguration\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.highlighting.XbaseHighlightingConfiguration\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.hover.IEObjectHoverProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.hover.XbaseHoverProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.hover.IEObjectHover\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.hover.XbaseDispatchingEObjectTextHover\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.hover.html.IEObjectHoverDocumentationProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.hover.XbaseHoverDocumentationProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider.CrossRefResolutionConverter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.quickfix.XbaseCrossRefResolutionConverter\")\n\t\t\t\t.addTypeToTypeEagerSingleton(\"org.eclipse.xtext.xbase.ui.validation.XbaseUIValidator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.validation.XbaseUIValidator\");\n\t\tif (useInferredJvmModel) {\n\t\t\t// rename refactoring\n\t\t\tbindFactory = bindFactory\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.findrefs.FindReferencesHandler\", \n\t\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.findrefs.JvmModelFindReferenceHandler\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.findrefs.ReferenceQueryExecutor\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.findrefs.JvmModelReferenceQueryExecutor\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IDependentElementsCalculator\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.JvmModelDependentElementsCalculator\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IRenameRefactoringProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.jdt.CombinedJvmJdtRenameRefactoringProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IReferenceUpdater\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.refactoring.XbaseReferenceUpdater\")\n\t\t\t\t.addfinalTypeToType(\"org.eclipse.xtext.ui.refactoring.ui.IRenameContextFactory\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.jdt.CombinedJvmJdtRenameContextFactory\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.ui.refactoring.participant.JdtRenameParticipant.ContextFactory\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.JvmModelJdtRenameParticipantContext.ContextFactory\")\n\t\t\t    .addTypeToType(\"org.eclipse.xtext.ui.refactoring.IRenameStrategy\", \n\t\t\t    \t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.refactoring.DefaultJvmModelRenameStrategy\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.ui.editor.outline.impl.OutlineNodeElementOpener\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.outline.JvmOutlineNodeElementOpener\")\n\t\t\t    .addTypeToType(\"org.eclipse.xtext.ui.editor.GlobalURIEditorOpener\", \n\t\t\t\t\t\t\"org.eclipse.xtext.common.types.ui.navigation.GlobalDerivedMemberAwareURIEditorOpener\")\n\t\t\t    .addTypeToType(\"org.eclipse.xtext.ui.editor.occurrences.IOccurrenceComputer\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.jvmmodel.occurrence.JvmModelOccurrenceComputer\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.ui.query.IJavaSearchParticipation\", \n\t\t\t\t\t\t\"org.eclipse.xtext.common.types.ui.query.IJavaSearchParticipation.No\")\n\t\t\t\t// DerivedMemberAwareEditorOpener\n\t\t\t\t.addConfiguredBinding(\"LanguageSpecificURIEditorOpener\", \"if (org.eclipse.ui.PlatformUI.isWorkbenchRunning()) { \\n\"+\n\t\t\t\t\t\t\"\\t\\t\\tbinder.bind(org.eclipse.xtext.ui.editor.IURIEditorOpener.class).annotatedWith(org.eclipse.xtext.ui.LanguageSpecific.class)\" +\n\t\t\t\t\t\t\".to(org.eclipse.xtext.xbase.ui.jvmmodel.navigation.DerivedMemberAwareEditorOpener.class); \\n\" +\n\t\t\t\t\t\t\"\\t\\t\\tbinder.bind(org.eclipse.xtext.common.types.ui.navigation.IDerivedMemberAwareEditorOpener.class).to(org.eclipse.xtext.xbase.ui.jvmmodel.navigation.DerivedMemberAwareEditorOpener.class); \\n\"+\n\t\t\t\t\t\t\"\\t\\t}\")\n\t\t\t\t.addTypeToType(\"org.eclipse.jface.viewers.ILabelProvider\", \"org.eclipse.xtext.xbase.ui.labeling.XbaseLabelProvider\");\n\n\t\t} else {\n\t\t\tbindFactory =  bindFactory.addTypeToType(\"org.eclipse.xtext.ui.refactoring.IRenameStrategy\", \n\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.refactoring.XbaseRenameStrategy\");\n\t\t}\n\t\tif(usesXImportSection(grammar)) {\n\t\t\tbindFactory\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.imports.IUnresolvedTypeResolver\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.imports.InteractiveUnresolvedTypeResolver\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.contentassist.ImportingTypesProposalProvider\");\n\t\t} else {\n\t\t\tbindFactory\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.ui.quickfix.JavaTypeQuickfixes\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.ui.quickfix.JavaTypeQuickfixesNoImportSection\");\n\t\t}\n\t\treturn bindFactory.getBindings();\n\t}","commit_id":"208285a185e07b5b39d414e4b12cd4785773bb40","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n   * Configures and creates a Dataset\n   *\n   * @param datasetInstanceId dataset instance to be created\n   * @param typeMeta type meta for the dataset\n   * @param props dataset instance properties\n   * @param existing if dataset already exists (in case of update), the existing properties\n   * @return dataset specification\n   * @throws Exception\n   */\n  public DatasetSpecification createOrUpdate(final Id.DatasetInstance datasetInstanceId, final DatasetTypeMeta typeMeta,\n                                             final DatasetProperties props,\n                                             @Nullable final DatasetSpecification existing) throws Exception {\n\n    if (existing == null) {\n      LOG.info(\"Creating dataset instance {}, type meta: {}, props: {}\", datasetInstanceId, typeMeta, props);\n    } else {\n      LOG.info(\"Updating dataset instance {}, type meta: {}, existing: {}, props: {}\",\n               datasetInstanceId, typeMeta, existing, props);\n    }\n    try (DatasetClassLoaderProvider classLoaderProvider =\n           new DirectoryClassLoaderProvider(cConf, locationFactory)) {\n\n      return impersonator.doAs(datasetInstanceId.getNamespace().toEntityId(), new Callable<DatasetSpecification>() {\n        @Override\n        public DatasetSpecification call() throws Exception {\n          DatasetType type = dsFramework.getDatasetType(typeMeta, null, classLoaderProvider);\n          if (type == null) {\n            throw new BadRequestException(\n              String.format(\"Cannot instantiate dataset type using provided type meta: %s\", typeMeta));\n          }\n          DatasetSpecification spec = existing == null\n            ? type.configure(datasetInstanceId.getId(), props)\n            : type.reconfigure(datasetInstanceId.getId(), props, existing);\n\n          DatasetContext context = DatasetContext.from(datasetInstanceId.getNamespaceId());\n          DatasetAdmin admin = type.getAdmin(context, spec);\n          if (existing != null) {\n            if (admin instanceof Updatable) {\n              ((Updatable) admin).update(existing);\n            } else {\n              admin.upgrade();\n            }\n          } else {\n            admin.create();\n          }\n\n          writeSystemMetadata(datasetInstanceId, spec, props, typeMeta, type, context, existing != null);\n          return spec;\n        }\n      });\n    } catch (Exception e) {\n      if (e instanceof IncompatibleUpdateException) {\n        // this is expected to happen if user provides bad update properties, so we log this as debug\n        LOG.debug(\"Incompatible update for dataset '{}'\", datasetInstanceId, e);\n      } else {\n        LOG.error(\"Error {} dataset '{}': {}\",\n                  existing == null ? \"creating\" : \"updating\", datasetInstanceId, e.getMessage(), e);\n      }\n      throw e;\n    }\n  }","id":84185,"modified_method":"/**\n   * Configures and creates a Dataset\n   *\n   * @param datasetInstanceId dataset instance to be created\n   * @param typeMeta type meta for the dataset\n   * @param props dataset instance properties\n   * @param existing if dataset already exists (in case of update), the existing properties\n   * @return dataset specification\n   * @throws Exception\n   */\n  public DatasetSpecification createOrUpdate(final Id.DatasetInstance datasetInstanceId, final DatasetTypeMeta typeMeta,\n                                             final DatasetProperties props,\n                                             @Nullable final DatasetSpecification existing) throws Exception {\n\n    if (existing == null) {\n      LOG.info(\"Creating dataset instance {}, type meta: {}, props: {}\", datasetInstanceId, typeMeta, props);\n    } else {\n      LOG.info(\"Updating dataset instance {}, type meta: {}, existing: {}, props: {}\",\n               datasetInstanceId, typeMeta, existing, props);\n    }\n    try (DatasetClassLoaderProvider classLoaderProvider =\n           new DirectoryClassLoaderProvider(cConf, locationFactory)) {\n      final DatasetContext context = DatasetContext.from(datasetInstanceId.getNamespaceId());\n      UserGroupInformation ugi = impersonator.getUGI(datasetInstanceId.getNamespace().toEntityId());\n\n      final DatasetType type = ImpersonationUtils.doAs(ugi, new Callable<DatasetType>() {\n        @Override\n        public DatasetType call() throws Exception {\n          DatasetType type = dsFramework.getDatasetType(typeMeta, null, classLoaderProvider);\n          if (type == null) {\n            throw new BadRequestException(\n              String.format(\"Cannot instantiate dataset type using provided type meta: %s\", typeMeta));\n          }\n          return type;\n        }\n      });\n\n      DatasetSpecification spec = ImpersonationUtils.doAs(ugi, new Callable<DatasetSpecification>() {\n        @Override\n        public DatasetSpecification call() throws Exception {\n          DatasetSpecification spec = existing == null ? type.configure(datasetInstanceId.getId(), props)\n            : type.reconfigure(datasetInstanceId.getId(), props, existing);\n\n          DatasetAdmin admin = type.getAdmin(context, spec);\n          if (existing != null) {\n            if (admin instanceof Updatable) {\n              ((Updatable) admin).update(existing);\n            } else {\n              admin.upgrade();\n            }\n          } else {\n            admin.create();\n          }\n          return spec;\n        }\n      });\n\n      // Writing system metadata should be done without impersonation since user may not have access to system tables.\n      writeSystemMetadata(datasetInstanceId, spec, props, typeMeta, type, context, existing != null);\n      return spec;\n    } catch (Exception e) {\n      if (e instanceof IncompatibleUpdateException) {\n        // this is expected to happen if user provides bad update properties, so we log this as debug\n        LOG.debug(\"Incompatible update for dataset '{}'\", datasetInstanceId, e);\n      } else {\n        LOG.error(\"Error {} dataset '{}': {}\",\n                  existing == null ? \"creating\" : \"updating\", datasetInstanceId, e.getMessage(), e);\n      }\n      throw e;\n    }\n  }","commit_id":"fd33c55d992098c1f06ef7135a03e78e43cbe021","url":"https://github.com/caskdata/cdap"},{"original_method":"private void writeIssue(IssueQueryResult result, DefaultIssue issue, JsonWriter json) {\n    String actionPlanKey = issue.actionPlanKey();\n    WorkDayDuration technicalDebt = issue.technicalDebt();\n    Date updateDate = issue.updateDate();\n    Date closeDate = issue.closeDate();\n\n    json\n      .prop(\"key\", issue.key())\n      .prop(\"component\", issue.componentKey())\n      .prop(\"componentLongName\", result.component(issue).longName())\n      .prop(\"componentQualifier\", result.component(issue).qualifier())\n      .prop(\"project\", result.project(issue).key())\n      .prop(\"projectLongName\", result.project(issue).longName())\n      .prop(\"rule\", issue.ruleKey().toString())\n      .prop(\"ruleName\", result.rule(issue).getName())\n      .prop(\"line\", issue.line())\n      .prop(\"message\", issue.message())\n      .prop(\"resolution\", issue.resolution())\n      .prop(\"status\", issue.status())\n      .prop(\"severity\", issue.severity())\n      .prop(\"author\", issue.authorLogin())\n      .prop(\"actionPlan\", actionPlanKey)\n      .prop(\"debt\", technicalDebt != null ? technicalDebtFormatter.format(UserSession.get().locale(), technicalDebt) : null)\n      .prop(\"actionPlanName\", actionPlanKey != null ? result.actionPlan(issue).name() : null)\n      .prop(\"creationDate\", DateUtils.formatDateTime(issue.creationDate()))\n      .prop(\"fCreationDate\", formatDate(issue.creationDate()))\n      .prop(\"updateDate\", updateDate != null ? DateUtils.formatDateTime(updateDate) : null)\n      .prop(\"fUpdateDate\", formatDate(updateDate))\n      .prop(\"fUpdateAge\", formatAgeDate(updateDate))\n      .prop(\"closeDate\", closeDate != null ? DateUtils.formatDateTime(closeDate) : null)\n      .prop(\"fCloseDate\", formatDate(issue.closeDate()));\n\n    addUserWithLabel(result, issue.assignee(), \"assignee\", json);\n    addUserWithLabel(result, issue.reporter(), \"reporter\", json);\n  }","id":84186,"modified_method":"private void writeIssue(IssueQueryResult result, DefaultIssue issue, JsonWriter json) {\n    Component component = result.component(issue);\n    Component project = result.project(issue);\n    String actionPlanKey = issue.actionPlanKey();\n    WorkDayDuration technicalDebt = issue.technicalDebt();\n    Date updateDate = issue.updateDate();\n    Date closeDate = issue.closeDate();\n\n    json\n      .prop(\"key\", issue.key())\n      .prop(\"component\", issue.componentKey())\n      .prop(\"componentLongName\", component != null ? component.longName() : null)\n      .prop(\"componentQualifier\", component != null ? component.qualifier() : null)\n      .prop(\"project\", issue.projectKey())\n      .prop(\"projectLongName\", project != null ? project.longName() : null)\n      .prop(\"rule\", issue.ruleKey().toString())\n      .prop(\"ruleName\", result.rule(issue).getName())\n      .prop(\"line\", issue.line())\n      .prop(\"message\", issue.message())\n      .prop(\"resolution\", issue.resolution())\n      .prop(\"status\", issue.status())\n      .prop(\"severity\", issue.severity())\n      .prop(\"author\", issue.authorLogin())\n      .prop(\"actionPlan\", actionPlanKey)\n      .prop(\"debt\", technicalDebt != null ? technicalDebtFormatter.format(UserSession.get().locale(), technicalDebt) : null)\n      .prop(\"actionPlanName\", actionPlanKey != null ? result.actionPlan(issue).name() : null)\n      .prop(\"creationDate\", DateUtils.formatDateTime(issue.creationDate()))\n      .prop(\"fCreationDate\", formatDate(issue.creationDate()))\n      .prop(\"updateDate\", updateDate != null ? DateUtils.formatDateTime(updateDate) : null)\n      .prop(\"fUpdateDate\", formatDate(updateDate))\n      .prop(\"fUpdateAge\", formatAgeDate(updateDate))\n      .prop(\"closeDate\", closeDate != null ? DateUtils.formatDateTime(closeDate) : null)\n      .prop(\"fCloseDate\", formatDate(issue.closeDate()));\n\n    addUserWithLabel(result, issue.assignee(), \"assignee\", json);\n    addUserWithLabel(result, issue.reporter(), \"reporter\", json);\n  }","commit_id":"a743db9c4104a4ab1f56dd061314f4dc96d24e6c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private DefaultIssue createStandardIssue() {\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCD\")\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setCreationDate(DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\"));\n    when(i18n.formatDateTime(any(Locale.class), eq(issue.creationDate()))).thenReturn(\"Jan 22, 2014 10:03 AM\");\n    when(i18n.message(any(Locale.class), eq(\"created\"), eq((String) null))).thenReturn(\"Created\");\n    return issue;\n  }","id":84187,"modified_method":"private DefaultIssue createStandardIssue() {\n    DefaultIssue issue =  createIssue();\n    addComponentAndProject();\n    return issue;\n  }","commit_id":"a743db9c4104a4ab1f56dd061314f4dc96d24e6c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    issues = new ArrayList<Issue>();\n    result = new DefaultIssueQueryResult(issues);\n\n    Component component = mock(Component.class);\n    when(component.key()).thenReturn(\"org.sonar.server.issue.IssueClient\");\n    when(component.longName()).thenReturn(\"SonarQube :: Issue Client\");\n    when(component.qualifier()).thenReturn(\"FIL\");\n    result.addComponents(newArrayList(component));\n    Component project = mock(Component.class);\n    when(project.key()).thenReturn(\"org.sonar.Sonar\");\n    when(project.longName()).thenReturn(\"SonarQube\");\n    result.addProjects(newArrayList(project));\n\n    result.addRules(newArrayList(Rule.create(\"squid\", \"AvoidCycle\").setName(\"Avoid cycle\")));\n    when(issueFinder.find(any(IssueQuery.class))).thenReturn(result);\n\n    when(issueChangelogService.changelog(any(Issue.class))).thenReturn(mock(IssueChangelog.class));\n\n    tester = new WsTester(new IssuesWs(new IssueShowWsHandler(issueFinder, issueService, issueChangelogService, actionService, technicalDebtFormatter, i18n)));\n  }","id":84188,"modified_method":"@Before\n  public void setUp() throws Exception {\n    issues = new ArrayList<Issue>();\n    result = new DefaultIssueQueryResult(issues);\n    result.addRules(newArrayList(Rule.create(\"squid\", \"AvoidCycle\").setName(\"Avoid cycle\")));\n    when(issueFinder.find(any(IssueQuery.class))).thenReturn(result);\n\n    when(issueChangelogService.changelog(any(Issue.class))).thenReturn(mock(IssueChangelog.class));\n\n    issue_creation_date = DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\");\n    when(i18n.formatDateTime(any(Locale.class), eq(issue_creation_date))).thenReturn(\"Jan 22, 2014 10:03 AM\");\n\n    when(i18n.message(any(Locale.class), eq(\"created\"), eq((String) null))).thenReturn(\"Created\");\n\n    tester = new WsTester(new IssuesWs(new IssueShowWsHandler(issueFinder, issueService, issueChangelogService, actionService, technicalDebtFormatter, i18n)));\n  }","commit_id":"a743db9c4104a4ab1f56dd061314f4dc96d24e6c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void show_issue() throws Exception {\n    String issueKey = \"ABCD\";\n    Issue issue = new DefaultIssue()\n      .setKey(issueKey)\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setLine(12)\n      .setEffortToFix(2.0)\n      .setMessage(\"Fix it\")\n      .setResolution(\"FIXED\")\n      .setStatus(\"CLOSED\")\n      .setSeverity(\"MAJOR\")\n      .setCreationDate(DateUtils.parseDateTime(\"2014-01-22T19:10:03+0100\"));\n    issues.add(issue);\n\n    when(i18n.formatDateTime(any(Locale.class), eq(issue.creationDate()))).thenReturn(\"Jan 22, 2014 10:03 AM\");\n    when(i18n.message(any(Locale.class), eq(\"created\"), eq((String) null))).thenReturn(\"Created\");\n\n    MockUserSession.set();\n    WsTester.TestRequest request = tester.newRequest(\"show\").setParam(\"key\", issueKey);\n    request.execute().assertJson(getClass(), \"show_issue.json\");\n  }","id":84189,"modified_method":"@Test\n  public void show_issue() throws Exception {\n    String issueKey = \"ABCD\";\n    Issue issue = new DefaultIssue()\n      .setKey(issueKey)\n      .setComponentKey(\"org.sonar.server.issue.IssueClient\")\n      .setProjectKey(\"org.sonar.Sonar\")\n      .setRuleKey(RuleKey.of(\"squid\", \"AvoidCycle\"))\n      .setLine(12)\n      .setEffortToFix(2.0)\n      .setMessage(\"Fix it\")\n      .setResolution(\"FIXED\")\n      .setStatus(\"CLOSED\")\n      .setSeverity(\"MAJOR\")\n      .setCreationDate(issue_creation_date);\n    issues.add(issue);\n\n    Component component = mock(Component.class);\n    when(component.key()).thenReturn(\"org.sonar.server.issue.IssueClient\");\n    when(component.longName()).thenReturn(\"SonarQube :: Issue Client\");\n    when(component.qualifier()).thenReturn(\"FIL\");\n    result.addComponents(newArrayList(component));\n\n    Component project = mock(Component.class);\n    when(project.key()).thenReturn(\"org.sonar.Sonar\");\n    when(project.longName()).thenReturn(\"SonarQube\");\n    result.addProjects(newArrayList(project));\n\n    MockUserSession.set();\n    WsTester.TestRequest request = tester.newRequest(\"show\").setParam(\"key\", issueKey);\n    request.execute().assertJson(getClass(), \"show_issue.json\");\n  }","commit_id":"a743db9c4104a4ab1f56dd061314f4dc96d24e6c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static ContentName versionName(ContentName name, Timestamp version) {\n\t\t// Timestamps go up to ns\n\t\t// DKS -- TODO FIX, wrong value\n\n\t\tlong versionns = version.getTime() * 1000000 + version.getNanos();\n\t\treturn versionName(name, versionns*1000); // 48 bits till year 4147\n\t}","id":84190,"modified_method":"public static ContentName versionName(ContentName name, Timestamp version) {\n\t\t// Timestamps go up to ns\n\t\t// DKS -- TODO FIX, wrong value\n\n\t\tlong versionns = version.getTime() * 1000000000 + version.getNanos();\n\t\treturn versionName(name, versionns*1000); // 48 bits till year 4147\n\t}","commit_id":"35ba7d52aadb2351f20f261fa6fae7bd7cccf8a2","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static long getVersionNumber(ContentName version) {\n\t\tif (isVersioned(version)) {\n\t\t\tbyte [] fcomp = version.component(version.count() - 2);\n\t\t\t// Will behave properly with everything but first fragment of fragmented content.\n\t\t\tif (fcomp.length == 1)\n\t\t\t\treturn 0;\n\t\t\treturn Long.valueOf(ContentName.componentPrintURI(fcomp, 1, fcomp.length-1));\n\t\t}\n\t\treturn -1; // unexpected, but not invalid\t\t\n\t}","id":84191,"modified_method":"public static long getVersionNumber(ContentName name) throws VersionMissingException {\n\t\tbyte [] vm = null;\n\t\tif (SegmentationProfile.isSegment(name)) {\n\t\t\tvm = name.component(name.count()-2);\n\t\t} else {\n\t\t\tvm = name.lastComponent(); // no fragment number, unusual\n\t\t}\n\t\tif ((null == vm) || (0 == vm.length) || (VERSION_MARKER != vm[0]))\n\t\t\tthrow new VersionMissingException();\n\t\t\n\t\tbyte [] versionData = new byte[vm.length - 1];\n\t\tSystem.arraycopy(vm, 1, versionData, 0, vm.length - 1);\n\t\treturn new BigInteger(versionData).longValue();\n\t}","commit_id":"35ba7d52aadb2351f20f261fa6fae7bd7cccf8a2","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    chain.doFilter(request, response);\n\n    DatabaseSessionFactory sessionFactory = Platform.getInstance().getContainer().getComponentByType(DatabaseSessionFactory.class);\n    if (sessionFactory != null) {\n      sessionFactory.clear();\n    }\n  }","id":84192,"modified_method":"@Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    chain.doFilter(request, response);\n\n    DatabaseSessionFactory sessionFactory = Platform.component(DatabaseSessionFactory.class);\n    if (sessionFactory != null) {\n      sessionFactory.clear();\n    }\n  }","commit_id":"568e5ddf9c1f805f269055d20b1601ea58f01304","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Used by ruby code\n   */\n  public static <T> T component(Class<T> type) {\n    return getInstance().getContainer().getComponentByType(type);\n  }","id":84193,"modified_method":"/**\n   * Used by ruby code\n   */\n  @Nullable\n  public static <T> T component(Class<T> type) {\n    if (INSTANCE.started) {\n      return INSTANCE.getContainer().getComponentByType(type);\n    }\n    return null;\n  }","commit_id":"568e5ddf9c1f805f269055d20b1601ea58f01304","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  Profiling getProfiling() {\n    try {\n      return (Profiling) Platform.component(Profiling.class);\n    } catch(Exception initException) {\n      LOG.error(\"Could not initialize platform profiling\", initException);\n      return new Profiling(new Settings());\n    }\n  }","id":84194,"modified_method":"@VisibleForTesting\n  Profiling getProfiling() {\n    Profiling profiling = Platform.component(Profiling.class);\n    if (profiling != null) {\n      return profiling;\n    }\n    return new Profiling(new Settings());\n  }","commit_id":"568e5ddf9c1f805f269055d20b1601ea58f01304","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void invalidateAntlibNamespace() {\n    final AntFile file = getAntFile();\n    if (file == null) return;\n    final ClassLoader loader = file.getClassLoader().getClassloader();\n    if (loader == null) return;\n    final String ns = getNamespace();\n    if (!ns.startsWith(ANTLIB_NS_PREFIX)) return;\n    final AntElement parent = getAntParent();\n    if (!(this instanceof AntProject)) {\n      if (parent instanceof AntStructuredElementImpl && ns.equals(((AntStructuredElementImpl)parent).getNamespace())) return;\n    }\n\n    final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(ns.substring(ANTLIB_NS_PREFIX.length()).replace('.', '/'));\n      builder.append('/');\n      builder.append(ANTLIB_XML);\n      InputStream antlibStream = null;\n      try {\n        try {\n          antlibStream = loader.getResourceAsStream(builder.toString());\n          if (antlibStream != null) {\n            builder.setLength(0);\n            int nextByte;\n            while ((nextByte = antlibStream.read()) >= 0) {\n              builder.append((char)nextByte);\n            }\n          }\n        }\n        finally {\n          if (antlibStream != null) {\n            antlibStream.close();\n          }\n        }\n      }\n      catch (IOException e) {\n        return;\n      }\n      if (antlibStream != null) {\n        final XmlFile xmlFile = (XmlFile)getManager().getElementFactory()\n          .createFileFromText(\"dummy.xml\", StdFileTypes.XML, builder, LocalTimeCounter.currentTime(), false, false);\n        final XmlDocument document = xmlFile.getDocument();\n        if (document == null) return;\n        final XmlTag rootTag = document.getRootTag();\n        if (rootTag == null) return;\n        for (final XmlTag tag : rootTag.getSubTags()) {\n          final AntElement element = AntElementFactory.createAntElement(this, tag);\n          if (element instanceof AntTypeDef) {\n            final AntTypeDefinition def = ((AntTypeDef)element).getDefinition();\n            if (def != null) {\n              if (parent instanceof AntStructuredElementImpl) {\n                ((AntStructuredElementImpl)parent).registerCustomType(def);\n              }\n              else {\n                file.registerCustomType(def);\n              }\n            }\n          }\n        }\n      }\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":84195,"modified_method":"private void invalidateAntlibNamespace() {\n    final AntFile file = getAntFile();\n    if (file == null) return;\n    final ClassLoader loader = file.getClassLoader().getClassloader();\n    if (loader == null) return;\n    final String ns = getNamespace();\n    if (!ns.startsWith(ANTLIB_NS_PREFIX)) return;\n    final AntElement parent = getAntParent();\n    if (!(this instanceof AntProject)) {\n      if (parent instanceof AntStructuredElementImpl && ns.equals(((AntStructuredElementImpl)parent).getNamespace())) return;\n    }\n\n    final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(ns.substring(ANTLIB_NS_PREFIX.length()).replace('.', '/'));\n      builder.append('/');\n      builder.append(ANTLIB_XML);\n      final InputStream antlibStream = loader.getResourceAsStream(builder.toString());\n      if (antlibStream != null) {\n        AntTypeDefImpl.loadAntlibStream(antlibStream, this, ns);\n      }\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"0a17490d279cb2759b66d34e86afcd0259f60769","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clearCaches() {\n    super.clearCaches();\n    if (myNewDefinition != null) {\n      final AntStructuredElement parent = getAntParent();\n      if (parent != null) {\n        parent.unregisterCustomType(myNewDefinition);\n      }\n      myNewDefinition = null;\n      myClassesLoaded = false;\n    }\n    getAntFile().clearCaches();\n  }","id":84196,"modified_method":"public void clearCaches() {\n    super.clearCaches();\n    if (myNewDefinitions != null) {\n      final AntStructuredElement parent = getAntParent();\n      if (parent != null) {\n        for (final AntTypeDefinition def : myNewDefinitions) {\n          parent.unregisterCustomType(def);\n        }\n      }\n      myNewDefinitions = null;\n      myClassesLoaded = false;\n    }\n    final AntFile file = getAntFile();\n    if (file != null) {\n      file.clearCaches();\n    }\n  }","commit_id":"0a17490d279cb2759b66d34e86afcd0259f60769","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    @NonNls final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntTypeDef[\");\n      builder.append(getSourceElement().getName());\n      builder.append(\"]\");\n      if (getDefinition() != null) {\n        builder.append(\" class=\");\n        builder.append(getDefinition().getClassName());\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":84197,"modified_method":"public String toString() {\n    @NonNls final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntTypeDef[\");\n      builder.append(getSourceElement().getName());\n      builder.append(\"]\");\n      final AntTypeDefinition[] defs = getDefinitions();\n      if (defs.length != 0) {\n        builder.append(\" classes={\");\n        builder.append(defs[0].getClassName());\n        for (int i = 1; i < defs.length; ++i) {\n          builder.append(',');\n          builder.append(defs[i].getClassName());\n        }\n        builder.append(\"}\");\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"0a17490d279cb2759b66d34e86afcd0259f60769","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private void loadClass(final String classname) {\n    URL[] urls = ClassEntry.EMPTY_URL_ARRAY;\n    final String classpath = getClassPath();\n    if (classpath != null) {\n      try {\n        if (classpath.indexOf(File.pathSeparatorChar) < 0) {\n          final File file = new File(computeAttributeValue(classpath));\n          urls = new URL[]{file.toURL()};\n        }\n        else {\n          final List<URL> urlList = new ArrayList<URL>();\n          for (final String path : classpath.split(File.pathSeparator)) {\n            final File file = new File(computeAttributeValue(path));\n            urlList.add(file.toURL());\n          }\n          urls = urlList.toArray(new URL[urlList.size()]);\n        }\n      }\n      catch (MalformedURLException e) {\n        urls = ClassEntry.EMPTY_URL_ARRAY;\n      }\n    }\n\n    boolean newlyLoaded = false;\n    Class clazz = CLASS_CACHE.getClass(urls, classname);\n    if (clazz == null) {\n      final AntFile file = getAntFile();\n      if (file != null) {\n        ClassLoader loader = file.getClassLoader().getClassloader();\n        if (urls.length > 0) {\n          loader = new URLClassLoader(urls, loader);\n        }\n        try {\n          if (loader == null) {\n            clazz = Class.forName(classname);\n          }\n          else {\n            clazz = loader.loadClass(classname);\n          }\n          newlyLoaded = true;\n        }\n        catch (ClassNotFoundException e) {\n          myLocalizedError = e.getLocalizedMessage();\n          clazz = null;\n        }\n        catch (NoClassDefFoundError e) {\n          myLocalizedError = e.getLocalizedMessage();\n          clazz = null;\n        }\n        catch (UnsupportedClassVersionError e) {\n          myLocalizedError = e.getLocalizedMessage();\n          clazz = null;\n        }\n      }\n    }\n    final String name = getDefinedName();\n    if (name != null && name.length() > 0) {\n      final String uri = getUri();\n      final String nsPrefix = (uri == null) ? null : getSourceElement().getPrefixByNamespace(uri);\n      final AntTypeId id = (nsPrefix == null) ? new AntTypeId(name) : new AntTypeId(name, nsPrefix);\n      if (clazz == null) {\n        myNewDefinition = new AntTypeDefinitionImpl(id, classname, isTask());\n      }\n      else {\n        myClassesLoaded = true;\n        myNewDefinition = (AntTypeDefinitionImpl)AntFileImpl.createTypeDefinition(id, clazz, Task.class.isAssignableFrom(clazz));\n      }\n      if (myNewDefinition != null) {\n        myNewDefinition.setDefiningElement(this);\n        final AntStructuredElement parent = getAntParent();\n        if (parent != null) {\n          parent.registerCustomType(myNewDefinition);\n        }\n        if (newlyLoaded && clazz != null) {\n          CLASS_CACHE.setClass(urls, classname, clazz);\n        }\n      }\n    }\n  }","id":84198,"modified_method":"private void loadClass(@Nullable final String classname, @Nullable final String name, @Nullable final String uri) {\n\n    if (classname == null || name == null || name.length() == 0) return;\n\n    boolean newlyLoaded = false;\n    final URL[] urls = getClassPathUrls();\n\n    Class clazz = CLASS_CACHE.getClass(urls, classname);\n    if (clazz == null) {\n      ClassLoader loader = getClassLoader(urls);\n      try {\n        if (loader == null) {\n          clazz = Class.forName(classname);\n        }\n        else {\n          clazz = loader.loadClass(classname);\n        }\n        newlyLoaded = true;\n      }\n      catch (ClassNotFoundException e) {\n        myLocalizedError = e.getLocalizedMessage();\n        clazz = null;\n      }\n      catch (NoClassDefFoundError e) {\n        myLocalizedError = e.getLocalizedMessage();\n        clazz = null;\n      }\n      catch (UnsupportedClassVersionError e) {\n        myLocalizedError = e.getLocalizedMessage();\n        clazz = null;\n      }\n    }\n    final String nsPrefix = (uri == null) ? null : getSourceElement().getPrefixByNamespace(uri);\n    final AntTypeId id = (nsPrefix == null) ? new AntTypeId(name) : new AntTypeId(name, nsPrefix);\n    final AntTypeDefinitionImpl def;\n    if (clazz == null) {\n      def = new AntTypeDefinitionImpl(id, classname, isTask());\n    }\n    else {\n      myClassesLoaded = true;\n      def = (AntTypeDefinitionImpl)AntFileImpl.createTypeDefinition(id, clazz, Task.class.isAssignableFrom(clazz));\n    }\n    if (def != null) {\n      myNewDefinitions = new AntTypeDefinition[]{def};\n      def.setDefiningElement(this);\n      final AntStructuredElement parent = getAntParent();\n      if (parent != null) {\n        parent.registerCustomType(def);\n      }\n      if (newlyLoaded && clazz != null) {\n        CLASS_CACHE.setClass(urls, classname, clazz);\n      }\n    }\n  }","commit_id":"0a17490d279cb2759b66d34e86afcd0259f60769","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntTypeDefImpl(final AntElement parent, final XmlTag sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n    getDefinition();\n  }","id":84199,"modified_method":"public AntTypeDefImpl(final AntElement parent, final XmlTag sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n    getDefinitions();\n  }","commit_id":"0a17490d279cb2759b66d34e86afcd0259f60769","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntTypeDefinition getDefinition() {\n    if (myNewDefinition == null) {\n      final String classname = getClassName();\n      if (classname != null) {\n        loadClass(classname);\n      }\n    }\n    return myNewDefinition;\n  }","id":84200,"modified_method":"@NotNull\n  public AntTypeDefinition[] getDefinitions() {\n    if (myNewDefinitions == null) {\n      myNewDefinitions = AntTypeDefinition.EMPTY_ARRAY;\n      final String classname = getClassName();\n      if (classname != null) {\n        loadClass(classname, getDefinedName(), getUri());\n      }\n      else {\n        final String resource = getResource();\n        if (resource != null) {\n          loadResource(resource);\n        }\n        else {\n          final String file = getFile();\n          if (file != null) {\n            loadFile(file);\n          }\n        }\n      }\n    }\n    return myNewDefinitions;\n  }","commit_id":"0a17490d279cb2759b66d34e86afcd0259f60769","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void invalidateAntlibNamespace() {\n    final String ns = getNamespace();\n    if (!ns.startsWith(ANTLIB_NS_PREFIX)) return;\n    if (!(this instanceof AntProject)) {\n      final AntStructuredElementImpl parent = (AntStructuredElementImpl)getAntParent();\n      if (ns.equals(parent.getNamespace())) return;\n    }\n\n    final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(ns.substring(ANTLIB_NS_PREFIX.length()).replace('.', '/'));\n      builder.append('/');\n      builder.append(ANTLIB_XML);\n      InputStream antlibStream = null;\n      try {\n        try {\n          antlibStream = getAntFile().getClassLoader().getClassloader().getResourceAsStream(builder.toString());\n          if (antlibStream != null) {\n            builder.setLength(0);\n            int nextByte;\n            while ((nextByte = antlibStream.read()) >= 0) {\n              builder.append((char)nextByte);\n            }\n          }\n        }\n        finally {\n          if (antlibStream != null) {\n            antlibStream.close();\n          }\n        }\n      }\n      catch (IOException e) {\n        return;\n      }\n      if (antlibStream != null) {\n        final XmlFile xmlFile = (XmlFile)getManager().getElementFactory()\n          .createFileFromText(\"dummy.xml\", StdFileTypes.XML, builder, LocalTimeCounter.currentTime(), false, false);\n        final XmlDocument document = xmlFile.getDocument();\n        if (document == null) return;\n        final XmlTag rootTag = document.getRootTag();\n        if (rootTag == null) return;\n        for (final XmlTag tag : rootTag.getSubTags()) {\n          final AntElement element = AntElementFactory.createAntElement(this, tag);\n          if (element instanceof AntTypeDef) {\n            final AntTypeDefinition def = ((AntTypeDef)element).getDefinition();\n            if (def != null) {\n              registerCustomType(def);\n            }\n          }\n        }\n      }\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":84201,"modified_method":"private void invalidateAntlibNamespace() {\n    final AntFile file = getAntFile();\n    if (file == null) return;\n    final String ns = getNamespace();\n    if (!ns.startsWith(ANTLIB_NS_PREFIX)) return;\n    if (!(this instanceof AntProject)) {\n      final AntElement parent = getAntParent();\n      if (parent instanceof AntStructuredElementImpl && ns.equals(((AntStructuredElementImpl)parent).getNamespace())) return;\n    }\n\n    final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(ns.substring(ANTLIB_NS_PREFIX.length()).replace('.', '/'));\n      builder.append('/');\n      builder.append(ANTLIB_XML);\n      InputStream antlibStream = null;\n      try {\n        try {\n          antlibStream = file.getClassLoader().getClassloader().getResourceAsStream(builder.toString());\n          if (antlibStream != null) {\n            builder.setLength(0);\n            int nextByte;\n            while ((nextByte = antlibStream.read()) >= 0) {\n              builder.append((char)nextByte);\n            }\n          }\n        }\n        finally {\n          if (antlibStream != null) {\n            antlibStream.close();\n          }\n        }\n      }\n      catch (IOException e) {\n        return;\n      }\n      if (antlibStream != null) {\n        final XmlFile xmlFile = (XmlFile)getManager().getElementFactory()\n          .createFileFromText(\"dummy.xml\", StdFileTypes.XML, builder, LocalTimeCounter.currentTime(), false, false);\n        final XmlDocument document = xmlFile.getDocument();\n        if (document == null) return;\n        final XmlTag rootTag = document.getRootTag();\n        if (rootTag == null) return;\n        for (final XmlTag tag : rootTag.getSubTags()) {\n          final AntElement element = AntElementFactory.createAntElement(this, tag);\n          if (element instanceof AntTypeDef) {\n            final AntTypeDefinition def = ((AntTypeDef)element).getDefinition();\n            if (def != null) {\n              registerCustomType(def);\n            }\n          }\n        }\n      }\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"c65ee49bfe0cc53ac9b50d23cd244fef1f89fe0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private void loadClass(final String classname) {\n    URL[] urls = ClassEntry.EMPTY_URL_ARRAY;\n    final String classpath = getClassPath();\n    if (classpath != null) {\n      try {\n        if (classpath.indexOf(File.pathSeparatorChar) < 0) {\n          final File file = new File(computeAttributeValue(classpath));\n          urls = new URL[]{file.toURL()};\n        }\n        else {\n          final List<URL> urlList = new ArrayList<URL>();\n          for (final String path : classpath.split(File.pathSeparator)) {\n            final File file = new File(computeAttributeValue(path));\n            urlList.add(file.toURL());\n          }\n          urls = urlList.toArray(new URL[urlList.size()]);\n        }\n      }\n      catch (MalformedURLException e) {\n        urls = ClassEntry.EMPTY_URL_ARRAY;\n      }\n    }\n\n    boolean newlyLoaded = false;\n    Class clazz = CLASS_CACHE.getClass(urls, classname);\n    if (clazz == null) {\n      ClassLoader loader = getAntFile().getClassLoader().getClassloader();\n      if (urls.length > 0) {\n        loader = new URLClassLoader(urls, loader);\n      }\n      try {\n        if (loader == null) {\n          clazz = Class.forName(classname);\n        }\n        else {\n          clazz = loader.loadClass(classname);\n        }\n        newlyLoaded = true;\n      }\n      catch (Exception e) {\n        clazz = null;\n      }\n    }\n    final String name = getDefinedName();\n    if (name != null && name.length() > 0) {\n      final String uri = getUri();\n      final String nsPrefix = (uri == null) ? null : getSourceElement().getPrefixByNamespace(uri);\n      final AntTypeId id = (nsPrefix == null) ? new AntTypeId(name) : new AntTypeId(name, nsPrefix);\n      if (clazz == null) {\n        myNewDefinition = new AntTypeDefinitionImpl(id, classname, isTask());\n      }\n      else {\n        myClassesLoaded = true;\n        myNewDefinition = (AntTypeDefinitionImpl)AntFileImpl.createTypeDefinition(id, clazz, Task.class.isAssignableFrom(clazz));\n      }\n      if (myNewDefinition != null) {\n        myNewDefinition.setDefiningElement(this);\n        final AntStructuredElement parent = getAntParent();\n        if (parent != null) {\n          parent.registerCustomType(myNewDefinition);\n        }\n        if (newlyLoaded && clazz != null) {\n          CLASS_CACHE.setClass(urls, classname, clazz);\n        }\n      }\n    }\n  }","id":84202,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private void loadClass(final String classname) {\n    URL[] urls = ClassEntry.EMPTY_URL_ARRAY;\n    final String classpath = getClassPath();\n    if (classpath != null) {\n      try {\n        if (classpath.indexOf(File.pathSeparatorChar) < 0) {\n          final File file = new File(computeAttributeValue(classpath));\n          urls = new URL[]{file.toURL()};\n        }\n        else {\n          final List<URL> urlList = new ArrayList<URL>();\n          for (final String path : classpath.split(File.pathSeparator)) {\n            final File file = new File(computeAttributeValue(path));\n            urlList.add(file.toURL());\n          }\n          urls = urlList.toArray(new URL[urlList.size()]);\n        }\n      }\n      catch (MalformedURLException e) {\n        urls = ClassEntry.EMPTY_URL_ARRAY;\n      }\n    }\n\n    boolean newlyLoaded = false;\n    Class clazz = CLASS_CACHE.getClass(urls, classname);\n    if (clazz == null) {\n      final AntFile file = getAntFile();\n      if (file != null) {\n        ClassLoader loader = file.getClassLoader().getClassloader();\n        if (urls.length > 0) {\n          loader = new URLClassLoader(urls, loader);\n        }\n        try {\n          if (loader == null) {\n            clazz = Class.forName(classname);\n          }\n          else {\n            clazz = loader.loadClass(classname);\n          }\n          newlyLoaded = true;\n        }\n        catch (Exception e) {\n          clazz = null;\n        }\n      }\n    }\n    final String name = getDefinedName();\n    if (name != null && name.length() > 0) {\n      final String uri = getUri();\n      final String nsPrefix = (uri == null) ? null : getSourceElement().getPrefixByNamespace(uri);\n      final AntTypeId id = (nsPrefix == null) ? new AntTypeId(name) : new AntTypeId(name, nsPrefix);\n      if (clazz == null) {\n        myNewDefinition = new AntTypeDefinitionImpl(id, classname, isTask());\n      }\n      else {\n        myClassesLoaded = true;\n        myNewDefinition = (AntTypeDefinitionImpl)AntFileImpl.createTypeDefinition(id, clazz, Task.class.isAssignableFrom(clazz));\n      }\n      if (myNewDefinition != null) {\n        myNewDefinition.setDefiningElement(this);\n        final AntStructuredElement parent = getAntParent();\n        if (parent != null) {\n          parent.registerCustomType(myNewDefinition);\n        }\n        if (newlyLoaded && clazz != null) {\n          CLASS_CACHE.setClass(urls, classname, clazz);\n        }\n      }\n    }\n  }","commit_id":"c65ee49bfe0cc53ac9b50d23cd244fef1f89fe0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlAttributeSet(final XmlAttributeSet xmlAttributeSet) {\n    final XmlTag tag = xmlAttributeSet.getTag();\n    if (AntFileImpl.BASEDIR_ATTR.equals(xmlAttributeSet.getName())) {\n      getAntFile(tag).clearCaches();\n    }\n    else {\n      clearParentCaches(tag);\n    }\n  }","id":84203,"modified_method":"public void visitXmlAttributeSet(final XmlAttributeSet xmlAttributeSet) {\n    final XmlTag tag = xmlAttributeSet.getTag();\n    if (AntFileImpl.BASEDIR_ATTR.equals(xmlAttributeSet.getName())) {\n      final AntFile antFile = getAntFile(tag);\n      if (antFile != null) {\n        antFile.clearCaches();\n      }\n    }\n    else {\n      clearParentCaches(tag);\n    }\n  }","commit_id":"a1b9d5502672ffa3a66cee32fecf8c4a7c8faa5c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Authenticates the third-party consumer and returns\n     * {@link OAuthInfo} bean capturing the information about the request. \n     * @param req http request\n     * @return OAuth info\n     * @see OAuthInfo\n     * @throws Exception\n     * @throws OAuthProblemException\n     */\n    protected OAuthInfo handleOAuthRequest(HttpServletRequest req,\n                                           boolean useUserSubject) throws\n        Exception, OAuthProblemException {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.log(Level.FINE, \"OAuth security filter for url: {0}\", req.getRequestURL());\n        }\n        \n        AccessToken accessToken = null;\n        Client client = null;\n        \n        OAuthMessage oAuthMessage = OAuthServlet.getMessage(req, req.getRequestURL().toString());\n        if (oAuthMessage.getParameter(OAuth.OAUTH_TOKEN) != null) {\n            oAuthMessage.requireParameters(REQUIRED_PARAMETERS);\n\n            accessToken = dataProvider.getAccessToken(oAuthMessage.getToken());\n\n            //check if access token is not null\n            if (accessToken == null) {\n                LOG.warning(\"Access token is unavailable\");\n                throw new OAuthProblemException(OAuth.Problems.TOKEN_REJECTED);\n            }\n            client = accessToken.getClient(); \n            \n        } else {\n            // TODO: the secret may not be included and only used to create a signature\n            //       so the header will effectively be similar to the one used during \n            //       RequestToken requests; we'd need to handle this case too\n            String consumerKey = oAuthMessage.getParameter(OAuth.OAUTH_CONSUMER_KEY);\n            String consumerSecret = oAuthMessage.getParameter(\"oauth_consumer_secret\");\n            client = dataProvider.getClient(consumerKey);\n            if (client == null || consumerSecret == null || !consumerSecret.equals(client.getSecretKey())) {\n                LOG.warning(\"Client is invalid\");\n                throw new OAuthProblemException(OAuth.Problems.CONSUMER_KEY_UNKNOWN);\n            }\n        }\n\n        OAuthUtils.validateMessage(oAuthMessage, client, accessToken, dataProvider);\n\n        //check valid URI\n        checkRequestURI(req, OAuthUtils.getAllUris(client, accessToken));\n        \n        List<OAuthPermission> permissions = dataProvider.getPermissionsInfo(\n                OAuthUtils.getAllScopes(client, accessToken));\n        \n        for (OAuthPermission perm : permissions) {\n            checkRequestURI(req, perm.getUris());\n            if (!perm.getHttpVerbs().isEmpty() \n                && !perm.getHttpVerbs().contains(req.getMethod())) {\n                String message = \"Invalid http verb\";\n                LOG.warning(message);\n                throw new OAuthProblemException(message);\n            }\n            checkNoAccessTokenIsAllowed(client, accessToken, perm);\n        }\n        \n        return new OAuthInfo(client, accessToken, permissions, useUserSubject);\n        \n    }","id":84204,"modified_method":"/**\n     * Authenticates the third-party consumer and returns\n     * {@link OAuthInfo} bean capturing the information about the request. \n     * @param req http request\n     * @return OAuth info\n     * @see OAuthInfo\n     * @throws Exception\n     * @throws OAuthProblemException\n     */\n    protected OAuthInfo handleOAuthRequest(HttpServletRequest req,\n                                           boolean useUserSubject) throws\n        Exception, OAuthProblemException {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.log(Level.FINE, \"OAuth security filter for url: {0}\", req.getRequestURL());\n        }\n        \n        AccessToken accessToken = null;\n        Client client = null;\n        \n        OAuthMessage oAuthMessage = OAuthServlet.getMessage(new CustomHttpServletWrapper(req), \n                                                            OAuthServlet.getRequestURL(req));\n        if (oAuthMessage.getParameter(OAuth.OAUTH_TOKEN) != null) {\n            oAuthMessage.requireParameters(REQUIRED_PARAMETERS);\n\n            accessToken = dataProvider.getAccessToken(oAuthMessage.getToken());\n\n            //check if access token is not null\n            if (accessToken == null) {\n                LOG.warning(\"Access token is unavailable\");\n                throw new OAuthProblemException(OAuth.Problems.TOKEN_REJECTED);\n            }\n            client = accessToken.getClient(); \n            \n        } else {\n            // TODO: the secret may not be included and only used to create a signature\n            //       so the header will effectively be similar to the one used during \n            //       RequestToken requests; we'd need to handle this case too\n            String consumerKey = oAuthMessage.getParameter(OAuth.OAUTH_CONSUMER_KEY);\n            String consumerSecret = oAuthMessage.getParameter(\"oauth_consumer_secret\");\n            client = dataProvider.getClient(consumerKey);\n            if (client == null || consumerSecret == null || !consumerSecret.equals(client.getSecretKey())) {\n                LOG.warning(\"Client is invalid\");\n                throw new OAuthProblemException(OAuth.Problems.CONSUMER_KEY_UNKNOWN);\n            }\n        }\n\n        OAuthUtils.validateMessage(oAuthMessage, client, accessToken, dataProvider);\n\n        //check valid URI\n        checkRequestURI(req, OAuthUtils.getAllUris(client, accessToken));\n        \n        List<OAuthPermission> permissions = dataProvider.getPermissionsInfo(\n                OAuthUtils.getAllScopes(client, accessToken));\n        \n        for (OAuthPermission perm : permissions) {\n            checkRequestURI(req, perm.getUris());\n            if (!perm.getHttpVerbs().isEmpty() \n                && !perm.getHttpVerbs().contains(req.getMethod())) {\n                String message = \"Invalid http verb\";\n                LOG.warning(message);\n                throw new OAuthProblemException(message);\n            }\n            checkNoAccessTokenIsAllowed(client, accessToken, perm);\n        }\n        \n        return new OAuthInfo(client, accessToken, permissions, useUserSubject);\n        \n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"public Response handle(MessageContext mc, OAuthDataProvider dataProvider) {\n        try {\n            OAuthMessage oAuthMessage = \n                OAuthUtils.getOAuthMessage(mc, mc.getHttpServletRequest(), REQUIRED_PARAMETERS);\n\n            RequestToken requestToken = dataProvider.getRequestToken(oAuthMessage.getToken());\n            if (requestToken == null) {\n                throw new OAuthProblemException(OAuth.Problems.TOKEN_REJECTED);\n            }\n            String oauthVerifier = oAuthMessage.getParameter(OAuth.OAUTH_VERIFIER);\n            if (oauthVerifier == null || !oauthVerifier.equals(requestToken.getVerifier())) {\n                throw new OAuthProblemException(OAuthConstants.VERIFIER_INVALID);\n            }\n            \n            OAuthUtils.validateMessage(oAuthMessage, requestToken.getClient(), requestToken,\n                                       dataProvider);\n\n            AccessToken accessToken = dataProvider.createAccessToken(requestToken);\n\n            //create response\n            Map<String, Object> responseParams = new HashMap<String, Object>();\n            responseParams.put(OAuth.OAUTH_TOKEN, accessToken.getTokenKey());\n            responseParams.put(OAuth.OAUTH_TOKEN_SECRET, accessToken.getTokenSecret());\n\n            String responseString = OAuth.formEncode(responseParams.entrySet());\n            return Response.ok(responseString).build();\n\n        } catch (OAuthProblemException e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"An OAuth-related problem: {0}\", new Object[] {e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, e.getHttpStatusCode(),\n                String.valueOf(e.getParameters().get(\"realm\")));\n        } catch (Exception e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"Server Exception: {0}\", new Object[] {e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }","id":84205,"modified_method":"public Response handle(MessageContext mc, OAuthDataProvider dataProvider) {\n        try {\n            OAuthMessage oAuthMessage = \n                OAuthUtils.getOAuthMessage(mc, mc.getHttpServletRequest(), REQUIRED_PARAMETERS);\n\n            RequestToken requestToken = dataProvider.getRequestToken(oAuthMessage.getToken());\n            if (requestToken == null) {\n                throw new OAuthProblemException(OAuth.Problems.TOKEN_REJECTED);\n            }\n            String oauthVerifier = oAuthMessage.getParameter(OAuth.OAUTH_VERIFIER);\n            if (oauthVerifier == null || !oauthVerifier.equals(requestToken.getVerifier())) {\n                throw new OAuthProblemException(OAuthConstants.VERIFIER_INVALID);\n            }\n            \n            OAuthUtils.validateMessage(oAuthMessage, requestToken.getClient(), requestToken,\n                                       dataProvider);\n\n            AccessToken accessToken = dataProvider.createAccessToken(requestToken);\n\n            //create response\n            Map<String, Object> responseParams = new HashMap<String, Object>();\n            responseParams.put(OAuth.OAUTH_TOKEN, accessToken.getTokenKey());\n            responseParams.put(OAuth.OAUTH_TOKEN_SECRET, accessToken.getTokenSecret());\n\n            String responseString = OAuth.formEncode(responseParams.entrySet());\n            return Response.ok(responseString).build();\n\n        } catch (OAuthProblemException e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"An OAuth-related problem: {0}\", new Object[] {e.fillInStackTrace()});\n            }\n            int code = e.getHttpStatusCode();\n            if (code == 200) {\n                code = HttpServletResponse.SC_UNAUTHORIZED; \n            }\n            return OAuthUtils.handleException(e, code, String.valueOf(e.getParameters().get(\"realm\")));\n        } catch (Exception e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"Server Exception: {0}\", new Object[] {e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"public Response handle(MessageContext mc, OAuthDataProvider dataProvider) {\n        HttpServletRequest request = mc.getHttpServletRequest();\n        try {\n            OAuthMessage oAuthMessage = \n                OAuthUtils.getOAuthMessage(mc, request, REQUIRED_PARAMETERS);\n            new DefaultOAuthValidator().checkSingleParameter(oAuthMessage);\n\n            RequestToken token = dataProvider.getRequestToken(oAuthMessage.getToken());\n            if (token == null) {\n                throw new OAuthProblemException(OAuth.Problems.TOKEN_REJECTED);\n            }\n            \n            OAuthAuthorizationData secData = new OAuthAuthorizationData();\n            if (!compareRequestSessionTokens(request, oAuthMessage)) {\n                addAuthenticityTokenToSession(secData, request);\n                return Response.ok(\n                        addAdditionalParams(secData, dataProvider, token)).build();\n            }\n            \n            String decision = oAuthMessage.getParameter(OAuthConstants.AUTHORIZATION_DECISION_KEY);\n            boolean allow = OAuthConstants.AUTHORIZATION_DECISION_ALLOW.equals(decision);\n\n            Map<String, String> queryParams = new HashMap<String, String>();\n            if (allow) {\n                SecurityContext sc = mc.getSecurityContext();\n                List<String> roleNames = Collections.emptyList();\n                if (sc instanceof LoginSecurityContext) {\n                    roleNames = new ArrayList<String>();\n                    Set<Principal> roles = ((LoginSecurityContext)sc).getUserRoles();\n                    for (Principal p : roles) {\n                        roleNames.add(p.getName());\n                    }\n                }\n                token.setSubject(new UserSubject(sc.getUserPrincipal().getName(),\n                                                 roleNames));\n                \n                String verifier = dataProvider.setRequestTokenVerifier(token);\n                queryParams.put(OAuth.OAUTH_VERIFIER, verifier);\n            } else {\n                dataProvider.removeToken(token);\n            }\n            queryParams.put(OAuth.OAUTH_TOKEN, token.getTokenKey());\n            if (token.getState() != null) {\n                queryParams.put(\"state\", token.getState());\n            }\n            URI callback = buildCallbackURI(getCallbackURI(token), queryParams);\n            return Response.seeOther(callback).build();\n            \n        } catch (OAuthProblemException e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"An OAuth related problem: {0}\", new Object[]{e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, e.getHttpStatusCode(),\n                    String.valueOf(e.getParameters().get(\"realm\")));\n        } catch (Exception e) {\n            if (LOG.isLoggable(Level.SEVERE)) {\n                LOG.log(Level.SEVERE, \"Server exception: {0}\", new Object[]{e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }","id":84206,"modified_method":"public Response handle(MessageContext mc, OAuthDataProvider dataProvider) {\n        HttpServletRequest request = mc.getHttpServletRequest();\n        try {\n            OAuthMessage oAuthMessage = \n                OAuthUtils.getOAuthMessage(mc, request, REQUIRED_PARAMETERS);\n            new DefaultOAuthValidator().checkSingleParameter(oAuthMessage);\n\n            RequestToken token = dataProvider.getRequestToken(oAuthMessage.getToken());\n            if (token == null) {\n                throw new OAuthProblemException(OAuth.Problems.TOKEN_REJECTED);\n            }\n            \n            OAuthAuthorizationData secData = new OAuthAuthorizationData();\n            if (!compareRequestSessionTokens(request, oAuthMessage)) {\n                addAuthenticityTokenToSession(secData, request);\n                return Response.ok(\n                        addAdditionalParams(secData, dataProvider, token)).build();\n            }\n            \n            String decision = oAuthMessage.getParameter(OAuthConstants.AUTHORIZATION_DECISION_KEY);\n            boolean allow = OAuthConstants.AUTHORIZATION_DECISION_ALLOW.equals(decision);\n\n            Map<String, String> queryParams = new HashMap<String, String>();\n            if (allow) {\n                SecurityContext sc = mc.getSecurityContext();\n                List<String> roleNames = Collections.emptyList();\n                if (sc instanceof LoginSecurityContext) {\n                    roleNames = new ArrayList<String>();\n                    Set<Principal> roles = ((LoginSecurityContext)sc).getUserRoles();\n                    for (Principal p : roles) {\n                        roleNames.add(p.getName());\n                    }\n                }\n                token.setSubject(new UserSubject(sc.getUserPrincipal().getName(),\n                                                 roleNames));\n                \n                String verifier = dataProvider.setRequestTokenVerifier(token);\n                queryParams.put(OAuth.OAUTH_VERIFIER, verifier);\n            } else {\n                dataProvider.removeToken(token);\n            }\n            queryParams.put(OAuth.OAUTH_TOKEN, token.getTokenKey());\n            if (token.getState() != null) {\n                queryParams.put(\"state\", token.getState());\n            }\n            URI callback = buildCallbackURI(getCallbackURI(token), queryParams);\n            return Response.seeOther(callback).build();\n            \n        } catch (OAuthProblemException e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"An OAuth related problem: {0}\", new Object[]{e.fillInStackTrace()});\n            }\n            int code = e.getHttpStatusCode();\n            if (code == 200) {\n                code = HttpServletResponse.SC_UNAUTHORIZED; \n            }\n            return OAuthUtils.handleException(e, code, String.valueOf(e.getParameters().get(\"realm\")));\n        } catch (Exception e) {\n            if (LOG.isLoggable(Level.SEVERE)) {\n                LOG.log(Level.SEVERE, \"Server exception: {0}\", new Object[]{e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"private static String doGetAuthorizationHeader(OAuthAccessor accessor, \n            String method, String requestURI, Map<String, String> parameters) {\n        try {\n            OAuthMessage msg = accessor.newRequestMessage(method, requestURI, parameters.entrySet());\n            return msg.getAuthorizationHeader(null);\n        } catch (Exception ex) {\n            throw new ClientWebApplicationException(ex);\n        }\n    }","id":84207,"modified_method":"private static String doGetAuthorizationHeader(OAuthAccessor accessor, \n            String method, String requestURI, Map<String, String> parameters) {\n        try {\n            OAuthMessage msg = accessor.newRequestMessage(method, requestURI, parameters.entrySet());\n            StringBuilder sb = new StringBuilder();\n            sb.append(msg.getAuthorizationHeader(null));\n            for (Map.Entry<String, String> entry : parameters.entrySet()) {\n                if (!entry.getKey().startsWith(\"oauth_\")) {\n                    sb.append(\", \");\n                    sb.append(OAuth.percentEncode(entry.getKey())).append(\"=\\\"\");\n                    sb.append(OAuth.percentEncode(entry.getValue())).append('\"');\n                }\n            }\n            return sb.toString();\n        } catch (Exception ex) {\n            throw new ClientWebApplicationException(ex);\n        }\n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"public OAuthPermission(String permission, String description, String role) {\n        this(permission, description, Collections.singletonList(role));\n    }","id":84208,"modified_method":"public OAuthPermission(String permission, String description) {\n        super(permission, description);\n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"public static List<String> parseParamValue(String paramValue, String defaultValue) \n        throws IOException {\n        \n        List<String> scopeList = new ArrayList<String>();\n\n        if (!StringUtils.isEmpty(paramValue)) {\n            StringTokenizer tokenizer = new StringTokenizer(paramValue, \",\");\n\n            while (tokenizer.hasMoreTokens()) {\n                String token = tokenizer.nextToken();\n                scopeList.add(token);\n            }\n        }\n        if (defaultValue != null) {\n            scopeList.add(defaultValue);\n        }\n        return scopeList;\n    }","id":84209,"modified_method":"public static List<String> parseParamValue(String paramValue, String defaultValue) \n        throws IOException {\n        \n        List<String> scopeList = new ArrayList<String>();\n\n        if (!StringUtils.isEmpty(paramValue)) {\n            StringTokenizer tokenizer = new StringTokenizer(paramValue, \",\");\n\n            while (tokenizer.hasMoreTokens()) {\n                String token = tokenizer.nextToken();\n                scopeList.add(token);\n            }\n        }\n        if (defaultValue != null && !scopeList.contains(defaultValue)) {\n            scopeList.add(defaultValue);\n        }\n        return scopeList;\n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"public Response handle(MessageContext mc, OAuthDataProvider dataProvider) {\n        try {\n            OAuthMessage oAuthMessage = \n                OAuthUtils.getOAuthMessage(mc, mc.getHttpServletRequest(), REQUIRED_PARAMETERS);\n\n            Client client = dataProvider\n                .getClient(oAuthMessage.getParameter(OAuth.OAUTH_CONSUMER_KEY));\n            //client credentials not found\n            if (client == null) {\n                OAuthProblemException problemEx = new OAuthProblemException(\n                    OAuth.Problems.CONSUMER_KEY_UNKNOWN);\n                problemEx\n                    .setParameter(OAuthProblemException.HTTP_STATUS_CODE,\n                        HttpServletResponse.SC_UNAUTHORIZED);\n                throw problemEx;\n            }\n\n            OAuthUtils.validateMessage(oAuthMessage, client, null, dataProvider);\n\n            String callback = oAuthMessage.getParameter(OAuth.OAUTH_CALLBACK);\n            validateCallbackURL(client, callback);\n\n            List<String> scopes = OAuthUtils.parseParamValue(\n                    oAuthMessage.getParameter(OAuthConstants.X_OAUTH_SCOPE), defaultScope);\n            List<String> uris = OAuthUtils.parseParamValue(\n                    oAuthMessage.getParameter(OAuthConstants.X_OAUTH_URI), defaultURI);\n            \n            RequestTokenRegistration reg = new RequestTokenRegistration();\n            reg.setClient(client);\n            reg.setCallback(callback);\n            reg.setState(oAuthMessage.getParameter(\"state\"));\n            reg.setUris(uris);\n            reg.setScopes(scopes);\n            reg.setLifetime(tokenLifetime);\n            reg.setIssuedAt(System.currentTimeMillis() / 1000);\n            \n            RequestToken requestToken = dataProvider.createRequestToken(reg);\n\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Preparing Temporary Credentials Endpoint correct response\");\n            }\n            //create response\n            Map<String, Object> responseParams = new HashMap<String, Object>();\n            responseParams.put(OAuth.OAUTH_TOKEN, requestToken.getTokenKey());\n            responseParams.put(OAuth.OAUTH_TOKEN_SECRET, requestToken.getTokenSecret());\n            responseParams.put(OAuth.OAUTH_CALLBACK_CONFIRMED, Boolean.TRUE);\n\n            String responseBody = OAuth.formEncode(responseParams.entrySet());\n\n            return Response.ok(responseBody).build();\n        } catch (OAuthProblemException e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"An OAuth-related problem: {0}\", new Object[] {e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, e.getHttpStatusCode(),\n                String.valueOf(e.getParameters().get(\"realm\")));\n        } catch (Exception e) {\n            if (LOG.isLoggable(Level.SEVERE)) {\n                LOG.log(Level.SEVERE, \"Unexpected internal server exception: {0}\",\n                    new Object[] {e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }","id":84210,"modified_method":"public Response handle(MessageContext mc, OAuthDataProvider dataProvider) {\n        try {\n            OAuthMessage oAuthMessage = \n                OAuthUtils.getOAuthMessage(mc, mc.getHttpServletRequest(), REQUIRED_PARAMETERS);\n\n            Client client = dataProvider\n                .getClient(oAuthMessage.getParameter(OAuth.OAUTH_CONSUMER_KEY));\n            //client credentials not found\n            if (client == null) {\n                throw new OAuthProblemException(OAuth.Problems.CONSUMER_KEY_UNKNOWN);\n            }\n\n            OAuthUtils.validateMessage(oAuthMessage, client, null, dataProvider);\n\n            String callback = oAuthMessage.getParameter(OAuth.OAUTH_CALLBACK);\n            validateCallbackURL(client, callback);\n\n            List<String> scopes = OAuthUtils.parseParamValue(\n                    oAuthMessage.getParameter(OAuthConstants.X_OAUTH_SCOPE), defaultScope);\n            List<String> uris = OAuthUtils.parseParamValue(\n                    oAuthMessage.getParameter(OAuthConstants.X_OAUTH_URI), defaultURI);\n            \n            RequestTokenRegistration reg = new RequestTokenRegistration();\n            reg.setClient(client);\n            reg.setCallback(callback);\n            reg.setState(oAuthMessage.getParameter(\"state\"));\n            reg.setUris(uris);\n            reg.setScopes(scopes);\n            reg.setLifetime(tokenLifetime);\n            reg.setIssuedAt(System.currentTimeMillis() / 1000);\n            \n            RequestToken requestToken = dataProvider.createRequestToken(reg);\n\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Preparing Temporary Credentials Endpoint correct response\");\n            }\n            //create response\n            Map<String, Object> responseParams = new HashMap<String, Object>();\n            responseParams.put(OAuth.OAUTH_TOKEN, requestToken.getTokenKey());\n            responseParams.put(OAuth.OAUTH_TOKEN_SECRET, requestToken.getTokenSecret());\n            responseParams.put(OAuth.OAUTH_CALLBACK_CONFIRMED, Boolean.TRUE);\n\n            String responseBody = OAuth.formEncode(responseParams.entrySet());\n\n            return Response.ok(responseBody).build();\n        } catch (OAuthProblemException e) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING, \"An OAuth-related problem: {0}\", new Object[] {e.fillInStackTrace()});\n            }\n            int code = e.getHttpStatusCode();\n            if (code == 200) {\n                code = HttpServletResponse.SC_UNAUTHORIZED; \n            }\n            return OAuthUtils.handleException(e, code, String.valueOf(e.getParameters().get(\"realm\")));\n        } catch (Exception e) {\n            if (LOG.isLoggable(Level.SEVERE)) {\n                LOG.log(Level.SEVERE, \"Unexpected internal server exception: {0}\",\n                    new Object[] {e.fillInStackTrace()});\n            }\n            return OAuthUtils.handleException(e, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }","commit_id":"3e37bddd68e98bcb359c74a1a4c13a3270574470","url":"https://github.com/apache/cxf"},{"original_method":"@Before\n\tpublic void setup() throws Exception {\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\t}","id":84211,"modified_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tthis.wac = new AnnotationConfigWebApplicationContext();\n\t\tthis.wac.register(getAnnotatedConfigClasses());\n\t\tthis.wac.register(upgradeStrategyConfigTypes.get(this.server.getClass()));\n\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\n\t\tthis.server.init(this.wac);\n\t\tthis.server.start();\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setup() throws Exception {\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\t}","id":84212,"modified_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tthis.wac = new AnnotationConfigWebApplicationContext();\n\t\tthis.wac.register(getAnnotatedConfigClasses());\n\t\tthis.wac.register(upgradeStrategyConfigTypes.get(this.server.getClass()));\n\n\t\tif (this.webSocketClient instanceof Lifecycle) {\n\t\t\t((Lifecycle) this.webSocketClient).start();\n\t\t}\n\n\t\tthis.server.init(this.wac);\n\t\tthis.server.start();\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic HandlerMapping webSocketHandlerMapping() {\n\t\tWebSocketHandlerRegistry registry = new WebSocketHandlerRegistry(defaultSockJsTaskScheduler());\n\t\tregisterWebSocketHandlers(registry);\n\t\treturn registry.getHandlerMapping();\n\t}","id":84213,"modified_method":"@Bean\n\tpublic HandlerMapping webSocketHandlerMapping() {\n\t\tServletWebSocketHandlerRegistry registry = new ServletWebSocketHandlerRegistry(defaultSockJsTaskScheduler());\n\t\tregisterWebSocketHandlers(registry);\n\t\tAbstractHandlerMapping hm = registry.getHandlerMapping();\n\t\thm.setOrder(1);\n\t\treturn hm;\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void registerWebSocketHandlerWithSockJS() throws Exception {\n\n\t\tAnnotationConfigWebApplicationContext cxt = new AnnotationConfigWebApplicationContext();\n\t\tcxt.register(TestWebSocketConfigurer.class, getUpgradeStrategyConfigClass());\n\n\t\tthis.server.init(cxt);\n\t\tthis.server.start();\n\n\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/sockjs/websocket\");\n\n\t\tTestWebSocketHandler serverHandler = cxt.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\t}","id":84214,"modified_method":"@Test\n\tpublic void registerWebSocketHandlerWithSockJS() throws Exception {\n\n\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/sockjs/websocket\");\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void registerWebSocketHandler() throws Exception {\n\n\t\tAnnotationConfigWebApplicationContext cxt = new AnnotationConfigWebApplicationContext();\n\t\tcxt.register(TestWebSocketConfigurer.class, getUpgradeStrategyConfigClass());\n\n\t\tthis.server.init(cxt);\n\t\tthis.server.start();\n\n\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/ws\");\n\n\t\tTestWebSocketHandler serverHandler = cxt.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\t}","id":84215,"modified_method":"@Test\n\tpublic void registerWebSocketHandler() throws Exception {\n\n\t\tthis.webSocketClient.doHandshake(new WebSocketHandlerAdapter(), getWsBaseUrl() + \"/ws\");\n\n\t\tTestWebSocketHandler serverHandler = this.wac.getBean(TestWebSocketHandler.class);\n\t\tassertTrue(serverHandler.latch.await(2, TimeUnit.SECONDS));\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic HandlerMapping brokerWebSocketHandlerMapping() {\n\t\tStompEndpointRegistry registry = new StompEndpointRegistry(\n\t\t\t\tsubProtocolWebSocketHandler(), userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler());\n\t\tregisterStompEndpoints(registry);\n\t\treturn registry.getHandlerMapping();\n\t}","id":84216,"modified_method":"@Bean\n\tpublic HandlerMapping brokerWebSocketHandlerMapping() {\n\t\tServletStompEndpointRegistry registry = new ServletStompEndpointRegistry(\n\t\t\t\tsubProtocolWebSocketHandler(), userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler());\n\t\tregisterStompEndpoints(registry);\n\t\tAbstractHandlerMapping hm = registry.getHandlerMapping();\n\t\thm.setOrder(1);\n\t\treturn hm;\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sendMessage() throws Exception {\n\n\t\tAnnotationConfigWebApplicationContext cxt = new AnnotationConfigWebApplicationContext();\n\t\tcxt.register(TestWebSocketMessageBrokerConfiguration.class, SimpleBrokerConfigurer.class);\n\t\tcxt.register(getUpgradeStrategyConfigClass());\n\n\t\tthis.server.init(cxt);\n\t\tthis.server.start();\n\n\t\tfinal TextMessage textMessage = StompTextMessageBuilder.create(StompCommand.SEND)\n\t\t\t\t.headers(\"destination:/app/foo\").build();\n\n\t\tWebSocketHandler clientHandler = new TextWebSocketHandlerAdapter() {\n\t\t\t@Override\n\t\t\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t\t\t\tsession.sendMessage(textMessage);\n\t\t\t}\n\t\t};\n\n\t\tTestController testController = cxt.getBean(TestController.class);\n\n\t\tthis.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/ws\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\n\t\ttestController.latch = new CountDownLatch(1);\n\t\tthis.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/sockjs/websocket\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\t}","id":84217,"modified_method":"@Test\n\tpublic void sendMessage() throws Exception {\n\n\t\tfinal TextMessage textMessage = StompTextMessageBuilder.create(StompCommand.SEND)\n\t\t\t\t.headers(\"destination:/app/foo\").build();\n\n\t\tWebSocketHandler clientHandler = new TextWebSocketHandlerAdapter() {\n\t\t\t@Override\n\t\t\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t\t\t\tsession.sendMessage(textMessage);\n\t\t\t}\n\t\t};\n\n\t\tTestController testController = this.wac.getBean(TestController.class);\n\n\t\tthis.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/ws\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\n\t\ttestController.latch = new CountDownLatch(1);\n\t\tthis.webSocketClient.doHandshake(clientHandler, getWsBaseUrl() + \"/sockjs/websocket\");\n\t\tassertTrue(testController.latch.await(2, TimeUnit.SECONDS));\n\t}","commit_id":"e21bbdd933050f829b55eb67ee8ae5a39a12b6e9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testMessageCodesResolver() {\n\t\tloadBeanDefinitions(\"mvc-config-message-codes-resolver.xml\");\n\t\tRequestMappingHandlerAdapter adapter = appContext.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertNotNull(adapter);\n\t\tObject initializer = new DirectFieldAccessor(adapter).getPropertyValue(\"webBindingInitializer\");\n\t\tassertNotNull(initializer);\n\t\tMessageCodesResolver resolver = ((ConfigurableWebBindingInitializer) initializer).getMessageCodesResolver();\n\t\tassertNotNull(resolver);\n\t\tassertEquals(TestMessageCodesResolver.class, resolver.getClass());\n\t}","id":84218,"modified_method":"@Test\n\tpublic void testMessageCodesResolver() {\n\t\tloadBeanDefinitions(\"mvc-config-message-codes-resolver.xml\");\n\t\tRequestMappingHandlerAdapter adapter = appContext.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertNotNull(adapter);\n\t\tObject initializer = adapter.getWebBindingInitializer();\n\t\tassertNotNull(initializer);\n\t\tMessageCodesResolver resolver = ((ConfigurableWebBindingInitializer) initializer).getMessageCodesResolver();\n\t\tassertNotNull(resolver);\n\t\tassertEquals(TestMessageCodesResolver.class, resolver.getClass());\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return a {@link SimpleUrlHandlerMapping} instance ordered at {@link Integer#MAX_VALUE} containing a\n\t * {@link DefaultServletHttpRequestHandler} mapped to {@code /**}.\n\t */\n\tprotected SimpleUrlHandlerMapping getHandlerMapping() {\n\t\tSimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();\n\t\thandlerMapping.setOrder(Integer.MAX_VALUE);\n\t\thandlerMapping.setUrlMap(getUrlMap());\n\t\treturn handlerMapping;\n\t}","id":84219,"modified_method":"/**\n\t * Return a handler mapping instance ordered at {@link Integer#MAX_VALUE} containing the\n\t * {@link DefaultServletHttpRequestHandler} instance mapped to {@code \"/**\"}; or {@code null} if \n\t * default servlet handling was not been enabled.\n\t */\n\tprotected AbstractHandlerMapping getHandlerMapping() {\n\t\tif (handler == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String, HttpRequestHandler> urlMap = new HashMap<String, HttpRequestHandler>();\n\t\turlMap.put(\"/**\", handler);\n\n\t\tSimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();\n\t\thandlerMapping.setOrder(Integer.MAX_VALUE);\n\t\thandlerMapping.setUrlMap(urlMap);\n\t\treturn handlerMapping;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Enable forwarding to the Servlet container default servlet specifying explicitly the name of the default\n\t * Servlet to forward static resource requests to. This is useful when the default Servlet cannot be detected\n\t * (e.g. when using an unknown container or when it has been manually configured).\n\t */\n\tpublic void enable(String defaultServletName) {\n\t\trequestHandler = new DefaultServletHttpRequestHandler();\n\t\trequestHandler.setDefaultServletName(defaultServletName);\n\t\trequestHandler.setServletContext(servletContext);\n\t}","id":84220,"modified_method":"/**\n\t * Enable forwarding to the \"default\" Servlet identified by the given name.\n\t * This is useful when the default Servlet cannot be auto-detected, for example when it has been manually configured.\n\t * @see DefaultServletHttpRequestHandler\n\t */\n\tpublic void enable(String defaultServletName) {\n\t\thandler = new DefaultServletHttpRequestHandler();\n\t\thandler.setDefaultServletName(defaultServletName);\n\t\thandler.setServletContext(servletContext);\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public DefaultServletHandlerConfigurer(ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}","id":84221,"modified_method":"/**\n\t * Create a {@link DefaultServletHandlerConfigurer} instance.\n\t * @param servletContext the ServletContext to use to configure the underlying DefaultServletHttpRequestHandler.\n\t */\n\tpublic DefaultServletHandlerConfigurer(ServletContext servletContext) {\n\t\tAssert.notNull(servletContext, \"A ServletContext is required to configure default servlet handling\");\n\t\tthis.servletContext = servletContext;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Enable forwarding to the Servlet container default servlet. The {@link DefaultServletHttpRequestHandler}\n\t * will try to auto-detect the default Servlet at startup using a list of known names. Alternatively, you can\n\t * specify the name of the default Servlet, see {@link #enable(String)}.\n\t */\n\tpublic void enable() {\n\t\tenable(null);\n\t}","id":84222,"modified_method":"/**\n\t * Enable forwarding to the \"default\" Servlet. When this method is used the {@link DefaultServletHttpRequestHandler}\n\t * will try to auto-detect the \"default\" Servlet name. Alternatively, you can specify the name of the default \n\t * Servlet via {@link #enable(String)}.\n\t * @see DefaultServletHttpRequestHandler\n\t */\n\tpublic void enable() {\n\t\tenable(null);\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void notEnabled() {\n\t\tassertTrue(configurer.getHandlerMapping().getUrlMap().isEmpty());\n\t}","id":84223,"modified_method":"@Test\n\tpublic void notEnabled() {\n\t\tassertNull(configurer.getHandlerMapping());\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void enable() throws Exception {\n\t\tconfigurer.enable();\n\t\tSimpleUrlHandlerMapping handlerMapping = configurer.getHandlerMapping();\n\t\tDefaultServletHttpRequestHandler handler = (DefaultServletHttpRequestHandler) handlerMapping.getUrlMap().get(\"/**\");\n\n\t\tassertNotNull(handler);\n\t\tassertEquals(Integer.MAX_VALUE, handlerMapping.getOrder());\n\n\t\thandler.handleRequest(new MockHttpServletRequest(), response);\n\n\t\tString expected = \"default\";\n\t\tassertEquals(\"The ServletContext was not called with the default servlet name\", expected, servletContext.url);\n\t\tassertEquals(\"The request was not forwarded\", expected, response.getForwardedUrl());\n\t}","id":84224,"modified_method":"@Test\n\tpublic void enable() throws Exception {\n\t\tconfigurer.enable();\n\t\tSimpleUrlHandlerMapping getHandlerMapping = getHandlerMapping();\n\t\tSimpleUrlHandlerMapping handlerMapping = getHandlerMapping;\n\t\tDefaultServletHttpRequestHandler handler = (DefaultServletHttpRequestHandler) handlerMapping.getUrlMap().get(\"/**\");\n\n\t\tassertNotNull(handler);\n\t\tassertEquals(Integer.MAX_VALUE, handlerMapping.getOrder());\n\n\t\thandler.handleRequest(new MockHttpServletRequest(), response);\n\n\t\tString expected = \"default\";\n\t\tassertEquals(\"The ServletContext was not called with the default servlet name\", expected, servletContext.url);\n\t\tassertEquals(\"The request was not forwarded\", expected, response.getForwardedUrl());\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void enableWithServletName() throws Exception {\n\t\tconfigurer.enable(\"defaultServlet\");\n\t\tSimpleUrlHandlerMapping handlerMapping = configurer.getHandlerMapping();\n\t\tDefaultServletHttpRequestHandler handler = (DefaultServletHttpRequestHandler) handlerMapping.getUrlMap().get(\"/**\");\n\n\t\tassertNotNull(handler);\n\t\tassertEquals(Integer.MAX_VALUE, handlerMapping.getOrder());\n\n\t\thandler.handleRequest(new MockHttpServletRequest(), response);\n\n\t\tString expected = \"defaultServlet\";\n\t\tassertEquals(\"The ServletContext was not called with the default servlet name\", expected, servletContext.url);\n\t\tassertEquals(\"The request was not forwarded\", expected, response.getForwardedUrl());\n\t}","id":84225,"modified_method":"@Test\n\tpublic void enableWithServletName() throws Exception {\n\t\tconfigurer.enable(\"defaultServlet\");\n\t\tSimpleUrlHandlerMapping handlerMapping = getHandlerMapping();\n\t\tDefaultServletHttpRequestHandler handler = (DefaultServletHttpRequestHandler) handlerMapping.getUrlMap().get(\"/**\");\n\n\t\tassertNotNull(handler);\n\t\tassertEquals(Integer.MAX_VALUE, handlerMapping.getOrder());\n\n\t\thandler.handleRequest(new MockHttpServletRequest(), response);\n\n\t\tString expected = \"defaultServlet\";\n\t\tassertEquals(\"The ServletContext was not called with the default servlet name\", expected, servletContext.url);\n\t\tassertEquals(\"The request was not forwarded\", expected, response.getForwardedUrl());\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected final void configureViewControllers(ViewControllerConfigurer configurer) {\n\t\tconfigurers.configureViewControllers(configurer);\n\t}","id":84226,"modified_method":"@Override\n\tprotected final void addViewControllers(ViewControllerRegistry registry) {\n\t\tconfigurers.addViewControllers(registry);\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns a {@link SimpleUrlHandlerMapping} ordered at 1 to map URL paths directly to view names.\n\t * To configure view controllers see {@link #configureViewControllers(ViewControllerConfigurer)}. \n\t */\n\t@Bean\n\tpublic SimpleUrlHandlerMapping viewControllerHandlerMapping() {\n\t\tViewControllerConfigurer configurer = new ViewControllerConfigurer();\n\t\tconfigurer.setOrder(1);\n\t\tconfigureViewControllers(configurer);\n\t\t\n\t\tSimpleUrlHandlerMapping handlerMapping = configurer.getHandlerMapping();\n\t\thandlerMapping.setInterceptors(getInterceptors());\n\t\treturn handlerMapping;\n\t}","id":84227,"modified_method":"/**\n\t * Returns a handler mapping ordered at 1 to map URL paths directly to view names.\n\t * To configure view controllers, override {@link #addViewControllers(ViewControllerRegistry)}. \n\t */\n\t@Bean\n\tpublic HandlerMapping viewControllerHandlerMapping() {\n\t\tViewControllerRegistry registry = new ViewControllerRegistry();\n\t\taddViewControllers(registry);\n\t\t\n\t\tAbstractHandlerMapping handlerMapping = registry.getHandlerMapping();\n\t\thandlerMapping = handlerMapping != null ? handlerMapping : new EmptyHandlerMapping();\n\t\thandlerMapping.setInterceptors(getInterceptors());\n\t\treturn handlerMapping;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns a {@link SimpleUrlHandlerMapping} ordered at Integer.MAX_VALUE-1 to serve static resource requests.\n\t * To configure resource handling, see {@link #configureResourceHandling(ResourceConfigurer)}.\n\t */\n\t@Bean\n\tpublic SimpleUrlHandlerMapping resourceHandlerMapping() {\n\t\tResourceConfigurer configurer = new ResourceConfigurer(applicationContext, servletContext);\n\t\tconfigurer.setOrder(Integer.MAX_VALUE-1);\n\t\tconfigureResourceHandling(configurer);\n\t\treturn configurer.getHandlerMapping();\n\t}","id":84228,"modified_method":"/**\n\t * Returns a handler mapping ordered at Integer.MAX_VALUE-1 with mapped resource handlers.\n\t * To configure resource handling, override {@link #addResourceHandlers(ResourceHandlerRegistry)}.\n\t */\n\t@Bean\n\tpublic HandlerMapping resourceHandlerMapping() {\n\t\tResourceHandlerRegistry registry = new ResourceHandlerRegistry(applicationContext, servletContext);\n\t\taddResourceHandlers(registry);\n\t\tAbstractHandlerMapping handlerMapping = registry.getHandlerMapping();\n\t\thandlerMapping = handlerMapping != null ? handlerMapping : new EmptyHandlerMapping();\n\t\treturn handlerMapping;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Provides access to the shared handler interceptors used to configure {@link HandlerMapping} instances with.\n\t * This method cannot be overridden, use {@link #configureInterceptors(InterceptorConfigurer)} instead. \n\t */\n\tprotected final Object[] getInterceptors() {\n\t\tif (interceptors == null) {\n\t\t\tInterceptorConfigurer configurer = new InterceptorConfigurer();\n\t\t\tconfigureInterceptors(configurer);\n\t\t\tconfigurer.addInterceptor(new ConversionServiceExposingInterceptor(mvcConversionService()));\n\t\t\tinterceptors = configurer.getInterceptors();\n\t\t}\n\t\treturn interceptors.toArray();\n\t}","id":84229,"modified_method":"/**\n\t * Provides access to the shared handler interceptors used to configure {@link HandlerMapping} instances with.\n\t * This method cannot be overridden, use {@link #addInterceptors(InterceptorRegistry)} instead. \n\t */\n\tprotected final Object[] getInterceptors() {\n\t\tif (interceptors == null) {\n\t\t\tInterceptorRegistry registry = new InterceptorRegistry();\n\t\t\taddInterceptors(registry);\n\t\t\tregistry.addInterceptor(new ConversionServiceExposingInterceptor(mvcConversionService()));\n\t\t\tinterceptors = registry.getInterceptors();\n\t\t}\n\t\treturn interceptors.toArray();\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to configure view controllers. View controllers provide a direct mapping between a \n\t * URL path and view name. This is useful when serving requests that don't require application-specific \n\t * controller logic and can be forwarded directly to a view for rendering.\n\t * @see ViewControllerConfigurer\n\t */\n\tprotected void configureViewControllers(ViewControllerConfigurer configurer) {\n\t}","id":84230,"modified_method":"/**\n\t * Override this method to add view controllers.\n\t * @see ViewControllerRegistry\n\t */\n\tprotected void addViewControllers(ViewControllerRegistry registry) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to configure a handler for delegating unhandled requests by forwarding to the \n\t * Servlet container's default servlet. This is commonly used when the {@link DispatcherServlet} is \n\t * mapped to \"/\", which results in cleaner URLs (without a servlet prefix) but may need to still allow \n\t * some requests (e.g. static resources) to be handled by the Servlet container's default servlet.\n\t * @see DefaultServletHandlerConfigurer\n\t */\n\tprotected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t}","id":84231,"modified_method":"/**\n\t * Override this method to configure \"default\" Servlet handling. \n\t * @see DefaultServletHandlerConfigurer\n\t */\n\tprotected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to add custom argument resolvers to use in addition to the ones registered by default\n\t * internally by the {@link RequestMappingHandlerAdapter}.\n\t * <p>Generally custom argument resolvers are invoked first. However this excludes default argument resolvers that\n\t * rely on the presence of annotations (e.g. {@code @RequestParameter}, {@code @PathVariable}, etc.). Those \n\t * argument resolvers are not customizable without configuring RequestMappingHandlerAdapter directly. \n\t */\n\tprotected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t}","id":84232,"modified_method":"/**\n\t * Add custom {@link HandlerMethodArgumentResolver}s to use in addition to the ones registered by default.\n\t * <p>Custom argument resolvers are invoked before built-in resolvers except for those that rely on the presence \n\t * of annotations (e.g. {@code @RequestParameter}, {@code @PathVariable}, etc.). The latter can be customized \n\t * by configuring the {@link RequestMappingHandlerAdapter} directly. \n\t * @param argumentResolvers the list of custom converters; initially an empty list.\n\t */\n\tprotected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns a {@link RequestMappingHandlerAdapter} for processing requests using annotated controller methods.\n\t * Also see the following other methods as an alternative to overriding this method:\n\t * <ul>\n\t * \t<li>{@link #initWebBindingInitializer()} for configuring data binding globally.\n\t *  <li>{@link #addArgumentResolvers(List)} for adding custom argument resolvers.\n\t * \t<li>{@link #addReturnValueHandlers(List)} for adding custom return value handlers.\n\t * \t<li>{@link #configureMessageConverters(List)} for adding custom message converters.\n\t * <\/ul>\n\t */\n\t@Bean\n\tpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n\t\tConfigurableWebBindingInitializer webBindingInitializer = new ConfigurableWebBindingInitializer();\n\t\twebBindingInitializer.setConversionService(mvcConversionService());\n\t\twebBindingInitializer.setValidator(mvcValidator());\n\t\tconfigureWebBindingInitializer(webBindingInitializer);\n\t\t\n\t\tList<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\t\taddArgumentResolvers(argumentResolvers);\n\n\t\tList<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<HandlerMethodReturnValueHandler>();\n\t\taddReturnValueHandlers(returnValueHandlers);\n\t\t\n\t\tRequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();\n\t\tadapter.setMessageConverters(getMessageConverters());\n\t\tadapter.setWebBindingInitializer(webBindingInitializer);\n\t\tadapter.setCustomArgumentResolvers(argumentResolvers);\n\t\tadapter.setCustomReturnValueHandlers(returnValueHandlers);\n\t\treturn adapter;\n\t}","id":84233,"modified_method":"/**\n\t * Returns a {@link RequestMappingHandlerAdapter} for processing requests through annotated controller methods.\n\t * Consider overriding one of these other more fine-grained methods:\n\t * <ul>\n\t *  <li>{@link #addArgumentResolvers(List)} for adding custom argument resolvers.\n\t * \t<li>{@link #addReturnValueHandlers(List)} for adding custom return value handlers.\n\t * \t<li>{@link #configureMessageConverters(List)} for adding custom message converters.\n\t * <\/ul>\n\t */\n\t@Bean\n\tpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n\t\tConfigurableWebBindingInitializer webBindingInitializer = new ConfigurableWebBindingInitializer();\n\t\twebBindingInitializer.setConversionService(mvcConversionService());\n\t\twebBindingInitializer.setValidator(mvcValidator());\n\t\t\n\t\tList<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\t\taddArgumentResolvers(argumentResolvers);\n\n\t\tList<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<HandlerMethodReturnValueHandler>();\n\t\taddReturnValueHandlers(returnValueHandlers);\n\t\t\n\t\tRequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();\n\t\tadapter.setMessageConverters(getMessageConverters());\n\t\tadapter.setWebBindingInitializer(webBindingInitializer);\n\t\tadapter.setCustomArgumentResolvers(argumentResolvers);\n\t\tadapter.setCustomReturnValueHandlers(returnValueHandlers);\n\t\treturn adapter;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to configure the list of {@link HandlerExceptionResolver}s to use for handling \n\t * unresolved controller exceptions. If any exception resolvers are added through this method, default \n\t * exception resolvers are not added automatically. For the list of exception resolvers added by \n\t * default see {@link #addDefaultHandlerExceptionResolvers(List)}.\n\t */\n\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t}","id":84234,"modified_method":"/**\n\t * Override this method to configure the list of {@link HandlerExceptionResolver}s to use.\n\t * Adding resolvers to the list turns off the default resolvers that would otherwise be registered by default.\n\t * Also see {@link #addDefaultHandlerExceptionResolvers(List)} that can be used to add the default exception resolvers.\n\t * @param exceptionResolvers a list to add exception resolvers to; initially an empty list.\n\t */\n\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to add custom return value handlers to use in addition to the ones registered by default\n\t * internally by the {@link RequestMappingHandlerAdapter}.\n\t * <p>Generally custom return value handlers are invoked first. However this excludes default return value handlers \n\t * that rely on the presence of annotations (e.g. {@code @ResponseBody}, {@code @ModelAttribute}, etc.). Those \n\t * handlers are not customizable without configuring RequestMappingHandlerAdapter directly.\n\t */\n\tprotected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t}","id":84235,"modified_method":"/**\n\t * Add custom {@link HandlerMethodReturnValueHandler}s in addition to the ones registered by default.\n\t * <p>Custom return value handlers are invoked before built-in ones except for those that rely on the presence \n\t * of annotations (e.g. {@code @ResponseBody}, {@code @ModelAttribute}, etc.). The latter can be customized\n\t * by configuring the {@link RequestMappingHandlerAdapter} directly.\n\t * @param returnValueHandlers the list of custom handlers; initially an empty list.\n\t */\n\tprotected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns a {@link RequestMappingHandlerMapping} ordered at 0 for mapping requests to annotated controllers.\n\t */\n\t@Bean\n\tpublic RequestMappingHandlerMapping requestMappingHandlerMapping() {\n\t\tRequestMappingHandlerMapping mapping = new RequestMappingHandlerMapping();\n\t\tmapping.setInterceptors(getInterceptors());\n\t\tmapping.setOrder(0);\n\t\treturn mapping;\n\t}","id":84236,"modified_method":"/**\n\t * Returns a {@link RequestMappingHandlerMapping} ordered at 0 for mapping requests to annotated controllers.\n\t */\n\t@Bean\n\tpublic RequestMappingHandlerMapping requestMappingHandlerMapping() {\n\t\tRequestMappingHandlerMapping handlerMapping = new RequestMappingHandlerMapping();\n\t\thandlerMapping.setOrder(0);\n\t\thandlerMapping.setInterceptors(getInterceptors());\n\t\treturn handlerMapping;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to provide a custom {@link Validator} type. If this method returns {@code null}, by \n\t * a check is made for the presence of a JSR-303 implementation on the classpath - if available a  \n\t * {@link org.springframework.validation.beanvalidation.LocalValidatorFactoryBean} instance is created. \n\t * Otherwise if no JSR-303 implementation is detected, a no-op {@link Validator} is returned instead.\n\t */\n\tprotected Validator getValidator() {\n\t\treturn null;\n\t}","id":84237,"modified_method":"/**\n\t * Override this method to provide a custom {@link Validator}.\n\t */\n\tprotected Validator getValidator() {\n\t\treturn null;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Override this method to add custom {@link HttpMessageConverter}s to use with \n\t * the {@link RequestMappingHandlerAdapter} and the {@link ExceptionHandlerExceptionResolver}.\n\t * If any converters are added through this method, default converters are added automatically.\n\t * See {@link #addDefaultHttpMessageConverters(List)} for adding default converters to the list.\n\t * @param messageConverters the list to add converters to\n\t */\n\tprotected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}","id":84238,"modified_method":"/**\n\t * Override this method to add custom {@link HttpMessageConverter}s to use with \n\t * the {@link RequestMappingHandlerAdapter} and the {@link ExceptionHandlerExceptionResolver}.\n\t * Adding converters to the list turns off the default converters that would otherwise be registered by default.\n\t * Also see {@link #addDefaultHttpMessageConverters(List)} that can be used to add default message converters.\n\t * @param converters a list to add message converters to; initially an empty list.\n\t */\n\tprotected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns a {@link SimpleUrlHandlerMapping} ordered at Integer.MAX_VALUE to serve static resources by \n\t * forwarding to the Servlet container's default servlet. To configure default servlet handling see\n\t * {@link #configureDefaultServletHandling(DefaultServletHandlerConfigurer)}.  \n\t */\n\t@Bean\n\tpublic SimpleUrlHandlerMapping defaultServletHandlerMapping() {\n\t\tDefaultServletHandlerConfigurer configurer = new DefaultServletHandlerConfigurer(servletContext);\n\t\tconfigureDefaultServletHandling(configurer);\n\t\treturn configurer.getHandlerMapping();\n\t}","id":84239,"modified_method":"/**\n\t * Returns a handler mapping ordered at Integer.MAX_VALUE with a mapped default servlet handler.\n\t * To configure \"default\" Servlet handling, override \n\t * {@link #configureDefaultServletHandling(DefaultServletHandlerConfigurer)}.  \n\t */\n\t@Bean\n\tpublic HandlerMapping defaultServletHandlerMapping() {\n\t\tDefaultServletHandlerConfigurer configurer = new DefaultServletHandlerConfigurer(servletContext);\n\t\tconfigureDefaultServletHandling(configurer);\n\t\tAbstractHandlerMapping handlerMapping = configurer.getHandlerMapping();\n\t\thandlerMapping = handlerMapping != null ? handlerMapping : new EmptyHandlerMapping();\n\t\treturn handlerMapping;\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * {@inheritDoc}\n\t * <p>This implementation is empty.\n\t */\n\tpublic void configureViewControllers(ViewControllerConfigurer configurer) {\n\t}","id":84240,"modified_method":"/**\n\t * {@inheritDoc}\n\t * <p>This implementation is empty.\n\t */\n\tpublic void addViewControllers(ViewControllerRegistry registry) {\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void configureViewControllers(ViewControllerConfigurer configurer) {\n\t\tfor (WebMvcConfigurer delegate : delegates) {\n\t\t\tdelegate.configureViewControllers(configurer);\n\t\t}\n\t}","id":84241,"modified_method":"public void addViewControllers(ViewControllerRegistry registry) {\n\t\tfor (WebMvcConfigurer delegate : delegates) {\n\t\t\tdelegate.addViewControllers(registry);\n\t\t}\n\t}","commit_id":"ab033086f98e633fa7314edf3adfab67fe9bd85b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Migrates this handler to a new IOSelector thread.\n     * The migration logic is rather simple:\n     * <p><ul>\n     *     <li>Submit a de-registration task to a current IOSelector thread<\/li>\n     *     <li>The de-registration task submits a registration task to the new IOSelector thread<\/li>\n     * <\/ul><\/p>\n     *\n     * @param newOwner target IOSelector this handler migrates to\n     */\n    public void requestMigration(final IOSelector newOwner) {\n        if (ioSelector == newOwner || !socketChannel.isOpen()) {\n            return;\n        }\n\n        ioSelector.addTaskAndWakeup(new MigrationTask(newOwner));\n    }","id":84242,"modified_method":"void startMigration(final IOSelector newOwner) {\n        assert ioSelector == Thread.currentThread() : \"startMigration can only run on the owning IOSelector thread\";\n        assert ioSelector != newOwner : \"newOwner can't be the same as the existing owner\";\n\n        if (!socketChannel.isOpen()) {\n            // if the channel is closed, we are done.\n            return;\n        }\n\n        unregisterOp(initialOps);\n        ioSelector = newOwner;\n        selectionKey.cancel();\n        selectionKey = null;\n        selector = null;\n\n        newOwner.addTaskAndWakeup(new Runnable() {\n            @Override\n            public void run() {\n                completeMigration(newOwner);\n            }\n        });\n    }","commit_id":"8526bd36cef6e21912e594b76f4524a175189936","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"VO_VOLATILE_INCREMENT\",\n            justification = \"eventCount is accessed by a single thread only.\")\n    public void handle() {\n        eventCount++;\n        lastHandle = Clock.currentTimeMillis();\n        if (!connection.isAlive()) {\n            return;\n        }\n\n        if (socketWriter == null) {\n            logger.log(Level.WARNING, \"SocketWriter is not set, creating SocketWriter with CLUSTER protocol!\");\n            createWriter(Protocols.CLUSTER);\n        }\n\n        try {\n            fillOutputBuffer();\n\n            if (dirtyOutputBuffer()) {\n                writeOutputBufferToSocket();\n            }\n        } catch (Throwable t) {\n            logger.severe(\"Fatal Error at WriteHandler for endPoint: \" + connection.getEndPoint(), t);\n        }\n        unschedule();\n    }","id":84243,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"VO_VOLATILE_INCREMENT\",\n            justification = \"eventCount is accessed by a single thread only.\")\n    public void handle() {\n        eventCount++;\n        lastHandle = Clock.currentTimeMillis();\n        if (shutdown) {\n            return;\n        }\n\n        if (socketWriter == null) {\n            logger.log(Level.WARNING, \"SocketWriter is not set, creating SocketWriter with CLUSTER protocol!\");\n            createWriter(Protocols.CLUSTER);\n        }\n\n        try {\n            fillOutputBuffer();\n\n            if (dirtyOutputBuffer()) {\n                writeOutputBufferToSocket();\n            }\n        } catch (Throwable t) {\n            logger.severe(\"Fatal Error at WriteHandler for endPoint: \" + connection.getEndPoint(), t);\n        }\n\n        if (newOwner == null) {\n            unschedule();\n        } else {\n            IOSelector newOwner = this.newOwner;\n            this.newOwner = null;\n            startMigration(newOwner);\n        }\n    }","commit_id":"8526bd36cef6e21912e594b76f4524a175189936","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void shutdown() {\n        writeQueue.clear();\n        urgentWriteQueue.clear();\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        ioSelector.addTaskAndWakeup(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    socketChannel.closeOutbound();\n                } catch (IOException e) {\n                    logger.finest(\"Error while closing outbound\", e);\n                } finally {\n                    latch.countDown();\n                }\n            }\n        });\n        try {\n            latch.await(TIMEOUT, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            EmptyStatement.ignore(e);\n        }\n    }","id":84244,"modified_method":"public void shutdown() {\n        writeQueue.clear();\n        urgentWriteQueue.clear();\n\n        ShutdownTask shutdownTask = new ShutdownTask();\n        offer(shutdownTask);\n        shutdownTask.awaitCompletion();\n    }","commit_id":"8526bd36cef6e21912e594b76f4524a175189936","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private SocketWritable poll() {\n        SocketWritable packet = urgentWriteQueue.poll();\n        if (packet == null) {\n            packet = writeQueue.poll();\n        }\n\n        return packet;\n    }","id":84245,"modified_method":"private SocketWritable poll() {\n        for (; ; ) {\n            SocketWritable packet = urgentWriteQueue.poll();\n\n            if (packet == null) {\n                packet = writeQueue.poll();\n            }\n\n            if (packet instanceof TaskPacket) {\n                ((TaskPacket) packet).run();\n                continue;\n            }\n\n            return packet;\n        }\n    }","commit_id":"8526bd36cef6e21912e594b76f4524a175189936","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void reIndex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\n\t\t\tNodeIterator itr = repositoryNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tif (node.getPrimaryNodeType().getName().equals(\n\t\t\t\t\t\tJCRConstants.NT_FILE)) {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument doc = Indexer.getFileDocument(\n\t\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\t\tnode.getName());\n\n\t\t\t\t\t\tSearchEngineUtil.updateDocument(\n\t\t\t\t\t\t\tcompanyId, doc.get(Field.UID), doc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e1) {\n\t\t\t\t\t\t_log.error(\"Reindexing \" + node.getName(), e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\tthrow new SearchException(e2);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (session != null) {\n\t\t\t\t\tsession.logout();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\t}","id":84246,"modified_method":"public void reIndex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\n\t\t\tNodeIterator itr = repositoryNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tif (node.getPrimaryNodeType().getName().equals(\n\t\t\t\t\t\tJCRConstants.NT_FILE)) {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument doc = Indexer.getFileDocument(\n\t\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\t\tnode.getName());\n\n\t\t\t\t\t\tSearchEngineUtil.updateDocument(\n\t\t\t\t\t\t\tcompanyId, doc.get(Field.UID), doc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2) {\n\t\t\t\t\t\t_log.error(\"Reindexing \" + node.getName(), e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\tthrow new SearchException(e1);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (session != null) {\n\t\t\t\t\tsession.logout();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"aa4e48e9563f28bc57f33e1f0705561a9a78e3ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void destroy() {\n\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets();\n\n\t\t// Scheduler\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Scheduler\");\n\t\t}\n\n\t\ttry {\n\t\t\tif (PropsValues.SCHEDULER_ENABLED) {\n\t\t\t\tfor (String className : PropsValues.SCHEDULER_CLASSES) {\n\t\t\t\t\tScheduler scheduler = (Scheduler)InstancePool.get(\n\t\t\t\t\t\tclassName);\n\n\t\t\t\t\tscheduler.unschedule();\n\t\t\t\t}\n\n\t\t\t\tIterator<Portlet> itr = portlets.iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tPortlet portlet = itr.next();\n\n\t\t\t\t\tString className = portlet.getSchedulerClass();\n\n\t\t\t\t\tif (!portlet.isActive() || Validator.isNull(className)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tScheduler scheduler = (Scheduler)InstancePool.get(\n\t\t\t\t\t\tclassName);\n\n\t\t\t\t\tscheduler.unschedule();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Portlets\n\n\t\ttry {\n\t\t\tIterator<Portlet> itr = portlets.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tPortlet portlet = itr.next();\n\n\t\t\t\tPortletInstanceFactoryUtil.destroy(portlet);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Companies\n\n\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\tfor (int i = 0; i < companyIds.length; i++) {\n\t\t\tdestroyCompany(companyIds[i]);\n\t\t}\n\n\t\t// Global shutdown events\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Process global shutdown events\");\n\t\t}\n\n\t\ttry {\n\t\t\tEventsProcessor.process(\n\t\t\t\tPropsKeys.GLOBAL_SHUTDOWN_EVENTS,\n\t\t\t\tPropsValues.GLOBAL_SHUTDOWN_EVENTS);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tsuper.destroy();\n\t}","id":84247,"modified_method":"public void destroy() {\n\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets();\n\n\t\t// Scheduler\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Scheduler\");\n\t\t}\n\n\t\ttry {\n\t\t\tif (PropsValues.SCHEDULER_ENABLED) {\n\t\t\t\tfor (String className : PropsValues.SCHEDULER_CLASSES) {\n\t\t\t\t\tScheduler scheduler = null;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler = (Scheduler)InstancePool.get(className);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2) {\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scheduler != null) {\n\t\t\t\t\t\tscheduler.unschedule();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tIterator<Portlet> itr = portlets.iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tPortlet portlet = itr.next();\n\n\t\t\t\t\tString className = portlet.getSchedulerClass();\n\n\t\t\t\t\tif (!portlet.isActive() || Validator.isNull(className)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tScheduler scheduler = null;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler = (Scheduler)InstancePool.get(className);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2) {\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scheduler != null) {\n\t\t\t\t\t\tscheduler.unschedule();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\t_log.error(e1, e1);\n\t\t}\n\n\t\t// Portlets\n\n\t\ttry {\n\t\t\tIterator<Portlet> itr = portlets.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tPortlet portlet = itr.next();\n\n\t\t\t\tPortletInstanceFactoryUtil.destroy(portlet);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Companies\n\n\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\tfor (int i = 0; i < companyIds.length; i++) {\n\t\t\tdestroyCompany(companyIds[i]);\n\t\t}\n\n\t\t// Global shutdown events\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Process global shutdown events\");\n\t\t}\n\n\t\ttry {\n\t\t\tEventsProcessor.process(\n\t\t\t\tPropsKeys.GLOBAL_SHUTDOWN_EVENTS,\n\t\t\t\tPropsValues.GLOBAL_SHUTDOWN_EVENTS);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tsuper.destroy();\n\t}","commit_id":"aa4e48e9563f28bc57f33e1f0705561a9a78e3ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Configuration newConfiguration() {\n\t\tConfiguration configuration = new Configuration();\n\n\t\ttry {\n\t\t\tClassLoader classLoader = getConfigurationClassLoader();\n\n\t\t\tString[] resources = getConfigurationResources();\n\n\t\t\tfor (String resource : resources) {\n\t\t\t\ttry {\n\t\t\t\t\tInputStream is = classLoader.getResourceAsStream(resource);\n\n\t\t\t\t\tif (is != null) {\n\t\t\t\t\t\tconfiguration = configuration.addInputStream(is);\n\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e1) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Validator.isNull(PropsValues.HIBERNATE_DIALECT)) {\n\t\t\t\tString dialect = determineDialect();\n\n\t\t\t\tconfiguration.setProperty(\"hibernate.dialect\", dialect);\n\t\t\t}\n\n\t\t\tconfiguration.setProperties(PropsUtil.getProperties());\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\t_log.error(e2, e2);\n\t\t}\n\n\t\treturn configuration;\n\t}","id":84248,"modified_method":"protected Configuration newConfiguration() {\n\t\tConfiguration configuration = new Configuration();\n\n\t\ttry {\n\t\t\tClassLoader classLoader = getConfigurationClassLoader();\n\n\t\t\tString[] resources = getConfigurationResources();\n\n\t\t\tfor (String resource : resources) {\n\t\t\t\ttry {\n\t\t\t\t\tInputStream is = classLoader.getResourceAsStream(resource);\n\n\t\t\t\t\tif (is != null) {\n\t\t\t\t\t\tconfiguration = configuration.addInputStream(is);\n\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e2) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(e2, e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Validator.isNull(PropsValues.HIBERNATE_DIALECT)) {\n\t\t\t\tString dialect = determineDialect();\n\n\t\t\t\tconfiguration.setProperty(\"hibernate.dialect\", dialect);\n\t\t\t}\n\n\t\t\tconfiguration.setProperties(PropsUtil.getProperties());\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\t_log.error(e1, e1);\n\t\t}\n\n\t\treturn configuration;\n\t}","commit_id":"aa4e48e9563f28bc57f33e1f0705561a9a78e3ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void afterPropertiesSet() {\n\t\ttry {\n\t\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProperties props = new Properties();\n\n\t\t\tEnumeration<Object> enu = PropsUtil.getProperties().keys();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString key = (String)enu.nextElement();\n\n\t\t\t\tif (key.startsWith(\"org.quartz.\")) {\n\t\t\t\t\tprops.setProperty(key, PropsUtil.get(key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStdSchedulerFactory schedulerFactory = new StdSchedulerFactory();\n\n\t\t\tschedulerFactory.initialize(props);\n\n\t\t\ttry {\n\t\t\t\t_scheduler = schedulerFactory.getScheduler();\n\t\t\t}\n\t\t\tcatch (Exception e1) {\n\t\t\t\tquartzLocalService.checkQuartzTables();\n\n\t\t\t\t_scheduler = schedulerFactory.getScheduler();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\t_log.error(\"Unable to initialize engine\", e2);\n\t\t}\n\t}","id":84249,"modified_method":"public void afterPropertiesSet() {\n\t\ttry {\n\t\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProperties props = new Properties();\n\n\t\t\tEnumeration<Object> enu = PropsUtil.getProperties().keys();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString key = (String)enu.nextElement();\n\n\t\t\t\tif (key.startsWith(\"org.quartz.\")) {\n\t\t\t\t\tprops.setProperty(key, PropsUtil.get(key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStdSchedulerFactory schedulerFactory = new StdSchedulerFactory();\n\n\t\t\tschedulerFactory.initialize(props);\n\n\t\t\ttry {\n\t\t\t\t_scheduler = schedulerFactory.getScheduler();\n\t\t\t}\n\t\t\tcatch (Exception e2) {\n\t\t\t\tquartzLocalService.checkQuartzTables();\n\n\t\t\t\t_scheduler = schedulerFactory.getScheduler();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\t_log.error(\"Unable to initialize engine\", e1);\n\t\t}\n\t}","commit_id":"aa4e48e9563f28bc57f33e1f0705561a9a78e3ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Register a job or task\n     * @param type The type (job or task)\n     * @param ref The service reference\n     */\n    private void register(final ServiceReference ref, final Object job) {\n        final String name = getServiceIdentifier(ref);\n        final Boolean concurrent = (Boolean)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_CONCURRENT);\n        final Object runOn = ref.getProperty(Scheduler.PROPERTY_SCHEDULER_RUN_ON);\n        String[] runOnOpts = null;\n        if ( runOn instanceof String ) {\n            runOnOpts = new String[] {runOn.toString()};\n        } else if ( runOn instanceof String[] ) {\n            runOnOpts = (String[])runOn;\n        } else if ( runOn != null ) {\n            this.logger.warn(\"Property {} ignored for scheduler {}\", Scheduler.PROPERTY_SCHEDULER_RUN_ON, ref);\n        }\n        final String expression = (String)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_EXPRESSION);\n        if ( expression != null ) {\n            this.scheduler.schedule(ref.getBundle().getBundleId(), (Long)ref.getProperty(Constants.SERVICE_ID),\n                    job, this.scheduler.EXPR(expression)\n                    .name(name)\n                    .canRunConcurrently((concurrent != null ? concurrent : true))\n                    .onInstancesOnly(runOnOpts));\n        } else {\n            final Long period = (Long)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_PERIOD);\n            if ( period != null ) {\n                if ( period < 1 ) {\n                    this.logger.debug(\"Ignoring service {} : scheduler period is less than 1.\", ref);\n                } else {\n                    boolean immediate = false;\n                    if ( ref.getProperty(Scheduler.PROPERTY_SCHEDULER_IMMEDIATE) != null ) {\n                        immediate = (Boolean)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_IMMEDIATE);\n                    }\n                    final Date date = new Date();\n                    if ( !immediate ) {\n                        date.setTime(System.currentTimeMillis() + period * 1000);\n                    }\n                    final Integer times = (Integer)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_TIMES);\n                    if ( times != null && times < 1 ) {\n                        this.logger.debug(\"Ignoring service {} : scheduler times is less than 1.\", ref);\n                    } else {\n                        final int t = (times != null ? times : -1);\n                        this.scheduler.schedule(ref.getBundle().getBundleId(), (Long)ref.getProperty(Constants.SERVICE_ID),\n                                job, this.scheduler.AT(date, t, period)\n                                .name(name)\n                                .canRunConcurrently((concurrent != null ? concurrent : true))\n                                .onInstancesOnly(runOnOpts));\n                    }\n                }\n            } else {\n                this.logger.debug(\"Ignoring servce {} : no scheduling property found.\", ref);\n            }\n        }\n    }","id":84250,"modified_method":"/**\n     * Register a job or task\n     * @param type The type (job or task)\n     * @param ref The service reference\n     * @throws IllegalArgumentException\n     */\n    private void register(final ServiceReference ref, final Object job) {\n        try {\n            final String name = getServiceIdentifier(ref);\n            final Boolean concurrent = getBooleanProperty(ref, Scheduler.PROPERTY_SCHEDULER_CONCURRENT);\n            final Object runOn = ref.getProperty(Scheduler.PROPERTY_SCHEDULER_RUN_ON);\n            String[] runOnOpts = null;\n            if ( runOn instanceof String ) {\n                runOnOpts = new String[] {runOn.toString()};\n            } else if ( runOn instanceof String[] ) {\n                runOnOpts = (String[])runOn;\n            } else if ( runOn != null ) {\n                this.logger.warn(\"Property {} ignored for scheduler {}\", Scheduler.PROPERTY_SCHEDULER_RUN_ON, ref);\n            }\n            final String expression = getStringProperty(ref, Scheduler.PROPERTY_SCHEDULER_EXPRESSION);\n            if ( expression != null ) {\n                this.scheduler.schedule(ref.getBundle().getBundleId(), (Long)ref.getProperty(Constants.SERVICE_ID),\n                        job, this.scheduler.EXPR(expression)\n                        .name(name)\n                        .canRunConcurrently((concurrent != null ? concurrent : true))\n                        .onInstancesOnly(runOnOpts));\n                this.idToNameMap.put((Long)ref.getProperty(Constants.SERVICE_ID), name);\n            } else {\n                final Long period = getLongProperty(ref, Scheduler.PROPERTY_SCHEDULER_PERIOD);\n                if ( period != null ) {\n                    if ( period < 1 ) {\n                        this.logger.debug(\"Ignoring service {} : scheduler period is less than 1.\", ref);\n                    } else {\n                        boolean immediate = false;\n                        if ( ref.getProperty(Scheduler.PROPERTY_SCHEDULER_IMMEDIATE) != null ) {\n                            immediate = getBooleanProperty(ref, Scheduler.PROPERTY_SCHEDULER_IMMEDIATE);\n                        }\n                        final Date date = new Date();\n                        if ( !immediate ) {\n                            date.setTime(System.currentTimeMillis() + period * 1000);\n                        }\n                        final Integer times = getIntegerProperty(ref, Scheduler.PROPERTY_SCHEDULER_TIMES);\n                        if ( times != null && times < 1 ) {\n                            this.logger.debug(\"Ignoring service {} : scheduler times is less than 1.\", ref);\n                        } else {\n                            final int t = (times != null ? times : -1);\n                            this.scheduler.schedule(ref.getBundle().getBundleId(), (Long)ref.getProperty(Constants.SERVICE_ID),\n                                    job, this.scheduler.AT(date, t, period)\n                                    .name(name)\n                                    .canRunConcurrently((concurrent != null ? concurrent : true))\n                                    .onInstancesOnly(runOnOpts));\n                            this.idToNameMap.put((Long)ref.getProperty(Constants.SERVICE_ID), name);\n                        }\n                    }\n                } else {\n                    this.logger.debug(\"Ignoring servce {} : no scheduling property found.\", ref);\n                }\n            }\n        } catch ( final IllegalArgumentException iae) {\n            this.logger.warn(\"Ignoring service {} : {}\", ref, iae.getMessage());\n        }\n    }","commit_id":"4d22623fbaf788ccc7dc2478c602c7559c847244","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Activate this component.\n     * @throws InvalidSyntaxException\n     */\n    @Activate\n    protected void activate(final BundleContext btx) throws InvalidSyntaxException {\n        this.serviceTracker = new ServiceTracker(btx,\n                btx.createFilter(\"(|(\" + Constants.OBJECTCLASS + \"=\" + Runnable.class.getName() + \")\" +\n                 \"(\" + Constants.OBJECTCLASS + \"=\" + Job.class.getName() + \"))\"),\n                new ServiceTrackerCustomizer() {\n\n            public synchronized void  removedService(final ServiceReference reference, final Object service) {\n                btx.ungetService(reference);\n                unregister(reference, service);\n            }\n\n            public synchronized void modifiedService(final ServiceReference reference, final Object service) {\n                unregister(reference, service);\n                register(reference, service);\n            }\n\n            public synchronized Object addingService(final ServiceReference reference) {\n                final Object obj = btx.getService(reference);\n                if ( obj != null ) {\n                    register(reference, obj);\n                }\n                return obj;\n            }\n        });\n        this.serviceTracker.open();\n    }","id":84251,"modified_method":"/**\n     * Activate this component.\n     * @throws InvalidSyntaxException\n     */\n    @Activate\n    protected void activate(final BundleContext btx) throws InvalidSyntaxException {\n        this.serviceTracker = new ServiceTracker(btx,\n                btx.createFilter(\"(|(\" + Constants.OBJECTCLASS + \"=\" + Runnable.class.getName() + \")\" +\n                 \"(\" + Constants.OBJECTCLASS + \"=\" + Job.class.getName() + \"))\"),\n                new ServiceTrackerCustomizer() {\n\n            public synchronized void  removedService(final ServiceReference reference, final Object service) {\n                unregister(reference, service);\n                btx.ungetService(reference);\n            }\n\n            public synchronized void modifiedService(final ServiceReference reference, final Object service) {\n                unregister(reference, service);\n                register(reference, service);\n            }\n\n            public synchronized Object addingService(final ServiceReference reference) {\n                final Object obj = btx.getService(reference);\n                if ( obj != null ) {\n                    register(reference, obj);\n                }\n                return obj;\n            }\n        });\n        this.serviceTracker.open();\n    }","commit_id":"4d22623fbaf788ccc7dc2478c602c7559c847244","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Unregister a service.\n     * @param ref The service reference.\n     */\n    private void unregister(final ServiceReference reference, final Object service) {\n        final String name = getServiceIdentifier(reference);\n        this.scheduler.unschedule(reference.getBundle().getBundleId(), name);\n    }","id":84252,"modified_method":"/**\n     * Unregister a service.\n     * @param ref The service reference.\n     */\n    private void unregister(final ServiceReference reference, final Object service) {\n        final String name = idToNameMap.remove(reference.getProperty(Constants.SERVICE_ID));\n        if ( name != null ) {\n            this.scheduler.unschedule(reference.getBundle().getBundleId(), name);\n        }\n    }","commit_id":"4d22623fbaf788ccc7dc2478c602c7559c847244","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create unique identifier\n     * @param type\n     * @param ref\n     * @throws Exception\n     */\n    private String getServiceIdentifier(final ServiceReference ref) {\n        String name = (String)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_NAME);\n        if ( name == null ) {\n            name = (String)ref.getProperty(Constants.SERVICE_PID);\n            if ( name == null ) {\n                name = \"Registered Service\";\n            }\n        }\n        // now append service id to create a unique identifier\n        name = name + \".\" + ref.getProperty(Constants.SERVICE_ID);\n        return name;\n    }","id":84253,"modified_method":"/**\n     * Create unique identifier\n     * @param type\n     * @param ref\n     * @throws IllegalArgumentException\n     */\n    private String getServiceIdentifier(final ServiceReference ref) {\n        String name = getStringProperty(ref, Scheduler.PROPERTY_SCHEDULER_NAME);\n        if ( name == null ) {\n            name = getStringProperty(ref, Constants.SERVICE_PID);\n            if ( name == null ) {\n                name = \"Registered Service\";\n            }\n        }\n        // now append service id to create a unique identifier\n        name = name + \".\" + ref.getProperty(Constants.SERVICE_ID);\n        return name;\n    }","commit_id":"4d22623fbaf788ccc7dc2478c602c7559c847244","url":"https://github.com/apache/sling"},{"original_method":"public static boolean testLocal( String address ) throws Exception {\n    List<String> addrs = Lists.newArrayList( );\n    Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces( );\n    while( ifaces.hasMoreElements( ) ) {\n      NetworkInterface iface = ifaces.nextElement( );\n      for( InterfaceAddress iaddr : iface.getInterfaceAddresses( ) ) {\n        InetAddress addr = iaddr.getAddress( );\n        if( addr instanceof Inet4Address ) {\n          addrs.add( addr.getHostAddress( ) );\n        }\n      }\n    }\n    return addrs.contains( address );\n  }","id":84254,"modified_method":"public static boolean testLocal( String address ) throws Exception {\n    InetAddress addr = InetAddress.getByName( address );\n    List<String> addrs = Lists.newArrayList( );\n    Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces( );\n    while( ifaces.hasMoreElements( ) ) {\n      NetworkInterface iface = ifaces.nextElement( );\n      for( InterfaceAddress iaddr : iface.getInterfaceAddresses( ) ) {\n        InetAddress ifaceAddr = iaddr.getAddress( );\n        if( ifaceAddr.equals( addr ) ) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"static-access\" )\n  public void dispatch( EucalyptusMessage msg ) {\n    MuleEvent context = RequestContext.getEvent( );\n    try {\n      if ( component.isLocal( ) ) {\n        this.getMuleClient( ).dispatch( this.address.toASCIIString( ), msg, null );\n      } else {\n        this.getNioClient( ).dispatch( msg );\n      }\n    } catch ( Exception e ) {\n      LOG.error( e );\n    } finally {\n      RequestContext.setEvent( context );\n    }\n  }","id":84255,"modified_method":"@SuppressWarnings( \"static-access\" )\n  public void dispatch( EucalyptusMessage msg ) {\n    MuleEvent context = RequestContext.getEvent( );\n    try {\n      if( NetworkUtil.testLocal( this.address.getHost( ) ) ) {\n        this.getMuleClient( ).dispatch( this.component.getLocalUri( ), msg, null );\n      } else {\n        this.getNioClient( ).dispatch( msg );\n      }\n    } catch ( Exception e ) {\n      LOG.error( e );\n    } finally {\n      RequestContext.setEvent( context );\n    }\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"static-access\" )\n  public EucalyptusMessage send( EucalyptusMessage msg ) throws EucalyptusCloudException {\n    MuleEvent context = RequestContext.getEvent( );\n    try {\n      if ( component.isLocal( ) ) {\n        MuleMessage reply = this.getMuleClient( ).send( this.address.toASCIIString( ), msg, null );\n\n        if ( reply.getExceptionPayload( ) != null ) {\n          throw new EucalyptusCloudException( reply.getExceptionPayload( ).getRootException( ).getMessage( ), reply.getExceptionPayload( ).getRootException( ) );\n        } else {\n          return ( EucalyptusMessage ) reply.getPayload( );\n        }\n      } else {\n        return this.getNioClient( ).send( msg );\n      }\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new EucalyptusCloudException( e );\n    } finally {\n      RequestContext.setEvent( context );\n    }\n  }","id":84256,"modified_method":"@SuppressWarnings( \"static-access\" )\n  public EucalyptusMessage send( EucalyptusMessage msg ) throws EucalyptusCloudException {\n    MuleEvent context = RequestContext.getEvent( );\n    try {\n      if( NetworkUtil.testLocal( this.address.getHost( ) ) ) {\n        MuleMessage reply = this.getMuleClient( ).send( this.component.getLocalUri( ), msg, null );\n\n        if ( reply.getExceptionPayload( ) != null ) {\n          throw new EucalyptusCloudException( reply.getExceptionPayload( ).getRootException( ).getMessage( ), reply.getExceptionPayload( ).getRootException( ) );\n        } else {\n          return ( EucalyptusMessage ) reply.getPayload( );\n        }\n      } else {\n        return this.getNioClient( ).send( msg );\n      }\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new EucalyptusCloudException( e );\n    } finally {\n      RequestContext.setEvent( context );\n    }\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static ServiceProxy lookup( Component component, String name) {\n    Registry registry = ServiceBootstrapper.getRegistry( );\n    String key = component.name( ) + \"/\" + name ;\n    return (ServiceProxy) registry.lookupObject( key );\n  }","id":84257,"modified_method":"public static ServiceProxy lookup( String registryKey ) {\n    Registry registry = ServiceBootstrapper.getRegistry( );\n    return (ServiceProxy) registry.lookupObject( registryKey );\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public boolean start( ) throws Exception {\n      List<WalrusConfiguration> walri = Configuration.getWalrusConfigurations( );\n      for( WalrusConfiguration w : walri ) {\n        try {\n          if( NetworkUtil.testLocal( w.getHostName( ) )) continue;\n          registerComponent( Component.walrus, w );\n        } catch ( Exception e ) {\n          LOG.error( \"Failed to create walrus service proxy: \" + e );\n        }\n      }\n      List<StorageControllerConfiguration> scs = Configuration.getStorageControllerConfigurations( );\n      for( StorageControllerConfiguration sc : scs ) {\n        try {\n          if( NetworkUtil.testLocal( sc.getHostName( ) )) continue;\n          registerComponent( Component.storage, sc );\n        } catch ( Exception e ) {\n          LOG.error( \"Failed to create storage controller \"+sc.getName( )+\" service proxy: \" + e );\n        }\n      }\n      if( Component.walrus.isLocal( ) ) {\n        registerLocalComponent( Component.storage );\n      }\n      if( Component.storage.isLocal( ) ) {\n        registerLocalComponent( Component.storage );\n      }\n      if( Component.dns.isLocal( ) ) {\n        registerLocalComponent( Component.dns );\n      }\n      if( Component.clusters.isLocal( ) ) {\n        registerLocalComponent( Component.clusters );\n      }\n      if( Component.jetty.isLocal( ) ) {\n        registerLocalComponent( Component.jetty );\n      }\n      return true;\n    }","id":84258,"modified_method":"@Override\n    public boolean start( ) throws Exception {\n      if( Component.walrus.isLocal( ) ) {\n        registerLocalComponent( Component.storage );\n      } else {\n        List<WalrusConfiguration> walri = Configuration.getWalrusConfigurations( );\n        for( WalrusConfiguration w : walri ) {\n          try {\n            if( NetworkUtil.testLocal( w.getHostName( ) )) continue;\n            registerComponent( Component.walrus, w );\n          } catch ( Exception e ) {\n            LOG.error( \"Failed to create walrus service proxy: \" + e );\n          }\n        }\n      }\n\n      List<StorageControllerConfiguration> scs = Configuration.getStorageControllerConfigurations( );\n      for( StorageControllerConfiguration sc : scs ) {\n        try {\n          if( NetworkUtil.testLocal( sc.getHostName( ) )) registerLocalComponent( Component.storage );\n          registerComponent( Component.storage, sc );\n        } catch ( Exception e ) {\n          LOG.error( \"Failed to create storage controller \"+sc.getName( )+\" service proxy: \" + e );\n        }\n      }\n      \n      if( Component.dns.isLocal( ) ) {\n        registerLocalComponent( Component.dns );\n      }\n      if( Component.clusters.isLocal( ) ) {\n        registerLocalComponent( Component.clusters );\n      }\n      if( Component.jetty.isLocal( ) ) {\n        registerLocalComponent( Component.jetty );\n      }\n\n      return true;\n    }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void registerLocalComponent( Component component ) throws RegistrationException {\n      Registry registry = ServiceBootstrapper.getRegistry( );\n      URI uri = component.getUri( );\n      String keyPrefix = component.name( ) + \"/\";\n      registry.registerObject( keyPrefix + component.name( ), new ServiceProxy( component, component.name( ), uri ) );\n    }","id":84259,"modified_method":"private void registerLocalComponent( Component component ) throws RegistrationException {\n      Registry registry = ServiceBootstrapper.getRegistry( );\n      URI uri = component.getUri( );\n      String key = component.getRegistryKey( \"localhost\" );\n      registry.registerObject( key, new ServiceProxy( component, component.name( ), uri ) );\n    }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void registerComponent( Component component, ComponentConfiguration componentConfiguration ) throws Exception {\n      Registry registry = ServiceBootstrapper.getRegistry( );\n      URI uri = new URI(component.makeUri( componentConfiguration.getHostName( ) ));\n      String keyPrefix = component.name( ) + \"/\";\n      registry.registerObject( keyPrefix + componentConfiguration.getName( ), new ServiceProxy( component, componentConfiguration.getName( ), uri ) );\n      LOG.info( \"Registering service proxy for \" + componentConfiguration.getName( ) + \" at \" + uri.toASCIIString( ) );\n    }","id":84260,"modified_method":"private void registerComponent( Component component, ComponentConfiguration componentConfiguration ) throws Exception {\n      Registry registry = ServiceBootstrapper.getRegistry( );\n      URI uri = new URI(component.makeUri( componentConfiguration.getHostName( ) ));\n      String key = component.getRegistryKey( componentConfiguration.getHostName( ) );\n      registry.registerObject( key, new ServiceProxy( component, componentConfiguration.getName( ), uri ) );\n      LOG.info( \"Registering service proxy for \" + componentConfiguration.getName( ) + \" at \" + uri.toASCIIString( ) );\n    }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void handleUpstream( ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n    LOG.debug( this.getClass( ).getSimpleName( ) + \"[incoming]: \" + e );\n    if( e instanceof ExceptionEvent) {\n      this.exceptionCaught( ctx, (ExceptionEvent)e );\n    } else if ( e instanceof MessageEvent ) {\n      this.startTime = System.currentTimeMillis( );\n      final MessageEvent event = ( MessageEvent ) e;\n      if ( event.getMessage( ) instanceof MappingHttpMessage ) {\n        MappingHttpMessage request = ( MappingHttpMessage ) event.getMessage( );\n        User user = request.getUser( );\n        requestLocal.set( ctx.getChannel( ), request );\n        EucalyptusMessage msg = (EucalyptusMessage) request.getMessage( );\n        if( user != null && msgReceiver == null) {\n          msg.setUserId( user.getUserName( ) );\n          msg.setEffectiveUserId( user.getIsAdministrator( )?Component.eucalyptus.name():user.getUserName( ) );\n        }\n        LOG.info( EventRecord.create( this.getClass( ).getSimpleName( ), msg.getUserId( ), msg.getCorrelationId( ), EventType.MSG_RECEIVED, msg.getClass( ).getSimpleName( ) ) );\n        ReplyQueue.addReplyListener( msg.getCorrelationId( ), ctx );\n        if( this.msgReceiver == null ) {\n          Messaging.dispatch( \"vm://RequestQueue\", msg );\n        } else if (user == null||user.getIsAdministrator( )){\n          MuleMessage reply = this.msgReceiver.routeMessage( new DefaultMuleMessage( this.msgReceiver.getConnector().getMessageAdapter( msg ) ) );\n          ctx.getChannel( ).write( reply.getPayload( ) );\n        }\n      }\n    }\n  }","id":84261,"modified_method":"@Override\n  public void handleUpstream( ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n    LOG.debug( this.getClass( ).getSimpleName( ) + \"[incoming]: \" + e );\n    if( e instanceof ExceptionEvent) {\n      this.exceptionCaught( ctx, (ExceptionEvent)e );\n    } else if ( e instanceof MessageEvent ) {\n      this.startTime = System.currentTimeMillis( );\n      final MessageEvent event = ( MessageEvent ) e;\n      if ( event.getMessage( ) instanceof MappingHttpMessage ) {\n        MappingHttpMessage request = ( MappingHttpMessage ) event.getMessage( );\n        User user = request.getUser( );\n        requestLocal.set( ctx.getChannel( ), request );\n        EucalyptusMessage msg = (EucalyptusMessage) request.getMessage( );\n        if( user != null && msgReceiver == null) {\n          msg.setUserId( user.getUserName( ) );\n          msg.setEffectiveUserId( user.getIsAdministrator( )?Component.eucalyptus.name():user.getUserName( ) );\n        }\n        LOG.info( EventRecord.create( this.getClass( ).getSimpleName( ), msg.getUserId( ), msg.getCorrelationId( ), EventType.MSG_RECEIVED, msg.getClass( ).getSimpleName( ) ) );\n        ReplyQueue.addReplyListener( msg.getCorrelationId( ), ctx );\n        if( this.msgReceiver == null ) {\n          Messaging.dispatch( \"vm://RequestQueue\", msg );\n        } else if (user == null||(user!=null&&user.getIsAdministrator())){\n          MuleMessage reply = this.msgReceiver.routeMessage( new DefaultMuleMessage( msg ) );\n          ctx.getChannel( ).write( reply.getPayload( ) );\n        } else {\n          ctx.getChannel( ).write( new MappingHttpResponse(request.getProtocolVersion( ), HttpResponseStatus.FORBIDDEN) );\n        }\n      }\n    }\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteSnapshotResponseType DeleteSnapshot( DeleteSnapshotType request ) throws EucalyptusCloudException {\n    DeleteSnapshotResponseType reply = ( DeleteSnapshotResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Snapshot snap = db.getUnique( Snapshot.named( userName, request.getSnapshotId() ) );\n//TODO: make this multi-cluster aware.\n      //      DeleteStorageSnapshotResponseType scReply = Messaging.send( StorageProperties.STORAGE_REF, new DeleteStorageSnapshotType( snap.getDisplayName() ), DeleteStorageSnapshotResponseType.class );\n//      LOG.debug( scReply );\n      db.delete( snap );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error deleting storage volume:\" + e.getMessage() );\n    }\n    reply.set_return( true );\n    return reply;\n  }","id":84262,"modified_method":"public DeleteSnapshotResponseType DeleteSnapshot( DeleteSnapshotType request ) throws EucalyptusCloudException {\n    DeleteSnapshotResponseType reply = ( DeleteSnapshotResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Snapshot snap = db.getUnique( Snapshot.named( userName, request.getSnapshotId() ) );\n      db.delete( snap );\n      db.getSession( ).flush( );\n      StorageProxy.dispatchAll( new DeleteStorageSnapshotType( snap.getDisplayName() ) );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error deleting storage volume:\" + e.getMessage() );\n    }\n    reply.set_return( true );\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateSnapshotResponseType CreateSnapshot( CreateSnapshotType request ) throws EucalyptusCloudException {\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    Volume vol = db.recast( Volume.class ).getUnique( Volume.named( userName, request.getVolumeId() ) );\n\n    String newId = null;\n    Snapshot snap = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n           db.getUnique( Snapshot.ownedBy( newId ) );\n      } catch ( EucalyptusCloudException e ) {\n           snap = new Snapshot( request.getUserId(), newId, vol.getDisplayName() );\n           db.add( snap );\n           break;\n      }\n    }\n\n    CreateStorageSnapshotType scRequest = new CreateStorageSnapshotType( vol.getDisplayName(), newId );\n    CreateStorageSnapshotResponseType scReply = null;\n    try {\n      scReply = StorageProxy.send( vol.getCluster( ), scRequest, CreateStorageSnapshotResponseType.class );\n      snap.setMappedState( scReply.getStatus() );\n      LOG.debug(scReply);\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageSnapshot:\" + e.getMessage() );\n    }\n    db.commit();\n\n    CreateSnapshotResponseType reply = ( CreateSnapshotResponseType ) request.getReply();\n    edu.ucsb.eucalyptus.msgs.Snapshot snapMsg = snap.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n    snapMsg.setProgress( \"0%\" );\n    reply.setSnapshot( snapMsg );\n    return reply;\n  }","id":84263,"modified_method":"public CreateSnapshotResponseType CreateSnapshot( CreateSnapshotType request ) throws EucalyptusCloudException {\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    Volume vol = db.recast( Volume.class ).getUnique( Volume.named( userName, request.getVolumeId() ) );\n\n    String newId = null;\n    Snapshot snap = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n           db.getUnique( Snapshot.ownedBy( newId ) );\n      } catch ( EucalyptusCloudException e ) {\n           snap = new Snapshot( request.getUserId(), newId, vol.getDisplayName() );\n           db.add( snap );\n           break;\n      }\n    }\n\n    StorageControllerConfiguration sc;\n    try {\n      sc = Configuration.getStorageControllerConfiguration( vol.getCluster( ) );\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException(\"Failed to find the storage controller information for volume: \" + vol.getDisplayName( ) + \" at \" + vol.getCluster( ), e );\n    }\n\n    CreateStorageSnapshotType scRequest = new CreateStorageSnapshotType( vol.getDisplayName(), newId );\n    CreateStorageSnapshotResponseType scReply = null;\n    try {\n      scReply = StorageProxy.send( sc.getHostName( ), scRequest, CreateStorageSnapshotResponseType.class );\n      snap.setMappedState( scReply.getStatus() );\n      LOG.debug(scReply);\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageSnapshot:\" + e.getMessage() );\n    }\n    db.commit();\n\n    CreateSnapshotResponseType reply = ( CreateSnapshotResponseType ) request.getReply();\n    edu.ucsb.eucalyptus.msgs.Snapshot snapMsg = snap.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n    snapMsg.setProgress( \"0%\" );\n    reply.setSnapshot( snapMsg );\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeSnapshotsResponseType DescribeSnapshots( DescribeSnapshotsType request ) throws EucalyptusCloudException {\n    DescribeSnapshotsResponseType reply = ( DescribeSnapshotsResponseType ) request.getReply();\n    EntityWrapper<Snapshot> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    List<Snapshot> snapshots = db.query( Snapshot.ownedBy( userName ) );\n    for ( Snapshot v : snapshots ) {\n      if ( request.getSnapshotSet().isEmpty() || request.getSnapshotSet().contains( v.getDisplayName() ) ) {\n//TODO: make this multi-cluster aware.\n        //        DescribeStorageSnapshotsResponseType snapshotInfo = null;\n//        try {\n//          snapshotInfo = ( DescribeStorageSnapshotsResponseType ) Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageSnapshotsType( Lists.newArrayList( v.getDisplayName() ) ) );\n//          for( StorageSnapshot storageSnapshot : snapshotInfo.getSnapshotSet() ) {\n//            v.setMappedState( storageSnapshot.getStatus() );\n//            edu.ucsb.eucalyptus.msgs.Snapshot snapReply = v.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n//            if( storageSnapshot.getProgress() != null )\n//              snapReply.setProgress( storageSnapshot.getProgress() );\n//            snapReply.setVolumeId( storageSnapshot.getVolumeId() );\n//            reply.getSnapshotSet().add( snapReply );\n//          }\n//        } catch ( EucalyptusCloudException e ) {\n//          LOG.debug( e, e );\n//          throw e;\n//        }\n      }\n    }\n    db.commit();\n    LOG.warn( \"RESPONSE ============\\n\" + reply );\n    return reply;\n  }","id":84264,"modified_method":"public DescribeSnapshotsResponseType DescribeSnapshots( DescribeSnapshotsType request ) throws EucalyptusCloudException {\n    DescribeSnapshotsResponseType reply = ( DescribeSnapshotsResponseType ) request.getReply();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n\n    EntityWrapper<Snapshot> db = getEntityWrapper();\n    List<Snapshot> snapshots = db.query( Snapshot.ownedBy( userName ) );\n\n    for ( Snapshot v : snapshots ) {\n      DescribeStorageSnapshotsType scRequest = new DescribeStorageSnapshotsType( Lists.newArrayList( v.getDisplayName() ) );\n      if ( request.getSnapshotSet().isEmpty() || request.getSnapshotSet().contains( v.getDisplayName() ) ) {\n        try {\n          StorageControllerConfiguration sc = Configuration.getStorageControllerConfiguration( v.getCluster( ) );\n          DescribeStorageSnapshotsResponseType snapshotInfo = StorageProxy.send( sc.getHostName( ), scRequest, DescribeStorageSnapshotsResponseType.class );\n          for( StorageSnapshot storageSnapshot : snapshotInfo.getSnapshotSet() ) {\n            v.setMappedState( storageSnapshot.getStatus() );\n            edu.ucsb.eucalyptus.msgs.Snapshot snapReply = v.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n            if( storageSnapshot.getProgress() != null )\n              snapReply.setProgress( storageSnapshot.getProgress() );\n            snapReply.setVolumeId( storageSnapshot.getVolumeId() );\n            reply.getSnapshotSet().add( snapReply );\n          }\n        } catch ( EucalyptusCloudException e ) {\n          LOG.warn( \"Error getting snapshot information from the Storage Controller: \" + e );\n          LOG.debug( e, e );\n        }\n      }\n    }\n    db.commit();\n    LOG.trace( \"RESPONSE ============\\n\" + reply );\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n  public static <REPLY> REPLY send( String scName, Object message, Class<REPLY> replyType ) throws EucalyptusCloudException {\n    return (REPLY) Messaging.send(StorageProxy.getAddress( scName ), message);\n  }","id":84265,"modified_method":"@SuppressWarnings( \"unchecked\" )\n  public static <REPLY> REPLY send( String scHostName, EucalyptusMessage message, Class<REPLY> replyType ) throws EucalyptusCloudException {\n    return (REPLY) ServiceProxy.lookup( Component.storage.getRegistryKey( scHostName ) ).send( message );\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteVolumeResponseType DeleteVolume( DeleteVolumeType request ) throws EucalyptusCloudException {\n    DeleteVolumeResponseType reply = ( DeleteVolumeResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Volume vol = db.getUnique( Volume.named( userName, request.getVolumeId() ) );\n      boolean isAttached = false;\n      for( VmInstance vm : VmInstances.getInstance().listValues() ) {\n        for( AttachedVolume attachedVol : vm.getVolumes() ) {\n          if( request.getVolumeId().equals( attachedVol.getVolumeId() ) ) {\n            isAttached = true;\n          }\n        }\n      }\n      if( isAttached ) return reply;\n      if( !vol.getState(  ).equals( State.ANNILATED ) ) {\n        StorageProxy.dispatch( vol.getCluster( ), new DeleteStorageVolumeType( vol.getDisplayName() ) );\n      }\n      db.delete( vol );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      return reply;\n    }\n    reply.set_return( true );\n    return reply;\n  }","id":84266,"modified_method":"public DeleteVolumeResponseType DeleteVolume( DeleteVolumeType request ) throws EucalyptusCloudException {\n    DeleteVolumeResponseType reply = ( DeleteVolumeResponseType ) request.getReply();\n    reply.set_return( false );\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Volume vol = db.getUnique( Volume.named( userName, request.getVolumeId() ) );\n      for( VmInstance vm : VmInstances.getInstance().listValues() ) {\n        for( AttachedVolume attachedVol : vm.getVolumes() ) {\n          if( request.getVolumeId().equals( attachedVol.getVolumeId() ) ) {\n            db.rollback( );\n            return reply;\n          }\n        }\n      }\n      db.delete( vol );\n      db.getSession( ).flush( );\n      if( !vol.getState(  ).equals( State.ANNILATED ) ) {\n        StorageProxy.dispatchAll( new DeleteStorageVolumeType( vol.getDisplayName() ) );\n      }\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      return reply;\n    }\n    reply.set_return( true );\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeVolumesResponseType DescribeVolumes( DescribeVolumesType request ) throws EucalyptusCloudException {\n    DescribeVolumesResponseType reply = ( DescribeVolumesResponseType ) request.getReply();\n    EntityWrapper<Volume> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n\n    Map<String, AttachedVolume> attachedVolumes = new HashMap<String, AttachedVolume>();\n    for ( VmInstance vm : VmInstances.getInstance().listValues() ) {\n      for ( AttachedVolume av : vm.getVolumes() ) {\n        attachedVolumes.put( av.getVolumeId(), av );\n      }\n    }\n    List<Volume> volumes = db.query( Volume.ownedBy( userName ) );\n    for ( Volume v : volumes ) {\n      if ( request.getVolumeSet().isEmpty() || request.getVolumeSet().contains( v.getDisplayName() ) ) {\n        DescribeStorageVolumesResponseType volState = StorageProxy.send( v.getCluster( ), new DescribeStorageVolumesType( Lists.newArrayList( v.getDisplayName() ) ), DescribeStorageVolumesResponseType.class  );\n        LOG.debug( volState );\n        String volumeState = \"unavailable\";\n        if ( !volState.getVolumeSet().isEmpty() ) {\n          StorageVolume vol = volState.getVolumeSet().get( 0 );\n          volumeState = vol.getStatus();\n          v.setSize( new Integer( vol.getSize() ) );\n          v.setRemoteDevice( vol.getActualDeviceName() );\n        }\n        if ( attachedVolumes.containsKey( v.getDisplayName() ) ) {\n          volumeState = \"in-use\";\n        }\n        v.setMappedState( volumeState );\n        edu.ucsb.eucalyptus.msgs.Volume aVolume = v.morph( new edu.ucsb.eucalyptus.msgs.Volume() );\n        if ( attachedVolumes.containsKey( v.getDisplayName() ) ) {\n          aVolume.setStatus( volumeState );\n          aVolume.getAttachmentSet().add( attachedVolumes.get( aVolume.getVolumeId() ) );\n        }\n        reply.getVolumeSet().add( aVolume );\n      }\n    }\n    db.commit();\n    return reply;\n  }","id":84267,"modified_method":"public DescribeVolumesResponseType DescribeVolumes( DescribeVolumesType request ) throws EucalyptusCloudException {\n    DescribeVolumesResponseType reply = ( DescribeVolumesResponseType ) request.getReply();\n    EntityWrapper<Volume> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n\n    Map<String, AttachedVolume> attachedVolumes = new HashMap<String, AttachedVolume>();\n    for ( VmInstance vm : VmInstances.getInstance().listValues() ) {\n      for ( AttachedVolume av : vm.getVolumes() ) {\n        attachedVolumes.put( av.getVolumeId(), av );\n      }\n    }\n    \n    List<Volume> volumes = db.query( Volume.ownedBy( userName ) );\n\n    for ( Volume v : volumes ) {\n      if ( request.getVolumeSet().isEmpty() || request.getVolumeSet().contains( v.getDisplayName() ) ) {\n        try {\n          edu.ucsb.eucalyptus.msgs.Volume aVolume = StorageProxy.getVolumeReply( attachedVolumes, v );\n          reply.getVolumeSet().add( aVolume );\n        } catch ( Exception e ) {\n          LOG.warn( \"Error getting volume information from the Storage Controller: \" + e );\n          LOG.debug( e, e );\n        }\n      }\n    }\n    db.commit();\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateVolumeResponseType CreateVolume( CreateVolumeType request ) throws EucalyptusCloudException {\n    if ( !Clusters.getInstance().contains( request.getAvailabilityZone() ) ) {\n      throw new EucalyptusCloudException( \"Zone does not exist: \" + request.getAvailabilityZone() );\n    }\n    if( ( request.getSnapshotId() == null && request.getSize() == null ) || ( request.getSnapshotId() != null && request.getSize() != null ) ) {\n      throw new EucalyptusCloudException( \"One of 'snapshotId' or 'size' must be set.\" );\n    }\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    if ( !( request.getSnapshotId() == null ) ) {\n      String userName = request.isAdministrator() ? null : request.getUserId();\n      try {\n        db.recast( Snapshot.class ).getUnique( Snapshot.named( userName, request.getSnapshotId() ) );\n      } catch ( EucalyptusCloudException e ) {\n        LOG.debug( e, e );\n        db.rollback();\n        throw new EucalyptusCloudException( \"Snapshot does not exist: \" + request.getSnapshotId() );\n      }\n    }\n    String newId = null;\n    Volume newVol = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( Volume.ownedBy( newId ) );\n      } catch ( EucalyptusCloudException e ) {\n        newVol = new Volume( request.getUserId(), newId, new Integer( request.getSize() != null ? request.getSize() : \"-1\" ),\n                             request.getAvailabilityZone(), request.getSnapshotId() );\n        db.add( newVol );\n        break;\n      }\n    }\n    newVol.setState( State.GENERATING );\n    CreateStorageVolumeType scRequest = new CreateStorageVolumeType( newId, request.getSize(), request.getSnapshotId() );\n    CreateStorageVolumeResponseType scReply = null;\n    try {\n      scReply =  StorageProxy.send( newVol.getCluster( ), scRequest, CreateStorageVolumeResponseType.class );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageVolume:\" + e.getMessage() );\n    }\n    db.commit();\n    CreateVolumeResponseType reply = ( CreateVolumeResponseType ) request.getReply();\n    reply.setVolume( newVol.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n    return reply;\n  }","id":84268,"modified_method":"public CreateVolumeResponseType CreateVolume( CreateVolumeType request ) throws EucalyptusCloudException {\n    if( ( request.getSnapshotId() == null && request.getSize() == null ) || ( request.getSnapshotId() != null && request.getSize() == null ) ) {\n      throw new EucalyptusCloudException( \"Size is a required parameter.\" );\n    }\n\n    try {\n      Configuration.getClusterConfiguration( request.getAvailabilityZone( ) );\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException( \"Zone does not exist: \" + request.getAvailabilityZone(), e );\n    }\n\n    StorageControllerConfiguration sc;\n    try {\n      sc = Configuration.getStorageControllerConfiguration( request.getAvailabilityZone( ) );\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException(\"Storage services are not available for the requested availability zone.\", e );\n    }\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    if ( request.getSnapshotId() != null ) {\n      String userName = request.isAdministrator() ? null : request.getUserId();\n      try {\n        db.recast( Snapshot.class ).getUnique( Snapshot.named( userName, request.getSnapshotId() ) );\n      } catch ( EucalyptusCloudException e ) {\n        LOG.debug( e, e );\n        db.rollback();\n        throw new EucalyptusCloudException( \"Snapshot does not exist: \" + request.getSnapshotId() );\n      }\n    }\n    \n    String newId = null;\n    Volume newVol = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( Volume.ownedBy( newId ) );\n      } catch ( EucalyptusCloudException e ) {\n        newVol = new Volume( request.getUserId(), newId, new Integer( request.getSize() != null ? request.getSize() : \"-1\" ),\n                             request.getAvailabilityZone(), request.getSnapshotId() );\n        db.add( newVol );\n        break;\n      }\n    }\n    newVol.setState( State.GENERATING );\n\n    try {\n      CreateStorageVolumeType req = new CreateStorageVolumeType( newId, request.getSize( ), request.getSnapshotId( ) );\n      req.setUserId( request.getUserId( ) );\n      req.setEffectiveUserId( request.getEffectiveUserId( ) );\n      StorageProxy.send( sc.getHostName( ), req, CreateStorageVolumeResponseType.class );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error communicating with Storage Controller: CreateStorageVolume:\" + e.getMessage() );\n    }\n    db.commit();\n\n    CreateVolumeResponseType reply = ( CreateVolumeResponseType ) request.getReply();\n    reply.setVolume( newVol.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void triggerCaching( ImageInfo imgInfo ) {\n    String[] parts = imgInfo.getImageLocation().split( \"/\" );\n    CacheImageType cache = new CacheImageType();\n    cache.setUserId( imgInfo.getImageOwnerId( ) );\n    cache.setBucket( parts[ 0 ] );\n    cache.setKey( parts[ 1 ] );\n    ServiceProxy.lookup( Component.walrus, Component.walrus.name( ) ).dispatch( cache );\n  }","id":84269,"modified_method":"public static void triggerCaching( ImageInfo imgInfo ) {\n    String[] parts = imgInfo.getImageLocation().split( \"/\" );\n    CacheImageType cache = new CacheImageType();\n    cache.setUserId( imgInfo.getImageOwnerId( ) );\n    cache.setBucket( parts[ 0 ] );\n    cache.setKey( parts[ 1 ] );\n    ServiceProxy.lookup( Component.walrus.getRegistryKey( Component.walrus.getHostAddress( ) ) ).dispatch( cache );\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void verifyManifestIntegrity( final ImageInfo imgInfo ) throws EucalyptusCloudException {\n    String[] imagePathParts = imgInfo.getImageLocation().split( \"/\" );\n    GetObjectResponseType reply = null;\n    GetObjectType msg = new GetObjectType( imagePathParts[ 0 ], imagePathParts[ 1 ], true, false, true );\n    msg.setUserId( Component.eucalyptus.name() );\n    msg.setEffectiveUserId( Component.eucalyptus.name() );\n    try {\n      reply = ( GetObjectResponseType ) ServiceProxy.lookup( Component.walrus, Component.walrus.name( ) ).send( msg );\n    } catch ( EucalyptusCloudException e ) {\n      ImageManager.LOG.error( e );\n      ImageManager.LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Invalid manifest reference: \" + imgInfo.getImageLocation(), e );\n    }\n  \n    if ( reply == null || reply.getBase64Data() == null ) throw new EucalyptusCloudException( \"Invalid manifest reference: \" + imgInfo.getImageLocation() );\n    XMLParser parser = new XMLParser( reply.getBase64Data() );\n    String encryptedKey = parser.getValue( \"//ec2_encrypted_key\" );\n    String encryptedIV = parser.getValue( \"//ec2_encrypted_iv\" );\n    String signature = parser.getValue( \"//signature\" );\n    String image = parser.getXML( \"image\" );\n    String machineConfiguration = parser.getXML( \"machine_configuration\" );\n  \n    List<String> aliases = Lists.newArrayList();\n    try {\n      for( X509Cert x : UserCredentialProvider.getUser( imgInfo.getImageOwnerId( ) ).getCertificates( ) ) {\n        aliases.add( x.getAlias( ) );\n      }\n    } catch ( NoSuchUserException e ) {\n      throw new EucalyptusCloudException( \"Invalid Manifest: Failed to verify signature because of missing (deleted?) user certificate.\", e );\n    }\n    boolean found = false;\n    for ( String alias : aliases )\n      found |= ImageUtil.verifyManifestSignature( signature, alias, machineConfiguration + image );\n    if ( !found ) throw new EucalyptusCloudException( \"Invalid Manifest: Failed to verify signature.\" );\n  \n    try {\n      PrivateKey pk = SystemCredentialProvider.getCredentialProvider(Component.eucalyptus).getPrivateKey();\n      Cipher cipher = Cipher.getInstance( \"RSA/ECB/PKCS1Padding\" );\n      cipher.init( Cipher.DECRYPT_MODE, pk );\n      cipher.doFinal( Hashes.hexToBytes( encryptedKey ) );\n      cipher.doFinal( Hashes.hexToBytes( encryptedIV ) );\n    } catch ( Exception ex ) {\n      throw new EucalyptusCloudException( \"Invalid Manifest: Failed to recover keys.\", ex );\n    }\n  }","id":84270,"modified_method":"public static void verifyManifestIntegrity( final ImageInfo imgInfo ) throws EucalyptusCloudException {\n    String[] imagePathParts = imgInfo.getImageLocation().split( \"/\" );\n    GetObjectResponseType reply = null;\n    GetObjectType msg = new GetObjectType( imagePathParts[ 0 ], imagePathParts[ 1 ], true, false, true );\n    msg.setUserId( Component.eucalyptus.name() );\n    msg.setEffectiveUserId( Component.eucalyptus.name() );\n    try {\n      reply = ( GetObjectResponseType ) ServiceProxy.lookup( Component.walrus.getRegistryKey( Component.walrus.getHostAddress( ) ) ).send( msg );\n    } catch ( EucalyptusCloudException e ) {\n      ImageManager.LOG.error( e );\n      ImageManager.LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Invalid manifest reference: \" + imgInfo.getImageLocation(), e );\n    }\n  \n    if ( reply == null || reply.getBase64Data() == null ) throw new EucalyptusCloudException( \"Invalid manifest reference: \" + imgInfo.getImageLocation() );\n    XMLParser parser = new XMLParser( reply.getBase64Data() );\n    String encryptedKey = parser.getValue( \"//ec2_encrypted_key\" );\n    String encryptedIV = parser.getValue( \"//ec2_encrypted_iv\" );\n    String signature = parser.getValue( \"//signature\" );\n    String image = parser.getXML( \"image\" );\n    String machineConfiguration = parser.getXML( \"machine_configuration\" );\n  \n    List<String> aliases = Lists.newArrayList();\n    try {\n      for( X509Cert x : UserCredentialProvider.getUser( imgInfo.getImageOwnerId( ) ).getCertificates( ) ) {\n        aliases.add( x.getAlias( ) );\n      }\n    } catch ( NoSuchUserException e ) {\n      throw new EucalyptusCloudException( \"Invalid Manifest: Failed to verify signature because of missing (deleted?) user certificate.\", e );\n    }\n    boolean found = false;\n    for ( String alias : aliases )\n      found |= ImageUtil.verifyManifestSignature( signature, alias, machineConfiguration + image );\n    if ( !found ) throw new EucalyptusCloudException( \"Invalid Manifest: Failed to verify signature.\" );\n  \n    try {\n      PrivateKey pk = SystemCredentialProvider.getCredentialProvider(Component.eucalyptus).getPrivateKey();\n      Cipher cipher = Cipher.getInstance( \"RSA/ECB/PKCS1Padding\" );\n      cipher.init( Cipher.DECRYPT_MODE, pk );\n      cipher.doFinal( Hashes.hexToBytes( encryptedKey ) );\n      cipher.doFinal( Hashes.hexToBytes( encryptedIV ) );\n    } catch ( Exception ex ) {\n      throw new EucalyptusCloudException( \"Invalid Manifest: Failed to recover keys.\", ex );\n    }\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static GetBucketAccessControlPolicyResponseType getBucketAcl( RegisterImageType request, String[] imagePathParts ) throws EucalyptusCloudException {\n    GetBucketAccessControlPolicyType getBukkitInfo = Admin.makeMsg( GetBucketAccessControlPolicyType.class, request );\n    getBukkitInfo.setBucket( imagePathParts[ 0 ] );\n    GetBucketAccessControlPolicyResponseType reply = ( GetBucketAccessControlPolicyResponseType ) ServiceProxy.lookup( Component.walrus, Component.walrus.name( ) ).send( getBukkitInfo );\n    return reply;\n  }","id":84271,"modified_method":"public static GetBucketAccessControlPolicyResponseType getBucketAcl( RegisterImageType request, String[] imagePathParts ) throws EucalyptusCloudException {\n    GetBucketAccessControlPolicyType getBukkitInfo = Admin.makeMsg( GetBucketAccessControlPolicyType.class, request );\n    getBukkitInfo.setBucket( imagePathParts[ 0 ] );\n    GetBucketAccessControlPolicyResponseType reply = ( GetBucketAccessControlPolicyResponseType ) ServiceProxy.lookup( Component.walrus.getRegistryKey( Component.walrus.getHostAddress( ) )).send( getBukkitInfo );\n    return reply;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void checkValid( ImageInfo imgInfo ) {\n    String[] parts = imgInfo.getImageLocation().split( \"/\" );\n    CheckImageType check = new CheckImageType();\n    check.setUserId( imgInfo.getImageOwnerId( ) );\n    check.setBucket( parts[ 0 ] );\n    check.setKey( parts[ 1 ] );\n    ServiceProxy.lookup( Component.walrus, Component.walrus.name( ) ).dispatch( check );\n  }","id":84272,"modified_method":"public static void checkValid( ImageInfo imgInfo ) {\n    String[] parts = imgInfo.getImageLocation().split( \"/\" );\n    CheckImageType check = new CheckImageType();\n    check.setUserId( imgInfo.getImageOwnerId( ) );\n    check.setBucket( parts[ 0 ] );\n    check.setKey( parts[ 1 ] );\n    ServiceProxy.lookup( Component.walrus.getRegistryKey( Component.walrus.getHostAddress( ) ) ).dispatch( check );\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Document getManifestData( String userId, String bucketName, String objectName ) throws EucalyptusCloudException {\n    GetObjectResponseType reply = null;\n    try {\n      GetObjectType msg = new GetObjectType( bucketName, objectName, true, false, true );\n      msg.setUserId( userId );\n      \n      reply = ( GetObjectResponseType ) ServiceProxy.lookup( Component.walrus, Component.walrus.name( ) ).send( msg );\n    }\n    catch ( Exception e ) {\n      throw new EucalyptusCloudException( \"Failed to read manifest file: \" + bucketName + \"/\" + objectName, e );\n    }\n  \n    Document inputSource = null;\n    try {\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      inputSource = builder.parse( new ByteArrayInputStream( reply.getBase64Data().getBytes() ) );\n    }\n    catch ( Exception e ) {\n      throw new EucalyptusCloudException( \"Failed to read manifest file: \" + bucketName + \"/\" + objectName, e );\n    }\n    return inputSource;\n  }","id":84273,"modified_method":"public static Document getManifestData( String userId, String bucketName, String objectName ) throws EucalyptusCloudException {\n    GetObjectResponseType reply = null;\n    try {\n      GetObjectType msg = new GetObjectType( bucketName, objectName, true, false, true );\n      msg.setUserId( userId );\n      \n      reply = ( GetObjectResponseType ) ServiceProxy.lookup( Component.walrus.getRegistryKey( Component.walrus.getHostAddress( ) ) ).send( msg );\n    }\n    catch ( Exception e ) {\n      throw new EucalyptusCloudException( \"Failed to read manifest file: \" + bucketName + \"/\" + objectName, e );\n    }\n  \n    Document inputSource = null;\n    try {\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      inputSource = builder.parse( new ByteArrayInputStream( reply.getBase64Data().getBytes() ) );\n    }\n    catch ( Exception e ) {\n      throw new EucalyptusCloudException( \"Failed to read manifest file: \" + bucketName + \"/\" + objectName, e );\n    }\n    return inputSource;\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void invalidate( ImageInfo imgInfo ) {\n    String[] parts = imgInfo.getImageLocation().split( \"/\" );\n    imgInfo.setImageState( \"deregistered\" );\n    try {\n      ServiceProxy.lookup( Component.walrus, Component.walrus.name( ) ).dispatch( new FlushCachedImageType( parts[ 0 ], parts[ 1 ] ) );\n    } catch ( Exception e ) {}\n  }","id":84274,"modified_method":"public static void invalidate( ImageInfo imgInfo ) {\n    String[] parts = imgInfo.getImageLocation().split( \"/\" );\n    imgInfo.setImageState( \"deregistered\" );\n    try {\n      ServiceProxy.lookup( Component.walrus.getRegistryKey( Component.walrus.getHostAddress( ) )).dispatch( new FlushCachedImageType( parts[ 0 ], parts[ 1 ] ) );\n    } catch ( Exception e ) {}\n  }","commit_id":"3110ca6dbf06922706848d4c9dc86a7b6046003e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SerializableNodeModel(XtextResource resource) {\n\t\tICompositeNode rootNode = resource.getParseResult().getRootNode();\n\n\t\tif (rootNode != null) {\n\t\t\troot = (RootNode) rootNode;\n\t\t}\n\n\t\tformatVersion = 1;\n\t\tdate = new Date();\n\t}","id":84275,"modified_method":"public SerializableNodeModel(XtextResource resource) {\n\t\tIParseResult parseResult = resource.getParseResult();\n\t\tif (parseResult != null) {\n\t\t\tICompositeNode rootNode = parseResult.getRootNode();\n\t\t\troot = (RootNode) rootNode;\n\t\t}\n\t\tformatVersion = 1;\n\t\tdate = new Date();\n\t}","commit_id":"594fab6ddfec4ff51455da5e81363cb0df50ded8","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void fillGrammarElementToIdMap(XtextResource r) {\n\t\tRootNode it = (RootNode) r.getParseResult().getRootNode();\n\t\tit.fillGrammarElementToIdMap(grammarElementToIdMap, grammarIdToURIMap);\n\t}","id":84276,"modified_method":"protected void fillGrammarElementToIdMap(XtextResource r) {\n\t\tIParseResult parseResult = r.getParseResult();\n\t\tif (parseResult != null) {\n\t\t\tRootNode it = (RootNode) parseResult.getRootNode();\n\t\t\tit.fillGrammarElementToIdMap(grammarElementToIdMap, grammarIdToURIMap);\n\t\t}\n\t}","commit_id":"594fab6ddfec4ff51455da5e81363cb0df50ded8","url":"https://github.com/eclipse/xtext"},{"original_method":"public Map<JvmDeclaredType, String> resolveConflicts(TypeUsages usages, VisibleTypesFromHierarchy typesFromHierarchy, XtendFile xtendFile) {\n\t\tString packageName = xtendFile.getPackage();\n\t\tImportSection importSection = new ImportSection(xtendFile);\n\t\tMap<String, JvmDeclaredType> locallyDeclaredTypes = getLocallyDeclaredTypes(xtendFile);\n\t\tMap<JvmDeclaredType, String> result = newLinkedHashMap();\n\t\tMultimap<String, JvmDeclaredType> simpleName2Types = usages.getSimpleName2Types();\n\t\tfor (String simpleName : simpleName2Types.keySet()) {\n\t\t\tCollection<JvmDeclaredType> types = simpleName2Types.get(simpleName);\n\t\t\tJvmDeclaredType locallyDeclaredType = locallyDeclaredTypes.get(simpleName);\n\t\t\tif (locallyDeclaredType != null || isConflictsWithVisibleTypes(types, usages, typesFromHierarchy, simpleName)) {\n\t\t\t\tfor (JvmDeclaredType type : types) {\n\t\t\t\t\tif (type != locallyDeclaredType)\n\t\t\t\t\t\tresult.put(type, type.getIdentifier());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (types.size() == 1) {\n\t\t\t\t\tresult.put(types.iterator().next(), simpleName);\n\t\t\t\t} else {\n\t\t\t\t\tJvmDeclaredType bestMatch = findBestMatch(types, usages, packageName, importSection);\n\t\t\t\t\tfor (JvmDeclaredType type : types) {\n\t\t\t\t\t\tif (type == bestMatch)\n\t\t\t\t\t\t\tresult.put(type, simpleName);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresult.put(type, type.getIdentifier());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":84277,"modified_method":"public Map<String, JvmDeclaredType> resolveConflicts(TypeUsages usages, NonOverridableTypesProvider nonOverridableTypesProvider, XtendFile xtendFile) {\n\t\tString packageName = xtendFile.getPackage();\n\t\tImportSection importSection = new ImportSection(xtendFile);\n\t\tMap<String, JvmDeclaredType> locallyDeclaredTypes = getLocallyDeclaredTypes(xtendFile);\n\t\tMap<String, JvmDeclaredType> result = newLinkedHashMap();\n\t\tMultimap<String, JvmDeclaredType> simpleName2Types = usages.getSimpleName2Types();\n\t\tfor (String simpleName : simpleName2Types.keySet()) {\n\t\t\tCollection<JvmDeclaredType> types = simpleName2Types.get(simpleName);\n\t\t\tJvmDeclaredType locallyDeclaredType = locallyDeclaredTypes.get(simpleName);\n\t\t\tif (locallyDeclaredType != null || isConflictsWithVisibleTypes(types, usages, nonOverridableTypesProvider, simpleName)) {\n\t\t\t\tfor (JvmDeclaredType type : types) {\n\t\t\t\t\tif (type != locallyDeclaredType)\n\t\t\t\t\t\tresult.put(type.getIdentifier(), type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (types.size() == 1) {\n\t\t\t\t\tresult.put(simpleName, types.iterator().next());\n\t\t\t\t} else {\n\t\t\t\t\tJvmDeclaredType bestMatch = findBestMatch(types, usages, packageName, importSection);\n\t\t\t\t\tfor (JvmDeclaredType type : types) {\n\t\t\t\t\t\tif (type == bestMatch)\n\t\t\t\t\t\t\tresult.put(simpleName, type);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresult.put(type.getIdentifier(), type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean isConflictsWithVisibleTypes(Iterable<JvmDeclaredType> types, TypeUsages usages, \n\t\t\tVisibleTypesFromHierarchy typesFromHierarchy, String simpleName) {\n\t\tfor(JvmDeclaredType type: types) {\n\t\t\tfor(TypeUsage usage: usages.getUsages(type)) {\n\t\t\t\tJvmIdentifiableElement visibleType = typesFromHierarchy.getVisibleType(usage.getContext(), simpleName);\n\t\t\t\tif(visibleType != null && !visibleType.equals(type))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":84278,"modified_method":"protected boolean isConflictsWithVisibleTypes(Iterable<JvmDeclaredType> types, TypeUsages usages, \n\t\t\tNonOverridableTypesProvider nonOverridableTypesProvider, String simpleName) {\n\t\tfor(JvmDeclaredType type: types) {\n\t\t\tfor(TypeUsage usage: usages.getUsages(type)) {\n\t\t\t\tJvmIdentifiableElement visibleType = nonOverridableTypesProvider.getVisibleType(usage.getContext(), simpleName);\n\t\t\t\tif(visibleType != null && !visibleType.equals(type))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<ReplaceRegion> getOrganizedImportChanges(XtextResource state) {\n\t\tXtendFile xtendFile = getXtendFile(state);\n\t\tSet<JvmDeclaredType> locallyDeclaredTypes = getDeclaredTypes(xtendFile);\n\t\tTypeUsageCollector typeUsageCollector = typeUsageCollectorProvider.get();\n\t\tTypeUsages typeUsages = typeUsageCollector.collectTypeUsages(xtendFile);\n\t\tMap<JvmDeclaredType, String> type2name = conflictResolver.resolveConflicts(typeUsages, typesFromHierarchy, xtendFile);\n\t\tSet<String> implicitlyImportedPackages = getImplicitlyImportedPackages(xtendFile);\n\t\tImportSection newImportSection = new ImportSection();\n\t\tList<ReplaceRegion> replaceRegions = newArrayList();\n\t\tfor(Map.Entry<JvmDeclaredType, String> entry: type2name.entrySet()) {\n\t\t\tJvmDeclaredType type = entry.getKey();\n\t\t\tString text = entry.getValue();\n\t\t\tIterable<TypeUsage> usages = typeUsages.getUsages(type);\n\t\t\tif(needsImport(type, text, xtendFile, locallyDeclaredTypes, implicitlyImportedPackages, typesFromHierarchy, usages)) {\n\t\t\t\tnewImportSection.getImportedTypes().add(type);\n\t\t\t}\n\t\t\tfor(TypeUsage usage: usages) {\n\t\t\t\tif(!equal(usage.getText(), text)) {\n\t\t\t\t\treplaceRegions.add(new ReplaceRegion(usage.getTextRegion(), text));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewImportSection.getStaticImports().addAll(typeUsages.getStaticImports());\n\t\tnewImportSection.getExtensionImports().addAll(typeUsages.getExtensionImports());\n\t\treplaceRegions.add(importSectionSerializer.serialize(xtendFile, newImportSection));\n\t\treturn replaceRegions; \n\t}","id":84279,"modified_method":"public List<ReplaceRegion> getOrganizedImportChanges(XtextResource state) {\n\t\tXtendFile xtendFile = getXtendFile(state);\n\t\tSet<JvmDeclaredType> locallyDeclaredTypes = getDeclaredTypes(xtendFile);\n\t\tTypeUsageCollector typeUsageCollector = typeUsageCollectorProvider.get();\n\t\tTypeUsages typeUsages = typeUsageCollector.collectTypeUsages(xtendFile);\n\t\tif(unresolvedTypeResolver != null) \n\t\t\tunresolvedTypeResolver.resolve(typeUsages, state);\n\t\tMap<String, JvmDeclaredType> name2type = conflictResolver.resolveConflicts(typeUsages, nonOverridableTypesProvider, xtendFile);\n\t\tSet<String> implicitlyImportedPackages = getImplicitlyImportedPackages(xtendFile);\n\t\tImportSection newImportSection = new ImportSection();\n\t\tList<ReplaceRegion> replaceRegions = newArrayList();\n\t\tfor(Map.Entry<String, JvmDeclaredType> entry: name2type.entrySet()) {\n\t\t\tString text = entry.getKey();\n\t\t\tJvmDeclaredType type = entry.getValue();\n\t\t\tIterable<TypeUsage> usages = typeUsages.getUsages(type);\n\t\t\tif(needsImport(type, text, xtendFile, locallyDeclaredTypes, implicitlyImportedPackages, nonOverridableTypesProvider, usages)) {\n\t\t\t\tnewImportSection.getImportedTypes().add(type);\n\t\t\t}\n\t\t\tfor(TypeUsage usage: usages) {\n\t\t\t\tif(!equal(usage.getText(), text)) {\n\t\t\t\t\treplaceRegions.add(new ReplaceRegion(usage.getTextRegion(), text));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewImportSection.getStaticImports().addAll(typeUsages.getStaticImports());\n\t\tnewImportSection.getExtensionImports().addAll(typeUsages.getExtensionImports());\n\t\treplaceRegions.add(importSectionSerializer.serialize(xtendFile, newImportSection));\n\t\treturn replaceRegions; \n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean needsImport(JvmDeclaredType type, String name, XtendFile xtendFile,\n\t\t\tSet<JvmDeclaredType> locallyDefinedTypes, Set<String> implicitlyImportedPackages, \n\t\t\tVisibleTypesFromHierarchy typesFromHierarchy, Iterable<TypeUsage> usages)  {\n\t\treturn !((type.getIdentifier().equals(name))\n\t\t\t|| implicitlyImportedPackages.contains(type.getPackageName())\n\t\t\t|| locallyDefinedTypes.contains(type)\n\t\t\t|| isVisibleFromHierarchyEverywhere(usages, typesFromHierarchy, name));\n\t}","id":84280,"modified_method":"protected boolean needsImport(JvmDeclaredType type, String name, XtendFile xtendFile,\n\t\t\tSet<JvmDeclaredType> locallyDefinedTypes, Set<String> implicitlyImportedPackages, \n\t\t\tNonOverridableTypesProvider nonOverridableTypesProvider, Iterable<TypeUsage> usages)  {\n\t\treturn !((type.getIdentifier().equals(name))\n\t\t\t|| implicitlyImportedPackages.contains(type.getPackageName())\n\t\t\t|| locallyDefinedTypes.contains(type)\n\t\t\t|| isUsedInNonOverridableContextOnly(usages, nonOverridableTypesProvider, name));\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"public void doOrganizeImports(final IXtextDocument document) {\n\t\tPair<Region, String> result = document.readOnly(new IUnitOfWork<Pair<Region,String>, XtextResource>() {\n\t\t\tpublic Pair<Region,String> exec(XtextResource state) throws Exception {\n\t\t\t\tfinal TextRegion computeRegion = organizeImports.computeRegion(state);\n\t\t\t\tif (computeRegion == null)\n\t\t\t\t\treturn null;\n\t\t\t\tfinal String organizedImportSection = organizeImports.getOrganizedImportSection(state);\n\t\t\t\tif (organizedImportSection == null)\n\t\t\t\t\treturn null;\n\t\t\t\treturn Tuples.create(new Region(computeRegion.getOffset(), computeRegion.getLength()) , organizedImportSection);\n\t\t\t}\n\t\t});\n\t\tif (result == null)\n\t\t\treturn;\n\t\ttry {\n\t\t\tString string = document.get(result.getFirst().getOffset(), result.getFirst().getLength());\n\t\t\tif (!string.equals(result.getSecond())) {\n\t\t\t\tdocument.replace(result.getFirst().getOffset(), result.getFirst().getLength(), result.getSecond());\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\t// ignore\n\t\t}\n\t}","id":84281,"modified_method":"public void doOrganizeImports(final IXtextDocument document) {\n\t\tList<ReplaceRegion> result = document.readOnly(new IUnitOfWork<List<ReplaceRegion>, XtextResource>() {\n\t\t\tpublic List<ReplaceRegion> exec(XtextResource state) throws Exception {\n\t\t\t\treturn importOrganizer.getOrganizedImportChanges(state);\n\t\t\t}\n\t\t});\n\t\tif (result == null)\n\t\t\treturn;\n\t\ttry {\n\t\t\tMultiTextEdit multiTextEdit = new MultiTextEdit();\n\t\t\tfor(ReplaceRegion replaceRegion: result) {\n\t\t\t\tmultiTextEdit.addChild(new ReplaceEdit(replaceRegion.getOffset(), replaceRegion.getLength(), replaceRegion.getText()));\n\t\t\t}\n\t\t\tmultiTextEdit.apply(document);\n\t\t} catch (BadLocationException e) {\n\t\t\t// ignore\n\t\t}\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void acceptType(JvmType type, String refText, ITextRegion refRegion) {\n\t\tif (type instanceof JvmDeclaredType && !type.equals(currentThisType)) {\n\t\t\tString simpleName = type.getSimpleName();\n\t\t\t\ttypeUsages.addTypeUsage((JvmDeclaredType) type, refText, refRegion, currentContext);\n\t\t}\n\t}","id":84282,"modified_method":"protected void acceptType(JvmType type, String refText, ITextRegion refRegion) {\n\t\tif (type == null || type.eIsProxy()) {\n\t\t\ttypeUsages.addUnresolved(refText, refRegion, currentContext);\n\t\t} else if (type instanceof JvmDeclaredType && !type.equals(currentThisType)) {\n\t\t\ttypeUsages.addTypeUsage((JvmDeclaredType) type, refText, refRegion, currentContext);\n\t\t}\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void acceptPreferredType(EObject owner, EReference referenceToTypeOrMember) {\n\t\tITextRegion refRegion = locationInFileProvider.getSignificantTextRegion(owner, referenceToTypeOrMember, 0);\n\t\tString refText = resource.getParseResult().getRootNode().getText().substring(\n\t\t\t\trefRegion.getOffset(), refRegion.getOffset() + refRegion.getLength());\n\t\tPair<JvmDeclaredType, String> preferredType = findPreferredType(owner, referenceToTypeOrMember);\n\t\tif(preferredType.getSecond() != null) {\n\t\t\trefRegion = new TextRegion(refRegion.getOffset(), refRegion.getLength() - refText.length() + preferredType.getSecond().length());\n\t\t\trefText = preferredType.getSecond();\n\t\t}\n\t\tacceptType(preferredType.getFirst(), refText, refRegion);\n\t}","id":84283,"modified_method":"protected void acceptPreferredType(EObject owner, EReference referenceToTypeOrMember) {\n\t\tITextRegion refRegion = locationInFileProvider.getSignificantTextRegion(owner, referenceToTypeOrMember, 0);\n\t\tIParseResult parseResult = resource.getParseResult();\n\t\tif(parseResult != null) {\n\t\t\tString refText = parseResult.getRootNode().getText().substring(\n\t\t\t\t\trefRegion.getOffset(), refRegion.getOffset() + refRegion.getLength());\n\t\t\tPair<JvmDeclaredType, String> preferredType = findPreferredType(owner, referenceToTypeOrMember);\n\t\t\tif (preferredType.getFirst() != null) {\n\t\t\t\tif (preferredType.getSecond() != null) {\n\t\t\t\t\trefRegion = new TextRegion(refRegion.getOffset(), refRegion.getLength() - refText.length() + preferredType.getSecond().length());\n\t\t\t\t\trefText = preferredType.getSecond();\n\t\t\t\t}\n\t\t\t\tacceptType(preferredType.getFirst(), refText, refRegion);\n\t\t\t}\n\t\t}\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Tries to locate the syntax for the type reference that the user used in the original code.\n\t * Especially interesting for nested types, where one could prefer the (arguably) more explicit (or verbose)\n\t * {@code Resource$Factory} with an import of {@code org.eclipse.emf.core.Resource} over the probably shorter\n\t * {@code Factory} with an import of {@code org.eclipse.emf.core.Resource$Factory}.\n\t * \n\t * The function relies on a node model to be available. Otherwise the actually referenced type is \n\t * used as the preferred type.\n\t * \n\t * @param owner the referrer to the JVM concept.\n\t * @param reference a reference to a {@link JvmType} or {@link JvmMember} that is declared in a type.\n\t * @return the referenced type or one of its containers.\n\t */\n\tprotected Pair<JvmDeclaredType, String> findPreferredType(EObject owner, EReference reference) {\n\t\tJvmIdentifiableElement referencedThing = (JvmIdentifiableElement) owner.eGet(reference);\n\t\tJvmDeclaredType referencedType = null;\n\t\tif (referencedThing instanceof JvmDeclaredType) {\n\t\t\treferencedType = (JvmDeclaredType) referencedThing;\n\t\t} else if (referencedThing instanceof JvmMember) {\n\t\t\treferencedType = ((JvmMember) referencedThing).getDeclaringType();\n\t\t}\n\t\tList<INode> nodes = NodeModelUtils.findNodesForFeature(owner, reference);\n\t\tif (nodes.size() == 1) {\n\t\t\tString text = NodeModelUtils.getTokenText(nodes.get(0));\n\t\t\tint dollar = text.lastIndexOf('$');\n\t\t\tString preferredTypeText = text; \n\t\t\tif (dollar >= 0) {\n\t\t\t\tJvmDeclaredType declaredType = referencedType;\n\t\t\t\twhile(declaredType.getDeclaringType() != null && dollar >= 0) {\n\t\t\t\t\tdeclaredType = declaredType.getDeclaringType();\n\t\t\t\t\tpreferredTypeText = text.substring(0, dollar);\n\t\t\t\t\tdollar = text.lastIndexOf('$', dollar-1);\n\t\t\t\t}\n\t\t\t\treturn Tuples.create(declaredType, preferredTypeText);\n\t\t\t}\n\t\t}\n\t\treturn Tuples.create(referencedType, null);\n\t}","id":84284,"modified_method":"/**\n\t * Tries to locate the syntax for the type reference that the user used in the original code.\n\t * Especially interesting for nested types, where one could prefer the (arguably) more explicit (or verbose)\n\t * {@code Resource$Factory} with an import of {@code org.eclipse.emf.core.Resource} over the probably shorter\n\t * {@code Factory} with an import of {@code org.eclipse.emf.core.Resource$Factory}.\n\t * \n\t * The function relies on a node model to be available. Otherwise the actually referenced type is \n\t * used as the preferred type.\n\t * \n\t * @param owner the referrer to the JVM concept.\n\t * @param reference a reference to a {@link JvmType} or {@link JvmMember} that is declared in a type.\n\t * @return the referenced type or one of its containers.\n\t */\n\tprotected Pair<JvmDeclaredType, String> findPreferredType(EObject owner, EReference reference) {\n\t\tJvmIdentifiableElement referencedThing = (JvmIdentifiableElement) owner.eGet(reference);\n\t\tJvmDeclaredType referencedType = null;\n\t\tif (referencedThing instanceof JvmDeclaredType) {\n\t\t\treferencedType = (JvmDeclaredType) referencedThing;\n\t\t} else if (referencedThing instanceof JvmMember) {\n\t\t\treferencedType = ((JvmMember) referencedThing).getDeclaringType();\n\t\t} \n\t\tif (referencedType != null) {\n\t\t\tList<INode> nodes = NodeModelUtils.findNodesForFeature(owner, reference);\n\t\t\tif (nodes.size() == 1) {\n\t\t\t\tString text = NodeModelUtils.getTokenText(nodes.get(0));\n\t\t\t\tint dollar = text.lastIndexOf('$');\n\t\t\t\tString preferredTypeText = text; \n\t\t\t\tif (dollar >= 0) {\n\t\t\t\t\tJvmDeclaredType declaredType = referencedType;\n\t\t\t\t\twhile(declaredType.getDeclaringType() != null && dollar >= 0) {\n\t\t\t\t\t\tdeclaredType = declaredType.getDeclaringType();\n\t\t\t\t\t\tpreferredTypeText = text.substring(0, dollar);\n\t\t\t\t\t\tdollar = text.lastIndexOf('$', dollar-1);\n\t\t\t\t\t}\n\t\t\t\t\treturn Tuples.create(declaredType, preferredTypeText);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Tuples.create(referencedType, null);\n\t}","commit_id":"fcfe2cb59828e65ea1bf4738cc4952ed8b040c4b","url":"https://github.com/eclipse/xtext"},{"original_method":"public void update(\n\t\t\tlong oldPrimaryKeyValue, Object[] oldColumnValues,\n\t\t\tObject[] oldExtraColumnValues, long newPrimaryKeyValue,\n\t\t\tObject[] newColumnValues, Object[] newExtraColumnValues)\n\t\tthrows Exception {\n\n\t\tlong threadId = 0;\n\n\t\tfor (int i = 0; i < columns.length; i++) {\n\t\t\tif (columns[i][0].equals(\"threadId\")) {\n\t\t\t\tthreadId = (Long)newColumnValues[i];\n\t\t\t}\n\t\t}\n\n\t\tif ((threadId == 0) && (extraColumns != null)) {\n\t\t\tfor (int i = 0; i < extraColumns.length; i++) {\n\t\t\t\tif (extraColumns[i][0].equals(\"threadId\")) {\n\t\t\t\t\tthreadId = (Long)newExtraColumnValues[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdeleteDuplicateData(\"MBMessage\", \"threadId\", threadId);\n\t\tdeleteDuplicateData(\"MBMessageFlag\", \"threadId\", threadId);\n\t\tdeleteDuplicateData(\"MBThread\", \"threadId\", threadId);\n\t}","id":84285,"modified_method":"public void update(\n\t\t\tlong oldPrimaryKeyValue, Object[] oldColumnValues,\n\t\t\tObject[] oldExtraColumnValues, long newPrimaryKeyValue,\n\t\t\tObject[] newColumnValues, Object[] newExtraColumnValues)\n\t\tthrows Exception {\n\n\t\tlong threadId = 0;\n\n\t\tfor (int i = 0; i < columns.length; i++) {\n\t\t\tif (columns[i][0].equals(\"threadId\")) {\n\t\t\t\tthreadId = (Long)newColumnValues[i];\n\t\t\t}\n\t\t}\n\n\t\tif ((threadId == 0) && (extraColumns != null)) {\n\t\t\tfor (int i = 0; i < extraColumns.length; i++) {\n\t\t\t\tif (extraColumns[i][0].equals(\"threadId\")) {\n\t\t\t\t\tthreadId = (Long)newExtraColumnValues[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isDuplicateThread(threadId)) {\n\t\t\tdeleteDuplicateData(\"MBMessage\", \"threadId\", threadId);\n\t\t\tdeleteDuplicateData(\"MBMessageFlag\", \"threadId\", threadId);\n\t\t\tdeleteDuplicateData(\"MBThread\", \"threadId\", threadId);\n\t\t}\n\t}","commit_id":"afa74ba3570cf19ec298f609179ce1a114e246ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      runConfiguration,\n      FRAMEWORK_NAME,\n      myExecutor,\n      false\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_IGNORED_TEST, true);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.SCROLL_TO_SOURCE, true);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.SELECT_FIRST_DEFECT, true);\n\n    KarmaConsoleView consoleView = new KarmaConsoleView(testConsoleProperties,\n                                                        myEnvironment,\n                                                        SMTestRunnerConnectionUtil.getSplitterPropertyName(FRAMEWORK_NAME),\n                                                        myKarmaServer,\n                                                        this);\n    Disposer.register(myProject, consoleView);\n    SMTestRunnerConnectionUtil.initConsoleView(consoleView,\n                                               FRAMEWORK_NAME,\n                                               new KarmaTestLocationProvider(myProject),\n                                               true,\n                                               new KarmaTestProxyFilterProvider(myProject, myKarmaServer));\n    return consoleView;\n  }","id":84286,"modified_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration)myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new KarmaConsoleProperties(runConfiguration, myExecutor);\n    String propertyName = SMTestRunnerConnectionUtil.getSplitterPropertyName(FRAMEWORK_NAME);\n    KarmaTestProxyFilterProvider filterProvider = new KarmaTestProxyFilterProvider(myProject, myKarmaServer);\n    KarmaConsoleView consoleView = new KarmaConsoleView(testConsoleProperties, myEnvironment, propertyName, myKarmaServer, this);\n    Disposer.register(myProject, consoleView);\n    SMTestRunnerConnectionUtil.initConsoleView(consoleView, FRAMEWORK_NAME, null, true, filterProvider);\n    return consoleView;\n  }","commit_id":"11dfe35bd61d56852bfad5593f78c900de9505ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private PsiElement findJasmineElement(@NotNull List<String> suiteNames, @Nullable String testName) {\n    String suiteKey = JsTestFileByTestNameIndex.createJasmineKey(suiteNames);\n    GlobalSearchScope scope = GlobalSearchScope.projectScope(myProject);\n    List<VirtualFile> jsTestVirtualFiles = JsTestFileByTestNameIndex.findJsTestFilesByNameInScope(suiteKey, scope);\n    for (VirtualFile file : jsTestVirtualFiles) {\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(file);\n      if (psiFile instanceof JSFile) {\n        JSFile jsFile = (JSFile) psiFile;\n        JasmineFileStructureBuilder builder = JasmineFileStructureBuilder.getInstance();\n        JasmineFileStructure jasmineFileStructure = builder.fetchCachedTestFileStructure(jsFile);\n        PsiElement element = jasmineFileStructure.findPsiElement(suiteNames, testName);\n        if (element != null && element.isValid()) {\n          return element;\n        }\n      }\n    }\n    return null;\n  }","id":84287,"modified_method":"@Nullable\n  private static PsiElement findJasmineElement(Project project, @NotNull List<String> suiteNames, @Nullable String testName) {\n    String key = JsTestFileByTestNameIndex.createJasmineKey(suiteNames);\n    GlobalSearchScope scope = GlobalSearchScope.projectScope(project);\n    List<VirtualFile> jsTestVirtualFiles = JsTestFileByTestNameIndex.findJsTestFilesByNameInScope(key, scope);\n\n    JasmineFileStructureBuilder builder = JasmineFileStructureBuilder.getInstance();\n    for (VirtualFile file : jsTestVirtualFiles) {\n      PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      if (psiFile instanceof JSFile) {\n        JasmineFileStructure jasmineFileStructure = builder.fetchCachedTestFileStructure((JSFile)psiFile);\n        PsiElement element = jasmineFileStructure.findPsiElement(suiteNames, testName);\n        if (element != null && element.isValid()) {\n          return element;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"11dfe35bd61d56852bfad5593f78c900de9505ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private PsiElement findQUnitElement(@NotNull String moduleName, @Nullable String testName) {\n    String qunitKey = JsTestFileByTestNameIndex.createQUnitKey(moduleName, testName);\n    GlobalSearchScope scope = GlobalSearchScope.projectScope(myProject);\n    List<VirtualFile> jsTestVirtualFiles = JsTestFileByTestNameIndex.findJsTestFilesByNameInScope(qunitKey, scope);\n    for (VirtualFile file : jsTestVirtualFiles) {\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(file);\n      if (psiFile instanceof JSFile) {\n        JSFile jsFile = (JSFile) psiFile;\n        QUnitFileStructureBuilder builder = QUnitFileStructureBuilder.getInstance();\n        QUnitFileStructure qunitFileStructure = builder.fetchCachedTestFileStructure(jsFile);\n        PsiElement element = qunitFileStructure.findPsiElement(moduleName, testName);\n        if (element != null && element.isValid()) {\n          return element;\n        }\n      }\n    }\n    return null;\n  }","id":84288,"modified_method":"@Nullable\n  private static PsiElement findQUnitElement(Project project, @NotNull String moduleName, @Nullable String testName) {\n    String key = JsTestFileByTestNameIndex.createQUnitKey(moduleName, testName);\n    GlobalSearchScope scope = GlobalSearchScope.projectScope(project);\n    List<VirtualFile> jsTestVirtualFiles = JsTestFileByTestNameIndex.findJsTestFilesByNameInScope(key, scope);\n\n    QUnitFileStructureBuilder builder = QUnitFileStructureBuilder.getInstance();\n    for (VirtualFile file : jsTestVirtualFiles) {\n      PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      if (psiFile instanceof JSFile) {\n        QUnitFileStructure qunitFileStructure = builder.fetchCachedTestFileStructure((JSFile)psiFile);\n        PsiElement element = qunitFileStructure.findPsiElement(moduleName, testName);\n        if (element != null && element.isValid()) {\n          return element;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"11dfe35bd61d56852bfad5593f78c900de9505ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private Location<PsiFile> getConfigLocation(@NotNull String locationData) {    VirtualFile\n    virtualFile = VfsUtil.findFileByIoFile(new File(locationData), false);\n    if (virtualFile != null && virtualFile.isValid()) {\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(virtualFile);\n      if (psiFile != null && psiFile.isValid()) {\n        return PsiLocation.fromPsiElement(psiFile);\n      }\n    }\n    return null;\n  }","id":84289,"modified_method":"@Nullable\n  private static Location<PsiFile> getConfigLocation(Project project, @NotNull String locationData) {\n    VirtualFile virtualFile = VfsUtil.findFileByIoFile(new File(locationData), false);\n    if (virtualFile != null && virtualFile.isValid()) {\n      PsiFile psiFile = PsiManager.getInstance(project).findFile(virtualFile);\n      if (psiFile != null && psiFile.isValid()) {\n        return PsiLocation.fromPsiElement(psiFile);\n      }\n    }\n    return null;\n  }","commit_id":"11dfe35bd61d56852bfad5593f78c900de9505ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public List<Location> getLocation(@NotNull String protocolId, @NotNull String locationData, Project project) {\n    final Location location;\n    if (PROTOCOL_ID__CONFIG_FILE.equals(protocolId)) {\n      location = getConfigLocation(locationData);\n    }\n    else if (PROTOCOL_ID__TEST_SUITE.equals(protocolId)) {\n      location = getTestLocation(locationData, true);\n    }\n    else if (PROTOCOL_ID__TEST.equals(protocolId)) {\n      location = getTestLocation(locationData, false);\n    }\n    else {\n      location = null;\n    }\n    if (location != null) {\n      return Collections.singletonList(location);\n    }\n    return Collections.emptyList();\n  }","id":84290,"modified_method":"@NotNull\n  @Override\n  public List<Location> getLocation(@NotNull String protocol, @NotNull String path, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n    final Location location;\n    if (PROTOCOL_ID__CONFIG_FILE.equals(protocol)) {\n      location = getConfigLocation(project, path);\n    }\n    else if (PROTOCOL_ID__TEST_SUITE.equals(protocol)) {\n      location = getTestLocation(project, path, true);\n    }\n    else if (PROTOCOL_ID__TEST.equals(protocol)) {\n      location = getTestLocation(project, path, false);\n    }\n    else {\n      location = null;\n    }\n    if (location != null) {\n      return Collections.singletonList(location);\n    }\n    return Collections.emptyList();\n  }","commit_id":"11dfe35bd61d56852bfad5593f78c900de9505ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private Location getTestLocation(@NotNull String locationData, boolean isSuite) {\n    List<String> path = EscapeUtils.split(locationData, '.');\n    if (path.isEmpty()) {\n      return null;\n    }\n    final List<String> suiteNames;\n    final String testName;\n    if (isSuite) {\n      suiteNames = path;\n      testName = null;\n    }\n    else {\n      suiteNames = path.subList(0, path.size() - 1);\n      testName = path.get(path.size() - 1);\n    }\n    PsiElement psiElement = findJasmineElement(suiteNames, testName);\n    if (psiElement == null) {\n      String moduleName = null;\n      if (suiteNames.size() == 0) {\n        moduleName = DefaultQUnitModuleStructure.NAME;\n      }\n      else if (suiteNames.size() == 1) {\n        moduleName = suiteNames.get(0);\n      }\n      if (moduleName != null) {\n        psiElement = findQUnitElement(moduleName, testName);\n      }\n    }\n    if (psiElement != null) {\n      return PsiLocation.fromPsiElement(psiElement);\n    }\n    return null;\n  }","id":84291,"modified_method":"@Nullable\n  private static Location getTestLocation(Project project, @NotNull String locationData, boolean isSuite) {\n    List<String> path = EscapeUtils.split(locationData, '.');\n    if (path.isEmpty()) {\n      return null;\n    }\n    final List<String> suiteNames;\n    final String testName;\n    if (isSuite) {\n      suiteNames = path;\n      testName = null;\n    }\n    else {\n      suiteNames = path.subList(0, path.size() - 1);\n      testName = path.get(path.size() - 1);\n    }\n    PsiElement psiElement = findJasmineElement(project, suiteNames, testName);\n    if (psiElement == null) {\n      String moduleName = null;\n      if (suiteNames.size() == 0) {\n        moduleName = DefaultQUnitModuleStructure.NAME;\n      }\n      else if (suiteNames.size() == 1) {\n        moduleName = suiteNames.get(0);\n      }\n      if (moduleName != null) {\n        psiElement = findQUnitElement(project, moduleName, testName);\n      }\n    }\n    if (psiElement != null) {\n      return PsiLocation.fromPsiElement(psiElement);\n    }\n    return null;\n  }","commit_id":"11dfe35bd61d56852bfad5593f78c900de9505ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      runConfiguration,\n      FRAMEWORK_NAME,\n      myExecutor,\n      false\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_IGNORED_TEST, true);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.SCROLL_TO_SOURCE, true);\n\n    KarmaConsoleView consoleView = new KarmaConsoleView(testConsoleProperties,\n                                                        myEnvironment,\n                                                        SMTestRunnerConnectionUtil.getSplitterPropertyName(FRAMEWORK_NAME),\n                                                        myKarmaServer,\n                                                        this);\n    Disposer.register(myProject, consoleView);\n    SMTestRunnerConnectionUtil.initConsoleView(consoleView,\n                                               FRAMEWORK_NAME,\n                                               new KarmaTestLocationProvider(myProject),\n                                               true,\n                                               new KarmaTestProxyFilterProvider(myProject, myKarmaServer));\n    return consoleView;\n  }","id":84292,"modified_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      runConfiguration,\n      FRAMEWORK_NAME,\n      myExecutor,\n      false\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_IGNORED_TEST, true);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.SCROLL_TO_SOURCE, true);\n    String splitterPropertyName = SMTestRunnerConnectionUtil.getSplitterPropertyName(FRAMEWORK_NAME);\n    PropertiesComponent.getInstance().setValue(splitterPropertyName, String.valueOf(0.2f));\n\n    KarmaConsoleView consoleView = new KarmaConsoleView(testConsoleProperties,\n                                                        myEnvironment,\n                                                        splitterPropertyName,\n                                                        myKarmaServer,\n                                                        this);\n    Disposer.register(myProject, consoleView);\n    SMTestRunnerConnectionUtil.initConsoleView(consoleView,\n                                               FRAMEWORK_NAME,\n                                               new KarmaTestLocationProvider(myProject),\n                                               true,\n                                               new KarmaTestProxyFilterProvider(myProject, myKarmaServer));\n    return consoleView;\n  }","commit_id":"15f54bc5bf03cf30ef82054cd2cc941d8b5f9954","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void setValueAt(Object value, int row, int column) {\n    treeTableModel.setValueAt(value, nodeForRow(row), column);\n  }","id":84293,"modified_method":"public void setValueAt(Object value, int row, int column) {\n    final Object o = nodeForRow(row);\n    if (o != null) treeTableModel.setValueAt(value, o, column);\n  }","commit_id":"cb8b58c2fa136170f63ab96dd8ec29a565cbe81b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getValueAt(int row, int column) {\n    return treeTableModel.getValueAt(nodeForRow(row), column);\n  }","id":84294,"modified_method":"public Object getValueAt(int row, int column) {\n    final Object o = nodeForRow(row);\n    return o == null? null : treeTableModel.getValueAt(o, column);\n  }","commit_id":"cb8b58c2fa136170f63ab96dd8ec29a565cbe81b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isCellEditable(int row, int column) {\n    return treeTableModel.isCellEditable(nodeForRow(row), column);\n  }","id":84295,"modified_method":"public boolean isCellEditable(int row, int column) {\n    final Object o = nodeForRow(row);\n    return o == null? false : treeTableModel.isCellEditable(o, column);\n  }","commit_id":"cb8b58c2fa136170f63ab96dd8ec29a565cbe81b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(final AnActionEvent event) {\n    if(!DebuggerAction.isFirstStart(event)) return;\n\n    final DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(event.getDataContext());\n    final DebuggerTreeNodeImpl[] selectedNodes = DebuggerAction.getSelectedNodes(event.getDataContext());\n\n    debuggerContext.getDebugProcess().getManagerThread().schedule(new DebuggerContextCommandImpl(debuggerContext) {\n      public void threadAction() {\n        myChildren = calcChildren(selectedNodes);\n        DebuggerAction.enableAction(event, myChildren.length > 0);\n      }\n    });\n  }","id":84296,"modified_method":"public void update(final AnActionEvent event) {\n    if(!DebuggerAction.isFirstStart(event)) {\n      return;\n    }\n\n    final DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(event.getDataContext());\n    final DebuggerTreeNodeImpl[] selectedNodes = DebuggerAction.getSelectedNodes(event.getDataContext());\n\n    final DebugProcessImpl process = debuggerContext.getDebugProcess();\n    if (process == null) {\n      event.getPresentation().setEnabled(false);\n      return;\n    }\n    \n    process.getManagerThread().schedule(new DebuggerContextCommandImpl(debuggerContext) {\n      public void threadAction() {\n        myChildren = calcChildren(selectedNodes);\n        DebuggerAction.enableAction(event, myChildren.length > 0);\n      }\n    });\n  }","commit_id":"9fc0fe0808a27b318ce81d429b9cb8ac12ee9471","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildNode(final DebuggerTreeNodeImpl node) {\n    if (node == null || node.getDescriptor() == null) {\n      return;\n    }\n    BuildNodeCommand builder = getBuildNodeCommand(node);\n    builder.getNode().add(myDescriptorManager.createMessageNode(MessageDescriptor.EVALUATING));\n    getDebuggerContext().getDebugProcess().getManagerThread().invokeLater(builder);\n  }","id":84297,"modified_method":"private void buildNode(final DebuggerTreeNodeImpl node) {\n    if (node == null || node.getDescriptor() == null) {\n      return;\n    }\n    final DebugProcessImpl debugProcess = getDebuggerContext().getDebugProcess();\n    if (debugProcess != null) {\n      BuildNodeCommand command = getBuildNodeCommand(node);\n      command.getNode().add(myDescriptorManager.createMessageNode(MessageDescriptor.EVALUATING));\n      debugProcess.getManagerThread().invokeLater(command);\n    }\n  }","commit_id":"7bac9398f3bf7243ab32648ccfd6058ecbb7f78a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n    final DebuggerTreeNodeImpl[] selectedNodes = DebuggerAction.getSelectedNodes(e.getDataContext());\n\n    if(debuggerContext != null && debuggerContext.getDebugProcess() != null) {\n      debuggerContext.getDebugProcess().getManagerThread().schedule(new DebuggerContextCommandImpl(debuggerContext) {\n          public void threadAction() {\n            for (int i = 0; i < selectedNodes.length; i++) {\n              DebuggerTreeNodeImpl selectedNode = selectedNodes[i];\n              NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n              if (descriptor instanceof ValueDescriptorImpl) {\n                ((ValueDescriptorImpl) descriptor).setRenderer(null);\n                selectedNode.calcRepresentation();\n              }\n            }\n          }\n        });\n    }\n  }","id":84298,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n\n    if(debuggerContext != null) {\n      final DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n      if(debugProcess != null) {\n        final DebuggerTreeNodeImpl[] selectedNodes = DebuggerAction.getSelectedNodes(e.getDataContext());\n        if (selectedNodes != null) {\n          debugProcess.getManagerThread().schedule(new DebuggerContextCommandImpl(debuggerContext) {\n              public void threadAction() {\n                for (DebuggerTreeNodeImpl selectedNode : selectedNodes) {\n                  final NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n                  if (descriptor instanceof ValueDescriptorImpl) {\n                    ((ValueDescriptorImpl)descriptor).setRenderer(null);\n                    selectedNode.calcRepresentation();\n                  }\n                }\n              }\n            });\n        }\n      }\n    }\n  }","commit_id":"bc4c101c7370b9baa0bd897b277d5c01d4aab119","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEvaluationPossible() {\n    return getDebugProcess().getSuspendManager().getPausedContext() != null;\n  }","id":84299,"modified_method":"public boolean isEvaluationPossible() {\n    final DebugProcessImpl debugProcess = getDebugProcess();\n    return debugProcess != null && debugProcess.getSuspendManager().getPausedContext() != null;\n  }","commit_id":"bc4c101c7370b9baa0bd897b277d5c01d4aab119","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void rebuild(final boolean updateOnly) {\n    if (!updateOnly) {\n      myThreadsCombo.removeAllItems();\n      synchronized (myFramesList) {\n        myFramesList.clear();\n      }\n    }\n\n    getContext().getDebugProcess().getManagerThread().invokeLater(new RefreshFramePanelCommand(updateOnly && myThreadsCombo.getItemCount() != 0));\n  }","id":84300,"modified_method":"protected void rebuild(final boolean updateOnly) {\n    if (!updateOnly) {\n      myThreadsCombo.removeAllItems();\n      synchronized (myFramesList) {\n        myFramesList.clear();\n      }\n    }\n\n    final DebugProcessImpl process = getContext().getDebugProcess();\n    if (process != null) {\n      process.getManagerThread().invokeLater(new RefreshFramePanelCommand(updateOnly && myThreadsCombo.getItemCount() != 0));\n    }\n  }","commit_id":"a452ebefad095c9a9862c9829bc633bcf3f7f08a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public SourcePosition getSourcePosition(final Project project, final DebuggerContextImpl context) {\n    if (context.getFrameProxy() == null) {\n      return null;\n    }\n    final ReferenceType type = myField.declaringType();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    final String fieldName = myField.name();\n    if (fieldName.startsWith(OUTER_LOCAL_VAR_FIELD_PREFIX)) {\n      // this field actually mirrors a local variable in the outer class\n      String varName = fieldName.substring(fieldName.lastIndexOf('$') + 1);\n      PsiElement element = PositionUtil.getContextElement(context);\n      if (element == null) {\n        return null;\n      }\n      PsiClass aClass = PsiTreeUtil.getParentOfType(element, PsiClass.class, false);\n      if (aClass == null) {\n        return null;\n      }\n      aClass = (PsiClass) aClass.getNavigationElement();\n      PsiVariable psiVariable = facade.getResolveHelper().resolveReferencedVariable(varName, aClass);\n      if (psiVariable == null) {\n        return null;\n      }\n      return SourcePosition.createFromOffset(psiVariable.getContainingFile(), psiVariable.getTextOffset());\n    }\n    else {\n      final DebuggerSession session = context.getDebuggerSession();\n      final GlobalSearchScope scope = session != null? session.getSearchScope() : GlobalSearchScope.allScope(myProject);\n      PsiClass aClass = facade.findClass(type.name().replace('$', '.'), scope);\n      if (aClass == null) {\n        // trying to search, assuming declaring class is an anonymous class\n        try {\n          final List<Location> locations = type.allLineLocations();\n          if (!locations.isEmpty()) {\n            // important: use the last location to be sure the position will be within the anonymous class\n            final Location lastLocation = locations.get(locations.size() - 1);\n            final SourcePosition position = context.getDebugProcess().getPositionManager().getSourcePosition(lastLocation);\n            if (position != null) {\n              aClass = JVMNameUtil.getClassAt(position);\n            }\n          }\n        }\n        catch (AbsentInformationException ignored) {\n        }\n        catch (ClassNotPreparedException ignored) {\n        }\n      }\n\n      if (aClass != null) {\n        aClass = (PsiClass) aClass.getNavigationElement();\n        for (PsiField field : aClass.getFields()) {\n          if (fieldName.equals(field.getName())) {\n            return SourcePosition.createFromOffset(field.getContainingFile(), field.getTextOffset());\n          }\n        }\n      }\n      return null;\n    }\n  }","id":84301,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public SourcePosition getSourcePosition(final Project project, final DebuggerContextImpl context) {\n    if (context.getFrameProxy() == null) {\n      return null;\n    }\n    final ReferenceType type = myField.declaringType();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    final String fieldName = myField.name();\n    if (fieldName.startsWith(OUTER_LOCAL_VAR_FIELD_PREFIX)) {\n      // this field actually mirrors a local variable in the outer class\n      String varName = fieldName.substring(fieldName.lastIndexOf('$') + 1);\n      PsiElement element = PositionUtil.getContextElement(context);\n      if (element == null) {\n        return null;\n      }\n      PsiClass aClass = PsiTreeUtil.getParentOfType(element, PsiClass.class, false);\n      if (aClass == null) {\n        return null;\n      }\n      aClass = (PsiClass) aClass.getNavigationElement();\n      PsiVariable psiVariable = facade.getResolveHelper().resolveReferencedVariable(varName, aClass);\n      if (psiVariable == null) {\n        return null;\n      }\n      return SourcePosition.createFromOffset(psiVariable.getContainingFile(), psiVariable.getTextOffset());\n    }\n    else {\n      final DebuggerSession session = context.getDebuggerSession();\n      final GlobalSearchScope scope = session != null? session.getSearchScope() : GlobalSearchScope.allScope(myProject);\n      PsiClass aClass = facade.findClass(type.name().replace('$', '.'), scope);\n      if (aClass == null) {\n        // trying to search, assuming declaring class is an anonymous class\n        final DebugProcessImpl debugProcess = context.getDebugProcess();\n        if (debugProcess != null) {\n          final Computable<PsiClass> classComputable = new Computable<PsiClass>() {\n            public PsiClass compute() {\n              try {\n                final List<Location> locations = type.allLineLocations();\n                if (!locations.isEmpty()) {\n                  // important: use the last location to be sure the position will be within the anonymous class\n                  final Location lastLocation = locations.get(locations.size() - 1);\n                  final SourcePosition position = debugProcess.getPositionManager().getSourcePosition(lastLocation);\n                  if (position != null) {\n                    return JVMNameUtil.getClassAt(position);\n                  }\n                }\n              }\n              catch (AbsentInformationException ignored) {\n              }\n              catch (ClassNotPreparedException ignored) {\n              }\n              return null;\n            }\n          };\n          if (!DebuggerManagerThreadImpl.isManagerThread()) {\n            final Ref<PsiClass> classRef = new Ref<PsiClass>(null);\n            debugProcess.getManagerThread().invokeAndWait(new DebuggerContextCommandImpl(context) {\n              public Priority getPriority() {\n                return Priority.HIGH;\n              }\n              public void threadAction() {\n                classRef.set(classComputable.compute());\n              }\n            });\n            aClass = classRef.get();\n          }\n          else {\n            aClass = classComputable.compute();\n          }\n        }\n      }\n\n      if (aClass != null) {\n        aClass = (PsiClass) aClass.getNavigationElement();\n        for (PsiField field : aClass.getFields()) {\n          if (fieldName.equals(field.getName())) {\n            return SourcePosition.createFromOffset(field.getContainingFile(), field.getTextOffset());\n          }\n        }\n      }\n      return null;\n    }\n  }","commit_id":"544a5807563b9844d6802dc10b94aa985f03d2d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void computeChildren(@NotNull final XCompositeNode node) {\n    scheduleCommand(myEvaluationContext, node, new SuspendContextCommandImpl(myEvaluationContext.getSuspendContext()) {\n      @Override\n      public Priority getPriority() {\n        return Priority.NORMAL;\n      }\n\n      @Override\n      public void contextAction() throws Exception {\n        final XValueChildrenList children = new XValueChildrenList();\n        final NodeRenderer renderer = myValueDescriptor.getRenderer(myEvaluationContext.getDebugProcess());\n        final Ref<Integer> remainingNum = new Ref<Integer>(0);\n        renderer.buildChildren(myValueDescriptor.getValue(), new ChildrenBuilder() {\n          @Override\n          public NodeDescriptorFactory getDescriptorManager() {\n            return myNodeManager;\n          }\n\n          @Override\n          public NodeManager getNodeManager() {\n            return myNodeManager;\n          }\n\n          @Override\n          public ValueDescriptor getParentDescriptor() {\n            return myValueDescriptor;\n          }\n\n          @Override\n          public void setRemaining(int remaining) {\n            remainingNum.set(remaining);\n          }\n\n          @Override\n          public void initChildrenArrayRenderer(ArrayRenderer renderer) {\n            renderer.START_INDEX = currentStart;\n            renderer.END_INDEX = currentStart + XCompositeNode.MAX_CHILDREN_TO_SHOW - 1;\n            currentStart += XCompositeNode.MAX_CHILDREN_TO_SHOW;\n          }\n\n          @Override\n          public void setChildren(List<DebuggerTreeNode> nodes) {\n            for (DebuggerTreeNode node : nodes) {\n              final NodeDescriptor descriptor = node.getDescriptor();\n              if (descriptor instanceof ValueDescriptorImpl) {\n                // Value is calculated already in NodeManagerImpl\n                children.add(create(JavaValue.this, (ValueDescriptorImpl)descriptor, myEvaluationContext, myNodeManager, false));\n              }\n              else if (descriptor instanceof MessageDescriptor) {\n                children.add(new JavaStackFrame.DummyMessageValueNode(descriptor.getLabel(), null));\n              }\n            }\n          }\n        }, myEvaluationContext);\n        node.addChildren(children, true);\n        if (remainingNum.get() > 0) {\n          node.tooManyChildren(remainingNum.get());\n        }\n      }\n    });\n  }","id":84302,"modified_method":"@Override\n  public void computeChildren(@NotNull final XCompositeNode node) {\n    scheduleCommand(myEvaluationContext, node, new SuspendContextCommandImpl(myEvaluationContext.getSuspendContext()) {\n      @Override\n      public Priority getPriority() {\n        return Priority.NORMAL;\n      }\n\n      @Override\n      public void contextAction() throws Exception {\n        final XValueChildrenList children = new XValueChildrenList();\n        final NodeRenderer renderer = myValueDescriptor.getRenderer(myEvaluationContext.getDebugProcess());\n        final Ref<Integer> remainingNum = new Ref<Integer>(0);\n        renderer.buildChildren(myValueDescriptor.getValue(), new ChildrenBuilder() {\n          @Override\n          public NodeDescriptorFactory getDescriptorManager() {\n            return myNodeManager;\n          }\n\n          @Override\n          public NodeManager getNodeManager() {\n            return myNodeManager;\n          }\n\n          @Override\n          public ValueDescriptor getParentDescriptor() {\n            return myValueDescriptor;\n          }\n\n          @Override\n          public void setRemaining(int remaining) {\n            remainingNum.set(remaining);\n          }\n\n          @Override\n          public void initChildrenArrayRenderer(ArrayRenderer renderer) {\n            renderer.START_INDEX = myCurrentChildrenStart;\n            renderer.END_INDEX = myCurrentChildrenStart + XCompositeNode.MAX_CHILDREN_TO_SHOW - 1;\n            myCurrentChildrenStart += XCompositeNode.MAX_CHILDREN_TO_SHOW;\n          }\n\n          @Override\n          public void setChildren(List<DebuggerTreeNode> nodes) {\n            for (DebuggerTreeNode node : nodes) {\n              final NodeDescriptor descriptor = node.getDescriptor();\n              if (descriptor instanceof ValueDescriptorImpl) {\n                // Value is calculated already in NodeManagerImpl\n                children.add(create(JavaValue.this, (ValueDescriptorImpl)descriptor, myEvaluationContext, myNodeManager, false));\n              }\n              else if (descriptor instanceof MessageDescriptor) {\n                children.add(new JavaStackFrame.DummyMessageValueNode(descriptor.getLabel(), null));\n              }\n            }\n          }\n        }, myEvaluationContext);\n        node.addChildren(children, true);\n        if (remainingNum.get() > 0) {\n          node.tooManyChildren(remainingNum.get());\n        }\n      }\n    });\n  }","commit_id":"70e786e0965d72fb379dd75eb6c8c470a1d9f2e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public String getEvaluationExpression() {\n    if (evaluationExpression == null) {\n      // TODO: change API to allow to calculate it asynchronously\n      myEvaluationContext.getManagerThread().invokeAndWait(new DebuggerCommandImpl() {\n        @Override\n        public Priority getPriority() {\n          return Priority.HIGH;\n        }\n\n        @Override\n        protected void action() throws Exception {\n          evaluationExpression = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n            @Override\n            public String compute() {\n              try {\n                PsiExpression psiExpression = getDescriptor().getTreeEvaluation(JavaValue.this, getDebuggerContext());\n                if (psiExpression != null) {\n                  return new TextWithImportsImpl(psiExpression).getText();\n                }\n              }\n              catch (EvaluateException e) {\n                LOG.info(e);\n              }\n              return null;\n            }\n          });\n        }\n      });\n    }\n    return evaluationExpression;\n  }","id":84303,"modified_method":"@Nullable\n  @Override\n  public String getEvaluationExpression() {\n    if (evaluationExpression == null) {\n      // TODO: change API to allow to calculate it asynchronously\n      myEvaluationContext.getManagerThread().invokeAndWait(new SuspendContextCommandImpl(myEvaluationContext.getSuspendContext()) {\n        @Override\n        public Priority getPriority() {\n          return Priority.HIGH;\n        }\n\n        @Override\n        public void contextAction() throws Exception {\n          evaluationExpression = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n            @Override\n            public String compute() {\n              try {\n                PsiExpression psiExpression = getDescriptor().getTreeEvaluation(JavaValue.this, getDebuggerContext());\n                if (psiExpression != null) {\n                  return new TextWithImportsImpl(psiExpression).getText();\n                }\n              }\n              catch (EvaluateException e) {\n                LOG.info(e);\n              }\n              return null;\n            }\n          });\n        }\n      });\n    }\n    return evaluationExpression;\n  }","commit_id":"70e786e0965d72fb379dd75eb6c8c470a1d9f2e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setSelected(final AnActionEvent e, final boolean state) {\n      if (!state) return;\n\n      final DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n      final List<JavaValue> values = getSelectedValues(e);\n\n      LOG.assertTrue(debuggerContext != null && !values.isEmpty());\n\n      debuggerContext.getDebugProcess().getManagerThread().schedule(new DebuggerContextCommandImpl(debuggerContext) {\n          public void threadAction() {\n            for (JavaValue value : values) {\n              value.getDescriptor().setRenderer(myNodeRenderer);\n            }\n            DebuggerAction.refreshViews(e);\n          }\n        }\n      );\n    }","id":84304,"modified_method":"public void setSelected(final AnActionEvent e, final boolean state) {\n      if (!state) return;\n\n      final DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n      final List<JavaValue> values = getSelectedValues(e);\n      final List<XValueNodeImpl> selectedNodes = XDebuggerTreeActionBase.getSelectedNodes(e.getDataContext());\n\n      LOG.assertTrue(debuggerContext != null && !values.isEmpty());\n\n      DebugProcessImpl process = debuggerContext.getDebugProcess();\n      if (process == null) {\n        return;\n      }\n\n      process.getManagerThread().schedule(new DebuggerContextCommandImpl(debuggerContext) {\n          public void threadAction() {\n            for (final XValueNodeImpl node : selectedNodes) {\n              final XValue container = node.getValueContainer();\n              if (container instanceof JavaValue) {\n                ((JavaValue)container).setRenderer(myNodeRenderer, node);\n              }\n            }\n          }\n        }\n      );\n    }","commit_id":"70e786e0965d72fb379dd75eb6c8c470a1d9f2e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void layoutPanel() {\n    final GridBagLayout layout = new GridBagLayout();\n    myMainPanel = new JPanel(layout);\n    final JLabel interpreterLabel = new JLabel(PyBundle.message(\"active.sdk.dialog.project.interpreter\"));\n    final JLabel emptyLabel = new JLabel(\"  \");\n    mySdkCombo = new ComboBox() {\n      @Override\n      public void setSelectedItem(Object item) {\n        if (SHOW_ALL.equals(item)) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              PythonSdkDetailsDialog options = myModule == null ? new PythonSdkDetailsDialog(myProject, myDetailsCallback) :\n                                               new PythonSdkDetailsDialog(myModule, myDetailsCallback);\n              options.show();\n            }\n          });\n          return;\n        }\n        if (!PySdkListCellRenderer.SEPARATOR.equals(item))\n          super.setSelectedItem(item);\n      }\n      @Override\n      public void paint(Graphics g) {\n        try {\n          putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.FALSE);\n          super.paint(g);\n        } finally {\n          putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.TRUE);\n        }\n      }\n    };\n    mySdkCombo.putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.TRUE);\n\n    final PackagesNotificationPanel notificationsArea = new PackagesNotificationPanel();\n    final JComponent notificationsComponent = notificationsArea.getComponent();\n    final Dimension preferredSize = mySdkCombo.getPreferredSize();\n    mySdkCombo.setPreferredSize(preferredSize);\n    notificationsArea.hide();\n    myDetailsButton = new FixedSizeButton();\n    myDetailsButton.setIcon(PythonIcons.Python.InterpreterGear);\n    //noinspection SuspiciousNameCombination\n    myDetailsButton.setPreferredSize(new Dimension(preferredSize.height, preferredSize.height));\n\n    myPackagesPanel = new PyInstalledPackagesPanel(myProject, notificationsArea);\n    final GridBagConstraints c = new GridBagConstraints();\n    c.fill = GridBagConstraints.HORIZONTAL;\n    c.insets = new Insets(2,2,2,2);\n\n    c.gridx = 0;\n    c.gridy = 0;\n    myMainPanel.add(interpreterLabel, c);\n\n    c.gridx = 1;\n    c.gridy = 0;\n    c.weightx = 0.1;\n    myMainPanel.add(mySdkCombo, c);\n\n    c.insets = new Insets(2,0,2,2);\n    c.gridx = 2;\n    c.gridy = 0;\n    c.weightx = 0.0;\n    myMainPanel.add(myDetailsButton, c);\n\n    c.insets = new Insets(2,2,0,2);\n    c.gridx = 0;\n    c.gridy = 1;\n    c.gridwidth = 3;\n    myMainPanel.add(emptyLabel, c);\n\n    c.gridx = 0;\n    c.gridy = 2;\n    c.weighty = 1.;\n    c.gridwidth = 3;\n    c.gridheight = GridBagConstraints.RELATIVE;\n    c.fill = GridBagConstraints.BOTH;\n    myMainPanel.add(myPackagesPanel, c);\n\n    c.gridheight = GridBagConstraints.REMAINDER;\n    c.gridx = 0;\n    c.gridy = 3;\n    c.gridwidth = 3;\n    c.weighty = 0.;\n    c.fill = GridBagConstraints.HORIZONTAL;\n    c.anchor = GridBagConstraints.SOUTH;\n\n    myMainPanel.add(notificationsComponent, c);\n  }","id":84305,"modified_method":"private void layoutPanel() {\n    final GridBagLayout layout = new GridBagLayout();\n    myMainPanel = new JPanel(layout);\n    final JLabel interpreterLabel = new JLabel(PyBundle.message(\"active.sdk.dialog.project.interpreter\"));\n    final JLabel emptyLabel = new JLabel(\"  \");\n    mySdkCombo = new ComboBox() {\n      @Override\n      public void setSelectedItem(Object item) {\n        if (SHOW_ALL.equals(item)) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              PythonSdkDetailsDialog moreDialog = myModule == null ? new PythonSdkDetailsDialog(myProject, myAddSdkCallback)\n                                                                   : new PythonSdkDetailsDialog(myModule, myAddSdkCallback);\n              moreDialog.show();\n            }\n          });\n          return;\n        }\n        if (!PySdkListCellRenderer.SEPARATOR.equals(item))\n          super.setSelectedItem(item);\n      }\n      @Override\n      public void paint(Graphics g) {\n        try {\n          putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.FALSE);\n          super.paint(g);\n        } finally {\n          putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.TRUE);\n        }\n      }\n    };\n    mySdkCombo.putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.TRUE);\n\n    final PackagesNotificationPanel notificationsArea = new PackagesNotificationPanel();\n    final JComponent notificationsComponent = notificationsArea.getComponent();\n    final Dimension preferredSize = mySdkCombo.getPreferredSize();\n    mySdkCombo.setPreferredSize(preferredSize);\n    notificationsArea.hide();\n    myDetailsButton = new FixedSizeButton();\n    myDetailsButton.setIcon(PythonIcons.Python.InterpreterGear);\n    //noinspection SuspiciousNameCombination\n    myDetailsButton.setPreferredSize(new Dimension(preferredSize.height, preferredSize.height));\n\n    myPackagesPanel = new PyInstalledPackagesPanel(myProject, notificationsArea);\n    final GridBagConstraints c = new GridBagConstraints();\n    c.fill = GridBagConstraints.HORIZONTAL;\n    c.insets = new Insets(2,2,2,2);\n\n    c.gridx = 0;\n    c.gridy = 0;\n    myMainPanel.add(interpreterLabel, c);\n\n    c.gridx = 1;\n    c.gridy = 0;\n    c.weightx = 0.1;\n    myMainPanel.add(mySdkCombo, c);\n\n    c.insets = new Insets(2,0,2,2);\n    c.gridx = 2;\n    c.gridy = 0;\n    c.weightx = 0.0;\n    myMainPanel.add(myDetailsButton, c);\n\n    c.insets = new Insets(2,2,0,2);\n    c.gridx = 0;\n    c.gridy = 1;\n    c.gridwidth = 3;\n    myMainPanel.add(emptyLabel, c);\n\n    c.gridx = 0;\n    c.gridy = 2;\n    c.weighty = 1.;\n    c.gridwidth = 3;\n    c.gridheight = GridBagConstraints.RELATIVE;\n    c.fill = GridBagConstraints.BOTH;\n    myMainPanel.add(myPackagesPanel, c);\n\n    c.gridheight = GridBagConstraints.REMAINDER;\n    c.gridx = 0;\n    c.gridy = 3;\n    c.gridwidth = 3;\n    c.weighty = 0.;\n    c.fill = GridBagConstraints.HORIZONTAL;\n    c.anchor = GridBagConstraints.SOUTH;\n\n    myMainPanel.add(notificationsComponent, c);\n  }","commit_id":"6fd859156748f48935c8a5d884828cdec9f7f78f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showDetails() {\n    final PythonSdkDetailsDialog moreDialog = myModule == null ? new PythonSdkDetailsDialog(myProject, myDetailsCallback) :\n                                                                 new PythonSdkDetailsDialog(myModule, myDetailsCallback);\n    final NullableConsumer<Sdk> sdkAddedCallback = new NullableConsumer<Sdk>() {\n      @Override\n      public void consume(Sdk sdk) {\n        if (sdk == null) return;\n        final PySdkService sdkService = PySdkService.getInstance();\n        sdkService.restoreSdk(sdk);\n        if (myProjectSdksModel.findSdk(sdk) == null) {\n          myProjectSdksModel.addSdk(sdk);\n        }\n        updateSdkList(false);\n        mySdkCombo.getModel().setSelectedItem(myProjectSdksModel.findSdk(sdk.getName()));\n        myPackagesPanel.updatePackages(PyPackageManagers.getInstance().getManagementService(myProject, sdk));\n        myPackagesPanel.updateNotifications(sdk);\n      }\n    };\n    PythonSdkDetailsStep.show(myProject, myProjectSdksModel.getSdks(), moreDialog, myMainPanel,\n                              myDetailsButton.getLocationOnScreen(), sdkAddedCallback);\n  }","id":84306,"modified_method":"private void showDetails() {\n    final PythonSdkDetailsDialog moreDialog = myModule == null ? new PythonSdkDetailsDialog(myProject, myAddSdkCallback) :\n                                                                 new PythonSdkDetailsDialog(myModule, myAddSdkCallback);\n\n    PythonSdkDetailsStep.show(myProject, myProjectSdksModel.getSdks(), moreDialog, myMainPanel,\n                              myDetailsButton.getLocationOnScreen(), myAddSdkCallback);\n  }","commit_id":"6fd859156748f48935c8a5d884828cdec9f7f78f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isModified() {\n    final Sdk selectedItem = (Sdk)mySdkCombo.getSelectedItem();\n    Sdk sdk = getSdk();\n    final Sdk selectedSdk = selectedItem == null ? null : myProjectSdksModel.findSdk(selectedItem);\n    return selectedItem instanceof PyDetectedSdk || !Comparing.equal(sdk, selectedSdk);\n  }","id":84307,"modified_method":"@Override\n  public boolean isModified() {\n    Sdk sdk = getSdk();\n    final Sdk selectedSdk = getSelectedSdk();\n    return selectedSdk instanceof PyDetectedSdk || !Comparing.equal(sdk, selectedSdk);\n  }","commit_id":"6fd859156748f48935c8a5d884828cdec9f7f78f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initContent() {\n    myInterpreterList = PyConfigurableInterpreterList.getInstance(myProject);\n\n    myProjectSdksModel = myInterpreterList.getModel();\n    myProjectSdksModel.addListener(mySdkModelListener);\n\n    mySdkCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final Sdk selectedSdk = (Sdk)mySdkCombo.getSelectedItem();\n        myPackagesPanel.updatePackages(selectedSdk != null ?\n                                       PyPackageManagers.getInstance().getManagementService(myProject, selectedSdk) : null);\n        myPackagesPanel.updateNotifications(selectedSdk);\n      }\n    });\n    myDetailsCallback = new NullableConsumer<Sdk>() {\n      @Override\n      public void consume(@Nullable Sdk sdk) {\n        if (sdk instanceof PyDetectedSdk) {\n          final Sdk addedSdk = SdkConfigurationUtil.createAndAddSDK(sdk.getHomePath(), PythonSdkType.getInstance());\n          if (addedSdk != null) {\n            myProjectSdksModel.addSdk(addedSdk);\n            updateSdkList(false);\n            mySdkCombo.getModel().setSelectedItem(myProjectSdksModel.findSdk(addedSdk.getName()));\n          }\n        }\n        else if (sdk != null) {\n          PythonSdkAdditionalData additionalData = (PythonSdkAdditionalData)sdk.getSdkAdditionalData();\n          if (additionalData != null) {\n            final String path = additionalData.getAssociatedProjectPath();\n            final String basePath = myProject.getBasePath();\n            if (basePath != null && !basePath.equals(path))\n              additionalData.setAssociatedProjectPath(null);\n          }\n          updateSdkList(false);\n          mySdkCombo.getModel().setSelectedItem(myProjectSdksModel.findSdk(sdk.getName()));\n        }\n      }\n    };\n    myDetailsButton.addActionListener(new ActionListener() {\n                                        @Override\n                                        public void actionPerformed(ActionEvent e) {\n                                          showDetails();\n                                        }\n                                      }\n    );\n\n  }","id":84308,"modified_method":"private void initContent() {\n    myInterpreterList = PyConfigurableInterpreterList.getInstance(myProject);\n\n    myProjectSdksModel = myInterpreterList.getModel();\n    myProjectSdksModel.addListener(mySdkModelListener);\n\n    mySdkCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final Sdk selectedSdk = (Sdk)mySdkCombo.getSelectedItem();\n        myPackagesPanel.updatePackages(selectedSdk != null ?\n                                       PyPackageManagers.getInstance().getManagementService(myProject, selectedSdk) : null);\n        myPackagesPanel.updateNotifications(selectedSdk);\n      }\n    });\n    myAddSdkCallback = new SdkAddedCallback();\n    myDetailsButton.addActionListener(new ActionListener() {\n                                        @Override\n                                        public void actionPerformed(ActionEvent e) {\n                                          showDetails();\n                                        }\n                                      }\n    );\n\n  }","commit_id":"6fd859156748f48935c8a5d884828cdec9f7f78f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void apply() throws ConfigurationException {\n    final Sdk item = (Sdk)mySdkCombo.getSelectedItem();\n    myProjectSdksModel.apply();\n    Sdk newSdk = item == null ? null : myProjectSdksModel.findSdk(item);\n    if (item instanceof PyDetectedSdk) {\n      VirtualFile sdkHome = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n        @Override\n        public VirtualFile compute() {\n          return LocalFileSystem.getInstance().refreshAndFindFileByPath(item.getName());\n        }\n      });\n      newSdk = SdkConfigurationUtil.createAndAddSDK(sdkHome.getPath(), PythonSdkType.getInstance());\n      if (newSdk != null) {\n        myProjectSdksModel.addSdk(newSdk);\n        updateSdkList(false);\n        myProjectSdksModel.apply();\n      }\n      PySdkService.getInstance().solidifySdk(item);\n    }\n    mySdkCombo.getModel().setSelectedItem(newSdk == null ? null : myProjectSdksModel.findSdk(newSdk.getName()));\n\n    final Sdk prevSdk = getSdk();\n    setSdk(newSdk);\n\n    rehighlightStringLiterals(newSdk, prevSdk);\n  }","id":84309,"modified_method":"@Override\n  public void apply() throws ConfigurationException {\n    Sdk selectedSdk = getSelectedSdk();\n    if (selectedSdk instanceof PyDetectedSdk) {\n      final String sdkName = selectedSdk.getName();\n      VirtualFile sdkHome = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n        @Override\n        public VirtualFile compute() {\n          return LocalFileSystem.getInstance().refreshAndFindFileByPath(sdkName);\n        }\n      });\n      selectedSdk = SdkConfigurationUtil.createAndAddSDK(sdkHome.getPath(), PythonSdkType.getInstance());\n      if (selectedSdk != null) {\n        myProjectSdksModel.addSdk(selectedSdk);\n      }\n    }\n    if (selectedSdk != null) {\n      updateSdkList(false);\n      myProjectSdksModel.apply();\n      setSelectedSdk(selectedSdk);\n      PySdkService.getInstance().solidifySdk(selectedSdk);\n    }\n\n    final Sdk prevSdk = getSdk();\n    setSdk(selectedSdk);\n\n    rehighlightStringLiterals(selectedSdk, prevSdk);\n  }","commit_id":"6fd859156748f48935c8a5d884828cdec9f7f78f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void reset() {\n    resetSdkList();\n  }","id":84310,"modified_method":"@Override\n  public void reset() {\n    updateSdkList(false);\n    final Sdk sdk = getSdk();\n    setSelectedSdk(sdk);\n  }","commit_id":"6fd859156748f48935c8a5d884828cdec9f7f78f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Sdk findOrCreateSdk(final SdkType... sdkTypes) {\n    final Project defaultProject = ProjectManager.getInstance().getDefaultProject();\n    final Sdk sdk = ProjectRootManager.getInstance(defaultProject).getProjectJdk();\n    if (sdk != null) {\n      for (SdkType type : sdkTypes) {\n        if (sdk.getSdkType() == type) {\n          return sdk;\n        }\n      }\n    }\n    for (SdkType type : sdkTypes) {\n      List<Sdk> sdks = ProjectJdkTable.getInstance().getSdksOfType(type);\n      if (sdks.size() > 0) {\n        return sdks.get(0);\n      }\n    }\n    for (SdkType sdkType : sdkTypes) {\n      final String suggestedHomePath = sdkType.suggestHomePath();\n      if (suggestedHomePath != null && sdkType.isValidSdkHome(suggestedHomePath)) {\n        VirtualFile sdkHome = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n          public VirtualFile compute() {\n            return LocalFileSystem.getInstance().refreshAndFindFileByPath(suggestedHomePath);\n          }\n        });\n        if (sdkHome != null) {\n          final Sdk newSdk = setupSdk(ProjectJdkTable.getInstance().getAllJdks(), sdkHome, sdkType, true, null, null);\n          addSdk(newSdk);\n          return newSdk;\n        }\n      }\n    }\n    return null;\n  }","id":84311,"modified_method":"@Nullable\n  public static Sdk findOrCreateSdk(final SdkType... sdkTypes) {\n    final Project defaultProject = ProjectManager.getInstance().getDefaultProject();\n    final Sdk sdk = ProjectRootManager.getInstance(defaultProject).getProjectJdk();\n    if (sdk != null) {\n      for (SdkType type : sdkTypes) {\n        if (sdk.getSdkType() == type) {\n          return sdk;\n        }\n      }\n    }\n    for (SdkType type : sdkTypes) {\n      List<Sdk> sdks = ProjectJdkTable.getInstance().getSdksOfType(type);\n      if (sdks.size() > 0) {\n        return sdks.get(0);\n      }\n    }\n    for (SdkType sdkType : sdkTypes) {\n      final String suggestedHomePath = sdkType.suggestHomePath();\n      if (suggestedHomePath != null && sdkType.isValidSdkHome(suggestedHomePath)) {\n        VirtualFile sdkHome = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n          public VirtualFile compute() {\n            return LocalFileSystem.getInstance().refreshAndFindFileByPath(suggestedHomePath);\n          }\n        });\n        if (sdkHome != null) {\n          final Sdk newSdk = setupSdk(ProjectJdkTable.getInstance().getAllJdks(), sdkHome, sdkType, true, null, null);\n          if (newSdk != null) {\n            addSdk(newSdk);\n          }\n          return newSdk;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"8609e6d0148adcfd7acdfc3650c32ec98e39f84e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected JComponent createCenterPanel() {\n    mySdkList = new JBList();\n    mySdkList.setCellRenderer(new PySdkListCellRenderer(\"\", myModificators));\n    mySdkList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    ToolbarDecorator decorator = ToolbarDecorator.createDecorator(mySdkList).disableUpDownActions()\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          addSdk(button);\n          updateOkButton();\n        }\n      })\n      .setEditAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          editSdk();\n          updateOkButton();\n        }\n      })\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          removeSdk();\n          updateOkButton();\n        }\n      })\n      .addExtraAction(new CreateVirtualEnvButton())\n      .addExtraAction(new ToggleVirtualEnvFilterButton())\n      .addExtraAction(new ShowPathButton());\n\n    decorator.setPreferredSize(new Dimension(600, 500));\n    myPanel = decorator.createPanel();\n    refreshSdkList();\n    addListeners();\n    return myPanel;\n  }","id":84312,"modified_method":"@Nullable\n  @Override\n  protected JComponent createCenterPanel() {\n    mySdkList = new JBList();\n    mySdkList.setCellRenderer(new PySdkListCellRenderer(\"\", myModificators));\n    mySdkList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    ToolbarDecorator decorator = ToolbarDecorator.createDecorator(mySdkList).disableUpDownActions()\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          addSdk(button);\n          updateOkButton();\n        }\n      })\n      .setEditAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          editSdk();\n          updateOkButton();\n        }\n      })\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          removeSdk();\n          updateOkButton();\n        }\n      })\n      .addExtraAction(new ToggleVirtualEnvFilterButton())\n      .addExtraAction(new ShowPathButton());\n\n    decorator.setPreferredSize(new Dimension(600, 500));\n    myPanel = decorator.createPanel();\n    refreshSdkList();\n    addListeners();\n    return myPanel;\n  }","commit_id":"9356f0b92ef8f8a995ed3d6c99e59434ef87ca0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addCreatedSdk(@Nullable final Sdk sdk, boolean newVirtualEnv) {\n    if (sdk != null) {\n      myAddedSdk = sdk;\n      boolean isVirtualEnv = PythonSdkType.isVirtualEnv(sdk);\n      if (isVirtualEnv && !newVirtualEnv) {\n        AddVEnvOptionsDialog dialog = new AddVEnvOptionsDialog(myPanel);\n        dialog.show();\n        if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n          return;\n        }\n        SdkModificator modificator = myModificators.get(sdk);\n        setSdkAssociated(modificator, !dialog.makeAvailableToAll());\n        myModifiedModificators.add(modificator);\n      }\n      myProjectSdksModel.addSdk(sdk);\n      refreshSdkList();\n      mySdkList.setSelectedValue(sdk, true);\n      mySdkListChanged = true;\n    }\n  }","id":84313,"modified_method":"private void addCreatedSdk(@Nullable final Sdk sdk, boolean newVirtualEnv) {\n    if (sdk != null) {\n      myAddedSdk = sdk;\n      boolean isVirtualEnv = PythonSdkType.isVirtualEnv(sdk);\n      if (isVirtualEnv && !newVirtualEnv) {\n        AddVEnvOptionsDialog dialog = new AddVEnvOptionsDialog(myPanel);\n        dialog.show();\n        if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n          return;\n        }\n        SdkModificator modificator = myModificators.get(sdk);\n        setSdkAssociated(modificator, !dialog.makeAvailableToAll());\n        myModifiedModificators.add(modificator);\n      }\n      final Sdk oldSdk = myProjectSdksModel.findSdk(sdk);\n      if (oldSdk == null)\n        myProjectSdksModel.addSdk(sdk);\n      refreshSdkList();\n      mySdkList.setSelectedValue(sdk, true);\n      mySdkListChanged = true;\n    }\n  }","commit_id":"9356f0b92ef8f8a995ed3d6c99e59434ef87ca0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void stop() throws EucalyptusCloudException {\n    LOG.debug(\"Checking ObjectStorageGateway preconditions\");\n    ospClient.stop();\n    synchronized (ObjectStorageGateway.class) {\n      ospClient = null;\n    }\n    Tracker.die();\n\n    try {\n      ObjectMetadataManagers.getInstance().stop();\n    } catch (Exception e) {\n      LOG.error(\"Error stopping object manager\", e);\n    }\n\n    try {\n      BucketMetadataManagers.getInstance().stop();\n    } catch (Exception e) {\n      LOG.error(\"Error stopping bucket manager\", e);\n    }\n\n    LOG.debug(\"Checking ObjectStorageGateway preconditions\");\n  }","id":84314,"modified_method":"public static void stop() throws EucalyptusCloudException {\n    LOG.debug(\"Stopping ObjectStorageGateway\");\n    if (ospClient != null) {\n      ospClient.stop();\n    } else {\n      LOG.warn(\"ospClient is null in stop(), OSG apparently not configured.\");\n      // Keep going, tear down the rest even if we didn't stop()\n    }\n    synchronized (ObjectStorageGateway.class) {\n      ospClient = null;\n    }\n    Tracker.die();\n\n    try {\n      ObjectMetadataManagers.getInstance().stop();\n    } catch (Exception e) {\n      LOG.error(\"Error stopping object manager\", e);\n    }\n\n    try {\n      BucketMetadataManagers.getInstance().stop();\n    } catch (Exception e) {\n      LOG.error(\"Error stopping bucket manager\", e);\n    }\n\n    LOG.debug(\"Checking ObjectStorageGateway preconditions\");\n  }","commit_id":"f17412625e65e9ba1bf84af89d49b1dae608bba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void configure() throws EucalyptusCloudException {\n    synchronized (ObjectStorageGateway.class) {\n      ConfigurationCache.getConfiguration(ObjectStorageGlobalConfiguration.class); // prime the cache\n\n      if (ospClient == null) {\n        try {\n          ospClient = ObjectStorageProviders.getInstance();\n        } catch (Exception ex) {\n          LOG.error(\"Error getting the configured providerclient for ObjectStorageGateway. Cannot continue\", ex);\n          throw new EucalyptusCloudException(ex);\n        }\n      }\n    }\n\n    try {\n      ospClient.initialize();\n    } catch (S3Exception ex) {\n      LOG.error(\"Error initializing Object Storage Gateway\", ex);\n      SystemUtil.shutdownWithError(ex.getMessage());\n    }\n\n    // Disable torrents\n    // Tracker.initialize();\n    try {\n      if (ospClient != null) {\n        // TODO: zhill - this seems wrong in check(), should be in enable() ?\n        ospClient.start();\n      }\n    } catch (S3Exception ex) {\n      LOG.error(\"Error starting storage backend: \" + ex);\n    }\n  }","id":84315,"modified_method":"public static void configure() throws EucalyptusCloudException {\n    synchronized (ObjectStorageGateway.class) {\n      ConfigurationCache.getConfiguration(ObjectStorageGlobalConfiguration.class); // prime the cache\n\n      if (ospClient == null) {\n        try {\n          ospClient = ObjectStorageProviders.getInstance();\n        } catch (Exception ex) {\n          LOG.error(\"Error getting the configured providerclient for ObjectStorageGateway. Cannot continue\", ex);\n          throw new EucalyptusCloudException(ex);\n        }\n      }\n    }\n\n    if (ospClient != null) {\n      try {\n        ospClient.initialize();\n      } catch (S3Exception ex) {\n        LOG.error(\"Error initializing Object Storage Gateway\", ex);\n        SystemUtil.shutdownWithError(ex.getMessage());\n      } \n    } else {\n      String errMsg = \"In initializing ospClient, expected a valid reference \" \n          + \"to Object Storage Provider Client, but found none (null)\";\n      LOG.error(errMsg);\n      throw new EucalyptusCloudException(errMsg);\n    }\n\n    // Disable torrents\n    // Tracker.initialize();\n    try {\n      if (ospClient != null) {\n        // TODO: zhill - this seems wrong in check(), should be in enable() ?\n        ospClient.start();\n      }\n    } catch (S3Exception ex) {\n      LOG.error(\"Error starting storage backend: \" + ex);\n    }\n    \n    // The ospClient should be configured by now.\n    if (ospClient == null) {\n      String errMsg = \"Error starting storage backend, ospClient is still null at the end of configure().\";\n      LOG.error(errMsg);\n      throw new EucalyptusCloudException(errMsg);\n    } else {\n      LOG.debug(\"Configuring ObjectStorageGateway complete\");\n    }\n  }","commit_id":"f17412625e65e9ba1bf84af89d49b1dae608bba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void disable() throws EucalyptusCloudException {\n    LOG.debug(\"Disabling ObjectStorageGateway\");\n    ospClient.disable();\n    LOG.debug(\"Disabling ObjectStorageGateway complete\");\n  }","id":84316,"modified_method":"public static void disable() throws EucalyptusCloudException {\n    LOG.debug(\"Disabling ObjectStorageGateway\");\n    if (ospClient != null) {\n      ospClient.disable();\n    } else {\n      String errMsg = \"ospClient is null in disable(), OSG apparently not configured.\";\n      LOG.error(errMsg);\n      throw new EucalyptusCloudException(errMsg);\n    }\n    LOG.debug(\"Disabling ObjectStorageGateway complete\");\n  }","commit_id":"f17412625e65e9ba1bf84af89d49b1dae608bba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void enable() throws EucalyptusCloudException {\n    LOG.debug(\"Enabling ObjectStorageGateway\");\n    ospClient.enable();\n    LOG.debug(\"Enabling ObjectStorageGateway complete\");\n  }","id":84317,"modified_method":"public static void enable() throws EucalyptusCloudException {\n    LOG.debug(\"Enabling ObjectStorageGateway\");\n    if (ospClient != null) {\n      ospClient.enable();\n    } else {\n      String errMsg = \"ospClient is null in enable(), OSG apparently not configured.\";\n      LOG.error(errMsg);\n      throw new EucalyptusCloudException(errMsg);\n    }\n    LOG.debug(\"Enabling ObjectStorageGateway complete\");\n  }","commit_id":"f17412625e65e9ba1bf84af89d49b1dae608bba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void check() throws EucalyptusCloudException {\n    LOG.trace(\"Checking ObjectStorageGateway\");\n    ospClient.check();\n    LOG.trace(\"Checking ObjectStorageGateway complete\");\n  }","id":84318,"modified_method":"public static void check() throws EucalyptusCloudException {\n    LOG.trace(\"Checking ObjectStorageGateway\");\n    if (ospClient != null) {\n      ospClient.check();\n    } else {\n      String errMsg = \"ospClient is null in check(), OSG apparently not configured.\";\n      LOG.error(errMsg);\n      throw new EucalyptusCloudException(errMsg);\n    }\n    LOG.trace(\"Checking ObjectStorageGateway complete\");\n  }","commit_id":"f17412625e65e9ba1bf84af89d49b1dae608bba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void doAddType() {\n\t\tString name = null;\n\t\t\n\t\tname = JOptionPane.showInputDialog(\"Name the new user type:\");\n\t\tif( name != null) {\n\t\t\tUserMapType type = new UserMapType( mMap, name);\n\t\t\tmListModel.addElement( type);\n\t\t\t//System.out.println(\" -- added item: \"+name);\n\t\t\t//System.out.println(\"  curent size is:  \"+mListModel.size() );\n\t\t\t}\n\t}","id":84319,"modified_method":"public void doAddType() {\n\t\tString name = null;\n\t\t\n\t\tname = JOptionPane.showInputDialog(\"Name the new user type:\");\n\t\tif( name != null) {\n\t\t\tUserMapType type = new UserMapType( mMap, name);\n\t\t\tmListModel.addElement( type);\n\t\t\tmTypeList.setSelectedValue( type, true);\n\t\t\t//System.out.println(\" -- added item: \"+name);\n\t\t\t//System.out.println(\"  curent size is:  \"+mListModel.size() );\n\t\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public void valueChanged( ListSelectionEvent pEvent) {\n\t\tObject source = pEvent.getSource();\n\t\tif( source == mTypeList ) {\n\t\t\tint index = mTypeList.getSelectedIndex();\n\t\t\tObject obj = null;\n\t\t\tif( index >= 0 ) {\n\t\t\t\tobj = mListModel.elementAt( index);\n\t\t\t\t}\n\t\t\tUserMapType type = null;\n\t\t\tif( obj instanceof UserMapType) {\n\t\t\t\ttype = (UserMapType) obj;\n\t\t\t\t}\n\t\t\tsetUserType( type);\n\t\t\t}\n\tupdateEnabledStates();\n\t}","id":84320,"modified_method":"public void valueChanged( ListSelectionEvent pEvent) {\n\t\tObject source = pEvent.getSource();\n\t\tif( source == mTypeList ) {\n\t\t\tint index = mTypeList.getSelectedIndex();\n\t\t\tObject obj = null;\n\t\t\tif( index >= 0 ) {\n\t\t\t\tobj = mListModel.elementAt( index);\n\t\t\t\t}\n\t\t\tUserMapType type = null;\n\t\t\tif( obj instanceof UserMapType) {\n\t\t\t\ttype = (UserMapType) obj;\n\t\t\t\t}\n\t\t\tsetUserType( type);\n\t\t\t\n\t\t\t}\n\t\tif( source == mTable) {\n\t\t\tSystem.out.println( \"table selection.\");\n\t\t\t}\n\tupdateEnabledStates();\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public void doOkay() {\n\t\tmDialog.dispose();\n\t}","id":84321,"modified_method":"public void doOkay() {\n\t\t\n\t\tUserMapType [] types = null;\n\t\t\n\t\tif( !mListModel.isEmpty() ) {\n\t\t\t types = new UserMapType[ mListModel.size() ];\n\t\t\tfor( int i= 0; i< mListModel.size(); i++) {\n\t\t\t\ttypes[ i] = (UserMapType) mListModel.elementAt( i);\n\t\t\t\t}\n\t\t\t}\n\t\tmMap.setUserMapTypes( types);\n\t\n\t\n\t\tmDialog.dispose();\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public void doRemoveProperty() {\n\t\n\t}","id":84322,"modified_method":"public void doRemoveProperty() {\n\t\tif( mCurType != null) {\n\t\t\tint index = mTable.getSelectedRow();\n\t\t\tif( index < 0 )\n\t\t\t\treturn;\n\t\t\tUserProperty [] props = mCurType.getUserProperties();\n\t\t\tmCurType.removeUserProperty( props[ index] );\n\t\t\t\n\t\t\tmPropertyTableModel.fireTableDataChanged();\n\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public void doAddProperty() {\n\t\t\n\t\tString name = null;\n\t\tname = JOptionPane.showInputDialog(\"Property name:\");\n\t\tif( name != null) {\n\t\t\tUserProperty prop = mCurType.createUserProperty( name);\n\t\t\tObject [] objs = new Object[3];\n\t\t\tobjs[0] = prop;\n\t\t\tobjs[1] = \"String\";   // FIX: do lookup\n\t\t\tobjs [2] = new String(\"\");\n\t\t\t\n\t\t\tmTableModel.addRow( objs );\n\t\t\tif( mCurType != null)\n\t\t\t\tmCurType.addUserProperty( prop);\n\t\t\t}\n\t}","id":84323,"modified_method":"public void doAddProperty() {\n\t\t\n\t\tString name = null;\n\t\t//name = JOptionPane.showInputDialog(\"Property name:\");\n\t\t\n\t\tname = \"Property \"+mCount++;\n\t\tif( name != null) {\n\t\t\tUserProperty prop = mCurType.createUserProperty( name);\n\t\t\tObject [] objs = new Object[3];\n\t\t\tobjs[0] = prop;\n\t\t\tobjs[1] = \"String\";   // FIX: do lookup\n\t\t\tobjs [2] = new String(\"\");\n\t\t\t\n\t\t\tmTableModel.addRow( objs );\n\t\t\tif( mCurType != null)\n\t\t\t\tmCurType.addUserProperty( prop);\n\t\t\t\tmPropertyTableModel.fireTableDataChanged();\n\t\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"private void setUserType( UserMapType pType) {\n\t\tif( mCurType != pType) {\n\t\t\tmCurType = pType;\n\t\t\t\n\t\t\t}\n\t}","id":84324,"modified_method":"private void setUserType( UserMapType pType) {\n\t\tif( mCurType != pType) {\n\t\t\tmCurType = pType;\n\t\t\tmPropertyTableModel.setUserType( pType);\n\t\t\t\n\t\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed( ActionEvent pEvent) {\n\t\t\n\t\tObject source = pEvent.getSource();\n\t\t\n\t\tif( source == mOkayButton) {\n\t\t\tdoOkay();\n\t\t\t}\n\t\tif( source == mAddTypeButton) {\n\t\t\tdoAddType();\n\t\t\t}\n\t\tif( source == mRemoveTypeButton ) {\n\t\t\tdoRemoveType();\n\t\t\t}\n\t\tif( source == mAddPropertyButton ) {\n\t\t\tdoAddProperty();\n\t\t\t}\n\t\tif( source == mRemovePropertyButton ) {\n\t\t\tdoRemoveProperty();\n\t\t\t}\n\t\tupdateEnabledStates();\n\t\n\t}","id":84325,"modified_method":"public void actionPerformed( ActionEvent pEvent) {\n\t\t\n\t\tObject source = pEvent.getSource();\n\t\t\n\t\tif( source == mOkayButton) {\n\t\t\tdoOkay();\n\t\t\t}\n\t\tif( source == mAddTypeButton) {\n\t\t\tdoAddType();\n\t\t\t}\n\t\tif( source == mRemoveTypeButton ) {\n\t\t\tdoRemoveType();\n\t\t\t}\n\t\tif( source == mAddPropertyButton ) {\n\t\t\tdoAddProperty();\n\t\t\t}\n\t\tif( source == mRemovePropertyButton ) {\n\t\t\tdoRemoveProperty();\n\t\t\t}\n\t\tif( source == mUpButton ) {\n\t\t\tdoNudgeUp();\n\t\t\t}\n\t\tif( source == mDownButton ) {\n\t\t\tdoNudgeDown();\n\t\t\t}\n\t\tupdateEnabledStates();\n\t\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"private void initializeComponents() {\n\t\t\n\t\tJPanel mainPanel = new JPanel();\n\t\tmainPanel.setLayout( new BorderLayout() );\n\t\t\n\t\tJPanel listPanel = new JPanel();\n\t\tlistPanel.setLayout( new BorderLayout() );\n\t\t\n\t\tJLabel listTitle = new JLabel(\"User TYpes:\");\n\t\tBox listControls = Box.createHorizontalBox();\n\t\tmAddTypeButton = createButton( \"New TYpe\");\n\t\tmRemoveTypeButton = createButton( \"Remove Type\");\n\t\tlistControls.add( mAddTypeButton );\n\t\tlistControls.add( mRemoveTypeButton);\n\t\t\n\t\tmListModel = new DefaultListModel();\n\t\t\n\t\t// mListModel.addElement( \"Default\");\n\t\tmTypeList = new JList( mListModel);\n\t\tmTypeList.setSelectionMode( ListSelectionModel.SINGLE_SELECTION);\n\t\tmTypeList.addListSelectionListener( this);\n\t\t\n\t\t//mTypeList.setModel( mListModel);\n\t\t\n\t\tJScrollPane listScroll = new JScrollPane();\n\t\tlistScroll.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n\t\tlistScroll.setHorizontalScrollBarPolicy( JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tlistScroll.getViewport().add(  mTypeList);\n\t\tlistPanel.add( BorderLayout.CENTER, listScroll);\n\t\tlistPanel.add( BorderLayout.NORTH, listTitle);\n\t\tlistPanel.add( BorderLayout.SOUTH, listControls);\n\t\t\n\t\tJPanel propPanel = new JPanel();\n\t\tpropPanel.setLayout( new BorderLayout() );\n\t\t\n\t\tmAddPropertyButton = createButton(\"Add\");\n\t\tmRemovePropertyButton = createButton( \"Remove\");\n\t\tmUpButton = createButton( \"Nudge Up\");\n\t\tmDownButton = createButton( \"Nudge Down\");\n\t\tJLabel propTitle = new JLabel( \"Properties:\");\n\t\tBox propControls = Box.createVerticalBox();\n\t\tpropControls.add( mUpButton );\n\t\tpropControls.add( mDownButton);\n\t\tpropControls.add( mRemovePropertyButton);\n\t\tpropControls.add( mAddPropertyButton);\n\t\t\n\t\tinitPropertyTable();\n\t\tJScrollPane tablePanel = new JScrollPane( mTable);\n\t\ttablePanel.setVerticalScrollBarPolicy( JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n\t\ttablePanel.setHorizontalScrollBarPolicy( JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t\n\t\tpropPanel.add( BorderLayout.NORTH, propTitle);\n\t\tpropPanel.add( BorderLayout.EAST, propControls);\n\t\tpropPanel.add( BorderLayout.CENTER, tablePanel);\n\t\t\n\t\tBox mainControls = Box.createHorizontalBox();\n\t\tmOkayButton = createButton(\"Okay\");\n\t\tmainControls.add( mOkayButton);\n\t\t\n\t\tmainPanel.add( BorderLayout.WEST, listPanel);\n\t\tmainPanel.add( BorderLayout.SOUTH, mainControls);\n\t\tmainPanel.add( BorderLayout.CENTER, propPanel);\n\t\tadd( BorderLayout.CENTER, mainPanel);\n\t\t\n\t}","id":84326,"modified_method":"private void initializeComponents() {\n\t\t\n\t\tJPanel mainPanel = new JPanel();\n\t\tmainPanel.setLayout( new BorderLayout() );\n\t\t\n\t\tJPanel listPanel = new JPanel();\n\t\tlistPanel.setLayout( new BorderLayout() );\n\t\t\n\t\tJLabel listTitle = new JLabel(\"User TYpes:\");\n\t\tBox listControls = Box.createHorizontalBox();\n\t\tmAddTypeButton = createButton( \"New TYpe\");\n\t\tmRemoveTypeButton = createButton( \"Remove Type\");\n\t\tlistControls.add( mAddTypeButton );\n\t\tlistControls.add( mRemoveTypeButton);\n\t\t\n\t\t\n\t\tUserMapType [] types = null;\n\t\tif( mMap != null) {\n\t\t\ttypes = mMap.getUserMapTypes();\n\t\t\t}\n\t\tmListModel = new DefaultListModel();\n\t\tif( types != null) {\n\t\t\tfor(int i=0; i< types.length; i++)  {\n\t\t\t\tmListModel.addElement( types[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t// mListModel.addElement( \"Default\");\n\t\tmTypeList = new JList( mListModel);\n\t\tmTypeList.setSelectionMode( ListSelectionModel.SINGLE_SELECTION);\n\t\tmTypeList.addListSelectionListener( this);\n\t\t\n\t\t//mTypeList.setModel( mListModel);\n\t\t\n\t\tJScrollPane listScroll = new JScrollPane();\n\t\tlistScroll.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n\t\tlistScroll.setHorizontalScrollBarPolicy( JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tlistScroll.getViewport().add(  mTypeList);\n\t\tlistPanel.add( BorderLayout.CENTER, listScroll);\n\t\tlistPanel.add( BorderLayout.NORTH, listTitle);\n\t\tlistPanel.add( BorderLayout.SOUTH, listControls);\n\t\t\n\t\tJPanel propPanel = new JPanel();\n\t\tpropPanel.setLayout( new BorderLayout() );\n\t\t\n\t\tmAddPropertyButton = createButton(\"Add\");\n\t\tmRemovePropertyButton = createButton( \"Remove\");\n\t\tmUpButton = createButton( \"Nudge Up\");\n\t\tmDownButton = createButton( \"Nudge Down\");\n\t\tJLabel propTitle = new JLabel( \"Properties:\");\n\t\tBox propControls = Box.createVerticalBox();\n\t\tpropControls.add( mUpButton );\n\t\tpropControls.add( mDownButton);\n\t\tpropControls.add( mRemovePropertyButton);\n\t\tpropControls.add( mAddPropertyButton);\n\t\t\n\t\tinitPropertyTable();\n\t\tJScrollPane tablePanel = new JScrollPane( mTable);\n\t\ttablePanel.setVerticalScrollBarPolicy( JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n\t\ttablePanel.setHorizontalScrollBarPolicy( JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t\n\t\tpropPanel.add( BorderLayout.NORTH, propTitle);\n\t\tpropPanel.add( BorderLayout.EAST, propControls);\n\t\tpropPanel.add( BorderLayout.CENTER, tablePanel);\n\t\t\n\t\tBox mainControls = Box.createHorizontalBox();\n\t\tmOkayButton = createButton(\"Okay\");\n\t\tmainControls.add( mOkayButton);\n\t\t\n\t\tmainPanel.add( BorderLayout.WEST, listPanel);\n\t\tmainPanel.add( BorderLayout.SOUTH, mainControls);\n\t\tmainPanel.add( BorderLayout.CENTER, propPanel);\n\t\tadd( BorderLayout.CENTER, mainPanel);\n\t\t\n\t\tif( mListModel.size() > 0 ) {\n\t\t\tmTypeList.setSelectedIndex( 0);\n\t\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public void doRemoveType() {\n\t\n\t}","id":84327,"modified_method":"public void doRemoveType() {\n\t\tObject obj = mTypeList.getSelectedValue();\n\t\tif( obj != null) {\n\t\t\tint index = mTypeList.getSelectedIndex();\n\t\t\tUserMapType type = (UserMapType) obj;\n\t\t\tmListModel.removeElement( type);\n\t\t\tif( mListModel.size() > 0 ) {\n\t\t\t\tif( index > 0)\n\t\t\t\t\tindex--;\t\t\t\n\t\t\t\tmTypeList.setSelectedIndex( index);\n\t\t\t\t}\n\t\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"private void updateEnabledStates() {\n\t\tboolean ts = (mCurType != null);\n\t\t\n\t\tmAddPropertyButton.enable( ts);\n\t\tmRemovePropertyButton.enable( ts);\n\t\tmUpButton.enable( ts);\n\t\tmDownButton.enable( ts);\n\t\tif( ts) {\n\t\t\tboolean ps = (mTable.getSelectedRow() != -1);\n\t\t\tmRemovePropertyButton.enable( ps);\n\t\t\tmUpButton.enable(  ps);\n\t\t\tmDownButton.enable( ps);\n\t\t\t}\n\t\t\t\n\t\tboolean hm = (mMap != null);\n\t\tmAddTypeButton.enable( hm);\n\t\tmRemoveTypeButton.enable( hm);\n\t\tif( hm) {\n\t\t\tmRemoveTypeButton.enable( mTypeList.getSelectedIndex() >= 0);\n\t\t\t}\n\t}","id":84328,"modified_method":"private void updateEnabledStates() {\n\t\tboolean ts = (mCurType != null);\n\t\t\n\t\tmAddPropertyButton.enable( ts);\n\t\tmRemovePropertyButton.enable( ts);\n\t\tmUpButton.enable( ts);\n\t\tmDownButton.enable( ts);\n\t\tif( ts) {\n\t\t\tboolean ps = (mTable.getSelectedRow() != -1);\n\t\t\tmRemovePropertyButton.enable( ps);\n\t\t\t\n\t\t\tint row = mTable.getSelectedRow();\n\t\t\tif( row == -1) {\n\t\t\t\tmUpButton.enable(  false);\n\t\t\t\tmDownButton.enable( false);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tmUpButton.setEnabled( row != 0);\n\t\t\t\tmDownButton.setEnabled( row < (mTable.getRowCount() -1));\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\tboolean hm = (mMap != null);\n\t\tmAddTypeButton.enable( hm);\n\t\tmRemoveTypeButton.enable( hm);\n\t\tif( hm) {\n\t\t\tmRemoveTypeButton.enable( mTypeList.getSelectedIndex() >= 0);\n\t\t\t}\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"private void initPropertyTable() {\n\t\t\n\t\tString [] columns = {\"Property\", \"Type\", \"Value\"};\n\t\tmTableModel = new DefaultTableModel( columns, 0);\n\t\t\n\t\t\n\t\tmTable = new JTable( mTableModel);\n\t}","id":84329,"modified_method":"private void initPropertyTable() {\n\t\t\n\t\tString [] columns = {\"Property\", \"Type\", \"Value\"};\n\t\tmTableModel = new DefaultTableModel( columns, 0);\n\t\tmPropertyTableModel = new PropertyTableModel( null);\n\t\t\n\t\tmTable = new JTable( mPropertyTableModel);\n\t\tmTable.setSelectionMode( ListSelectionModel.SINGLE_SELECTION);\n\t\tmTable.setRowSelectionAllowed( true);\n\t\tmTable.setColumnSelectionAllowed( false);\n\t\tmTable.getSelectionModel().addListSelectionListener( this);\n\t\t\n\t\tmTypeEditor = new JComboBox( UserProperty.sPropertyTypeNames );\n\n\t\tTableColumn typeColumn = mTable.getColumnModel().getColumn(1);\n\t\ttypeColumn.setCellEditor(new DefaultCellEditor( mTypeEditor));\n\t\n\t}","commit_id":"28eecfd8fa7124ef4b577374d5b1e81d3a2a3db6","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean run(Collection<String> externals, Result changeLog) throws IOException, InterruptedException {\n        boolean changelogFileCreated = false;\n\n        SVNLogClient svnlc = SubversionSCM.createSvnClientManager(createAuthenticationProvider()).getLogClient();\n        TransformerHandler th = createTransformerHandler();\n        th.setResult(changeLog);\n        SVNXMLLogHandler logHandler = new SVNXMLLogHandler(th);\n        // work around for http://svnkit.com/tracker/view.php?id=175\n        th.setDocumentLocator(DUMMY_LOCATOR);\n        logHandler.startDocument();\n\n        for (ModuleLocation l : scm.getLocations()) {\n            changelogFileCreated |= buildModule(l.remote, svnlc, logHandler);\n        }\n        for(String path : externals) {\n            changelogFileCreated |= buildModule(\n                getUrlForPath(build.getProject().getWorkspace().child(path)), svnlc, logHandler);\n        }\n\n        if(changelogFileCreated) {\n            logHandler.endDocument();\n        }\n\n        return changelogFileCreated;\n    }","id":84330,"modified_method":"public boolean run(Collection<String> externals, Result changeLog) throws IOException, InterruptedException {\n        boolean changelogFileCreated = false;\n\n        final SVNClientManager manager = SubversionSCM.createSvnClientManager(createAuthenticationProvider());\n        try {\n\t\t\tSVNLogClient svnlc = manager.getLogClient();\n        TransformerHandler th = createTransformerHandler();\n        th.setResult(changeLog);\n        SVNXMLLogHandler logHandler = new SVNXMLLogHandler(th);\n        // work around for http://svnkit.com/tracker/view.php?id=175\n        th.setDocumentLocator(DUMMY_LOCATOR);\n        logHandler.startDocument();\n\n        for (ModuleLocation l : scm.getLocations()) {\n            changelogFileCreated |= buildModule(l.remote, svnlc, logHandler);\n        }\n        for(String path : externals) {\n            changelogFileCreated |= buildModule(\n                getUrlForPath(build.getProject().getWorkspace().child(path)), svnlc, logHandler);\n        }\n\n        if(changelogFileCreated) {\n            logHandler.endDocument();\n        }\n\n        return changelogFileCreated;\n        } finally {\n        \tmanager.dispose();\n        }\n    }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"public String invoke(File p, VirtualChannel channel) throws IOException {\n            SVNWCClient svnwc = SubversionSCM.createSvnClientManager(authProvider).getWCClient();\n\n            SVNInfo info;\n            try {\n                info = svnwc.doInfo(p, SVNRevision.WORKING);\n                return info.getURL().toDecodedString();\n            } catch (SVNException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }","id":84331,"modified_method":"public String invoke(File p, VirtualChannel channel) throws IOException {\n            final SVNClientManager manager = SubversionSCM.createSvnClientManager(authProvider);\n            try {\n\t\t\t\tfinal SVNWCClient svnwc = manager.getWCClient();\n\n            SVNInfo info;\n            try {\n                info = svnwc.doInfo(p, SVNRevision.WORKING);\n                return info.getURL().toDecodedString();\n            } catch (SVNException e) {\n                e.printStackTrace();\n                return null;\n            }\n            } finally {\n            \tmanager.dispose();\n            }\n        }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Gets the SVN metadata for the remote repository.\n     *\n     * @param remoteUrl\n     *      The target to run \"svn info\".\n     */\n    private static SVNInfo parseSvnInfo(SVNURL remoteUrl, ISVNAuthenticationProvider authProvider) throws SVNException {\n        SVNWCClient svnWc = createSvnClientManager(authProvider).getWCClient();\n        return svnWc.doInfo(remoteUrl, SVNRevision.HEAD, SVNRevision.HEAD);\n    }","id":84332,"modified_method":"/**\n     * Gets the SVN metadata for the remote repository.\n     *\n     * @param remoteUrl\n     *      The target to run \"svn info\".\n     */\n    private static SVNInfo parseSvnInfo(SVNURL remoteUrl, ISVNAuthenticationProvider authProvider) throws SVNException {\n        final SVNClientManager manager = createSvnClientManager(authProvider);\n        try {\n        \tfinal SVNWCClient svnWc = manager.getWCClient();\n        return svnWc.doInfo(remoteUrl, SVNRevision.HEAD, SVNRevision.HEAD);\n        } finally {\n        \tmanager.dispose();\n        }\n    }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"public List<String> invoke(File ws, VirtualChannel channel) throws IOException {\n            SVNUpdateClient svnuc = createSvnClientManager(authProvider).getUpdateClient();\n            List<String> externals = new ArrayList<String>(); // store discovered externals to here\n            SVNRevision revision = SVNRevision.create(timestamp);\n            if(update) {\n\n                for (ModuleLocation l : locations) {\n                    try {\n                        listener.getLogger().println(\"Updating \"+ l.remote);\n\n                        svnuc.setEventHandler(new SubversionUpdateEventHandler(listener, externals, l.local));\n                        svnuc.doUpdate(new File(ws, l.local).getCanonicalFile(), revision, true);\n\n                    } catch (SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to update \"+l.remote));\n                        // trouble-shooting probe for #591\n                        if(e.getErrorMessage().getErrorCode()== SVNErrorCode.WC_NOT_LOCKED) {\n                            listener.getLogger().println(\"Polled jobs are \"+ SCMTrigger.DESCRIPTOR.getItemsBeingPolled());\n                        }\n                        return null;\n                    }\n                }\n            } else {\n                Util.deleteContentsRecursive(ws);\n\n                for (ModuleLocation l : locations) {\n                    try {\n                        SVNURL url = SVNURL.parseURIEncoded(l.remote);\n                        listener.getLogger().println(\"Checking out \"+url);\n\n                        svnuc.setEventHandler(new SubversionUpdateEventHandler(listener, externals, l.local));\n                        svnuc.doCheckout(url, new File(ws, l.local).getCanonicalFile(), SVNRevision.HEAD, revision, true);\n\n                    } catch (SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to check out \"+l.remote));\n                        return null;\n                    }\n                }\n            }\n            return externals;\n        }","id":84333,"modified_method":"public List<String> invoke(File ws, VirtualChannel channel) throws IOException {\n            final SVNClientManager manager = createSvnClientManager(authProvider);\n            try {\n\t\t\t\tfinal SVNUpdateClient svnuc = manager.getUpdateClient();\n\t            final List<String> externals = new ArrayList<String>(); // store discovered externals to here\n\t            final SVNRevision revision = SVNRevision.create(timestamp);\n            if(update) {\n\t                for (final ModuleLocation l : locations) {\n                    try {\n                        listener.getLogger().println(\"Updating \"+ l.remote);\n\n                        svnuc.setEventHandler(new SubversionUpdateEventHandler(listener, externals, l.local));\n                        svnuc.doUpdate(new File(ws, l.local).getCanonicalFile(), revision, true);\n\n\t                    } catch (final SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to update \"+l.remote));\n                        // trouble-shooting probe for #591\n                        if(e.getErrorMessage().getErrorCode()== SVNErrorCode.WC_NOT_LOCKED) {\n                            listener.getLogger().println(\"Polled jobs are \"+ SCMTrigger.DESCRIPTOR.getItemsBeingPolled());\n                        }\n                        return null;\n                    }\n                }\n            } else {\n                Util.deleteContentsRecursive(ws);\n\n\t                for (final ModuleLocation l : locations) {\n                    try {\n\t                        final SVNURL url = SVNURL.parseURIEncoded(l.remote);\n                        listener.getLogger().println(\"Checking out \"+url);\n\n                        svnuc.setEventHandler(new SubversionUpdateEventHandler(listener, externals, l.local));\n                        svnuc.doCheckout(url, new File(ws, l.local).getCanonicalFile(), SVNRevision.HEAD, revision, true);\n\n\t                    } catch (final SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to check out \"+l.remote));\n                        return null;\n                    }\n                }\n            }\n            return externals;\n            } finally {\n            \tmanager.dispose();\n            }\n        }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Gets the SVN metadata for the given local workspace.\n     *\n     * @param workspace\n     *      The target to run \"svn info\".\n     */\n    private static SVNInfo parseSvnInfo(File workspace, ISVNAuthenticationProvider authProvider) throws SVNException {\n        SVNWCClient svnWc = createSvnClientManager(authProvider).getWCClient();\n        return svnWc.doInfo(workspace,SVNRevision.WORKING);\n    }","id":84334,"modified_method":"/**\n     * Gets the SVN metadata for the given local workspace.\n     *\n     * @param workspace\n     *      The target to run \"svn info\".\n     */\n    private static SVNInfo parseSvnInfo(File workspace, ISVNAuthenticationProvider authProvider) throws SVNException {\n        final SVNClientManager manager = createSvnClientManager(authProvider);\n        try {\n        \tfinal SVNWCClient svnWc = manager.getWCClient();\n        return svnWc.doInfo(workspace,SVNRevision.WORKING);\n        } finally {\n        \tmanager.dispose();\n        }\n    }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Map<String,SvnInfo> invoke(File ws, VirtualChannel channel) throws IOException {\n            Map<String/*module name*/,SvnInfo> revisions = new HashMap<String,SvnInfo>();\n\n            SVNWCClient svnWc = createSvnClientManager(authProvider).getWCClient();\n            // invoke the \"svn info\"\n            for( ModuleLocation module : locations ) {\n                try {\n                    SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws,module.local), SVNRevision.WORKING));\n                    revisions.put(info.url,info);\n                } catch (SVNException e) {\n                    e.printStackTrace(listener.error(\"Failed to parse svn info for \"+module.remote));\n                }\n            }\n            for(String local : externals){\n                try {\n                    SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws, local),SVNRevision.WORKING));\n                    revisions.put(info.url,info);\n                } catch (SVNException e) {\n                    e.printStackTrace(listener.error(\"Failed to parse svn info for external \"+local));\n                }\n\n            }\n\n            return revisions;\n        }","id":84335,"modified_method":"public Map<String,SvnInfo> invoke(File ws, VirtualChannel channel) throws IOException {\n            Map<String/*module name*/,SvnInfo> revisions = new HashMap<String,SvnInfo>();\n\n            final SVNClientManager manager = createSvnClientManager(authProvider);\n            try {\n\t\t\t\tfinal SVNWCClient svnWc = manager.getWCClient();\n            // invoke the \"svn info\"\n            for( ModuleLocation module : locations ) {\n                try {\n                    SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws,module.local), SVNRevision.WORKING));\n                    revisions.put(info.url,info);\n                } catch (SVNException e) {\n                    e.printStackTrace(listener.error(\"Failed to parse svn info for \"+module.remote));\n                }\n            }\n            for(String local : externals){\n                try {\n                    SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws, local),SVNRevision.WORKING));\n                    revisions.put(info.url,info);\n                } catch (SVNException e) {\n                    e.printStackTrace(listener.error(\"Failed to parse svn info for external \"+local));\n                }\n\n            }\n\n            return revisions;\n            } finally {\n            \tmanager.dispose();\n            }\n        }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n        protected void perform(TaskListener listener) {\n            try {\n                SVNClientManager cm = SubversionSCM.createSvnClientManager(SubversionSCM.DescriptorImpl.DESCRIPTOR.createAuthenticationProvider());\n\n                for (Entry<SvnInfo, String> e : tagSet.entrySet()) {\n                    PrintStream logger = listener.getLogger();\n                    logger.println(\"Tagging \"+e.getKey()+\" to \"+e.getValue());\n\n                    try {\n                        SVNURL src = SVNURL.parseURIDecoded(e.getKey().url);\n                        SVNURL dst = SVNURL.parseURIDecoded(e.getValue());\n\n                        SVNCopyClient svncc = cm.getCopyClient();\n                        svncc.doCopy(src, SVNRevision.create(e.getKey().revision), dst, false, true, \"Tagged from \"+build );\n                    } catch (SVNException x) {\n                        x.printStackTrace(listener.error(\"Failed to tag\"));\n                        return;\n                    }\n                }\n\n                // completed successfully\n                for (Entry<SvnInfo,String> e : tagSet.entrySet())\n                    SubversionTagAction.this.tags.get(e.getKey()).add(e.getValue());\n                build.save();\n                workerThread = null;\n           } catch (Throwable e) {\n               e.printStackTrace(listener.fatalError(e.getMessage()));\n           }\n        }","id":84336,"modified_method":"@Override\n        protected void perform(TaskListener listener) {\n            try {\n                final SVNClientManager cm = SubversionSCM.createSvnClientManager(SubversionSCM.DescriptorImpl.DESCRIPTOR.createAuthenticationProvider());\n                try {\n                for (Entry<SvnInfo, String> e : tagSet.entrySet()) {\n                    PrintStream logger = listener.getLogger();\n                    logger.println(\"Tagging \"+e.getKey()+\" to \"+e.getValue());\n\n                    try {\n                        SVNURL src = SVNURL.parseURIDecoded(e.getKey().url);\n                        SVNURL dst = SVNURL.parseURIDecoded(e.getValue());\n\n                        SVNCopyClient svncc = cm.getCopyClient();\n                        svncc.doCopy(src, SVNRevision.create(e.getKey().revision), dst, false, true, \"Tagged from \"+build );\n                    } catch (SVNException x) {\n                        x.printStackTrace(listener.error(\"Failed to tag\"));\n                        return;\n                    }\n                }\n\n                // completed successfully\n                for (Entry<SvnInfo,String> e : tagSet.entrySet())\n                    SubversionTagAction.this.tags.get(e.getKey()).add(e.getValue());\n                build.save();\n                workerThread = null;\n                } finally {\n                \tcm.dispose();\n                }\n           } catch (Throwable e) {\n               e.printStackTrace(listener.fatalError(e.getMessage()));\n           }\n        }","commit_id":"5f776d402e6d4297b0fa09e2e4b710828eb06b0e","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected XStream createXStream(ClassResolver resolver) {\n        if (xstreamDriver != null) {\n            xstream = new XStream(xstreamDriver);\n        } else {\n            xstream = new XStream();\n        }\n\n        try {\n            if (this.implicitCollections != null) {\n                for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.aliases != null) {\n                for (Entry<String, String> entry : this.aliases.entrySet()) {\n                    xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                    // It can turn the auto-detection mode off\n                    xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                }\n            }\n\n            if (this.omitFields != null) {\n                for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.converters != null) {\n                for (String name : this.converters) {\n                    Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                    Converter converter;\n\n                    Constructor<Converter> con = null;\n                    try {\n                        con = converterClass.getDeclaredConstructor(new Class[] {XStream.class});\n                    } catch (Exception e) {\n                         //swallow as we null check in a moment.\n                    }\n                    if (con != null) {\n                        converter = con.newInstance(xstream);\n                    } else {\n                        converter = converterClass.newInstance();\n                        try { \n                            Method method = converterClass.getMethod(\"setXStream\", new Class[] {XStream.class});\n                            if (method != null) {\n                                ObjectHelper.invokeMethod(method, converter, xstream);\n                            }\n                        } catch (Throwable e) {\n                            // swallow, as it just means the user never add an XStream setter, which is optional\n                        }\n                    }\n\n                    xstream.registerConverter(converter);\n                }\n                \n                if (mode != null) {\n                    xstream.setMode(getModeFromString(mode));\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to build XStream instance\", e);\n        }\n\n        return xstream;\n    }","id":84337,"modified_method":"protected XStream createXStream(ClassResolver resolver) {\n        if (xstreamDriver != null) {\n            xstream = new XStream(xstreamDriver);\n        } else {\n            xstream = new XStream();\n        }\n\n        if (mode != null) {\n            xstream.setMode(getModeFromString(mode));\n        }\n\n        try {\n            if (this.implicitCollections != null) {\n                for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.aliases != null) {\n                for (Entry<String, String> entry : this.aliases.entrySet()) {\n                    xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                    // It can turn the auto-detection mode off\n                    xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                }\n            }\n\n            if (this.omitFields != null) {\n                for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.converters != null) {\n                for (String name : this.converters) {\n                    Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                    Converter converter;\n\n                    Constructor<Converter> con = null;\n                    try {\n                        con = converterClass.getDeclaredConstructor(new Class[]{XStream.class});\n                    } catch (Exception e) {\n                        //swallow as we null check in a moment.\n                    }\n                    if (con != null) {\n                        converter = con.newInstance(xstream);\n                    } else {\n                        converter = converterClass.newInstance();\n                        try {\n                            Method method = converterClass.getMethod(\"setXStream\", new Class[]{XStream.class});\n                            if (method != null) {\n                                ObjectHelper.invokeMethod(method, converter, xstream);\n                            }\n                        } catch (Throwable e) {\n                            // swallow, as it just means the user never add an XStream setter, which is optional\n                        }\n                    }\n\n                    xstream.registerConverter(converter);\n                }\n            }\n                \n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to build XStream instance\", e);\n        }\n\n        return xstream;\n    }","commit_id":"64352d3449f828f914ae34b6d140254fc05f7512","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected XStream createXStream(ClassResolver resolver) {\n        XStream xs = super.createXStream(resolver);\n        xs.setMode(XStream.NO_REFERENCES);\n        return xs;\n    }","id":84338,"modified_method":"@Override\n    protected XStream createXStream(ClassResolver resolver) {\n        XStream xs = super.createXStream(resolver);\n        if (getMode() != null) {\n            xs.setMode(getModeFromString(getMode()));\n        } else {\n            xs.setMode(XStream.NO_REFERENCES);\n        }\n        return xs;\n    }","commit_id":"64352d3449f828f914ae34b6d140254fc05f7512","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void unbind(String name) {\n        ServiceController<?> service = container.getService(ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(name));\n        if (service != null)\n            service.setMode(ServiceController.Mode.REMOVE);\n    }","id":84339,"modified_method":"@Override\n    public void unbind(String name) {\n        if (name == null || name.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot unbind null or empty jndi name\");\n        }\n        final JndiBinding jndiBinding = JndiBinding.parse(name);\n        if (jndiBinding == null) {\n            throw new IllegalArgumentException(\"Cannot unbind \" + name + \" since it belongs to a unknown/unsupported jndi name context\");\n        }\n        ServiceController<?> bindingService = container.getService(jndiBinding.jndiContextServiceName.append(jndiBinding.relativeJndiName));\n        if (bindingService == null) {\n            logger.debug(\"Cannot unbind \" + name + \" since no binding exists with that name\");\n            return;\n        }\n        // remove the binding service\n        bindingService.setMode(ServiceController.Mode.REMOVE);\n    }","commit_id":"e6d896aa3ebe112d072304dfa610b80c007f1a5c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public boolean bind(String name, Object obj) {\n        final BinderService binderService = new BinderService(name);\n        container.addService(ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(name), binderService)\n                 .addDependency(ContextNames.JAVA_CONTEXT_SERVICE_NAME, NamingStore.class, binderService.getNamingStoreInjector())\n                 .addInjection(binderService.getManagedObjectInjector(), new ValueManagedReferenceFactory(Values.immediateValue(obj)))\n                 .setInitialMode(ServiceController.Mode.ACTIVE)\n                 .install();\n\n        return true;\n    }","id":84340,"modified_method":"@Override\n    public boolean bind(String name, Object obj) {\n        if (name == null || name.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot bind a null or empty string as jndi name\");\n        }\n        if (name.equals(\"java:jboss/\") || name.equals(\"java:comp/\") || name.equals(\"java:module/\")\n                || name.equals(\"java:/app\") || name.equals(\"java:global/\") || name.equals(\"java:/\")) {\n            throw new IllegalArgumentException(\"Missing relative path in (invalid) jndi name: \" + name);\n        }\n        final JndiBinding jndiBinding = JndiBinding.parse(name);\n        if (jndiBinding == null) {\n            throw new IllegalArgumentException(\"Binding to \" + name + \" isn't allowed, since it belongs to a unknown/unsupported jndi name context\");\n        }\n        // create the binding service\n        final BinderService binderService = new BinderService(name);\n        container.addService(jndiBinding.jndiContextServiceName.append(jndiBinding.relativeJndiName), binderService)\n                .addDependency(jndiBinding.jndiContextServiceName, NamingStore.class, binderService.getNamingStoreInjector())\n                .addInjection(binderService.getManagedObjectInjector(), new ValueManagedReferenceFactory(Values.immediateValue(obj)))\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        logger.info(\"Bound messaging object to jndi name \" + jndiBinding);\n        return true;\n    }","commit_id":"e6d896aa3ebe112d072304dfa610b80c007f1a5c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSendMessage() throws JMSException, NamingException {\n        final InitialContext ctx = new InitialContext();\n        final QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup(\"java:/JmsXA\");\n        final QueueConnection connection = factory.createQueueConnection();\n        connection.start();\n        try {\n            final QueueSession session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n            final Queue replyDestination = session.createTemporaryQueue();\n            final QueueReceiver receiver = session.createReceiver(replyDestination);\n            final Message message = session.createTextMessage(\"Test\");\n            message.setJMSReplyTo(replyDestination);\n            final Destination destination = (Destination) ctx.lookup(\"queue/test\");\n            final MessageProducer producer = session.createProducer(destination);\n            producer.send(message);\n            producer.close();\n\n            final Message reply = receiver.receive(1000);\n            assertNotNull(reply);\n            final String result = ((TextMessage) reply).getText();\n            assertEquals(\"replying Test\", result);\n        } finally {\n            //connection.stop();\n        }\n    }","id":84341,"modified_method":"@Test\n    public void testSendMessage() throws JMSException, NamingException {\n        final InitialContext ctx = new InitialContext();\n        final QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup(\"java:/JmsXA\");\n        final QueueConnection connection = factory.createQueueConnection();\n        connection.start();\n        try {\n            final QueueSession session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n            final Queue replyDestination = session.createTemporaryQueue();\n            final QueueReceiver receiver = session.createReceiver(replyDestination);\n            final Message message = session.createTextMessage(\"Test\");\n            message.setJMSReplyTo(replyDestination);\n            final Destination destination = (Destination) ctx.lookup(\"java:jboss/queue/test\");\n            final MessageProducer producer = session.createProducer(destination);\n            producer.send(message);\n            producer.close();\n\n            final Message reply = receiver.receive(1000);\n            assertNotNull(reply);\n            final String result = ((TextMessage) reply).getText();\n            assertEquals(\"replying Test\", result);\n        } finally {\n            //connection.stop();\n        }\n    }","commit_id":"e6d896aa3ebe112d072304dfa610b80c007f1a5c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void createJmsDestinations() {\n        final JMSAdminOperations jmsAdminOperations = new JMSAdminOperations();\n        jmsAdminOperations.createJmsQueue(\"mdbtest/queue\", \"mdbtest/queue\");\n        jmsAdminOperations.createJmsQueue(\"mdbtest/replyQueue\", \"mdbtest/replyQueue\");\n    }","id":84342,"modified_method":"public static void createJmsDestinations() {\n        final JMSAdminOperations jmsAdminOperations = new JMSAdminOperations();\n        jmsAdminOperations.createJmsQueue(\"mdbtest/queue\", \"java:jboss/mdbtest/queue\");\n        jmsAdminOperations.createJmsQueue(\"mdbtest/replyQueue\", \"java:jboss/mdbtest/replyQueue\");\n    }","commit_id":"e6d896aa3ebe112d072304dfa610b80c007f1a5c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void uninstall(final Endpoint endpoint, final DeploymentUnit unit) {\n        final ServiceName serviceName = getServiceName(unit, endpoint.getShortName());\n        WSServices.getContainerRegistry().getRequiredService(serviceName).setMode(Mode.REMOVE);\n    }","id":84343,"modified_method":"public static void uninstall(final Endpoint endpoint, final DeploymentUnit unit) {\n        final ServiceName serviceName = getServiceName(unit, endpoint.getShortName());\n        final ServiceController<?> endpointService = WSServices.getContainerRegistry().getService(serviceName);\n        if (endpointService != null) {\n            endpointService.setMode(Mode.REMOVE);\n        }\n    }","commit_id":"76b0afddb8e65dc3cfb5fb59aea8ba1500963a4b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static MacroHelper forModule(AbstractModule module) {\n    // todo: if descriptor file == null?\n    return forModuleFile(module.getDescriptorFile());\n  }","id":84344,"modified_method":"public static MacroHelper forModule(AbstractModule module) {\n    // todo: if descriptor file == null?\n    IFile file = module.getDescriptorFile();\n    return file == null ? null : forModuleFile(file);\n  }","commit_id":"e4da520549add7734bcfc308aedb69ffe625db11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable<VirtualFile> getUnversionedFilesForModule(Project project, IModule module) {\n    IFile moduleDir = module.getDescriptorFile().getParent();\n    VcsFileStatusProvider statusProvider = project.getComponent(VcsFileStatusProvider.class);\n    return collectUnversionedFiles(statusProvider, VirtualFileUtils.getVirtualFile(moduleDir));\n  }","id":84345,"modified_method":"public static Iterable<VirtualFile> getUnversionedFilesForModule(@NotNull Project project, @NotNull IModule module) {\n    IFile descriptorFile = module.getDescriptorFile();\n    if (descriptorFile == null) {\n      return Sequence.fromIterable(Collections.<VirtualFile>emptyList());\n    }\n    IFile moduleDir = descriptorFile.getParent();\n    VcsFileStatusProvider statusProvider = project.getComponent(VcsFileStatusProvider.class);\n    return collectUnversionedFiles(statusProvider, VirtualFileUtils.getVirtualFile(moduleDir));\n  }","commit_id":"04623a77154d6d2ab2d9aa15318a69974f254265","url":"https://github.com/JetBrains/MPS"},{"original_method":"Generator(Language sourceLanguage, GeneratorDescriptor generatorDescriptor) {\n    mySourceLanguage = sourceLanguage;\n    myGeneratorDescriptor = generatorDescriptor;\n\n    // read modules and models\n    readModulesAndModels();\n  }","id":84346,"modified_method":"Generator(Language sourceLanguage, GeneratorDescriptor generatorDescriptor) {\n    mySourceLanguage = sourceLanguage;\n    myGeneratorDescriptor = generatorDescriptor;\n\n    if (!MPSModuleRepository.getInstance().existsModule(this)) {\n      MPSModuleRepository.getInstance().addModule(this, mySourceLanguage);\n    }\n\n    // read modules and models\n    readModulesAndModels();\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IModule getModule(String namespace, MPSModuleOwner moduleOwner) {\n    IModule module = myNamespaceToLanguageMap.get(namespace);\n    if (module == null) {\n      return null;\n    }\n    Set<MPSModuleOwner> languageOwners = myModuleToOwnersMap.get(module);\n    if (languageOwners.contains(moduleOwner)) {\n      return module;\n    }\n    return null;\n  }","id":84347,"modified_method":"public IModule getModule(String namespace, MPSModuleOwner moduleOwner) {\n    IModule module = myNamespaceToModuleMap.get(namespace);\n    if (module == null) {\n      return null;\n    }\n    Set<MPSModuleOwner> languageOwners = myModuleToOwnersMap.get(module);\n    if (languageOwners.contains(moduleOwner)) {\n      return module;\n    }\n    return null;\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<IModule> getReleasedModulesWhenReleasingOwner(MPSModuleOwner owner) {\n    Set<IModule> modules = new HashSet<IModule>(myFileToModuleMap.values());\n\n    //copying module to owners map\n    Map<IModule, HashSet<MPSModuleOwner>> moduleToOwnerMap = new HashMap<IModule, HashSet<MPSModuleOwner>>();\n    for (IModule md : myModuleToOwnersMap.keySet()) {\n      moduleToOwnerMap.put(md, new HashSet<MPSModuleOwner>(myModuleToOwnersMap.get(md)));\n    }//--copying\n\n    return collectReleasedModules(modules, moduleToOwnerMap, owner);\n  }","id":84348,"modified_method":"public Set<IModule> getReleasedModulesWhenReleasingOwner(MPSModuleOwner owner) {\n    Set<IModule> modules = new HashSet<IModule>(myNamespaceToModuleMap.values());\n\n    //copying module to owners map\n    Map<IModule, HashSet<MPSModuleOwner>> moduleToOwnerMap = new HashMap<IModule, HashSet<MPSModuleOwner>>();\n    for (IModule md : myModuleToOwnersMap.keySet()) {\n      moduleToOwnerMap.put(md, new HashSet<MPSModuleOwner>(myModuleToOwnersMap.get(md)));\n    }//--copying\n\n    return collectReleasedModules(modules, moduleToOwnerMap, owner);\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void removeModule(IModule module) {\n    File descriptorFile = module.getDescriptorFile();\n    myModuleToOwnersMap.remove(module);\n    myNamespaceToLanguageMap.remove(module.getNamespace());\n\n    try {\n      myFileToModuleMap.remove(descriptorFile.getCanonicalPath());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","id":84349,"modified_method":"private void removeModule(IModule module) {\n    File descriptorFile = module.getDescriptorFile();\n    myModuleToOwnersMap.remove(module);\n    myNamespaceToModuleMap.remove(module.getNamespace());\n    if (descriptorFile != null) {\n      try {\n        myFileToModuleMap.remove(descriptorFile.getCanonicalPath());\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IModule getModule(String namespace) {\n    return myNamespaceToLanguageMap.get(namespace);\n  }","id":84350,"modified_method":"public IModule getModule(String namespace) {\n    return myNamespaceToModuleMap.get(namespace);\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void invalidateLanguagesCaches() {\n    for (IModule module : myFileToModuleMap.values()) {\n      if (module instanceof Language) ((Language) module).invalidateCaches();\n    }\n  }","id":84351,"modified_method":"public void invalidateLanguagesCaches() {\n    for (IModule module : myNamespaceToModuleMap.values()) {\n      if (module instanceof Language) ((Language) module).invalidateCaches();\n    }\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void unRegisterModules(MPSModuleOwner owner) {\n    for (String fileName : myFileToModuleMap.keySet()) {\n      IModule module = myFileToModuleMap.get(fileName);\n      Set owners = myModuleToOwnersMap.get(module);\n      if (owners != null) {\n        owners.remove(owner);\n      }\n    }\n\n    fireRepositoryChanged();\n  }","id":84352,"modified_method":"public void unRegisterModules(MPSModuleOwner owner) {\n    for (IModule module : myNamespaceToModuleMap.values()) {\n      Set owners = myModuleToOwnersMap.get(module);\n      if (owners != null) {\n        owners.remove(owner);\n      }\n    }\n\n    fireRepositoryChanged();\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addModule(IModule module, MPSModuleOwner owner) {\n    if (myNamespaceToLanguageMap.containsKey(module.getNamespace())) {\n      throw new RuntimeException(\"Couldn't add language \\\"\" + module.getNamespace() + \"\\\" : this language is already registered\");\n    }\n    try {\n      myFileToModuleMap.put(module.getDescriptorFile().getCanonicalPath(), module);\n      myNamespaceToLanguageMap.put(module.getNamespace(), module);\n      Set<MPSModuleOwner> owners = new HashSet<MPSModuleOwner>();\n      owners.add(owner);\n      myModuleToOwnersMap.put(module, owners);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Failed to add language \\\"\" + module.getNamespace() + \"\\\"\", e);\n    }\n  }","id":84353,"modified_method":"public void addModule(IModule module, MPSModuleOwner owner) {\n    if (existsModule(module)) {\n      throw new RuntimeException(\"Couldn't add module \\\"\" + module.getNamespace() + \"\\\" : this module is already registered\");\n    }\n    try {\n      File descriptorFile = module.getDescriptorFile();\n      if (descriptorFile != null) {\n        myFileToModuleMap.put(descriptorFile.getCanonicalPath(), module);\n      }\n      myNamespaceToModuleMap.put(module.getNamespace(), module);\n      Set<MPSModuleOwner> owners = new HashSet<MPSModuleOwner>();\n      owners.add(owner);\n      myModuleToOwnersMap.put(module, owners);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Failed to add module \\\"\" + module.getNamespace() + \"\\\"\", e);\n    }\n  }","commit_id":"f766ad56542244456385d58ebe1224de8213d185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable<VirtualFile> getUnversionedFilesForModule(Project project, IModule module) {\n    IFile moduleDir = module.getDescriptorFile().getParent();\n    VcsFileStatusProvider statusProvider = project.getComponent(VcsFileStatusProvider.class);\n    return collectUnversionedFiles(statusProvider, VirtualFileUtils.getVirtualFile(moduleDir));\n  }","id":84354,"modified_method":"public static Iterable<VirtualFile> getUnversionedFilesForModule(@NotNull Project project, @NotNull IModule module) {\n    IFile descriptorFile = module.getDescriptorFile();\n    if (descriptorFile == null) {\n      return Sequence.fromIterable(Collections.<VirtualFile>emptyList());\n    }\n    IFile moduleDir = descriptorFile.getParent();\n    VcsFileStatusProvider statusProvider = project.getComponent(VcsFileStatusProvider.class);\n    return collectUnversionedFiles(statusProvider, VirtualFileUtils.getVirtualFile(moduleDir));\n  }","commit_id":"27787a7f4bdcd2c9a30183fef61f5a47d2cad181","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void updatePresentationInternal() {\n    if (!myFile.exists()) {\n      removeFromParent();\n      return;\n    }\n    setText(myFile.getName());\n    if (myShowFullPath) {\n      setAdditionalText(myFile.getPresentableUrl());\n    }\n    setNodeIdentifier(myFile.getPath() != null ? myFile.getPath() : \"\");\n    setColor(myProvider.getFileStatus(myFile).getColor());\n  }","id":84355,"modified_method":"private void updatePresentationInternal() {\n    if (!myFile.exists()) {\n      removeFromParent();\n      return;\n    }\n    setText(myFile.getName());\n    if (myShowFullPath) {\n      setAdditionalText(myFile.getPresentableUrl());\n    }\n    setNodeIdentifier(myFile.getPath());\n    setColor(myProvider.getFileStatus(myFile).getColor());\n  }","commit_id":"4dd4ce2f1baa6f64879d46d15f36891aa49260ee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProjectTreeNode(Project project) {\n    super(project, project.getBaseDir());\n    myProject = project;\n\n    List<ModuleTreeNode> moduleNodes = new LinkedList<ModuleTreeNode>();\n    jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);\n    if (mpsProject != null) {\n      for (SModule m : mpsProject.getModules()) {\n        if (m instanceof AbstractModule) {\n          if (((AbstractModule) m).getDescriptorFile().exists()) {\n            moduleNodes.add(new ModuleTreeNode(project, (AbstractModule) m));\n          }\n        }\n      }\n    }\n\n    Collections.sort(moduleNodes, new ModuleTreeNodeComparator());\n\n    MyNamespaceTreeBuilder builder = new MyNamespaceTreeBuilder();\n    for (ModuleTreeNode mtn : moduleNodes) {\n      builder.addNode(mtn);\n    }\n    builder.fillNode(this);\n\n    VirtualFile baseDir = project.getBaseDir();\n    if (baseDir != null) {\n      VirtualFile[] files = baseDir.getChildren();\n      for (VirtualFile f : files) {\n        if (!f.isDirectory()) {\n          add(new FileTreeNode(project, f));\n        }\n      }\n    }\n  }","id":84356,"modified_method":"public ProjectTreeNode(Project project) {\n    super(project, project.getBaseDir());\n    myProject = project;\n\n    List<ModuleTreeNode> moduleNodes = new LinkedList<ModuleTreeNode>();\n    jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);\n    if (mpsProject != null) {\n      for (SModule m : mpsProject.getModules()) {\n        if (!(m instanceof AbstractModule)) {\n          continue;\n        }\n        IFile moduleFile = ((AbstractModule) m).getDescriptorFile();\n        if (moduleFile != null && moduleFile.exists()) {\n          moduleNodes.add(new ModuleTreeNode(project, (AbstractModule) m));\n        }\n      }\n    }\n\n    Collections.sort(moduleNodes, new ModuleTreeNodeComparator());\n\n    MyNamespaceTreeBuilder builder = new MyNamespaceTreeBuilder();\n    for (ModuleTreeNode mtn : moduleNodes) {\n      builder.addNode(mtn);\n    }\n    builder.fillNode(this);\n\n    VirtualFile baseDir = project.getBaseDir();\n    if (baseDir != null) {\n      VirtualFile[] files = baseDir.getChildren();\n      for (VirtualFile f : files) {\n        if (!f.isDirectory()) {\n          add(new FileTreeNode(project, f));\n        }\n      }\n    }\n  }","commit_id":"4dd4ce2f1baa6f64879d46d15f36891aa49260ee","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected final SessionPoolManager getPoolManager()\n            throws RepositoryException {\n        if (this.poolManager == null) {\n            Dictionary properties = this.componentContext.getProperties();\n            int maxActiveSessions = this.getIntProperty(properties,\n                PARAM_MAX_ACTIVE_SESSIONS);\n            int maxIdleSessions = this.getIntProperty(properties,\n                PARAM_MAX_IDLE_SESSIONS);\n            int maxActiveSessionsWait = this.getIntProperty(properties,\n                PARAM_MAX_ACTIVE_SESSIONS_WAIT);\n\n            this.poolManager = new SessionPoolManager(this.getDelegatee(),\n                maxActiveSessions, maxActiveSessionsWait, maxIdleSessions);\n        }\n\n        return this.poolManager;\n    }","id":84357,"modified_method":"protected final SessionPoolManager getPoolManager()\n            throws RepositoryException {\n        if (this.poolManager == null) {\n            Dictionary properties = this.componentContext.getProperties();\n            int maxActiveSessions = this.getIntProperty(properties,\n                PARAM_MAX_ACTIVE_SESSIONS);\n            int maxIdleSessions = this.getIntProperty(properties,\n                PARAM_MAX_IDLE_SESSIONS);\n            int maxActiveSessionsWait = this.getIntProperty(properties,\n                PARAM_MAX_ACTIVE_SESSIONS_WAIT);\n\n            this.poolManager = new SessionPoolManager(this.getDelegatee(), this.loader,\n                maxActiveSessions, maxActiveSessionsWait, maxIdleSessions);\n        }\n\n        return this.poolManager;\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Loads and unloads any components provided by the bundle whose state\n     * changed. If the bundle has been started, the components are loaded. If\n     * the bundle is about to stop, the components are unloaded.\n     *\n     * @param event The <code>BundleEvent<\/code> representing the bundle state\n     *            change.\n     */\n    public void bundleChanged(BundleEvent event) {\n        // TODO: This is synchronous - take care to not block the system !!\n        switch (event.getType()) {\n            case BundleEvent.INSTALLED:\n                // register content and types when the bundle content is\n                // available\n                this.loader.registerBundle(event.getBundle());\n                break;\n\n            case BundleEvent.UNINSTALLED:\n                this.loader.unregisterBundle(event.getBundle());\n                break;\n        }\n    }","id":84358,"modified_method":"/**\n     * Loads and unloads any components provided by the bundle whose state\n     * changed. If the bundle has been started, the components are loaded. If\n     * the bundle is about to stop, the components are unloaded.\n     *\n     * @param event The <code>BundleEvent<\/code> representing the bundle state\n     *            change.\n     */\n    public void bundleChanged(BundleEvent event) {\n        // TODO: This is synchronous - take care to not block the system !!\n        switch (event.getType()) {\n            case BundleEvent.INSTALLED:\n                // register content and types when the bundle content is\n                // available\n                this.loader.registerBundle(event.getBundle());\n                break;\n\n            case BundleEvent.UNINSTALLED:\n                this.loader.unregisterBundle(event.getBundle());\n                break;\n            case BundleEvent.UPDATED:\n                this.loader.updateBundle(event.getBundle());\n        }\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"public void unregisterBundle(Bundle bundle) {\n        if ( this.delayedBundles.contains(bundle) ) {\n            this.delayedBundles.remove(bundle);\n        }\n    }","id":84359,"modified_method":"public void unregisterBundle(Bundle bundle) {\n        this.unregisterNamespaces(bundle);\n        if ( this.delayedBundles.contains(bundle) ) {\n            this.delayedBundles.remove(bundle);\n        }\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"public void registerBundle(Bundle bundle) {\n        if (this.registerBundleInternal(bundle, false)) {\n            // handle delayed bundles, might help now\n            int currentSize = -1;\n            for (int i=this.delayedBundles.size(); i > 0 && currentSize != this.delayedBundles.size() && !this.delayedBundles.isEmpty(); i--) {\n                for (Iterator<Bundle> di=this.delayedBundles.iterator(); di.hasNext(); ) {\n                    Bundle delayed = di.next();\n                    if (this.registerBundleInternal(delayed, true)) {\n                        di.remove();\n                    }\n                }\n                currentSize = this.delayedBundles.size();\n            }\n        } else {\n            // add to delayed bundles\n            this.delayedBundles.add(bundle);\n        }\n    }","id":84360,"modified_method":"public void registerBundle(Bundle bundle) {\n        this.registerNamespaces(bundle);\n        if (this.registerBundleInternal(bundle, false)) {\n            // handle delayed bundles, might help now\n            int currentSize = -1;\n            for (int i=this.delayedBundles.size(); i > 0 && currentSize != this.delayedBundles.size() && !this.delayedBundles.isEmpty(); i--) {\n                for (Iterator<Bundle> di=this.delayedBundles.iterator(); di.hasNext(); ) {\n                    Bundle delayed = di.next();\n                    if (this.registerBundleInternal(delayed, true)) {\n                        di.remove();\n                    }\n                }\n                currentSize = this.delayedBundles.size();\n            }\n        } else {\n            // add to delayed bundles\n            this.delayedBundles.add(bundle);\n        }\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"public Session login(Credentials credentials, String workspace)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // get the session pool for the credentials\n        if (credentials instanceof SimpleCredentials) {\n            SimpleCredentials simple = (SimpleCredentials) credentials;\n            SessionPool pool = this.getPool(simple);\n            if (pool != null) {\n                return pool.acquireSession(simple, workspace);\n            }\n        }\n\n        // direct session, if no pool is available for the credentials\n        return this.getRepository().login(credentials, workspace);\n    }","id":84361,"modified_method":"public Session login(Credentials credentials, String workspace)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        Session result = null;\n\n        // get the session pool for the credentials\n        if (credentials instanceof SimpleCredentials) {\n            SimpleCredentials simple = (SimpleCredentials) credentials;\n            SessionPool pool = this.getPool(simple);\n            if (pool != null) {\n                result = pool.acquireSession(simple, workspace);\n            }\n        }\n\n        if ( result == null ) {\n            // direct session, if no pool is available for the credentials\n            result = this.getRepository().login(credentials, workspace);\n        }\n        if ( result != null && this.namespaceMapper != null ) {\n            this.namespaceMapper.defineNamespacePrefixes(result);\n        }\n        return result;\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"public SessionPoolManager(Repository repository, int maxActiveSessions,\n            int maxActiveSessionsWait, int maxIdleSessions) {\n\n        this.repository = repository;\n        this.sessionPools = new HashMap<String, SessionPool>();\n\n        // default session pool configuration (actual values will be checked\n        // for validity by the SessionPool instances themselves when\n        // configuring)\n        this.poolMaxActiveSessions = maxActiveSessions;\n        this.poolMaxActiveSessionsWait = maxActiveSessionsWait;\n        this.poolMaxIdleSessions = maxIdleSessions;\n    }","id":84362,"modified_method":"public SessionPoolManager(Repository repository,\n            NamespaceMapper mapper,\n            int maxActiveSessions,\n            int maxActiveSessionsWait,\n            int maxIdleSessions) {\n\n        this.repository = repository;\n        this.sessionPools = new HashMap<String, SessionPool>();\n\n        // default session pool configuration (actual values will be checked\n        // for validity by the SessionPool instances themselves when\n        // configuring)\n        this.poolMaxActiveSessions = maxActiveSessions;\n        this.poolMaxActiveSessionsWait = maxActiveSessionsWait;\n        this.poolMaxIdleSessions = maxIdleSessions;\n\n        this.namespaceMapper = mapper;\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"Session impersonate(Session baseSession, Credentials credentials)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // assert base session is live\n        if (!baseSession.isLive()) {\n            throw new RepositoryException(\n                \"Base Session is not alive, cannot impersonate\");\n        }\n\n        if (credentials instanceof SimpleCredentials) {\n            SessionPool pool = this.getPool((SimpleCredentials) credentials);\n            if (pool != null) {\n                return pool.acquireSession(baseSession, credentials);\n            }\n        }\n\n        // no pool available for the credentials, use direct session\n        return baseSession.impersonate(credentials);\n    }","id":84363,"modified_method":"Session impersonate(Session baseSession, Credentials credentials)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n        Session result = null;\n\n        // assert base session is live\n        if (!baseSession.isLive()) {\n            throw new RepositoryException(\n                \"Base Session is not alive, cannot impersonate\");\n        }\n\n        if (credentials instanceof SimpleCredentials) {\n            SessionPool pool = this.getPool((SimpleCredentials) credentials);\n            if (pool != null) {\n                result = pool.acquireSession(baseSession, credentials);\n            }\n        }\n\n        if ( result == null ) {\n            // no pool available for the credentials, use direct session\n            result = baseSession.impersonate(credentials);\n        }\n\n        if ( result != null && this.namespaceMapper != null ) {\n            this.namespaceMapper.defineNamespacePrefixes(result);\n        }\n        return result;\n    }","commit_id":"bfc9108bf3843a7015e43c7698150335bebee5e4","url":"https://github.com/apache/sling"},{"original_method":"public boolean isNewUser()\n   {\n      return isNewUser( credentials.getUsername() );\n   }","id":84364,"modified_method":"public boolean isNewUser()\n   {\n      if (credentials.getAuthType() == AuthenticationType.OPENID && applicationConfiguration.isOpenIdAuth())\n      {\n         return credentialsDAO.findByUser(zanataOpenId.getAuthResult().getAuthenticatedId()) == null;\n      }\n      return isNewUser(credentials.getUsername());\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean isAccountEnabled(String username)\n   {\n      return identityStore.isUserEnabled(username);\n   }","id":84365,"modified_method":"public boolean isAccountEnabled(String username)\n   {\n      if (StringUtils.isEmpty(username))\n      {\n         return false;\n      }\n      return identityStore.isUserEnabled(username);\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * This method indicates where a user needs to be redirected for security purposes. It should be\n    * used to determine where to direct a user when they try to access secured content.\n    *\n    * @return A string containing a hint of where to redirect the user. <br/>\n    *         Valid values are: <br/>\n    *         edit - Redirect the user to the edit profile page.<br/>\n    *         redirect - Allow the user to continue to the page they originally aimed for.<br/>\n    *         home - Redirect the user to the home page.<br/>\n    *         inactive - The user's account is inactive.<br/>\n    *         login - Redirect the user to the login page.\n    */\n   public String getAuthenticationRedirect()\n   {\n      if (identity.getAuthenticationType() == AuthenticationType.KERBEROS)\n      {\n         if (identity.isLoggedIn())\n         {\n            if (isNewUser())\n            {\n               return \"edit\";\n            }\n            else if (userRedirect != null && userRedirect.isRedirect())\n            {\n               return \"redirect\";\n            }\n            return \"home\";\n         }\n         else if (isLoggedInAccountWaitingForActivation())\n         {\n            return \"inactive\";\n         }\n         return \"home\";\n      }\n      else\n      {\n         return \"login\";\n      }\n   }","id":84366,"modified_method":"/**\n    * This method indicates where a user needs to be redirected for security\n    * purposes. It should be used to determine where to direct a user when they\n    * try to access secured content.\n    * \n    * @return A string containing a hint of where to redirect the user. <br/>\n    *         Valid values are: <br/>\n    *         edit - Redirect the user to the edit profile page.<br/>\n    *         redirect - Allow the user to continue to the page they originally\n    *         aimed for.<br/>\n    *         home - Redirect the user to the home page.<br/>\n    *         inactive - The user's account is inactive.<br/>\n    *         login - Redirect the user to the login page.\n    */\n   public String getAuthenticationRedirect()\n   {\n      if (identity.getCredentials().getAuthType() == AuthenticationType.KERBEROS)\n      {\n         if (isAuthenticatedAccountWaitingForActivation())\n         {\n            return \"inactive\";\n         }\n         else if (identity.isLoggedIn())\n         {\n            if (isNewUser())\n            {\n               return \"edit\";\n            }\n            else if (userRedirect != null && userRedirect.isRedirect())\n            {\n               return \"redirect\";\n            }\n            return \"home\";\n         }\n         return \"home\";\n      }\n      else\n      {\n         return \"login\";\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"private boolean isExternalLogin()\n   {\n      return identity.getAuthenticationType() != AuthenticationType.INTERNAL && !identity.isApiRequest();\n   }","id":84367,"modified_method":"private boolean isExternalLogin()\n   {\n      return identity.getCredentials().getAuthType() != AuthenticationType.INTERNAL && !identity.isApiRequest();\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Logs in user with jaas authentication type\n    * \n    * @return\n    */\n   public String jaasLogin()\n   {\n      if (isLoggedInAccountWaitingForActivation())\n      {\n         return \"inactive\";\n      }\n      return login(AuthenticationType.JAAS, credentials.getUsername(), credentials.getPassword());\n   }","id":84368,"modified_method":"/**\n    * Logs in user with jaas authentication type\n    * \n    * @return\n    */\n   public String jaasLogin()\n   {\n      String result = login(AuthenticationType.JAAS, credentials.getUsername(), credentials.getPassword());\n\n      if (isLoggedIn(result))\n      {\n         if (isAuthenticatedAccountWaitingForActivation())\n         {\n            return \"inactive\";\n         }\n      }\n      return result;\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Performs operations after a successful login is completed.\n    * Currently runs the role assignment rules on the logged in account.\n    *\n    * @param authType Authentication type that was used to login.\n    */\n   @Observer(EVENT_LOGIN_COMPLETED)\n   public void onLoginCompleted(AuthenticationType authType)\n   {\n      // Get the authenticated account and credentials\n      HAccount authenticatedAccount = null;\n      HCredentials authenticatedCredentials = null;\n\n      String username = credentials.getUsername();\n\n      if( authType == AuthenticationType.OPENID )\n      {\n         authenticatedCredentials = credentialsDAO.findByUser( zanataOpenId.getAuthResult().getAuthenticatedId() );\n         // on first Open Id login, there might not be any stored credentials\n         if( authenticatedCredentials != null )\n         {\n            authenticatedAccount = authenticatedCredentials.getAccount();\n         }\n      }\n      else\n      {\n         authenticatedCredentials = credentialsDAO.findByUser( username );\n         authenticatedAccount = accountDAO.getByUsername( username );\n      }\n\n      if( authenticatedAccount != null )\n      {\n         userAccountServiceImpl.runRoleAssignmentRules(authenticatedAccount, authenticatedCredentials, authType.name());\n      }\n   }","id":84369,"modified_method":"/**\n    * Performs operations after a successful login is completed. Currently runs\n    * the role assignment rules on the logged in account.\n    * \n    * @param authType Authentication type that was used to login.\n    */\n   @Observer(EVENT_LOGIN_COMPLETED)\n   public void onLoginCompleted(AuthenticationType authType)\n   {\n      identity.setPreAuthenticated(true);\n      if (isExternalLogin() && !isNewUser() && isAccountEnabledAndActivated())\n      {\n         applyAuthentication();\n      }\n      // Get the authenticated account and credentials\n      HAccount authenticatedAccount = null;\n      HCredentials authenticatedCredentials = null;\n\n      String username = credentials.getUsername();\n\n      if (authType == AuthenticationType.OPENID)\n      {\n         authenticatedCredentials = credentialsDAO.findByUser(zanataOpenId.getAuthResult().getAuthenticatedId());\n         // on first Open Id login, there might not be any stored credentials\n         if (authenticatedCredentials != null)\n         {\n            authenticatedAccount = authenticatedCredentials.getAccount();\n         }\n      }\n      else\n      {\n         authenticatedCredentials = credentialsDAO.findByUser(username);\n         authenticatedAccount = accountDAO.getByUsername(username);\n      }\n\n      if (authenticatedAccount != null)\n      {\n         userAccountServiceImpl.runRoleAssignmentRules(authenticatedAccount, authenticatedCredentials, authType.name());\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Logs in user with internal authentication type\n    * \n    * @return\n    */\n   public String internalLogin()\n   {\n      if( isLoggedInAccountWaitingForActivation() )\n      {\n         return \"inactive\";\n      }\n\n      return login(AuthenticationType.INTERNAL, credentials.getUsername(), credentials.getPassword());\n   }","id":84370,"modified_method":"/**\n    * Logs in user with internal authentication type\n    * \n    * @return\n    */\n   public String internalLogin()\n   {\n      if (isAuthenticatedAccountWaitingForActivation())\n      {\n         return \"inactive\";\n      }\n\n      return login(AuthenticationType.INTERNAL, credentials.getUsername(), credentials.getPassword());\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean isLoggedInAccountWaitingForActivation()\n   {\n      boolean userIsAuthenticated = true;\n\n      // For internal Authentication, the user must be re-authenticated without taking into account\n      // the account's enabled flag\n      if( credentials.getAuthType() == AuthenticationType.INTERNAL && applicationConfiguration.isInternalAuth() )\n      {\n         userIsAuthenticated = identityStore.authenticateEvenIfDisabled(credentials.getUsername(), credentials.getPassword());\n      }\n\n      return userIsAuthenticated && !isAccountEnabled(credentials.getUsername()) && !isAccountActivated(credentials.getUsername());\n   }","id":84371,"modified_method":"public boolean isAuthenticatedAccountWaitingForActivation()\n   {\n      boolean userIsAuthenticated = true;\n\n      // For internal Authentication, the user must be re-authenticated without\n      // taking into account\n      // the account's enabled flag\n      if (credentials.getAuthType() == AuthenticationType.INTERNAL && applicationConfiguration.isInternalAuth())\n      {\n         userIsAuthenticated = identityStore.authenticateEvenIfDisabled(credentials.getUsername(), credentials.getPassword());\n      }\n\n      return userIsAuthenticated && !isAccountEnabled(credentials.getUsername()) && !isAccountActivated(credentials.getUsername());\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Logs in with the kerberos authentication type\n    */\n   public void kerberosLogin()\n   {\n      if( credentials.getAuthType() == AuthenticationType.KERBEROS && applicationConfiguration.isKerberosAuth() )\n      {\n         SpNegoIdentity spNegoIdentity = (SpNegoIdentity) Component.getInstance(SpNegoIdentity.class, ScopeType.SESSION);\n         spNegoIdentity.setCredential();\n      }\n   }","id":84372,"modified_method":"/**\n    * Logs in with the kerberos authentication type\n    */\n   public void kerberosLogin()\n   {\n      // credentials.getAuthType() == AuthenticationType.KERBEROS &&\n      if (applicationConfiguration.isKerberosAuth())\n      {\n         SpNegoIdentity spNegoIdentity = (SpNegoIdentity) Component.getInstance(SpNegoIdentity.class, ScopeType.SESSION);\n         spNegoIdentity.authenticate();\n         if (!isAuthenticatedAccountWaitingForActivation())\n         {\n            spNegoIdentity.login();\n         }\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Logs in a user using a specified authentication type.\n    *\n    * @param authenticationType Authentication type to use.\n    * @param username User's name.\n    * @param password User's password. May be null for some authentication types.\n    * @return A String with the result of the operation.\n    */\n   private String login(AuthenticationType authenticationType, String username, String password)\n   {\n      credentials.setUsername(username);\n      credentials.setPassword(password);\n\n      String result = identity.login(authenticationType);\n      if( result != null && result.equals(\"loggedIn\") )\n      {\n         this.onLoginCompleted(authenticationType);\n      }\n\n      return result;\n   }","id":84373,"modified_method":"/**\n    * Logs in a user using a specified authentication type.\n    * \n    * @param authenticationType Authentication type to use.\n    * @param username User's name.\n    * @param password User's password. May be null for some authentication\n    *           types.\n    * @return A String with the result of the operation.\n    */\n   private String login(AuthenticationType authenticationType, String username, String password)\n   {\n      credentials.setUsername(username);\n      credentials.setPassword(password);\n\n      String result = identity.login(authenticationType);\n      if (isLoggedIn(result))\n      {\n         this.onLoginCompleted(authenticationType);\n      }\n\n      return result;\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void init()\n   {\n      if( credentials.getAuthType() == AuthenticationType.OPENID )\n      {\n         // NB: Maybe we can get the authenticated openid from somewhere else\n         account = credentialsDAO.findByUser( zanataOpenId.getId() ).getAccount();\n      }\n      else\n      {\n         account = accountDAO.getByUsername(credentials.getUsername());\n      }\n   }","id":84374,"modified_method":"public void init()\n   {\n      if( credentials.getAuthType() == AuthenticationType.OPENID )\n      {\n         // NB: Maybe we can get the authenticated openid from somewhere else\n         account = credentialsDAO.findByUser(zanataOpenId.getAuthResult().getAuthenticatedId()).getAccount();\n      }\n      else\n      {\n         account = accountDAO.getByUsername(credentials.getUsername());\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Prepares authentication credentials based on the passed parameters.\n    */\n   private void prepareCredentials()\n   {\n      AuthenticationType authType = null;\n      OpenIdProviderType openIdProviderType = null;\n\n      credentials.setUsername( username );\n      credentials.setPassword( password );\n\n      // All others\n      if (authProvider == null)\n      {\n         if (applicationConfiguration.isInternalAuth())\n         {\n            authType = AuthenticationType.INTERNAL;\n         }\n         else if (applicationConfiguration.isJaasAuth())\n         {\n            authType = AuthenticationType.JAAS;\n         }\n      }\n      // Open Id / internal auth\n      else\n      {\n         try\n         {\n            // If it is open Id\n            openIdProviderType = OpenIdProviderType.valueOf(authProvider);\n            authType = AuthenticationType.OPENID;\n         }\n         catch (Exception e)\n         {\n            // If it's not open id, it might be another authentication type\n            openIdProviderType = null;\n            authType = AuthenticationType.valueOf(authProvider);\n         }\n      }\n\n      credentials.setAuthType( authType );\n      credentials.setOpenIdProviderType( openIdProviderType );\n   }","id":84375,"modified_method":"/**\n    * Prepares authentication credentials based on the passed parameters.\n    */\n   private void prepareCredentials()\n   {\n      AuthenticationType authType = null;\n      OpenIdProviderType openIdProviderType = null;\n\n      credentials.setUsername( username );\n      credentials.setPassword( password );\n\n      // All others\n      if (authProvider == null)\n      {\n         if (applicationConfiguration.isInternalAuth())\n         {\n            authType = AuthenticationType.INTERNAL;\n         }\n         else if (applicationConfiguration.isJaasAuth())\n         {\n            authType = AuthenticationType.JAAS;\n         }\n         else if (applicationConfiguration.isKerberosAuth())\n         {\n            authType = AuthenticationType.KERBEROS;\n         }\n      }\n      // Open Id / internal auth\n      else\n      {\n         try\n         {\n            // If it is open Id\n            openIdProviderType = OpenIdProviderType.valueOf(authProvider);\n            authType = AuthenticationType.OPENID;\n         }\n         catch (Exception e)\n         {\n            // If it's not open id, it might be another authentication type\n            openIdProviderType = null;\n            authType = AuthenticationType.valueOf(authProvider);\n         }\n      }\n\n      credentials.setAuthType( authType );\n      credentials.setOpenIdProviderType( openIdProviderType );\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n   public String edit()\n   {\n      this.valid = true;\n      validateEmail(this.email);\n      validateUsername();\n\n      if( !this.isValid() )\n      {\n         return null;\n      }\n\n      if (authenticatedAccount != null)\n      {\n         HPerson person = personDAO.findById(authenticatedAccount.getPerson().getId(), true);\n         person.setName(this.name);\n         personDAO.makePersistent(person);\n         personDAO.flush();\n         authenticatedAccount.getPerson().setName(this.name);\n         log.debug(\"updated successfully\");\n         if (!authenticatedAccount.getPerson().getEmail().equals(this.email))\n         {\n            activationKey = EmailChangeActivationService.generateActivationKey(authenticatedAccount.getPerson().getId().toString(), this.email, new Date());\n            renderer.render(\"/WEB-INF/facelets/email/email_validation.xhtml\");\n            FacesMessages.instance().add(\"You will soon receive an email with a link to activate your email account change.\");\n         }\n\n         return \"updated\";\n      }\n      else\n      {\n\n         String key;\n         if (identity.getAuthenticationType() == AuthenticationType.KERBEROS || identity.getAuthenticationType() == AuthenticationType.JAAS)\n         {\n            key = registerServiceImpl.register(this.username, this.username, this.email);\n         }\n         else\n         {\n            key = registerServiceImpl.register(this.username, zanataOpenId.getAuthResult().getAuthenticatedId(),\n                  AuthenticationType.OPENID, this.name, this.email);\n         }\n         setActivationKey(key);\n         renderer.render(\"/WEB-INF/facelets/email/email_activation.xhtml\");\n         FacesMessages.instance().add(\"You will soon receive an email with a link to activate your account.\");\n\n         return \"home\";\n      }\n   }","id":84376,"modified_method":"@Transactional\n   public String edit()\n   {\n      this.valid = true;\n      validateEmail(this.email);\n      validateUsername();\n\n      if( !this.isValid() )\n      {\n         return null;\n      }\n\n      if (authenticatedAccount != null)\n      {\n         HPerson person = personDAO.findById(authenticatedAccount.getPerson().getId(), true);\n         person.setName(this.name);\n         personDAO.makePersistent(person);\n         personDAO.flush();\n         authenticatedAccount.getPerson().setName(this.name);\n         log.debug(\"updated successfully\");\n         if (!authenticatedAccount.getPerson().getEmail().equals(this.email))\n         {\n            activationKey = EmailChangeActivationService.generateActivationKey(authenticatedAccount.getPerson().getId().toString(), this.email, new Date());\n            renderer.render(\"/WEB-INF/facelets/email/email_validation.xhtml\");\n            FacesMessages.instance().add(\"You will soon receive an email with a link to activate your email account change.\");\n         }\n\n         return \"updated\";\n      }\n      else\n      {\n\n         String key;\n         if (identity.getCredentials().getAuthType() == AuthenticationType.KERBEROS || identity.getCredentials().getAuthType() == AuthenticationType.JAAS)\n         {\n            key = registerServiceImpl.register(this.username, this.username, this.email);\n         }\n         else\n         {\n            key = registerServiceImpl.register(this.username, zanataOpenId.getAuthResult().getAuthenticatedId(),\n                  AuthenticationType.OPENID, this.name, this.email);\n         }\n         setActivationKey(key);\n         renderer.render(\"/WEB-INF/facelets/email/email_activation.xhtml\");\n         FacesMessages.instance().add(\"You will soon receive an email with a link to activate your account.\");\n\n         return \"home\";\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public LoginContext getLoginContext() throws LoginException\n   {\n      if (isApiRequest())\n      {\n         return new LoginContext(JAAS_DEFAULT, getSubject(), getCredentials().createCallbackHandler(), Configuration.instance());\n      }\n      if (getJaasConfigName() != null && !getJaasConfigName().equals(JAAS_DEFAULT))\n      {\n         ApplicationConfiguration appConfig = (ApplicationConfiguration)Component.getInstance(ApplicationConfiguration.class);\n         return new LoginContext(appConfig.getLoginModuleName(this.authenticationType), getSubject(), getCredentials().createCallbackHandler());\n      }\n\n      return new LoginContext(JAAS_DEFAULT, getSubject(), getCredentials().createCallbackHandler(), Configuration.instance());\n   }","id":84377,"modified_method":"@Override\n   public LoginContext getLoginContext() throws LoginException\n   {\n      if (isApiRequest())\n      {\n         return new LoginContext(JAAS_DEFAULT, getSubject(), getCredentials().createCallbackHandler(), Configuration.instance());\n      }\n      if (getJaasConfigName() != null && !getJaasConfigName().equals(JAAS_DEFAULT))\n      {\n         ApplicationConfiguration appConfig = (ApplicationConfiguration)Component.getInstance(ApplicationConfiguration.class);\n         return new LoginContext(appConfig.getLoginModuleName(getCredentials().getAuthType()), getSubject(), getCredentials().createCallbackHandler());\n      }\n\n      return new LoginContext(JAAS_DEFAULT, getSubject(), getCredentials().createCallbackHandler(), Configuration.instance());\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String login( AuthenticationType authType )\n   {\n      this.authenticationType = authType;\n      String result = super.login();\n      if (result != null && result.equals(\"loggedIn\"))\n      {\n         this.preAuthenticated = true;\n      }\n      /*else\n      {\n         this.getCredentials().clear();\n      }*/\n      return result;\n   }","id":84378,"modified_method":"public String login( AuthenticationType authType )\n   {\n      getCredentials().setAuthType(authType);\n      String result = super.login();\n      if (result != null && result.equals(\"loggedIn\"))\n      {\n         this.preAuthenticated = true;\n      }\n      return result;\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void loginImmediate()\n   {\n      if (loginImmediately() && Events.exists())\n      {\n         Events.instance().raiseEvent(Identity.EVENT_POST_AUTHENTICATE, identity);\n         Events.instance().raiseEvent(Identity.EVENT_LOGIN_SUCCESSFUL, AuthenticationType.OPENID);\n         Events.instance().raiseEvent(AuthenticationManager.EVENT_LOGIN_COMPLETED, AuthenticationType.OPENID);\n      }\n   }","id":84379,"modified_method":"private void loginImmediate()\n   {\n      if (loginImmediately() && Events.exists())\n      {\n         Events.instance().raiseEvent(Identity.EVENT_POST_AUTHENTICATE, identity);\n         // Events.instance().raiseEvent(Identity.EVENT_LOGIN_SUCCESSFUL,\n         // AuthenticationType.OPENID);\n         Events.instance().raiseEvent(AuthenticationManager.EVENT_LOGIN_COMPLETED, AuthenticationType.OPENID);\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Default implementation for an authentication callback. This implementations simply authenticates\n    * the user locally.\n    */\n   @Override\n   public void afterOpenIdAuth(OpenIdAuthenticationResult result)\n   {\n      if( result.isAuthenticated() )\n      {\n         HAccount authenticatedAccount = accountDAO.getByCredentialsId( result.getAuthenticatedId() );\n\n         // If the user hasn't been registered, there is no authenticated account\n         if( authenticatedAccount != null && authenticatedAccount.isEnabled() )\n         {\n            credentials.setUsername( authenticatedAccount.getUsername() );\n            Identity.instance().acceptExternallyAuthenticatedPrincipal((new OpenIdPrincipal(result.getAuthenticatedId())));\n            this.loginImmediate();\n         }\n\n      }\n   }","id":84380,"modified_method":"/**\n    * Default implementation for an authentication callback. This implementations simply authenticates\n    * the user locally.\n    */\n   @Override\n   public void afterOpenIdAuth(OpenIdAuthenticationResult result)\n   {\n      if( result.isAuthenticated() )\n      {\n         HAccount authenticatedAccount = accountDAO.getByCredentialsId( result.getAuthenticatedId() );\n\n         identity.setPreAuthenticated(true);\n\n         // If the user hasn't been registered, there is no authenticated account\n         if( authenticatedAccount != null && authenticatedAccount.isEnabled() )\n         {\n            credentials.setUsername(authenticatedAccount.getUsername());\n            Identity.instance().acceptExternallyAuthenticatedPrincipal((new OpenIdPrincipal(result.getAuthenticatedId())));\n            this.loginImmediate();\n         }\n\n      }\n   }","commit_id":"b56bd04ad7b8b27ce60032b055e451e32367e024","url":"https://github.com/zanata/zanata-server"},{"original_method":"public HAccount getByCredentialsId( String credentialsId )\n   {\n      Query query = getSession()\n            .createQuery(\"from HAccount as a where exists ( from HCredentials c where c.account = a and c.user = :id)\");\n      query.setParameter(\"id\", credentialsId);\n      return (HAccount)query.uniqueResult();\n   }","id":84381,"modified_method":"public HAccount getByCredentialsId( String credentialsId )\n   {\n      Query query = getSession()\n            .createQuery(\"select c.account from HCredentials c where c.user = :id\");\n      query.setParameter(\"id\", credentialsId);\n      return (HAccount)query.uniqueResult();\n   }","commit_id":"d5390d6df0a3184c1b8948fb8b4196d1840e452e","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void loginCompleted(AuthenticationType authType, HAccount account, HCredentials credentials)\n   {\n      if(Events.exists())\n      {\n         Events.instance().raiseEvent(EVENT_LOGIN_COMPLETED, authType, account, credentials);\n      }\n   }","id":84382,"modified_method":"/**\n    * Performs operations after a successful login is completed.\n    *\n    * @param authType Authentication type that was used to login.\n    */\n   @Observer(EVENT_LOGIN_COMPLETED)\n   public void onLoginCompleted(AuthenticationType authType)\n   {\n      // Get the authenticated account and credentials\n      HAccount authenticatedAccount;\n      HCredentials authenticatedCredentials;\n\n      String username = credentials.getUsername();\n\n      if( authType == AuthenticationType.OPENID )\n      {\n         authenticatedCredentials = credentialsDAO.findByUser( zanataOpenId.getAuthResult().getAuthenticatedId() );\n         authenticatedAccount = authenticatedCredentials.getAccount();\n      }\n      else\n      {\n         authenticatedCredentials = credentialsDAO.findByUser( username );\n         authenticatedAccount = accountDAO.getByUsername( username );\n      }\n\n      userAccountServiceImpl.runRoleAssignmentRules(authenticatedAccount, authenticatedCredentials, authType.name());\n   }","commit_id":"d5390d6df0a3184c1b8948fb8b4196d1840e452e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Logs in a user using a specified authentication type.\n    *\n    * @param authenticationType Authentication type to use.\n    * @param username User's name.\n    * @param password User's password. May be null for some authentication types.\n    * @return A String with the result of the operation.\n    */\n   public String login( AuthenticationType authenticationType, String username, String password )\n   {\n      credentials.setUsername(username);\n      credentials.setPassword(password);\n\n      return identity.login(authenticationType);\n   }","id":84383,"modified_method":"/**\n    * Logs in a user using a specified authentication type.\n    *\n    * @param authenticationType Authentication type to use.\n    * @param username User's name.\n    * @param password User's password. May be null for some authentication types.\n    * @return A String with the result of the operation.\n    */\n   public String login( AuthenticationType authenticationType, String username, String password )\n   {\n      credentials.setUsername(username);\n      credentials.setPassword(password);\n\n      String result = identity.login(authenticationType);\n      if( result != null && result.equals(\"loggedIn\") )\n      {\n         this.onLoginCompleted(authenticationType);\n      }\n\n      return result;\n   }","commit_id":"d5390d6df0a3184c1b8948fb8b4196d1840e452e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Default implementation for an authentication callback. This implementations simply authenticates\n    * the user locally.\n    */\n   @Override\n   public void afterOpenIdAuth(OpenIdAuthenticationResult result)\n   {\n      if( result.isAuthenticated() )\n      {\n         credentials.setUsername(this.getZanataUsername( result.getAuthenticatedId() ));\n         Identity.instance().acceptExternallyAuthenticatedPrincipal((new OpenIdPrincipal(authResult.getAuthenticatedId())));\n      }\n   }","id":84384,"modified_method":"/**\n    * Default implementation for an authentication callback. This implementations simply authenticates\n    * the user locally.\n    */\n   @Override\n   public void afterOpenIdAuth(OpenIdAuthenticationResult result)\n   {\n      if( result.isAuthenticated() )\n      {\n         HAccount authenticatedAccount = accountDAO.getByCredentialsId( result.getAuthenticatedId() );\n         credentials.setUsername( authenticatedAccount.getUsername() );\n         Identity.instance().acceptExternallyAuthenticatedPrincipal((new OpenIdPrincipal(result.getAuthenticatedId())));\n\n         if( Events.exists() )\n         {\n            Events.instance().raiseEvent(AuthenticationManager.EVENT_LOGIN_COMPLETED, AuthenticationType.OPENID);\n         }\n      }\n   }","commit_id":"d5390d6df0a3184c1b8948fb8b4196d1840e452e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void customNodeTypesAreRegistered() throws RepositoryException {\n        final JackrabbitSession adminSession = createAdminSession();\n        final NodeTypeManager nodeTypeManager = adminSession.getWorkspace().getNodeTypeManager();\n        final NodeType testFolderNodeType = nodeTypeManager.getNodeType(\"test:Folder\");\n        final NodeDefinition[] cnd = testFolderNodeType.getChildNodeDefinitions();\n        final PropertyDefinition[] pd = testFolderNodeType.getPropertyDefinitions();\n        assertEquals(\"More than one child node definition\", 1, cnd.length);\n        assertEquals(\"Incorrect default primary type\", \"test:Folder\", cnd[0].getDefaultPrimaryTypeName());\n        assertEquals(\"More than two property definitions\", 4, pd.length);\n    }","id":84385,"modified_method":"@Test\n    public void customNodeTypesAreRegistered() throws RepositoryException {\n        final JackrabbitSession adminSession = createAdminSession();\n        final NodeTypeManager nodeTypeManager = adminSession.getWorkspace().getNodeTypeManager();\n        final NodeType testFolderNodeType = nodeTypeManager.getNodeType(\"test:Folder\");\n        final NodeDefinition[] cnd = testFolderNodeType.getChildNodeDefinitions();\n        final PropertyDefinition[] pd = testFolderNodeType.getPropertyDefinitions();\n        assertEquals(\"More than one child node definition\", 1, cnd.length);\n        assertEquals(\"Incorrect default primary type\", \"test:Folder\", cnd[0].getDefaultPrimaryTypeName());\n        assertEquals(\"More than two property definitions\", 4, pd.length);\n        adminSession.logout();\n    }","commit_id":"e1f24514a0acf0f0872f89798a453c3eb26ca94b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected Session performCopy(VersionCopySetup setup) throws RepositoryException, IOException {\n        final NodeStore targetNodeStore = new MemoryNodeStore();\n        final RepositorySidegrade sidegrade = new RepositorySidegrade(sourceNodeStore, targetNodeStore);\n        setup.setup(sidegrade.versionCopyConfiguration);\n        sidegrade.copy(null);\n\n        repository = (RepositoryImpl) new Jcr(new Oak(targetNodeStore)).createRepository();\n        return repository.login(AbstractRepositoryUpgradeTest.CREDENTIALS);\n    }","id":84386,"modified_method":"@Override\n    protected Session performCopy(VersionCopySetup setup) throws RepositoryException, IOException {\n        final NodeStore targetNodeStore = new MemoryNodeStore();\n        final RepositorySidegrade sidegrade = new RepositorySidegrade(sourceNodeStore, targetNodeStore);\n        setup.setup(sidegrade.versionCopyConfiguration);\n        sidegrade.copy(null);\n\n        repository = (RepositoryImpl) new Jcr(new Oak(targetNodeStore)).createRepository();\n        Session s = repository.login(AbstractRepositoryUpgradeTest.CREDENTIALS);\n        sessions.add(s);\n        return s;\n    }","commit_id":"e1f24514a0acf0f0872f89798a453c3eb26ca94b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Before\n    @Override\n    public void upgradeRepository() throws Exception {\n        if (sourceNodeStore == null) {\n            sourceNodeStore = new MemoryNodeStore();\n            RepositoryImpl repository = (RepositoryImpl) new Jcr(new Oak(sourceNodeStore)).createRepository();\n            Session session = repository.login(CREDENTIALS);\n            try {\n                createSourceContent(session);\n            } finally {\n                repository.shutdown();\n            }\n        }\n    }","id":84387,"modified_method":"@Before\n    @Override\n    public void upgradeRepository() throws Exception {\n        if (sourceNodeStore == null) {\n            sourceNodeStore = new MemoryNodeStore();\n            RepositoryImpl repository = (RepositoryImpl) new Jcr(new Oak(sourceNodeStore)).createRepository();\n            Session session = repository.login(CREDENTIALS);\n            try {\n                createSourceContent(session);\n            } finally {\n                session.logout();\n                repository.shutdown();\n            }\n        }\n    }","commit_id":"e1f24514a0acf0f0872f89798a453c3eb26ca94b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected Session performCopy(VersionCopySetup setup) throws RepositoryException, IOException {\n        final RepositoryConfig sourceConfig = RepositoryConfig.create(source);\n        final RepositoryContext sourceContext = RepositoryContext.create(sourceConfig);\n        final NodeStore targetNodeStore = new MemoryNodeStore();\n        try {\n            final RepositoryUpgrade upgrade = new RepositoryUpgrade(sourceContext, targetNodeStore);\n            setup.setup(upgrade.versionCopyConfiguration);\n            upgrade.setEarlyShutdown(true);\n            upgrade.copy(null);\n        } finally {\n            sourceContext.getRepository().shutdown();\n        }\n\n        repository = (RepositoryImpl) new Jcr(new Oak(targetNodeStore)).createRepository();\n        return repository.login(AbstractRepositoryUpgradeTest.CREDENTIALS);\n    }","id":84388,"modified_method":"protected Session performCopy(VersionCopySetup setup) throws RepositoryException, IOException {\n        final RepositoryConfig sourceConfig = RepositoryConfig.create(source);\n        final RepositoryContext sourceContext = RepositoryContext.create(sourceConfig);\n        final NodeStore targetNodeStore = new MemoryNodeStore();\n        try {\n            final RepositoryUpgrade upgrade = new RepositoryUpgrade(sourceContext, targetNodeStore);\n            setup.setup(upgrade.versionCopyConfiguration);\n            upgrade.setEarlyShutdown(true);\n            upgrade.copy(null);\n        } finally {\n            sourceContext.getRepository().shutdown();\n        }\n\n        repository = (RepositoryImpl) new Jcr(new Oak(targetNodeStore)).createRepository();\n        Session s = repository.login(AbstractRepositoryUpgradeTest.CREDENTIALS);\n        sessions.add(s);\n        return s;\n    }","commit_id":"e1f24514a0acf0f0872f89798a453c3eb26ca94b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@After\n    public void closeRepository() {\n        repository.shutdown();\n    }","id":84389,"modified_method":"@After\n    public void closeRepository() {\n        for (Session s : sessions) {\n            s.logout();\n        }\n        sessions.clear();\n        repository.shutdown();\n    }","commit_id":"e1f24514a0acf0f0872f89798a453c3eb26ca94b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * This method must be called if overwritten by implementations !!\n     * \n     * @throws nothing, but allow derived classes to throw any Exception\n     */\n    protected void activate(ComponentContext componentContext) throws Exception {\n        this.componentContext = componentContext;\n\n        @SuppressWarnings(\"unchecked\")\n        Dictionary<String, Object> properties = componentContext.getProperties();\n\n        // ensure the default workspace is not null and not empty\n        this.defaultWorkspace = this.getProperty(properties,\n            PROPERTY_DEFAULT_WORKSPACE, null);\n        if (this.defaultWorkspace != null\n            && this.defaultWorkspace.length() == 0) {\n            this.defaultWorkspace = null;\n        }\n\n        this.anonUser = this.getProperty(properties, PROPERTY_ANONYMOUS_USER,\n            DEFAULT_ANONYMOUS_USER);\n        this.anonPass = this.getProperty(properties, PROPERTY_ANONYMOUS_PASS,\n            DEFAULT_ANONYMOUS_PASS).toCharArray();\n\n        this.adminUser = this.getProperty(properties, PROPERTY_ADMIN_USER,\n            DEFAULT_ADMIN_USER);\n        this.adminPass = this.getProperty(properties, PROPERTY_ADMIN_PASS,\n            DEFAULT_ADMIN_PASS).toCharArray();\n\n        setPollTimeActive(getIntProperty(properties, PROPERTY_POLL_ACTIVE));\n        setPollTimeInActive(getIntProperty(properties, PROPERTY_POLL_INACTIVE));\n\n        componentContext.getBundleContext().addBundleListener(this);\n\n        // immediately try to start the repository while activating\n        // this component instance\n        try {\n            startRepository();\n        } catch (Throwable t) {\n            log(LogService.LOG_WARNING,\n                \"activate: Unexpected problem starting repository\", t);\n        }\n\n        // launch the background repository checker now\n        startRepositoryPinger();\n    }","id":84390,"modified_method":"/**\n     * This method must be called if overwritten by implementations !!\n     * \n     * @throws nothing, but allow derived classes to throw any Exception\n     */\n    protected void activate(ComponentContext componentContext) throws Exception {\n        this.componentContext = componentContext;\n\n        @SuppressWarnings(\"unchecked\")\n        Dictionary<String, Object> properties = componentContext.getProperties();\n\n        setDefaultWorkspace(this.getProperty(properties,\n            PROPERTY_DEFAULT_WORKSPACE, null));\n        this.anonUser = this.getProperty(properties, PROPERTY_ANONYMOUS_USER,\n            DEFAULT_ANONYMOUS_USER);\n        this.anonPass = this.getProperty(properties, PROPERTY_ANONYMOUS_PASS,\n            DEFAULT_ANONYMOUS_PASS).toCharArray();\n\n        this.adminUser = this.getProperty(properties, PROPERTY_ADMIN_USER,\n            DEFAULT_ADMIN_USER);\n        this.adminPass = this.getProperty(properties, PROPERTY_ADMIN_PASS,\n            DEFAULT_ADMIN_PASS).toCharArray();\n\n        setPollTimeActive(getIntProperty(properties, PROPERTY_POLL_ACTIVE));\n        setPollTimeInActive(getIntProperty(properties, PROPERTY_POLL_INACTIVE));\n\n        componentContext.getBundleContext().addBundleListener(this);\n\n        // immediately try to start the repository while activating\n        // this component instance\n        try {\n            startRepository();\n        } catch (Throwable t) {\n            log(LogService.LOG_WARNING,\n                \"activate: Unexpected problem starting repository\", t);\n        }\n\n        // launch the background repository checker now\n        startRepositoryPinger();\n    }","commit_id":"08b6cf240ab4e7414688d70cc308b2e150d67a89","url":"https://github.com/apache/sling"},{"original_method":"public Session login(Credentials credentials, String workspace)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // if already stopped, don't retrieve a session\n        if (this.componentContext == null || this.getRepository() == null) {\n            throw new RepositoryException(\"Sling Repository not ready\");\n        }\n\n        if (credentials == null) {\n            credentials = new SimpleCredentials(this.anonUser, this.anonPass);\n        }\n\n        // check the workspace\n        if (workspace == null) {\n            workspace = this.getDefaultWorkspace();\n        }\n\n        try {\n            log(LogService.LOG_DEBUG, \"login: Logging in to workspace '\"\n                + workspace + \"'\");\n            return this.getPoolManager().login(credentials, workspace);\n        } catch (NoSuchWorkspaceException nswe) {\n            // if the desired workspace is the default workspace, try to create\n            // (but not if using the repository-supplied default workspace)\n            if (workspace != null\n                && workspace.equals(this.getDefaultWorkspace())\n                && this.createWorkspace(workspace)) {\n                return this.getPoolManager().login(credentials, workspace);\n            }\n\n            // otherwise (any workspace) or if workspace creation fails\n            // just forward the original exception\n            throw nswe;\n        }\n    }","id":84391,"modified_method":"public Session login(Credentials credentials, String workspace)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // if already stopped, don't retrieve a session\n        if (this.componentContext == null || this.getRepository() == null) {\n            throw new RepositoryException(\"Sling Repository not ready\");\n        }\n\n        if (credentials == null) {\n            credentials = new SimpleCredentials(this.anonUser, this.anonPass);\n        }\n\n        // check the workspace\n        if (workspace == null) {\n            workspace = this.getDefaultWorkspace();\n        }\n\n        try {\n            log(LogService.LOG_DEBUG, \"login: Logging in to workspace '\"\n                + workspace + \"'\");\n            Session session = getPoolManager().login(credentials, workspace);\n\n            // if the defualt workspace is null, acquire a session from the pool\n            // and use the workspace used as the new default workspace\n            if (workspace == null) {\n                String defaultWorkspace = session.getWorkspace().getName();\n                log(LogService.LOG_DEBUG, \"login: Using \" + defaultWorkspace\n                    + \" as the default workspace instead of 'null'\");\n                setDefaultWorkspace(defaultWorkspace);\n            }\n\n            return session;\n\n        } catch (NoSuchWorkspaceException nswe) {\n            // if the desired workspace is the default workspace, try to create\n            // (but not if using the repository-supplied default workspace)\n            if (workspace != null\n                && workspace.equals(this.getDefaultWorkspace())\n                && this.createWorkspace(workspace)) {\n                return this.getPoolManager().login(credentials, workspace);\n            }\n\n            // otherwise (any workspace) or if workspace creation fails\n            // just forward the original exception\n            throw nswe;\n        }\n    }","commit_id":"08b6cf240ab4e7414688d70cc308b2e150d67a89","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the default workspace, which may be <code>null<\/code> meaning\n     * to use the repository provided default workspace. Declared final to make\n     * sure the SLING-256 rule is enforced.\n     */\n    public final String getDefaultWorkspace() {\n        if (defaultWorkspace == null || defaultWorkspace.trim().length() == 0) {\n            // SLING-256\n            return null;\n        }\n        return this.defaultWorkspace;\n    }","id":84392,"modified_method":"/**\n     * Returns the default workspace, which may be <code>null<\/code> meaning\n     * to use the repository provided default workspace. Declared final to make\n     * sure the SLING-256 rule is enforced.\n     */\n    public final String getDefaultWorkspace() {\n        return defaultWorkspace;\n    }","commit_id":"08b6cf240ab4e7414688d70cc308b2e150d67a89","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public SNodePointer getGroup(BreakpointNodeData breakpointNodeData) {\n      IBreakpoint breakpoint = breakpointNodeData.getBreakpoint();\n      if (breakpoint instanceof ILocationBreakpoint) {\n        return new SNodePointer(((ILocationBreakpoint) breakpoint).getLocation().getSNode().getContainingRoot());\n      } else {\n        return null;\n      }\n    }","id":84393,"modified_method":"@Override\n    public SNodePointer getGroup(@NotNull BreakpointNodeData breakpointNodeData) {\n      IBreakpoint breakpoint = breakpointNodeData.getBreakpoint();\n      if (breakpoint instanceof ILocationBreakpoint) {\n        SNode node = ((ILocationBreakpoint) breakpoint).getLocation().getSNode();\n        if (node != null) {\n          return new SNodePointer(node.getContainingRoot());\n        }\n      }\n      return null;\n    }","commit_id":"1f263712e82eec38e83be8d6ed333a5ec45926a1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String toString() {\n    StringBuffer output = new StringBuffer();\n\n    if (myRole != null) {\n      output.append(myRole).append(\" : \");\n    }\n\n    if (getSNode() != null) {\n      output.append(getSNode().toString());\n    }\n\n    return output.toString();\n  }","id":84394,"modified_method":"public String toString() {\n    StringBuffer output = new StringBuffer();\n\n    if (myRole != null) {\n      output.append(myRole).append(\" : \");\n    }\n\n    SNode node = getSNode();\n    if (node != null) {\n      String nodeString = node.toString();\n      output.append(nodeString);\n      if (myRole != null) {\n        String matchingText = NodePresentationUtil.matchingText(node);\n        if (!matchingText.equals(nodeString)) {\n          output.append(\" [\").append(matchingText).append(\"]\");\n        }\n      }\n    }\n\n    return output.toString();\n  }","commit_id":"bd8508f10f2c552672ca925bfa1581e52c5da559","url":"https://github.com/JetBrains/MPS"},{"original_method":"public <T> T get(Class<T> cls) {\n    if (cls == SNode.class) return (T) getSelectedNode();\n    if (cls == SModelDescriptor.class) return (T) getSelectedModel();\n    if (cls == List.class) return (T) getSelectedNodes();\n    if (cls == IOperationContext.class) return (T) getContextForSelection();\n    return null;\n  }","id":84395,"modified_method":"public <T> T get(Class<T> cls) {\n    if (cls == SNode.class) return (T) getSelectedNode();\n    if (cls == SModelDescriptor.class) return (T) getSelectedModel();\n    if (cls == List.class) {\n      List result = new ArrayList();\n      result.add(getSelectedModel());\n      return (T) result;\n    }\n    if (cls == IOperationContext.class) return (T) getContextForSelection();\n    return null;\n  }","commit_id":"b1136748bf32218b1eba34854d8beb1cb9456c80","url":"https://github.com/JetBrains/MPS"},{"original_method":"List<SNode> getSelectedNodes() {\n    List<SNode> result = new ArrayList<SNode>();\n    TreePath[] paths = myTree.getSelectionPaths();\n    if (paths == null) return null;\n    for (TreePath path : paths) {\n      MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();\n      if (node instanceof MPSTreeNodeEx) {\n        result.add(((MPSTreeNodeEx) node).getSNode());\n      }\n    }\n    return result;\n  }","id":84396,"modified_method":"List<SNode> getSelectedNodes() {\n    List<SNode> result = new ArrayList<SNode>();\n    TreePath[] paths = myTree.getSelectionPaths();\n    if (paths == null) return null;\n    for (TreePath path : paths) {\n      MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();\n      if (node instanceof MPSTreeNodeEx) {\n        SNode snode = ((MPSTreeNodeEx) node).getSNode();\n        if (snode != null) {\n          result.add(snode);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"b1136748bf32218b1eba34854d8beb1cb9456c80","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void inspect(SNode node) {\n    myInspector.inspectNode(node, getOperationContext());\n    myInspector.getHighlightManager().removeAllChanges(this);\n    myInspector.getHighlightManager().rebuildMessages();\n    //makeChangeBlocks(myInspector, new ArrayList(myChanges));\n  }","id":84397,"modified_method":"public void inspect(SNode node) {\n    myInspector.inspectNode(node, getOperationContext());\n    myInspector.getHighlightManager().removeAllChanges(this);\n    myInspector.getHighlightManager().rebuildMessages();\n    if (myInspector.getHighlightManager().getMessageFor(node) == null) {\n      makeChangeBlocks(myInspector, new ArrayList(myChanges));\n    }\n  }","commit_id":"350c8d8bd1ac9ce205e36a474a3eadffb54a51b5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void makeChangeBlocks() {\n    makeChangeBlocks(this, new ArrayList(myChanges));\n    makeChangeBlocks(myInspector, new ArrayList(myChanges));\n  }","id":84398,"modified_method":"public void makeChangeBlocks() {\n    makeChangeBlocks(this, new ArrayList(myChanges));\n    if (myInspector.getHighlightManager().getMessageFor(myInspector.getEditedNode()) == null) {\n      makeChangeBlocks(myInspector, new ArrayList(myChanges));\n    }\n  }","commit_id":"350c8d8bd1ac9ce205e36a474a3eadffb54a51b5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void hightlight(final List<Change> changes, final boolean isNew, final boolean revertedChanges) {\n    final List<ChangeEditorMessage> resultChanges = new ArrayList<ChangeEditorMessage>();\n    final SModel model = getRootCell().getSNode().getModel();\n\n    final Set<Change> newChanges = getNewChanges(changes);\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n\n      public void run() {\n        for (Change change : changes) {\n\n          if (change instanceof SetReferenceChange) {\n            SetReferenceChange referenceChange = (SetReferenceChange) change;\n\n            ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n            message.setRole(referenceChange.getRole());\n\n            resultChanges.add(message);\n            getHighlightManager().mark(message);\n          }\n\n          if (change instanceof MoveNodeChange || change instanceof ChangeConceptChange) {\n            ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n            resultChanges.add(message);\n            getHighlightManager().mark(message);\n          }\n\n          if (change instanceof NewNodeChange) {\n            if (!isNew) {\n              ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n              resultChanges.add(message);\n              getHighlightManager().mark(message);\n            }\n          }\n\n          if (change instanceof SetPropertyChange) {\n            SetPropertyChange propertyChange = (SetPropertyChange) change;\n            ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n            message.setProperty(propertyChange.getProperty());\n            resultChanges.add(message);\n            getHighlightManager().mark(message);\n          }\n\n          if (change instanceof DeleteNodeChange) {\n            if (isNew) {             \n              ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n              resultChanges.add(message);\n              getHighlightManager().mark(message);\n            }\n          }\n\n        }\n      }\n    });\n    for (ChangeEditorMessage editorMessage : resultChanges) {\n      getInspector().getHighlightManager().mark(editorMessage);\n    }\n    myChanges = new ArrayList<ChangeEditorMessage>(resultChanges);\n  }","id":84399,"modified_method":"public void hightlight(final List<Change> changes, final boolean isNew, final boolean revertedChanges) {\n    final List<ChangeEditorMessage> resultChanges = new ArrayList<ChangeEditorMessage>();\n    SNode sNode = getRootCell().getSNode();\n    if (sNode == null) {\n      return;\n    }\n    final SModel model = sNode.getModel();\n\n    final Set<Change> newChanges = getNewChanges(changes);\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n\n      public void run() {\n        for (Change change : changes) {\n\n          if (change instanceof SetReferenceChange) {\n            SetReferenceChange referenceChange = (SetReferenceChange) change;\n\n            ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n            message.setRole(referenceChange.getRole());\n\n            resultChanges.add(message);\n            getHighlightManager().mark(message);\n          }\n\n          if (change instanceof MoveNodeChange || change instanceof ChangeConceptChange) {\n            ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n            resultChanges.add(message);\n            getHighlightManager().mark(message);\n          }\n\n          if (change instanceof NewNodeChange) {\n            if (!isNew) {\n              ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n              resultChanges.add(message);\n              getHighlightManager().mark(message);\n            }\n          }\n\n          if (change instanceof SetPropertyChange) {\n            SetPropertyChange propertyChange = (SetPropertyChange) change;\n            ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n            message.setProperty(propertyChange.getProperty());\n            resultChanges.add(message);\n            getHighlightManager().mark(message);\n          }\n\n          if (change instanceof DeleteNodeChange) {\n            if (isNew) {             \n              ChangeEditorMessage message = createEditorMessage(change, model, revertedChanges, !newChanges.contains(change));\n              resultChanges.add(message);\n              getHighlightManager().mark(message);\n            }\n          }\n\n        }\n      }\n    });\n    for (ChangeEditorMessage editorMessage : resultChanges) {\n      getInspector().getHighlightManager().mark(editorMessage);\n    }\n    myChanges = new ArrayList<ChangeEditorMessage>(resultChanges);\n  }","commit_id":"350c8d8bd1ac9ce205e36a474a3eadffb54a51b5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void init(final SNode node, Merger merger) {\n    myNode = node;\n    myMerger = merger;\n    final SNode[] change1Node = new SNode[1];\n    final SNode[] resultNode = new SNode[1];\n    final SNode[] change2Node = new SNode[1];\n\n    merger.setPreviewMode(true);\n    merger.rebuldResultModel();\n\n    final SModel resultModel = merger.getResultModel();\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n\n      public void run() {\n        change1Node[0] = myChange1Model.getRootByName(node.getName());\n        resultNode[0] = resultModel.getRootByName(node.getName());\n        change2Node[0] = myChange2Model.getRootByName(node.getName());\n      }\n    });\n\n    myTopComponent = new JPanel(new GridLayout(1, 3));\n    myBottomComponent = new JPanel(new GridLayout(1, 3));\n\n    for (Change conflict : merger.getConflictedChanges()) {\n      conflict.setError(true);      \n    }\n\n    myChange1EditorComponent = addEditor(myContext, change1Node[0], \"\");\n    myResultEditorComponent = addEditor(myContext, resultNode[0], \"\");\n    myChange2EditorComponent = addEditor(myContext, change2Node[0], \"\");\n\n    rebuildChangeBlocks();\n\n    myContainer = new JSplitPane(JSplitPane.VERTICAL_SPLIT, myTopComponent, myBottomComponent);\n    myContainer.setResizeWeight(1);    \n  }","id":84400,"modified_method":"public void init(final SNode node, Merger merger) {\n    myRoot = node;\n    myMerger = merger;\n    final SNode[] change1Node = new SNode[1];\n    final SNode[] resultNode = new SNode[1];\n    final SNode[] change2Node = new SNode[1];\n\n    merger.setPreviewMode(true);\n    merger.rebuldResultModel();\n\n    final SModel resultModel = merger.getResultModel();\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n\n      public void run() {\n        change1Node[0] = myChange1Model.getRootByName(node.getName());\n        resultNode[0] = resultModel.getRootByName(node.getName());\n        change2Node[0] = myChange2Model.getRootByName(node.getName());\n      }\n    });\n\n    myTopComponent = new JPanel(new GridLayout(1, 3));\n    myBottomComponent = new JPanel(new GridLayout(1, 3));\n\n    for (Change conflict : merger.getConflictedChanges()) {\n      conflict.setError(true);\n    }\n\n    myChange1EditorComponent = addEditor(myContext, change1Node[0], \"\");\n    myResultEditorComponent = addEditor(myContext, resultNode[0], \"\");\n    myChange2EditorComponent = addEditor(myContext, change2Node[0], \"\");\n\n    rebuildChangeBlocks();\n\n    JSplitPane modelsPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, myTopComponent, myBottomComponent);\n    modelsPane.setResizeWeight(1);\n    myContainer = new JPanel(new BorderLayout());\n    myContainer.add(modelsPane);\n    myContainer.add(createControlsPanel(), BorderLayout.PAGE_START);\n  }","commit_id":"350c8d8bd1ac9ce205e36a474a3eadffb54a51b5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void rebuildChangeBlocks() {\n    myResultEditorComponent.removeAllChanges();\n    myChange1EditorComponent.removeAllChanges();\n    myChange2EditorComponent.removeAllChanges();\n\n    myMerger.doRebuild(new Runnable() {\n      public void run() {\n      }\n    });\n    \n    myResultModel = myMerger.getResultModel();\n\n    final SNode[] resultNode = new SNode[1];\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n\n      public void run() {\n        resultNode[0] = myResultModel.getRootByName(myNode.getName());\n      }\n    });\n\n    myResultEditorComponent.editNode(resultNode[0], myContext);\n\n    List<Change> myneChange = new ArrayList<Change>(myMerger.getBaseMyneChange());\n    myneChange.removeAll(myMerger.getApplyedChanges());\n    myneChange.removeAll(myMerger.getExcludedChanges());\n    myChange1EditorComponent.hightlight(myneChange, false, false);\n    myChange1EditorComponent.makeChangeBlocks();\n\n    myResultEditorComponent.hightlight(new ArrayList<Change>(myMerger.getUnresolvedChanges()), true, false);\n    myResultEditorComponent.makeChangeBlocks();\n\n    List<Change> repoChange = new ArrayList<Change>(myMerger.getBaseRepoChange());\n    repoChange.removeAll(myMerger.getApplyedChanges());\n    repoChange.removeAll(myMerger.getExcludedChanges());\n    myChange2EditorComponent.hightlight(repoChange, false, false);\n    myChange2EditorComponent.makeChangeBlocks();\n  }","id":84401,"modified_method":"private void rebuildChangeBlocks() {\n    myResultEditorComponent.removeAllChanges();\n    myChange1EditorComponent.removeAllChanges();\n    myChange2EditorComponent.removeAllChanges();\n\n    myMerger.doRebuild(new Runnable() {\n      public void run() {\n      }\n    });\n\n    myResultModel = myMerger.getResultModel();\n\n    final SNode[] resultNode = new SNode[1];\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n\n      public void run() {\n        resultNode[0] = myResultModel.getRootByName(myRoot.getName());\n      }\n    });\n\n    myResultEditorComponent.editNode(resultNode[0], myContext);\n\n    List<Change> myneChange = new ArrayList<Change>(myMerger.getBaseMyneChange());\n    myneChange.removeAll(myMerger.getApplyedChanges());\n    myneChange.removeAll(myMerger.getExcludedChanges());\n    myChange1EditorComponent.hightlight(myneChange, false, false);\n    myChange1EditorComponent.makeChangeBlocks();\n\n    myResultEditorComponent.hightlight(new ArrayList<Change>(myMerger.getUnresolvedChanges()), true, false);\n    myResultEditorComponent.makeChangeBlocks();\n\n    List<Change> repoChange = new ArrayList<Change>(myMerger.getBaseRepoChange());\n    repoChange.removeAll(myMerger.getApplyedChanges());\n    repoChange.removeAll(myMerger.getExcludedChanges());\n    myChange2EditorComponent.hightlight(repoChange, false, false);\n    myChange2EditorComponent.makeChangeBlocks();\n  }","commit_id":"350c8d8bd1ac9ce205e36a474a3eadffb54a51b5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(EditorContext context) {\n    List<SNode> nodeList = new LinkedList<SNode>();\n    EditorComponent editorComponent = context.getNodeEditorComponent();\n    TextBuilder textBuilder = TextRenderUtil.getTextBuilderForSelectedCellsOfEditor(editorComponent);\n\n    NodeRangeSelection nodeRangeSelection = editorComponent.getNodeRangeSelection();\n    if (nodeRangeSelection.isActive()) {\n      nodeList.addAll(nodeRangeSelection.getNodes());\n      LOG.debug(\"Copy \" + nodeList.size() + \" nodes : \");\n      for (SNode aNodeList : nodeList) {\n        LOG.debug(\"    \" + aNodeList.getDebugText());\n      }\n    } else {\n      nodeList.add(editorComponent.getSelectedCell().getSNode());\n      LOG.debug(\"Copy node : \" + nodeList.get(0).getDebugText());\n    }\n    List<SNode> copyNodeList = new ArrayList<SNode>();\n    Map<SNode, Set<SNode>> nodesAndAttributes = new HashMap<SNode, Set<SNode>>();\n    for (SNode node : nodeList) {\n      final SNode parent = node.getParent();\n      if (parent != null && AttributesRolesUtil.isAttributeRole(node.getRole_())) {\n\n        EditorCell selectedCell = editorComponent.getSelectedCell();\n        Condition<EditorCell> condition = new Condition<EditorCell>() {\n          public boolean met(EditorCell object) {\n            SNode selectedNode = object.getSNode();\n            return selectedNode != null &&\n                    selectedNode.getParent() == parent && AttributesRolesUtil.isAttributeRole(selectedNode.getRole_());\n          }\n        };\n\n        Set<SNode> selectedAttributes = new HashSet<SNode>();\n        if (selectedCell instanceof EditorCell_Collection) {\n          EditorCell_Collection selectedCollection = (EditorCell_Collection) selectedCell;\n          for (EditorCell cell : selectedCollection.dfsCells()) {\n            if (condition.met(cell)) {\n              selectedAttributes.add(cell.getSNode());\n            }\n          }\n        } else {\n          if (condition.met(selectedCell)) {\n            selectedAttributes.add(selectedCell.getSNode());\n          }\n        }\n        copyNodeList.add(parent);\n        nodesAndAttributes.put(parent, selectedAttributes);\n      } else {\n        copyNodeList.add(node);\n      }\n    }\n\n    CopyPasteUtil.copyNodesAndTextToClipboard(copyNodeList, nodesAndAttributes, textBuilder.getText());\n  }","id":84402,"modified_method":"public void execute(EditorContext context) {\n    List<SNode> nodeList = new LinkedList<SNode>();\n    EditorComponent editorComponent = context.getNodeEditorComponent();\n    TextBuilder textBuilder = TextRenderUtil.getTextBuilderForSelectedCellsOfEditor(editorComponent);\n\n    NodeRangeSelection nodeRangeSelection = editorComponent.getNodeRangeSelection();\n    if (nodeRangeSelection.isActive()) {\n      nodeList.addAll(nodeRangeSelection.getNodes());\n      LOG.debug(\"Copy \" + nodeList.size() + \" nodes : \");\n      for (SNode aNodeList : nodeList) {\n        LOG.debug(\"    \" + aNodeList.getDebugText());\n      }\n    } else {\n      SNode sNode = editorComponent.getSelectedCell().getSNode();\n      if (sNode != null) {\n        nodeList.add(sNode);\n        LOG.debug(\"Copy node : \" + nodeList.get(0).getDebugText());\n      }\n    }\n    List<SNode> copyNodeList = new ArrayList<SNode>();\n    Map<SNode, Set<SNode>> nodesAndAttributes = new HashMap<SNode, Set<SNode>>();\n    for (SNode node : nodeList) {\n      final SNode parent = node.getParent();\n      if (parent != null && AttributesRolesUtil.isAttributeRole(node.getRole_())) {\n\n        EditorCell selectedCell = editorComponent.getSelectedCell();\n        Condition<EditorCell> condition = new Condition<EditorCell>() {\n          public boolean met(EditorCell object) {\n            SNode selectedNode = object.getSNode();\n            return selectedNode != null &&\n                    selectedNode.getParent() == parent && AttributesRolesUtil.isAttributeRole(selectedNode.getRole_());\n          }\n        };\n\n        Set<SNode> selectedAttributes = new HashSet<SNode>();\n        if (selectedCell instanceof EditorCell_Collection) {\n          EditorCell_Collection selectedCollection = (EditorCell_Collection) selectedCell;\n          for (EditorCell cell : selectedCollection.dfsCells()) {\n            if (condition.met(cell)) {\n              selectedAttributes.add(cell.getSNode());\n            }\n          }\n        } else {\n          if (condition.met(selectedCell)) {\n            selectedAttributes.add(selectedCell.getSNode());\n          }\n        }\n        copyNodeList.add(parent);\n        nodesAndAttributes.put(parent, selectedAttributes);\n      } else {\n        copyNodeList.add(node);\n      }\n    }\n\n    CopyPasteUtil.copyNodesAndTextToClipboard(copyNodeList, nodesAndAttributes, textBuilder.getText());\n  }","commit_id":"b2725f118740fb2f88b2daad1b579dcdaa982efa","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void makeSureLazyLoadingRelationshipsWorksEvenIfOtherIteratorAlsoLoadsInTheSameIteration() throws IOException\n    {\n        String path = \"target/var/lazyloadrels\";\n        FileUtils.deleteRecursively( new File( path ) );\n        GraphDatabaseService graphDB = new EmbeddedGraphDatabase( path );\n        int num_edges = 100;\n        Node hub;\n\n        /* create 256 nodes */\n        Transaction tx = graphDB.beginTx();\n        Node[] nodes = new Node[256];\n        for ( int num_nodes = 0; num_nodes < nodes.length; num_nodes += 1 )\n        {\n            nodes[num_nodes] = graphDB.createNode();\n        }\n        tx.success();\n        tx.finish();\n\n        /* create random outgoing relationships from node 5 */\n        hub = nodes[4];\n        int nextID = 7;\n\n        tx = graphDB.beginTx();\n        for ( int k = 0; k < num_edges; k += 1 )\n        {\n            Node neighbor = graphDB.getNodeById( nextID );\n            nextID += 7;\n            nextID &= 255;\n            if ( nextID == 0 )\n            {\n                nextID = 1;\n            }\n            hub.createRelationshipTo( neighbor, DynamicRelationshipType.withName( \"outtie\" ) );\n        }\n        tx.success();\n        tx.finish();\n\n        tx = graphDB.beginTx();\n        /* create random incoming relationships to node 5 */\n        for ( int k = 0; k < num_edges; k += 1 )\n        {\n            Node neighbor = graphDB.getNodeById( nextID );\n            nextID += 7;\n            nextID &= 255;\n            if ( nextID == 0 )\n            {\n                nextID = 1;\n            }\n            neighbor.createRelationshipTo( hub, DynamicRelationshipType.withName( \"innie\" ) );\n        }\n        tx.success();\n        tx.finish();\n\n        graphDB.shutdown();\n        graphDB = new EmbeddedGraphDatabase( path );\n        hub = graphDB.getNodeById( hub.getId() );\n        int count = 0;\n        for ( @SuppressWarnings( \"unused\" )\n        Relationship r1 : hub.getRelationships() )\n        {\n            for ( @SuppressWarnings( \"unused\" )\n            Relationship r2 : hub.getRelationships() )\n            {\n                count += 1;\n            }\n        }\n        assertEquals( 40000, count );\n\n        count = 0;\n        for ( @SuppressWarnings( \"unused\" )\n        Relationship r1 : hub.getRelationships() )\n        {\n            for ( @SuppressWarnings( \"unused\" )\n            Relationship r2 : hub.getRelationships() )\n            {\n                count += 1;\n            }\n        }\n        assertEquals( 40000, count );\n        graphDB.shutdown();\n    }","id":84403,"modified_method":"@Test\n    public void makeSureLazyLoadingRelationshipsWorksEvenIfOtherIteratorAlsoLoadsInTheSameIteration() throws IOException\n    {\n        int num_edges = 100;\n        Node hub;\n\n        /* create 256 nodes */\n        GraphDatabaseService graphDB = getGraphDb();\n        Node[] nodes = new Node[256];\n        for ( int num_nodes = 0; num_nodes < nodes.length; num_nodes += 1 )\n        {\n            nodes[num_nodes] = graphDB.createNode();\n        }\n        newTransaction();\n\n        /* create random outgoing relationships from node 5 */\n        hub = nodes[4];\n        int nextID = 7;\n\n        DynamicRelationshipType outtie = DynamicRelationshipType.withName( \"outtie\" );\n        DynamicRelationshipType innie = DynamicRelationshipType.withName( \"innie\" );\n        for ( int k = 0; k < num_edges; k += 1 )\n        {\n            Node neighbor = nodes[nextID];\n            nextID += 7;\n            nextID &= 255;\n            if ( nextID == 0 ) nextID = 1;\n            hub.createRelationshipTo( neighbor, outtie );\n        }\n        newTransaction();\n\n        /* create random incoming relationships to node 5 */\n        for ( int k = 0; k < num_edges; k += 1 )\n        {\n            Node neighbor = nodes[nextID];\n            nextID += 7;\n            nextID &= 255;\n            if ( nextID == 0 ) nextID = 1;\n            neighbor.createRelationshipTo( hub, innie );\n        }\n        commit();\n        clearCache();\n        \n        hub = graphDB.getNodeById( hub.getId() );\n        int count = 0;\n        for ( @SuppressWarnings( \"unused\" )\n        Relationship r1 : hub.getRelationships() )\n        {\n            count += count( hub.getRelationships() );\n        }\n        assertEquals( 40000, count );\n\n        count = 0;\n        for ( @SuppressWarnings( \"unused\" )\n        Relationship r1 : hub.getRelationships() )\n        {\n            count += count( hub.getRelationships() );\n        }\n        assertEquals( 40000, count );\n    }","commit_id":"130534605c53ab3d5fad853bc8bb9cfd6f207733","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void doHeapDump( Pair<Long, String> pid, File dir ) throws Exception\n    {\n        String[] cmdarray = new String[] {\"jmap\", \"-dump:file=\" + new File( dir, \"heapdump-\" + pid.other() + \"-\" + System.currentTimeMillis() ).getAbsolutePath(), \"\" + pid.first() };\n        Runtime.getRuntime().exec( cmdarray ).waitFor();\n    }","id":84404,"modified_method":"private static void doHeapDump( Pair<Long, String> pid, File dir ) throws Exception\n    {\n        String[] cmdarray = new String[] {\"jmap\", \"-dump:file=\" + new File( dir, \"heapdump-\" + pid.other() +\n                \"-\" + currentTimeMillis() ).getAbsolutePath(), \"\" + pid.first() };\n        getRuntime().exec( cmdarray ).waitFor();\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void doThreadDump( Pair<Long, String> pid, File outputDirectory ) throws Exception\n    {\n        String[] cmdarray = new String[] {\"jstack\", \"\" + pid.first()};\n        File outputFile = new File( outputDirectory, \"threaddump-\" + pid.other() + \"-\" + System.currentTimeMillis() );\n        Process process = Runtime.getRuntime().exec( cmdarray );\n        writeProcessOutputToFile( process, outputFile );\n        reduceThreadDump( outputFile, new File( outputFile.getParentFile(), outputFile.getName() + \"-reduced\" ) );\n        System.out.println( \"Created thread dump \" + outputFile.getAbsolutePath() );\n    }","id":84405,"modified_method":"public static File doThreadDump( Pair<Long, String> pid, File outputDirectory ) throws Exception\n    {\n        String[] cmdarray = new String[] {\"jstack\", \"\" + pid.first()};\n        File outputFile = new File( outputDirectory, \"threaddump-\" + pid.other() + \"-\" + currentTimeMillis() );\n        Process process = getRuntime().exec( cmdarray );\n        writeProcessOutputToFile( process, outputFile );\n        return outputFile;\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Collection<Pair<Long, String>> getJPids( String containing ) throws IOException, InterruptedException\n    {\n        Process process = Runtime.getRuntime().exec( new String[] { \"jps\", \"-l\" } );\n        BufferedReader reader = new BufferedReader( new InputStreamReader( process.getInputStream() ) );\n        String line = null;\n        Collection<Pair<Long, String>> jPids = new ArrayList<Pair<Long,String>>();\n        while ( (line = reader.readLine()) != null )\n        {\n            int spaceIndex = line.indexOf( ' ' );\n            String name = line.substring( spaceIndex + 1 );\n            // Work-around for a windows problem where if your java.exe is in a directory\n            // containing spaces the value in the second column from jps output will be\n            // something like \"C:\\Program\" if it was under \"C:\\Program Files\\Java...\"\n            // If that's the case then use the PID instead\n            if ( name.contains( \":\" ) )\n            {\n                String pid = line.substring( 0, spaceIndex );\n                name = pid;\n            }\n            \n            if ( name.contains( DumpProcessInformation.class.getSimpleName() ) || name.contains( \"Jps\" ) ||\n                    name.contains( \"eclipse.equinox\" ) )\n            {\n                continue;\n            }\n            if ( containing != null && !name.contains( containing ) )\n            {\n                continue;\n            }\n            jPids.add( Pair.of( Long.parseLong( line.substring( 0, spaceIndex ) ), name ) );\n        }\n        process.waitFor();\n        return jPids;\n    }","id":84406,"modified_method":"public static Collection<Pair<Long, String>> getJPids( Predicate<String> processFilter )\n            throws IOException, InterruptedException\n    {\n        Process process = getRuntime().exec( new String[] { \"jps\", \"-l\" } );\n        BufferedReader reader = new BufferedReader( new InputStreamReader( process.getInputStream() ) );\n        Collection<Pair<Long, String>> jPids = new ArrayList<Pair<Long,String>>();\n        for ( String line = null; (line = reader.readLine()) != null; )\n        {\n            int spaceIndex = line.indexOf( ' ' );\n            String name = line.substring( spaceIndex + 1 );\n            // Work-around for a windows problem where if your java.exe is in a directory\n            // containing spaces the value in the second column from jps output will be\n            // something like \"C:\\Program\" if it was under \"C:\\Program Files\\Java...\"\n            // If that's the case then use the PID instead\n            if ( name.contains( \":\" ) )\n            {\n                String pid = line.substring( 0, spaceIndex );\n                name = pid;\n            }\n            \n            if ( name.contains( DumpProcessInformation.class.getSimpleName() ) || name.contains( \"Jps\" ) ||\n                    name.contains( \"eclipse.equinox\" ) )\n            {\n                continue;\n            }\n            if ( processFilter.accept( name ) )\n            {\n                jPids.add( Pair.of( Long.parseLong( line.substring( 0, spaceIndex ) ), name ) );\n            }\n        }\n        process.waitFor();\n        return jPids;\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args ) throws Exception\n    {\n        Args arg = new Args( args == null ? new String[0] : args );\n        boolean doHeapDump = arg.getBoolean( \"heap\", false, true );\n        String containing = arg.orphans().isEmpty() ? null : arg.orphans().get( 0 );\n        String dumpDir = arg.get( \"dir\", \"data\" );\n        File dirFile = dumpDir != null ? new File( dumpDir ) : null;\n        dirFile.mkdirs();\n        for ( Pair<Long, String> pid : getJPids( containing ) )\n        {\n            doThreadDump( pid, dirFile );\n            if ( doHeapDump ) doHeapDump( pid, dirFile );\n        }\n    }","id":84407,"modified_method":"public static void main( String[] args ) throws Exception\n    {\n        Args arg = new Args( args == null ? new String[0] : args );\n        boolean doHeapDump = arg.getBoolean( \"heap\", false, true );\n        Predicate<String> processFilter = arg.orphans().isEmpty() ?\n                Predicates.<String>TRUE() : stringContains( arg.orphans().get( 0 ) );\n        String dumpDir = arg.get( \"dir\", \"data\" );\n        File dirFile = dumpDir != null ? new File( dumpDir ) : null;\n        dirFile.mkdirs();\n        for ( Pair<Long, String> pid : getJPids( processFilter ) )\n        {\n            doThreadDump( pid, dirFile );\n            if ( doHeapDump )\n                doHeapDump( pid, dirFile );\n        }\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"public DumpProcessInformationRule( String containing, File baseDir, long duration, TimeUnit timeUnit )\n    {\n        super();\n\n        this.containing = containing;\n        this.baseDir = baseDir;\n        this.duration = duration;\n        this.timeUnit = timeUnit;\n    }","id":84408,"modified_method":"public DumpProcessInformationRule( String containing, File baseDir, long duration, TimeUnit timeUnit )\n    {\n        this( stringContains( containing ), baseDir, duration, timeUnit );\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected synchronized void before() throws Throwable\n    {\n        if ( null == thunk )\n        {\n            super.before();\n            thunk = executor.schedule( this, duration, timeUnit );\n        }\n        else\n            throw new IllegalStateException( \"process dumping thunk already started\" );\n    }","id":84409,"modified_method":"@Override\n    protected synchronized void before() throws Throwable\n    {\n        if ( null == thunk )\n        {\n            super.before();\n            thunk = executor.schedule( new Callable<Void>()\n            {\n                @Override\n                public Void call() throws Exception\n                {\n                    dump();\n                    return null;\n                }\n            }, duration, timeUnit );\n        }\n        else\n            throw new IllegalStateException( \"process dumping thunk already started\" );\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Triplet<Iterable<Relationship>, Long, Relationship> setup( GraphDatabaseAPI db )\n    {\n        Transaction tx = db.beginTx();\n        Node node1 = db.createNode();\n        Node node2 = db.createNode();\n        RelationshipType relType = DynamicRelationshipType.withName( \"POISON\" );\n        Relationship firstFromSecondBatch = node1.createRelationshipTo( node2, relType );\n        for ( int i = 0; i < RelationshipGrabSize; i++ )\n        {\n            node1.createRelationshipTo( node2, relType );\n        }\n        tx.success();\n        tx.finish();\n\n        db.getNodeManager().clearCache();\n        return Triplet.of( node1.getRelationships(), node1.getId(), firstFromSecondBatch );\n    }","id":84410,"modified_method":"private Triplet<Iterable<Relationship>, Long, Relationship> setup( GraphDatabaseAPI db )\n    {\n        Transaction tx = db.beginTx();\n        Node node1 = db.createNode();\n        Node node2 = db.createNode();\n        RelationshipType relType = DynamicRelationshipType.withName( \"POISON\" );\n        Relationship firstFromSecondBatch = node1.createRelationshipTo( node2, relType );\n        for ( int i = 0; i < RelationshipGrabSize; i++ )\n        {\n            node1.createRelationshipTo( node2, relType );\n        }\n        tx.success();\n        tx.finish();\n\n        db.getDependencyResolver().resolveDependency( NodeManager.class ).clearCache();\n        return Triplet.of( node1.getRelationships(), node1.getId(), firstFromSecondBatch );\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @EnabledBreakpoints( {\"doPrepare\", \"waitForPrepare\", \"readDone\"} )\n    public void theTest() throws InterruptedException\n    {\n        final GraphDatabaseAPI db = database.getGraphDatabaseAPI();\n\n        Transaction tx = db.beginTx();\n        final Node first = db.createNode();\n        final Relationship theOneAfterTheGap =\n                first.createRelationshipTo( db.createNode(), DynamicRelationshipType.withName( \"AC\" ) );\n        // The gap\n        for ( int i = 0; i < RelationshipGrabSize; i++)\n        {\n            first.createRelationshipTo( db.createNode(), DynamicRelationshipType.withName( \"AC\" ) );\n        }\n        tx.success();\n        tx.finish();\n\n        // This is required, otherwise relChainPosition is never consulted, everything will already be in mem.\n        db.getNodeManager().clearCache();\n\n        Runnable writer = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                Transaction tx = db.beginTx();\n                theOneAfterTheGap.delete();\n                tx.success();\n                tx.finish();\n            }\n        };\n\n        Runnable reader = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                waitForPrepare();\n                // Get the first batch into the cache - relChainPosition points to theOneAfterTheGap\n                first.getRelationships().iterator().next();\n                readDone();\n            }\n        };\n\n        Thread writerThread = new Thread( writer );\n        Thread readerThread = new Thread( reader );\n\n        // Start order matters - suspend the reader first, then start the writes.\n        readerThread.start();\n        writerThread.start();\n\n        readerThread.join();\n        writerThread.join();\n\n        // This should pass without any problems.\n        int count = 0;\n        for ( Relationship rel : first.getRelationships() )\n        {\n            count++;\n        }\n        assertEquals(\"Should have read relationships created minus one\", RelationshipGrabSize, count);\n    }","id":84411,"modified_method":"@Test\n    @EnabledBreakpoints( {\"doPrepare\", \"waitForPrepare\", \"readDone\"} )\n    public void theTest() throws InterruptedException\n    {\n        final GraphDatabaseAPI db = database.getGraphDatabaseAPI();\n\n        Transaction tx = db.beginTx();\n        final Node first = db.createNode();\n        final Relationship theOneAfterTheGap =\n                first.createRelationshipTo( db.createNode(), DynamicRelationshipType.withName( \"AC\" ) );\n        // The gap\n        for ( int i = 0; i < RelationshipGrabSize; i++)\n        {\n            first.createRelationshipTo( db.createNode(), DynamicRelationshipType.withName( \"AC\" ) );\n        }\n        tx.success();\n        tx.finish();\n\n        // This is required, otherwise relChainPosition is never consulted, everything will already be in mem.\n        db.getDependencyResolver().resolveDependency( NodeManager.class ).clearCache();\n\n        Runnable writer = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                Transaction tx = db.beginTx();\n                theOneAfterTheGap.delete();\n                tx.success();\n                tx.finish();\n            }\n        };\n\n        Runnable reader = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                waitForPrepare();\n                // Get the first batch into the cache - relChainPosition points to theOneAfterTheGap\n                first.getRelationships().iterator().next();\n                readDone();\n            }\n        };\n\n        Thread writerThread = new Thread( writer );\n        Thread readerThread = new Thread( reader );\n\n        // Start order matters - suspend the reader first, then start the writes.\n        readerThread.start();\n        writerThread.start();\n\n        readerThread.join();\n        writerThread.join();\n\n        // This should pass without any problems.\n        int count = count( first.getRelationships() );\n        assertEquals(\"Should have read relationships created minus one\", RelationshipGrabSize, count);\n    }","commit_id":"8a74ded74cffdc038c1f7e22b652a1801717bf69","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void applyRule(final SNode closure, final TypeCheckingContext typeCheckingContext) {\n    List<SNode> paramTypes = ListSequence.<SNode>fromArray();\n    for(SNode param : SLinkOperations.getTargets(closure, \"parameter\", true)) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(param, \"type\", true), \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n        final SNode pt_typevar_1221579075465 = typeCheckingContext.createNewRuntimeTypesVariable();\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(pt_typevar_1221579075465), typeCheckingContext.typeOf(param, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075470\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075466\", intentionProvider);\n        }\n        ListSequence.fromList(paramTypes).addElement(typeCheckingContext.getEquationManager().getRepresentator(pt_typevar_1221579075465));\n      } else if ((SLinkOperations.getTarget(param, \"type\", true) != null)) {\n        ListSequence.fromList(paramTypes).addElement(SLinkOperations.getTarget(param, \"type\", true));\n      }\n    }\n    List<SNode> allRets = ListSequence.<SNode>fromArray();\n    List<SNode> allYlds = ListSequence.<SNode>fromArray();\n    List<SNode> allYldAlls = ListSequence.<SNode>fromArray();\n    List<SNode> allStmts = ListSequence.fromList(new LinkedList<SNode>());\n    List<SNode> allThrows = ListSequence.<SNode>fromArray();\n    for(SNode c : SNodeOperations.getChildren(SLinkOperations.getTarget(closure, \"body\", true))) {\n      if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(c);\n      } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n        ListSequence.fromList(allStmts).addElement(c);\n      }\n    }\n    while (!(ListSequence.fromList(allStmts).isEmpty())) {\n      SNode stmt = ListSequence.fromList(allStmts).removeElementAt(0);\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(stmt);\n      } else\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else\n      {\n        if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ThrowStatement\")) {\n          final SNode tt_typevar_1221579075612 = typeCheckingContext.createNewRuntimeTypesVariable();\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(tt_typevar_1221579075612), typeCheckingContext.typeOf(SLinkOperations.getTarget(stmt, \"throwable\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075617\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075613\", intentionProvider);\n          }\n          ListSequence.fromList(allThrows).addElement(typeCheckingContext.getEquationManager().getRepresentator(tt_typevar_1221579075612));\n        } else\n        if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n          for(SNode thr : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(stmt, \"baseMethodDeclaration\", false), \"throwsItem\", true))) {\n            ListSequence.fromList(allThrows).addElement(SNodeOperations.copyNode(thr));\n          }\n        }\n        List<SNode> allChildren = ListSequence.fromList(new LinkedList<SNode>());\n        ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(stmt)));\n        while (ListSequence.fromList(allChildren).isNotEmpty()) {\n          SNode c = ListSequence.fromList(allChildren).removeElementAt(0);\n          if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.StatementList\")) {\n            for(SNode cstmt : SLinkOperations.getTargets(c, \"statement\", true)) {\n              if (!(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n                ListSequence.fromList(allStmts).addElement(cstmt);\n              }\n            }\n          } else\n          {\n            ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(c)));\n          }\n        }\n      }\n    }\n    final SNode RLCS_typevar_1221579075692 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for(SNode rs : allRets) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), ((SLinkOperations.getTarget(rs, \"expression\", true) != null) ?\n          typeCheckingContext.typeOf(SLinkOperations.getTarget(rs, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1231434118678\", true) :\n          new _Quotations.QuotationClass_7().createNode(typeCheckingContext)\n        ), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075710\", false, 0, intentionProvider);\n      }\n    }\n    final SNode YLCS_typevar_1221579075693 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for(SNode ys : allYlds) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(YLCS_typevar_1221579075693), typeCheckingContext.typeOf(SLinkOperations.getTarget(ys, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075728\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075724\", false, 0, intentionProvider);\n      }\n    }\n    final SNode YALCS_typevar_1229000934873 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for(SNode yas : allYldAlls) {\n      final SNode elementType_typevar_1229000969704 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(yas, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000996769\", true), new _Quotations.QuotationClass_8().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1229000969704), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1229000969704), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000989981\", false, 0, intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(YALCS_typevar_1229000934873), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1229000969704), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001090979\", false, 0, intentionProvider);\n      }\n    }\n    List<SNode> stmts = SLinkOperations.getTargets(SLinkOperations.getTarget(closure, \"body\", true), \"statement\", true);\n    SNode lastStmt = (stmts != null && ListSequence.fromList(stmts).count() > 0 ?\n      ListSequence.fromList(stmts).getElement(ListSequence.fromList(stmts).count() - 1) :\n      null\n    );\n    boolean returnsValue = !(ListSequence.fromList(allRets).isEmpty());\n    boolean returnsFromLast = SNodeOperations.isInstanceOf(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\");\n    boolean yieldsValue = !(ListSequence.fromList(allYlds).isEmpty());\n    switch (ListSequence.fromList(allYldAlls).count()) {\n      case 0:\n        break;\n      case 1:\n        if (ListSequence.fromList(allYldAlls).getElement(0) == lastStmt && !(yieldsValue)) {\n          returnsValue = true;\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), new _Quotations.QuotationClass_9().createNode(typeCheckingContext.getEquationManager().getRepresentator(YALCS_typevar_1229000934873), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001407669\", false, 0, intentionProvider);\n          }\n          break;\n        }\n        //  fall through\n      default:\n        yieldsValue = true;\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(YLCS_typevar_1221579075693), typeCheckingContext.getEquationManager().getRepresentator(YALCS_typevar_1229000934873), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229010820337\", false, 0, intentionProvider);\n        }\n    }\n    final SNode RESULT_typevar_1221579592331 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode RETURN_typevar_1232125235963 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode TERMINATE_typevar_1232105622932 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = closure;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RETURN_typevar_1232125235963), typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131392781\", false, 0, intentionProvider);\n    }\n    if (returnsFromLast && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(TERMINATE_typevar_1232105622932), typeCheckingContext.typeOf(SLinkOperations.getTarget(lastStmt, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131997253\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131997249\", intentionProvider);\n      }\n      final SNode RET_AND_TERM_typevar_1232125197501 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232125205435\", false, 0, intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), typeCheckingContext.typeOf(SLinkOperations.getTarget(lastStmt, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075774\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075770\", false, 0, intentionProvider);\n      }\n      if (returnsValue) {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663085197\", intentionProvider);\n        }\n      } else\n      {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), new _Quotations.QuotationClass_10().createNode(typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579747323\", intentionProvider);\n        }\n      }\n    } else\n    {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(TERMINATE_typevar_1232105622932), new _Quotations.QuotationClass_11().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131979682\", intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663751995\", intentionProvider);\n      }\n    }\n    List<SNode> realThrows = ListSequence.<SNode>fromArray();\nwith_allThrows:\n    for(SNode another : allThrows) {\n      for(SNode one : realThrows) {\n        if (SNodeOperations.isInstanceOf(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && SNodeOperations.isInstanceOf(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && SLinkOperations.getTarget(one, \"classifier\", false) == SLinkOperations.getTarget(another, \"classifier\", false)) {\n          continue with_allThrows;\n        }\n        if (MatchingUtil.matchNodes(one, another)) {\n          continue with_allThrows;\n        }\n      }\n      ListSequence.fromList(realThrows).addElement(another);\n    }\n    if (returnsValue && yieldsValue) {\n      if (!(false)) {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(closure, \"closure must either return or yield value\", \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075859\", intentionProvider, errorTarget);\n      }\n    } else\n    if ((returnsValue || returnsFromLast) && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(closure, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718156828\", true), ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), typeCheckingContext.getEquationManager().getRepresentator(RETURN_typevar_1232125235963), typeCheckingContext.getEquationManager().getRepresentator(TERMINATE_typevar_1232105622932), realThrows), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718163909\", intentionProvider);\n      }\n    } else\n    if (yieldsValue) {\n      SNode st = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.SequenceType\", null);\n      SLinkOperations.setTarget(st, \"elementType\", typeCheckingContext.getEquationManager().getRepresentator(YLCS_typevar_1221579075693), true);\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(closure, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718251100\", true), ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, st, null, null, realThrows), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718256918\", intentionProvider);\n      }\n    } else\n    {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(closure, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718277155\", true), ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, new _Quotations.QuotationClass_12().createNode(typeCheckingContext), new _Quotations.QuotationClass_13().createNode(typeCheckingContext), new _Quotations.QuotationClass_14().createNode(typeCheckingContext), realThrows), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718281813\", intentionProvider);\n      }\n    }\n  }","id":84412,"modified_method":"public void applyRule(final SNode closure, final TypeCheckingContext typeCheckingContext) {\n    List<SNode> paramTypes = ListSequence.<SNode>fromArray();\n    for(SNode param : SLinkOperations.getTargets(closure, \"parameter\", true)) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(param, \"type\", true), \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n        final SNode pt_typevar_1221579075465 = typeCheckingContext.createNewRuntimeTypesVariable();\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(pt_typevar_1221579075465), typeCheckingContext.typeOf(param, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075470\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075466\", intentionProvider);\n        }\n        ListSequence.fromList(paramTypes).addElement(typeCheckingContext.getEquationManager().getRepresentator(pt_typevar_1221579075465));\n      } else if ((SLinkOperations.getTarget(param, \"type\", true) != null)) {\n        ListSequence.fromList(paramTypes).addElement(SLinkOperations.getTarget(param, \"type\", true));\n      }\n    }\n    List<SNode> allRets = ListSequence.<SNode>fromArray();\n    List<SNode> allYlds = ListSequence.<SNode>fromArray();\n    List<SNode> allYldAlls = ListSequence.<SNode>fromArray();\n    List<SNode> allStmts = ListSequence.fromList(new LinkedList<SNode>());\n    List<SNode> allThrows = ListSequence.<SNode>fromArray();\n    for(SNode c : SNodeOperations.getChildren(SLinkOperations.getTarget(closure, \"body\", true))) {\n      if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(c);\n      } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n        ListSequence.fromList(allStmts).addElement(c);\n      }\n    }\n    while (!(ListSequence.fromList(allStmts).isEmpty())) {\n      SNode stmt = ListSequence.fromList(allStmts).removeElementAt(0);\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(stmt);\n      } else\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else\n      {\n        if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ThrowStatement\")) {\n          final SNode tt_typevar_1221579075612 = typeCheckingContext.createNewRuntimeTypesVariable();\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(tt_typevar_1221579075612), typeCheckingContext.typeOf(SLinkOperations.getTarget(stmt, \"throwable\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075617\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075613\", intentionProvider);\n          }\n          ListSequence.fromList(allThrows).addElement(typeCheckingContext.getEquationManager().getRepresentator(tt_typevar_1221579075612));\n        } else\n        if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n          for(SNode thr : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(stmt, \"baseMethodDeclaration\", false), \"throwsItem\", true))) {\n            ListSequence.fromList(allThrows).addElement(SNodeOperations.copyNode(thr));\n          }\n        }\n        List<SNode> allChildren = ListSequence.fromList(new LinkedList<SNode>());\n        ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(stmt)));\n        while (ListSequence.fromList(allChildren).isNotEmpty()) {\n          SNode c = ListSequence.fromList(allChildren).removeElementAt(0);\n          if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.StatementList\")) {\n            for(SNode cstmt : SLinkOperations.getTargets(c, \"statement\", true)) {\n              if (!(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n                ListSequence.fromList(allStmts).addElement(cstmt);\n              }\n            }\n          } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n            ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(c)));\n          }\n        }\n      }\n    }\n    final SNode RLCS_typevar_1221579075692 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for(SNode rs : allRets) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), ((SLinkOperations.getTarget(rs, \"expression\", true) != null) ?\n          typeCheckingContext.typeOf(SLinkOperations.getTarget(rs, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1231434118678\", true) :\n          new _Quotations.QuotationClass_7().createNode(typeCheckingContext)\n        ), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075710\", false, 0, intentionProvider);\n      }\n    }\n    final SNode YLCS_typevar_1221579075693 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for(SNode ys : allYlds) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(YLCS_typevar_1221579075693), typeCheckingContext.typeOf(SLinkOperations.getTarget(ys, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075728\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075724\", false, 0, intentionProvider);\n      }\n    }\n    final SNode YALCS_typevar_1229000934873 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for(SNode yas : allYldAlls) {\n      final SNode elementType_typevar_1229000969704 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(yas, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000996769\", true), new _Quotations.QuotationClass_8().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1229000969704), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1229000969704), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000989981\", false, 0, intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(YALCS_typevar_1229000934873), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1229000969704), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001090979\", false, 0, intentionProvider);\n      }\n    }\n    List<SNode> stmts = SLinkOperations.getTargets(SLinkOperations.getTarget(closure, \"body\", true), \"statement\", true);\n    SNode lastStmt = (stmts != null && ListSequence.fromList(stmts).count() > 0 ?\n      ListSequence.fromList(stmts).getElement(ListSequence.fromList(stmts).count() - 1) :\n      null\n    );\n    boolean returnsValue = !(ListSequence.fromList(allRets).isEmpty());\n    boolean returnsFromLast = SNodeOperations.isInstanceOf(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\");\n    boolean yieldsValue = !(ListSequence.fromList(allYlds).isEmpty());\n    switch (ListSequence.fromList(allYldAlls).count()) {\n      case 0:\n        break;\n      case 1:\n        if (ListSequence.fromList(allYldAlls).getElement(0) == lastStmt && !(yieldsValue)) {\n          returnsValue = true;\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), new _Quotations.QuotationClass_9().createNode(typeCheckingContext.getEquationManager().getRepresentator(YALCS_typevar_1229000934873), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001407669\", false, 0, intentionProvider);\n          }\n          break;\n        }\n        //  fall through\n      default:\n        yieldsValue = true;\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(YLCS_typevar_1221579075693), typeCheckingContext.getEquationManager().getRepresentator(YALCS_typevar_1229000934873), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229010820337\", false, 0, intentionProvider);\n        }\n    }\n    final SNode RESULT_typevar_1221579592331 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode RETURN_typevar_1232125235963 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode TERMINATE_typevar_1232105622932 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = closure;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RETURN_typevar_1232125235963), typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131392781\", false, 0, intentionProvider);\n    }\n    if (returnsFromLast && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(TERMINATE_typevar_1232105622932), typeCheckingContext.typeOf(SLinkOperations.getTarget(lastStmt, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131997253\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131997249\", intentionProvider);\n      }\n      final SNode RET_AND_TERM_typevar_1232125197501 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232125205435\", false, 0, intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createGreaterThanInequation(typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), typeCheckingContext.typeOf(SLinkOperations.getTarget(lastStmt, \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075774\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075770\", false, 0, intentionProvider);\n      }\n      if (returnsValue) {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663085197\", intentionProvider);\n        }\n      } else\n      {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), new _Quotations.QuotationClass_10().createNode(typeCheckingContext.getEquationManager().getRepresentator(RET_AND_TERM_typevar_1232125197501), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579747323\", intentionProvider);\n        }\n      }\n    } else\n    {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(TERMINATE_typevar_1232105622932), new _Quotations.QuotationClass_11().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131979682\", intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), typeCheckingContext.getEquationManager().getRepresentator(RLCS_typevar_1221579075692), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663751995\", intentionProvider);\n      }\n    }\n    List<SNode> realThrows = ListSequence.<SNode>fromArray();\nwith_allThrows:\n    for(SNode another : allThrows) {\n      for(SNode one : realThrows) {\n        if (SNodeOperations.isInstanceOf(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && SNodeOperations.isInstanceOf(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && SLinkOperations.getTarget(one, \"classifier\", false) == SLinkOperations.getTarget(another, \"classifier\", false)) {\n          continue with_allThrows;\n        }\n        if (MatchingUtil.matchNodes(one, another)) {\n          continue with_allThrows;\n        }\n      }\n      ListSequence.fromList(realThrows).addElement(another);\n    }\n    if (returnsValue && yieldsValue) {\n      if (!(false)) {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(closure, \"closure must either return or yield value\", \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075859\", intentionProvider, errorTarget);\n      }\n    } else\n    if ((returnsValue || returnsFromLast) && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(closure, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718156828\", true), ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, typeCheckingContext.getEquationManager().getRepresentator(RESULT_typevar_1221579592331), typeCheckingContext.getEquationManager().getRepresentator(RETURN_typevar_1232125235963), typeCheckingContext.getEquationManager().getRepresentator(TERMINATE_typevar_1232105622932), realThrows), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718163909\", intentionProvider);\n      }\n    } else\n    if (yieldsValue) {\n      SNode st = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.SequenceType\", null);\n      SLinkOperations.setTarget(st, \"elementType\", typeCheckingContext.getEquationManager().getRepresentator(YLCS_typevar_1221579075693), true);\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(closure, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718251100\", true), ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, st, null, null, realThrows), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718256918\", intentionProvider);\n      }\n    } else\n    {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(closure, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718277155\", true), ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, new _Quotations.QuotationClass_12().createNode(typeCheckingContext), new _Quotations.QuotationClass_13().createNode(typeCheckingContext), new _Quotations.QuotationClass_14().createNode(typeCheckingContext), realThrows), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718281813\", intentionProvider);\n      }\n    }\n  }","commit_id":"c25b700eebfdc0584341cace31f3ce30efc6ca4f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode invoke, final TypeCheckingContext typeCheckingContext) {\n    List<SNode> ptypes = ListSequence.<SNode>fromArray();\n    List<SNode> ptypes2 = ListSequence.<SNode>fromArray();\n    for(SNode p : SLinkOperations.getTargets(invoke, \"parameter\", true)) {\n      ListSequence.fromList(ptypes).addElement(typeCheckingContext.typeOf(p, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237042863792\", true));\n      ListSequence.fromList(ptypes2).addElement(typeCheckingContext.typeOf(p, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237042864597\", true));\n    }\n    final SNode ret_typevar_1225797542595 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode ret2_typevar_1230048995510 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequationStrong(typeCheckingContext.typeOf(invoke, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1231326091849\", true), new _Quotations.QuotationClass_15().createNode(typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1231326088049\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequationStrong(new _Quotations.QuotationClass_16().createNode(typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), typeCheckingContext), typeCheckingContext.typeOf(invoke, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1231326226782\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1231326206745\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequationStrong(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(invoke), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1230048905737\", true), new _Quotations.QuotationClass_17().createNode(ptypes, typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), ptypes2, typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), typeCheckingContext.getEquationManager().getRepresentator(ret2_typevar_1230048995510), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1230048793938\", false, 0, intentionProvider);\n    }\n  }","id":84413,"modified_method":"public void applyRule(final SNode invoke, final TypeCheckingContext typeCheckingContext) {\n    List<SNode> ptypes = ListSequence.<SNode>fromArray();\n    List<SNode> ptypes2 = ListSequence.<SNode>fromArray();\n    for(SNode p : SLinkOperations.getTargets(invoke, \"parameter\", true)) {\n      ListSequence.fromList(ptypes).addElement(typeCheckingContext.typeOf(p, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237042863792\", true));\n      ListSequence.fromList(ptypes2).addElement(typeCheckingContext.typeOf(p, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237042864597\", true));\n    }\n    final SNode ret_typevar_1225797542595 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode ret2_typevar_1230048995510 = typeCheckingContext.createNewRuntimeTypesVariable();\n    /*\n      {\n        SNode _nodeToCheck_1029348928467 = invoke;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(invoke, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237374021867\", true), new _Quotations.QuotationClass_15().createNode(typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237374021865\", false, 0, intentionProvider);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = invoke;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(new _Quotations.QuotationClass_16().createNode(typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), typeCheckingContext), typeCheckingContext.typeOf(invoke, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237374026565\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237374026556\", false, 0, intentionProvider);\n      }\n    */\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(invoke, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237374276263\", true), typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1237374285371\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequationStrong(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(invoke), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1230048905737\", true), new _Quotations.QuotationClass_17().createNode(ptypes, typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), ptypes2, typeCheckingContext.getEquationManager().getRepresentator(ret_typevar_1225797542595), typeCheckingContext.getEquationManager().getRepresentator(ret2_typevar_1230048995510), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1230048793938\", false, 0, intentionProvider);\n    }\n  }","commit_id":"c25b700eebfdc0584341cace31f3ce30efc6ca4f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    final SNode oldVariable = SLinkOperations.getTarget(node, \"variable\", true);\n    SNode variableType = SNodeOperations.copyNode(TypeChecker.getInstance().getTypeOf(oldVariable));\n    SNode foreachStatement = SNodeOperations.replaceWithNewChild(node, \"jetbrains.mps.baseLanguage.structure.ForeachStatement\");\n    SLinkOperations.setTarget(foreachStatement, \"body\", SLinkOperations.getTarget(node, \"body\", true), true);\n    SLinkOperations.setTarget(foreachStatement, \"iterable\", SLinkOperations.getTarget(node, \"inputSequence\", true), true);\n    SPropertyOperations.set(foreachStatement, \"label\", SPropertyOperations.getString(node, \"label\"));\n    SNode newVariable = SLinkOperations.setNewChild(foreachStatement, \"variable\", \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n    SPropertyOperations.set(newVariable, \"name\", SPropertyOperations.getString(oldVariable, \"name\"));\n    SLinkOperations.setTarget(newVariable, \"type\", variableType, true);\n    for(SNode oldRef : ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(foreachStatement, \"body\", true), \"jetbrains.mps.baseLanguage.collections.structure.ForEachVariableReference\", false)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return SLinkOperations.getTarget(it, \"variable\", false) == oldVariable;\n      }\n\n    })) {\n      SLinkOperations.setTarget(SNodeOperations.replaceWithNewChild(oldRef, \"jetbrains.mps.baseLanguage.structure.LocalVariableReference\"), \"variableDeclaration\", newVariable, false);\n    }\n  }","id":84414,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    final SNode oldVariable = SLinkOperations.getTarget(node, \"variable\", true);\n    SNode variableType = SNodeOperations.copyNode(TypeChecker.getInstance().getTypeOf(oldVariable));\n    SNode foreachStatement = SNodeOperations.replaceWithNewChild(node, \"jetbrains.mps.baseLanguage.structure.ForeachStatement\");\n    SLinkOperations.setTarget(foreachStatement, \"body\", SLinkOperations.getTarget(node, \"body\", true), true);\n    SLinkOperations.setTarget(foreachStatement, \"iterable\", SLinkOperations.getTarget(node, \"inputSequence\", true), true);\n    SPropertyOperations.set(foreachStatement, \"label\", SPropertyOperations.getString(node, \"label\"));\n    SNode newVariable = SLinkOperations.setNewChild(foreachStatement, \"variable\", \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n    SPropertyOperations.set(newVariable, \"name\", SPropertyOperations.getString(oldVariable, \"name\"));\n    SLinkOperations.setTarget(newVariable, \"type\", variableType, true);\n    for(SNode oldRef : Sequence.fromIterable(ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(foreachStatement, \"body\", true), \"jetbrains.mps.baseLanguage.collections.structure.ForEachVariableReference\", false)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return SLinkOperations.getTarget(it, \"variable\", false) == oldVariable;\n      }\n\n    }))) {\n      SLinkOperations.setTarget(SNodeOperations.replaceWithNewChild(oldRef, \"jetbrains.mps.baseLanguage.structure.LocalVariableReference\"), \"variableDeclaration\", newVariable, false);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test()\n  public void test_legacyForeach() throws Exception {\n    ArrayList<Integer> res = new ArrayList<Integer>();\n    for(Integer foo : this.input5()) {\n      res.add(foo * 2);\n    }\n    this.assertIterableEquals(this.expectEven10(), res);\n  }","id":84415,"modified_method":"@Test()\n  public void test_legacyForeach() throws Exception {\n    ArrayList<Integer> res = new ArrayList<Integer>();\n    for(Integer foo : Sequence.fromIterable(this.input5())) {\n      res.add(foo * 2);\n    }\n    this.assertIterableEquals(this.expectEven10(), res);\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<String> virtual_getVariableSuffixes_1213877337304(SNode thisNode) {\n    List<String> variableSuffixes = ListSequence.<String>fromArray(\"list\");\n    if ((SLinkOperations.getTarget(thisNode, \"elementType\", true) != null)) {\n      for(String suffix : Type_Behavior.call_getVariableSuffixes_1213877337304(SLinkOperations.getTarget(thisNode, \"elementType\", true))) {\n        ListSequence.fromList(variableSuffixes).addElement(NameUtil.pluralize(suffix));\n      }\n    }\n    return variableSuffixes;\n  }","id":84416,"modified_method":"public static List<String> virtual_getVariableSuffixes_1213877337304(SNode thisNode) {\n    List<String> variableSuffixes = ListSequence.<String>fromArray(\"list\");\n    if ((SLinkOperations.getTarget(thisNode, \"elementType\", true) != null)) {\n      for(String suffix : Sequence.fromIterable(Type_Behavior.call_getVariableSuffixes_1213877337304(SLinkOperations.getTarget(thisNode, \"elementType\", true)))) {\n        ListSequence.fromList(variableSuffixes).addElement(NameUtil.pluralize(suffix));\n      }\n    }\n    return variableSuffixes;\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test()\n  public void test_forEach() throws Exception {\n    if (Sequence.USE_NULL_SEQUENCE) {\n      for(Object foo : Sequence.fromIterable(null)) {\n        //  must not throw exception\n        throw new RuntimeException(\"unpossible!\");\n      }\n    }\n  }","id":84417,"modified_method":"@Test()\n  public void test_forEach() throws Exception {\n    if (Sequence.USE_NULL_SEQUENCE) {\n      for(Object foo : Sequence.fromIterable(null)) {\n        //  must not throw exception\n        throw new RuntimeException(\"me fail english? unpossible!\");\n      }\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable<SNode> collectYieldStatements(SNode node) {\n    Iterable<SNode> yieldStatements = ListSequence.fromList(SNodeOperations.getChildren(node)).translate(new ITranslator <SNode, SNode>() {\n\n      public ISequence<SNode> translate(final SNode it) {\n        return new ISequenceIterableAdapter <SNode>() {\n\n          public Iterator<SNode> iterator() {\n            return new YieldingIterator <SNode>() {\n\n              private int __CP__ = 0;\n              private SNode _11_yieldStmt;\n              private Iterator<SNode> _11_yieldStmt_it;\n\n              protected boolean moveToNext() {\n__loop__:\n                do {\n__switch__:\n                  switch (this.__CP__) {\n                    case -1:\n                      assert false : \"Internal error\";\n                      return false;\n                    case 11:\n                      this._11_yieldStmt_it = collectYieldStatements(it).iterator();\n                    case 12:\n                      if (!(this._11_yieldStmt_it.hasNext())) {\n                        this.__CP__ = 3;\n                        break;\n                      }\n                      this._11_yieldStmt = this._11_yieldStmt_it.next();\n                      this.__CP__ = 13;\n                      break;\n                    case 4:\n                      if (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.collections.structure.TraversalYieldStatement\")) {\n                        this.__CP__ = 5;\n                        break;\n                      }\n                      this.__CP__ = 7;\n                      break;\n                    case 7:\n                      if (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.ConceptFunction\") || SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) {\n                        this.__CP__ = 8;\n                        break;\n                      }\n                      this.__CP__ = 10;\n                      break;\n                    case 3:\n                      if (false) {\n                        this.__CP__ = 2;\n                        break;\n                      }\n                      this.__CP__ = 1;\n                      break;\n                    case 6:\n                      this.__CP__ = 3;\n                      this.yield(it);\n                      return true;\n                    case 14:\n                      this.__CP__ = 12;\n                      this.yield(this._11_yieldStmt);\n                      return true;\n                    case 0:\n                      this.__CP__ = 2;\n                      break;\n                    case 2:\n                      this.__CP__ = 4;\n                      break;\n                    case 5:\n                      this.__CP__ = 6;\n                      break;\n                    case 8:\n                      // don't look inside closures and other code-blocks\n                      // don't look inside commented statements\n                      this.__CP__ = 1;\n                      break;\n                    case 10:\n                      this.__CP__ = 11;\n                      break;\n                    case 13:\n                      this.__CP__ = 14;\n                      break;\n                    default:\n                      break __loop__;\n                  }\n                } while(true);\n                return false;\n              }\n\n            };\n          }\n\n        };\n      }\n\n    });\n    return yieldStatements;\n  }","id":84418,"modified_method":"public static Iterable<SNode> collectYieldStatements(SNode node) {\n    Iterable<SNode> yieldStatements = ListSequence.fromList(SNodeOperations.getChildren(node)).translate(new ITranslator <SNode, SNode>() {\n\n      public ISequence<SNode> translate(final SNode it) {\n        return new ISequenceIterableAdapter <SNode>() {\n\n          public Iterator<SNode> iterator() {\n            return new YieldingIterator <SNode>() {\n\n              private int __CP__ = 0;\n              private SNode _11_yieldStmt;\n              private Iterator<SNode> _11_yieldStmt_it;\n\n              protected boolean moveToNext() {\n__loop__:\n                do {\n__switch__:\n                  switch (this.__CP__) {\n                    case -1:\n                      assert false : \"Internal error\";\n                      return false;\n                    case 11:\n                      this._11_yieldStmt_it = Sequence.fromIterable(collectYieldStatements(it)).iterator();\n                    case 12:\n                      if (!(this._11_yieldStmt_it.hasNext())) {\n                        this.__CP__ = 3;\n                        break;\n                      }\n                      this._11_yieldStmt = this._11_yieldStmt_it.next();\n                      this.__CP__ = 13;\n                      break;\n                    case 4:\n                      if (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.collections.structure.TraversalYieldStatement\")) {\n                        this.__CP__ = 5;\n                        break;\n                      }\n                      this.__CP__ = 7;\n                      break;\n                    case 7:\n                      if (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.ConceptFunction\") || SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) {\n                        this.__CP__ = 8;\n                        break;\n                      }\n                      this.__CP__ = 10;\n                      break;\n                    case 3:\n                      if (false) {\n                        this.__CP__ = 2;\n                        break;\n                      }\n                      this.__CP__ = 1;\n                      break;\n                    case 6:\n                      this.__CP__ = 3;\n                      this.yield(it);\n                      return true;\n                    case 14:\n                      this.__CP__ = 12;\n                      this.yield(this._11_yieldStmt);\n                      return true;\n                    case 0:\n                      this.__CP__ = 2;\n                      break;\n                    case 2:\n                      this.__CP__ = 4;\n                      break;\n                    case 5:\n                      this.__CP__ = 6;\n                      break;\n                    case 8:\n                      // don't look inside closures and other code-blocks\n                      // don't look inside commented statements\n                      this.__CP__ = 1;\n                      break;\n                    case 10:\n                      this.__CP__ = 11;\n                      break;\n                    case 13:\n                      this.__CP__ = 14;\n                      break;\n                    default:\n                      break __loop__;\n                  }\n                } while(true);\n                return false;\n              }\n\n            };\n          }\n\n        };\n      }\n\n    });\n    return yieldStatements;\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<String> virtual_getVariableSuffixes_1213877337304(SNode thisNode) {\n    List<String> variableSuffixes = ListSequence.<String>fromArray(\"seq\");\n    if ((SLinkOperations.getTarget(thisNode, \"elementType\", true) != null)) {\n      for(String suffix : Type_Behavior.call_getVariableSuffixes_1213877337304(SLinkOperations.getTarget(thisNode, \"elementType\", true))) {\n        ListSequence.fromList(variableSuffixes).addElement(NameUtil.pluralize(suffix));\n      }\n    }\n    return variableSuffixes;\n  }","id":84419,"modified_method":"public static List<String> virtual_getVariableSuffixes_1213877337304(SNode thisNode) {\n    List<String> variableSuffixes = ListSequence.<String>fromArray(\"seq\");\n    if ((SLinkOperations.getTarget(thisNode, \"elementType\", true) != null)) {\n      for(String suffix : Sequence.fromIterable(Type_Behavior.call_getVariableSuffixes_1213877337304(SLinkOperations.getTarget(thisNode, \"elementType\", true)))) {\n        ListSequence.fromList(variableSuffixes).addElement(NameUtil.pluralize(suffix));\n      }\n    }\n    return variableSuffixes;\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode ct) {\n    List<SNode> res = Collections.emptyList();\n    if (SLinkOperations.getTarget(new _Quotations.QuotationClass_72().createNode(), \"classifier\", false) == SLinkOperations.getTarget(ct, \"classifier\", false)) {\n      res = new ArrayList<SNode>();\n      List<SNode> ptypes = SLinkOperations.getTargets(ct, \"parameter\", true);\n      if (ptypes.size() > 0) {\n        SNode elType = ptypes.get(0);\n        res.add(new _Quotations.QuotationClass_71().createNode(elType));\n      }\n    }\n    return res;\n  }","id":84420,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode ct) {\n    List<SNode> res = Collections.emptyList();\n    if (SLinkOperations.getTarget(new _Quotations.QuotationClass_74().createNode(), \"classifier\", false) == SLinkOperations.getTarget(ct, \"classifier\", false)) {\n      res = new ArrayList<SNode>();\n      List<SNode> ptypes = SLinkOperations.getTargets(ct, \"parameter\", true);\n      if (ptypes.size() > 0) {\n        SNode elType = ptypes.get(0);\n        res.add(new _Quotations.QuotationClass_73().createNode(elType));\n      }\n    }\n    return res;\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode co, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = co;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(co, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753329622\", true), typeCheckingContext.typeOf(SLinkOperations.getTarget(SNodeOperations.getParent(co), \"operand\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753430842\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753325804\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = co;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(co, \"length\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753511511\", true), new _Quotations.QuotationClass_77().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753509659\", false, 0, intentionProvider);\n    }\n  }","id":84421,"modified_method":"public void applyRule(final SNode co, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = co;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(co, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753329622\", true), typeCheckingContext.typeOf(SLinkOperations.getTarget(SNodeOperations.getParent(co), \"operand\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753430842\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753325804\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = co;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(co, \"length\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753511511\", true), new _Quotations.QuotationClass_79().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205753509659\", false, 0, intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode cso, final TypeCheckingContext typeCheckingContext) {\n    final SNode paramType_typevar_1209728259188 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode resType_typevar_1209728259189 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(cso, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259192\", true), new _Quotations.QuotationClass_79().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext.getEquationManager().getRepresentator(resType_typevar_1209728259189), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259190\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(resType_typevar_1209728259189), new _Quotations.QuotationClass_80().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259205\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(cso, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259213\", true), new _Quotations.QuotationClass_81().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259211\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(cso, \"ascending\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259224\", true), new _Quotations.QuotationClass_82().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259222\", false, 0, intentionProvider);\n    }\n  }","id":84422,"modified_method":"public void applyRule(final SNode cso, final TypeCheckingContext typeCheckingContext) {\n    final SNode paramType_typevar_1209728259188 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(cso), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225885254827\", true), new _Quotations.QuotationClass_83().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225885254825\", false, 0, intentionProvider);\n    }\n    final SNode resType_typevar_1209728259189 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(cso, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259192\", true), new _Quotations.QuotationClass_84().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259190\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(cso, \"ascending\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259224\", true), new _Quotations.QuotationClass_85().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259222\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = cso;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(cso, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259213\", true), new _Quotations.QuotationClass_86().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1209728259188), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1209728259211\", intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    final SNode elementType_typevar_1225727823542 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727831549\", true), new _Quotations.QuotationClass_93().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225727823542), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727841274\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727909229\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225727823542), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727913024\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727925390\", true), new _Quotations.QuotationClass_94().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225727823542), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727952016\", false, 0, intentionProvider);\n    }\n  }","id":84423,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    final SNode elementType_typevar_1225727823542 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727831549\", true), new _Quotations.QuotationClass_98().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225727823542), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727841274\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727909229\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225727823542), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727913024\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727925390\", true), new _Quotations.QuotationClass_99().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225727823542), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225727952016\", false, 0, intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    final SNode elementType_typevar_1225730451735 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451744\", true), new _Quotations.QuotationClass_95().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225730451735), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451736\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451752\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225730451735), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451748\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451763\", true), new _Quotations.QuotationClass_96().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225730451735), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451754\", false, 0, intentionProvider);\n    }\n  }","id":84424,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    final SNode elementType_typevar_1225730451735 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451744\", true), new _Quotations.QuotationClass_100().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225730451735), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451736\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451752\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225730451735), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451748\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451763\", true), new _Quotations.QuotationClass_101().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225730451735), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225730451754\", false, 0, intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"index\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622519598\", true), new _Quotations.QuotationClass_87().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622529097\", false, 0, intentionProvider);\n    }\n    final SNode elementType_typevar_1225625140805 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225625109892\", true), new _Quotations.QuotationClass_88().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225625140805), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225625115380\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"element\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622545086\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225625140805), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622627558\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622680239\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225625140805), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622714904\", intentionProvider);\n    }\n  }","id":84425,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"index\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622519598\", true), new _Quotations.QuotationClass_92().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622529097\", false, 0, intentionProvider);\n    }\n    final SNode elementType_typevar_1225625140805 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225625109892\", true), new _Quotations.QuotationClass_93().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225625140805), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225625115380\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"element\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622545086\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225625140805), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622627558\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622680239\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225625140805), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225622714904\", intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    final SNode elementType_typevar_1225711334597 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(expression, \"list\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711317313\", true), new _Quotations.QuotationClass_91().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225711334597), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711322689\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(expression, \"index\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711355326\", true), new _Quotations.QuotationClass_92().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711362428\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(expression, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711372118\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225711334597), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711376610\", intentionProvider);\n    }\n  }","id":84426,"modified_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    final SNode elementType_typevar_1225711334597 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(expression, \"list\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711317313\", true), new _Quotations.QuotationClass_96().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225711334597), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711322689\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(expression, \"index\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711355326\", true), new _Quotations.QuotationClass_97().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711362428\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(expression, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711372118\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225711334597), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225711376610\", intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode to, final TypeCheckingContext typeCheckingContext) {\n    final SNode resType_typevar_1203507994156 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode paramType_typevar_1203508136831 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode elType_typevar_1203507994173 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = to;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(SLinkOperations.getTarget(to, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1203507994160\", true), new _Quotations.QuotationClass_64().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1203508136831), typeCheckingContext.getEquationManager().getRepresentator(resType_typevar_1203507994156), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1203507994158\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = to;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(resType_typevar_1203507994156), new _Quotations.QuotationClass_65().createNode(typeCheckingContext.getEquationManager().getRepresentator(elType_typevar_1203507994173), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1204817857369\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = to;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(to, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1203507994189\", true), typeCheckingContext.getEquationManager().getRepresentator(resType_typevar_1203507994156), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1203507994185\", intentionProvider);\n    }\n  }","id":84427,"modified_method":"public void applyRule(final SNode to, final TypeCheckingContext typeCheckingContext) {\n    final SNode paramType_typevar_1203508136831 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = to;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(to), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225885291574\", true), new _Quotations.QuotationClass_64().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1203508136831), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225885291572\", false, 0, intentionProvider);\n    }\n    final SNode elType_typevar_1203507994173 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = to;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(to, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225883546585\", true), new _Quotations.QuotationClass_65().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1203508136831), typeCheckingContext.getEquationManager().getRepresentator(elType_typevar_1203507994173), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225883546583\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = to;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(to, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1203507994189\", true), new _Quotations.QuotationClass_66().createNode(typeCheckingContext.getEquationManager().getRepresentator(elType_typevar_1203507994173), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1203507994185\", intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode creator, final TypeCheckingContext typeCheckingContext) {\n    SNode elementType = SLinkOperations.getTarget(creator, \"elementType\", true);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(creator, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414558830\", true), new _Quotations.QuotationClass_84().createNode(elementType, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414570410\", intentionProvider);\n    }\n    if ((SLinkOperations.getTarget(creator, \"initializer\", true) != null)) {\n      {\n        SNode _nodeToCheck_1029348928467 = creator;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(creator, \"initializer\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414629838\", true), new _Quotations.QuotationClass_85().createNode(elementType, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414640119\", false, 0, intentionProvider);\n      }\n    }\n  }","id":84428,"modified_method":"public void applyRule(final SNode creator, final TypeCheckingContext typeCheckingContext) {\n    SNode elementType = SLinkOperations.getTarget(creator, \"elementType\", true);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(creator, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414558830\", true), new _Quotations.QuotationClass_88().createNode(elementType, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414570410\", intentionProvider);\n    }\n    if ((SLinkOperations.getTarget(creator, \"initializer\", true) != null)) {\n      {\n        SNode _nodeToCheck_1029348928467 = creator;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(creator, \"initializer\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414629838\", true), new _Quotations.QuotationClass_89().createNode(elementType, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1224414640119\", false, 0, intentionProvider);\n      }\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"index\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926708\", true), new _Quotations.QuotationClass_89().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926703\", false, 0, intentionProvider);\n    }\n    final SNode elementType_typevar_1225645926712 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926721\", true), new _Quotations.QuotationClass_90().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225645926712), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926713\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"element\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926729\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225645926712), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926725\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926737\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225645926712), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926733\", intentionProvider);\n    }\n  }","id":84429,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"index\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926708\", true), new _Quotations.QuotationClass_94().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926703\", false, 0, intentionProvider);\n    }\n    final SNode elementType_typevar_1225645926712 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(operation), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926721\", true), new _Quotations.QuotationClass_95().createNode(typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225645926712), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926713\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"element\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926729\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225645926712), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926725\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(operation, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926737\", true), typeCheckingContext.getEquationManager().getRepresentator(elementType_typevar_1225645926712), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225645926733\", intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode vo, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = vo;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(vo, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205842235753\", true), new _Quotations.QuotationClass_78().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205842233781\", intentionProvider);\n    }\n  }","id":84430,"modified_method":"public void applyRule(final SNode vo, final TypeCheckingContext typeCheckingContext) {\n    final SNode paramType_typevar_1225883650310 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = vo;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(IOperation_Behavior.call_getOperand_1213877410070(vo), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225885296681\", true), new _Quotations.QuotationClass_80().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1225883650310), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225885296679\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = vo;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(vo, \"closure\", true), \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225883613452\", true), new _Quotations.QuotationClass_81().createNode(typeCheckingContext.getEquationManager().getRepresentator(paramType_typevar_1225883650310), typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1225883621916\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = vo;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(vo, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205842235753\", true), new _Quotations.QuotationClass_82().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1205842233781\", intentionProvider);\n    }\n  }","commit_id":"3e5e1d19183f297e7d383ec334b32c9dbb8a4964","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Optional<List<ETLStage>> getTransforms() {\n    return Optional.fromNullable(transforms);\n  }","id":84431,"modified_method":"public List<ETLStage> getTransforms() {\n    return transforms != null ? transforms : Lists.<ETLStage>newArrayList();\n  }","commit_id":"e002acab5729f85fe225b62aea5492c8928d188b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void initialize(MapReduceContext context) throws Exception {\n      Map<String, String> runtimeArgs = context.getRuntimeArguments();\n      ETLBatchConfig etlConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n      String sourcePluginId = runtimeArgs.get(Constants.Source.PLUGINID);\n      String sinkPluginId = runtimeArgs.get(Constants.Sink.PLUGINID);\n      List<String> transformIds = GSON.fromJson(runtimeArgs.get(Constants.Transform.PLUGINIDS), STRING_LIST_TYPE);\n\n\n      List<ETLStage> stageList = etlConfig.getTransforms().or(Lists.<ETLStage>newArrayList());\n      LOG.info(\"Transform Stages : {}\", stageList);\n\n      List<Transformation> pipeline = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      List<StageMetrics> stageMetrics = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      transforms = Lists.newArrayListWithCapacity(stageList.size());\n\n      BatchSource source = context.newPluginInstance(sourcePluginId);\n      BatchSourceContext batchSourceContext = new MapReduceSourceContext(context, mapperMetrics, sourcePluginId);\n      source.initialize(batchSourceContext);\n      pipeline.add(source);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SOURCE, etlConfig.getSource().getName()));\n\n      addTransforms(stageList, pipeline, stageMetrics, transformIds, context);\n\n      BatchSink sink = context.newPluginInstance(sinkPluginId);\n      BatchSinkContext batchSinkContext = new MapReduceSinkContext(context, mapperMetrics, sinkPluginId);\n      sink.initialize(batchSinkContext);\n      pipeline.add(sink);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SINK, etlConfig.getSink().getName()));\n\n      transformExecutor = new TransformExecutor<>(pipeline, stageMetrics);\n    }","id":84432,"modified_method":"@Override\n    public void initialize(MapReduceContext context) throws Exception {\n      Map<String, String> runtimeArgs = context.getRuntimeArguments();\n      ETLBatchConfig etlConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n      String sourcePluginId = runtimeArgs.get(Constants.Source.PLUGINID);\n      String sinkPluginId = runtimeArgs.get(Constants.Sink.PLUGINID);\n      List<String> transformIds = GSON.fromJson(runtimeArgs.get(Constants.Transform.PLUGINIDS), STRING_LIST_TYPE);\n\n\n      List<ETLStage> stageList = etlConfig.getTransforms();\n      LOG.info(\"Transform Stages : {}\", stageList);\n\n      List<Transformation> pipeline = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      List<StageMetrics> stageMetrics = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      transforms = Lists.newArrayListWithCapacity(stageList.size());\n\n      BatchSource source = context.newPluginInstance(sourcePluginId);\n      BatchSourceContext batchSourceContext = new MapReduceSourceContext(context, mapperMetrics, sourcePluginId);\n      source.initialize(batchSourceContext);\n      pipeline.add(source);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SOURCE, etlConfig.getSource().getName()));\n\n      addTransforms(stageList, pipeline, stageMetrics, transformIds, context);\n\n      BatchSink sink = context.newPluginInstance(sinkPluginId);\n      BatchSinkContext batchSinkContext = new MapReduceSinkContext(context, mapperMetrics, sinkPluginId);\n      sink.initialize(batchSinkContext);\n      pipeline.add(sink);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SINK, etlConfig.getSink().getName()));\n\n      transformExecutor = new TransformExecutor<>(pipeline, stageMetrics);\n    }","commit_id":"e002acab5729f85fe225b62aea5492c8928d188b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configureAdapter(String adapterName, T etlConfig, AdapterConfigurer configurer) throws Exception {\n    ETLStage sourceConfig = etlConfig.getSource();\n    ETLStage sinkConfig = etlConfig.getSink();\n    List<ETLStage> transformConfigs = etlConfig.getTransforms().or(Lists.<ETLStage>newArrayList());\n    String sourcePluginId = String.format(\"%s%s%s\", Constants.Source.PLUGINTYPE, Constants.ID_SEPARATOR,\n                                          sourceConfig.getName());\n    String sinkPluginId = String.format(\"%s%s%s\", Constants.Sink.PLUGINTYPE, Constants.ID_SEPARATOR,\n                                        sinkConfig.getName());\n\n    // Instantiate Source, Transforms, Sink stages.\n    // Use the plugin name as the plugin id for source and sink stages since there can be only one source and one sink.\n    PluginProperties sourceProperties = getPluginProperties(sourceConfig);\n    PipelineConfigurable source = configurer.usePlugin(Constants.Source.PLUGINTYPE, sourceConfig.getName(),\n                                                       sourcePluginId, sourceProperties);\n    if (source == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Source.PLUGINTYPE, sourceConfig.getName()));\n    }\n\n    PluginProperties sinkProperties = getPluginProperties(sinkConfig);\n    PipelineConfigurable sink = configurer.usePlugin(Constants.Sink.PLUGINTYPE, sinkConfig.getName(), sinkPluginId,\n                                                     sinkProperties);\n    if (sink == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Sink.PLUGINTYPE, sinkConfig.getName()));\n    }\n\n    // Store transform id list to be serialized and passed to the driver program\n    List<String> transformIds = Lists.newArrayListWithCapacity(transformConfigs.size());\n    List<Transformation> transforms = Lists.newArrayListWithCapacity(transformConfigs.size());\n    for (int i = 0; i < transformConfigs.size(); i++) {\n      ETLStage transformConfig = transformConfigs.get(i);\n\n      // Generate a transformId based on transform name and the array index (since there could\n      // multiple transforms - ex, N filter transforms in the same pipeline)\n      String transformId = String.format(\"%s%s%d\", transformConfig.getName(), Constants.ID_SEPARATOR, i);\n      PluginProperties transformProperties = getPluginProperties(transformConfig);\n      Transform transformObj = configurer.usePlugin(Constants.Transform.PLUGINTYPE, transformConfig.getName(),\n                                                    transformId, transformProperties);\n      if (transformObj == null) {\n        throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                         Constants.Transform.PLUGINTYPE, transformConfig.getName()));\n      }\n\n      transformIds.add(transformId);\n      transforms.add(transformObj);\n    }\n\n    // Validate Source -> Transform -> Sink hookup\n    validateStages(source, sink, transforms);\n\n    configure(source, configurer, sourcePluginId);\n    configure(sink, configurer, sinkPluginId);\n\n    configurer.addRuntimeArgument(Constants.ADAPTER_NAME, adapterName);\n    configurer.addRuntimeArgument(Constants.Source.PLUGINID, sourcePluginId);\n    configurer.addRuntimeArgument(Constants.Sink.PLUGINID, sinkPluginId);\n    configurer.addRuntimeArgument(Constants.Transform.PLUGINIDS, GSON.toJson(transformIds));\n\n    Resources resources = etlConfig.getResources();\n    if (resources != null) {\n      configurer.setResources(resources);\n    }\n  }","id":84433,"modified_method":"@Override\n  public void configureAdapter(String adapterName, T etlConfig, AdapterConfigurer configurer) throws Exception {\n    ETLStage sourceConfig = etlConfig.getSource();\n    ETLStage sinkConfig = etlConfig.getSink();\n    List<ETLStage> transformConfigs = etlConfig.getTransforms();\n    String sourcePluginId = String.format(\"%s%s%s\", Constants.Source.PLUGINTYPE, Constants.ID_SEPARATOR,\n                                          sourceConfig.getName());\n    String sinkPluginId = String.format(\"%s%s%s\", Constants.Sink.PLUGINTYPE, Constants.ID_SEPARATOR,\n                                        sinkConfig.getName());\n\n    // Instantiate Source, Transforms, Sink stages.\n    // Use the plugin name as the plugin id for source and sink stages since there can be only one source and one sink.\n    PluginProperties sourceProperties = getPluginProperties(sourceConfig);\n    PipelineConfigurable source = configurer.usePlugin(Constants.Source.PLUGINTYPE, sourceConfig.getName(),\n                                                       sourcePluginId, sourceProperties);\n    if (source == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Source.PLUGINTYPE, sourceConfig.getName()));\n    }\n\n    PluginProperties sinkProperties = getPluginProperties(sinkConfig);\n    PipelineConfigurable sink = configurer.usePlugin(Constants.Sink.PLUGINTYPE, sinkConfig.getName(), sinkPluginId,\n                                                     sinkProperties);\n    if (sink == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Sink.PLUGINTYPE, sinkConfig.getName()));\n    }\n\n    // Store transform id list to be serialized and passed to the driver program\n    List<String> transformIds = Lists.newArrayListWithCapacity(transformConfigs.size());\n    List<Transformation> transforms = Lists.newArrayListWithCapacity(transformConfigs.size());\n    for (int i = 0; i < transformConfigs.size(); i++) {\n      ETLStage transformConfig = transformConfigs.get(i);\n\n      // Generate a transformId based on transform name and the array index (since there could\n      // multiple transforms - ex, N filter transforms in the same pipeline)\n      String transformId = String.format(\"%s%s%d\", transformConfig.getName(), Constants.ID_SEPARATOR, i);\n      PluginProperties transformProperties = getPluginProperties(transformConfig);\n      Transform transformObj = configurer.usePlugin(Constants.Transform.PLUGINTYPE, transformConfig.getName(),\n                                                    transformId, transformProperties);\n      if (transformObj == null) {\n        throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                         Constants.Transform.PLUGINTYPE, transformConfig.getName()));\n      }\n\n      transformIds.add(transformId);\n      transforms.add(transformObj);\n    }\n\n    // Validate Source -> Transform -> Sink hookup\n    validateStages(source, sink, transforms);\n\n    configure(source, configurer, sourcePluginId);\n    configure(sink, configurer, sinkPluginId);\n\n    configurer.addRuntimeArgument(Constants.ADAPTER_NAME, adapterName);\n    configurer.addRuntimeArgument(Constants.Source.PLUGINID, sourcePluginId);\n    configurer.addRuntimeArgument(Constants.Sink.PLUGINID, sinkPluginId);\n    configurer.addRuntimeArgument(Constants.Transform.PLUGINIDS, GSON.toJson(transformIds));\n\n    Resources resources = etlConfig.getResources();\n    if (resources != null) {\n      configurer.setResources(resources);\n    }\n  }","commit_id":"e002acab5729f85fe225b62aea5492c8928d188b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void initialize(final WorkerContext context) throws Exception {\n    super.initialize(context);\n    Map<String, String> runtimeArgs = context.getRuntimeArguments();\n\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.ADAPTER_NAME));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.CONFIG_KEY));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Source.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Sink.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Transform.PLUGINIDS));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Realtime.UNIQUE_ID));\n\n    adapterName = runtimeArgs.get(Constants.ADAPTER_NAME);\n    // Each worker instance should have its own unique state.\n    stateStoreKey = String.format(\"%s%s%s%s%s\", adapterName, SEPARATOR, runtimeArgs.get(Constants.Realtime.UNIQUE_ID),\n                                  SEPARATOR, context.getInstanceId());\n    stateStoreKeyBytes = Bytes.toBytes(stateStoreKey);\n    final ETLRealtimeConfig config = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLRealtimeConfig.class);\n\n    // Cleanup the rows in statetable for runs with same adapter name but other runids.\n    getContext().execute(new TxRunnable() {\n      @Override\n      public void run(DatasetContext dsContext) throws Exception {\n        KeyValueTable stateTable = dsContext.getDataset(ETLRealtimeTemplate.STATE_TABLE);\n        byte[] startKey = Bytes.toBytes(String.format(\"%s%s\", adapterName, SEPARATOR));\n        // Scan the table for adaptername: prefixes and remove rows which doesn't match the unique id of this adapter.\n        CloseableIterator<KeyValue<byte[], byte[]>> rows = stateTable.scan(startKey, Bytes.stopKeyForPrefix(startKey));\n        try {\n          while (rows.hasNext()) {\n            KeyValue<byte[], byte[]> row = rows.next();\n            if (Bytes.compareTo(stateStoreKeyBytes, row.getKey()) != 0) {\n              stateTable.delete(row.getKey());\n            }\n          }\n        } finally {\n          rows.close();\n        }\n      }\n    });\n\n    initializeSource(context, config.getSource());\n    List<Transformation> transforms = initializeTransforms(context,\n                                                           config.getTransforms().or(Lists.<ETLStage>newArrayList()));\n    initializeSink(context, config.getSink());\n\n    transformExecutor = new TransformExecutor(transforms, transformMetrics);\n  }","id":84434,"modified_method":"@Override\n  public void initialize(final WorkerContext context) throws Exception {\n    super.initialize(context);\n    Map<String, String> runtimeArgs = context.getRuntimeArguments();\n\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.ADAPTER_NAME));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.CONFIG_KEY));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Source.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Sink.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Transform.PLUGINIDS));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Realtime.UNIQUE_ID));\n\n    adapterName = runtimeArgs.get(Constants.ADAPTER_NAME);\n    // Each worker instance should have its own unique state.\n    stateStoreKey = String.format(\"%s%s%s%s%s\", adapterName, SEPARATOR, runtimeArgs.get(Constants.Realtime.UNIQUE_ID),\n                                  SEPARATOR, context.getInstanceId());\n    stateStoreKeyBytes = Bytes.toBytes(stateStoreKey);\n    final ETLRealtimeConfig config = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLRealtimeConfig.class);\n\n    // Cleanup the rows in statetable for runs with same adapter name but other runids.\n    getContext().execute(new TxRunnable() {\n      @Override\n      public void run(DatasetContext dsContext) throws Exception {\n        KeyValueTable stateTable = dsContext.getDataset(ETLRealtimeTemplate.STATE_TABLE);\n        byte[] startKey = Bytes.toBytes(String.format(\"%s%s\", adapterName, SEPARATOR));\n        // Scan the table for adaptername: prefixes and remove rows which doesn't match the unique id of this adapter.\n        CloseableIterator<KeyValue<byte[], byte[]>> rows = stateTable.scan(startKey, Bytes.stopKeyForPrefix(startKey));\n        try {\n          while (rows.hasNext()) {\n            KeyValue<byte[], byte[]> row = rows.next();\n            if (Bytes.compareTo(stateStoreKeyBytes, row.getKey()) != 0) {\n              stateTable.delete(row.getKey());\n            }\n          }\n        } finally {\n          rows.close();\n        }\n      }\n    });\n\n    initializeSource(context, config.getSource());\n    List<Transformation> transforms = initializeTransforms(context, config.getTransforms());\n    initializeSink(context, config.getSink());\n\n    transformExecutor = new TransformExecutor(transforms, transformMetrics);\n  }","commit_id":"e002acab5729f85fe225b62aea5492c8928d188b","url":"https://github.com/caskdata/cdap"},{"original_method":"protected void handleControlStart(String uri, String localname, String qName, Attributes attributes, String staticId, String effectiveId, XFormsControl control) throws SAXException {\n\n        final XFormsTextareaControl textareaControl = (XFormsTextareaControl) control;\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final boolean isConcreteControl = textareaControl != null;\n\n        final AttributesImpl containerAttributes = getContainerAttributes(uri, localname, attributes, effectiveId, control, true);\n\n        // Create xhtml:textarea\n        {\n            final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n            if (!isStaticReadonly(textareaControl)) {\n                final String textareaQName = XMLUtils.buildQName(xhtmlPrefix, \"textarea\");\n                containerAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n\n                // Handle accessibility attributes\n                handleAccessibilityAttributes(attributes, containerAttributes);\n\n                // Output all extension attributes\n                if (isConcreteControl) {\n                    // Output xxforms:* extension attributes\n                    textareaControl.addExtensionAttributes(reusableAttributes, XFormsConstants.XXFORMS_NAMESPACE_URI);\n                }\n\n                handleReadOnlyAttribute(reusableAttributes, containingDocument, textareaControl);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName, containerAttributes);\n                if (isConcreteControl) {\n                    final String value = textareaControl.getExternalValue(pipelineContext);\n                    if (value != null)\n                        contentHandler.characters(value.toCharArray(), 0, value.length());\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName);\n            } else {\n                // Static readonly\n                final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, containerAttributes);\n                if (isConcreteControl) {\n                    final String value = textareaControl.getExternalValue(pipelineContext);\n                    if (value != null) {\n                        final boolean isHTMLMediaType = \"text/html\".equals(textareaControl.getMediatype());\n                        if (!isHTMLMediaType) {\n                            // Output and replace spaces with &nbsp; so that spaces are preserved in the resulting HTML\n                            final String replaced = StringUtils.replace(value, \" \", XMLConstants.NBSP);\n                            contentHandler.characters(replaced.toCharArray(), 0, replaced.length());\n                        } else {\n                            XFormsUtils.streamHTMLFragment(contentHandler, value, textareaControl.getLocationData(), xhtmlPrefix);\n                        }\n                    }\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n        }\n    }","id":84435,"modified_method":"protected void handleControlStart(String uri, String localname, String qName, Attributes attributes, String staticId, String effectiveId, XFormsControl control) throws SAXException {\n\n        final XFormsTextareaControl textareaControl = (XFormsTextareaControl) control;\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final boolean isConcreteControl = textareaControl != null;\n\n        final AttributesImpl containerAttributes = getContainerAttributes(uri, localname, attributes, effectiveId, control, true);\n\n        // Create xhtml:textarea\n        {\n            final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n            if (!isStaticReadonly(textareaControl)) {\n                final String textareaQName = XMLUtils.buildQName(xhtmlPrefix, \"textarea\");\n                containerAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n\n                // Handle accessibility attributes\n                handleAccessibilityAttributes(attributes, containerAttributes);\n\n                // Output all extension attributes\n                if (isConcreteControl) {\n                    // Output xxforms:* extension attributes\n                    textareaControl.addExtensionAttributes(reusableAttributes, XFormsConstants.XXFORMS_NAMESPACE_URI);\n                }\n\n                handleReadOnlyAttribute(reusableAttributes, containingDocument, textareaControl);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName, containerAttributes);\n                if (isConcreteControl) {\n                    final String value = textareaControl.getExternalValue(pipelineContext);\n                    if (value != null)\n                        contentHandler.characters(value.toCharArray(), 0, value.length());\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName);\n            } else {\n                // Static readonly\n\n                // For now the mediatype is known statically\n                final boolean isHTMLMediaType = \"text/html\".equals(attributes.getValue(\"mediatype\"));\n\n                // Use <pre> in text/plain so that spaces are kept by the serializer\n                final String containerName = isHTMLMediaType ? \"span\" : \"pre\";\n                final String containerQName = XMLUtils.buildQName(xhtmlPrefix, containerName);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, containerName, containerQName, containerAttributes);\n                if (isConcreteControl) {\n                    final String value = textareaControl.getExternalValue(pipelineContext);\n                    if (value != null) {\n                        if (!isHTMLMediaType) {\n                            // NOTE: Don't replace spaces with &nbsp;, as this is not the right algorithm for all cases\n                            contentHandler.characters(value.toCharArray(), 0, value.length());\n                        } else {\n                            XFormsUtils.streamHTMLFragment(contentHandler, value, textareaControl.getLocationData(), xhtmlPrefix);\n                        }\n                    }\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, containerName, containerQName);\n            }\n        }\n    }","commit_id":"934a8f80124e6d7a4405e2f865709e002c4adb08","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        effectiveGroupId = handlerContext.getEffectiveId(attributes);\n\n        // Find classes to add\n        final StringBuffer classes = getInitialClasses(localname, attributes, null);\n        if (!handlerContext.isGenerateTemplate()) {\n            groupXFormsControl = ((XFormsControl) containingDocument.getObjectById(handlerContext.getPipelineContext(), effectiveGroupId));\n\n            HandlerBase.handleMIPClasses(classes, groupXFormsControl);\n        }\n\n        // Start xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n        handlerContext.getController().getOutput().startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, getAttributes(attributes, classes.toString(), effectiveGroupId));\n\n        // xforms:label\n        final String labelValue = handlerContext.isGenerateTemplate() ? null : groupXFormsControl.getLabel();\n        if (labelValue != null) {\n            final AttributesImpl labelAttributes = getAttributes(attributes, \"xforms-label\", null);\n            outputLabelHintHelpAlert(handlerContext, labelAttributes, effectiveGroupId, labelValue);\n        }\n\n        // NOTE: This doesn't work because attributes for the label are only gathered after start()\n//        handleLabelHintHelpAlert(effectiveGroupId, \"label\", groupXFormsControl);\n    }","id":84436,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        effectiveGroupId = handlerContext.getEffectiveId(attributes);\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        isFieldsetAppearance = XFormsConstants.XXFORMS_FIELDSET_APPEARANCE_QNAME.equals(getAppearance(attributes));\n\n        // Find classes to add\n        final StringBuffer classes = getInitialClasses(localname, attributes, null);\n        if (!handlerContext.isGenerateTemplate()) {\n            groupXFormsControl = ((XFormsControl) containingDocument.getObjectById(handlerContext.getPipelineContext(), effectiveGroupId));\n\n            HandlerBase.handleMIPClasses(classes, groupXFormsControl);\n        }\n\n        // Start xhtml:span or xhtml:fieldset\n        final String groupElementName = isFieldsetAppearance ? \"fieldset\" : \"span\";\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String groupElementQName = XMLUtils.buildQName(xhtmlPrefix, groupElementName);\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, groupElementName, groupElementQName, getAttributes(attributes, classes.toString(), effectiveGroupId));\n\n        // xforms:label\n        final String labelValue = handlerContext.isGenerateTemplate() ? null : groupXFormsControl.getLabel();\n        if (labelValue != null) {\n            final AttributesImpl labelAttributes = getAttributes(attributes, \"xforms-label\", null);\n            if (isFieldsetAppearance) {\n                // Output an xhtml:legend element\n                final String legendQName = XMLUtils.buildQName(xhtmlPrefix, \"legend\");\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"legend\", legendQName, labelAttributes);\n                contentHandler.characters(labelValue.toCharArray(), 0, labelValue.length());\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"legend\", legendQName);\n            } else {\n                // Output an xhtml:label element\n                outputLabelHintHelpAlert(handlerContext, labelAttributes, effectiveGroupId, labelValue);\n            }\n        }\n\n        // NOTE: This doesn't work because attributes for the label are only gathered after start()\n//        handleLabelHintHelpAlert(effectiveGroupId, \"label\", groupXFormsControl);\n    }","commit_id":"e5b87e41193cb60044363a44c9d436ed157c435f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        // Close xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n        handlerContext.getController().getOutput().endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveGroupId, \"help\", groupXFormsControl, false);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveGroupId, \"alert\", groupXFormsControl, false);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveGroupId, \"hint\", groupXFormsControl, false);\n    }","id":84437,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        // Close xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String groupElementName = isFieldsetAppearance ? \"fieldset\" : \"span\";\n        final String groupElementQName = XMLUtils.buildQName(xhtmlPrefix, groupElementName);\n        handlerContext.getController().getOutput().endElement(XMLConstants.XHTML_NAMESPACE_URI, groupElementName, groupElementQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveGroupId, \"help\", groupXFormsControl, false);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveGroupId, \"alert\", groupXFormsControl, false);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveGroupId, \"hint\", groupXFormsControl, false);\n    }","commit_id":"e5b87e41193cb60044363a44c9d436ed157c435f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.OutputControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.OutputControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDateOrTime;\n        final StringBuffer classes = new StringBuffer(\"xforms-control xforms-output\");\n\n        final String appearanceValue = elementAttributes.getValue(\"appearance\");\n        final String appearanceLocalname = (appearanceValue == null) ? null : XMLUtils.localNameFromQName(appearanceValue);\n        final String appearanceURI = (appearanceValue == null) ? null : uriFromQName(appearanceValue);\n\n        final String mediatypeValue = elementAttributes.getValue(\"mediatype\");\n        final boolean isImage = mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n        final boolean isHTML = ( mediatypeValue != null && mediatypeValue.equals(\"text/html\"))\n                || (appearanceValue != null && XFormsConstants.XXFORMS_NAMESPACE_URI.equals(appearanceURI) && \"html\".equals(appearanceLocalname));\n\n        if (isHTML) {\n            classes.append(\" xforms-output-html\");\n        } else if (isImage) {\n            classes.append(\" xforms-output-image\");\n        }\n\n        if (!handlerContext.isGenerateTemplate()) {\n\n            // Find classes to add\n            isDateOrTime = isDateOrTime(controlInfo.getType());\n            if (isDateOrTime) {\n                classes.append(\" xforms-date\");\n            }\n            handleMIPClasses(classes, controlInfo);\n\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            handleReadOnlyAttribute(newAttributes, controlInfo);\n        } else {\n            isDateOrTime = false;\n\n            // Find classes to add\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        }\n\n        // Create xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        if (!handlerContext.isGenerateTemplate()) {\n            if (isImage) {\n                // Case of image media type with URI\n                final String imgQName = XMLUtils.buildQName(xhtmlPrefix, \"img\");\n                final AttributesImpl imgAttributes = new AttributesImpl();\n                // @src=\"...\"\n                imgAttributes.addAttribute(\"\", \"src\", \"src\", ContentHandlerHelper.CDATA, controlInfo.getValue());\n                // @f:url-norewrite=\"true\"\n                final String formattingPrefix;\n                final boolean isNewPrefix;\n                {\n                    final String existingFormattingPrefix = handlerContext.findFormattingPrefix();\n                    if (existingFormattingPrefix == null || \"\".equals(existingFormattingPrefix)) {\n                        // No prefix is currently mapped\n                        formattingPrefix = handlerContext.findNewPrefix();\n                        isNewPrefix = true;\n                    } else {\n                        formattingPrefix = existingFormattingPrefix;\n                        isNewPrefix = false;\n                    }\n                    imgAttributes.addAttribute(XMLConstants.OPS_FORMATTING_URI, \"url-norewrite\", XMLUtils.buildQName(formattingPrefix, \"url-norewrite\"), ContentHandlerHelper.CDATA, \"true\");\n                }\n                if (isNewPrefix)\n                    contentHandler.startPrefixMapping(formattingPrefix, XMLConstants.OPS_FORMATTING_URI);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName, imgAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName);\n                if (isNewPrefix)\n                    contentHandler.endPrefixMapping(formattingPrefix);\n            } else if (isDateOrTime) {\n                // Display formatted value for dates\n                final String displayValue = controlInfo.getDisplayValue();\n                contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            } else {\n                // Regular text case\n                final String value = controlInfo.getValue();\n                if (value != null)\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","id":84438,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.OutputControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.OutputControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDateOrTime;\n        final StringBuffer classes = new StringBuffer(\"xforms-control xforms-output\");\n\n        final String appearanceValue = elementAttributes.getValue(\"appearance\");\n        final String appearanceLocalname = (appearanceValue == null) ? null : XMLUtils.localNameFromQName(appearanceValue);\n        final String appearanceURI = (appearanceValue == null) ? null : uriFromQName(appearanceValue);\n\n        final String mediatypeValue = elementAttributes.getValue(\"mediatype\");\n        final boolean isImage = mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n        final boolean isHTML = (mediatypeValue != null && mediatypeValue.equals(\"text/html\"))\n                || (appearanceValue != null && XFormsConstants.XXFORMS_NAMESPACE_URI.equals(appearanceURI) && \"html\".equals(appearanceLocalname));\n\n        if (isHTML) {\n            classes.append(\" xforms-output-html\");\n        } else if (isImage) {\n            classes.append(\" xforms-output-image\");\n        }\n\n        if (!handlerContext.isGenerateTemplate()) {\n\n            // Find classes to add\n            isDateOrTime = isDateOrTime(controlInfo.getType());\n            if (isDateOrTime) {\n                classes.append(\" xforms-date\");\n            }\n            handleMIPClasses(classes, controlInfo);\n\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            handleReadOnlyAttribute(newAttributes, controlInfo);\n        } else {\n            isDateOrTime = false;\n\n            // Find classes to add\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        }\n\n        // Create xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String enclosingElementLocalname = isHTML ? \"div\" : \"span\";\n        final String enclosingElementQName = XMLUtils.buildQName(xhtmlPrefix, enclosingElementLocalname);\n\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, enclosingElementLocalname, enclosingElementQName, newAttributes);\n        if (!handlerContext.isGenerateTemplate()) {\n            if (isImage) {\n                // Case of image media type with URI\n                final String imgQName = XMLUtils.buildQName(xhtmlPrefix, \"img\");\n                final AttributesImpl imgAttributes = new AttributesImpl();\n                // @src=\"...\"\n                imgAttributes.addAttribute(\"\", \"src\", \"src\", ContentHandlerHelper.CDATA, controlInfo.getValue());\n                // @f:url-norewrite=\"true\"\n                final String formattingPrefix;\n                final boolean isNewPrefix;\n                {\n                    final String existingFormattingPrefix = handlerContext.findFormattingPrefix();\n                    if (existingFormattingPrefix == null || \"\".equals(existingFormattingPrefix)) {\n                        // No prefix is currently mapped\n                        formattingPrefix = handlerContext.findNewPrefix();\n                        isNewPrefix = true;\n                    } else {\n                        formattingPrefix = existingFormattingPrefix;\n                        isNewPrefix = false;\n                    }\n                    imgAttributes.addAttribute(XMLConstants.OPS_FORMATTING_URI, \"url-norewrite\", XMLUtils.buildQName(formattingPrefix, \"url-norewrite\"), ContentHandlerHelper.CDATA, \"true\");\n                }\n                if (isNewPrefix)\n                    contentHandler.startPrefixMapping(formattingPrefix, XMLConstants.OPS_FORMATTING_URI);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName, imgAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName);\n                if (isNewPrefix)\n                    contentHandler.endPrefixMapping(formattingPrefix);\n            } else if (isDateOrTime) {\n                // Display formatted value for dates\n                final String displayValue = controlInfo.getDisplayValue();\n                contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            } else {\n                // Regular text case\n                final String value = controlInfo.getValue();\n                if (value != null)\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, enclosingElementLocalname, enclosingElementQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","commit_id":"e592b6e3929c70a183ce66838754a1c18d2b1416","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void updateRevisionsList() {\n    if (myIsInLoading) return;\n\n    List<VcsFileRevision> newItems;\n    if (myChangesOnlyCheckBox.isSelected()) {\n      try {\n        loadContentsFor(myRevisions.toArray(new VcsFileRevision[myRevisions.size()]));\n        newItems = filteredRevisions();\n      }\n      catch (final VcsException e) {\n        // todo test it, always exception\n        canNotLoadRevisionMessage(e);\n        return;\n      }\n    }\n    else {\n      newItems = myRevisions;\n    }\n\n    myListModel.setItems(newItems);\n    myList.getSelectionModel().setSelectionInterval(0, 0);\n  }","id":84439,"modified_method":"private void updateRevisionsList() {\n    if (myIsDuringUpdate) return;\n    try {\n      myIsDuringUpdate = true;\n\n      List<VcsFileRevision> newItems;\n      if (myChangesOnlyCheckBox.isSelected()) {\n        try {\n          loadContentsFor(myRevisions.toArray(new VcsFileRevision[myRevisions.size()]));\n          newItems = filteredRevisions();\n        }\n        catch (final VcsException e) {\n          // todo test it, always exception\n          canNotLoadRevisionMessage(e);\n          return;\n        }\n      }\n      else {\n        newItems = myRevisions;\n      }\n\n      List<VcsFileRevision> oldSelection = getSelectedRevisions();\n\n      myListModel.setItems(newItems);\n\n      myList.setSelection(oldSelection);\n      if (myList.getSelectedRowCount() == 0) {\n        int index = getNearestVisibleRevision(ContainerUtil.getFirstItem(oldSelection));\n        myList.getSelectionModel().setSelectionInterval(index, index);\n      }\n    }\n    finally {\n      myIsDuringUpdate = false;\n    }\n\n    updateDiff();\n  }","commit_id":"72779ed7e9a224e93d7845f40ca7983bd9c2ebbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateDiff(int first, int second) {\n    if (myIsDisposed || myIsInLoading) return;\n\n    VcsFileRevision firstRev = myListModel.getRowValue(first);\n    VcsFileRevision secondRev = myListModel.getRowValue(second);\n\n    DiffRequest diffRequest = createDiffRequest(firstRev, secondRev);\n    myDiffPanel.setRequest(diffRequest);\n  }","id":84440,"modified_method":"private void updateDiff(int first, int second) {\n    if (myIsDisposed || myIsDuringUpdate) return;\n\n    VcsFileRevision firstRev = myListModel.getRowValue(first);\n    VcsFileRevision secondRev = myListModel.getRowValue(second);\n\n    DiffRequest diffRequest = createDiffRequest(firstRev, secondRev);\n    myDiffPanel.setRequest(diffRequest);\n  }","commit_id":"72779ed7e9a224e93d7845f40ca7983bd9c2ebbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getPreferredFocusedComponent() {\n    if (myParametersTableModel.getRowCount() > 0) {\n      final JTable table = myParametersTable.getComponent();\n      table.getSelectionModel().setSelectionInterval(0,0);\n      table.getColumnModel().getSelectionModel().setSelectionInterval(0, 0);\n      return table;\n    } else {\n      return myNameField == null ? super.getPreferredFocusedComponent() : myNameField;\n    }\n  }","id":84441,"modified_method":"public JComponent getPreferredFocusedComponent() {\n    if (myParametersTableModel.getRowCount() > 0) {\n      final JTable table = myParametersTable.getComponent();\n      if (table.getColumnModel().getSelectedColumnCount() == 0) {\n        table.getSelectionModel().setSelectionInterval(0,0);\n        table.getColumnModel().getSelectionModel().setSelectionInterval(0, 0);\n      }\n      return table;\n    } else {\n      return myNameField == null ? super.getPreferredFocusedComponent() : myNameField;\n    }\n  }","commit_id":"213575547a1ba1daa12ec182b75f0f3d5460d8ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JPanel createParametersPanel() {\n    myParametersTable = new TableView<ParameterTableModelItemBase<P>>(myParametersTableModel) {\n      @Override\n      public void editingStopped(ChangeEvent e) {\n        super.editingStopped(e);\n        repaint(); // to update disabled cells background\n      }\n\n      @Nullable\n      @Override\n      public TableCellEditor getCellEditor(int row, int column) {\n        final TableCellEditor editor = super.getCellEditor(row, column);\n        final DocumentAdapter listener = new DocumentAdapter() {\n          @Override\n          public void documentChanged(DocumentEvent e) {\n            final TableCellEditor ed = myParametersTable.getCellEditor();\n            if (ed != null) {\n              Object editorValue = ed.getCellEditorValue();\n              myParametersTableModel.setValueAtWithoutUpdate(editorValue, myParametersTable.getSelectedRow(), myParametersTable.getSelectedColumn());\n              updateSignature();\n            }\n          }\n        };\n\n        if (editor instanceof StringTableCellEditor) {\n          final StringTableCellEditor ed = (StringTableCellEditor)editor;\n          ed.addDocumentListener(listener);\n        } else if (editor instanceof CodeFragmentTableCellEditorBase) {\n          ((CodeFragmentTableCellEditorBase)editor).addDocumentListener(listener);\n        }\n        return editor;\n      }\n    };\n    myParametersTable.setCellSelectionEnabled(true);\n    myParametersTable.setRowSelectionAllowed(false);\n    myParametersTable.setColumnSelectionAllowed(false);\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(IdeBorderFactory.createTitledBorder(RefactoringBundle.message(\"parameters.border.title\")));\n\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myParametersTable);\n\n    JPanel tablePanel = new JPanel(new BorderLayout());\n    tablePanel.add(scrollPane, BorderLayout.CENTER);\n\n    tablePanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    panel.add(tablePanel, BorderLayout.CENTER);\n\n    myParametersTable.setPreferredScrollableViewportSize(new Dimension(450, myParametersTable.getRowHeight() * 8));\n    myParametersTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myParametersTable.getSelectionModel().setSelectionInterval(0, 0);\n    myParametersTable.setSurrendersFocusOnKeystroke(true);\n    myPropagateParamChangesButton.setShortcut(KeyboardShortcut.fromString(\"alt G\"));\n    final JPanel buttonsPanel = EditableRowTable.createButtonsTable(myParametersTable, myParametersTableModel,\n                                                              false, true, false, myPropagateParamChangesButton);\n    myPropagateParamChangesButton.setEnabled(false);\n    myPropagateParamChangesButton.setVisible(false);\n    panel.add(buttonsPanel, BorderLayout.EAST);\n\n    myParametersTableModel.addTableModelListener(\n      new TableModelListener() {\n        public void tableChanged(TableModelEvent e) {\n          updateSignature();\n        }\n      }\n    );\n\n    customizeParametersTable(myParametersTable);\n\n    return panel;\n  }","id":84442,"modified_method":"protected JPanel createParametersPanel() {\n    myParametersTable = new TableView<ParameterTableModelItemBase<P>>(myParametersTableModel) {\n      @Override\n      public void editingStopped(ChangeEvent e) {\n        super.editingStopped(e);\n        repaint(); // to update disabled cells background\n      }\n\n      @Nullable\n      @Override\n      public TableCellEditor getCellEditor(int row, int column) {\n        final TableCellEditor editor = super.getCellEditor(row, column);\n        final DocumentAdapter listener = new DocumentAdapter() {\n          @Override\n          public void documentChanged(DocumentEvent e) {\n            final TableCellEditor ed = myParametersTable.getCellEditor();\n            if (ed != null) {\n              Object editorValue = ed.getCellEditorValue();\n              myParametersTableModel.setValueAtWithoutUpdate(editorValue, myParametersTable.getSelectedRow(), myParametersTable.getSelectedColumn());\n              updateSignature();\n            }\n          }\n        };\n\n        if (editor instanceof StringTableCellEditor) {\n          final StringTableCellEditor ed = (StringTableCellEditor)editor;\n          ed.addDocumentListener(listener);\n        } else if (editor instanceof CodeFragmentTableCellEditorBase) {\n          ((CodeFragmentTableCellEditorBase)editor).addDocumentListener(listener);\n        }\n        return editor;\n      }\n    };\n    myParametersTable.setCellSelectionEnabled(true);\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(IdeBorderFactory.createTitledBorder(RefactoringBundle.message(\"parameters.border.title\")));\n\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myParametersTable);\n\n    JPanel tablePanel = new JPanel(new BorderLayout());\n    tablePanel.add(scrollPane, BorderLayout.CENTER);\n\n    tablePanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    panel.add(tablePanel, BorderLayout.CENTER);\n\n    myParametersTable.setPreferredScrollableViewportSize(new Dimension(450, myParametersTable.getRowHeight() * 8));\n    myParametersTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myParametersTable.getSelectionModel().setSelectionInterval(0, 0);\n    myParametersTable.setSurrendersFocusOnKeystroke(true);\n    myPropagateParamChangesButton.setShortcut(KeyboardShortcut.fromString(\"alt G\"));\n    final JPanel buttonsPanel = EditableRowTable.createButtonsTable(myParametersTable, myParametersTableModel,\n                                                              false, true, false, myPropagateParamChangesButton);\n    myPropagateParamChangesButton.setEnabled(false);\n    myPropagateParamChangesButton.setVisible(false);\n    panel.add(buttonsPanel, BorderLayout.EAST);\n\n    myParametersTableModel.addTableModelListener(\n      new TableModelListener() {\n        public void tableChanged(TableModelEvent e) {\n          updateSignature();\n        }\n      }\n    );\n\n    customizeParametersTable(myParametersTable);\n\n    return panel;\n  }","commit_id":"213575547a1ba1daa12ec182b75f0f3d5460d8ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testDfsQueryThenFetchWithSort() throws Exception {\n        prepareData();\n\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"multi\", \"test\"))\n                .from(0).size(60).explain(true).sort(\"age\", SortOrder.ASC);\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(DFS_QUERY_THEN_FETCH).scroll(new Scroll(timeValueMinutes(10)))).actionGet();\n        assertNoFailures(searchResponse);\n        assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n        assertThat(searchResponse.getHits().hits().length, equalTo(60));\n        for (int i = 0; i < 60; i++) {\n            SearchHit hit = searchResponse.getHits().hits()[i];\n            assertThat(hit.explanation(), notNullValue());\n            assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(i)));\n        }\n\n        searchResponse = client().searchScroll(searchScrollRequest(searchResponse.getScrollId())).actionGet();\n\n        assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n        assertThat(searchResponse.getHits().hits().length, equalTo(40));\n        for (int i = 0; i < 40; i++) {\n            SearchHit hit = searchResponse.getHits().hits()[i];\n            assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(i + 60)));\n        }\n    }","id":84443,"modified_method":"@Test\n    public void testDfsQueryThenFetchWithSort() throws Exception {\n        prepareData();\n\n        int total = 0;\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSearchType(DFS_QUERY_THEN_FETCH).setQuery(termQuery(\"multi\", \"test\")).setSize(60).setExplain(true).addSort(\"age\", SortOrder.ASC).setScroll(TimeValue.timeValueSeconds(30)).get();\n        while (true) {\n            assertNoFailures(searchResponse);\n            assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n            SearchHit[] hits = searchResponse.getHits().hits();\n            if (hits.length == 0) {\n                break; // finished\n            }\n            for (int i = 0; i < hits.length; ++i) {\n                SearchHit hit = hits[i];\n                assertThat(hit.explanation(), notNullValue());\n                assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(total + i)));\n            }\n            total += hits.length;\n            searchResponse = client().prepareSearchScroll(searchResponse.getScrollId()).setScroll(TimeValue.timeValueSeconds(30)).get();\n        }\n        clearScroll(searchResponse.getScrollId());\n        assertEquals(100, total);\n    }","commit_id":"d9515e9717d25f82af132b5b152686f6e0943e1b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testQueryThenFetch() throws Exception {\n        prepareData();\n\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"multi\", \"test\"))\n                .sort(\"nid\", SortOrder.DESC) // we have to sort here to have some ordering with dist scoring\n                .from(0).size(60).explain(true);\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH).scroll(new Scroll(timeValueMinutes(10)))).actionGet();\n        assertNoFailures(searchResponse);\n        assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n        assertThat(searchResponse.getHits().hits().length, equalTo(60));\n        for (int i = 0; i < 60; i++) {\n            SearchHit hit = searchResponse.getHits().hits()[i];\n            assertThat(hit.explanation(), notNullValue());\n            assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(100 - i - 1)));\n        }\n\n        searchResponse = client().searchScroll(searchScrollRequest(searchResponse.getScrollId())).actionGet();\n\n        assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n        assertThat(searchResponse.getHits().hits().length, equalTo(40));\n        for (int i = 0; i < 40; i++) {\n            SearchHit hit = searchResponse.getHits().hits()[i];\n            assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(100 - 60 - 1 - i)));\n        }\n    }","id":84444,"modified_method":"@Test\n    public void testQueryThenFetch() throws Exception {\n        prepareData();\n\n        int total = 0;\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSearchType(QUERY_THEN_FETCH).setQuery(termQuery(\"multi\", \"test\")).setSize(60).setExplain(true).addSort(\"nid\", SortOrder.DESC).setScroll(TimeValue.timeValueSeconds(30)).get();\n        while (true) {\n            assertNoFailures(searchResponse);\n            assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n            SearchHit[] hits = searchResponse.getHits().hits();\n            if (hits.length == 0) {\n                break; // finished\n            }\n            for (int i = 0; i < hits.length; ++i) {\n                SearchHit hit = hits[i];\n                assertThat(hit.explanation(), notNullValue());\n                assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(100 - total - i - 1)));\n            }\n            total += hits.length;\n            searchResponse = client().prepareSearchScroll(searchResponse.getScrollId()).setScroll(TimeValue.timeValueSeconds(30)).get();\n        }\n        clearScroll(searchResponse.getScrollId());\n        assertEquals(100, total);\n    }","commit_id":"d9515e9717d25f82af132b5b152686f6e0943e1b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDfsQueryThenFetch() throws Exception {\n        prepareData();\n\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"multi\", \"test\"))\n                .from(0).size(60).explain(true);\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(DFS_QUERY_THEN_FETCH).scroll(new Scroll(timeValueMinutes(10)))).actionGet();\n        assertNoFailures(searchResponse);\n\n        assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n        assertThat(searchResponse.getHits().hits().length, equalTo(60));\n        for (int i = 0; i < 60; i++) {\n            SearchHit hit = searchResponse.getHits().hits()[i];\n            assertThat(hit.explanation(), notNullValue());\n            assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(100 - i - 1)));\n        }\n\n        searchResponse = client().searchScroll(searchScrollRequest(searchResponse.getScrollId())).actionGet();\n\n        assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n        assertThat(searchResponse.getHits().hits().length, equalTo(40));\n        for (int i = 0; i < 40; i++) {\n            SearchHit hit = searchResponse.getHits().hits()[i];\n            assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(100 - 60 - 1 - i)));\n        }\n    }","id":84445,"modified_method":"@Test\n    public void testDfsQueryThenFetch() throws Exception {\n        prepareData();\n\n        int total = 0;\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSearchType(DFS_QUERY_THEN_FETCH).setQuery(termQuery(\"multi\", \"test\")).setSize(60).setExplain(true).setScroll(TimeValue.timeValueSeconds(30)).get();\n        while (true) {\n            assertNoFailures(searchResponse);\n            assertThat(searchResponse.getHits().totalHits(), equalTo(100l));\n            SearchHit[] hits = searchResponse.getHits().hits();\n            if (hits.length == 0) {\n                break; // finished\n            }\n            for (int i = 0; i < hits.length; ++i) {\n                SearchHit hit = hits[i];\n                assertThat(hit.explanation(), notNullValue());\n                assertThat(\"id[\" + hit.id() + \"]\", hit.id(), equalTo(Integer.toString(100 - total - i - 1)));\n            }\n            total += hits.length;\n            searchResponse = client().prepareSearchScroll(searchResponse.getScrollId()).setScroll(TimeValue.timeValueSeconds(30)).get();\n        }\n        clearScroll(searchResponse.getScrollId());\n        assertEquals(100, total);\n    }","commit_id":"d9515e9717d25f82af132b5b152686f6e0943e1b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GCInspector()\n    {\n        // we only want this class to do its thing on sun jdks, or when the sun classes are present.\n        Class gcBeanClass = null;\n        try\n        {\n            gcBeanClass = Class.forName(\"com.sun.management.GarbageCollectorMXBean\");\n            Class.forName(\"com.sun.management.GcInfo\");\n        }\n        catch (ClassNotFoundException ex)\n        {\n            // this happens when using a non-sun jdk.\n            logger.warn(\"Cannot load sun GC monitoring classes. GCInspector is disabled.\");\n        }\n        \n        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        try\n        {\n            ObjectName gcName = new ObjectName(ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + \",*\");\n            for (ObjectName name : server.queryNames(gcName, null))\n            {\n                Object gc = ManagementFactory.newPlatformMXBeanProxy(server, name.getCanonicalName(), gcBeanClass);\n                beans.add(gc);\n            }\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","id":84446,"modified_method":"public GCInspector()\n    {\n        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        try\n        {\n            ObjectName gcName = new ObjectName(ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + \",*\");\n            for (ObjectName name : server.queryNames(gcName, null))\n            {\n                GarbageCollectorMXBean gc = ManagementFactory.newPlatformMXBeanProxy(server, name.getCanonicalName(), GarbageCollectorMXBean.class);\n                beans.add(gc);\n            }\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"aeaab2445e3fcc022ee3d1c92eda8a56dd509b5a","url":"https://github.com/apache/cassandra"},{"original_method":"private void logGCResults()\n    {\n        for (Object gc : beans)\n        {\n            SunGcWrapper gcw = new SunGcWrapper(gc);\n            if (gcw.isLastGcInfoNull())\n                continue;\n\n            Long previous = gctimes.get(gcw.getName());\n            if (previous != null && previous.longValue() == gcw.getCollectionTime().longValue())\n                continue;\n            gctimes.put(gcw.getName(), gcw.getCollectionTime());\n\n            long previousMemoryUsed = 0;\n            long memoryUsed = 0;\n            long memoryMax = 0;\n            for (Map.Entry<String, MemoryUsage> entry : gcw.getMemoryUsageBeforeGc().entrySet())\n            {\n                previousMemoryUsed += entry.getValue().getUsed();\n            }\n            for (Map.Entry<String, MemoryUsage> entry : gcw.getMemoryUsageAfterGc().entrySet())\n            {\n                MemoryUsage mu = entry.getValue();\n                memoryUsed += mu.getUsed();\n                memoryMax += mu.getMax();\n            }\n\n            String st = String.format(\"GC for %s: %s ms, %s reclaimed leaving %s used; max is %s\",\n                                      gcw.getName(), gcw.getDuration(), previousMemoryUsed - memoryUsed, memoryUsed, memoryMax);\n            if (gcw.getDuration() > MIN_DURATION)\n                logger.info(st);\n            else if (logger.isDebugEnabled())\n                logger.debug(st);\n\n            if (gcw.getDuration() > MIN_DURATION_TPSTATS)\n                StatusLogger.log();\n\n            // if we just finished a full collection and we're still using a lot of memory, try to reduce the pressure\n            if (gcw.getName().equals(\"ConcurrentMarkSweep\"))\n            {\n                double usage = (double) memoryUsed / memoryMax;\n\n                if (memoryUsed > DatabaseDescriptor.getReduceCacheSizesAt() * memoryMax && !cacheSizesReduced)\n                {\n                    cacheSizesReduced = true;\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra is now reducing cache sizes to free up memory.  Adjust reduce_cache_sizes_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.reduceCacheSizes();\n                }\n\n                if (memoryUsed > DatabaseDescriptor.getFlushLargestMemtablesAt() * memoryMax)\n                {\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra will now flush up to the two largest memtables to free up memory.  Adjust flush_largest_memtables_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.flushLargestMemtables();\n                }\n            }\n        }\n    }","id":84447,"modified_method":"private void logGCResults()\n    {\n        for (GarbageCollectorMXBean gc : beans)\n        {\n            Long previousTotal = gctimes.get(gc.getName());\n            Long total = gc.getCollectionTime();\n            if (previousTotal == null)\n                previousTotal = 0L;\n            if (previousTotal.equals(total))\n                continue;\n            gctimes.put(gc.getName(), total);\n            Long duration = total - previousTotal;\n            assert duration > 0;\n\n            Long previousCount = gccounts.get(gc.getName());\n            Long count = gc.getCollectionCount();\n            if (previousCount == null)\n                previousCount = 0L;\n            gccounts.put(gc.getName(), count);\n            assert count > previousCount;\n\n            MemoryUsage mu = membean.getHeapMemoryUsage();\n            long memoryUsed = mu.getUsed();\n            long memoryMax = mu.getMax();\n\n            String st = String.format(\"GC for %s: %s ms for %s collections, %s used; max is %s\",\n                                      gc.getName(), duration, count - previousCount, memoryUsed, memoryMax);\n            long durationPerCollection = duration / (count - previousCount);\n            if (durationPerCollection > MIN_DURATION)\n                logger.info(st);\n            else if (logger.isDebugEnabled())\n                logger.debug(st);\n\n            if (durationPerCollection > MIN_DURATION_TPSTATS)\n                StatusLogger.log();\n\n            // if we just finished a full collection and we're still using a lot of memory, try to reduce the pressure\n            if (gc.getName().equals(\"ConcurrentMarkSweep\"))\n            {\n                double usage = (double) memoryUsed / memoryMax;\n\n                if (memoryUsed > DatabaseDescriptor.getReduceCacheSizesAt() * memoryMax && !cacheSizesReduced)\n                {\n                    cacheSizesReduced = true;\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra is now reducing cache sizes to free up memory.  Adjust reduce_cache_sizes_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.reduceCacheSizes();\n                }\n\n                if (memoryUsed > DatabaseDescriptor.getFlushLargestMemtablesAt() * memoryMax)\n                {\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra will now flush up to the two largest memtables to free up memory.  Adjust flush_largest_memtables_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.flushLargestMemtables();\n                }\n            }\n        }\n    }","commit_id":"aeaab2445e3fcc022ee3d1c92eda8a56dd509b5a","url":"https://github.com/apache/cassandra"},{"original_method":"public GCInspector()\n    {\n        // we only want this class to do its thing on sun jdks, or when the sun classes are present.\n        Class gcBeanClass = null;\n        try\n        {\n            gcBeanClass = Class.forName(\"com.sun.management.GarbageCollectorMXBean\");\n            Class.forName(\"com.sun.management.GcInfo\");\n        }\n        catch (ClassNotFoundException ex)\n        {\n            // this happens when using a non-sun jdk.\n            logger.warn(\"Cannot load sun GC monitoring classes. GCInspector is disabled.\");\n        }\n        \n        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        try\n        {\n            ObjectName gcName = new ObjectName(ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + \",*\");\n            for (ObjectName name : server.queryNames(gcName, null))\n            {\n                Object gc = ManagementFactory.newPlatformMXBeanProxy(server, name.getCanonicalName(), gcBeanClass);\n                beans.add(gc);\n            }\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","id":84448,"modified_method":"public GCInspector()\n    {\n        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        try\n        {\n            ObjectName gcName = new ObjectName(ManagementFactory.GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + \",*\");\n            for (ObjectName name : server.queryNames(gcName, null))\n            {\n                GarbageCollectorMXBean gc = ManagementFactory.newPlatformMXBeanProxy(server, name.getCanonicalName(), GarbageCollectorMXBean.class);\n                beans.add(gc);\n            }\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"c953ee622b90d4eacc916461a2ae31d3f052b331","url":"https://github.com/apache/cassandra"},{"original_method":"private void logGCResults()\n    {\n        for (Object gc : beans)\n        {\n            SunGcWrapper gcw = new SunGcWrapper(gc);\n            if (gcw.isLastGcInfoNull())\n                continue;\n\n            Long previous = gctimes.get(gcw.getName());\n            if (previous != null && previous.longValue() == gcw.getCollectionTime().longValue())            \n                continue;\n            gctimes.put(gcw.getName(), gcw.getCollectionTime());\n\n            long previousMemoryUsed = 0;\n            long memoryUsed = 0;\n            long memoryMax = 0;\n            for (Map.Entry<String, MemoryUsage> entry : gcw.getMemoryUsageBeforeGc().entrySet())\n            {\n                previousMemoryUsed += entry.getValue().getUsed();\n            }\n            for (Map.Entry<String, MemoryUsage> entry : gcw.getMemoryUsageAfterGc().entrySet())\n            {\n                MemoryUsage mu = entry.getValue();\n                memoryUsed += mu.getUsed();\n                memoryMax += mu.getMax();\n            }\n\n            String st = String.format(\"GC for %s: %s ms, %s reclaimed leaving %s used; max is %s\",\n                                      gcw.getName(), gcw.getDuration(), previousMemoryUsed - memoryUsed, memoryUsed, memoryMax);\n            if (gcw.getDuration() > MIN_DURATION)                          \n                logger.info(st);\n            else if (logger.isDebugEnabled())\n                logger.debug(st);\n\n            if (gcw.getDuration() > MIN_DURATION_TPSTATS)\n                StatusLogger.log();\n\n            // if we just finished a full collection and we're still using a lot of memory, try to reduce the pressure\n            if (gcw.getName().equals(\"ConcurrentMarkSweep\"))\n            {\n                double usage = (double) memoryUsed / memoryMax;\n\n                if (memoryUsed > DatabaseDescriptor.getReduceCacheSizesAt() * memoryMax && !cacheSizesReduced)\n                {\n                    cacheSizesReduced = true;\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra is now reducing cache sizes to free up memory.  Adjust reduce_cache_sizes_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.reduceCacheSizes();\n                }\n\n                if (memoryUsed > DatabaseDescriptor.getFlushLargestMemtablesAt() * memoryMax)\n                {\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra will now flush up to the two largest memtables to free up memory.  Adjust flush_largest_memtables_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.flushLargestMemtables();\n                }\n            }\n        }\n    }","id":84449,"modified_method":"private void logGCResults()\n    {\n        for (GarbageCollectorMXBean gc : beans)\n        {\n            Long previousTotal = gctimes.get(gc.getName());\n            Long total = gc.getCollectionTime();\n            if (previousTotal == null)\n                previousTotal = 0L;\n            if (previousTotal.equals(total))            \n                continue;\n            gctimes.put(gc.getName(), total);\n            Long duration = total - previousTotal;\n            assert duration > 0;\n\n            Long previousCount = gccounts.get(gc.getName());\n            Long count = gc.getCollectionCount();\n            if (previousCount == null)\n                previousCount = 0L;\n            gccounts.put(gc.getName(), count);\n            assert count > previousCount;\n\n            MemoryUsage mu = membean.getHeapMemoryUsage();\n            long memoryUsed = mu.getUsed();\n            long memoryMax = mu.getMax();\n\n            String st = String.format(\"GC for %s: %s ms for %s collections, %s used; max is %s\",\n                                      gc.getName(), duration, count - previousCount, memoryUsed, memoryMax);\n            long durationPerCollection = duration / (count - previousCount);\n            if (durationPerCollection > MIN_DURATION)                          \n                logger.info(st);\n            else if (logger.isDebugEnabled())\n                logger.debug(st);\n\n            if (durationPerCollection > MIN_DURATION_TPSTATS)\n                StatusLogger.log();\n\n            // if we just finished a full collection and we're still using a lot of memory, try to reduce the pressure\n            if (gc.getName().equals(\"ConcurrentMarkSweep\"))\n            {\n                double usage = (double) memoryUsed / memoryMax;\n\n                if (memoryUsed > DatabaseDescriptor.getReduceCacheSizesAt() * memoryMax && !cacheSizesReduced)\n                {\n                    cacheSizesReduced = true;\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra is now reducing cache sizes to free up memory.  Adjust reduce_cache_sizes_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.reduceCacheSizes();\n                }\n\n                if (memoryUsed > DatabaseDescriptor.getFlushLargestMemtablesAt() * memoryMax)\n                {\n                    logger.warn(\"Heap is \" + usage + \" full.  You may need to reduce memtable and/or cache sizes.  Cassandra will now flush up to the two largest memtables to free up memory.  Adjust flush_largest_memtables_at threshold in cassandra.yaml if you don't want Cassandra to do this automatically\");\n                    StorageService.instance.flushLargestMemtables();\n                }\n            }\n        }\n    }","commit_id":"c953ee622b90d4eacc916461a2ae31d3f052b331","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Imports the pid to the target Map.\n     *\n     * @param pid\n     * @param target\n     */\n    private void importPidFromLocalConfigAdmin(String pid, Map<String, String> target) {\n        try {\n            Configuration[] configuration = configurationAdmin.listConfigurations(\"service.pid=\" + pid + \")\");\n            if (configuration != null && configuration.length > 0) {\n                Dictionary dictionary = configuration[0].getProperties();\n                Enumeration keyEnumeration = dictionary.keys();\n                while (keyEnumeration.hasMoreElements()) {\n                    String key = String.valueOf(keyEnumeration.nextElement());\n                    String value = String.valueOf(dictionary.get(key));\n                    target.put(key, value);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while importing configuration {} to profile.\", pid);\n        }\n    }","id":84450,"modified_method":"/**\n     * Imports the pid to the target Map.\n     *\n     * @param pid\n     * @param target\n     */\n    private void importPidFromLocalConfigAdmin(String pid, Map<String, String> target) {\n        try {\n            Configuration[] configuration = configurationAdmin.listConfigurations(\"(service.pid=\" + pid + \")\");\n            if (configuration != null && configuration.length > 0) {\n                Dictionary dictionary = configuration[0].getProperties();\n                Enumeration keyEnumeration = dictionary.keys();\n                while (keyEnumeration.hasMoreElements()) {\n                    String key = String.valueOf(keyEnumeration.nextElement());\n                    String value = String.valueOf(dictionary.get(key));\n                    target.put(key, value);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while importing configuration {} to profile.\", pid);\n        }\n    }","commit_id":"0f23f8c498986fe573607cc64d680660b238ec9f","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n\n        if (configAdminConfigList != null) {\n            pid = configAdminConfigList.substring(0,configAdminConfigList.indexOf(PID_KEY_SEPARATOR));\n        }\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (featuresList != null && !featuresList.isEmpty()) {\n            String[] features = featuresList.split(DELIMETER);\n            for (String feature : features) {\n                updateConfig(pidConfig, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            }\n        }\n        if (repositoryUriList != null && !repositoryUriList.isEmpty()) {\n            String[] repositoryURIs = repositoryUriList.split(DELIMETER);\n            for (String repopsitoryURI : repositoryURIs) {\n                updateConfig(pidConfig, REPOSITORY_PREFIX + repopsitoryURI.replace('/', '_'), repopsitoryURI, set, delete);\n            }\n        }\n        if (bundlesList != null && !bundlesList.isEmpty()) {\n            String[] bundles = bundlesList.split(DELIMETER);\n            for (String bundlesLocation : bundles) {\n                updateConfig(pidConfig, BUNDLE_PREFIX + bundlesLocation.replace('/', '_'), bundlesLocation, set, delete);\n            }\n        }\n        if (fabsList != null && !fabsList.isEmpty()) {\n            String[] fabs = fabsList.split(DELIMETER);\n            for (String fabsLocation : fabs) {\n                updateConfig(pidConfig, FAB_PREFIX + fabsLocation.replace('/', '_'), fabsLocation, set, delete);\n            }\n        }\n\n        if (configAdminConfigList != null && !configAdminConfigList.isEmpty()) {\n            Map<String, String> configMap = extractConfigs(configAdminConfigList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                if (key.contains(PID_KEY_SEPARATOR)) {\n                    String currentPid = key.substring(0, key.lastIndexOf(PID_KEY_SEPARATOR));\n                    key = key.substring(key.lastIndexOf(PID_KEY_SEPARATOR) + 1);\n                    String value = configEntries.getValue();\n                    Map<String, String> cfg = config.get(currentPid);\n                    if (cfg == null) {\n                        cfg = new HashMap<String, String>();\n                    }\n                    if (importPid) {\n                        importPidFromLocalConfigAdmin(currentPid, cfg);\n                    }\n                    updatedDelimitedList(pidConfig, key, value, delimiter, set, delete, append, remove);\n                    config.put(currentPid, cfg);\n                }\n            }\n        }\n\n        if (systemPropertyList != null && !systemPropertyList.isEmpty()) {\n            String[] keyValues = systemPropertyList.split(\"=\");\n            Map<String, String> configMap = extractConfigs(systemPropertyList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                updatedDelimitedList(pidConfig, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n\n        if (configPropertyList != null && !configPropertyList.isEmpty()) {\n            String[] keyValues = configPropertyList.split(\"=\");\n            Map<String, String> configMap = extractConfigs(configPropertyList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                updatedDelimitedList(pidConfig, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n\n        config.put(pid, pidConfig);\n        profile.setConfigurations(config);\n    }","id":84451,"modified_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (featuresList != null && !featuresList.isEmpty()) {\n            String[] features = featuresList.split(DELIMETER);\n            for (String feature : features) {\n                updateConfig(pidConfig, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            }\n        }\n        if (repositoryUriList != null && !repositoryUriList.isEmpty()) {\n            String[] repositoryURIs = repositoryUriList.split(DELIMETER);\n            for (String repopsitoryURI : repositoryURIs) {\n                updateConfig(pidConfig, REPOSITORY_PREFIX + repopsitoryURI.replace('/', '_'), repopsitoryURI, set, delete);\n            }\n        }\n        if (bundlesList != null && !bundlesList.isEmpty()) {\n            String[] bundles = bundlesList.split(DELIMETER);\n            for (String bundlesLocation : bundles) {\n                updateConfig(pidConfig, BUNDLE_PREFIX + bundlesLocation.replace('/', '_'), bundlesLocation, set, delete);\n            }\n        }\n        if (fabsList != null && !fabsList.isEmpty()) {\n            String[] fabs = fabsList.split(DELIMETER);\n            for (String fabsLocation : fabs) {\n                updateConfig(pidConfig, FAB_PREFIX + fabsLocation.replace('/', '_'), fabsLocation, set, delete);\n            }\n        }\n\n        if (configAdminProperties != null && configAdminProperties.length > 0) {\n\n            for (String configAdminProperty : configAdminProperties) {\n                String currentPid = null;\n                Map<String, String> existingConfig = null;\n\n                if (configAdminProperty != null ) {\n                    String keyValue = \"\";\n                    if (configAdminProperty.contains(PID_KEY_SEPARATOR)) {\n                        currentPid = configAdminProperty.substring(0, configAdminProperty.indexOf(PID_KEY_SEPARATOR));\n                        keyValue = configAdminProperty.substring(configAdminProperty.indexOf(PID_KEY_SEPARATOR) + 1);\n                    } else {\n                        currentPid = configAdminProperty;\n                    }\n                    \n                    existingConfig = config.get(currentPid);\n                    if (existingConfig == null) {\n                        existingConfig = new HashMap<String, String>();\n                    }\n                    \n                    //We only support import when a single pid is spcecified\n                    if (configAdminProperties.length == 1 && importPid) {\n                        importPidFromLocalConfigAdmin(currentPid, existingConfig);\n                    }\n                    \n                    \n                    Map<String, String> configMap = extractConfigs(keyValue);\n                    for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                        String key = configEntries.getKey();\n                        String value = configEntries.getValue();\n                        updatedDelimitedList(existingConfig, key, value, delimiter, set, delete, append, remove);\n                    }\n\n                    config.put(currentPid, existingConfig);\n                } \n            }\n        }\n\n        if (systemProperties != null && systemProperties.length > 0) { \n            for (String systemProperty : systemProperties) {\n                Map<String, String> configMap = extractConfigs(systemProperty);\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    updatedDelimitedList(pidConfig, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n                }\n            }\n        }\n\n        if (configProperties != null && configProperties.length > 0) {\n            for (String configProperty : configProperties) {\n                Map<String, String> configMap = extractConfigs(configProperty);\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    updatedDelimitedList(pidConfig, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n                }\n            }            \n        }\n\n        config.put(pid, pidConfig);\n        profile.setConfigurations(config);\n    }","commit_id":"0f23f8c498986fe573607cc64d680660b238ec9f","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Extracts Key value pairs from a delimited string of key value pairs.\n     * Note: The value may contain commas.\n     *\n     * @param configs\n     * @return\n     */\n    private Map<String, String> extractConfigs(String configs) {\n        Map<String, String> configMap = new HashMap<String, String>();\n        //If contains key values.\n        if (configs.contains(\"=\")) {\n            String[] keyValues = configs.split(\"=\");\n            int index = 0;\n            String prefix = \"\";\n            while (index + 1 < keyValues.length) {\n                String key = !prefix.isEmpty() ? prefix : keyValues[index];\n                String value = keyValues[index + 1];\n                if (value.contains(DELIMETER) && index + 2 != keyValues.length) {\n                    prefix = value.substring(value.lastIndexOf(DELIMETER) + 1);\n                    value = value.substring(0, value.lastIndexOf(DELIMETER));\n                } else {\n                    prefix = \"\";\n                }\n                configMap.put(key, value);\n                index += 1;\n            }\n        } else {\n            String[] keys = configs.split(\",\");\n            for (String key : keys) {\n                configMap.put(key, \"\");\n            }\n        }\n        return configMap;\n    }","id":84452,"modified_method":"/**\n     * Extracts Key value pairs from a delimited string of key value pairs.\n     * Note: The value may contain commas.\n     *\n     * @param configs\n     * @return\n     */\n    private Map<String, String> extractConfigs(String configs) {\n        Map<String, String> configMap = new HashMap<String, String>();\n        //If contains key values.\n        if (configs.contains(\"=\")) {\n            String key = configs.substring(0, configs.indexOf(\"=\"));\n            String value = configs.substring(configs.indexOf(\"=\") + 1);\n            configMap.put(key, value);\n        } \n        return configMap;\n    }","commit_id":"0f23f8c498986fe573607cc64d680660b238ec9f","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n\n        if (configAdminConfigList != null) {\n            pid = configAdminConfigList.substring(0,configAdminConfigList.indexOf(PID_KEY_SEPARATOR));\n        }\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (featuresList != null && !featuresList.isEmpty()) {\n            String[] features = featuresList.split(DELIMETER);\n            for (String feature : features) {\n                updateConfig(pidConfig, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            }\n        }\n        if (repositoryUriList != null && !repositoryUriList.isEmpty()) {\n            String[] repositoryURIs = repositoryUriList.split(DELIMETER);\n            for (String repopsitoryURI : repositoryURIs) {\n                updateConfig(pidConfig, REPOSITORY_PREFIX + repopsitoryURI.replace('/', '_'), repopsitoryURI, set, delete);\n            }\n        }\n        if (bundlesList != null && !bundlesList.isEmpty()) {\n            String[] bundles = bundlesList.split(DELIMETER);\n            for (String bundlesLocation : bundles) {\n                updateConfig(pidConfig, BUNDLE_PREFIX + bundlesLocation.replace('/', '_'), bundlesLocation, set, delete);\n            }\n        }\n        if (fabsList != null && !fabsList.isEmpty()) {\n            String[] fabs = fabsList.split(DELIMETER);\n            for (String fabsLocation : fabs) {\n                updateConfig(pidConfig, FAB_PREFIX + fabsLocation.replace('/', '_'), fabsLocation, set, delete);\n            }\n        }\n\n        if (configAdminConfigList != null && !configAdminConfigList.isEmpty()) {\n            Map<String, String> configMap = extractConfigs(configAdminConfigList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                if (key.contains(PID_KEY_SEPARATOR)) {\n                    String currentPid = key.substring(0, key.lastIndexOf(PID_KEY_SEPARATOR));\n                    key = key.substring(key.lastIndexOf(PID_KEY_SEPARATOR) + 1);\n                    String value = configEntries.getValue();\n                    Map<String, String> cfg = config.get(currentPid);\n                    if (cfg == null) {\n                        cfg = new HashMap<String, String>();\n                    }\n                    if (importPid) {\n                        importPidFromLocalConfigAdmin(currentPid, cfg);\n                    }\n                    updatedDelimitedList(pidConfig, key, value, delimiter, set, delete, append, remove);\n                    config.put(currentPid, cfg);\n                }\n            }\n        }\n\n        if (systemPropertyList != null && !systemPropertyList.isEmpty()) {\n            String[] keyValues = systemPropertyList.split(\"=\");\n            Map<String, String> configMap = extractConfigs(systemPropertyList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                updatedDelimitedList(pidConfig, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n\n        if (configPropertyList != null && !configPropertyList.isEmpty()) {\n            String[] keyValues = configPropertyList.split(\"=\");\n            Map<String, String> configMap = extractConfigs(configPropertyList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                updatedDelimitedList(pidConfig, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n\n        config.put(pid, pidConfig);\n        profile.setConfigurations(config);\n    }","id":84453,"modified_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (featuresList != null && !featuresList.isEmpty()) {\n            String[] features = featuresList.split(DELIMETER);\n            for (String feature : features) {\n                updateConfig(pidConfig, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            }\n        }\n        if (repositoryUriList != null && !repositoryUriList.isEmpty()) {\n            String[] repositoryURIs = repositoryUriList.split(DELIMETER);\n            for (String repopsitoryURI : repositoryURIs) {\n                updateConfig(pidConfig, REPOSITORY_PREFIX + repopsitoryURI.replace('/', '_'), repopsitoryURI, set, delete);\n            }\n        }\n        if (bundlesList != null && !bundlesList.isEmpty()) {\n            String[] bundles = bundlesList.split(DELIMETER);\n            for (String bundlesLocation : bundles) {\n                updateConfig(pidConfig, BUNDLE_PREFIX + bundlesLocation.replace('/', '_'), bundlesLocation, set, delete);\n            }\n        }\n        if (fabsList != null && !fabsList.isEmpty()) {\n            String[] fabs = fabsList.split(DELIMETER);\n            for (String fabsLocation : fabs) {\n                updateConfig(pidConfig, FAB_PREFIX + fabsLocation.replace('/', '_'), fabsLocation, set, delete);\n            }\n        }\n\n        if (configAdminProperties != null && configAdminProperties.length > 0) {\n\n            for (String configAdminProperty : configAdminProperties) {\n                String currentPid = null;\n                Map<String, String> existingConfig = null;\n\n                if (configAdminProperty != null ) {\n                    String keyValue = \"\";\n                    if (configAdminProperty.contains(PID_KEY_SEPARATOR)) {\n                        currentPid = configAdminProperty.substring(0, configAdminProperty.indexOf(PID_KEY_SEPARATOR));\n                        keyValue = configAdminProperty.substring(configAdminProperty.indexOf(PID_KEY_SEPARATOR) + 1);\n                    } else {\n                        currentPid = configAdminProperty;\n                    }\n                    \n                    existingConfig = config.get(currentPid);\n                    if (existingConfig == null) {\n                        existingConfig = new HashMap<String, String>();\n                    }\n                    \n                    //We only support import when a single pid is spcecified\n                    if (configAdminProperties.length == 1 && importPid) {\n                        importPidFromLocalConfigAdmin(currentPid, existingConfig);\n                    }\n                    \n                    \n                    Map<String, String> configMap = extractConfigs(keyValue);\n                    for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                        String key = configEntries.getKey();\n                        String value = configEntries.getValue();\n                        updatedDelimitedList(existingConfig, key, value, delimiter, set, delete, append, remove);\n                    }\n\n                    config.put(currentPid, existingConfig);\n                } \n            }\n        }\n\n        if (systemProperties != null && systemProperties.length > 0) { \n            for (String systemProperty : systemProperties) {\n                Map<String, String> configMap = extractConfigs(systemProperty);\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    updatedDelimitedList(pidConfig, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n                }\n            }\n        }\n\n        if (configProperties != null && configProperties.length > 0) {\n            for (String configProperty : configProperties) {\n                Map<String, String> configMap = extractConfigs(configProperty);\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    updatedDelimitedList(pidConfig, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n                }\n            }            \n        }\n\n        config.put(pid, pidConfig);\n        profile.setConfigurations(config);\n    }","commit_id":"e32f2bf756d4c7a3f4b8f26885057e24274c1d58","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Extracts Key value pairs from a delimited string of key value pairs.\n     * Note: The value may contain commas.\n     *\n     * @param configs\n     * @return\n     */\n    private Map<String, String> extractConfigs(String configs) {\n        Map<String, String> configMap = new HashMap<String, String>();\n        //If contains key values.\n        if (configs.contains(\"=\")) {\n            String[] keyValues = configs.split(\"=\");\n            int index = 0;\n            String prefix = \"\";\n            while (index + 1 < keyValues.length) {\n                String key = !prefix.isEmpty() ? prefix : keyValues[index];\n                String value = keyValues[index + 1];\n                if (value.contains(DELIMETER) && index + 2 != keyValues.length) {\n                    prefix = value.substring(value.lastIndexOf(DELIMETER) + 1);\n                    value = value.substring(0, value.lastIndexOf(DELIMETER));\n                } else {\n                    prefix = \"\";\n                }\n                configMap.put(key, value);\n                index += 1;\n            }\n        } else {\n            String[] keys = configs.split(\",\");\n            for (String key : keys) {\n                configMap.put(key, \"\");\n            }\n        }\n        return configMap;\n    }","id":84454,"modified_method":"/**\n     * Extracts Key value pairs from a delimited string of key value pairs.\n     * Note: The value may contain commas.\n     *\n     * @param configs\n     * @return\n     */\n    private Map<String, String> extractConfigs(String configs) {\n        Map<String, String> configMap = new HashMap<String, String>();\n        //If contains key values.\n        if (configs.contains(\"=\")) {\n            String key = configs.substring(0, configs.indexOf(\"=\"));\n            String value = configs.substring(configs.indexOf(\"=\") + 1);\n            configMap.put(key, value);\n        } \n        return configMap;\n    }","commit_id":"e32f2bf756d4c7a3f4b8f26885057e24274c1d58","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Imports the pid to the target Map.\n     *\n     * @param pid\n     * @param target\n     */\n    private void importPidFromLocalConfigAdmin(String pid, Map<String, String> target) {\n        try {\n            Configuration[] configuration = configurationAdmin.listConfigurations(\"service.pid=\" + pid + \")\");\n            if (configuration != null && configuration.length > 0) {\n                Dictionary dictionary = configuration[0].getProperties();\n                Enumeration keyEnumeration = dictionary.keys();\n                while (keyEnumeration.hasMoreElements()) {\n                    String key = String.valueOf(keyEnumeration.nextElement());\n                    String value = String.valueOf(dictionary.get(key));\n                    target.put(key, value);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while importing configuration {} to profile.\", pid);\n        }\n    }","id":84455,"modified_method":"/**\n     * Imports the pid to the target Map.\n     *\n     * @param pid\n     * @param target\n     */\n    private void importPidFromLocalConfigAdmin(String pid, Map<String, String> target) {\n        try {\n            Configuration[] configuration = configurationAdmin.listConfigurations(\"(service.pid=\" + pid + \")\");\n            if (configuration != null && configuration.length > 0) {\n                Dictionary dictionary = configuration[0].getProperties();\n                Enumeration keyEnumeration = dictionary.keys();\n                while (keyEnumeration.hasMoreElements()) {\n                    String key = String.valueOf(keyEnumeration.nextElement());\n                    String value = String.valueOf(dictionary.get(key));\n                    target.put(key, value);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while importing configuration {} to profile.\", pid);\n        }\n    }","commit_id":"e32f2bf756d4c7a3f4b8f26885057e24274c1d58","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Imports the pid to the target Map.\n     *\n     * @param pid\n     * @param target\n     */\n    private void importPidFromLocalConfigAdmin(String pid, Map<String, String> target) {\n        try {\n            Configuration[] configuration = configurationAdmin.listConfigurations(\"service.pid=\" + pid + \")\");\n            if (configuration != null && configuration.length > 0) {\n                Dictionary dictionary = configuration[0].getProperties();\n                Enumeration keyEnumeration = dictionary.keys();\n                while (keyEnumeration.hasMoreElements()) {\n                    String key = String.valueOf(keyEnumeration.nextElement());\n                    String value = String.valueOf(dictionary.get(key));\n                    target.put(key, value);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while importing configuration {} to profile.\", pid);\n        }\n    }","id":84456,"modified_method":"/**\n     * Imports the pid to the target Map.\n     *\n     * @param pid\n     * @param target\n     */\n    private void importPidFromLocalConfigAdmin(String pid, Map<String, String> target) {\n        try {\n            Configuration[] configuration = configurationAdmin.listConfigurations(\"(service.pid=\" + pid + \")\");\n            if (configuration != null && configuration.length > 0) {\n                Dictionary dictionary = configuration[0].getProperties();\n                Enumeration keyEnumeration = dictionary.keys();\n                while (keyEnumeration.hasMoreElements()) {\n                    String key = String.valueOf(keyEnumeration.nextElement());\n                    String value = String.valueOf(dictionary.get(key));\n                    target.put(key, value);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Error while importing configuration {} to profile.\", pid);\n        }\n    }","commit_id":"d49ff05abcbb581a985646201ce38a16e6f4790d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n\n        if (configAdminConfigList != null) {\n            pid = configAdminConfigList.substring(0,configAdminConfigList.indexOf(PID_KEY_SEPARATOR));\n        }\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (featuresList != null && !featuresList.isEmpty()) {\n            String[] features = featuresList.split(DELIMETER);\n            for (String feature : features) {\n                updateConfig(pidConfig, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            }\n        }\n        if (repositoryUriList != null && !repositoryUriList.isEmpty()) {\n            String[] repositoryURIs = repositoryUriList.split(DELIMETER);\n            for (String repopsitoryURI : repositoryURIs) {\n                updateConfig(pidConfig, REPOSITORY_PREFIX + repopsitoryURI.replace('/', '_'), repopsitoryURI, set, delete);\n            }\n        }\n        if (bundlesList != null && !bundlesList.isEmpty()) {\n            String[] bundles = bundlesList.split(DELIMETER);\n            for (String bundlesLocation : bundles) {\n                updateConfig(pidConfig, BUNDLE_PREFIX + bundlesLocation.replace('/', '_'), bundlesLocation, set, delete);\n            }\n        }\n        if (fabsList != null && !fabsList.isEmpty()) {\n            String[] fabs = fabsList.split(DELIMETER);\n            for (String fabsLocation : fabs) {\n                updateConfig(pidConfig, FAB_PREFIX + fabsLocation.replace('/', '_'), fabsLocation, set, delete);\n            }\n        }\n        if (overridesList != null && !overridesList.isEmpty()) {\n            String[] overrides = overridesList.split(DELIMETER);\n            for (String overridesLocation : overrides) {\n                updateConfig(pidConfig, FAB_PREFIX + overridesLocation.replace('/', '_'), overridesLocation, set, delete);\n            }\n        }\n\n        if (configAdminConfigList != null && !configAdminConfigList.isEmpty()) {\n            Map<String, String> configMap = extractConfigs(configAdminConfigList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                if (key.contains(PID_KEY_SEPARATOR)) {\n                    String currentPid = key.substring(0, key.lastIndexOf(PID_KEY_SEPARATOR));\n                    key = key.substring(key.lastIndexOf(PID_KEY_SEPARATOR) + 1);\n                    String value = configEntries.getValue();\n                    Map<String, String> cfg = config.get(currentPid);\n                    if (cfg == null) {\n                        cfg = new HashMap<String, String>();\n                    }\n                    if (importPid) {\n                        importPidFromLocalConfigAdmin(currentPid, cfg);\n                    }\n                    updatedDelimitedList(pidConfig, key, value, delimiter, set, delete, append, remove);\n                    config.put(currentPid, cfg);\n                }\n            }\n        }\n\n        if (systemPropertyList != null && !systemPropertyList.isEmpty()) {\n            String[] keyValues = systemPropertyList.split(\"=\");\n            Map<String, String> configMap = extractConfigs(systemPropertyList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                updatedDelimitedList(pidConfig, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n\n        if (configPropertyList != null && !configPropertyList.isEmpty()) {\n            String[] keyValues = configPropertyList.split(\"=\");\n            Map<String, String> configMap = extractConfigs(configPropertyList);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                updatedDelimitedList(pidConfig, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n\n        config.put(pid, pidConfig);\n        profile.setConfigurations(config);\n    }","id":84457,"modified_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (featuresList != null && !featuresList.isEmpty()) {\n            String[] features = featuresList.split(DELIMETER);\n            for (String feature : features) {\n                updateConfig(pidConfig, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            }\n        }\n        if (repositoryUriList != null && !repositoryUriList.isEmpty()) {\n            String[] repositoryURIs = repositoryUriList.split(DELIMETER);\n            for (String repopsitoryURI : repositoryURIs) {\n                updateConfig(pidConfig, REPOSITORY_PREFIX + repopsitoryURI.replace('/', '_'), repopsitoryURI, set, delete);\n            }\n        }\n        if (bundlesList != null && !bundlesList.isEmpty()) {\n            String[] bundles = bundlesList.split(DELIMETER);\n            for (String bundlesLocation : bundles) {\n                updateConfig(pidConfig, BUNDLE_PREFIX + bundlesLocation.replace('/', '_'), bundlesLocation, set, delete);\n            }\n        }\n        if (fabsList != null && !fabsList.isEmpty()) {\n            String[] fabs = fabsList.split(DELIMETER);\n            for (String fabsLocation : fabs) {\n                updateConfig(pidConfig, FAB_PREFIX + fabsLocation.replace('/', '_'), fabsLocation, set, delete);\n            }\n        }\n        if (overridesList != null && !overridesList.isEmpty()) {\n            String[] overrides = overridesList.split(DELIMETER);\n            for (String overridesLocation : overrides) {\n                updateConfig(pidConfig, FAB_PREFIX + overridesLocation.replace('/', '_'), overridesLocation, set, delete);\n            }\n        }\n\n        if (configAdminProperties != null && configAdminProperties.length > 0) {\n\n            for (String configAdminProperty : configAdminProperties) {\n                String currentPid = null;\n                Map<String, String> existingConfig = null;\n\n                if (configAdminProperty != null ) {\n                    String keyValue = \"\";\n                    if (configAdminProperty.contains(PID_KEY_SEPARATOR)) {\n                        currentPid = configAdminProperty.substring(0, configAdminProperty.indexOf(PID_KEY_SEPARATOR));\n                        keyValue = configAdminProperty.substring(configAdminProperty.indexOf(PID_KEY_SEPARATOR) + 1);\n                    } else {\n                        currentPid = configAdminProperty;\n                    }\n                    \n                    existingConfig = config.get(currentPid);\n                    if (existingConfig == null) {\n                        existingConfig = new HashMap<String, String>();\n                    }\n                    \n                    //We only support import when a single pid is spcecified\n                    if (configAdminProperties.length == 1 && importPid) {\n                        importPidFromLocalConfigAdmin(currentPid, existingConfig);\n                    }\n                    \n                    \n                    Map<String, String> configMap = extractConfigs(keyValue);\n                    for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                        String key = configEntries.getKey();\n                        String value = configEntries.getValue();\n                        updatedDelimitedList(existingConfig, key, value, delimiter, set, delete, append, remove);\n                    }\n\n                    config.put(currentPid, existingConfig);\n                } \n            }\n        }\n\n        if (systemProperties != null && systemProperties.length > 0) { \n            for (String systemProperty : systemProperties) {\n                Map<String, String> configMap = extractConfigs(systemProperty);\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    updatedDelimitedList(pidConfig, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n                }\n            }\n        }\n\n        if (configProperties != null && configProperties.length > 0) {\n            for (String configProperty : configProperties) {\n                Map<String, String> configMap = extractConfigs(configProperty);\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    updatedDelimitedList(pidConfig, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n                }\n            }            \n        }\n\n        config.put(pid, pidConfig);\n        profile.setConfigurations(config);\n    }","commit_id":"d49ff05abcbb581a985646201ce38a16e6f4790d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Extracts Key value pairs from a delimited string of key value pairs.\n     * Note: The value may contain commas.\n     *\n     * @param configs\n     * @return\n     */\n    private Map<String, String> extractConfigs(String configs) {\n        Map<String, String> configMap = new HashMap<String, String>();\n        //If contains key values.\n        if (configs.contains(\"=\")) {\n            String[] keyValues = configs.split(\"=\");\n            int index = 0;\n            String prefix = \"\";\n            while (index + 1 < keyValues.length) {\n                String key = !prefix.isEmpty() ? prefix : keyValues[index];\n                String value = keyValues[index + 1];\n                if (value.contains(DELIMETER) && index + 2 != keyValues.length) {\n                    prefix = value.substring(value.lastIndexOf(DELIMETER) + 1);\n                    value = value.substring(0, value.lastIndexOf(DELIMETER));\n                } else {\n                    prefix = \"\";\n                }\n                configMap.put(key, value);\n                index += 1;\n            }\n        } else {\n            String[] keys = configs.split(\",\");\n            for (String key : keys) {\n                configMap.put(key, \"\");\n            }\n        }\n        return configMap;\n    }","id":84458,"modified_method":"/**\n     * Extracts Key value pairs from a delimited string of key value pairs.\n     * Note: The value may contain commas.\n     *\n     * @param configs\n     * @return\n     */\n    private Map<String, String> extractConfigs(String configs) {\n        Map<String, String> configMap = new HashMap<String, String>();\n        //If contains key values.\n        if (configs.contains(\"=\")) {\n            String key = configs.substring(0, configs.indexOf(\"=\"));\n            String value = configs.substring(configs.indexOf(\"=\") + 1);\n            configMap.put(key, value);\n        } \n        return configMap;\n    }","commit_id":"d49ff05abcbb581a985646201ce38a16e6f4790d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Constructs a new event encapsulation instance based upon the\n     * information passed to the method. The passed byte array is decoded into\n     * a string using the <tt>US-ASCII<\/tt> character encoding.\n     *\n     * @param addr The remote agent's address.\n     * @param port The remote agent's port\n     * @param data The XML data in US-ASCII encoding.\n     * @param len  The length of the XML data in the buffer.\n     * @throws java.io.UnsupportedEncodingException\n     *          Thrown if the data buffer cannot be decoded using the\n     *          US-ASCII encoding.\n     * @throws MessageDiscardedException \n     */\n    static ConvertToEvent make(InetAddress addr, int port, byte[] data,\n                               int len, String matchPattern, int hostGroup, int messageGroup,\n                               UeiList ueiList, HideMessage hideMessage, String discardUei)\n            throws UnsupportedEncodingException, MessageDiscardedException {\n\n        ConvertToEvent e = new ConvertToEvent();\n\n        // Get host address /\n\n        e.m_sender = addr;\n        e.m_port = port;\n        e.m_eventXML = new String(data, 0, len, \"US-ASCII\");\n        e.m_ackEvents = new ArrayList<Event>(16);\n        e.m_log = null;\n\n        String m_logPrefix = Syslogd.LOG4J_CATEGORY;\n        ThreadCategory.setPrefix(m_logPrefix);\n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        Category log = ThreadCategory.getInstance();\n\n        log.debug(\"In the make part of UdpReceivedSyslog \" + e.toString());\n\n        // Build a basic event out of the syslog message\n\n        Event event = new Event();\n        event.setSource(\"syslogd\");\n\n        // Set nodeId\n\n        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\",\n                \"\"));\n        // log.debug(\"Nodeid via SyslogdIPMgr \" +\n        // SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\",\"\")));\n\n        if (nodeId != -1)\n            event.setNodeid(nodeId);\n\n        // Set event host\n        //\n        try {\n            event.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            event.setHost(\"unresolved.host\");\n            log.warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        event.setInterface(addr.toString().replaceAll(\"/\", \"\"));\n\n        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));\n        Logmsg logmsg = new Logmsg();\n        logmsg.setDest(\"logndisplay\");\n\n        String message = new String(data, 0, len, \"US-ASCII\");\n\n        // log.debug(\"The parsed message... \" + message );\n\n        int lbIdx = message.indexOf('<');\n        int rbIdx = message.indexOf('>');\n\n        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {\n            log.warn(\"Syslogd received an unparsable message!\");\n        }\n\n        int priCode = 0;\n        String priStr = message.substring(lbIdx + 1, rbIdx);\n\n        try {\n            priCode = Integer.parseInt(priStr);\n        } catch (NumberFormatException ex) {\n            log.debug(\"ERROR Bad priority code '\" + priStr + \"'\");\n\n        }\n\n        int facility = SyslogDefs.extractFacility(priCode);\n        int priority = SyslogDefs.extractPriority(priCode);\n\n        String priorityTxt = SyslogDefs.getPriorityName(priority);\n        // event.setSeverity(priorityTxt);\n        // We leave the priority alone, this might need to be set.\n\n        String facilityTxt = SyslogDefs.getFacilityName(facility);\n\n        //Check for UEI matching or allow a simple standard one.\n\n        event.setUei(\"uei.opennms.org/syslogd/\" + facilityTxt + \"/\"\n                + priorityTxt);\n\n        // message = message.substring(rbIdx + 1, (message.length() - 1));\n\n        message = message.substring(rbIdx + 1, (message.length()));\n\n        //\n        // Check to see if msg looks non-standard.\n        // In this case, it means that there is not a standard\n        // date in the front of the message text.\n        //\n        boolean stdMsg = true;\n\n        if (message.length() < 16) {\n            stdMsg = false;\n        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '\n                || message.charAt(9) != ':' || message.charAt(12) != ':'\n                || message.charAt(15) != ' ') {\n            stdMsg = false;\n        }\n\n        String timestamp;\n\n        if (!stdMsg) {\n            try {\n                timestamp = SyslogTimeStamp.getInstance().format(new Date());\n            } catch (IllegalArgumentException ex) {\n                log.debug(\"ERROR INTERNAL DATE ERROR!\");\n                timestamp = \"\";\n            }\n        } else {\n            timestamp = message.substring(0, 15);\n            message = message.substring(16);\n        }\n\n        // These 2 debugs will aid in analyzing the regexpes as syslog seems\n        // to differ alot\n        // depending on implementation or message structure.\n\n        log.debug(\"Message : \" + message);\n        log.debug(\"Pattern : \" + matchPattern);\n        log.debug(\"Host group: \" + hostGroup);\n        log.debug(\"Message group: \" + messageGroup);\n\n        // We will also here find out if, the host needs to\n        // be replaced, the message matched to a UEI, and\n        // last if we need to actually hide the message.\n        // this being potentially helpful in avoiding showing\n        // operator a password or other data that should be\n        // confindential.\n\n        Pattern pattern = Pattern.compile(matchPattern);\n        Matcher m = pattern.matcher(message);\n\n        /*\n        * We matched on a regexp for host/message pair.\n        * This can be a forwarded message as in BSD Style\n        * or syslog-ng.\n        * We assume that the host is given to us\n        * as an IP/Hostname and that the resolver\n        * on the ONMS host actually can resolve the\n        * node to match against nodeId.\n         */\n\n        // Antonio: Here seems to me a duplicated match\n        // m is setted why i need to reassign?\n        // What is wrong?\n        // This is causing a trouble generating syslog events not needed\n        // I added an else with trowing \n        // Bug # 3278\n        if ((m = pattern.matcher(message)).matches()) {\n\n            log.debug(\"Regexp matched message: \" + message);\n            log.debug(\"Host: \" + m.group(hostGroup));\n            log.debug(\"Message: \" + m.group(messageGroup));\n\n            // We will try and extract an IP address from\n            // a hostname.....\n\n            String myHost = \"\";\n\n            try {\n                InetAddress address = InetAddress.getByName(m.group(hostGroup));\n                byte[] ipAddr = address.getAddress();\n\n                // Convert to dot representation\n                for (int i = 0; i < ipAddr.length; i++) {\n                    if (i > 0) {\n                        myHost += \".\";\n                    }\n                    myHost += ipAddr[i] & 0xFF;\n                }\n            } catch (UnknownHostException e1) {\n                log.info(\"Could not parse the host: \" + e1);\n\n            }\n\n            if (!\"\".equals(myHost)) {\n                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(\n                        \"/\",\n                        \"\"));\n\n                if (nodeId != -1)\n                  event.setNodeid(nodeId);\n                  // Clean up for further processing....\n                  event.setInterface(myHost.replaceAll(\"/\", \"\"));\n                message = m.group(messageGroup);\n                log.debug(\"Regexp used to find node: \" + event.getNodeid());\n            }\n        } else {\n            log.error(\"Regexp not matched message: \" + message);            \n            throw new MessageDiscardedException();\n        }\n\n        // We will need these shortly\n        Parms eventParms = new Parms();\n        Parm eventParm = null;\n        Value parmValue = null;\n        \n        Pattern msgPat;\n        Matcher msgMat;\n\n        // Time to verify UEI matching.\n\n        for (UeiMatch uei : ueiList.getUeiMatchCollection()) {\n            if (uei.getMatch().getType().equals(\"substr\")) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting substring match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n            \tif (message.contains(uei.getMatch().getExpression())) {\n            \t    if (discardUei.equals(uei.getUei())) {\n            \t        if (log.isDebugEnabled()) {\n            \t            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n            \t            throw new MessageDiscardedException();\n            \t        }\n            \t    }\n                    //We can pass a new UEI on this\n                    log.debug(\"Changed the UEI of a Syslogd event, based on substring match, to :\" + uei.getUei());\n                    event.setUei(uei.getUei());\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n                    break;\n                }\n            } else if (uei.getMatch().getType().equals(\"regex\")) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting regex match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n                try {\n            \t\tmsgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);\n            \t\tmsgMat = msgPat.matcher(message);\n                } catch(PatternSyntaxException pse) {\n            \t\tlog.error(\"Failed to compile regex pattern '\"+uei.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    if (discardUei.equals(uei.getUei())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n                            throw new MessageDiscardedException();\n                        }\n                    }\n            \t    // We matched a UEI\n            \t\tlog.debug(\"Changed the UEI of a Syslogd event, based on regex match, to :\" + uei.getUei());\n            \t\tevent.setUei(uei.getUei());\n            \t\tif (msgMat.groupCount() > 0) {\n            \t\t\tfor (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {\n            \t\t\t\tlog.debug(\"Added parm 'group\"+groupNum+\"' with value '\"+msgMat.group(groupNum)+\"' to Syslogd event based on regex match group\");\n            \t\t\t\teventParm = new Parm();\n            \t\t\t\teventParm.setParmName(\"group\"+groupNum);\n            \t\t\t\tparmValue = new Value();\n            \t\t\t\tparmValue.setContent(msgMat.group(groupNum));\n            \t\t\t\teventParm.setValue(parmValue);\n            \t\t\t\teventParms.addParm(eventParm);\n            \t\t\t}\n            \t\t}\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n            \t\tbreak;\n            \t}\n            }\n        }\n\n        // Time to verify if we need to hide the message\n\n        boolean doHide = false;\n        for (HideMatch hide : hideMessage.getHideMatchCollection()) {\n            if (hide.getMatch().getType().equals(\"substr\")) {\n                if (message.contains(hide.getMatch().getExpression())) {\n                    // We should hide the message based on this match\n                \tdoHide = true;\n                }            \t\n            } else if (hide.getMatch().getType().equals(\"regex\")) {\n            \ttry {\n                \tmsgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);\n                \tmsgMat = msgPat.matcher(message);            \t\t\n            \t} catch (PatternSyntaxException pse) {\n            \t\tlog.error(\"Failed to compile regex pattern '\"+hide.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    // We should hide the message based on this match\n            \t\tdoHide = true;\n            \t}\n            }\n            if (doHide) {\n\t            log.debug(\"Hiding syslog message from Event - May contain sensitive data\");\n\t            message = HIDDEN_MESSAGE;\n\t            // We want to stop here, no point in checking further hideMatches\n\t            break;\n            }\n        }\n\n        lbIdx = message.indexOf('[');\n        rbIdx = message.indexOf(']');\n        int colonIdx = message.indexOf(':');\n        int spaceIdx = message.indexOf(' ');\n\n        int processId = 0;\n        String processName = \"\";\n        String processIdStr = \"\";\n\n        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, lbIdx);\n            processIdStr = message.substring(lbIdx + 1, rbIdx);\n            message = message.substring(colonIdx + 2);\n\n            try {\n                processId = Integer.parseInt(processIdStr);\n            } catch (NumberFormatException ex) {\n                log.debug(\"ERROR Bad process id '\" + processIdStr + \"'\");\n                processId = 0;\n            }\n        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, colonIdx);\n            message = message.substring(colonIdx + 2);\n        }\n\n        // Using parms provides configurability.\n        logmsg.setContent(message);\n        event.setLogmsg(logmsg);\n\n        // Add appropriate parms\n        eventParm = new Parm();\n        eventParm.setParmName(\"syslogmessage\");\n        parmValue = new Value();\n        parmValue.setContent((message));\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"severity\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + priorityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"timestamp\");\n        parmValue = new Value();\n        parmValue.setContent(timestamp);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"process\");\n        parmValue = new Value();\n        parmValue.setContent(processName);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"service\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + facilityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"processid\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + processId);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        // Good thing(TM)\n        event.setParms(eventParms);\n\n        e.m_event = event;\n        return e;\n    }","id":84459,"modified_method":"/**\n     * Constructs a new event encapsulation instance based upon the\n     * information passed to the method. The passed byte array is decoded into\n     * a string using the <tt>US-ASCII<\/tt> character encoding.\n     *\n     * @param addr The remote agent's address.\n     * @param port The remote agent's port\n     * @param data The XML data in US-ASCII encoding.\n     * @param len  The length of the XML data in the buffer.\n     * @throws java.io.UnsupportedEncodingException\n     *          Thrown if the data buffer cannot be decoded using the\n     *          US-ASCII encoding.\n     * @throws MessageDiscardedException \n     */\n    static ConvertToEvent make(InetAddress addr, int port, byte[] data,\n                               int len, String matchPattern, int hostGroup, int messageGroup,\n                               UeiList ueiList, HideMessage hideMessage, String discardUei)\n            throws UnsupportedEncodingException, MessageDiscardedException {\n\n        ConvertToEvent e = new ConvertToEvent();\n\n        // Get host address /\n\n        e.m_sender = addr;\n        e.m_port = port;\n        e.m_eventXML = new String(data, 0, len, \"US-ASCII\");\n        e.m_ackEvents = new ArrayList<Event>(16);\n        e.m_log = null;\n\n        String m_logPrefix = Syslogd.LOG4J_CATEGORY;\n        ThreadCategory.setPrefix(m_logPrefix);\n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        Category log = ThreadCategory.getInstance();\n\n        if (log.isDebugEnabled())\n            log.debug(\"In the make part of UdpReceivedSyslog \" + e.toString());\n\n        // Build a basic event out of the syslog message\n\n        Event event = new Event();\n        event.setSource(\"syslogd\");\n\n        // Set nodeId\n        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\", \"\"));\n        if (nodeId != -1)\n            event.setNodeid(nodeId);\n\n        // Set event host\n        try {\n            event.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            event.setHost(\"unresolved.host\");\n            log.warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        event.setInterface(addr.toString().replaceAll(\"/\", \"\"));\n\n        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));\n        Logmsg logmsg = new Logmsg();\n        logmsg.setDest(\"logndisplay\");\n\n        String message = new String(data, 0, len, \"US-ASCII\");\n\n        int lbIdx = message.indexOf('<');\n        int rbIdx = message.indexOf('>');\n\n        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {\n            log.warn(\"Syslogd received an unparsable message!\");\n        }\n\n        int priCode = 0;\n        String priStr = message.substring(lbIdx + 1, rbIdx);\n\n        try {\n            priCode = Integer.parseInt(priStr);\n        } catch (NumberFormatException ex) {\n            log.debug(\"ERROR Bad priority code '\" + priStr + \"'\");\n\n        }\n\n        int facility = SyslogDefs.extractFacility(priCode);\n        int priority = SyslogDefs.extractPriority(priCode);\n\n        String priorityTxt = SyslogDefs.getPriorityName(priority);\n        // event.setSeverity(priorityTxt);\n        // We leave the priority alone, this might need to be set.\n\n        String facilityTxt = SyslogDefs.getFacilityName(facility);\n\n        //Check for UEI matching or allow a simple standard one.\n\n        event.setUei(\"uei.opennms.org/syslogd/\" + facilityTxt + \"/\" + priorityTxt);\n\n        // message = message.substring(rbIdx + 1, (message.length() - 1));\n        message = message.substring(rbIdx + 1, (message.length()));\n\n        // Check to see if message looks non-standard.\n        // In this case, it means that there is not a standard\n        // date in the front of the message text.\n        boolean stdMsg = true;\n\n        if (message.length() < 16) {\n            stdMsg = false;\n        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '\n                || message.charAt(9) != ':' || message.charAt(12) != ':'\n                || message.charAt(15) != ' ') {\n            stdMsg = false;\n        }\n\n        String timestamp;\n\n        if (!stdMsg) {\n            try {\n                timestamp = SyslogTimeStamp.getInstance().format(new Date());\n            } catch (IllegalArgumentException ex) {\n                log.debug(\"ERROR INTERNAL DATE ERROR!\");\n                timestamp = \"\";\n            }\n        } else {\n            timestamp = message.substring(0, 15);\n            message = message.substring(16);\n        }\n\n        // These 2 debugs will aid in analyzing the regexes as syslog seems\n        // to differ a lot depending on implementation or message structure.\n\n        boolean traceEnabled = log.isEnabledFor(Level.TRACE);\n\n        if (traceEnabled) {\n            log.log(Level.TRACE, \"Message : \" + message);\n            log.log(Level.TRACE, \"Pattern : \" + matchPattern);\n            log.log(Level.TRACE, \"Host group: \" + hostGroup);\n            log.log(Level.TRACE, \"Message group: \" + messageGroup);\n        }\n\n        // We will also here find out if, the host needs to\n        // be replaced, the message matched to a UEI, and\n        // last if we need to actually hide the message.\n        // this being potentially helpful in avoiding showing\n        // operator a password or other data that should be\n        // confidential.\n\n        Pattern pattern = Pattern.compile(matchPattern);\n        Matcher m = pattern.matcher(message);\n\n        /*\n        * We matched on a regexp for host/message pair.\n        * This can be a forwarded message as in BSD Style\n        * or syslog-ng.\n        * We assume that the host is given to us\n        * as an IP/Hostname and that the resolver\n        * on the ONMS host actually can resolve the\n        * node to match against nodeId.\n         */\n\n        if (m.matches()) {\n\n            if (traceEnabled) {\n                log.log(Level.TRACE, \"Regexp matched message: \" + message);\n                log.log(Level.TRACE, \"Host: \" + m.group(hostGroup));\n                log.log(Level.TRACE, \"Message: \" + m.group(messageGroup));\n            }\n\n            // We will try to extract an IP address from a hostname.....\n            String myHost = \"\";\n\n            try {\n                InetAddress address = InetAddress.getByName(m.group(hostGroup));\n                byte[] ipAddr = address.getAddress();\n\n                // Convert to dot representation\n                for (int i = 0; i < ipAddr.length; i++) {\n                    if (i > 0) {\n                        myHost += \".\";\n                    }\n                    myHost += ipAddr[i] & 0xFF;\n                }\n            } catch (UnknownHostException e1) {\n                log.warn(\"Could not parse the host: \" + e1);\n\n            }\n\n            if (!\"\".equals(myHost)) {\n                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(\"/\", \"\"));\n\n                if (nodeId != -1) {\n                    event.setNodeid(nodeId);\n                }\n                // Clean up for further processing....\n                event.setInterface(myHost.replaceAll(\"/\", \"\"));\n                message = m.group(messageGroup);\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Regexp used to find node: \" + event.getNodeid());\n                }\n            }\n        } else {\n            log.warn(\"Regexp not matched: \" + message);            \n            throw new MessageDiscardedException();\n        }\n\n        // We will need these shortly\n        Parms eventParms = new Parms();\n        Parm eventParm = null;\n        Value parmValue = null;\n        \n        Pattern msgPat;\n        Matcher msgMat;\n\n        // Time to verify UEI matching.\n\n        for (UeiMatch uei : ueiList.getUeiMatchCollection()) {\n            if (uei.getMatch().getType().equals(\"substr\")) {\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Attempting substring match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n            \tif (message.contains(uei.getMatch().getExpression())) {\n            \t    if (discardUei.equals(uei.getUei())) {\n            \t        if (traceEnabled) {\n            \t            log.log(Level.TRACE, \"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n            \t            throw new MessageDiscardedException();\n            \t        }\n            \t    }\n                    //We can pass a new UEI on this\n            \t    if (traceEnabled) {\n            \t        log.log(Level.TRACE, \"Changed the UEI of a Syslogd event, based on substring match, to :\" + uei.getUei());\n            \t    }\n                    event.setUei(uei.getUei());\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n                    break;\n                }\n            } else if (uei.getMatch().getType().equals(\"regex\")) {\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Attempting regex match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n                try {\n            \t\tmsgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);\n            \t\tmsgMat = msgPat.matcher(message);\n                } catch(PatternSyntaxException pse) {\n            \t\tlog.warn(\"Failed to compile regex pattern '\"+uei.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    if (discardUei.equals(uei.getUei())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n                        }\n                        throw new MessageDiscardedException();\n                    }\n\n                    // We matched a UEI\n                    if (traceEnabled) {\n                        log.log(Level.TRACE, \"Changed the UEI of a Syslogd event, based on regex match, to :\" + uei.getUei());\n                    }\n                    event.setUei(uei.getUei());\n            \t\tif (msgMat.groupCount() > 0) {\n            \t\t\tfor (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {\n            \t\t\t    if (traceEnabled) {\n            \t\t\t        log.log(Level.TRACE, \"Added parm 'group\"+groupNum+\"' with value '\"+msgMat.group(groupNum)+\"' to Syslogd event based on regex match group\");\n            \t\t\t    }\n            \t\t\t\teventParm = new Parm();\n            \t\t\t\teventParm.setParmName(\"group\"+groupNum);\n            \t\t\t\tparmValue = new Value();\n            \t\t\t\tparmValue.setContent(msgMat.group(groupNum));\n            \t\t\t\teventParm.setValue(parmValue);\n            \t\t\t\teventParms.addParm(eventParm);\n            \t\t\t}\n            \t\t}\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n            \t\tbreak;\n            \t}\n            }\n        }\n\n        // Time to verify if we need to hide the message\n        boolean doHide = false;\n        for (HideMatch hide : hideMessage.getHideMatchCollection()) {\n            if (hide.getMatch().getType().equals(\"substr\")) {\n                if (message.contains(hide.getMatch().getExpression())) {\n                    // We should hide the message based on this match\n                \tdoHide = true;\n                }            \t\n            } else if (hide.getMatch().getType().equals(\"regex\")) {\n            \ttry {\n                \tmsgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);\n                \tmsgMat = msgPat.matcher(message);            \t\t\n            \t} catch (PatternSyntaxException pse) {\n            \t\tlog.warn(\"Failed to compile regex pattern '\"+hide.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    // We should hide the message based on this match\n            \t\tdoHide = true;\n            \t}\n            }\n            if (doHide) {\n\t            log.debug(\"Hiding syslog message from Event - May contain sensitive data\");\n\t            message = HIDDEN_MESSAGE;\n\t            // We want to stop here, no point in checking further hideMatches\n\t            break;\n            }\n        }\n\n        lbIdx = message.indexOf('[');\n        rbIdx = message.indexOf(']');\n        int colonIdx = message.indexOf(':');\n        int spaceIdx = message.indexOf(' ');\n\n        int processId = 0;\n        String processName = \"\";\n        String processIdStr = \"\";\n\n        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, lbIdx);\n            processIdStr = message.substring(lbIdx + 1, rbIdx);\n            message = message.substring(colonIdx + 2);\n\n            try {\n                processId = Integer.parseInt(processIdStr);\n            } catch (NumberFormatException ex) {\n                log.debug(\"Bad process id '\" + processIdStr + \"'\");\n                processId = 0;\n            }\n        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, colonIdx);\n            message = message.substring(colonIdx + 2);\n        }\n\n        // Using parms provides configurability.\n        logmsg.setContent(message);\n        event.setLogmsg(logmsg);\n\n        // Add appropriate parms\n        eventParm = new Parm();\n        eventParm.setParmName(\"syslogmessage\");\n        parmValue = new Value();\n        parmValue.setContent((message));\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"severity\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + priorityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"timestamp\");\n        parmValue = new Value();\n        parmValue.setContent(timestamp);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"process\");\n        parmValue = new Value();\n        parmValue.setContent(processName);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"service\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + facilityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"processid\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + processId);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        // Good thing(TM)\n        event.setParms(eventParms);\n\n        e.m_event = event;\n        return e;\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Stops the current context\n     */\n    void stop() throws InterruptedException {\n        m_stop = true;\n        if (m_context != null) {\n            Category log = ThreadCategory.getInstance(getClass());\n            if (log.isDebugEnabled())\n                log.debug(\"Stopping and joining thread context \"\n                        + m_context.getName());\n\n            m_context.interrupt();\n            m_context.join();\n\n            if (log.isDebugEnabled())\n                log.debug(\"Thread context stopped and joined\");\n        }\n    }","id":84460,"modified_method":"/**\n     * Stops the current context\n     */\n    void stop() throws InterruptedException {\n        m_stop = true;\n        if (m_context != null) {\n            Category log = ThreadCategory.getInstance(getClass());\n            if (log.isDebugEnabled())\n                log.debug(\"Stopping and joining thread context \" + m_context.getName());\n\n            m_context.interrupt();\n            m_context.join();\n\n            log.debug(\"Thread context stopped and joined\");\n        }\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void setSyslogConfig(SyslogdConfig syslogdConfig) {\n        SyslogdConfig m_syslogdConfig = syslogdConfig;\n\n    }","id":84461,"modified_method":"public static void setSyslogConfig(SyslogdConfig syslogdConfig) {\n        @SuppressWarnings(\"unused\")\n        SyslogdConfig m_syslogdConfig = syslogdConfig;\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The event processing execution context.\n     */\n    public void run() {\n        // The runnable context\n        //\n        m_context = Thread.currentThread();\n\n        // get a logger\n        //\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean isTracing = log.isDebugEnabled();\n\n        if (m_stop) {\n            if (isTracing)\n                log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else if (isTracing)\n            log.debug(\"Thread context started\");\n\n        // This loop is labeled so that it can be\n        // exited quickly when the thread is interrupted\n        //\n        RunLoop:\n        while (!m_stop) {\n\n            ConvertToEvent o = null;\n\n            o = SyslogHandler.queueManager.getFromQueue();\n\n            if (o != null) {\n                try {\n                    log.debug(\"Processing a syslog to event dispatch\"\n                            + o.toString());\n\n                    // print out the eui, source, and other\n                    // important aspects\n                    //\n                    String uuid = o.getEvent().getUuid();\n                    log.debug(\"Event {\");\n                    log.debug(\"  uuid  = \"\n                            + (uuid != null && uuid.length() > 0 ? uuid\n                            : \"<not-set>\"));\n                    log.debug(\"  uei   = \" + o.getEvent().getUei());\n                    log.debug(\"  src   = \" + o.getEvent().getSource());\n                    log.debug(\"  iface = \" + o.getEvent().getInterface());\n                    log.debug(\"  time  = \" + o.getEvent().getTime());\n                    log.debug(\"  Msg   = \"\n                            + o.getEvent().getLogmsg().getContent());\n                    log.debug(\"  Dst   = \"\n                            + o.getEvent().getLogmsg().getDest());\n                    Parm[] parms = (o.getEvent().getParms() == null ? null\n                            : o.getEvent().getParms().getParm());\n                    if (parms != null) {\n                        log.debug(\"  parms {\");\n                        for (Parm parm : parms) {\n                            if ((parm.getParmName() != null)\n                                    && (parm.getValue().getContent() != null)) {\n                                log.debug(\"    (\"\n                                        + parm.getParmName().trim()\n                                        + \", \"\n                                        + parm.getValue().getContent().trim()\n                                        + \")\");\n                            }\n                        }\n                        log.debug(\"  }\");\n                    }\n                    log.debug(\"}\");\n\n                    EventIpcManagerFactory.getIpcManager().sendNow(\n                            o.getEvent());\n                    // !event.hasNodeid() && m_newSuspect\n                    if (m_NewSuspectOnMessage && !o.getEvent().hasNodeid()) {\n                        log.debug(\"Syslogd: Found a new suspect \"\n                                + o.getEvent().getInterface());\n                        sendNewSuspectEvent(o.getEvent().getInterface());\n                    }\n\n                } catch (Throwable t) {\n                    log.error(\n                            \"Unexpected error processing SyslogMessage - Could not send\",\n                            t);\n\n                }\n            }\n\n        }\n\n    }","id":84462,"modified_method":"/**\n     * The event processing execution context.\n     */\n    public void run() {\n        // The runnable context\n        m_context = Thread.currentThread();\n\n        // get a logger\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean isTracing = log.isEnabledFor(Level.TRACE);\n\n        if (m_stop) {\n            if (isTracing)\n                log.log(Level.TRACE, \"Stop flag set before thread started, exiting\");\n            return;\n        } else if (isTracing)\n            log.debug(\"Thread context started\");\n\n        while (!m_stop) {\n\n            ConvertToEvent o = null;\n\n            o = SyslogHandler.queueManager.getFromQueue();\n\n            if (o != null) {\n                try {\n                    if (isTracing)  {\n                        log.log(Level.TRACE, \"Processing a syslog to event dispatch\" + o.toString());\n                        String uuid = o.getEvent().getUuid();\n                        log.log(Level.TRACE, \"Event {\");\n                        log.log(Level.TRACE, \"  uuid  = \"\n                                + (uuid != null && uuid.length() > 0 ? uuid\n                                : \"<not-set>\"));\n                        log.log(Level.TRACE, \"  uei   = \" + o.getEvent().getUei());\n                        log.log(Level.TRACE, \"  src   = \" + o.getEvent().getSource());\n                        log.log(Level.TRACE, \"  iface = \" + o.getEvent().getInterface());\n                        log.log(Level.TRACE, \"  time  = \" + o.getEvent().getTime());\n                        log.log(Level.TRACE, \"  Msg   = \"\n                                + o.getEvent().getLogmsg().getContent());\n                        log.log(Level.TRACE, \"  Dst   = \"\n                                + o.getEvent().getLogmsg().getDest());\n                        Parm[] parms = (o.getEvent().getParms() == null ? null\n                                : o.getEvent().getParms().getParm());\n                        if (parms != null) {\n                            log.log(Level.TRACE, \"  parms {\");\n                            for (Parm parm : parms) {\n                                if ((parm.getParmName() != null)\n                                        && (parm.getValue().getContent() != null)) {\n                                    log.log(Level.TRACE, \"    (\"\n                                            + parm.getParmName().trim()\n                                            + \", \"\n                                            + parm.getValue().getContent().trim()\n                                            + \")\");\n                                }\n                            }\n                            log.log(Level.TRACE, \"  }\");\n                        }\n                        log.log(Level.TRACE, \"}\");\n                    }\n\n                    EventIpcManagerFactory.getIpcManager().sendNow(o.getEvent());\n\n                    if (m_NewSuspectOnMessage && !o.getEvent().hasNodeid()) {\n                        if (isTracing) {\n                            log.log(Level.TRACE, \"Syslogd: Found a new suspect \" + o.getEvent().getInterface());\n                        }\n                        sendNewSuspectEvent(o.getEvent().getInterface());\n                    }\n\n                } catch (Throwable t) {\n                    log.error(\"Unexpected error processing SyslogMessage - Could not send\", t);\n                }\n            }\n\n        }\n\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"SyslogProcessor(boolean newSuspectOnMessage, String forwardingRegexp, int matchingGroupHost,\n                    int matchingGroupMessage, UeiList ueiList, HideMessage hideMessages) {\n        m_context = null;\n        m_stop = false;\n        m_NewSuspectOnMessage = newSuspectOnMessage;\n        m_ForwardingRegexp = forwardingRegexp;\n        m_MatchingGroupHost = matchingGroupHost;\n        m_MatchingGroupMessage = matchingGroupMessage;\n        m_UeiList = ueiList;\n        m_HideMessages = hideMessages;\n\n        m_logPrefix = Syslogd.LOG4J_CATEGORY;\n\n        try {\n            m_localAddr = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException uhE) {\n            Category log = ThreadCategory.getInstance(getClass());\n\n            m_localAddr = \"localhost\";\n            log.error(\"<ctor>: Error looking up local hostname\", uhE);\n        }\n\n    }","id":84463,"modified_method":"SyslogProcessor(boolean newSuspectOnMessage, String forwardingRegexp, int matchingGroupHost,\n                    int matchingGroupMessage, UeiList ueiList, HideMessage hideMessages) {\n        m_context = null;\n        m_stop = false;\n        m_NewSuspectOnMessage = newSuspectOnMessage;\n\n        m_logPrefix = Syslogd.LOG4J_CATEGORY;\n\n        try {\n            m_localAddr = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException uhE) {\n            Category log = ThreadCategory.getInstance(getClass());\n\n            m_localAddr = \"localhost\";\n            log.error(\"Error looking up local hostname; using 'localhost'\", uhE);\n        }\n\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The execution context.\n     */\n    public void run() {\n        // get the context\n        //\n        m_context = Thread.currentThread();\n\n        // Get a log instance\n        //\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_stop) {\n            log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else\n            log.debug(\"Thread context started\");\n\n        // allocate a buffer\n        final int length = 0xffff;\n        final byte[] buffer = new byte[length];\n\n        // set an SO timout to make sure we don't block forever\n        // if a socket is closed.\n        try {\n            log.debug(\"Setting socket timeout to 500ms\");\n            m_dgSock.setSoTimeout(500);\n        } catch (SocketException e) {\n            log.warn(\n                    \"An I/O error occured while trying to set the socket timeout\",\n                    e);\n        }\n\n        // Increase the receive buffer for the\n        // socket\n        try {\n            log.debug(\"Setting receive buffer size to \" + length);\n            m_dgSock.setReceiveBufferSize(length);\n        } catch (SocketException e) {\n            log.info(\"Failed to set the receive buffer to \" + length, e);\n        }\n        // set to avoid numerious tracing message\n        // \n        boolean ioInterrupted = false;\n        // now start processing incomming request\n        //\n        while (!m_stop) {\n            if (m_context.isInterrupted()) {\n                log.debug(\"Thread context interrupted\");\n                break;\n            }\n\n            try {\n                if (!ioInterrupted)\n                    log.debug(\"Wating on a datagram to arrive\");\n                DatagramPacket pkt = new DatagramPacket(buffer, length);\n                m_dgSock.receive(pkt);\n                //SyslogConnection *Must* copy pkt datas and InetAddress as DatagramPacket is a mutable type\n                Thread worker = new Thread(new SyslogConnection(pkt, m_matchPattern, m_hostGroup, m_messageGroup, m_UeiList, m_HideMessages, m_discardUei));\n                worker.start();\n                ioInterrupted = false; // reset the flag\n            }\n\t\tcatch (SocketTimeoutException e) {\n\t\t  ioInterrupted = true;\n\t\t  continue;\n\t\t} \n\t\tcatch (InterruptedIOException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (IOException e) {\n                log.error(\n                        \"An I/O exception occured on the datagram receipt port, exiting\",\n                        e);\n                break;\n            }\n\n        } // end while status ok\n\n        log.debug(\"Thread context exiting\");\n\n    }","id":84464,"modified_method":"/**\n     * The execution context.\n     */\n    public void run() {\n        // get the context\n        m_context = Thread.currentThread();\n\n        // Get a log instance\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_stop) {\n            log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else\n            log.debug(\"Thread context started\");\n\n        // allocate a buffer\n        final int length = 0xffff;\n        final byte[] buffer = new byte[length];\n\n        // set an SO timeout to make sure we don't block forever\n        // if a socket is closed.\n        try {\n            log.debug(\"Setting socket timeout to \" + SOCKET_TIMEOUT + \"ms\");\n            m_dgSock.setSoTimeout(SOCKET_TIMEOUT);\n        } catch (SocketException e) {\n            log.warn(\"An I/O error occured while trying to set the socket timeout\", e);\n        }\n\n        // Increase the receive buffer for the socket\n        try {\n            log.debug(\"Setting receive buffer size to \" + length);\n            m_dgSock.setReceiveBufferSize(length);\n        } catch (SocketException e) {\n            log.info(\"Failed to set the receive buffer to \" + length, e);\n        }\n        // set to avoid numerous tracing message\n        boolean ioInterrupted = false;\n        // now start processing incoming requests\n        while (!m_stop) {\n            if (m_context.isInterrupted()) {\n                log.debug(\"Thread context interrupted\");\n                break;\n            }\n\n            try {\n                if (!ioInterrupted) {\n                    log.debug(\"Wating on a datagram to arrive\");\n                }\n\n                DatagramPacket pkt = new DatagramPacket(buffer, length);\n                m_dgSock.receive(pkt);\n\n                //SyslogConnection *Must* copy packet data and InetAddress as DatagramPacket is a mutable type\n                Thread worker = new Thread(new SyslogConnection(pkt, m_matchPattern, m_hostGroup, m_messageGroup, m_UeiList, m_HideMessages, m_discardUei));\n                worker.start();\n                ioInterrupted = false; // reset the flag\n            } catch (SocketTimeoutException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (InterruptedIOException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (IOException e) {\n                log.error(\"An I/O exception occured on the datagram receipt port, exiting\", e);\n                break;\n            }\n\n        } // end while status OK\n\n        log.debug(\"Thread context exiting\");\n\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DEBUG);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n\n    }","id":84465,"modified_method":"public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        MockLogAppender.assertNotGreaterOrEqual(Level.FATAL);\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DEBUG);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n\n    }","commit_id":"1d3e37be566dcae30fc9b2128180da81e34466cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructs a new event encapsulation instance based upon the\n     * information passed to the method. The passed byte array is decoded into\n     * a string using the <tt>US-ASCII<\/tt> character encoding.\n     *\n     * @param addr The remote agent's address.\n     * @param port The remote agent's port\n     * @param data The XML data in US-ASCII encoding.\n     * @param len  The length of the XML data in the buffer.\n     * @throws java.io.UnsupportedEncodingException\n     *          Thrown if the data buffer cannot be decoded using the\n     *          US-ASCII encoding.\n     * @throws MessageDiscardedException \n     */\n    static ConvertToEvent make(InetAddress addr, int port, byte[] data,\n                               int len, String matchPattern, int hostGroup, int messageGroup,\n                               UeiList ueiList, HideMessage hideMessage, String discardUei)\n            throws UnsupportedEncodingException, MessageDiscardedException {\n\n        ConvertToEvent e = new ConvertToEvent();\n\n        // Get host address /\n\n        e.m_sender = addr;\n        e.m_port = port;\n        e.m_eventXML = new String(data, 0, len, \"US-ASCII\");\n        e.m_ackEvents = new ArrayList<Event>(16);\n        e.m_log = null;\n\n        String m_logPrefix = Syslogd.LOG4J_CATEGORY;\n        ThreadCategory.setPrefix(m_logPrefix);\n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        Category log = ThreadCategory.getInstance();\n\n        log.debug(\"In the make part of UdpReceivedSyslog \" + e.toString());\n\n        // Build a basic event out of the syslog message\n\n        Event event = new Event();\n        event.setSource(\"syslogd\");\n\n        // Set nodeId\n\n        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\",\n                \"\"));\n        // log.debug(\"Nodeid via SyslogdIPMgr \" +\n        // SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\",\"\")));\n\n        if (nodeId != -1)\n            event.setNodeid(nodeId);\n\n        // Set event host\n        //\n        try {\n            event.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            event.setHost(\"unresolved.host\");\n            log.warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        event.setInterface(addr.toString().replaceAll(\"/\", \"\"));\n\n        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));\n        Logmsg logmsg = new Logmsg();\n        logmsg.setDest(\"logndisplay\");\n\n        String message = new String(data, 0, len, \"US-ASCII\");\n\n        // log.debug(\"The parsed message... \" + message );\n\n        int lbIdx = message.indexOf('<');\n        int rbIdx = message.indexOf('>');\n\n        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {\n            log.warn(\"Syslogd received an unparsable message!\");\n        }\n\n        int priCode = 0;\n        String priStr = message.substring(lbIdx + 1, rbIdx);\n\n        try {\n            priCode = Integer.parseInt(priStr);\n        } catch (NumberFormatException ex) {\n            log.debug(\"ERROR Bad priority code '\" + priStr + \"'\");\n\n        }\n\n        int facility = SyslogDefs.extractFacility(priCode);\n        int priority = SyslogDefs.extractPriority(priCode);\n\n        String priorityTxt = SyslogDefs.getPriorityName(priority);\n        // event.setSeverity(priorityTxt);\n        // We leave the priority alone, this might need to be set.\n\n        String facilityTxt = SyslogDefs.getFacilityName(facility);\n\n        //Check for UEI matching or allow a simple standard one.\n\n        event.setUei(\"uei.opennms.org/syslogd/\" + facilityTxt + \"/\"\n                + priorityTxt);\n\n        // message = message.substring(rbIdx + 1, (message.length() - 1));\n\n        message = message.substring(rbIdx + 1, (message.length()));\n\n        //\n        // Check to see if msg looks non-standard.\n        // In this case, it means that there is not a standard\n        // date in the front of the message text.\n        //\n        boolean stdMsg = true;\n\n        if (message.length() < 16) {\n            stdMsg = false;\n        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '\n                || message.charAt(9) != ':' || message.charAt(12) != ':'\n                || message.charAt(15) != ' ') {\n            stdMsg = false;\n        }\n\n        String timestamp;\n\n        if (!stdMsg) {\n            try {\n                timestamp = SyslogTimeStamp.getInstance().format(new Date());\n            } catch (IllegalArgumentException ex) {\n                log.debug(\"ERROR INTERNAL DATE ERROR!\");\n                timestamp = \"\";\n            }\n        } else {\n            timestamp = message.substring(0, 15);\n            message = message.substring(16);\n        }\n\n        // These 2 debugs will aid in analyzing the regexpes as syslog seems\n        // to differ alot\n        // depending on implementation or message structure.\n\n        log.debug(\"Message : \" + message);\n        log.debug(\"Pattern : \" + matchPattern);\n        log.debug(\"Host group: \" + hostGroup);\n        log.debug(\"Message group: \" + messageGroup);\n\n        // We will also here find out if, the host needs to\n        // be replaced, the message matched to a UEI, and\n        // last if we need to actually hide the message.\n        // this being potentially helpful in avoiding showing\n        // operator a password or other data that should be\n        // confindential.\n\n        Pattern pattern = Pattern.compile(matchPattern);\n        Matcher m = pattern.matcher(message);\n\n        /*\n        * We matched on a regexp for host/message pair.\n        * This can be a forwarded message as in BSD Style\n        * or syslog-ng.\n        * We assume that the host is given to us\n        * as an IP/Hostname and that the resolver\n        * on the ONMS host actually can resolve the\n        * node to match against nodeId.\n         */\n\n        // Antonio: Here seems to me a duplicated match\n        // m is setted why i need to reassign?\n        // What is wrong?\n        // This is causing a trouble generating syslog events not needed\n        // I added an else with trowing \n        // Bug # 3278\n        if ((m = pattern.matcher(message)).matches()) {\n\n            log.debug(\"Regexp matched message: \" + message);\n            log.debug(\"Host: \" + m.group(hostGroup));\n            log.debug(\"Message: \" + m.group(messageGroup));\n\n            // We will try and extract an IP address from\n            // a hostname.....\n\n            String myHost = \"\";\n\n            try {\n                InetAddress address = InetAddress.getByName(m.group(hostGroup));\n                byte[] ipAddr = address.getAddress();\n\n                // Convert to dot representation\n                for (int i = 0; i < ipAddr.length; i++) {\n                    if (i > 0) {\n                        myHost += \".\";\n                    }\n                    myHost += ipAddr[i] & 0xFF;\n                }\n            } catch (UnknownHostException e1) {\n                log.info(\"Could not parse the host: \" + e1);\n\n            }\n\n            if (!\"\".equals(myHost)) {\n                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(\n                        \"/\",\n                        \"\"));\n\n                if (nodeId != -1)\n                  event.setNodeid(nodeId);\n                  // Clean up for further processing....\n                  event.setInterface(myHost.replaceAll(\"/\", \"\"));\n                message = m.group(messageGroup);\n                log.debug(\"Regexp used to find node: \" + event.getNodeid());\n            }\n        } else {\n            log.error(\"Regexp not matched message: \" + message);            \n            throw new MessageDiscardedException();\n        }\n\n        // We will need these shortly\n        Parms eventParms = new Parms();\n        Parm eventParm = null;\n        Value parmValue = null;\n        \n        Pattern msgPat;\n        Matcher msgMat;\n\n        // Time to verify UEI matching.\n\n        for (UeiMatch uei : ueiList.getUeiMatchCollection()) {\n            if (uei.getMatch().getType().equals(\"substr\")) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting substring match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n            \tif (message.contains(uei.getMatch().getExpression())) {\n            \t    if (discardUei.equals(uei.getUei())) {\n            \t        if (log.isDebugEnabled()) {\n            \t            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n            \t            throw new MessageDiscardedException();\n            \t        }\n            \t    }\n                    //We can pass a new UEI on this\n                    log.debug(\"Changed the UEI of a Syslogd event, based on substring match, to :\" + uei.getUei());\n                    event.setUei(uei.getUei());\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n                    break;\n                }\n            } else if (uei.getMatch().getType().equals(\"regex\")) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting regex match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n                try {\n            \t\tmsgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);\n            \t\tmsgMat = msgPat.matcher(message);\n                } catch(PatternSyntaxException pse) {\n            \t\tlog.error(\"Failed to compile regex pattern '\"+uei.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    if (discardUei.equals(uei.getUei())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n                            throw new MessageDiscardedException();\n                        }\n                    }\n            \t    // We matched a UEI\n            \t\tlog.debug(\"Changed the UEI of a Syslogd event, based on regex match, to :\" + uei.getUei());\n            \t\tevent.setUei(uei.getUei());\n            \t\tif (msgMat.groupCount() > 0) {\n            \t\t\tfor (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {\n            \t\t\t\tlog.debug(\"Added parm 'group\"+groupNum+\"' with value '\"+msgMat.group(groupNum)+\"' to Syslogd event based on regex match group\");\n            \t\t\t\teventParm = new Parm();\n            \t\t\t\teventParm.setParmName(\"group\"+groupNum);\n            \t\t\t\tparmValue = new Value();\n            \t\t\t\tparmValue.setContent(msgMat.group(groupNum));\n            \t\t\t\teventParm.setValue(parmValue);\n            \t\t\t\teventParms.addParm(eventParm);\n            \t\t\t}\n            \t\t}\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n            \t\tbreak;\n            \t}\n            }\n        }\n\n        // Time to verify if we need to hide the message\n\n        boolean doHide = false;\n        for (HideMatch hide : hideMessage.getHideMatchCollection()) {\n            if (hide.getMatch().getType().equals(\"substr\")) {\n                if (message.contains(hide.getMatch().getExpression())) {\n                    // We should hide the message based on this match\n                \tdoHide = true;\n                }            \t\n            } else if (hide.getMatch().getType().equals(\"regex\")) {\n            \ttry {\n                \tmsgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);\n                \tmsgMat = msgPat.matcher(message);            \t\t\n            \t} catch (PatternSyntaxException pse) {\n            \t\tlog.error(\"Failed to compile regex pattern '\"+hide.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    // We should hide the message based on this match\n            \t\tdoHide = true;\n            \t}\n            }\n            if (doHide) {\n\t            log.debug(\"Hiding syslog message from Event - May contain sensitive data\");\n\t            message = HIDDEN_MESSAGE;\n\t            // We want to stop here, no point in checking further hideMatches\n\t            break;\n            }\n        }\n\n        lbIdx = message.indexOf('[');\n        rbIdx = message.indexOf(']');\n        int colonIdx = message.indexOf(':');\n        int spaceIdx = message.indexOf(' ');\n\n        int processId = 0;\n        String processName = \"\";\n        String processIdStr = \"\";\n\n        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, lbIdx);\n            processIdStr = message.substring(lbIdx + 1, rbIdx);\n            message = message.substring(colonIdx + 2);\n\n            try {\n                processId = Integer.parseInt(processIdStr);\n            } catch (NumberFormatException ex) {\n                log.debug(\"ERROR Bad process id '\" + processIdStr + \"'\");\n                processId = 0;\n            }\n        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, colonIdx);\n            message = message.substring(colonIdx + 2);\n        }\n\n        // Using parms provides configurability.\n        logmsg.setContent(message);\n        event.setLogmsg(logmsg);\n\n        // Add appropriate parms\n        eventParm = new Parm();\n        eventParm.setParmName(\"syslogmessage\");\n        parmValue = new Value();\n        parmValue.setContent((message));\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"severity\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + priorityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"timestamp\");\n        parmValue = new Value();\n        parmValue.setContent(timestamp);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"process\");\n        parmValue = new Value();\n        parmValue.setContent(processName);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"service\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + facilityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"processid\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + processId);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        // Good thing(TM)\n        event.setParms(eventParms);\n\n        e.m_event = event;\n        return e;\n    }","id":84466,"modified_method":"/**\n     * Constructs a new event encapsulation instance based upon the\n     * information passed to the method. The passed byte array is decoded into\n     * a string using the <tt>US-ASCII<\/tt> character encoding.\n     *\n     * @param addr The remote agent's address.\n     * @param port The remote agent's port\n     * @param data The XML data in US-ASCII encoding.\n     * @param len  The length of the XML data in the buffer.\n     * @throws java.io.UnsupportedEncodingException\n     *          Thrown if the data buffer cannot be decoded using the\n     *          US-ASCII encoding.\n     * @throws MessageDiscardedException \n     */\n    static ConvertToEvent make(InetAddress addr, int port, byte[] data,\n                               int len, String matchPattern, int hostGroup, int messageGroup,\n                               UeiList ueiList, HideMessage hideMessage, String discardUei)\n            throws UnsupportedEncodingException, MessageDiscardedException {\n\n        ConvertToEvent e = new ConvertToEvent();\n\n        // Get host address /\n\n        e.m_sender = addr;\n        e.m_port = port;\n        e.m_eventXML = new String(data, 0, len, \"US-ASCII\");\n        e.m_ackEvents = new ArrayList<Event>(16);\n        e.m_log = null;\n\n        String m_logPrefix = Syslogd.LOG4J_CATEGORY;\n        ThreadCategory.setPrefix(m_logPrefix);\n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        Category log = ThreadCategory.getInstance();\n\n        if (log.isDebugEnabled())\n            log.debug(\"In the make part of UdpReceivedSyslog \" + e.toString());\n\n        // Build a basic event out of the syslog message\n\n        Event event = new Event();\n        event.setSource(\"syslogd\");\n\n        // Set nodeId\n        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\", \"\"));\n        if (nodeId != -1)\n            event.setNodeid(nodeId);\n\n        // Set event host\n        try {\n            event.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            event.setHost(\"unresolved.host\");\n            log.warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        event.setInterface(addr.toString().replaceAll(\"/\", \"\"));\n\n        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));\n        Logmsg logmsg = new Logmsg();\n        logmsg.setDest(\"logndisplay\");\n\n        String message = new String(data, 0, len, \"US-ASCII\");\n\n        int lbIdx = message.indexOf('<');\n        int rbIdx = message.indexOf('>');\n\n        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {\n            log.warn(\"Syslogd received an unparsable message!\");\n        }\n\n        int priCode = 0;\n        String priStr = message.substring(lbIdx + 1, rbIdx);\n\n        try {\n            priCode = Integer.parseInt(priStr);\n        } catch (NumberFormatException ex) {\n            log.debug(\"ERROR Bad priority code '\" + priStr + \"'\");\n\n        }\n\n        int facility = SyslogDefs.extractFacility(priCode);\n        int priority = SyslogDefs.extractPriority(priCode);\n\n        String priorityTxt = SyslogDefs.getPriorityName(priority);\n        // event.setSeverity(priorityTxt);\n        // We leave the priority alone, this might need to be set.\n\n        String facilityTxt = SyslogDefs.getFacilityName(facility);\n\n        //Check for UEI matching or allow a simple standard one.\n\n        event.setUei(\"uei.opennms.org/syslogd/\" + facilityTxt + \"/\" + priorityTxt);\n\n        // message = message.substring(rbIdx + 1, (message.length() - 1));\n        message = message.substring(rbIdx + 1, (message.length()));\n\n        // Check to see if message looks non-standard.\n        // In this case, it means that there is not a standard\n        // date in the front of the message text.\n        boolean stdMsg = true;\n\n        if (message.length() < 16) {\n            stdMsg = false;\n        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '\n                || message.charAt(9) != ':' || message.charAt(12) != ':'\n                || message.charAt(15) != ' ') {\n            stdMsg = false;\n        }\n\n        String timestamp;\n\n        if (!stdMsg) {\n            try {\n                timestamp = SyslogTimeStamp.getInstance().format(new Date());\n            } catch (IllegalArgumentException ex) {\n                log.debug(\"ERROR INTERNAL DATE ERROR!\");\n                timestamp = \"\";\n            }\n        } else {\n            timestamp = message.substring(0, 15);\n            message = message.substring(16);\n        }\n\n        // These 2 debugs will aid in analyzing the regexes as syslog seems\n        // to differ a lot depending on implementation or message structure.\n\n        boolean traceEnabled = log.isEnabledFor(Level.TRACE);\n\n        if (traceEnabled) {\n            log.log(Level.TRACE, \"Message : \" + message);\n            log.log(Level.TRACE, \"Pattern : \" + matchPattern);\n            log.log(Level.TRACE, \"Host group: \" + hostGroup);\n            log.log(Level.TRACE, \"Message group: \" + messageGroup);\n        }\n\n        // We will also here find out if, the host needs to\n        // be replaced, the message matched to a UEI, and\n        // last if we need to actually hide the message.\n        // this being potentially helpful in avoiding showing\n        // operator a password or other data that should be\n        // confidential.\n\n        Pattern pattern = Pattern.compile(matchPattern);\n        Matcher m = pattern.matcher(message);\n\n        /*\n        * We matched on a regexp for host/message pair.\n        * This can be a forwarded message as in BSD Style\n        * or syslog-ng.\n        * We assume that the host is given to us\n        * as an IP/Hostname and that the resolver\n        * on the ONMS host actually can resolve the\n        * node to match against nodeId.\n         */\n\n        if (m.matches()) {\n\n            if (traceEnabled) {\n                log.log(Level.TRACE, \"Regexp matched message: \" + message);\n                log.log(Level.TRACE, \"Host: \" + m.group(hostGroup));\n                log.log(Level.TRACE, \"Message: \" + m.group(messageGroup));\n            }\n\n            // We will try to extract an IP address from a hostname.....\n            String myHost = \"\";\n\n            try {\n                InetAddress address = InetAddress.getByName(m.group(hostGroup));\n                byte[] ipAddr = address.getAddress();\n\n                // Convert to dot representation\n                for (int i = 0; i < ipAddr.length; i++) {\n                    if (i > 0) {\n                        myHost += \".\";\n                    }\n                    myHost += ipAddr[i] & 0xFF;\n                }\n            } catch (UnknownHostException e1) {\n                log.warn(\"Could not parse the host: \" + e1);\n\n            }\n\n            if (!\"\".equals(myHost)) {\n                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(\"/\", \"\"));\n\n                if (nodeId != -1) {\n                    event.setNodeid(nodeId);\n                }\n                // Clean up for further processing....\n                event.setInterface(myHost.replaceAll(\"/\", \"\"));\n                message = m.group(messageGroup);\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Regexp used to find node: \" + event.getNodeid());\n                }\n            }\n        } else {\n            log.warn(\"Regexp not matched: \" + message);            \n            throw new MessageDiscardedException();\n        }\n\n        // We will need these shortly\n        Parms eventParms = new Parms();\n        Parm eventParm = null;\n        Value parmValue = null;\n        \n        Pattern msgPat;\n        Matcher msgMat;\n\n        // Time to verify UEI matching.\n\n        for (UeiMatch uei : ueiList.getUeiMatchCollection()) {\n            if (uei.getMatch().getType().equals(\"substr\")) {\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Attempting substring match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n            \tif (message.contains(uei.getMatch().getExpression())) {\n            \t    if (discardUei.equals(uei.getUei())) {\n            \t        if (traceEnabled) {\n            \t            log.log(Level.TRACE, \"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n            \t            throw new MessageDiscardedException();\n            \t        }\n            \t    }\n                    //We can pass a new UEI on this\n            \t    if (traceEnabled) {\n            \t        log.log(Level.TRACE, \"Changed the UEI of a Syslogd event, based on substring match, to :\" + uei.getUei());\n            \t    }\n                    event.setUei(uei.getUei());\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n                    break;\n                }\n            } else if (uei.getMatch().getType().equals(\"regex\")) {\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Attempting regex match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n                try {\n            \t\tmsgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);\n            \t\tmsgMat = msgPat.matcher(message);\n                } catch(PatternSyntaxException pse) {\n            \t\tlog.warn(\"Failed to compile regex pattern '\"+uei.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    if (discardUei.equals(uei.getUei())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n                        }\n                        throw new MessageDiscardedException();\n                    }\n\n                    // We matched a UEI\n                    if (traceEnabled) {\n                        log.log(Level.TRACE, \"Changed the UEI of a Syslogd event, based on regex match, to :\" + uei.getUei());\n                    }\n                    event.setUei(uei.getUei());\n            \t\tif (msgMat.groupCount() > 0) {\n            \t\t\tfor (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {\n            \t\t\t    if (traceEnabled) {\n            \t\t\t        log.log(Level.TRACE, \"Added parm 'group\"+groupNum+\"' with value '\"+msgMat.group(groupNum)+\"' to Syslogd event based on regex match group\");\n            \t\t\t    }\n            \t\t\t\teventParm = new Parm();\n            \t\t\t\teventParm.setParmName(\"group\"+groupNum);\n            \t\t\t\tparmValue = new Value();\n            \t\t\t\tparmValue.setContent(msgMat.group(groupNum));\n            \t\t\t\teventParm.setValue(parmValue);\n            \t\t\t\teventParms.addParm(eventParm);\n            \t\t\t}\n            \t\t}\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n            \t\tbreak;\n            \t}\n            }\n        }\n\n        // Time to verify if we need to hide the message\n        boolean doHide = false;\n        for (HideMatch hide : hideMessage.getHideMatchCollection()) {\n            if (hide.getMatch().getType().equals(\"substr\")) {\n                if (message.contains(hide.getMatch().getExpression())) {\n                    // We should hide the message based on this match\n                \tdoHide = true;\n                }            \t\n            } else if (hide.getMatch().getType().equals(\"regex\")) {\n            \ttry {\n                \tmsgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);\n                \tmsgMat = msgPat.matcher(message);            \t\t\n            \t} catch (PatternSyntaxException pse) {\n            \t\tlog.warn(\"Failed to compile regex pattern '\"+hide.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    // We should hide the message based on this match\n            \t\tdoHide = true;\n            \t}\n            }\n            if (doHide) {\n\t            log.debug(\"Hiding syslog message from Event - May contain sensitive data\");\n\t            message = HIDDEN_MESSAGE;\n\t            // We want to stop here, no point in checking further hideMatches\n\t            break;\n            }\n        }\n\n        lbIdx = message.indexOf('[');\n        rbIdx = message.indexOf(']');\n        int colonIdx = message.indexOf(':');\n        int spaceIdx = message.indexOf(' ');\n\n        int processId = 0;\n        String processName = \"\";\n        String processIdStr = \"\";\n\n        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, lbIdx);\n            processIdStr = message.substring(lbIdx + 1, rbIdx);\n            message = message.substring(colonIdx + 2);\n\n            try {\n                processId = Integer.parseInt(processIdStr);\n            } catch (NumberFormatException ex) {\n                log.debug(\"Bad process id '\" + processIdStr + \"'\");\n                processId = 0;\n            }\n        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, colonIdx);\n            message = message.substring(colonIdx + 2);\n        }\n\n        // Using parms provides configurability.\n        logmsg.setContent(message);\n        event.setLogmsg(logmsg);\n\n        // Add appropriate parms\n        eventParm = new Parm();\n        eventParm.setParmName(\"syslogmessage\");\n        parmValue = new Value();\n        parmValue.setContent((message));\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"severity\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + priorityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"timestamp\");\n        parmValue = new Value();\n        parmValue.setContent(timestamp);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"process\");\n        parmValue = new Value();\n        parmValue.setContent(processName);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"service\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + facilityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"processid\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + processId);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        // Good thing(TM)\n        event.setParms(eventParms);\n\n        e.m_event = event;\n        return e;\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"SyslogProcessor(boolean newSuspectOnMessage, String forwardingRegexp, int matchingGroupHost,\n                    int matchingGroupMessage, UeiList ueiList, HideMessage hideMessages) {\n        m_context = null;\n        m_stop = false;\n        m_NewSuspectOnMessage = newSuspectOnMessage;\n        m_ForwardingRegexp = forwardingRegexp;\n        m_MatchingGroupHost = matchingGroupHost;\n        m_MatchingGroupMessage = matchingGroupMessage;\n        m_UeiList = ueiList;\n        m_HideMessages = hideMessages;\n\n        m_logPrefix = Syslogd.LOG4J_CATEGORY;\n\n        try {\n            m_localAddr = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException uhE) {\n            Category log = ThreadCategory.getInstance(getClass());\n\n            m_localAddr = \"localhost\";\n            log.error(\"<ctor>: Error looking up local hostname\", uhE);\n        }\n\n    }","id":84467,"modified_method":"SyslogProcessor(boolean newSuspectOnMessage, String forwardingRegexp, int matchingGroupHost,\n                    int matchingGroupMessage, UeiList ueiList, HideMessage hideMessages) {\n        m_context = null;\n        m_stop = false;\n        m_NewSuspectOnMessage = newSuspectOnMessage;\n\n        m_logPrefix = Syslogd.LOG4J_CATEGORY;\n\n        try {\n            m_localAddr = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException uhE) {\n            Category log = ThreadCategory.getInstance(getClass());\n\n            m_localAddr = \"localhost\";\n            log.error(\"Error looking up local hostname; using 'localhost'\", uhE);\n        }\n\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Stops the current context\n     */\n    void stop() throws InterruptedException {\n        m_stop = true;\n        if (m_context != null) {\n            Category log = ThreadCategory.getInstance(getClass());\n            if (log.isDebugEnabled())\n                log.debug(\"Stopping and joining thread context \"\n                        + m_context.getName());\n\n            m_context.interrupt();\n            m_context.join();\n\n            if (log.isDebugEnabled())\n                log.debug(\"Thread context stopped and joined\");\n        }\n    }","id":84468,"modified_method":"/**\n     * Stops the current context\n     */\n    void stop() throws InterruptedException {\n        m_stop = true;\n        if (m_context != null) {\n            Category log = ThreadCategory.getInstance(getClass());\n            if (log.isDebugEnabled())\n                log.debug(\"Stopping and joining thread context \" + m_context.getName());\n\n            m_context.interrupt();\n            m_context.join();\n\n            log.debug(\"Thread context stopped and joined\");\n        }\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The event processing execution context.\n     */\n    public void run() {\n        // The runnable context\n        //\n        m_context = Thread.currentThread();\n\n        // get a logger\n        //\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean isTracing = log.isDebugEnabled();\n\n        if (m_stop) {\n            if (isTracing)\n                log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else if (isTracing)\n            log.debug(\"Thread context started\");\n\n        // This loop is labeled so that it can be\n        // exited quickly when the thread is interrupted\n        //\n        RunLoop:\n        while (!m_stop) {\n\n            ConvertToEvent o = null;\n\n            o = SyslogHandler.queueManager.getFromQueue();\n\n            if (o != null) {\n                try {\n                    log.debug(\"Processing a syslog to event dispatch\"\n                            + o.toString());\n\n                    // print out the eui, source, and other\n                    // important aspects\n                    //\n                    String uuid = o.getEvent().getUuid();\n                    log.debug(\"Event {\");\n                    log.debug(\"  uuid  = \"\n                            + (uuid != null && uuid.length() > 0 ? uuid\n                            : \"<not-set>\"));\n                    log.debug(\"  uei   = \" + o.getEvent().getUei());\n                    log.debug(\"  src   = \" + o.getEvent().getSource());\n                    log.debug(\"  iface = \" + o.getEvent().getInterface());\n                    log.debug(\"  time  = \" + o.getEvent().getTime());\n                    log.debug(\"  Msg   = \"\n                            + o.getEvent().getLogmsg().getContent());\n                    log.debug(\"  Dst   = \"\n                            + o.getEvent().getLogmsg().getDest());\n                    Parm[] parms = (o.getEvent().getParms() == null ? null\n                            : o.getEvent().getParms().getParm());\n                    if (parms != null) {\n                        log.debug(\"  parms {\");\n                        for (Parm parm : parms) {\n                            if ((parm.getParmName() != null)\n                                    && (parm.getValue().getContent() != null)) {\n                                log.debug(\"    (\"\n                                        + parm.getParmName().trim()\n                                        + \", \"\n                                        + parm.getValue().getContent().trim()\n                                        + \")\");\n                            }\n                        }\n                        log.debug(\"  }\");\n                    }\n                    log.debug(\"}\");\n\n                    EventIpcManagerFactory.getIpcManager().sendNow(\n                            o.getEvent());\n                    // !event.hasNodeid() && m_newSuspect\n                    if (m_NewSuspectOnMessage && !o.getEvent().hasNodeid()) {\n                        log.debug(\"Syslogd: Found a new suspect \"\n                                + o.getEvent().getInterface());\n                        sendNewSuspectEvent(o.getEvent().getInterface());\n                    }\n\n                } catch (Throwable t) {\n                    log.error(\n                            \"Unexpected error processing SyslogMessage - Could not send\",\n                            t);\n\n                }\n            }\n\n        }\n\n    }","id":84469,"modified_method":"/**\n     * The event processing execution context.\n     */\n    public void run() {\n        // The runnable context\n        m_context = Thread.currentThread();\n\n        // get a logger\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean isTracing = log.isEnabledFor(Level.TRACE);\n\n        if (m_stop) {\n            if (isTracing)\n                log.log(Level.TRACE, \"Stop flag set before thread started, exiting\");\n            return;\n        } else if (isTracing)\n            log.debug(\"Thread context started\");\n\n        while (!m_stop) {\n\n            ConvertToEvent o = null;\n\n            o = SyslogHandler.queueManager.getFromQueue();\n\n            if (o != null) {\n                try {\n                    if (isTracing)  {\n                        log.log(Level.TRACE, \"Processing a syslog to event dispatch\" + o.toString());\n                        String uuid = o.getEvent().getUuid();\n                        log.log(Level.TRACE, \"Event {\");\n                        log.log(Level.TRACE, \"  uuid  = \"\n                                + (uuid != null && uuid.length() > 0 ? uuid\n                                : \"<not-set>\"));\n                        log.log(Level.TRACE, \"  uei   = \" + o.getEvent().getUei());\n                        log.log(Level.TRACE, \"  src   = \" + o.getEvent().getSource());\n                        log.log(Level.TRACE, \"  iface = \" + o.getEvent().getInterface());\n                        log.log(Level.TRACE, \"  time  = \" + o.getEvent().getTime());\n                        log.log(Level.TRACE, \"  Msg   = \"\n                                + o.getEvent().getLogmsg().getContent());\n                        log.log(Level.TRACE, \"  Dst   = \"\n                                + o.getEvent().getLogmsg().getDest());\n                        Parm[] parms = (o.getEvent().getParms() == null ? null\n                                : o.getEvent().getParms().getParm());\n                        if (parms != null) {\n                            log.log(Level.TRACE, \"  parms {\");\n                            for (Parm parm : parms) {\n                                if ((parm.getParmName() != null)\n                                        && (parm.getValue().getContent() != null)) {\n                                    log.log(Level.TRACE, \"    (\"\n                                            + parm.getParmName().trim()\n                                            + \", \"\n                                            + parm.getValue().getContent().trim()\n                                            + \")\");\n                                }\n                            }\n                            log.log(Level.TRACE, \"  }\");\n                        }\n                        log.log(Level.TRACE, \"}\");\n                    }\n\n                    EventIpcManagerFactory.getIpcManager().sendNow(o.getEvent());\n\n                    if (m_NewSuspectOnMessage && !o.getEvent().hasNodeid()) {\n                        if (isTracing) {\n                            log.log(Level.TRACE, \"Syslogd: Found a new suspect \" + o.getEvent().getInterface());\n                        }\n                        sendNewSuspectEvent(o.getEvent().getInterface());\n                    }\n\n                } catch (Throwable t) {\n                    log.error(\"Unexpected error processing SyslogMessage - Could not send\", t);\n                }\n            }\n\n        }\n\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void setSyslogConfig(SyslogdConfig syslogdConfig) {\n        SyslogdConfig m_syslogdConfig = syslogdConfig;\n\n    }","id":84470,"modified_method":"public static void setSyslogConfig(SyslogdConfig syslogdConfig) {\n        @SuppressWarnings(\"unused\")\n        SyslogdConfig m_syslogdConfig = syslogdConfig;\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The execution context.\n     */\n    public void run() {\n        // get the context\n        //\n        m_context = Thread.currentThread();\n\n        // Get a log instance\n        //\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_stop) {\n            log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else\n            log.debug(\"Thread context started\");\n\n        // allocate a buffer\n        final int length = 0xffff;\n        final byte[] buffer = new byte[length];\n\n        // set an SO timout to make sure we don't block forever\n        // if a socket is closed.\n        try {\n            log.debug(\"Setting socket timeout to 500ms\");\n            m_dgSock.setSoTimeout(500);\n        } catch (SocketException e) {\n            log.warn(\n                    \"An I/O error occured while trying to set the socket timeout\",\n                    e);\n        }\n\n        // Increase the receive buffer for the\n        // socket\n        try {\n            log.debug(\"Setting receive buffer size to \" + length);\n            m_dgSock.setReceiveBufferSize(length);\n        } catch (SocketException e) {\n            log.info(\"Failed to set the receive buffer to \" + length, e);\n        }\n        // set to avoid numerious tracing message\n        // \n        boolean ioInterrupted = false;\n        // now start processing incomming request\n        //\n        while (!m_stop) {\n            if (m_context.isInterrupted()) {\n                log.debug(\"Thread context interrupted\");\n                break;\n            }\n\n            try {\n                if (!ioInterrupted)\n                    log.debug(\"Wating on a datagram to arrive\");\n                DatagramPacket pkt = new DatagramPacket(buffer, length);\n                m_dgSock.receive(pkt);\n                //SyslogConnection *Must* copy pkt datas and InetAddress as DatagramPacket is a mutable type\n                Thread worker = new Thread(new SyslogConnection(pkt, m_matchPattern, m_hostGroup, m_messageGroup, m_UeiList, m_HideMessages, m_discardUei));\n                worker.start();\n                ioInterrupted = false; // reset the flag\n            }\n\t\tcatch (SocketTimeoutException e) {\n\t\t  ioInterrupted = true;\n\t\t  continue;\n\t\t} \n\t\tcatch (InterruptedIOException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (IOException e) {\n                log.error(\n                        \"An I/O exception occured on the datagram receipt port, exiting\",\n                        e);\n                break;\n            }\n\n        } // end while status ok\n\n        log.debug(\"Thread context exiting\");\n\n    }","id":84471,"modified_method":"/**\n     * The execution context.\n     */\n    public void run() {\n        // get the context\n        m_context = Thread.currentThread();\n\n        // Get a log instance\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_stop) {\n            log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else\n            log.debug(\"Thread context started\");\n\n        // allocate a buffer\n        final int length = 0xffff;\n        final byte[] buffer = new byte[length];\n\n        // set an SO timeout to make sure we don't block forever\n        // if a socket is closed.\n        try {\n            log.debug(\"Setting socket timeout to \" + SOCKET_TIMEOUT + \"ms\");\n            m_dgSock.setSoTimeout(SOCKET_TIMEOUT);\n        } catch (SocketException e) {\n            log.warn(\"An I/O error occured while trying to set the socket timeout\", e);\n        }\n\n        // Increase the receive buffer for the socket\n        try {\n            log.debug(\"Setting receive buffer size to \" + length);\n            m_dgSock.setReceiveBufferSize(length);\n        } catch (SocketException e) {\n            log.info(\"Failed to set the receive buffer to \" + length, e);\n        }\n        // set to avoid numerous tracing message\n        boolean ioInterrupted = false;\n        // now start processing incoming requests\n        while (!m_stop) {\n            if (m_context.isInterrupted()) {\n                log.debug(\"Thread context interrupted\");\n                break;\n            }\n\n            try {\n                if (!ioInterrupted) {\n                    log.debug(\"Wating on a datagram to arrive\");\n                }\n\n                DatagramPacket pkt = new DatagramPacket(buffer, length);\n                m_dgSock.receive(pkt);\n\n                //SyslogConnection *Must* copy packet data and InetAddress as DatagramPacket is a mutable type\n                Thread worker = new Thread(new SyslogConnection(pkt, m_matchPattern, m_hostGroup, m_messageGroup, m_UeiList, m_HideMessages, m_discardUei));\n                worker.start();\n                ioInterrupted = false; // reset the flag\n            } catch (SocketTimeoutException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (InterruptedIOException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (IOException e) {\n                log.error(\"An I/O exception occured on the datagram receipt port, exiting\", e);\n                break;\n            }\n\n        } // end while status OK\n\n        log.debug(\"Thread context exiting\");\n\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DEBUG);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n\n    }","id":84472,"modified_method":"public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        MockLogAppender.assertNotGreaterOrEqual(Level.FATAL);\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DEBUG);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n\n    }","commit_id":"a09866c508e14bd82c71a2e6e1d4fa1bd67a3f52","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructs a new event encapsulation instance based upon the\n     * information passed to the method. The passed byte array is decoded into\n     * a string using the <tt>US-ASCII<\/tt> character encoding.\n     *\n     * @param addr The remote agent's address.\n     * @param port The remote agent's port\n     * @param data The XML data in US-ASCII encoding.\n     * @param len  The length of the XML data in the buffer.\n     * @throws java.io.UnsupportedEncodingException\n     *          Thrown if the data buffer cannot be decoded using the\n     *          US-ASCII encoding.\n     * @throws MessageDiscardedException \n     */\n    static ConvertToEvent make(InetAddress addr, int port, byte[] data,\n                               int len, String matchPattern, int hostGroup, int messageGroup,\n                               UeiList ueiList, HideMessage hideMessage, String discardUei)\n            throws UnsupportedEncodingException, MessageDiscardedException {\n\n        ConvertToEvent e = new ConvertToEvent();\n\n        // Get host address /\n\n        e.m_sender = addr;\n        e.m_port = port;\n        e.m_eventXML = new String(data, 0, len, \"US-ASCII\");\n        e.m_ackEvents = new ArrayList<Event>(16);\n        e.m_log = null;\n\n        String m_logPrefix = Syslogd.LOG4J_CATEGORY;\n        ThreadCategory.setPrefix(m_logPrefix);\n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        Category log = ThreadCategory.getInstance();\n\n        log.debug(\"In the make part of UdpReceivedSyslog \" + e.toString());\n\n        // Build a basic event out of the syslog message\n\n        Event event = new Event();\n        event.setSource(\"syslogd\");\n\n        // Set nodeId\n\n        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\",\n                \"\"));\n        // log.debug(\"Nodeid via SyslogdIPMgr \" +\n        // SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\",\"\")));\n\n        if (nodeId != -1)\n            event.setNodeid(nodeId);\n\n        // Set event host\n        //\n        try {\n            event.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            event.setHost(\"unresolved.host\");\n            log.warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        event.setInterface(addr.toString().replaceAll(\"/\", \"\"));\n\n        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));\n        Logmsg logmsg = new Logmsg();\n        logmsg.setDest(\"logndisplay\");\n\n        String message = new String(data, 0, len, \"US-ASCII\");\n\n        // log.debug(\"The parsed message... \" + message );\n\n        int lbIdx = message.indexOf('<');\n        int rbIdx = message.indexOf('>');\n\n        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {\n            log.warn(\"Syslogd received an unparsable message!\");\n        }\n\n        int priCode = 0;\n        String priStr = message.substring(lbIdx + 1, rbIdx);\n\n        try {\n            priCode = Integer.parseInt(priStr);\n        } catch (NumberFormatException ex) {\n            log.debug(\"ERROR Bad priority code '\" + priStr + \"'\");\n\n        }\n\n        int facility = SyslogDefs.extractFacility(priCode);\n        int priority = SyslogDefs.extractPriority(priCode);\n\n        String priorityTxt = SyslogDefs.getPriorityName(priority);\n        // event.setSeverity(priorityTxt);\n        // We leave the priority alone, this might need to be set.\n\n        String facilityTxt = SyslogDefs.getFacilityName(facility);\n\n        //Check for UEI matching or allow a simple standard one.\n\n        event.setUei(\"uei.opennms.org/syslogd/\" + facilityTxt + \"/\"\n                + priorityTxt);\n\n        // message = message.substring(rbIdx + 1, (message.length() - 1));\n\n        message = message.substring(rbIdx + 1, (message.length()));\n\n        //\n        // Check to see if msg looks non-standard.\n        // In this case, it means that there is not a standard\n        // date in the front of the message text.\n        //\n        boolean stdMsg = true;\n\n        if (message.length() < 16) {\n            stdMsg = false;\n        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '\n                || message.charAt(9) != ':' || message.charAt(12) != ':'\n                || message.charAt(15) != ' ') {\n            stdMsg = false;\n        }\n\n        String timestamp;\n\n        if (!stdMsg) {\n            try {\n                timestamp = SyslogTimeStamp.getInstance().format(new Date());\n            } catch (IllegalArgumentException ex) {\n                log.debug(\"ERROR INTERNAL DATE ERROR!\");\n                timestamp = \"\";\n            }\n        } else {\n            timestamp = message.substring(0, 15);\n            message = message.substring(16);\n        }\n\n        // These 2 debugs will aid in analyzing the regexpes as syslog seems\n        // to differ alot\n        // depending on implementation or message structure.\n\n        log.debug(\"Message : \" + message);\n        log.debug(\"Pattern : \" + matchPattern);\n        log.debug(\"Host group: \" + hostGroup);\n        log.debug(\"Message group: \" + messageGroup);\n\n        // We will also here find out if, the host needs to\n        // be replaced, the message matched to a UEI, and\n        // last if we need to actually hide the message.\n        // this being potentially helpful in avoiding showing\n        // operator a password or other data that should be\n        // confindential.\n\n        Pattern pattern = Pattern.compile(matchPattern);\n        Matcher m = pattern.matcher(message);\n\n        /*\n        * We matched on a regexp for host/message pair.\n        * This can be a forwarded message as in BSD Style\n        * or syslog-ng.\n        * We assume that the host is given to us\n        * as an IP/Hostname and that the resolver\n        * on the ONMS host actually can resolve the\n        * node to match against nodeId.\n         */\n\n        // Antonio: Here seems to me a duplicated match\n        // m is setted why i need to reassign?\n        // What is wrong?\n        // This is causing a trouble generating syslog events not needed\n        // I added an else with trowing \n        // Bug # 3278\n        if ((m = pattern.matcher(message)).matches()) {\n\n            log.debug(\"Regexp matched message: \" + message);\n            log.debug(\"Host: \" + m.group(hostGroup));\n            log.debug(\"Message: \" + m.group(messageGroup));\n\n            // We will try and extract an IP address from\n            // a hostname.....\n\n            String myHost = \"\";\n\n            try {\n                InetAddress address = InetAddress.getByName(m.group(hostGroup));\n                byte[] ipAddr = address.getAddress();\n\n                // Convert to dot representation\n                for (int i = 0; i < ipAddr.length; i++) {\n                    if (i > 0) {\n                        myHost += \".\";\n                    }\n                    myHost += ipAddr[i] & 0xFF;\n                }\n            } catch (UnknownHostException e1) {\n                log.info(\"Could not parse the host: \" + e1);\n\n            }\n\n            if (!\"\".equals(myHost)) {\n                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(\n                        \"/\",\n                        \"\"));\n\n                if (nodeId != -1)\n                  event.setNodeid(nodeId);\n                  // Clean up for further processing....\n                  event.setInterface(myHost.replaceAll(\"/\", \"\"));\n                message = m.group(messageGroup);\n                log.debug(\"Regexp used to find node: \" + event.getNodeid());\n            }\n        } else {\n            log.error(\"Regexp not matched message: \" + message);            \n            throw new MessageDiscardedException();\n        }\n\n        // We will need these shortly\n        Parms eventParms = new Parms();\n        Parm eventParm = null;\n        Value parmValue = null;\n        \n        Pattern msgPat;\n        Matcher msgMat;\n\n        // Time to verify UEI matching.\n\n        for (UeiMatch uei : ueiList.getUeiMatchCollection()) {\n            if (uei.getMatch().getType().equals(\"substr\")) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting substring match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n            \tif (message.contains(uei.getMatch().getExpression())) {\n            \t    if (discardUei.equals(uei.getUei())) {\n            \t        if (log.isDebugEnabled()) {\n            \t            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n            \t            throw new MessageDiscardedException();\n            \t        }\n            \t    }\n                    //We can pass a new UEI on this\n                    log.debug(\"Changed the UEI of a Syslogd event, based on substring match, to :\" + uei.getUei());\n                    event.setUei(uei.getUei());\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n                    break;\n                }\n            } else if (uei.getMatch().getType().equals(\"regex\")) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting regex match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n                try {\n            \t\tmsgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);\n            \t\tmsgMat = msgPat.matcher(message);\n                } catch(PatternSyntaxException pse) {\n            \t\tlog.error(\"Failed to compile regex pattern '\"+uei.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    if (discardUei.equals(uei.getUei())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n                            throw new MessageDiscardedException();\n                        }\n                    }\n            \t    // We matched a UEI\n            \t\tlog.debug(\"Changed the UEI of a Syslogd event, based on regex match, to :\" + uei.getUei());\n            \t\tevent.setUei(uei.getUei());\n            \t\tif (msgMat.groupCount() > 0) {\n            \t\t\tfor (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {\n            \t\t\t\tlog.debug(\"Added parm 'group\"+groupNum+\"' with value '\"+msgMat.group(groupNum)+\"' to Syslogd event based on regex match group\");\n            \t\t\t\teventParm = new Parm();\n            \t\t\t\teventParm.setParmName(\"group\"+groupNum);\n            \t\t\t\tparmValue = new Value();\n            \t\t\t\tparmValue.setContent(msgMat.group(groupNum));\n            \t\t\t\teventParm.setValue(parmValue);\n            \t\t\t\teventParms.addParm(eventParm);\n            \t\t\t}\n            \t\t}\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n            \t\tbreak;\n            \t}\n            }\n        }\n\n        // Time to verify if we need to hide the message\n\n        boolean doHide = false;\n        for (HideMatch hide : hideMessage.getHideMatchCollection()) {\n            if (hide.getMatch().getType().equals(\"substr\")) {\n                if (message.contains(hide.getMatch().getExpression())) {\n                    // We should hide the message based on this match\n                \tdoHide = true;\n                }            \t\n            } else if (hide.getMatch().getType().equals(\"regex\")) {\n            \ttry {\n                \tmsgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);\n                \tmsgMat = msgPat.matcher(message);            \t\t\n            \t} catch (PatternSyntaxException pse) {\n            \t\tlog.error(\"Failed to compile regex pattern '\"+hide.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    // We should hide the message based on this match\n            \t\tdoHide = true;\n            \t}\n            }\n            if (doHide) {\n\t            log.debug(\"Hiding syslog message from Event - May contain sensitive data\");\n\t            message = HIDDEN_MESSAGE;\n\t            // We want to stop here, no point in checking further hideMatches\n\t            break;\n            }\n        }\n\n        lbIdx = message.indexOf('[');\n        rbIdx = message.indexOf(']');\n        int colonIdx = message.indexOf(':');\n        int spaceIdx = message.indexOf(' ');\n\n        int processId = 0;\n        String processName = \"\";\n        String processIdStr = \"\";\n\n        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, lbIdx);\n            processIdStr = message.substring(lbIdx + 1, rbIdx);\n            message = message.substring(colonIdx + 2);\n\n            try {\n                processId = Integer.parseInt(processIdStr);\n            } catch (NumberFormatException ex) {\n                log.debug(\"ERROR Bad process id '\" + processIdStr + \"'\");\n                processId = 0;\n            }\n        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, colonIdx);\n            message = message.substring(colonIdx + 2);\n        }\n\n        // Using parms provides configurability.\n        logmsg.setContent(message);\n        event.setLogmsg(logmsg);\n\n        // Add appropriate parms\n        eventParm = new Parm();\n        eventParm.setParmName(\"syslogmessage\");\n        parmValue = new Value();\n        parmValue.setContent((message));\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"severity\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + priorityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"timestamp\");\n        parmValue = new Value();\n        parmValue.setContent(timestamp);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"process\");\n        parmValue = new Value();\n        parmValue.setContent(processName);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"service\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + facilityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"processid\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + processId);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        // Good thing(TM)\n        event.setParms(eventParms);\n\n        e.m_event = event;\n        return e;\n    }","id":84473,"modified_method":"/**\n     * Constructs a new event encapsulation instance based upon the\n     * information passed to the method. The passed byte array is decoded into\n     * a string using the <tt>US-ASCII<\/tt> character encoding.\n     *\n     * @param addr The remote agent's address.\n     * @param port The remote agent's port\n     * @param data The XML data in US-ASCII encoding.\n     * @param len  The length of the XML data in the buffer.\n     * @throws java.io.UnsupportedEncodingException\n     *          Thrown if the data buffer cannot be decoded using the\n     *          US-ASCII encoding.\n     * @throws MessageDiscardedException \n     */\n    static ConvertToEvent make(InetAddress addr, int port, byte[] data,\n                               int len, String matchPattern, int hostGroup, int messageGroup,\n                               UeiList ueiList, HideMessage hideMessage, String discardUei)\n            throws UnsupportedEncodingException, MessageDiscardedException {\n\n        ConvertToEvent e = new ConvertToEvent();\n\n        // Get host address /\n\n        e.m_sender = addr;\n        e.m_port = port;\n        e.m_eventXML = new String(data, 0, len, \"US-ASCII\");\n        e.m_ackEvents = new ArrayList<Event>(16);\n        e.m_log = null;\n\n        String m_logPrefix = Syslogd.LOG4J_CATEGORY;\n        ThreadCategory.setPrefix(m_logPrefix);\n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        Category log = ThreadCategory.getInstance();\n\n        if (log.isDebugEnabled())\n            log.debug(\"In the make part of UdpReceivedSyslog \" + e.toString());\n\n        // Build a basic event out of the syslog message\n\n        Event event = new Event();\n        event.setSource(\"syslogd\");\n\n        // Set nodeId\n        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll(\"/\", \"\"));\n        if (nodeId != -1)\n            event.setNodeid(nodeId);\n\n        // Set event host\n        try {\n            event.setHost(InetAddress.getLocalHost().getHostName());\n        } catch (UnknownHostException uhE) {\n            event.setHost(\"unresolved.host\");\n            log.warn(\"Failed to resolve local hostname\", uhE);\n        }\n\n        event.setInterface(addr.toString().replaceAll(\"/\", \"\"));\n\n        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));\n        Logmsg logmsg = new Logmsg();\n        logmsg.setDest(\"logndisplay\");\n\n        String message = new String(data, 0, len, \"US-ASCII\");\n\n        int lbIdx = message.indexOf('<');\n        int rbIdx = message.indexOf('>');\n\n        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {\n            log.warn(\"Syslogd received an unparsable message!\");\n        }\n\n        int priCode = 0;\n        String priStr = message.substring(lbIdx + 1, rbIdx);\n\n        try {\n            priCode = Integer.parseInt(priStr);\n        } catch (NumberFormatException ex) {\n            log.debug(\"ERROR Bad priority code '\" + priStr + \"'\");\n\n        }\n\n        int facility = SyslogDefs.extractFacility(priCode);\n        int priority = SyslogDefs.extractPriority(priCode);\n\n        String priorityTxt = SyslogDefs.getPriorityName(priority);\n        // event.setSeverity(priorityTxt);\n        // We leave the priority alone, this might need to be set.\n\n        String facilityTxt = SyslogDefs.getFacilityName(facility);\n\n        //Check for UEI matching or allow a simple standard one.\n\n        event.setUei(\"uei.opennms.org/syslogd/\" + facilityTxt + \"/\" + priorityTxt);\n\n        // message = message.substring(rbIdx + 1, (message.length() - 1));\n        message = message.substring(rbIdx + 1, (message.length()));\n\n        // Check to see if message looks non-standard.\n        // In this case, it means that there is not a standard\n        // date in the front of the message text.\n        boolean stdMsg = true;\n\n        if (message.length() < 16) {\n            stdMsg = false;\n        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '\n                || message.charAt(9) != ':' || message.charAt(12) != ':'\n                || message.charAt(15) != ' ') {\n            stdMsg = false;\n        }\n\n        String timestamp;\n\n        if (!stdMsg) {\n            try {\n                timestamp = SyslogTimeStamp.getInstance().format(new Date());\n            } catch (IllegalArgumentException ex) {\n                log.debug(\"ERROR INTERNAL DATE ERROR!\");\n                timestamp = \"\";\n            }\n        } else {\n            timestamp = message.substring(0, 15);\n            message = message.substring(16);\n        }\n\n        // These 2 debugs will aid in analyzing the regexes as syslog seems\n        // to differ a lot depending on implementation or message structure.\n\n        boolean traceEnabled = log.isEnabledFor(Level.TRACE);\n\n        if (traceEnabled) {\n            log.log(Level.TRACE, \"Message : \" + message);\n            log.log(Level.TRACE, \"Pattern : \" + matchPattern);\n            log.log(Level.TRACE, \"Host group: \" + hostGroup);\n            log.log(Level.TRACE, \"Message group: \" + messageGroup);\n        }\n\n        // We will also here find out if, the host needs to\n        // be replaced, the message matched to a UEI, and\n        // last if we need to actually hide the message.\n        // this being potentially helpful in avoiding showing\n        // operator a password or other data that should be\n        // confidential.\n\n        Pattern pattern = Pattern.compile(matchPattern);\n        Matcher m = pattern.matcher(message);\n\n        /*\n        * We matched on a regexp for host/message pair.\n        * This can be a forwarded message as in BSD Style\n        * or syslog-ng.\n        * We assume that the host is given to us\n        * as an IP/Hostname and that the resolver\n        * on the ONMS host actually can resolve the\n        * node to match against nodeId.\n         */\n\n        if (m.matches()) {\n\n            if (traceEnabled) {\n                log.log(Level.TRACE, \"Regexp matched message: \" + message);\n                log.log(Level.TRACE, \"Host: \" + m.group(hostGroup));\n                log.log(Level.TRACE, \"Message: \" + m.group(messageGroup));\n            }\n\n            // We will try to extract an IP address from a hostname.....\n            String myHost = \"\";\n\n            try {\n                InetAddress address = InetAddress.getByName(m.group(hostGroup));\n                byte[] ipAddr = address.getAddress();\n\n                // Convert to dot representation\n                for (int i = 0; i < ipAddr.length; i++) {\n                    if (i > 0) {\n                        myHost += \".\";\n                    }\n                    myHost += ipAddr[i] & 0xFF;\n                }\n            } catch (UnknownHostException e1) {\n                log.warn(\"Could not parse the host: \" + e1);\n\n            }\n\n            if (!\"\".equals(myHost)) {\n                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(\"/\", \"\"));\n\n                if (nodeId != -1) {\n                    event.setNodeid(nodeId);\n                }\n                // Clean up for further processing....\n                event.setInterface(myHost.replaceAll(\"/\", \"\"));\n                message = m.group(messageGroup);\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Regexp used to find node: \" + event.getNodeid());\n                }\n            }\n        } else {\n            log.warn(\"Regexp not matched: \" + message);            \n            throw new MessageDiscardedException();\n        }\n\n        // We will need these shortly\n        Parms eventParms = new Parms();\n        Parm eventParm = null;\n        Value parmValue = null;\n        \n        Pattern msgPat;\n        Matcher msgMat;\n\n        // Time to verify UEI matching.\n\n        for (UeiMatch uei : ueiList.getUeiMatchCollection()) {\n            if (uei.getMatch().getType().equals(\"substr\")) {\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Attempting substring match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n            \tif (message.contains(uei.getMatch().getExpression())) {\n            \t    if (discardUei.equals(uei.getUei())) {\n            \t        if (traceEnabled) {\n            \t            log.log(Level.TRACE, \"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n            \t            throw new MessageDiscardedException();\n            \t        }\n            \t    }\n                    //We can pass a new UEI on this\n            \t    if (traceEnabled) {\n            \t        log.log(Level.TRACE, \"Changed the UEI of a Syslogd event, based on substring match, to :\" + uei.getUei());\n            \t    }\n                    event.setUei(uei.getUei());\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n                    break;\n                }\n            } else if (uei.getMatch().getType().equals(\"regex\")) {\n                if (traceEnabled) {\n                    log.log(Level.TRACE, \"Attempting regex match for text of a Syslogd event to :\" + uei.getMatch().getExpression());\n                }\n                try {\n            \t\tmsgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);\n            \t\tmsgMat = msgPat.matcher(message);\n                } catch(PatternSyntaxException pse) {\n            \t\tlog.warn(\"Failed to compile regex pattern '\"+uei.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    if (discardUei.equals(uei.getUei())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Specified UEI '\" + uei.getUei() + \"' is same as discard-uei, discarding this message.\");\n                        }\n                        throw new MessageDiscardedException();\n                    }\n\n                    // We matched a UEI\n                    if (traceEnabled) {\n                        log.log(Level.TRACE, \"Changed the UEI of a Syslogd event, based on regex match, to :\" + uei.getUei());\n                    }\n                    event.setUei(uei.getUei());\n            \t\tif (msgMat.groupCount() > 0) {\n            \t\t\tfor (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {\n            \t\t\t    if (traceEnabled) {\n            \t\t\t        log.log(Level.TRACE, \"Added parm 'group\"+groupNum+\"' with value '\"+msgMat.group(groupNum)+\"' to Syslogd event based on regex match group\");\n            \t\t\t    }\n            \t\t\t\teventParm = new Parm();\n            \t\t\t\teventParm.setParmName(\"group\"+groupNum);\n            \t\t\t\tparmValue = new Value();\n            \t\t\t\tparmValue.setContent(msgMat.group(groupNum));\n            \t\t\t\teventParm.setValue(parmValue);\n            \t\t\t\teventParms.addParm(eventParm);\n            \t\t\t}\n            \t\t}\n                    // I think we want to stop processing here so the first\n                    // ueiMatch wins, right?\n            \t\tbreak;\n            \t}\n            }\n        }\n\n        // Time to verify if we need to hide the message\n        boolean doHide = false;\n        for (HideMatch hide : hideMessage.getHideMatchCollection()) {\n            if (hide.getMatch().getType().equals(\"substr\")) {\n                if (message.contains(hide.getMatch().getExpression())) {\n                    // We should hide the message based on this match\n                \tdoHide = true;\n                }            \t\n            } else if (hide.getMatch().getType().equals(\"regex\")) {\n            \ttry {\n                \tmsgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);\n                \tmsgMat = msgPat.matcher(message);            \t\t\n            \t} catch (PatternSyntaxException pse) {\n            \t\tlog.warn(\"Failed to compile regex pattern '\"+hide.getMatch().getExpression()+\"'\", pse);\n            \t\tmsgMat = null;\n            \t}\n            \tif ((msgMat != null) && (msgMat.matches())) {\n                    // We should hide the message based on this match\n            \t\tdoHide = true;\n            \t}\n            }\n            if (doHide) {\n\t            log.debug(\"Hiding syslog message from Event - May contain sensitive data\");\n\t            message = HIDDEN_MESSAGE;\n\t            // We want to stop here, no point in checking further hideMatches\n\t            break;\n            }\n        }\n\n        lbIdx = message.indexOf('[');\n        rbIdx = message.indexOf(']');\n        int colonIdx = message.indexOf(':');\n        int spaceIdx = message.indexOf(' ');\n\n        int processId = 0;\n        String processName = \"\";\n        String processIdStr = \"\";\n\n        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, lbIdx);\n            processIdStr = message.substring(lbIdx + 1, rbIdx);\n            message = message.substring(colonIdx + 2);\n\n            try {\n                processId = Integer.parseInt(processIdStr);\n            } catch (NumberFormatException ex) {\n                log.debug(\"Bad process id '\" + processIdStr + \"'\");\n                processId = 0;\n            }\n        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {\n            processName = message.substring(0, colonIdx);\n            message = message.substring(colonIdx + 2);\n        }\n\n        // Using parms provides configurability.\n        logmsg.setContent(message);\n        event.setLogmsg(logmsg);\n\n        // Add appropriate parms\n        eventParm = new Parm();\n        eventParm.setParmName(\"syslogmessage\");\n        parmValue = new Value();\n        parmValue.setContent((message));\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"severity\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + priorityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"timestamp\");\n        parmValue = new Value();\n        parmValue.setContent(timestamp);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"process\");\n        parmValue = new Value();\n        parmValue.setContent(processName);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"service\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + facilityTxt);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        eventParm = new Parm();\n        eventParm.setParmName(\"processid\");\n        parmValue = new Value();\n        parmValue.setContent(\"\" + processId);\n        eventParm.setValue(parmValue);\n        eventParms.addParm(eventParm);\n\n        // Good thing(TM)\n        event.setParms(eventParms);\n\n        e.m_event = event;\n        return e;\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The event processing execution context.\n     */\n    public void run() {\n        // The runnable context\n        //\n        m_context = Thread.currentThread();\n\n        // get a logger\n        //\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean isTracing = log.isDebugEnabled();\n\n        if (m_stop) {\n            if (isTracing)\n                log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else if (isTracing)\n            log.debug(\"Thread context started\");\n\n        // This loop is labeled so that it can be\n        // exited quickly when the thread is interrupted\n        //\n        RunLoop:\n        while (!m_stop) {\n\n            ConvertToEvent o = null;\n\n            o = SyslogHandler.queueManager.getFromQueue();\n\n            if (o != null) {\n                try {\n                    log.debug(\"Processing a syslog to event dispatch\"\n                            + o.toString());\n\n                    // print out the eui, source, and other\n                    // important aspects\n                    //\n                    String uuid = o.getEvent().getUuid();\n                    log.debug(\"Event {\");\n                    log.debug(\"  uuid  = \"\n                            + (uuid != null && uuid.length() > 0 ? uuid\n                            : \"<not-set>\"));\n                    log.debug(\"  uei   = \" + o.getEvent().getUei());\n                    log.debug(\"  src   = \" + o.getEvent().getSource());\n                    log.debug(\"  iface = \" + o.getEvent().getInterface());\n                    log.debug(\"  time  = \" + o.getEvent().getTime());\n                    log.debug(\"  Msg   = \"\n                            + o.getEvent().getLogmsg().getContent());\n                    log.debug(\"  Dst   = \"\n                            + o.getEvent().getLogmsg().getDest());\n                    Parm[] parms = (o.getEvent().getParms() == null ? null\n                            : o.getEvent().getParms().getParm());\n                    if (parms != null) {\n                        log.debug(\"  parms {\");\n                        for (Parm parm : parms) {\n                            if ((parm.getParmName() != null)\n                                    && (parm.getValue().getContent() != null)) {\n                                log.debug(\"    (\"\n                                        + parm.getParmName().trim()\n                                        + \", \"\n                                        + parm.getValue().getContent().trim()\n                                        + \")\");\n                            }\n                        }\n                        log.debug(\"  }\");\n                    }\n                    log.debug(\"}\");\n\n                    EventIpcManagerFactory.getIpcManager().sendNow(\n                            o.getEvent());\n                    // !event.hasNodeid() && m_newSuspect\n                    if (m_NewSuspectOnMessage && !o.getEvent().hasNodeid()) {\n                        log.debug(\"Syslogd: Found a new suspect \"\n                                + o.getEvent().getInterface());\n                        sendNewSuspectEvent(o.getEvent().getInterface());\n                    }\n\n                } catch (Throwable t) {\n                    log.error(\n                            \"Unexpected error processing SyslogMessage - Could not send\",\n                            t);\n\n                }\n            }\n\n        }\n\n    }","id":84474,"modified_method":"/**\n     * The event processing execution context.\n     */\n    public void run() {\n        // The runnable context\n        m_context = Thread.currentThread();\n\n        // get a logger\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean isTracing = log.isEnabledFor(Level.TRACE);\n\n        if (m_stop) {\n            if (isTracing)\n                log.log(Level.TRACE, \"Stop flag set before thread started, exiting\");\n            return;\n        } else if (isTracing)\n            log.debug(\"Thread context started\");\n\n        while (!m_stop) {\n\n            ConvertToEvent o = null;\n\n            o = SyslogHandler.queueManager.getFromQueue();\n\n            if (o != null) {\n                try {\n                    if (isTracing)  {\n                        log.log(Level.TRACE, \"Processing a syslog to event dispatch\" + o.toString());\n                        String uuid = o.getEvent().getUuid();\n                        log.log(Level.TRACE, \"Event {\");\n                        log.log(Level.TRACE, \"  uuid  = \"\n                                + (uuid != null && uuid.length() > 0 ? uuid\n                                : \"<not-set>\"));\n                        log.log(Level.TRACE, \"  uei   = \" + o.getEvent().getUei());\n                        log.log(Level.TRACE, \"  src   = \" + o.getEvent().getSource());\n                        log.log(Level.TRACE, \"  iface = \" + o.getEvent().getInterface());\n                        log.log(Level.TRACE, \"  time  = \" + o.getEvent().getTime());\n                        log.log(Level.TRACE, \"  Msg   = \"\n                                + o.getEvent().getLogmsg().getContent());\n                        log.log(Level.TRACE, \"  Dst   = \"\n                                + o.getEvent().getLogmsg().getDest());\n                        Parm[] parms = (o.getEvent().getParms() == null ? null\n                                : o.getEvent().getParms().getParm());\n                        if (parms != null) {\n                            log.log(Level.TRACE, \"  parms {\");\n                            for (Parm parm : parms) {\n                                if ((parm.getParmName() != null)\n                                        && (parm.getValue().getContent() != null)) {\n                                    log.log(Level.TRACE, \"    (\"\n                                            + parm.getParmName().trim()\n                                            + \", \"\n                                            + parm.getValue().getContent().trim()\n                                            + \")\");\n                                }\n                            }\n                            log.log(Level.TRACE, \"  }\");\n                        }\n                        log.log(Level.TRACE, \"}\");\n                    }\n\n                    EventIpcManagerFactory.getIpcManager().sendNow(o.getEvent());\n\n                    if (m_NewSuspectOnMessage && !o.getEvent().hasNodeid()) {\n                        if (isTracing) {\n                            log.log(Level.TRACE, \"Syslogd: Found a new suspect \" + o.getEvent().getInterface());\n                        }\n                        sendNewSuspectEvent(o.getEvent().getInterface());\n                    }\n\n                } catch (Throwable t) {\n                    log.error(\"Unexpected error processing SyslogMessage - Could not send\", t);\n                }\n            }\n\n        }\n\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void setSyslogConfig(SyslogdConfig syslogdConfig) {\n        SyslogdConfig m_syslogdConfig = syslogdConfig;\n\n    }","id":84475,"modified_method":"public static void setSyslogConfig(SyslogdConfig syslogdConfig) {\n        @SuppressWarnings(\"unused\")\n        SyslogdConfig m_syslogdConfig = syslogdConfig;\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"SyslogProcessor(boolean newSuspectOnMessage, String forwardingRegexp, int matchingGroupHost,\n                    int matchingGroupMessage, UeiList ueiList, HideMessage hideMessages) {\n        m_context = null;\n        m_stop = false;\n        m_NewSuspectOnMessage = newSuspectOnMessage;\n        m_ForwardingRegexp = forwardingRegexp;\n        m_MatchingGroupHost = matchingGroupHost;\n        m_MatchingGroupMessage = matchingGroupMessage;\n        m_UeiList = ueiList;\n        m_HideMessages = hideMessages;\n\n        m_logPrefix = Syslogd.LOG4J_CATEGORY;\n\n        try {\n            m_localAddr = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException uhE) {\n            Category log = ThreadCategory.getInstance(getClass());\n\n            m_localAddr = \"localhost\";\n            log.error(\"<ctor>: Error looking up local hostname\", uhE);\n        }\n\n    }","id":84476,"modified_method":"SyslogProcessor(boolean newSuspectOnMessage, String forwardingRegexp, int matchingGroupHost,\n                    int matchingGroupMessage, UeiList ueiList, HideMessage hideMessages) {\n        m_context = null;\n        m_stop = false;\n        m_NewSuspectOnMessage = newSuspectOnMessage;\n\n        m_logPrefix = Syslogd.LOG4J_CATEGORY;\n\n        try {\n            m_localAddr = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException uhE) {\n            Category log = ThreadCategory.getInstance(getClass());\n\n            m_localAddr = \"localhost\";\n            log.error(\"Error looking up local hostname; using 'localhost'\", uhE);\n        }\n\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Stops the current context\n     */\n    void stop() throws InterruptedException {\n        m_stop = true;\n        if (m_context != null) {\n            Category log = ThreadCategory.getInstance(getClass());\n            if (log.isDebugEnabled())\n                log.debug(\"Stopping and joining thread context \"\n                        + m_context.getName());\n\n            m_context.interrupt();\n            m_context.join();\n\n            if (log.isDebugEnabled())\n                log.debug(\"Thread context stopped and joined\");\n        }\n    }","id":84477,"modified_method":"/**\n     * Stops the current context\n     */\n    void stop() throws InterruptedException {\n        m_stop = true;\n        if (m_context != null) {\n            Category log = ThreadCategory.getInstance(getClass());\n            if (log.isDebugEnabled())\n                log.debug(\"Stopping and joining thread context \" + m_context.getName());\n\n            m_context.interrupt();\n            m_context.join();\n\n            log.debug(\"Thread context stopped and joined\");\n        }\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The execution context.\n     */\n    public void run() {\n        // get the context\n        //\n        m_context = Thread.currentThread();\n\n        // Get a log instance\n        //\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_stop) {\n            log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else\n            log.debug(\"Thread context started\");\n\n        // allocate a buffer\n        final int length = 0xffff;\n        final byte[] buffer = new byte[length];\n\n        // set an SO timout to make sure we don't block forever\n        // if a socket is closed.\n        try {\n            log.debug(\"Setting socket timeout to 500ms\");\n            m_dgSock.setSoTimeout(500);\n        } catch (SocketException e) {\n            log.warn(\n                    \"An I/O error occured while trying to set the socket timeout\",\n                    e);\n        }\n\n        // Increase the receive buffer for the\n        // socket\n        try {\n            log.debug(\"Setting receive buffer size to \" + length);\n            m_dgSock.setReceiveBufferSize(length);\n        } catch (SocketException e) {\n            log.info(\"Failed to set the receive buffer to \" + length, e);\n        }\n        // set to avoid numerious tracing message\n        // \n        boolean ioInterrupted = false;\n        // now start processing incomming request\n        //\n        while (!m_stop) {\n            if (m_context.isInterrupted()) {\n                log.debug(\"Thread context interrupted\");\n                break;\n            }\n\n            try {\n                if (!ioInterrupted)\n                    log.debug(\"Wating on a datagram to arrive\");\n                DatagramPacket pkt = new DatagramPacket(buffer, length);\n                m_dgSock.receive(pkt);\n                //SyslogConnection *Must* copy pkt datas and InetAddress as DatagramPacket is a mutable type\n                Thread worker = new Thread(new SyslogConnection(pkt, m_matchPattern, m_hostGroup, m_messageGroup, m_UeiList, m_HideMessages, m_discardUei));\n                worker.start();\n                ioInterrupted = false; // reset the flag\n            }\n\t\tcatch (SocketTimeoutException e) {\n\t\t  ioInterrupted = true;\n\t\t  continue;\n\t\t} \n\t\tcatch (InterruptedIOException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (IOException e) {\n                log.error(\n                        \"An I/O exception occured on the datagram receipt port, exiting\",\n                        e);\n                break;\n            }\n\n        } // end while status ok\n\n        log.debug(\"Thread context exiting\");\n\n    }","id":84478,"modified_method":"/**\n     * The execution context.\n     */\n    public void run() {\n        // get the context\n        m_context = Thread.currentThread();\n\n        // Get a log instance\n        ThreadCategory.setPrefix(m_logPrefix);\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_stop) {\n            log.debug(\"Stop flag set before thread started, exiting\");\n            return;\n        } else\n            log.debug(\"Thread context started\");\n\n        // allocate a buffer\n        final int length = 0xffff;\n        final byte[] buffer = new byte[length];\n\n        // set an SO timeout to make sure we don't block forever\n        // if a socket is closed.\n        try {\n            log.debug(\"Setting socket timeout to \" + SOCKET_TIMEOUT + \"ms\");\n            m_dgSock.setSoTimeout(SOCKET_TIMEOUT);\n        } catch (SocketException e) {\n            log.warn(\"An I/O error occured while trying to set the socket timeout\", e);\n        }\n\n        // Increase the receive buffer for the socket\n        try {\n            log.debug(\"Setting receive buffer size to \" + length);\n            m_dgSock.setReceiveBufferSize(length);\n        } catch (SocketException e) {\n            log.info(\"Failed to set the receive buffer to \" + length, e);\n        }\n        // set to avoid numerous tracing message\n        boolean ioInterrupted = false;\n        // now start processing incoming requests\n        while (!m_stop) {\n            if (m_context.isInterrupted()) {\n                log.debug(\"Thread context interrupted\");\n                break;\n            }\n\n            try {\n                if (!ioInterrupted) {\n                    log.debug(\"Wating on a datagram to arrive\");\n                }\n\n                DatagramPacket pkt = new DatagramPacket(buffer, length);\n                m_dgSock.receive(pkt);\n\n                //SyslogConnection *Must* copy packet data and InetAddress as DatagramPacket is a mutable type\n                Thread worker = new Thread(new SyslogConnection(pkt, m_matchPattern, m_hostGroup, m_messageGroup, m_UeiList, m_HideMessages, m_discardUei));\n                worker.start();\n                ioInterrupted = false; // reset the flag\n            } catch (SocketTimeoutException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (InterruptedIOException e) {\n                ioInterrupted = true;\n                continue;\n            } catch (IOException e) {\n                log.error(\"An I/O exception occured on the datagram receipt port, exiting\", e);\n                break;\n            }\n\n        } // end while status OK\n\n        log.debug(\"Thread context exiting\");\n\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DEBUG);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n\n    }","id":84479,"modified_method":"public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        MockLogAppender.assertNotGreaterOrEqual(Level.FATAL);\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DEBUG);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n\n    }","commit_id":"65eeb4a78bb69b79e78d9b5542621e5adf464979","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testPostingsHighlighterTermRangeQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"aaab\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(rangeQuery(\"field2\").gte(\"aaaa\").lt(\"zzzz\"))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"<em>aaab<\/em>\"));\n    }","id":84480,"modified_method":"@Test\n    public void testPostingsHighlighterTermRangeQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"aaab\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(rangeQuery(\"field2\").gte(\"aaaa\").lt(\"zzzz\"))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"<em>aaab<\/em>\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterQueryString() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(queryString(\"qui*\").defaultField(\"field2\").rewrite(rewriteMethod))\n                    .highlight(highlight().field(\"field2\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n\n            assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n        }\n    }","id":84481,"modified_method":"@Test\n    public void testPostingsHighlighterQueryString() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(queryString(\"qui*\").defaultField(\"field2\").rewrite(randomFrom(REWRITE_METHODS)))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testGlobalHighlightingSettingsOverriddenAtFieldLevel() {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", new String[]{\"this is a test\", \"this is the second test\"},\n                        \"field2\", new String[]{\"this is another test\", \"yet another test\"}).get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1 and field2 produces different tags\");\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"field1\", \"test\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().order(\"score\").preTags(\"<global>\").postTags(\"<\/global>\").fragmentSize(1).numOfFragments(1)\n                        .field(new HighlightBuilder.Field(\"field1\").numOfFragments(2))\n                        .field(new HighlightBuilder.Field(\"field2\").preTags(\"<field2>\").postTags(\"<\/field2>\").fragmentSize(50)));\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 2, equalTo(\" <global>test<\/global>\"));\n        assertHighlight(searchResponse, 0, \"field1\", 1, 2, equalTo(\" <global>test<\/global>\"));\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"this is another <field2>test<\/field2>\"));\n    }","id":84482,"modified_method":"@Test\n    public void testGlobalHighlightingSettingsOverriddenAtFieldLevel() {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", new String[]{\"this is a test\", \"this is the second test\"},\n                        \"field2\", new String[]{\"this is another test\", \"yet another test\"}).get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1 and field2 produces different tags\");\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"field1\", \"test\"))\n                .highlight(highlight().order(\"score\").preTags(\"<global>\").postTags(\"<\/global>\").fragmentSize(1).numOfFragments(1)\n                        .field(new HighlightBuilder.Field(\"field1\").numOfFragments(2))\n                        .field(new HighlightBuilder.Field(\"field2\").preTags(\"<field2>\").postTags(\"<\/field2>\").fragmentSize(50)));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 2, equalTo(\" <global>test<\/global>\"));\n        assertHighlight(searchResponse, 0, \"field1\", 1, 2, equalTo(\" <global>test<\/global>\"));\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"this is another <field2>test<\/field2>\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterPrefixQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(prefixQuery(\"field2\", \"qui\").rewrite(rewriteMethod))\n                    .highlight(highlight().field(\"field2\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n            assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n        }\n    }","id":84483,"modified_method":"@Test\n    public void testPostingsHighlighterPrefixQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n\n        SearchSourceBuilder source = searchSource().query(prefixQuery(\"field2\", \"qui\").rewrite(randomFrom(REWRITE_METHODS)))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPlainHighlighter() throws Exception {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"field1\", \"test\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field1\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field1\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"test\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field1\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"quick\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(prefixQuery(\"_all\", \"qui\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all with constant score, highlighting on field2\");\n        source = searchSource()\n                .query(constantScoreQuery(prefixQuery(\"_all\", \"qui\")))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all with constant score, highlighting on field2\");\n        source = searchSource()\n                .query(boolQuery().should(constantScoreQuery(prefixQuery(\"_all\", \"qui\"))))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n    }","id":84484,"modified_method":"@Test\n    public void testPlainHighlighter() throws Exception {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"field1\", \"test\"))\n                .highlight(highlight().field(\"field1\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field1\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"test\"))\n                .highlight(highlight().field(\"field1\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"quick\"))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(prefixQuery(\"_all\", \"qui\"))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all with constant score, highlighting on field2\");\n        source = searchSource()\n                .query(constantScoreQuery(prefixQuery(\"_all\", \"qui\")))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all with constant score, highlighting on field2\");\n        source = searchSource()\n                .query(boolQuery().should(constantScoreQuery(prefixQuery(\"_all\", \"qui\"))))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testBoostingQuery() {\n        createIndex(\"test\");\n        ensureGreen();\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(boostingQuery().positive(termQuery(\"field2\", \"brown\")).negative(termQuery(\"field2\", \"foobar\")).negativeBoost(0.5f))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The quick <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","id":84485,"modified_method":"@Test\n    public void testBoostingQuery() {\n        createIndex(\"test\");\n        ensureGreen();\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(boostingQuery().positive(termQuery(\"field2\", \"brown\")).negative(termQuery(\"field2\", \"foobar\")).negativeBoost(0.5f))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The quick <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testBoostingQueryTermVector() throws ElasticsearchException, IOException {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\")\n                .get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(boostingQuery().positive(termQuery(\"field2\", \"brown\")).negative(termQuery(\"field2\", \"foobar\")).negativeBoost(0.5f))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().search(\n                searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The quick <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","id":84486,"modified_method":"@Test\n    public void testBoostingQueryTermVector() throws ElasticsearchException, IOException {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\")\n                .get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(boostingQuery().positive(termQuery(\"field2\", \"brown\")).negative(termQuery(\"field2\", \"foobar\")).negativeBoost(0.5f))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The quick <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterFuzzyQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(fuzzyQuery(\"field2\", \"quck\"))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n    }","id":84487,"modified_method":"@Test\n    public void testPostingsHighlighterFuzzyQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(fuzzyQuery(\"field2\", \"quck\"))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testFastVectorHighlighter() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"field1\", \"test\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field1\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field1\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"test\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field1\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"quick\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(prefixQuery(\"_all\", \"qui\"))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n    }","id":84488,"modified_method":"@Test\n    public void testFastVectorHighlighter() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(termQuery(\"field1\", \"test\"))\n                .highlight(highlight().field(\"field1\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field1\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"test\"))\n                .highlight(highlight().field(\"field1\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"this is a <xxx>test<\/xxx>\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(termQuery(\"_all\", \"quick\"))\n                .highlight(highlight().field(\"field2\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n\n        logger.info(\"--> searching on _all, highlighting on field2\");\n        source = searchSource()\n                .query(prefixQuery(\"_all\", \"qui\"))\n                .highlight(highlight().field(\"field2\", 100, 0).order(\"score\").preTags(\"<xxx>\").postTags(\"<\/xxx>\"));\n\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <xxx>quick<\/xxx> brown fox jumps over the lazy dog\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterMultiTermQueryMultipleLevels() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(boolQuery()\n                    .should(constantScoreQuery(FilterBuilders.missingFilter(\"field1\")))\n                    .should(matchQuery(\"field1\", \"test\"))\n                    .should(filteredQuery(queryString(\"field1:photo*\").rewrite(rewriteMethod), null)))\n                    .highlight(highlight().field(\"field1\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n            assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n        }\n    }","id":84489,"modified_method":"@Test\n    public void testPostingsHighlighterMultiTermQueryMultipleLevels() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource().query(boolQuery()\n                .should(constantScoreQuery(FilterBuilders.missingFilter(\"field1\")))\n                .should(matchQuery(\"field1\", \"test\"))\n                .should(filteredQuery(queryString(\"field1:photo*\").rewrite(randomFrom(REWRITE_METHODS)), null)))\n                .highlight(highlight().field(\"field1\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    @Slow\n    public void testFastVectorHighlighterManyDocs() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n\n        int COUNT = between(20, 100);\n        IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[COUNT];\n        for (int i = 0; i < COUNT; i++) {\n            indexRequestBuilders[i] = client().prepareIndex(\"test\", \"type1\", Integer.toString(i)).setSource(\"field1\", \"test \" + i);\n        }\n        logger.info(\"--> indexing docs\");\n        indexRandom(true, indexRequestBuilders);\n\n        logger.info(\"--> searching explicitly on field1 and highlighting on it\");\n        SearchResponse searchResponse = client().prepareSearch()\n                .setSize(COUNT)\n                .setQuery(termQuery(\"field1\", \"test\"))\n                .addHighlightedField(\"field1\", 100, 0)\n                .get();\n        for (int i = 0; i < COUNT; i++) {\n            SearchHit hit = searchResponse.getHits().getHits()[i];\n            // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n            assertHighlight(searchResponse, i, \"field1\", 0, 1, equalTo(\"<em>test<\/em> \" + hit.id()));\n        }\n\n        logger.info(\"--> searching explicitly on field1 and highlighting on it, with DFS\");\n        searchResponse = client().prepareSearch()\n                .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)\n                .setSize(COUNT)\n                .setQuery(termQuery(\"field1\", \"test\"))\n                .addHighlightedField(\"field1\", 100, 0)\n                .get();\n        for (int i = 0; i < COUNT; i++) {\n            SearchHit hit = searchResponse.getHits().getHits()[i];\n            assertHighlight(searchResponse, i, \"field1\", 0, 1, equalTo(\"<em>test<\/em> \" + hit.id()));\n        }\n\n        logger.info(\"--> searching explicitly _all and highlighting on _all\");\n        searchResponse = client().prepareSearch()\n                .setSize(COUNT)\n                .setQuery(termQuery(\"_all\", \"test\"))\n                .addHighlightedField(\"_all\", 100, 0)\n                .get();\n        for (int i = 0; i < COUNT; i++) {\n            SearchHit hit = searchResponse.getHits().getHits()[i];\n            assertHighlight(searchResponse, i, \"_all\", 0, 1, equalTo(\"<em>test<\/em> \" + hit.id() + \" \"));\n        }\n    }","id":84490,"modified_method":"@Test\n    @Slow\n    public void testFastVectorHighlighterManyDocs() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n\n        int COUNT = between(20, 100);\n        IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[COUNT];\n        for (int i = 0; i < COUNT; i++) {\n            indexRequestBuilders[i] = client().prepareIndex(\"test\", \"type1\", Integer.toString(i)).setSource(\"field1\", \"test \" + i);\n        }\n        logger.info(\"--> indexing docs\");\n        indexRandom(true, indexRequestBuilders);\n\n        logger.info(\"--> searching explicitly on field1 and highlighting on it\");\n        SearchResponse searchResponse = client().prepareSearch()\n                .setSize(COUNT)\n                .setQuery(termQuery(\"field1\", \"test\"))\n                .addHighlightedField(\"field1\", 100, 0)\n                .get();\n        for (int i = 0; i < COUNT; i++) {\n            SearchHit hit = searchResponse.getHits().getHits()[i];\n            // LUCENE 3.1 UPGRADE: Caused adding the space at the end...\n            assertHighlight(searchResponse, i, \"field1\", 0, 1, equalTo(\"<em>test<\/em> \" + hit.id()));\n        }\n\n        logger.info(\"--> searching explicitly _all and highlighting on _all\");\n        searchResponse = client().prepareSearch()\n                .setSize(COUNT)\n                .setQuery(termQuery(\"_all\", \"test\"))\n                .addHighlightedField(\"_all\", 100, 0)\n                .get();\n        for (int i = 0; i < COUNT; i++) {\n            SearchHit hit = searchResponse.getHits().getHits()[i];\n            assertHighlight(searchResponse, i, \"_all\", 0, 1, equalTo(\"<em>test<\/em> \" + hit.id() + \" \"));\n        }\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    @Slow\n    public void testPostingsHighlighterManyDocs() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        int COUNT = between(20, 100);\n        Map<String, String> prefixes = new HashMap<>(COUNT);\n\n        IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[COUNT];\n        for (int i = 0; i < COUNT; i++) {\n            //generating text with word to highlight in a different position\n            //(https://github.com/elasticsearch/elasticsearch/issues/4103)\n            String prefix = randomAsciiOfLengthBetween(5, 30);\n            prefixes.put(String.valueOf(i), prefix);\n            indexRequestBuilders[i] = client().prepareIndex(\"test\", \"type1\", Integer.toString(i)).setSource(\"field1\", \"Sentence \" + prefix\n                    + \" test. Sentence two.\");\n        }\n        logger.info(\"--> indexing docs\");\n        indexRandom(true, indexRequestBuilders);\n\n        logger.info(\"--> searching explicitly on field1 and highlighting on it\");\n        SearchResponse searchResponse = client().prepareSearch()\n                .setSize(COUNT)\n                .setQuery(termQuery(\"field1\", \"test\"))\n                .addHighlightedField(\"field1\")\n                .get();\n        assertHitCount(searchResponse, (long)COUNT);\n        assertThat(searchResponse.getHits().hits().length, equalTo(COUNT));\n        for (SearchHit hit : searchResponse.getHits()) {\n            String prefix = prefixes.get(hit.id());\n            assertHighlight(hit, \"field1\", 0, 1, equalTo(\"Sentence \" + prefix + \" <em>test<\/em>.\"));\n        }\n\n        logger.info(\"--> searching explicitly on field1 and highlighting on it, with DFS\");\n        searchResponse = client().prepareSearch()\n                .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)\n                .setSize(COUNT)\n                .setQuery(termQuery(\"field1\", \"test\"))\n                .addHighlightedField(\"field1\")\n                .get();\n        assertHitCount(searchResponse, (long)COUNT);\n        assertThat(searchResponse.getHits().hits().length, equalTo(COUNT));\n        for (SearchHit hit : searchResponse.getHits()) {\n            String prefix = prefixes.get(hit.id());\n            assertHighlight(hit, \"field1\", 0, 1, equalTo(\"Sentence \" + prefix + \" <em>test<\/em>.\"));\n        }\n    }","id":84491,"modified_method":"@Test\n    @Slow\n    public void testPostingsHighlighterManyDocs() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        int COUNT = between(20, 100);\n        Map<String, String> prefixes = new HashMap<>(COUNT);\n\n        IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[COUNT];\n        for (int i = 0; i < COUNT; i++) {\n            //generating text with word to highlight in a different position\n            //(https://github.com/elasticsearch/elasticsearch/issues/4103)\n            String prefix = randomAsciiOfLengthBetween(5, 30);\n            prefixes.put(String.valueOf(i), prefix);\n            indexRequestBuilders[i] = client().prepareIndex(\"test\", \"type1\", Integer.toString(i)).setSource(\"field1\", \"Sentence \" + prefix\n                    + \" test. Sentence two.\");\n        }\n        logger.info(\"--> indexing docs\");\n        indexRandom(true, indexRequestBuilders);\n\n        logger.info(\"--> searching explicitly on field1 and highlighting on it\");\n        SearchRequestBuilder searchRequestBuilder = client().prepareSearch()\n                .setSize(COUNT)\n                .setQuery(termQuery(\"field1\", \"test\"))\n                .addHighlightedField(\"field1\");\n        SearchResponse searchResponse =\n                searchRequestBuilder.get();\n        assertHitCount(searchResponse, (long)COUNT);\n        assertThat(searchResponse.getHits().hits().length, equalTo(COUNT));\n        for (SearchHit hit : searchResponse.getHits()) {\n            String prefix = prefixes.get(hit.id());\n            assertHighlight(hit, \"field1\", 0, 1, equalTo(\"Sentence \" + prefix + \" <em>test<\/em>.\"));\n        }\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private <P extends QueryBuilder & BoostableQueryBuilder<?>> void\n            phraseBoostTestCaseForClauses(String highlighterType, float boost, QueryBuilder terms, P phrase) {\n        Matcher<String> highlightedMatcher = Matchers.<String>either(containsString(\"<em>highlight words together<\/em>\")).or(\n                containsString(\"<em>highlight<\/em> <em>words<\/em> <em>together<\/em>\"));\n        SearchRequestBuilder search = client().prepareSearch(\"test\").setHighlighterRequireFieldMatch(true)\n                .setHighlighterOrder(\"score\").setHighlighterType(highlighterType)\n                .addHighlightedField(\"field1\", 100, 1);\n\n        // Try with a bool query\n        phrase.boost(boost);\n        SearchResponse response = search.setQuery(boolQuery().must(terms).should(phrase)).get();\n        assertHighlight(response, 0, \"field1\", 0, 1, highlightedMatcher);\n        phrase.boost(1);\n        // Try with a boosting query\n        response = search.setQuery(boostingQuery().positive(phrase).negative(terms).boost(boost).negativeBoost(1)).get();\n        assertHighlight(response, 0, \"field1\", 0, 1, highlightedMatcher);\n        // Try with a boosting query using a negative boost\n        response = search.setQuery(boostingQuery().positive(phrase).negative(terms).boost(1).negativeBoost(1/boost)).get();\n        assertHighlight(response, 0, \"field1\", 0, 1, highlightedMatcher);\n    }","id":84492,"modified_method":"private <P extends QueryBuilder & BoostableQueryBuilder<?>> void\n            phraseBoostTestCaseForClauses(String highlighterType, float boost, QueryBuilder terms, P phrase) {\n        Matcher<String> highlightedMatcher = Matchers.either(containsString(\"<em>highlight words together<\/em>\")).or(\n                containsString(\"<em>highlight<\/em> <em>words<\/em> <em>together<\/em>\"));\n        SearchRequestBuilder search = client().prepareSearch(\"test\").setHighlighterRequireFieldMatch(true)\n                .setHighlighterOrder(\"score\").setHighlighterType(highlighterType)\n                .addHighlightedField(\"field1\", 100, 1);\n\n        // Try with a bool query\n        phrase.boost(boost);\n        SearchResponse response = search.setQuery(boolQuery().must(terms).should(phrase)).get();\n        assertHighlight(response, 0, \"field1\", 0, 1, highlightedMatcher);\n        phrase.boost(1);\n        // Try with a boosting query\n        response = search.setQuery(boostingQuery().positive(phrase).negative(terms).boost(boost).negativeBoost(1)).get();\n        assertHighlight(response, 0, \"field1\", 0, 1, highlightedMatcher);\n        // Try with a boosting query using a negative boost\n        response = search.setQuery(boostingQuery().positive(phrase).negative(terms).boost(1).negativeBoost(1/boost)).get();\n        assertHighlight(response, 0, \"field1\", 0, 1, highlightedMatcher);\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCommonTermsTermVector() throws ElasticsearchException, IOException {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource().query(commonTerms(\"field2\", \"quick brown\").cutoffFrequency(100)).from(0).size(60)\n                .explain(true).highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().search(\n                searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <x>quick<\/x> <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","id":84493,"modified_method":"@Test\n    public void testCommonTermsTermVector() throws ElasticsearchException, IOException {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1TermVectorMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource().query(commonTerms(\"field2\", \"quick brown\").cutoffFrequency(100))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <x>quick<\/x> <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterRegexpQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(regexpQuery(\"field2\", \"qu[a-l]+k\").rewrite(rewriteMethod))\n                    .highlight(highlight().field(\"field2\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n\n            assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n        }\n    }","id":84494,"modified_method":"@Test\n    public void testPostingsHighlighterRegexpQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(regexpQuery(\"field2\", \"qu[a-l]+k\").rewrite(randomFrom(REWRITE_METHODS)))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterWildcardQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(wildcardQuery(\"field2\", \"qui*\").rewrite(rewriteMethod))\n                    .highlight(highlight().field(\"field2\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n\n            assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n\n            source = searchSource().query(wildcardQuery(\"field2\", \"qu*k\").rewrite(rewriteMethod))\n                    .highlight(highlight().field(\"field2\"));\n            searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n            assertHitCount(searchResponse, 1l);\n\n            assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n        }\n    }","id":84495,"modified_method":"@Test\n    public void testPostingsHighlighterWildcardQuery() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog! Second sentence.\").get();\n        refresh();\n        logger.info(\"--> highlighting and searching on field2\");\n        SearchSourceBuilder source = searchSource().query(wildcardQuery(\"field2\", \"qui*\").rewrite(randomFrom(REWRITE_METHODS)))\n                .highlight(highlight().field(\"field2\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n\n        source = searchSource().query(wildcardQuery(\"field2\", \"qu*k\").rewrite(randomFrom(REWRITE_METHODS)))\n                .highlight(highlight().field(\"field2\"));\n        searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHitCount(searchResponse, 1l);\n\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <em>quick<\/em> brown fox jumps over the lazy dog!\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterRegexpQueryWithinConstantScoreQuery() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(constantScoreQuery(regexpQuery(\"field1\", \"pho[a-z]+\").rewrite(rewriteMethod)))\n                    .highlight(highlight().field(\"field1\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n            assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n        }\n    }","id":84496,"modified_method":"@Test\n    public void testPostingsHighlighterRegexpQueryWithinConstantScoreQuery() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource().query(constantScoreQuery(regexpQuery(\"field1\", \"pho[a-z]+\").rewrite(randomFrom(REWRITE_METHODS))))\n                .highlight(highlight().field(\"field1\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterPrefixQueryWithinBooleanQuery() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(boolQuery().must(prefixQuery(\"field1\", \"photo\").rewrite(rewriteMethod)).should(matchQuery(\"field1\", \"test\").minimumShouldMatch(\"0\")))\n                    .highlight(highlight().field(\"field1\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n            assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n        }\n    }","id":84497,"modified_method":"@Test\n    public void testPostingsHighlighterPrefixQueryWithinBooleanQuery() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource().query(boolQuery().must(prefixQuery(\"field1\", \"photo\").rewrite(randomFrom(REWRITE_METHODS))).should(matchQuery(\"field1\", \"test\").minimumShouldMatch(\"0\")))\n                .highlight(highlight().field(\"field1\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCommonTermsQuery() {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\")\n                .get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(commonTerms(\"field2\", \"quick brown\").cutoffFrequency(100))\n                .from(0).size(60).explain(true)\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source).searchType(QUERY_THEN_FETCH)).actionGet();\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <x>quick<\/x> <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","id":84498,"modified_method":"@Test\n    public void testCommonTermsQuery() {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\")\n                .setSource(\"field1\", \"this is a test\", \"field2\", \"The quick brown fox jumps over the lazy dog\")\n                .get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource()\n                .query(commonTerms(\"field2\", \"quick brown\").cutoffFrequency(100))\n                .highlight(highlight().field(\"field2\").order(\"score\").preTags(\"<x>\").postTags(\"<\/x>\"));\n\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field2\", 0, 1, equalTo(\"The <x>quick<\/x> <x>brown<\/x> fox jumps over the lazy dog\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPostingsHighlighterQueryStringWithinFilteredQuery() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        for (String rewriteMethod : REWRITE_METHODS) {\n            SearchSourceBuilder source = searchSource().query(filteredQuery(queryString(\"field1:photo*\").rewrite(rewriteMethod), missingFilter(\"field_null\")))\n                    .highlight(highlight().field(\"field1\"));\n            SearchResponse searchResponse = client().search(searchRequest(\"test\").source(source)\n                    .searchType(randomBoolean() ? SearchType.DFS_QUERY_THEN_FETCH : SearchType.QUERY_THEN_FETCH)).get();\n            assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n        }\n    }","id":84499,"modified_method":"@Test\n    public void testPostingsHighlighterQueryStringWithinFilteredQuery() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", type1PostingsffsetsMapping()));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\").setSource(\"field1\", \"The photography word will get highlighted\").get();\n        refresh();\n\n        logger.info(\"--> highlighting and searching on field1\");\n        SearchSourceBuilder source = searchSource().query(filteredQuery(queryString(\"field1:photo*\").rewrite(randomFrom(REWRITE_METHODS)), missingFilter(\"field_null\")))\n                .highlight(highlight().field(\"field1\"));\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setSource(source.buildAsBytes()).get();\n        assertHighlight(searchResponse, 0, \"field1\", 0, 1, equalTo(\"The <em>photography<\/em> word will get highlighted\"));\n    }","commit_id":"e8995ecaa78a38245329e8532b5a81034e2ae230","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Returns the encoded URL for the current audio content.\n\t * Don't call this method unless _audio is not null;\n\t */\n\tprivate String getAudioSrc() {\n\t\tfinal Desktop desktop = getDesktop();\n\t\tif (desktop == null) return \"\"; //no avail at client\n\n\t\tfinal StringBuffer sb = new StringBuffer(64).append('/');\n\t\tStrings.encode(sb, _audver);\n\t\tfinal String name = _audio.getName();\n\t\tfinal String format = _audio.getFormat();\n\t\tif (name != null || format != null) {\n\t\t\tsb.append('/');\n\t\t\tboolean bExtRequired = true;\n\t\t\tif (name != null && name.length() != 0) {\n\t\t\t\tsb.append(name);\n\t\t\t\tbExtRequired = name.lastIndexOf('.') < 0;\n\t\t\t} else {\n\t\t\t\tsb.append(getId());\n\t\t\t}\n\t\t\tif (bExtRequired && format != null)\n\t\t\t\tsb.append('.').append(format);\n\t\t}\n\t\treturn desktop.getDynamicMediaURI(this, sb.toString()); //already encoded\n\t}","id":84500,"modified_method":"/** Returns the encoded URL for the current audio content.\n\t * Don't call this method unless _audio is not null;\n\t */\n\tprivate String getAudioSrc() {\n\t\treturn Utils.getEncodedURI(\n\t\t\tthis, _audver, _audio.getName(), _audio.getFormat());\n\t}","commit_id":"0168bd78d27e714674f6b4e176319bb930d4911a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the encoded URL for the current media content.\n\t * Don't call this method unless _media is not null;\n\t */\n\tprivate String getMediaSrc() {\n\t\tfinal Desktop desktop = getDesktop();\n\t\tif (desktop == null) return \"\"; //no avail at client\n\n\t\tfinal StringBuffer sb = new StringBuffer(64).append('/');\n\t\tStrings.encode(sb, _medver);\n\t\tfinal String name = _media.getName();\n\t\tfinal String format = _media.getFormat();\n\t\tif (name != null || format != null) {\n\t\t\tsb.append('/');\n\t\t\tboolean bExtRequired = true;\n\t\t\tif (name != null && name.length() != 0) {\n\t\t\t\tsb.append(name);\n\t\t\t\tbExtRequired = name.lastIndexOf('.') < 0;\n\t\t\t} else {\n\t\t\t\tsb.append(getId());\n\t\t\t}\n\t\t\tif (bExtRequired && format != null)\n\t\t\t\tsb.append('.').append(format);\n\t\t}\n\t\treturn desktop.getDynamicMediaURI(this, sb.toString()); //already encoded\n\t}","id":84501,"modified_method":"/** Returns the encoded URL for the current media content.\n\t * Don't call this method unless _media is not null;\n\t */\n\tprivate String getMediaSrc() {\n\t\treturn Utils.getEncodedURI(\n\t\t\tthis, _medver, _media.getName(), _media.getFormat());\n\t}","commit_id":"0168bd78d27e714674f6b4e176319bb930d4911a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the encoded URL for the current image content.\n\t * Don't call this method unless _image is not null;\n\t *\n\t * <p>Used only for component template, not for application developers.\n\t */\n\tprivate String getContentSrc() {\n\t\tfinal Desktop desktop = getDesktop();\n\t\tif (desktop == null) return \"\"; //no avail at client\n\n\t\tfinal StringBuffer sb = new StringBuffer(64).append('/');\n\t\tStrings.encode(sb, _imgver);\n\t\tfinal String name = _image.getName();\n\t\tfinal String format = _image.getFormat();\n\t\tif (name != null || format != null) {\n\t\t\tsb.append('/');\n\t\t\tboolean bExtRequired = true;\n\t\t\tif (name != null && name.length() != 0) {\n\t\t\t\tsb.append(name);\n\t\t\t\tbExtRequired = name.lastIndexOf('.') < 0;\n\t\t\t} else {\n\t\t\t\tsb.append(getId());\n\t\t\t}\n\t\t\tif (bExtRequired && format != null)\n\t\t\t\tsb.append('.').append(format);\n\t\t}\n\t\treturn desktop.getDynamicMediaURI(this, sb.toString()); //already encoded\n\t}","id":84502,"modified_method":"/** Returns the encoded URL for the current image content.\n\t * Don't call this method unless _image is not null;\n\t *\n\t * <p>Used only for component template, not for application developers.\n\t */\n\tprivate String getContentSrc() {\n\t\treturn Utils.getEncodedURI(\n\t\t\tthis, _imgver, _image.getName(), _image.getFormat());\n\t}","commit_id":"0168bd78d27e714674f6b4e176319bb930d4911a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the encoded URL for the current image content.\n\t * Don't call this method unless _image is not null;\n\t *\n\t * <p>Used only for component template, not for application developers.\n\t */\n\tprivate String getContentSrc() {\n\t\tfinal Desktop desktop = getDesktop();\n\t\tif (desktop == null) return \"\"; //no avail at client\n\n\t\tfinal StringBuffer sb = new StringBuffer(64).append('/');\n\t\tStrings.encode(sb, _imgver);\n\t\tfinal String name = _image.getName();\n\t\tfinal String format = _image.getFormat();\n\t\tif (name != null || format != null) {\n\t\t\tsb.append('/');\n\t\t\tboolean bExtRequired = true;\n\t\t\tif (name != null && name.length() != 0) {\n\t\t\t\tsb.append(name);\n\t\t\t\tbExtRequired = name.lastIndexOf('.') < 0;\n\t\t\t} else {\n\t\t\t\tsb.append(getId());\n\t\t\t}\n\t\t\tif (bExtRequired && format != null)\n\t\t\t\tsb.append('.').append(format);\n\t\t}\n\t\treturn desktop.getDynamicMediaURI(this, sb.toString()); //already encoded\n\t}","id":84503,"modified_method":"/** Returns the encoded URL for the current image content.\n\t * Don't call this method unless _image is not null;\n\t *\n\t * <p>Used only for component template, not for application developers.\n\t */\n\tprivate String getContentSrc() {\n\t\treturn Utils.getEncodedURI(\n\t\t\tthis, _imgver, _image.getName(), _image.getFormat());\n\t}","commit_id":"0168bd78d27e714674f6b4e176319bb930d4911a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Long rtt = null;\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tint retries = ParameterMap.getKeyedInteger(parameters, \"retry\", pinger.getRetries());\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", pinger.getTimeout());\n\t\t\t\n\t\t\trtt = pinger.ping(host, timeout, retries);\n\t\t} catch (IOException e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setResponseTime(rtt);\n        }\n        \n        return serviceStatus;\n    }","id":84504,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Long rtt = null;\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tint retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n\t\t\t\n\t\t\trtt = pinger.ping(host, timeout, retries);\n\t\t} catch (Exception e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setResponseTime(rtt);\n        }\n        \n        return serviceStatus;\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * \n     * @param address\n     *            The address to check for support.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address) {\n    \tPinger pinger;\n\t\ttry {\n\t\t\tpinger = new Pinger();\n\t    \tLong retval = pinger.ping(address);\n\t    \tif (retval != null) {\n\t    \t\treturn true;\n\t    \t}\n\t\t} catch (IOException e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n\t\t}\n\t\treturn false;\n    }","id":84505,"modified_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * \n     * @param address\n     *            The address to check for support.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address) {\n    \tPinger pinger;\n\t\ttry {\n\t\t\tpinger = new Pinger();\n\t    \tLong retval = pinger.ping(address);\n\t    \tif (retval != null) {\n\t    \t\treturn true;\n\t    \t}\n\t\t} catch (Exception e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n\t\t}\n\t\treturn false;\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map qualifiers) {\n    \tPinger pinger;\n    \tint retries;\n    \tlong timeout;\n\n    \ttry {\n    \t\tpinger = new Pinger();\n    \t\tif (qualifiers != null) {\n    \t\t\tretries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", pinger.getRetries());\n    \t\t\ttimeout = ParameterMap.getKeyedLong(qualifiers, \"timeout\", pinger.getTimeout());\n    \t\t} else {\n    \t\t\tretries = pinger.getRetries();\n    \t\t\ttimeout = pinger.getTimeout();\n    \t\t}\n    \t\tLong retval = pinger.ping(address, timeout, retries);\n    \t\tif (retval != null) {\n    \t\t\treturn true;\n    \t\t}\n    \t} catch (IOException e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n    \t}\n    \t\n    \treturn false;\n    }","id":84506,"modified_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map qualifiers) {\n    \tPinger pinger;\n    \tint retries;\n    \tlong timeout;\n\n    \ttry {\n    \t\tpinger = new Pinger();\n    \t\tif (qualifiers != null) {\n    \t\t\tretries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", Pinger.DEFAULT_RETRIES);\n    \t\t\ttimeout = ParameterMap.getKeyedLong(qualifiers, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n    \t\t} else {\n    \t\t\tretries = Pinger.DEFAULT_RETRIES;\n    \t\t\ttimeout = Pinger.DEFAULT_TIMEOUT;\n    \t\t}\n    \t\tLong retval = pinger.ping(address, timeout, retries);\n    \t\tif (retval != null) {\n    \t\t\treturn true;\n    \t\t}\n    \t} catch (Exception e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n        }\n    \t\n    \treturn false;\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/receive) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\tMap<String, Number> rtt = null;\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tpinger.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", pinger.getRetries()));\n\t\t\tpinger.setTimeout(ParameterMap.getKeyedLong(parameters, \"timeout\", pinger.getTimeout()));\n\t\t\tint count = ParameterMap.getKeyedInteger(parameters, \"pings\", DEFAULT_MULTI_PING_COUNT);\n\t\t\t\n\t\t\trtt = pinger.parallelPing(host, count);\n\t\t} catch (IOException e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setProperties(rtt);\n        }\n        \n        return serviceStatus;\n    }","id":84507,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/receive) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\tList<Number> responseTimes = null;\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n\t\t\tint count = ParameterMap.getKeyedInteger(parameters, \"pings\", DEFAULT_MULTI_PING_COUNT);\n\t\t\tlong pingInterval = ParameterMap.getKeyedLong(parameters, \"interval\", DEFAULT_PING_INTERVAL);\n\t\t\t\n\t\t\tresponseTimes = new ArrayList<Number>(pinger.parallelPing(host, count, timeout, pingInterval));\n\n\t\t\tserviceStatus = PollStatus.available();\n\t\t\tCollections.sort(responseTimes, new Comparator<Number>() {\n\n                public int compare(Number arg0, Number arg1) {\n                    if (arg0 == null) {\n                        return -1;\n                    } else if (arg1 == null) {\n                        return 1;\n                    } else if (arg0.doubleValue() == arg1.doubleValue()) {\n                        return 0;\n                    } else {\n                        return arg1.doubleValue() > arg0.doubleValue()? 1 : -1;\n                    }\n                }\n\t\t\t    \n\t\t\t});\n\t\t\t\n\t\t\tMap<String, Number> returnval = new LinkedHashMap<String,Number>();\n\t\t\tfor (int i = 0; i < responseTimes.size(); i++) {\n\t\t\t    returnval.put(\"ping\" + (i+1), responseTimes.get(i));\n\t\t\t}\n\t\t\treturnval.put(\"loss\", CollectionMath.countNull(responseTimes));\n\t\t\treturnval.put(\"median\", CollectionMath.median(responseTimes));\n\t\t\treturnval.put(\"response-time\", CollectionMath.average(responseTimes));\n\t\t\t\n\t\t\tserviceStatus.setProperties(returnval);\n\t\t} catch (Exception e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        return serviceStatus;\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPing() throws Exception {\n        Map<String,Number> ret = m_pinger.parallelPing(m_goodHost, 10);\n        ArrayList<Number> items = new ArrayList<Number>();\n        for (String key : ret.keySet()) {\n            items.add(ret.get(key));\n            System.out.println(key + \": \" + ret.get(key));\n        }\n        ret.remove(\"loss\");\n        ret.remove(\"median\");\n        ret.remove(\"response-time\");\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","id":84508,"modified_method":"public void testParallelPing() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPingFailure() throws Exception {\n        Map<String,Number> ret = m_pinger.parallelPing(m_badHost, 10);\n        ret.remove(\"loss\");\n        ret.remove(\"median\");\n        ret.remove(\"response-time\");\n        ArrayList<Number>items = new ArrayList<Number>();\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","id":84509,"modified_method":"public void testParallelPingFailure() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException\n\t */\n\tpublic Long ping(InetAddress host) throws IOException {\n\t\treturn this.ping(host, timeout, retries);\n\t}","id":84510,"modified_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException\n\t * @throws InterruptedException \n\t */\n\tpublic Long ping(InetAddress host) throws IOException, InterruptedException {\n\t    return this.ping(host, DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to ping a remote host to test for ICMP support. If\n     * the remote host responds within the specified period, defined by retries\n     * and timeouts, then the response time is returned.\n     * \n     * @param host\n     *            The address to poll.\n     * @param timeout\n     *            The time to wait between each retry.\n     * @param retries\n     *            The number of times to retry\n     * \n     * @return The response time in microseconds if the host is reachable and has responded with an echo reply, otherwise a null value.\n     */\n    public Long ping(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        \n        Long tidKey = getTidKey();\n\n        short sid = sequenceId++;\n    \tDatagramPacket pkt = getDatagram(host, tidKey, sid);\n        PingRequest reply = new PingRequest(host, sid);\n        \n        waiting.put(tidKey, reply);\n        for (int attempts = 0; attempts <= retries && !reply.isSignaled(); ++attempts) {\n            synchronized (reply) {\n                sendPacket(pkt);\n                try {\n                    reply.wait(timeout);\n                } catch (InterruptedException ex) {\n                    // interrupted so return, reset interrupt.\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n        waiting.remove(tidKey);\n        \n        Long rtt = getRTT(reply);\n        if (rtt == null && log.isDebugEnabled()) {\n        \tlog.debug(\"no response time for \" + host + \"received\");\n        } else if (log.isDebugEnabled()){\n        \tlog.debug(\"Ping round trip time for \" + host + \": \" + rtt + \"us\");\n        }\n        return rtt;\n    }","id":84511,"modified_method":"/**\n     * This method is used to ping a remote host to test for ICMP support. If\n     * the remote host responds within the specified period, defined by retries\n     * and timeouts, then the response time is returned.\n     * \n     * @param host\n     *            The address to poll.\n     * @param timeout\n     *            The time to wait between each retry.\n     * @param retries\n     *            The number of times to retry\n     * \n     * @return The response time in microseconds if the host is reachable and has responded with an echo reply, otherwise a null value.\n     * @throws InterruptedException \n     */\n    public Long ping(InetAddress host, long timeout, int retries) throws InterruptedException {\n        SinglePingResponseCallback cb = new SinglePingResponseCallback();\n        ping(host, timeout, retries, (short) 1, cb);\n        cb.waitFor();\n        return cb.getResponseTime();\n    }","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initialize a Pinger object, using the default timeout and retries.\n     * @throws IOException\n     */\n    public Pinger() throws IOException {\n\t\tthis(DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","id":84512,"modified_method":"/**\n     * Initialize a Pinger object, specifying the timeout and retries.\n     * @param defaultTimeout the timeout, in milliseconds, to wait for returned packets.\n     * @param defaultRetries the number of times to retry a given ping packet\n     * @throws IOException\n     */\n\tpublic Pinger() throws IOException {\n\t\tsynchronized (Pinger.class) {\n\t\t\tif (worker == null) {\n\t\t\t    final FifoQueueImpl<Reply> queue = new FifoQueueImpl<Reply>();\n\t\t\t\ticmpSocket = new IcmpSocket();\n                receiver = new ReplyReceiver(icmpSocket, queue, PingRequest.FILTER_ID);\n                receiver.start();\n\t\t\t\t\n                worker = new Thread(new Runnable() {\n                    public void run() {\n                        for (;;) {\n                        \tlong waitTime = minimumWaitTime();\n                        \tif (waitTime > 0) {\n                        \t    try {\n                                    Reply pong = queue.remove(waitTime);\n                                    processReply(pong);\n                        \t    } catch (InterruptedException ie) {\n                        \t        break;\n                        \t    } catch (FifoQueueException fqe) {\n                        \t        ThreadCategory.getInstance(this.getClass()).error(\"Error processing response queue\", fqe);\n                        \t    }\n                        \t} else {\n                        \t    processTimeouts();\n                        \t}\n                        }\n                    }\n                });\n                worker.setDaemon(true);\n                worker.start();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, Number> parallelPing(InetAddress host, int count) throws IOException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        LinkedHashMap<String, Number> returnval = new LinkedHashMap<String, Number>();\n        \n        Long tidKey = getTidKey();\n        ArrayList<PingRequest> requests = new ArrayList<PingRequest>();\n        parallelWaiting.put(tidKey, requests);\n        for (int i = 0; i < count; i++) {\n        \tshort sid = sequenceId++;\n        \tPingRequest reply = new PingRequest(host, sid);\n        \t// log.debug(\"sending packet with ID '\" + tidKey + \"' and sequence '\" + reply.getSequenceId());\n        \trequests.add(reply);\n        \tDatagramPacket pkt = getDatagram(host, tidKey, reply.getSequenceId());\n        \tsynchronized(reply) {\n        \t\tsendPacket(pkt);\n        \t}\n       \t\ttry {\n       \t\t\tThread.sleep(50);\n       \t\t} catch (InterruptedException ex) {\n                Thread.currentThread().interrupt();\n       \t\t}\n        }\n        \n        try {\n            synchronized(requests) {\n            \tThread.sleep(timeout);\n            \trequests.wait(1);\n            \t/* requests.wait(timeout); */\n            }\n        } catch (InterruptedException ex) {\n            // interrupted so return, reset interrupt.\n            Thread.currentThread().interrupt();\n        }\n\n        parallelWaiting.remove(tidKey);\n\n        Collections.sort(requests, new Comparator<PingRequest>() {\n\t\t\tpublic int compare(PingRequest arg0, PingRequest arg1) {\n\t\t\t\tif (!arg0.isSignaled()) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (!arg1.isSignaled()) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn (int)(arg0.getPacket().getPingRTT() - arg1.getPacket().getPingRTT());\n\t\t\t}\n        });\n        for (int i = 0; i < requests.size(); i++) {\n        \tPingRequest reply = requests.get(i);\n        \tif (reply.isSignaled()) {\n        \t\tLong rtt = getRTT(reply);\n        \t\tif (rtt <= (timeout * 1000)) {\n        \t\t\treturnval.put(\"ping\" + (i+1), rtt);\n        \t\t} else {\n        \t\t\tlog.debug(\"a response came back, but it was too old: sid = \" + reply.getSequenceId() + \", rtt = \" + rtt);\n        \t\t\treturnval.put(\"ping\" + (i+1), null);\n        \t\t}\n    \t\t} else {\n    \t\t\tlog.debug(\"no response came back: sid = \" + reply.getSequenceId());\n    \t\t\treturnval.put(\"ping\" + (i+1), null);\n        \t}\n        }\n\n        ArrayList<Number> al = new ArrayList<Number>(returnval.values());\n        returnval.put(\"loss\", new Long(CollectionMath.countNull(al)));\n        returnval.put(\"median\", new Long(CollectionMath.median(al).longValue()));\n        returnval.put(\"response-time\", new Long(CollectionMath.average(al).longValue()));\n        \n        return returnval;\n\t}","id":84513,"modified_method":"public List<Number> parallelPing(InetAddress host, int count, long timeout, long pingInterval) throws IOException, InterruptedException {\n\t    ParallelPingResponseCallback cb = new ParallelPingResponseCallback(count);\n\t    \n\t    for (int i = 0; i < count; i++) {\n\t        PingRequest request = new PingRequest(host, DEFAULT_TIMEOUT, 0, (short) i, cb);\n\t        ping(request, cb);\n\t        Thread.sleep(pingInterval);\n\t    }\n\t    \n\t    cb.waitFor();\n\t    return cb.getResponseTimes();\n\t}","commit_id":"4c6699e22a8c6fea554e57668eadf82cabff925b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Long rtt = null;\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tint retries = ParameterMap.getKeyedInteger(parameters, \"retry\", pinger.getRetries());\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", pinger.getTimeout());\n\t\t\t\n\t\t\trtt = pinger.ping(host, timeout, retries);\n\t\t} catch (IOException e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setResponseTime(rtt);\n        }\n        \n        return serviceStatus;\n    }","id":84514,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Long rtt = null;\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tint retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n\t\t\t\n\t\t\trtt = pinger.ping(host, timeout, retries);\n\t\t} catch (Exception e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setResponseTime(rtt);\n        }\n        \n        return serviceStatus;\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map qualifiers) {\n    \tPinger pinger;\n    \tint retries;\n    \tlong timeout;\n\n    \ttry {\n    \t\tpinger = new Pinger();\n    \t\tif (qualifiers != null) {\n    \t\t\tretries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", pinger.getRetries());\n    \t\t\ttimeout = ParameterMap.getKeyedLong(qualifiers, \"timeout\", pinger.getTimeout());\n    \t\t} else {\n    \t\t\tretries = pinger.getRetries();\n    \t\t\ttimeout = pinger.getTimeout();\n    \t\t}\n    \t\tLong retval = pinger.ping(address, timeout, retries);\n    \t\tif (retval != null) {\n    \t\t\treturn true;\n    \t\t}\n    \t} catch (IOException e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n    \t}\n    \t\n    \treturn false;\n    }","id":84515,"modified_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map qualifiers) {\n    \tPinger pinger;\n    \tint retries;\n    \tlong timeout;\n\n    \ttry {\n    \t\tpinger = new Pinger();\n    \t\tif (qualifiers != null) {\n    \t\t\tretries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", Pinger.DEFAULT_RETRIES);\n    \t\t\ttimeout = ParameterMap.getKeyedLong(qualifiers, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n    \t\t} else {\n    \t\t\tretries = Pinger.DEFAULT_RETRIES;\n    \t\t\ttimeout = Pinger.DEFAULT_TIMEOUT;\n    \t\t}\n    \t\tLong retval = pinger.ping(address, timeout, retries);\n    \t\tif (retval != null) {\n    \t\t\treturn true;\n    \t\t}\n    \t} catch (Exception e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n        }\n    \t\n    \treturn false;\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * \n     * @param address\n     *            The address to check for support.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address) {\n    \tPinger pinger;\n\t\ttry {\n\t\t\tpinger = new Pinger();\n\t    \tLong retval = pinger.ping(address);\n\t    \tif (retval != null) {\n\t    \t\treturn true;\n\t    \t}\n\t\t} catch (IOException e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n\t\t}\n\t\treturn false;\n    }","id":84516,"modified_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * \n     * @param address\n     *            The address to check for support.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address) {\n    \tPinger pinger;\n\t\ttry {\n\t\t\tpinger = new Pinger();\n\t    \tLong retval = pinger.ping(address);\n\t    \tif (retval != null) {\n\t    \t\treturn true;\n\t    \t}\n\t\t} catch (Exception e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n\t\t}\n\t\treturn false;\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/receive) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\tMap<String, Number> rtt = null;\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tpinger.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", pinger.getRetries()));\n\t\t\tpinger.setTimeout(ParameterMap.getKeyedLong(parameters, \"timeout\", pinger.getTimeout()));\n\t\t\tint count = ParameterMap.getKeyedInteger(parameters, \"pings\", DEFAULT_MULTI_PING_COUNT);\n\t\t\t\n\t\t\trtt = pinger.parallelPing(host, count);\n\t\t} catch (IOException e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setProperties(rtt);\n        }\n        \n        return serviceStatus;\n    }","id":84517,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/receive) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\tList<Number> responseTimes = null;\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n\t\t\tint count = ParameterMap.getKeyedInteger(parameters, \"pings\", DEFAULT_MULTI_PING_COUNT);\n\t\t\tlong pingInterval = ParameterMap.getKeyedLong(parameters, \"interval\", DEFAULT_PING_INTERVAL);\n\t\t\t\n\t\t\tresponseTimes = new ArrayList<Number>(pinger.parallelPing(host, count, timeout, pingInterval));\n\n\t\t\tserviceStatus = PollStatus.available();\n\t\t\tCollections.sort(responseTimes, new Comparator<Number>() {\n\n                public int compare(Number arg0, Number arg1) {\n                    if (arg0 == null) {\n                        return -1;\n                    } else if (arg1 == null) {\n                        return 1;\n                    } else if (arg0.doubleValue() == arg1.doubleValue()) {\n                        return 0;\n                    } else {\n                        return arg1.doubleValue() > arg0.doubleValue()? 1 : -1;\n                    }\n                }\n\t\t\t    \n\t\t\t});\n\t\t\t\n\t\t\tMap<String, Number> returnval = new LinkedHashMap<String,Number>();\n\t\t\tfor (int i = 0; i < responseTimes.size(); i++) {\n\t\t\t    returnval.put(\"ping\" + (i+1), responseTimes.get(i));\n\t\t\t}\n\t\t\treturnval.put(\"loss\", CollectionMath.countNull(responseTimes));\n\t\t\treturnval.put(\"median\", CollectionMath.median(responseTimes));\n\t\t\treturnval.put(\"response-time\", CollectionMath.average(responseTimes));\n\t\t\t\n\t\t\tserviceStatus.setProperties(returnval);\n\t\t} catch (Exception e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        return serviceStatus;\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPingFailure() throws Exception {\n        Map<String,Number> ret = m_pinger.parallelPing(m_badHost, 10);\n        ret.remove(\"loss\");\n        ret.remove(\"median\");\n        ret.remove(\"response-time\");\n        ArrayList<Number>items = new ArrayList<Number>();\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","id":84518,"modified_method":"public void testParallelPingFailure() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPing() throws Exception {\n        Map<String,Number> ret = m_pinger.parallelPing(m_goodHost, 10);\n        ArrayList<Number> items = new ArrayList<Number>();\n        for (String key : ret.keySet()) {\n            items.add(ret.get(key));\n            System.out.println(key + \": \" + ret.get(key));\n        }\n        ret.remove(\"loss\");\n        ret.remove(\"median\");\n        ret.remove(\"response-time\");\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","id":84519,"modified_method":"public void testParallelPing() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, Number> parallelPing(InetAddress host, int count) throws IOException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        LinkedHashMap<String, Number> returnval = new LinkedHashMap<String, Number>();\n        \n        Long tidKey = getTidKey();\n        ArrayList<PingRequest> requests = new ArrayList<PingRequest>();\n        parallelWaiting.put(tidKey, requests);\n        for (int i = 0; i < count; i++) {\n        \tshort sid = sequenceId++;\n        \tPingRequest reply = new PingRequest(host, sid);\n        \t// log.debug(\"sending packet with ID '\" + tidKey + \"' and sequence '\" + reply.getSequenceId());\n        \trequests.add(reply);\n        \tDatagramPacket pkt = getDatagram(host, tidKey, reply.getSequenceId());\n        \tsynchronized(reply) {\n        \t\tsendPacket(pkt);\n        \t}\n       \t\ttry {\n       \t\t\tThread.sleep(50);\n       \t\t} catch (InterruptedException ex) {\n                Thread.currentThread().interrupt();\n       \t\t}\n        }\n        \n        try {\n            synchronized(requests) {\n            \tThread.sleep(timeout);\n            \trequests.wait(1);\n            \t/* requests.wait(timeout); */\n            }\n        } catch (InterruptedException ex) {\n            // interrupted so return, reset interrupt.\n            Thread.currentThread().interrupt();\n        }\n\n        parallelWaiting.remove(tidKey);\n\n        Collections.sort(requests, new Comparator<PingRequest>() {\n\t\t\tpublic int compare(PingRequest arg0, PingRequest arg1) {\n\t\t\t\tif (!arg0.isSignaled()) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (!arg1.isSignaled()) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn (int)(arg0.getPacket().getPingRTT() - arg1.getPacket().getPingRTT());\n\t\t\t}\n        });\n        for (int i = 0; i < requests.size(); i++) {\n        \tPingRequest reply = requests.get(i);\n        \tif (reply.isSignaled()) {\n        \t\tLong rtt = getRTT(reply);\n        \t\tif (rtt <= (timeout * 1000)) {\n        \t\t\treturnval.put(\"ping\" + (i+1), rtt);\n        \t\t} else {\n        \t\t\tlog.debug(\"a response came back, but it was too old: sid = \" + reply.getSequenceId() + \", rtt = \" + rtt);\n        \t\t\treturnval.put(\"ping\" + (i+1), null);\n        \t\t}\n    \t\t} else {\n    \t\t\tlog.debug(\"no response came back: sid = \" + reply.getSequenceId());\n    \t\t\treturnval.put(\"ping\" + (i+1), null);\n        \t}\n        }\n\n        ArrayList<Number> al = new ArrayList<Number>(returnval.values());\n        returnval.put(\"loss\", new Long(CollectionMath.countNull(al)));\n        returnval.put(\"median\", new Long(CollectionMath.median(al).longValue()));\n        returnval.put(\"response-time\", new Long(CollectionMath.average(al).longValue()));\n        \n        return returnval;\n\t}","id":84520,"modified_method":"public List<Number> parallelPing(InetAddress host, int count, long timeout, long pingInterval) throws IOException, InterruptedException {\n\t    ParallelPingResponseCallback cb = new ParallelPingResponseCallback(count);\n\t    \n\t    for (int i = 0; i < count; i++) {\n\t        PingRequest request = new PingRequest(host, DEFAULT_TIMEOUT, 0, (short) i, cb);\n\t        ping(request, cb);\n\t        Thread.sleep(pingInterval);\n\t    }\n\t    \n\t    cb.waitFor();\n\t    return cb.getResponseTimes();\n\t}","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initialize a Pinger object, using the default timeout and retries.\n     * @throws IOException\n     */\n    public Pinger() throws IOException {\n\t\tthis(DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","id":84521,"modified_method":"/**\n     * Initialize a Pinger object, specifying the timeout and retries.\n     * @param defaultTimeout the timeout, in milliseconds, to wait for returned packets.\n     * @param defaultRetries the number of times to retry a given ping packet\n     * @throws IOException\n     */\n\tpublic Pinger() throws IOException {\n\t\tsynchronized (Pinger.class) {\n\t\t\tif (worker == null) {\n\t\t\t    final FifoQueueImpl<Reply> queue = new FifoQueueImpl<Reply>();\n\t\t\t\ticmpSocket = new IcmpSocket();\n                receiver = new ReplyReceiver(icmpSocket, queue, PingRequest.FILTER_ID);\n                receiver.start();\n\t\t\t\t\n                worker = new Thread(new Runnable() {\n                    public void run() {\n                        for (;;) {\n                        \tlong waitTime = minimumWaitTime();\n                        \tif (waitTime > 0) {\n                        \t    try {\n                                    Reply pong = queue.remove(waitTime);\n                                    processReply(pong);\n                        \t    } catch (InterruptedException ie) {\n                        \t        break;\n                        \t    } catch (FifoQueueException fqe) {\n                        \t        ThreadCategory.getInstance(this.getClass()).error(\"Error processing response queue\", fqe);\n                        \t    }\n                        \t} else {\n                        \t    processTimeouts();\n                        \t}\n                        }\n                    }\n                });\n                worker.setDaemon(true);\n                worker.start();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to ping a remote host to test for ICMP support. If\n     * the remote host responds within the specified period, defined by retries\n     * and timeouts, then the response time is returned.\n     * \n     * @param host\n     *            The address to poll.\n     * @param timeout\n     *            The time to wait between each retry.\n     * @param retries\n     *            The number of times to retry\n     * \n     * @return The response time in microseconds if the host is reachable and has responded with an echo reply, otherwise a null value.\n     */\n    public Long ping(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        \n        Long tidKey = getTidKey();\n\n        short sid = sequenceId++;\n    \tDatagramPacket pkt = getDatagram(host, tidKey, sid);\n        PingRequest reply = new PingRequest(host, sid);\n        \n        waiting.put(tidKey, reply);\n        for (int attempts = 0; attempts <= retries && !reply.isSignaled(); ++attempts) {\n            synchronized (reply) {\n                sendPacket(pkt);\n                try {\n                    reply.wait(timeout);\n                } catch (InterruptedException ex) {\n                    // interrupted so return, reset interrupt.\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n        waiting.remove(tidKey);\n        \n        Long rtt = getRTT(reply);\n        if (rtt == null && log.isDebugEnabled()) {\n        \tlog.debug(\"no response time for \" + host + \"received\");\n        } else if (log.isDebugEnabled()){\n        \tlog.debug(\"Ping round trip time for \" + host + \": \" + rtt + \"us\");\n        }\n        return rtt;\n    }","id":84522,"modified_method":"/**\n     * This method is used to ping a remote host to test for ICMP support. If\n     * the remote host responds within the specified period, defined by retries\n     * and timeouts, then the response time is returned.\n     * \n     * @param host\n     *            The address to poll.\n     * @param timeout\n     *            The time to wait between each retry.\n     * @param retries\n     *            The number of times to retry\n     * \n     * @return The response time in microseconds if the host is reachable and has responded with an echo reply, otherwise a null value.\n     * @throws InterruptedException \n     */\n    public Long ping(InetAddress host, long timeout, int retries) throws InterruptedException {\n        SinglePingResponseCallback cb = new SinglePingResponseCallback();\n        ping(host, timeout, retries, (short) 1, cb);\n        cb.waitFor();\n        return cb.getResponseTime();\n    }","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException\n\t */\n\tpublic Long ping(InetAddress host) throws IOException {\n\t\treturn this.ping(host, timeout, retries);\n\t}","id":84523,"modified_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException\n\t * @throws InterruptedException \n\t */\n\tpublic Long ping(InetAddress host) throws IOException, InterruptedException {\n\t    return this.ping(host, DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","commit_id":"9c5cafa841ddd472a5e6739a7c359ed3a4bf739e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Long rtt = null;\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tint retries = ParameterMap.getKeyedInteger(parameters, \"retry\", pinger.getRetries());\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", pinger.getTimeout());\n\t\t\t\n\t\t\trtt = pinger.ping(host, timeout, retries);\n\t\t} catch (IOException e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setResponseTime(rtt);\n        }\n        \n        return serviceStatus;\n    }","id":84524,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Long rtt = null;\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tint retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n\t\t\t\n\t\t\trtt = pinger.ping(host, timeout, retries);\n\t\t} catch (Exception e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setResponseTime(rtt);\n        }\n        \n        return serviceStatus;\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map qualifiers) {\n    \tPinger pinger;\n    \tint retries;\n    \tlong timeout;\n\n    \ttry {\n    \t\tpinger = new Pinger();\n    \t\tif (qualifiers != null) {\n    \t\t\tretries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", pinger.getRetries());\n    \t\t\ttimeout = ParameterMap.getKeyedLong(qualifiers, \"timeout\", pinger.getTimeout());\n    \t\t} else {\n    \t\t\tretries = pinger.getRetries();\n    \t\t\ttimeout = pinger.getTimeout();\n    \t\t}\n    \t\tLong retval = pinger.ping(address, timeout, retries);\n    \t\tif (retval != null) {\n    \t\t\treturn true;\n    \t\t}\n    \t} catch (IOException e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n    \t}\n    \t\n    \treturn false;\n    }","id":84525,"modified_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map qualifiers) {\n    \tPinger pinger;\n    \tint retries;\n    \tlong timeout;\n\n    \ttry {\n    \t\tpinger = new Pinger();\n    \t\tif (qualifiers != null) {\n    \t\t\tretries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", Pinger.DEFAULT_RETRIES);\n    \t\t\ttimeout = ParameterMap.getKeyedLong(qualifiers, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n    \t\t} else {\n    \t\t\tretries = Pinger.DEFAULT_RETRIES;\n    \t\t\ttimeout = Pinger.DEFAULT_TIMEOUT;\n    \t\t}\n    \t\tLong retval = pinger.ping(address, timeout, retries);\n    \t\tif (retval != null) {\n    \t\t\treturn true;\n    \t\t}\n    \t} catch (Exception e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n        }\n    \t\n    \treturn false;\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * \n     * @param address\n     *            The address to check for support.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address) {\n    \tPinger pinger;\n\t\ttry {\n\t\t\tpinger = new Pinger();\n\t    \tLong retval = pinger.ping(address);\n\t    \tif (retval != null) {\n\t    \t\treturn true;\n\t    \t}\n\t\t} catch (IOException e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n\t\t}\n\t\treturn false;\n    }","id":84526,"modified_method":"/**\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * \n     * @param address\n     *            The address to check for support.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address) {\n    \tPinger pinger;\n\t\ttry {\n\t\t\tpinger = new Pinger();\n\t    \tLong retval = pinger.ping(address);\n\t    \tif (retval != null) {\n\t    \t\treturn true;\n\t    \t}\n\t\t} catch (Exception e) {\n\t        Category log = ThreadCategory.getInstance(this.getClass());\n\t\t\tlog.warn(\"Pinger failed to ping \" + address, e);\n\t\t}\n\t\treturn false;\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/receive) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\tMap<String, Number> rtt = null;\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tpinger.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", pinger.getRetries()));\n\t\t\tpinger.setTimeout(ParameterMap.getKeyedLong(parameters, \"timeout\", pinger.getTimeout()));\n\t\t\tint count = ParameterMap.getKeyedInteger(parameters, \"pings\", DEFAULT_MULTI_PING_COUNT);\n\t\t\t\n\t\t\trtt = pinger.parallelPing(host, count);\n\t\t} catch (IOException e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        if (rtt != null) {\n        \tserviceStatus = PollStatus.available();\n        \tserviceStatus.setProperties(rtt);\n        }\n        \n        return serviceStatus;\n    }","id":84527,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/receive) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n\t\tInetAddress host = (InetAddress) iface.getAddress();\n\t\tList<Number> responseTimes = null;\n\t\t\n\t\ttry {\n\t\t\tPinger pinger = new Pinger();\n\t\t\t\n\t\t\t// get parameters\n\t\t\t//\n\t\t\tlong timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n\t\t\tint count = ParameterMap.getKeyedInteger(parameters, \"pings\", DEFAULT_MULTI_PING_COUNT);\n\t\t\tlong pingInterval = ParameterMap.getKeyedLong(parameters, \"interval\", DEFAULT_PING_INTERVAL);\n\t\t\t\n\t\t\tresponseTimes = new ArrayList<Number>(pinger.parallelPing(host, count, timeout, pingInterval));\n\n\t\t\tserviceStatus = PollStatus.available();\n\t\t\tCollections.sort(responseTimes, new Comparator<Number>() {\n\n                public int compare(Number arg0, Number arg1) {\n                    if (arg0 == null) {\n                        return -1;\n                    } else if (arg1 == null) {\n                        return 1;\n                    } else if (arg0.doubleValue() == arg1.doubleValue()) {\n                        return 0;\n                    } else {\n                        return arg1.doubleValue() > arg0.doubleValue()? 1 : -1;\n                    }\n                }\n\t\t\t    \n\t\t\t});\n\t\t\t\n\t\t\tMap<String, Number> returnval = new LinkedHashMap<String,Number>();\n\t\t\tfor (int i = 0; i < responseTimes.size(); i++) {\n\t\t\t    returnval.put(\"ping\" + (i+1), responseTimes.get(i));\n\t\t\t}\n\t\t\treturnval.put(\"loss\", CollectionMath.countNull(responseTimes));\n\t\t\treturnval.put(\"median\", CollectionMath.median(responseTimes));\n\t\t\treturnval.put(\"response-time\", CollectionMath.average(responseTimes));\n\t\t\t\n\t\t\tserviceStatus.setProperties(returnval);\n\t\t} catch (Exception e) {\n\t\t\tlog.debug(\"failed to ping \" + host, e);\n\t\t}\n        \n        return serviceStatus;\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPing() throws Exception {\n        Map<String,Number> ret = m_pinger.parallelPing(m_goodHost, 10);\n        ArrayList<Number> items = new ArrayList<Number>();\n        for (String key : ret.keySet()) {\n            items.add(ret.get(key));\n            System.out.println(key + \": \" + ret.get(key));\n        }\n        ret.remove(\"loss\");\n        ret.remove(\"median\");\n        ret.remove(\"response-time\");\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","id":84528,"modified_method":"public void testParallelPing() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPingFailure() throws Exception {\n        Map<String,Number> ret = m_pinger.parallelPing(m_badHost, 10);\n        ret.remove(\"loss\");\n        ret.remove(\"median\");\n        ret.remove(\"response-time\");\n        ArrayList<Number>items = new ArrayList<Number>();\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","id":84529,"modified_method":"public void testParallelPingFailure() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, Number> parallelPing(InetAddress host, int count) throws IOException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        LinkedHashMap<String, Number> returnval = new LinkedHashMap<String, Number>();\n        \n        Long tidKey = getTidKey();\n        ArrayList<PingRequest> requests = new ArrayList<PingRequest>();\n        parallelWaiting.put(tidKey, requests);\n        for (int i = 0; i < count; i++) {\n        \tshort sid = sequenceId++;\n        \tPingRequest reply = new PingRequest(host, sid);\n        \t// log.debug(\"sending packet with ID '\" + tidKey + \"' and sequence '\" + reply.getSequenceId());\n        \trequests.add(reply);\n        \tDatagramPacket pkt = getDatagram(host, tidKey, reply.getSequenceId());\n        \tsynchronized(reply) {\n        \t\tsendPacket(pkt);\n        \t}\n       \t\ttry {\n       \t\t\tThread.sleep(50);\n       \t\t} catch (InterruptedException ex) {\n                Thread.currentThread().interrupt();\n       \t\t}\n        }\n        \n        try {\n            synchronized(requests) {\n            \tThread.sleep(timeout);\n            \trequests.wait(1);\n            \t/* requests.wait(timeout); */\n            }\n        } catch (InterruptedException ex) {\n            // interrupted so return, reset interrupt.\n            Thread.currentThread().interrupt();\n        }\n\n        parallelWaiting.remove(tidKey);\n\n        Collections.sort(requests, new Comparator<PingRequest>() {\n\t\t\tpublic int compare(PingRequest arg0, PingRequest arg1) {\n\t\t\t\tif (!arg0.isSignaled()) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (!arg1.isSignaled()) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn (int)(arg0.getPacket().getPingRTT() - arg1.getPacket().getPingRTT());\n\t\t\t}\n        });\n        for (int i = 0; i < requests.size(); i++) {\n        \tPingRequest reply = requests.get(i);\n        \tif (reply.isSignaled()) {\n        \t\tLong rtt = getRTT(reply);\n        \t\tif (rtt <= (timeout * 1000)) {\n        \t\t\treturnval.put(\"ping\" + (i+1), rtt);\n        \t\t} else {\n        \t\t\tlog.debug(\"a response came back, but it was too old: sid = \" + reply.getSequenceId() + \", rtt = \" + rtt);\n        \t\t\treturnval.put(\"ping\" + (i+1), null);\n        \t\t}\n    \t\t} else {\n    \t\t\tlog.debug(\"no response came back: sid = \" + reply.getSequenceId());\n    \t\t\treturnval.put(\"ping\" + (i+1), null);\n        \t}\n        }\n\n        ArrayList<Number> al = new ArrayList<Number>(returnval.values());\n        returnval.put(\"loss\", new Long(CollectionMath.countNull(al)));\n        returnval.put(\"median\", new Long(CollectionMath.median(al).longValue()));\n        returnval.put(\"response-time\", new Long(CollectionMath.average(al).longValue()));\n        \n        return returnval;\n\t}","id":84530,"modified_method":"public List<Number> parallelPing(InetAddress host, int count, long timeout, long pingInterval) throws IOException, InterruptedException {\n\t    ParallelPingResponseCallback cb = new ParallelPingResponseCallback(count);\n\t    \n\t    for (int i = 0; i < count; i++) {\n\t        PingRequest request = new PingRequest(host, DEFAULT_TIMEOUT, 0, (short) i, cb);\n\t        ping(request, cb);\n\t        Thread.sleep(pingInterval);\n\t    }\n\t    \n\t    cb.waitFor();\n\t    return cb.getResponseTimes();\n\t}","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException\n\t */\n\tpublic Long ping(InetAddress host) throws IOException {\n\t\treturn this.ping(host, timeout, retries);\n\t}","id":84531,"modified_method":"/**\n\t * Ping a remote host, using the default number of retries and timeouts.\n\t * @param host the host to ping\n\t * @return the round-trip time of the packet\n\t * @throws IOException\n\t * @throws InterruptedException \n\t */\n\tpublic Long ping(InetAddress host) throws IOException, InterruptedException {\n\t    return this.ping(host, DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to ping a remote host to test for ICMP support. If\n     * the remote host responds within the specified period, defined by retries\n     * and timeouts, then the response time is returned.\n     * \n     * @param host\n     *            The address to poll.\n     * @param timeout\n     *            The time to wait between each retry.\n     * @param retries\n     *            The number of times to retry\n     * \n     * @return The response time in microseconds if the host is reachable and has responded with an echo reply, otherwise a null value.\n     */\n    public Long ping(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        \n        Long tidKey = getTidKey();\n\n        short sid = sequenceId++;\n    \tDatagramPacket pkt = getDatagram(host, tidKey, sid);\n        PingRequest reply = new PingRequest(host, sid);\n        \n        waiting.put(tidKey, reply);\n        for (int attempts = 0; attempts <= retries && !reply.isSignaled(); ++attempts) {\n            synchronized (reply) {\n                sendPacket(pkt);\n                try {\n                    reply.wait(timeout);\n                } catch (InterruptedException ex) {\n                    // interrupted so return, reset interrupt.\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n        waiting.remove(tidKey);\n        \n        Long rtt = getRTT(reply);\n        if (rtt == null && log.isDebugEnabled()) {\n        \tlog.debug(\"no response time for \" + host + \"received\");\n        } else if (log.isDebugEnabled()){\n        \tlog.debug(\"Ping round trip time for \" + host + \": \" + rtt + \"us\");\n        }\n        return rtt;\n    }","id":84532,"modified_method":"/**\n     * This method is used to ping a remote host to test for ICMP support. If\n     * the remote host responds within the specified period, defined by retries\n     * and timeouts, then the response time is returned.\n     * \n     * @param host\n     *            The address to poll.\n     * @param timeout\n     *            The time to wait between each retry.\n     * @param retries\n     *            The number of times to retry\n     * \n     * @return The response time in microseconds if the host is reachable and has responded with an echo reply, otherwise a null value.\n     * @throws InterruptedException \n     */\n    public Long ping(InetAddress host, long timeout, int retries) throws InterruptedException {\n        SinglePingResponseCallback cb = new SinglePingResponseCallback();\n        ping(host, timeout, retries, (short) 1, cb);\n        cb.waitFor();\n        return cb.getResponseTime();\n    }","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initialize a Pinger object, using the default timeout and retries.\n     * @throws IOException\n     */\n    public Pinger() throws IOException {\n\t\tthis(DEFAULT_TIMEOUT, DEFAULT_RETRIES);\n\t}","id":84533,"modified_method":"/**\n     * Initialize a Pinger object, specifying the timeout and retries.\n     * @param defaultTimeout the timeout, in milliseconds, to wait for returned packets.\n     * @param defaultRetries the number of times to retry a given ping packet\n     * @throws IOException\n     */\n\tpublic Pinger() throws IOException {\n\t\tsynchronized (Pinger.class) {\n\t\t\tif (worker == null) {\n\t\t\t    final FifoQueueImpl<Reply> queue = new FifoQueueImpl<Reply>();\n\t\t\t\ticmpSocket = new IcmpSocket();\n                receiver = new ReplyReceiver(icmpSocket, queue, PingRequest.FILTER_ID);\n                receiver.start();\n\t\t\t\t\n                worker = new Thread(new Runnable() {\n                    public void run() {\n                        for (;;) {\n                        \tlong waitTime = minimumWaitTime();\n                        \tif (waitTime > 0) {\n                        \t    try {\n                                    Reply pong = queue.remove(waitTime);\n                                    processReply(pong);\n                        \t    } catch (InterruptedException ie) {\n                        \t        break;\n                        \t    } catch (FifoQueueException fqe) {\n                        \t        ThreadCategory.getInstance(this.getClass()).error(\"Error processing response queue\", fqe);\n                        \t    }\n                        \t} else {\n                        \t    processTimeouts();\n                        \t}\n                        }\n                    }\n                });\n                worker.setDaemon(true);\n                worker.start();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","commit_id":"0337d3699a42b5a6af99e1d23e29062b2d90f9bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BrainPryEffect() {\n        super(Outcome.Discard);\n        staticText = \"Name a nonland card. Target player reveals his or her hand. That player discards a card with that name. If he or she can't, you draw a card\";\n    }","id":84534,"modified_method":"public BrainPryEffect() {\n        super(Outcome.Discard);\n        staticText = \"Target player reveals his or her hand. That player discards a card with that name. If he or she can't, you draw a card\";\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"public BrainPry(UUID ownerId) {\n        super(ownerId, 39, \"Brain Pry\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{1}{B}\");\n        this.expansionSetCode = \"DIS\";\n\n        //Name a nonland card. Target player reveals his or her hand. That player discards a card with that name. If he or she can't, you draw a card.\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new BrainPryEffect());\n    }","id":84535,"modified_method":"public BrainPry(UUID ownerId) {\n        super(ownerId, 39, \"Brain Pry\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{1}{B}\");\n        this.expansionSetCode = \"DIS\";\n\n        //Name a nonland card. Target player reveals his or her hand. That player discards a card with that name. If he or she can't, you draw a card.\n        this.getSpellAbility().addEffect((new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME)));\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new BrainPryEffect());\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (targetPlayer != null && controller != null && sourceObject != null) {\n            Choice cardChoice = new ChoiceImpl(true);\n            cardChoice.setMessage(\"Name a nonland card.\");\n            cardChoice.setChoices(CardRepository.instance.getNonLandNames());\n            cardChoice.clearChoice();\n\n            while (!controller.choose(Outcome.Discard, cardChoice, game)) {\n                if (!controller.canRespond()) {\n                    return false;\n                }\n            }\n\n            String cardName = cardChoice.getChoice();\n            Boolean hasDiscarded = false;\n            game.informPlayers(sourceObject.getLogName() + \", named card: [\" + cardName + \"]\");\n            for (Card card : targetPlayer.getHand().getCards(game)) {\n                if (card.getName().equals(cardName)) {\n                    targetPlayer.discard(card, source, game);\n                    hasDiscarded = true;\n                    break;\n                }\n            }\n\n            if (!hasDiscarded) {\n                controller.drawCards(1, game);\n            }\n\n            controller.lookAtCards(sourceObject.getName() + \" Hand\", targetPlayer.getHand(), game);\n        }\n        return true;\n    }","id":84536,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);\n        if (targetPlayer != null && controller != null && sourceObject != null && cardName != null) {\n            Boolean hasDiscarded = false;\n            for (Card card : targetPlayer.getHand().getCards(game)) {\n                if (card.getName().equals(cardName)) {\n                    targetPlayer.discard(card, source, game);\n                    hasDiscarded = true;\n                    break;\n                }\n            }\n            if (!hasDiscarded) {\n                controller.drawCards(1, game);\n            }\n            controller.lookAtCards(sourceObject.getName() + \" Hand\", targetPlayer.getHand(), game);\n        }\n        return true;\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (targetPlayer != null && controller != null && sourceObject != null) {\n            Choice cardChoice = new ChoiceImpl(true);\n            cardChoice.setMessage(\"Name a nonland card.\");\n            cardChoice.setChoices(CardRepository.instance.getNonLandNames());\n            cardChoice.clearChoice();\n\n            while (!controller.choose(Outcome.Discard, cardChoice, game)) {\n                if (!controller.canRespond()) {\n                    return false;\n                }\n            }\n\n            String cardName = cardChoice.getChoice();\n            game.informPlayers(sourceObject.getLogName() + \", named card: [\" + cardName + \"]\");\n            for (Card card : targetPlayer.getHand().getCards(game)) {\n                if (card.getName().equals(cardName)) {\n                    targetPlayer.discard(card, source, game);\n                }\n            }\n\n            controller.lookAtCards(sourceObject.getName() + \" Hand\", targetPlayer.getHand(), game);\n        }\n        return true;\n    }","id":84537,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (targetPlayer != null && controller != null && sourceObject != null) {\n            String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);\n            for (Card card : targetPlayer.getHand().getCards(game)) {\n                if (card.getName().equals(cardName)) {\n                    targetPlayer.discard(card, source, game);\n                }\n            }\n            controller.lookAtCards(sourceObject.getName() + \" Hand\", targetPlayer.getHand(), game);\n        }\n        return true;\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"public CabalTherapy(UUID ownerId) {\n        super(ownerId, 62, \"Cabal Therapy\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{B}\");\n        this.expansionSetCode = \"JUD\";\n\n        // Name a nonland card. Target player reveals his or her hand and discards all cards with that name.\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new CabalTherapyEffect());\n        \n        // Flashback-Sacrifice a creature.\n        this.addAbility(new FlashbackAbility(\n                new SacrificeTargetCost(new TargetControlledCreaturePermanent(1,1,new FilterControlledCreaturePermanent(\"a creature\"), true)), \n                TimingRule.SORCERY));\n    }","id":84538,"modified_method":"public CabalTherapy(UUID ownerId) {\n        super(ownerId, 62, \"Cabal Therapy\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{B}\");\n        this.expansionSetCode = \"JUD\";\n\n        // Name a nonland card. Target player reveals his or her hand and discards all cards with that name.\n        this.getSpellAbility().addEffect((new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME)));\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new CabalTherapyEffect());\n\n        // Flashback-Sacrifice a creature.\n        this.addAbility(new FlashbackAbility(\n                new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent(\"a creature\"), true)),\n                TimingRule.SORCERY));\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"public Memoricide(UUID ownerId) {\n        super(ownerId, 69, \"Memoricide\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{3}{B}\");\n        this.expansionSetCode = \"SOM\";\n\n        // Name a nonland card. Search target player's graveyard, hand, and library for any number of cards with\n        // that name and exile them. Then that player shuffles his or her library\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new MemoricideEffect());\n    }","id":84539,"modified_method":"public Memoricide(UUID ownerId) {\n        super(ownerId, 69, \"Memoricide\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{3}{B}\");\n        this.expansionSetCode = \"SOM\";\n\n        // Name a nonland card. Search target player's graveyard, hand, and library for any number of cards with\n        // that name and exile them. Then that player shuffles his or her library\n        this.getSpellAbility().addEffect((new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME)));\n        this.getSpellAbility().addTarget(new TargetPlayer());\n        this.getSpellAbility().addEffect(new MemoricideEffect());\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (player != null && controller != null) {\n            Choice cardChoice = new ChoiceImpl();\n            cardChoice.setChoices(CardRepository.instance.getNonLandNames());\n            cardChoice.clearChoice();\n            cardChoice.setMessage(\"Name a nonland card\");\n\n            while (!controller.choose(Outcome.Exile, cardChoice, game)) {\n                if (!controller.canRespond()) {\n                    return false;\n                }\n            }\n            String cardName = cardChoice.getChoice();\n            MageObject sourceObject = game.getObject(source.getSourceId());\n            if (sourceObject != null) {\n                game.informPlayers(sourceObject.getName() + \" named card: [\" + cardName + \"]\");\n            }\n            super.applySearchAndExile(game, source, cardName, player.getId());\n        }\n        return true;\n    }","id":84540,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);\n        return super.applySearchAndExile(game, source, cardName, targetPointer.getFirst(game, source));\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (player != null && controller != null) {\n            Choice cardChoice = new ChoiceImpl();\n            cardChoice.setChoices(CardRepository.instance.getNonLandNames());\n            cardChoice.clearChoice();\n            cardChoice.setMessage(\"Name a nonland card\");\n\n            while (!controller.choose(Outcome.Exile, cardChoice, game)) {\n                if (!controller.canRespond()) {\n                    return false;\n                }\n            }\n            String cardName;\n            cardName = cardChoice.getChoice();\n            MageObject sourceObject = game.getObject(source.getSourceId());\n            if (sourceObject != null) {\n                game.informPlayers(sourceObject.getName() + \" named card: [\" + cardName + \"]\");\n            }\n\n            super.applySearchAndExile(game, source, cardName, player.getId());\n        }\n        return true;\n    }","id":84541,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);\n        return super.applySearchAndExile(game, source, cardName, targetPointer.getFirst(game, source));\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"public SlaughterGames(UUID ownerId) {\n        super(ownerId, 197, \"Slaughter Games\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{B}{R}\");\n        this.expansionSetCode = \"RTR\";\n\n        // Slaughter Games can't be countered by spells or abilities.\n        Effect effect = new CantBeCounteredSourceEffect();\n        effect.setText(\"{this} can't be countered by spells or abilities\");\n        Ability ability = new SimpleStaticAbility(Zone.STACK, effect);\n        ability.setRuleAtTheTop(true);\n        this.addAbility(ability);\n\n        // Name a nonland card. Search target opponent's graveyard, hand, and library for any number of cards with that name and exile them. Then that player shuffles his or her library.\n        this.getSpellAbility().addEffect(new SlaughterGamesEffect());\n        this.getSpellAbility().addTarget(new TargetOpponent());\n\n    }","id":84542,"modified_method":"public SlaughterGames(UUID ownerId) {\n        super(ownerId, 197, \"Slaughter Games\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{B}{R}\");\n        this.expansionSetCode = \"RTR\";\n\n        // Slaughter Games can't be countered by spells or abilities.\n        Effect effect = new CantBeCounteredSourceEffect();\n        effect.setText(\"{this} can't be countered by spells or abilities\");\n        Ability ability = new SimpleStaticAbility(Zone.STACK, effect);\n        ability.setRuleAtTheTop(true);\n        this.addAbility(ability);\n\n        // Name a nonland card. Search target opponent's graveyard, hand, and library for any number of cards with that name and exile them. Then that player shuffles his or her library.\n        this.getSpellAbility().addEffect(new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME));\n        this.getSpellAbility().addEffect(new SlaughterGamesEffect());\n        this.getSpellAbility().addTarget(new TargetOpponent());\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (player != null && controller != null) {\n            Choice cardChoice = new ChoiceImpl();\n            cardChoice.setChoices(CardRepository.instance.getNonLandNames());\n            cardChoice.clearChoice();\n            cardChoice.setMessage(\"Name a nonland card\");\n\n            while (!controller.choose(Outcome.Exile, cardChoice, game)) {\n                if (!controller.canRespond()) {\n                    return false;\n                }\n            }\n            String cardName;\n            cardName = cardChoice.getChoice();\n            MageObject sourceObject = game.getObject(source.getSourceId());\n            if (sourceObject != null) {\n                game.informPlayers(sourceObject.getName() + \" named card: [\" + cardName + \"]\");\n            }\n\n            super.applySearchAndExile(game, source, cardName, player.getId());\n        }\n        return true;\n    }","id":84543,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);\n        return super.applySearchAndExile(game, source, cardName, targetPointer.getFirst(game, source));\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"public StainTheMind(UUID ownerId) {\n        super(ownerId, 117, \"Stain the Mind\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{4}{B}\");\n        this.expansionSetCode = \"M15\";\n\n        // Convoke\n        this.addAbility(new ConvokeAbility());\n        // Name a nonland card. Search target player's graveyard, hand, and library for any number of card's with that name and exile them. Then that player shuffles his or her library.\n        this.getSpellAbility().addEffect(new StainTheMindEffect());\n        this.getSpellAbility().addTarget(new TargetPlayer());\n    }","id":84544,"modified_method":"public StainTheMind(UUID ownerId) {\n        super(ownerId, 117, \"Stain the Mind\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{4}{B}\");\n        this.expansionSetCode = \"M15\";\n\n        // Convoke\n        this.addAbility(new ConvokeAbility());\n        // Name a nonland card. Search target player's graveyard, hand, and library for any number of card's with that name and exile them. Then that player shuffles his or her library.\n        this.getSpellAbility().addEffect((new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME)));\n        this.getSpellAbility().addEffect(new StainTheMindEffect());\n        this.getSpellAbility().addTarget(new TargetPlayer());\n    }","commit_id":"7563b0c30f23d36bc1007b14b6e0622106f8c161","url":"https://github.com/magefree/mage"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit\");\n        \n        AdminRancidCloginCommClass bean = (AdminRancidCloginCommClass) command;\n        \n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit following changes\"+\n                    \"userID [\"+ bean.getUserID() +\"] \"+\n                    \"pass [\" + bean.getPass() +\"] \"+\n                    \"enpass [\" + bean.getEnpass()+\"] \"+\n                    \"loginM [\" + bean.getLoginM()+\"] \"+\n                    \"autoE [\" + bean.getAutoE()+\"] \"+\n                    \"groupName [\" + bean.getGroupName()+\"] \"+\n                    \"deviceName [\" + bean.getDeviceName() + \"] \"); \n\n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n\n        RancidNodeAuthentication rna = RWSClientApi.getRWSAuthNode(cp, bean.getDeviceName());\n        rna.setUser(bean.getUserID());\n        rna.setPassword(bean.getPass());\n        rna.setConnectionMethod(bean.getLoginM());\n        rna.setEnablePass(bean.getAutoE());\n        boolean autoe = false;\n        if (bean.getAutoE().compareTo(\"1\")==0) {\n            autoe = true;\n        }\n        rna.setAutoEnable(autoe);\n        RWSClientApi.createOrUpdateRWSAuthNode(cp,rna);\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit changes submitted\");\n\n\n        \n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","id":84545,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit\");\n        \n        AdminRancidCloginCommClass bean = (AdminRancidCloginCommClass) command;\n        \n        boolean done = m_inventoryService.updateClogin(bean.getDeviceName(), bean.getGroupName(), bean.getUserID(), bean.getPass(),\n                                        bean.getEnpass(), bean.getLoginM(), bean.getAutoE());\n        if (!done){\n            log().debug(\"AdminRancidCloginController error on submitting cLogin changes\");\n        }\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"admin/rancid/rancidAdmin\",\"model\",model);\n        return modelAndView;\n    }","id":84546,"modified_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map<String, Object> model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"admin/rancid/rancidAdmin\",\"model\",model);\n        return modelAndView;\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit\");\n\n        AdminRancidStatusCommClass bean = (AdminRancidStatusCommClass) command;\n        \n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n                \n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit setting state to device[\"+ bean.getDeviceName() + \"] group[\" + bean.getGroupName() + \"] status[\" + bean.getStatusName()+\"]\");\n\n        RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, bean.getGroupName(), bean.getDeviceName());\n        if (rn.isStateUp()){\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit :down\");\n            rn.setStateUp(false);\n        }else {\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit :up\");\n            rn.setStateUp(true);\n        }\n        RWSClientApi.updateRWSRancidNode(cp, rn);\n\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","id":84547,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit\");\n\n        AdminRancidStatusCommClass bean = (AdminRancidStatusCommClass) command;\n                       \n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit setting state to device[\"+ bean.getDeviceName() + \"] group[\" + bean.getGroupName() + \"] status[\" + bean.getStatusName()+\"]\");\n\n        boolean done = m_inventoryService.updateStatus(bean.getGroupName(), bean.getDeviceName());\n        if (!done){\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit error while updating status for\"+ bean.getGroupName() + \"/\" + bean.getDeviceName());\n        }\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeAdmin(String rancidName, HttpServletRequest request) throws RancidApiException{\n      \n       \n       log().debug(\"getRancidNodeAdmin start\");\n\n       log().debug(\"getRancidNode: \" + rancidName);\n\n       //OnmsNode node = m_nodeDao.get(nodeid);\n\n       Map<String, Object> nodeModel = new TreeMap<String, Object>();\n       nodeModel.put(\"id\", rancidName);\n       //nodeModel.put(\"status_general\", node.getType());\n       \n       List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n       \n       // Group list \n       ConnectionProperties cp = new ConnectionProperties(_URL,\"/rws\",60);\n       RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(cp);\n       \n       List<String> grouplist = groups.getResource();\n       Iterator<String> iter1 = grouplist.iterator();\n       \n     \n       String groupname;\n       boolean first = true;\n       while (iter1.hasNext()){\n           groupname = iter1.next();\n           log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n           \n           try {\n               if (first){\n                   RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, groupname, rancidName);\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   nodeModel.put(\"status\", rn.getState());\n                   nodeModel.put(\"devicetype\", rn.getDeviceType());\n                   nodeModel.put(\"comment\", rn.getComment());\n                   nodeModel.put(\"group\", groupname);\n\n                   first = false;\n               } \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(cp ,groupname, rancidName);\n               String vs = rn.getHeadRevision();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n               RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                 rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n               ranlist.add(rnw); \n               \n           }\n           catch (RancidApiException e){\n               log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n           }\n       }\n       \n       //Groups invariant            \n       nodeModel.put(\"grouptable\", ranlist);\n       nodeModel.put(\"url\", cp.getUrl());\n       \n       //CLOGIN\n       if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n           RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(cp,rancidName);\n           nodeModel.put(\"isadmin\", \"true\");\n           nodeModel.put(\"cloginuser\", rn5.getUser());\n           nodeModel.put(\"cloginpassword\", rn5.getPassword());\n           nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n           nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n           String autoen = \"0\";\n           if (rn5.isAutoEnable()){\n               autoen = \"1\";\n           }\n           nodeModel.put(\"cloginautoenable\", autoen);\n       }\n       \n       return nodeModel;\n}","id":84548,"modified_method":"static public Map<String, Object> getRancidNodeAdmin(String rancidName, HttpServletRequest request) throws RancidApiException{\n      \n       \n       log().debug(\"getRancidNodeAdmin start\");\n\n       log().debug(\"getRancidNode: \" + rancidName);\n\n       //OnmsNode node = m_nodeDao.get(nodeid);\n\n       Map<String, Object> nodeModel = new TreeMap<String, Object>();\n       nodeModel.put(\"id\", rancidName);\n       //nodeModel.put(\"status_general\", node.getType());\n       \n       List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n       \n       // Group list \n       RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n       \n       List<String> grouplist = groups.getResource();\n       Iterator<String> iter1 = grouplist.iterator();\n       \n     \n       String groupname;\n       boolean first = true;\n       while (iter1.hasNext()){\n           groupname = iter1.next();\n           log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n           \n           try {\n               if (first){\n                   RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(m_cp, groupname, rancidName);\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   nodeModel.put(\"status\", rn.getState());\n                   nodeModel.put(\"devicetype\", rn.getDeviceType());\n                   nodeModel.put(\"comment\", rn.getComment());\n                   nodeModel.put(\"group\", groupname);\n\n                   first = false;\n               } \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n               String vs = rn.getHeadRevision();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n               RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                 rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n               ranlist.add(rnw); \n               \n           }\n           catch (RancidApiException e){\n               log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n           }\n       }\n       \n       //Groups invariant            \n       nodeModel.put(\"grouptable\", ranlist);\n       nodeModel.put(\"url\", m_cp.getUrl());\n       \n       //CLOGIN\n       if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n           RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n           nodeModel.put(\"isadmin\", \"true\");\n           nodeModel.put(\"cloginuser\", rn5.getUser());\n           nodeModel.put(\"cloginpassword\", rn5.getPassword());\n           nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n           nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n           String autoen = \"0\";\n           if (rn5.isAutoEnable()){\n               autoen = \"1\";\n           }\n           nodeModel.put(\"cloginautoenable\", autoen);\n       }\n       \n       return nodeModel;\n}","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getInventoryNode(String rancidName, String group, String version) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getInventoryNode \" + rancidName);\n\n    \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, group, rancidName);\n       \n           InventoryNode in = (InventoryNode)rn.getNodeVersions().get(version);\n           \n           //InventoryWrapper tmpw = new InventoryWrapper(version, in.getExpirationDate(), group, in.getConfigurationUrl());\n                       \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n   \n           nodeModel.put(\"devicename\", rancidName);\n           nodeModel.put(\"groupname\", group);\n           nodeModel.put(\"version\", version);\n           nodeModel.put(\"status\", in.getParent().getState());\n           nodeModel.put(\"creationdate\", in.getCreationDate());\n           log().debug(\"getInventoryNode date\" + in.getCreationDate());\n           nodeModel.put(\"configurationurl\", in.getConfigurationUrl());\n           nodeModel.put(\"url\", _URL);\n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84549,"modified_method":"static public Map<String, Object> getInventoryNode(String rancidName, String group, String version) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getInventoryNode \" + rancidName);\n\n    \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, group, rancidName);\n       \n           InventoryNode in = (InventoryNode)rn.getNodeVersions().get(version);\n           \n           //InventoryWrapper tmpw = new InventoryWrapper(version, in.getExpirationDate(), group, in.getConfigurationUrl());\n                       \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n   \n           nodeModel.put(\"devicename\", rancidName);\n           nodeModel.put(\"groupname\", group);\n           nodeModel.put(\"version\", version);\n           nodeModel.put(\"status\", in.getParent().getState());\n           nodeModel.put(\"creationdate\", in.getCreationDate());\n           nodeModel.put(\"swconfigurationurl\", in.getSoftwareImageUrl());\n           log().debug(\"getInventoryNode date\" + in.getCreationDate());\n           nodeModel.put(\"configurationurl\", in.getConfigurationUrl());\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getInventoryElement(String rancidName) throws RancidApiException{\n        \n        try {\n        \n            String group = \"laboratorio\";\n            \n            \n            RancidNode rn = RWSClientApi.getRWSRancidNode(_URL, group, rancidName);\n    \n            \n    \n            InventoryNode in = new InventoryNode(rn);\n            InventoryElement ie = new InventoryElement(in);\n            \n            ie.setElementName(\"Router1\");\n            ie.setVendor(\"Cisco\");\n            ie.setSysOid(\"1.1.1.1.1.1.1\");\n            ie.setModelType(\"x123\");\n            ie.setSerialNumber(\"17266577871\");\n            ie.setProductPartNumber(\"21211212\");\n            ie.setHardwareVersion(\"1.1\");\n            ie.setRamSize(8);\n            ie.setNwRamSize(4);\n            ie.setElementId(4);\n            \n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n    //      Integer ii = Integer(ie.getElementId(4));\n    //      nodeModel.put(\"id\", ii.toString());\n    \n            nodeModel.put(\"status\", ie.getParent().getParent().getState());\n            nodeModel.put(\"name\", ie.getElementName());\n            nodeModel.put(\"elementid\", ie.getElementId());\n            nodeModel.put(\"vendor\", ie.getVendor());\n            nodeModel.put(\"sysoid\", ie.getSysOid());\n            nodeModel.put(\"modeltype\", ie.getModelType());\n            nodeModel.put(\"serialnumber\", ie.getSerialNumber());\n            nodeModel.put(\"productpartnumber\", ie.getProductPartNumber());\n            nodeModel.put(\"hardwareversion\", ie.getHardwareVersion());\n            nodeModel.put(\"ramsize\", ie.getRamSize());        \n            nodeModel.put(\"nwramsize\", ie.getNwRamSize());\n            nodeModel.put(\"group\", group);;\n            nodeModel.put(\"url\", _URL);\n\n    \n            \n            return nodeModel;\n        }\n        catch (RancidApiException e) {\n            throw e;\n        }\n    }","id":84550,"modified_method":"static public Map<String, Object> getInventoryElement(String rancidName) throws RancidApiException{\n        \n        try {\n        \n            String group = \"laboratorio\";\n            \n            \n            RancidNode rn = RWSClientApi.getRWSRancidNode(m_cp, group, rancidName);\n    \n            \n    \n            InventoryNode in = new InventoryNode(rn);\n            InventoryElement ie = new InventoryElement(in);\n            \n            ie.setElementName(\"Router1\");\n            ie.setVendor(\"Cisco\");\n            ie.setSysOid(\"1.1.1.1.1.1.1\");\n            ie.setModelType(\"x123\");\n            ie.setSerialNumber(\"17266577871\");\n            ie.setProductPartNumber(\"21211212\");\n            ie.setHardwareVersion(\"1.1\");\n            ie.setRamSize(8);\n            ie.setNwRamSize(4);\n            ie.setElementId(4);\n            \n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n    //      Integer ii = Integer(ie.getElementId(4));\n    //      nodeModel.put(\"id\", ii.toString());\n    \n            nodeModel.put(\"status\", ie.getParent().getParent().getState());\n            nodeModel.put(\"name\", ie.getElementName());\n            nodeModel.put(\"elementid\", ie.getElementId());\n            nodeModel.put(\"vendor\", ie.getVendor());\n            nodeModel.put(\"sysoid\", ie.getSysOid());\n            nodeModel.put(\"modeltype\", ie.getModelType());\n            nodeModel.put(\"serialnumber\", ie.getSerialNumber());\n            nodeModel.put(\"productpartnumber\", ie.getProductPartNumber());\n            nodeModel.put(\"hardwareversion\", ie.getHardwareVersion());\n            nodeModel.put(\"ramsize\", ie.getRamSize());        \n            nodeModel.put(\"nwramsize\", ie.getNwRamSize());\n            nodeModel.put(\"group\", group);;\n            nodeModel.put(\"url\", m_cp.getUrl());\n\n    \n            \n            return nodeModel;\n        }\n        catch (RancidApiException e) {\n            throw e;\n        }\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeList(String rancidName, String groupname) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName + \" \" + groupname);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, groupname, rancidName);\n\n           nodeModel.put(\"devicename\", rn.getDeviceName());\n           \n           //*********\n           // version\n         \n           RWSResourceList versionList;\n           \n           versionList = RWSClientApi.getRWSResourceConfigList(_URL, groupname, rancidName);\n           \n           List<String> versionListStr= versionList.getResource();\n           \n           Iterator<String> iter1 = versionListStr.iterator();\n           \n           String vs;\n           \n           while (iter1.hasNext()) {\n               vs = iter1.next();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n               InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n               ranlist.add(inwr);\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", _URL);\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84551,"modified_method":"static public Map<String, Object> getRancidNodeList(String rancidName, String groupname) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName + \" \" + groupname);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, groupname, rancidName);\n\n           nodeModel.put(\"devicename\", rn.getDeviceName());\n           \n           //*********\n           // version\n         \n           RWSResourceList versionList;\n           \n           versionList = RWSClientApi.getRWSResourceConfigList(m_cp, groupname, rancidName);\n           \n           List<String> versionListStr= versionList.getResource();\n           \n           Iterator<String> iter1 = versionListStr.iterator();\n           \n           String vs;\n           \n           while (iter1.hasNext()) {\n               vs = iter1.next();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n               InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n               ranlist.add(inwr);\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNode(String rancidName, HttpServletRequest request) throws RancidApiException{\n        \n            \n            log().debug(\"getRancidNode \" + rancidName);\n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list            \n            RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(_URL);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);\n\n                try {\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n                    if (first) {\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        first = false;\n                    }\n                    ranlist.add(rnw); \n\n                }\n                catch (RancidApiException e){\n                    log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", _URL);\n            \n            //CLOGIN\n            if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(_URL,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n            \n            return nodeModel;\n        \n\n    }","id":84552,"modified_method":"static public Map<String, Object> getRancidNode(String rancidName, HttpServletRequest request) throws RancidApiException{\n        \n            \n            log().debug(\"getRancidNode \" + rancidName);\n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list            \n            RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);\n\n                try {\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n                    if (first) {\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        first = false;\n                    }\n                    ranlist.add(rnw); \n\n                }\n                catch (RancidApiException e){\n                    log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", m_cp.getUrl());\n            \n            //CLOGIN\n            if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n            \n            return nodeModel;\n        \n\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public void init(){\n        \n        try {\n            log().debug(\"Setting Up RWS client\");\n            RWSClientApi.init();\n\n            //nel config\n            RWSConfigFactory.init();\n            rwsCfgFactory = RWSConfigFactory.getInstance();\n            \n            \n            burl = rwsCfgFactory.getBaseUrl();\n            _URL = burl.getServer_url();\n            log().debug(\"RWS Url \" + _URL);            \n        }\n        catch (Exception e) {\n            \n        }\n    }","id":84553,"modified_method":"static public void init(){\n        \n        try {\n            log().debug(\"Setting Up RWS client\");\n            RWSClientApi.init();\n\n            //nel config\n            RWSConfigFactory.init();\n            rwsCfgFactory = RWSConfigFactory.getInstance();\n            \n           \n            m_cp = rwsCfgFactory.getBase();\n            \n            log().debug(\"RWS Url \" + m_cp.getUrl());            \n        }\n        catch (Exception e) {\n            \n        }\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeList(String rancidName) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(_URL);\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           List<String> grouplist = groups.getResource();\n           Iterator<String> iter2 = grouplist.iterator();\n           \n           boolean first = true;\n           String groupname;\n           while (iter2.hasNext()) {\n               groupname = iter2.next();\n           \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, groupname, rancidName);\n    \n               if (first){\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   first = false;\n               }\n               \n               //*********\n               // version\n             \n               RWSResourceList versionList;\n               \n               versionList = RWSClientApi.getRWSResourceConfigList(_URL, groupname, rancidName);\n               \n               List<String> versionListStr= versionList.getResource();\n               \n               Iterator<String> iter1 = versionListStr.iterator();\n               \n               String vs;\n               \n               while (iter1.hasNext()) {\n                   vs = iter1.next();\n                   InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n                   InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n                   ranlist.add(inwr);\n               }\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", _URL);\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84554,"modified_method":"static public Map<String, Object> getRancidNodeList(String rancidName) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           List<String> grouplist = groups.getResource();\n           Iterator<String> iter2 = grouplist.iterator();\n           \n           boolean first = true;\n           String groupname;\n           while (iter2.hasNext()) {\n               groupname = iter2.next();\n           \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, groupname, rancidName);\n    \n               if (first){\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   first = false;\n               }\n               \n               //*********\n               // version\n             \n               RWSResourceList versionList;\n               \n               versionList = RWSClientApi.getRWSResourceConfigList(m_cp, groupname, rancidName);\n               \n               List<String> versionListStr= versionList.getResource();\n               \n               Iterator<String> iter1 = versionListStr.iterator();\n               \n               String vs;\n               \n               while (iter1.hasNext()) {\n                   vs = iter1.next();\n                   InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n                   InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n                   ranlist.add(inwr);\n               }\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, Object> getRancidNode(int nodeid, boolean adminRole) throws RancidApiException{\n        \n        log().debug(\"getRancidNode start\");\n        \n        OnmsNode node = m_nodeDao.get(nodeid);\n        String rancidName = node.getLabel();\n\n        log().debug(\"getRancidNode: \" + rancidName);\n\n\n        Map<String, Object> nodeModel = new TreeMap<String, Object>();\n        nodeModel.put(\"id\", rancidName);\n        nodeModel.put(\"db_id\", nodeid);\n        nodeModel.put(\"status_general\", node.getType());\n        \n        List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n        \n        // Group list \n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n        RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(cp);\n        \n        List<String> grouplist = groups.getResource();\n        Iterator<String> iter1 = grouplist.iterator();\n        \n      \n        String groupname;\n        boolean first = true;\n        while (iter1.hasNext()){\n            groupname = iter1.next();\n            log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n            \n            try {\n                if (first){\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, groupname, rancidName);\n                    nodeModel.put(\"devicename\", rn.getDeviceName());\n                    nodeModel.put(\"status\", rn.getState());\n                    nodeModel.put(\"devicetype\", rn.getDeviceType());\n                    nodeModel.put(\"comment\", rn.getComment());\n                    nodeModel.put(\"groupname\", groupname);\n                    first = false;\n                } \n                RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(cp ,groupname, rancidName);\n                String vs = rn.getHeadRevision();\n                InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                  rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n                ranlist.add(rnw); \n                \n            }\n            catch (RancidApiException e){\n                log().debug(\"No inventory information associated to \" + rancidName);\n            }\n        }\n        \n        //Groups invariant            \n        nodeModel.put(\"grouptable\", ranlist);\n        nodeModel.put(\"url\", cp.getUrl());\n        \n        //CLOGIN\n        if (adminRole) {\n\n            RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(cp,rancidName);\n            nodeModel.put(\"isadmin\", \"true\");\n            nodeModel.put(\"cloginuser\", rn5.getUser());\n            nodeModel.put(\"cloginpassword\", rn5.getPassword());\n            nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n            nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n            String autoen = \"0\";\n            if (rn5.isAutoEnable()){\n                autoen = \"1\";\n            }\n            nodeModel.put(\"cloginautoenable\", autoen);\n        }\n        \n        return nodeModel;\n    \n\n    }","id":84555,"modified_method":"public Map<String, Object> getRancidNode(int nodeid, boolean adminRole) {\n        \n        log().debug(\"getRancidNode start\");\n        Map<String, Object> nodeModel = new TreeMap<String, Object>();\n\n        try {\n        \n            OnmsNode node = m_nodeDao.get(nodeid);\n            String rancidName = node.getLabel();\n    \n            log().debug(\"getRancidNode: \" + rancidName);\n    \n    \n            nodeModel.put(\"id\", rancidName);\n            nodeModel.put(\"db_id\", nodeid);\n            nodeModel.put(\"status_general\", node.getType());\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n                \n                try {\n                    if (first){\n                        RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(m_cp, groupname, rancidName);\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        nodeModel.put(\"groupname\", groupname);\n                        first = false;\n                    } \n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n    \n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n    \n                    ranlist.add(rnw); \n                    \n                }\n                catch (RancidApiException e){\n                    log().debug(\"No inventory information associated to \" + rancidName);\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", m_cp.getUrl());\n            \n            //CLOGIN\n            if (adminRole) {\n    \n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n        }catch (Exception e){\n            log().debug(\"getRancidNode has given exception \" + e.getMessage());\n        }\n        return nodeModel;\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        //FIXME this should be done by spring\n            RWSClientApi.init();\n    }","id":84556,"modified_method":"public void afterPropertiesSet() throws Exception {\n        //FIXME this should be done by spring\n            RWSClientApi.init();\n            m_cp = m_rwsConfig.getBase();\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n       \n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"inventory/rancid\",\"model\",model);\n        return modelAndView;\n    }","id":84557,"modified_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n       \n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map<String, Object> model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"inventory/rancid\",\"model\",model);\n        return modelAndView;\n    }","commit_id":"69fd2a05c4752124bf460ac71a83178925ae1ef7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit\");\n        \n        AdminRancidCloginCommClass bean = (AdminRancidCloginCommClass) command;\n        \n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit following changes\"+\n                    \"userID [\"+ bean.getUserID() +\"] \"+\n                    \"pass [\" + bean.getPass() +\"] \"+\n                    \"enpass [\" + bean.getEnpass()+\"] \"+\n                    \"loginM [\" + bean.getLoginM()+\"] \"+\n                    \"autoE [\" + bean.getAutoE()+\"] \"+\n                    \"groupName [\" + bean.getGroupName()+\"] \"+\n                    \"deviceName [\" + bean.getDeviceName() + \"] \"); \n\n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n\n        RancidNodeAuthentication rna = RWSClientApi.getRWSAuthNode(cp, bean.getDeviceName());\n        rna.setUser(bean.getUserID());\n        rna.setPassword(bean.getPass());\n        rna.setConnectionMethod(bean.getLoginM());\n        rna.setEnablePass(bean.getAutoE());\n        boolean autoe = false;\n        if (bean.getAutoE().compareTo(\"1\")==0) {\n            autoe = true;\n        }\n        rna.setAutoEnable(autoe);\n        RWSClientApi.createOrUpdateRWSAuthNode(cp,rna);\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit changes submitted\");\n\n\n        \n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","id":84558,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit\");\n        \n        AdminRancidCloginCommClass bean = (AdminRancidCloginCommClass) command;\n        \n        boolean done = m_inventoryService.updateClogin(bean.getDeviceName(), bean.getGroupName(), bean.getUserID(), bean.getPass(),\n                                        bean.getEnpass(), bean.getLoginM(), bean.getAutoE());\n        if (!done){\n            log().debug(\"AdminRancidCloginController error on submitting cLogin changes\");\n        }\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"admin/rancid/rancidAdmin\",\"model\",model);\n        return modelAndView;\n    }","id":84559,"modified_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map<String, Object> model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"admin/rancid/rancidAdmin\",\"model\",model);\n        return modelAndView;\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit\");\n\n        AdminRancidStatusCommClass bean = (AdminRancidStatusCommClass) command;\n        \n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n                \n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit setting state to device[\"+ bean.getDeviceName() + \"] group[\" + bean.getGroupName() + \"] status[\" + bean.getStatusName()+\"]\");\n\n        RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, bean.getGroupName(), bean.getDeviceName());\n        if (rn.isStateUp()){\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit :down\");\n            rn.setStateUp(false);\n        }else {\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit :up\");\n            rn.setStateUp(true);\n        }\n        RWSClientApi.updateRWSRancidNode(cp, rn);\n\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","id":84560,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit\");\n\n        AdminRancidStatusCommClass bean = (AdminRancidStatusCommClass) command;\n                       \n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit setting state to device[\"+ bean.getDeviceName() + \"] group[\" + bean.getGroupName() + \"] status[\" + bean.getStatusName()+\"]\");\n\n        boolean done = m_inventoryService.updateStatus(bean.getGroupName(), bean.getDeviceName());\n        if (!done){\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit error while updating status for\"+ bean.getGroupName() + \"/\" + bean.getDeviceName());\n        }\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeList(String rancidName) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(_URL);\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           List<String> grouplist = groups.getResource();\n           Iterator<String> iter2 = grouplist.iterator();\n           \n           boolean first = true;\n           String groupname;\n           while (iter2.hasNext()) {\n               groupname = iter2.next();\n           \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, groupname, rancidName);\n    \n               if (first){\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   first = false;\n               }\n               \n               //*********\n               // version\n             \n               RWSResourceList versionList;\n               \n               versionList = RWSClientApi.getRWSResourceConfigList(_URL, groupname, rancidName);\n               \n               List<String> versionListStr= versionList.getResource();\n               \n               Iterator<String> iter1 = versionListStr.iterator();\n               \n               String vs;\n               \n               while (iter1.hasNext()) {\n                   vs = iter1.next();\n                   InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n                   InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n                   ranlist.add(inwr);\n               }\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", _URL);\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84561,"modified_method":"static public Map<String, Object> getRancidNodeList(String rancidName) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           List<String> grouplist = groups.getResource();\n           Iterator<String> iter2 = grouplist.iterator();\n           \n           boolean first = true;\n           String groupname;\n           while (iter2.hasNext()) {\n               groupname = iter2.next();\n           \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, groupname, rancidName);\n    \n               if (first){\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   first = false;\n               }\n               \n               //*********\n               // version\n             \n               RWSResourceList versionList;\n               \n               versionList = RWSClientApi.getRWSResourceConfigList(m_cp, groupname, rancidName);\n               \n               List<String> versionListStr= versionList.getResource();\n               \n               Iterator<String> iter1 = versionListStr.iterator();\n               \n               String vs;\n               \n               while (iter1.hasNext()) {\n                   vs = iter1.next();\n                   InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n                   InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n                   ranlist.add(inwr);\n               }\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getInventoryElement(String rancidName) throws RancidApiException{\n        \n        try {\n        \n            String group = \"laboratorio\";\n            \n            \n            RancidNode rn = RWSClientApi.getRWSRancidNode(_URL, group, rancidName);\n    \n            \n    \n            InventoryNode in = new InventoryNode(rn);\n            InventoryElement ie = new InventoryElement(in);\n            \n            ie.setElementName(\"Router1\");\n            ie.setVendor(\"Cisco\");\n            ie.setSysOid(\"1.1.1.1.1.1.1\");\n            ie.setModelType(\"x123\");\n            ie.setSerialNumber(\"17266577871\");\n            ie.setProductPartNumber(\"21211212\");\n            ie.setHardwareVersion(\"1.1\");\n            ie.setRamSize(8);\n            ie.setNwRamSize(4);\n            ie.setElementId(4);\n            \n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n    //      Integer ii = Integer(ie.getElementId(4));\n    //      nodeModel.put(\"id\", ii.toString());\n    \n            nodeModel.put(\"status\", ie.getParent().getParent().getState());\n            nodeModel.put(\"name\", ie.getElementName());\n            nodeModel.put(\"elementid\", ie.getElementId());\n            nodeModel.put(\"vendor\", ie.getVendor());\n            nodeModel.put(\"sysoid\", ie.getSysOid());\n            nodeModel.put(\"modeltype\", ie.getModelType());\n            nodeModel.put(\"serialnumber\", ie.getSerialNumber());\n            nodeModel.put(\"productpartnumber\", ie.getProductPartNumber());\n            nodeModel.put(\"hardwareversion\", ie.getHardwareVersion());\n            nodeModel.put(\"ramsize\", ie.getRamSize());        \n            nodeModel.put(\"nwramsize\", ie.getNwRamSize());\n            nodeModel.put(\"group\", group);;\n            nodeModel.put(\"url\", _URL);\n\n    \n            \n            return nodeModel;\n        }\n        catch (RancidApiException e) {\n            throw e;\n        }\n    }","id":84562,"modified_method":"static public Map<String, Object> getInventoryElement(String rancidName) throws RancidApiException{\n        \n        try {\n        \n            String group = \"laboratorio\";\n            \n            \n            RancidNode rn = RWSClientApi.getRWSRancidNode(m_cp, group, rancidName);\n    \n            \n    \n            InventoryNode in = new InventoryNode(rn);\n            InventoryElement ie = new InventoryElement(in);\n            \n            ie.setElementName(\"Router1\");\n            ie.setVendor(\"Cisco\");\n            ie.setSysOid(\"1.1.1.1.1.1.1\");\n            ie.setModelType(\"x123\");\n            ie.setSerialNumber(\"17266577871\");\n            ie.setProductPartNumber(\"21211212\");\n            ie.setHardwareVersion(\"1.1\");\n            ie.setRamSize(8);\n            ie.setNwRamSize(4);\n            ie.setElementId(4);\n            \n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n    //      Integer ii = Integer(ie.getElementId(4));\n    //      nodeModel.put(\"id\", ii.toString());\n    \n            nodeModel.put(\"status\", ie.getParent().getParent().getState());\n            nodeModel.put(\"name\", ie.getElementName());\n            nodeModel.put(\"elementid\", ie.getElementId());\n            nodeModel.put(\"vendor\", ie.getVendor());\n            nodeModel.put(\"sysoid\", ie.getSysOid());\n            nodeModel.put(\"modeltype\", ie.getModelType());\n            nodeModel.put(\"serialnumber\", ie.getSerialNumber());\n            nodeModel.put(\"productpartnumber\", ie.getProductPartNumber());\n            nodeModel.put(\"hardwareversion\", ie.getHardwareVersion());\n            nodeModel.put(\"ramsize\", ie.getRamSize());        \n            nodeModel.put(\"nwramsize\", ie.getNwRamSize());\n            nodeModel.put(\"group\", group);;\n            nodeModel.put(\"url\", m_cp.getUrl());\n\n    \n            \n            return nodeModel;\n        }\n        catch (RancidApiException e) {\n            throw e;\n        }\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeAdmin(String rancidName, HttpServletRequest request) throws RancidApiException{\n      \n       \n       log().debug(\"getRancidNodeAdmin start\");\n\n       log().debug(\"getRancidNode: \" + rancidName);\n\n       //OnmsNode node = m_nodeDao.get(nodeid);\n\n       Map<String, Object> nodeModel = new TreeMap<String, Object>();\n       nodeModel.put(\"id\", rancidName);\n       //nodeModel.put(\"status_general\", node.getType());\n       \n       List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n       \n       // Group list \n       ConnectionProperties cp = new ConnectionProperties(_URL,\"/rws\",60);\n       RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(cp);\n       \n       List<String> grouplist = groups.getResource();\n       Iterator<String> iter1 = grouplist.iterator();\n       \n     \n       String groupname;\n       boolean first = true;\n       while (iter1.hasNext()){\n           groupname = iter1.next();\n           log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n           \n           try {\n               if (first){\n                   RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, groupname, rancidName);\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   nodeModel.put(\"status\", rn.getState());\n                   nodeModel.put(\"devicetype\", rn.getDeviceType());\n                   nodeModel.put(\"comment\", rn.getComment());\n                   nodeModel.put(\"group\", groupname);\n\n                   first = false;\n               } \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(cp ,groupname, rancidName);\n               String vs = rn.getHeadRevision();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n               RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                 rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n               ranlist.add(rnw); \n               \n           }\n           catch (RancidApiException e){\n               log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n           }\n       }\n       \n       //Groups invariant            \n       nodeModel.put(\"grouptable\", ranlist);\n       nodeModel.put(\"url\", cp.getUrl());\n       \n       //CLOGIN\n       if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n           RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(cp,rancidName);\n           nodeModel.put(\"isadmin\", \"true\");\n           nodeModel.put(\"cloginuser\", rn5.getUser());\n           nodeModel.put(\"cloginpassword\", rn5.getPassword());\n           nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n           nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n           String autoen = \"0\";\n           if (rn5.isAutoEnable()){\n               autoen = \"1\";\n           }\n           nodeModel.put(\"cloginautoenable\", autoen);\n       }\n       \n       return nodeModel;\n}","id":84563,"modified_method":"static public Map<String, Object> getRancidNodeAdmin(String rancidName, HttpServletRequest request) throws RancidApiException{\n      \n       \n       log().debug(\"getRancidNodeAdmin start\");\n\n       log().debug(\"getRancidNode: \" + rancidName);\n\n       //OnmsNode node = m_nodeDao.get(nodeid);\n\n       Map<String, Object> nodeModel = new TreeMap<String, Object>();\n       nodeModel.put(\"id\", rancidName);\n       //nodeModel.put(\"status_general\", node.getType());\n       \n       List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n       \n       // Group list \n       RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n       \n       List<String> grouplist = groups.getResource();\n       Iterator<String> iter1 = grouplist.iterator();\n       \n     \n       String groupname;\n       boolean first = true;\n       while (iter1.hasNext()){\n           groupname = iter1.next();\n           log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n           \n           try {\n               if (first){\n                   RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(m_cp, groupname, rancidName);\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   nodeModel.put(\"status\", rn.getState());\n                   nodeModel.put(\"devicetype\", rn.getDeviceType());\n                   nodeModel.put(\"comment\", rn.getComment());\n                   nodeModel.put(\"group\", groupname);\n\n                   first = false;\n               } \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n               String vs = rn.getHeadRevision();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n               RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                 rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n               ranlist.add(rnw); \n               \n           }\n           catch (RancidApiException e){\n               log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n           }\n       }\n       \n       //Groups invariant            \n       nodeModel.put(\"grouptable\", ranlist);\n       nodeModel.put(\"url\", m_cp.getUrl());\n       \n       //CLOGIN\n       if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n           RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n           nodeModel.put(\"isadmin\", \"true\");\n           nodeModel.put(\"cloginuser\", rn5.getUser());\n           nodeModel.put(\"cloginpassword\", rn5.getPassword());\n           nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n           nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n           String autoen = \"0\";\n           if (rn5.isAutoEnable()){\n               autoen = \"1\";\n           }\n           nodeModel.put(\"cloginautoenable\", autoen);\n       }\n       \n       return nodeModel;\n}","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public void init(){\n        \n        try {\n            log().debug(\"Setting Up RWS client\");\n            RWSClientApi.init();\n\n            //nel config\n            RWSConfigFactory.init();\n            rwsCfgFactory = RWSConfigFactory.getInstance();\n            \n            \n            burl = rwsCfgFactory.getBaseUrl();\n            _URL = burl.getServer_url();\n            log().debug(\"RWS Url \" + _URL);            \n        }\n        catch (Exception e) {\n            \n        }\n    }","id":84564,"modified_method":"static public void init(){\n        \n        try {\n            log().debug(\"Setting Up RWS client\");\n            RWSClientApi.init();\n\n            //nel config\n            RWSConfigFactory.init();\n            rwsCfgFactory = RWSConfigFactory.getInstance();\n            \n           \n            m_cp = rwsCfgFactory.getBase();\n            \n            log().debug(\"RWS Url \" + m_cp.getUrl());            \n        }\n        catch (Exception e) {\n            \n        }\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeList(String rancidName, String groupname) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName + \" \" + groupname);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, groupname, rancidName);\n\n           nodeModel.put(\"devicename\", rn.getDeviceName());\n           \n           //*********\n           // version\n         \n           RWSResourceList versionList;\n           \n           versionList = RWSClientApi.getRWSResourceConfigList(_URL, groupname, rancidName);\n           \n           List<String> versionListStr= versionList.getResource();\n           \n           Iterator<String> iter1 = versionListStr.iterator();\n           \n           String vs;\n           \n           while (iter1.hasNext()) {\n               vs = iter1.next();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n               InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n               ranlist.add(inwr);\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", _URL);\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84565,"modified_method":"static public Map<String, Object> getRancidNodeList(String rancidName, String groupname) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName + \" \" + groupname);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, groupname, rancidName);\n\n           nodeModel.put(\"devicename\", rn.getDeviceName());\n           \n           //*********\n           // version\n         \n           RWSResourceList versionList;\n           \n           versionList = RWSClientApi.getRWSResourceConfigList(m_cp, groupname, rancidName);\n           \n           List<String> versionListStr= versionList.getResource();\n           \n           Iterator<String> iter1 = versionListStr.iterator();\n           \n           String vs;\n           \n           while (iter1.hasNext()) {\n               vs = iter1.next();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n               InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n               ranlist.add(inwr);\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getInventoryNode(String rancidName, String group, String version) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getInventoryNode \" + rancidName);\n\n    \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, group, rancidName);\n       \n           InventoryNode in = (InventoryNode)rn.getNodeVersions().get(version);\n           \n           //InventoryWrapper tmpw = new InventoryWrapper(version, in.getExpirationDate(), group, in.getConfigurationUrl());\n                       \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n   \n           nodeModel.put(\"devicename\", rancidName);\n           nodeModel.put(\"groupname\", group);\n           nodeModel.put(\"version\", version);\n           nodeModel.put(\"status\", in.getParent().getState());\n           nodeModel.put(\"creationdate\", in.getCreationDate());\n           log().debug(\"getInventoryNode date\" + in.getCreationDate());\n           nodeModel.put(\"configurationurl\", in.getConfigurationUrl());\n           nodeModel.put(\"url\", _URL);\n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84566,"modified_method":"static public Map<String, Object> getInventoryNode(String rancidName, String group, String version) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getInventoryNode \" + rancidName);\n\n    \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, group, rancidName);\n       \n           InventoryNode in = (InventoryNode)rn.getNodeVersions().get(version);\n           \n           //InventoryWrapper tmpw = new InventoryWrapper(version, in.getExpirationDate(), group, in.getConfigurationUrl());\n                       \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n   \n           nodeModel.put(\"devicename\", rancidName);\n           nodeModel.put(\"groupname\", group);\n           nodeModel.put(\"version\", version);\n           nodeModel.put(\"status\", in.getParent().getState());\n           nodeModel.put(\"creationdate\", in.getCreationDate());\n           nodeModel.put(\"swconfigurationurl\", in.getSoftwareImageUrl());\n           log().debug(\"getInventoryNode date\" + in.getCreationDate());\n           nodeModel.put(\"configurationurl\", in.getConfigurationUrl());\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNode(String rancidName, HttpServletRequest request) throws RancidApiException{\n        \n            \n            log().debug(\"getRancidNode \" + rancidName);\n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list            \n            RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(_URL);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);\n\n                try {\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n                    if (first) {\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        first = false;\n                    }\n                    ranlist.add(rnw); \n\n                }\n                catch (RancidApiException e){\n                    log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", _URL);\n            \n            //CLOGIN\n            if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(_URL,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n            \n            return nodeModel;\n        \n\n    }","id":84567,"modified_method":"static public Map<String, Object> getRancidNode(String rancidName, HttpServletRequest request) throws RancidApiException{\n        \n            \n            log().debug(\"getRancidNode \" + rancidName);\n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list            \n            RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);\n\n                try {\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n                    if (first) {\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        first = false;\n                    }\n                    ranlist.add(rnw); \n\n                }\n                catch (RancidApiException e){\n                    log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", m_cp.getUrl());\n            \n            //CLOGIN\n            if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n            \n            return nodeModel;\n        \n\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        //FIXME this should be done by spring\n            RWSClientApi.init();\n    }","id":84568,"modified_method":"public void afterPropertiesSet() throws Exception {\n        //FIXME this should be done by spring\n            RWSClientApi.init();\n            m_cp = m_rwsConfig.getBase();\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, Object> getRancidNode(int nodeid, boolean adminRole) throws RancidApiException{\n        \n        log().debug(\"getRancidNode start\");\n        \n        OnmsNode node = m_nodeDao.get(nodeid);\n        String rancidName = node.getLabel();\n\n        log().debug(\"getRancidNode: \" + rancidName);\n\n\n        Map<String, Object> nodeModel = new TreeMap<String, Object>();\n        nodeModel.put(\"id\", rancidName);\n        nodeModel.put(\"db_id\", nodeid);\n        nodeModel.put(\"status_general\", node.getType());\n        \n        List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n        \n        // Group list \n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n        RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(cp);\n        \n        List<String> grouplist = groups.getResource();\n        Iterator<String> iter1 = grouplist.iterator();\n        \n      \n        String groupname;\n        boolean first = true;\n        while (iter1.hasNext()){\n            groupname = iter1.next();\n            log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n            \n            try {\n                if (first){\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, groupname, rancidName);\n                    nodeModel.put(\"devicename\", rn.getDeviceName());\n                    nodeModel.put(\"status\", rn.getState());\n                    nodeModel.put(\"devicetype\", rn.getDeviceType());\n                    nodeModel.put(\"comment\", rn.getComment());\n                    nodeModel.put(\"groupname\", groupname);\n                    first = false;\n                } \n                RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(cp ,groupname, rancidName);\n                String vs = rn.getHeadRevision();\n                InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                  rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n                ranlist.add(rnw); \n                \n            }\n            catch (RancidApiException e){\n                log().debug(\"No inventory information associated to \" + rancidName);\n            }\n        }\n        \n        //Groups invariant            \n        nodeModel.put(\"grouptable\", ranlist);\n        nodeModel.put(\"url\", cp.getUrl());\n        \n        //CLOGIN\n        if (adminRole) {\n\n            RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(cp,rancidName);\n            nodeModel.put(\"isadmin\", \"true\");\n            nodeModel.put(\"cloginuser\", rn5.getUser());\n            nodeModel.put(\"cloginpassword\", rn5.getPassword());\n            nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n            nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n            String autoen = \"0\";\n            if (rn5.isAutoEnable()){\n                autoen = \"1\";\n            }\n            nodeModel.put(\"cloginautoenable\", autoen);\n        }\n        \n        return nodeModel;\n    \n\n    }","id":84569,"modified_method":"public Map<String, Object> getRancidNode(int nodeid, boolean adminRole) {\n        \n        log().debug(\"getRancidNode start\");\n        Map<String, Object> nodeModel = new TreeMap<String, Object>();\n\n        try {\n        \n            OnmsNode node = m_nodeDao.get(nodeid);\n            String rancidName = node.getLabel();\n    \n            log().debug(\"getRancidNode: \" + rancidName);\n    \n    \n            nodeModel.put(\"id\", rancidName);\n            nodeModel.put(\"db_id\", nodeid);\n            nodeModel.put(\"status_general\", node.getType());\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n                \n                try {\n                    if (first){\n                        RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(m_cp, groupname, rancidName);\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        nodeModel.put(\"groupname\", groupname);\n                        first = false;\n                    } \n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n    \n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n    \n                    ranlist.add(rnw); \n                    \n                }\n                catch (RancidApiException e){\n                    log().debug(\"No inventory information associated to \" + rancidName);\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", m_cp.getUrl());\n            \n            //CLOGIN\n            if (adminRole) {\n    \n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n        }catch (Exception e){\n            log().debug(\"getRancidNode has given exception \" + e.getMessage());\n        }\n        return nodeModel;\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n       \n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"inventory/rancid\",\"model\",model);\n        return modelAndView;\n    }","id":84570,"modified_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n       \n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map<String, Object> model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"inventory/rancid\",\"model\",model);\n        return modelAndView;\n    }","commit_id":"1fe6b1e2b0197702ede61c0718f6c08fb2ee4cc2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit\");\n        \n        AdminRancidCloginCommClass bean = (AdminRancidCloginCommClass) command;\n        \n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit following changes\"+\n                    \"userID [\"+ bean.getUserID() +\"] \"+\n                    \"pass [\" + bean.getPass() +\"] \"+\n                    \"enpass [\" + bean.getEnpass()+\"] \"+\n                    \"loginM [\" + bean.getLoginM()+\"] \"+\n                    \"autoE [\" + bean.getAutoE()+\"] \"+\n                    \"groupName [\" + bean.getGroupName()+\"] \"+\n                    \"deviceName [\" + bean.getDeviceName() + \"] \"); \n\n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n\n        RancidNodeAuthentication rna = RWSClientApi.getRWSAuthNode(cp, bean.getDeviceName());\n        rna.setUser(bean.getUserID());\n        rna.setPassword(bean.getPass());\n        rna.setConnectionMethod(bean.getLoginM());\n        rna.setEnablePass(bean.getAutoE());\n        boolean autoe = false;\n        if (bean.getAutoE().compareTo(\"1\")==0) {\n            autoe = true;\n        }\n        rna.setAutoEnable(autoe);\n        RWSClientApi.createOrUpdateRWSAuthNode(cp,rna);\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit changes submitted\");\n\n\n        \n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","id":84571,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidCloginController ModelAndView onSubmit\");\n        \n        AdminRancidCloginCommClass bean = (AdminRancidCloginCommClass) command;\n        \n        boolean done = m_inventoryService.updateClogin(bean.getDeviceName(), bean.getGroupName(), bean.getUserID(), bean.getPass(),\n                                        bean.getEnpass(), bean.getLoginM(), bean.getAutoE());\n        if (!done){\n            log().debug(\"AdminRancidCloginController error on submitting cLogin changes\");\n        }\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"admin/rancid/rancidAdmin\",\"model\",model);\n        return modelAndView;\n    }","id":84572,"modified_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map<String, Object> model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"admin/rancid/rancidAdmin\",\"model\",model);\n        return modelAndView;\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit\");\n\n        AdminRancidStatusCommClass bean = (AdminRancidStatusCommClass) command;\n        \n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n                \n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit setting state to device[\"+ bean.getDeviceName() + \"] group[\" + bean.getGroupName() + \"] status[\" + bean.getStatusName()+\"]\");\n\n        RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, bean.getGroupName(), bean.getDeviceName());\n        if (rn.isStateUp()){\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit :down\");\n            rn.setStateUp(false);\n        }else {\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit :up\");\n            rn.setStateUp(true);\n        }\n        RWSClientApi.updateRWSRancidNode(cp, rn);\n\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","id":84573,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit\");\n\n        AdminRancidStatusCommClass bean = (AdminRancidStatusCommClass) command;\n                       \n        log().debug(\"AdminRancidStatusController ModelAndView onSubmit setting state to device[\"+ bean.getDeviceName() + \"] group[\" + bean.getGroupName() + \"] status[\" + bean.getStatusName()+\"]\");\n\n        boolean done = m_inventoryService.updateStatus(bean.getGroupName(), bean.getDeviceName());\n        if (!done){\n            log().debug(\"AdminRancidStatusController ModelAndView onSubmit error while updating status for\"+ bean.getGroupName() + \"/\" + bean.getDeviceName());\n        }\n        String redirectURL = request.getHeader(\"Referer\");\n        response.sendRedirect(redirectURL);\n        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeAdmin(String rancidName, HttpServletRequest request) throws RancidApiException{\n      \n       \n       log().debug(\"getRancidNodeAdmin start\");\n\n       log().debug(\"getRancidNode: \" + rancidName);\n\n       //OnmsNode node = m_nodeDao.get(nodeid);\n\n       Map<String, Object> nodeModel = new TreeMap<String, Object>();\n       nodeModel.put(\"id\", rancidName);\n       //nodeModel.put(\"status_general\", node.getType());\n       \n       List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n       \n       // Group list \n       ConnectionProperties cp = new ConnectionProperties(_URL,\"/rws\",60);\n       RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(cp);\n       \n       List<String> grouplist = groups.getResource();\n       Iterator<String> iter1 = grouplist.iterator();\n       \n     \n       String groupname;\n       boolean first = true;\n       while (iter1.hasNext()){\n           groupname = iter1.next();\n           log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n           \n           try {\n               if (first){\n                   RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, groupname, rancidName);\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   nodeModel.put(\"status\", rn.getState());\n                   nodeModel.put(\"devicetype\", rn.getDeviceType());\n                   nodeModel.put(\"comment\", rn.getComment());\n                   nodeModel.put(\"group\", groupname);\n\n                   first = false;\n               } \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(cp ,groupname, rancidName);\n               String vs = rn.getHeadRevision();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n               RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                 rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n               ranlist.add(rnw); \n               \n           }\n           catch (RancidApiException e){\n               log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n           }\n       }\n       \n       //Groups invariant            \n       nodeModel.put(\"grouptable\", ranlist);\n       nodeModel.put(\"url\", cp.getUrl());\n       \n       //CLOGIN\n       if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n           RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(cp,rancidName);\n           nodeModel.put(\"isadmin\", \"true\");\n           nodeModel.put(\"cloginuser\", rn5.getUser());\n           nodeModel.put(\"cloginpassword\", rn5.getPassword());\n           nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n           nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n           String autoen = \"0\";\n           if (rn5.isAutoEnable()){\n               autoen = \"1\";\n           }\n           nodeModel.put(\"cloginautoenable\", autoen);\n       }\n       \n       return nodeModel;\n}","id":84574,"modified_method":"static public Map<String, Object> getRancidNodeAdmin(String rancidName, HttpServletRequest request) throws RancidApiException{\n      \n       \n       log().debug(\"getRancidNodeAdmin start\");\n\n       log().debug(\"getRancidNode: \" + rancidName);\n\n       //OnmsNode node = m_nodeDao.get(nodeid);\n\n       Map<String, Object> nodeModel = new TreeMap<String, Object>();\n       nodeModel.put(\"id\", rancidName);\n       //nodeModel.put(\"status_general\", node.getType());\n       \n       List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n       \n       // Group list \n       RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n       \n       List<String> grouplist = groups.getResource();\n       Iterator<String> iter1 = grouplist.iterator();\n       \n     \n       String groupname;\n       boolean first = true;\n       while (iter1.hasNext()){\n           groupname = iter1.next();\n           log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n           \n           try {\n               if (first){\n                   RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(m_cp, groupname, rancidName);\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   nodeModel.put(\"status\", rn.getState());\n                   nodeModel.put(\"devicetype\", rn.getDeviceType());\n                   nodeModel.put(\"comment\", rn.getComment());\n                   nodeModel.put(\"group\", groupname);\n\n                   first = false;\n               } \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n               String vs = rn.getHeadRevision();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n               RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                 rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n               ranlist.add(rnw); \n               \n           }\n           catch (RancidApiException e){\n               log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n           }\n       }\n       \n       //Groups invariant            \n       nodeModel.put(\"grouptable\", ranlist);\n       nodeModel.put(\"url\", m_cp.getUrl());\n       \n       //CLOGIN\n       if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n           RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n           nodeModel.put(\"isadmin\", \"true\");\n           nodeModel.put(\"cloginuser\", rn5.getUser());\n           nodeModel.put(\"cloginpassword\", rn5.getPassword());\n           nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n           nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n           String autoen = \"0\";\n           if (rn5.isAutoEnable()){\n               autoen = \"1\";\n           }\n           nodeModel.put(\"cloginautoenable\", autoen);\n       }\n       \n       return nodeModel;\n}","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNode(String rancidName, HttpServletRequest request) throws RancidApiException{\n        \n            \n            log().debug(\"getRancidNode \" + rancidName);\n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list            \n            RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(_URL);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);\n\n                try {\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n                    if (first) {\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        first = false;\n                    }\n                    ranlist.add(rnw); \n\n                }\n                catch (RancidApiException e){\n                    log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", _URL);\n            \n            //CLOGIN\n            if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(_URL,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n            \n            return nodeModel;\n        \n\n    }","id":84575,"modified_method":"static public Map<String, Object> getRancidNode(String rancidName, HttpServletRequest request) throws RancidApiException{\n        \n            \n            log().debug(\"getRancidNode \" + rancidName);\n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list            \n            RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);\n\n                try {\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n                    if (first) {\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        first = false;\n                    }\n                    ranlist.add(rnw); \n\n                }\n                catch (RancidApiException e){\n                    log().debug(\"Exception in getRancidNode getRWSRancidNodeInventory \");\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", m_cp.getUrl());\n            \n            //CLOGIN\n            if (request.isUserInRole(Authentication.ADMIN_ROLE)) {\n\n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n            \n            return nodeModel;\n        \n\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeList(String rancidName, String groupname) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName + \" \" + groupname);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, groupname, rancidName);\n\n           nodeModel.put(\"devicename\", rn.getDeviceName());\n           \n           //*********\n           // version\n         \n           RWSResourceList versionList;\n           \n           versionList = RWSClientApi.getRWSResourceConfigList(_URL, groupname, rancidName);\n           \n           List<String> versionListStr= versionList.getResource();\n           \n           Iterator<String> iter1 = versionListStr.iterator();\n           \n           String vs;\n           \n           while (iter1.hasNext()) {\n               vs = iter1.next();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n               InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n               ranlist.add(inwr);\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", _URL);\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84576,"modified_method":"static public Map<String, Object> getRancidNodeList(String rancidName, String groupname) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName + \" \" + groupname);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, groupname, rancidName);\n\n           nodeModel.put(\"devicename\", rn.getDeviceName());\n           \n           //*********\n           // version\n         \n           RWSResourceList versionList;\n           \n           versionList = RWSClientApi.getRWSResourceConfigList(m_cp, groupname, rancidName);\n           \n           List<String> versionListStr= versionList.getResource();\n           \n           Iterator<String> iter1 = versionListStr.iterator();\n           \n           String vs;\n           \n           while (iter1.hasNext()) {\n               vs = iter1.next();\n               InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n               InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n               ranlist.add(inwr);\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getRancidNodeList(String rancidName) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(_URL);\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           List<String> grouplist = groups.getResource();\n           Iterator<String> iter2 = grouplist.iterator();\n           \n           boolean first = true;\n           String groupname;\n           while (iter2.hasNext()) {\n               groupname = iter2.next();\n           \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, groupname, rancidName);\n    \n               if (first){\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   first = false;\n               }\n               \n               //*********\n               // version\n             \n               RWSResourceList versionList;\n               \n               versionList = RWSClientApi.getRWSResourceConfigList(_URL, groupname, rancidName);\n               \n               List<String> versionListStr= versionList.getResource();\n               \n               Iterator<String> iter1 = versionListStr.iterator();\n               \n               String vs;\n               \n               while (iter1.hasNext()) {\n                   vs = iter1.next();\n                   InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n                   InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n                   ranlist.add(inwr);\n               }\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", _URL);\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84577,"modified_method":"static public Map<String, Object> getRancidNodeList(String rancidName) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getRancidNodeList \" + rancidName);\n\n           \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n           \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n           \n           List<InventoryWrapper> ranlist = new ArrayList<InventoryWrapper>();\n           \n           List<String> grouplist = groups.getResource();\n           Iterator<String> iter2 = grouplist.iterator();\n           \n           boolean first = true;\n           String groupname;\n           while (iter2.hasNext()) {\n               groupname = iter2.next();\n           \n               RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, groupname, rancidName);\n    \n               if (first){\n                   nodeModel.put(\"devicename\", rn.getDeviceName());\n                   first = false;\n               }\n               \n               //*********\n               // version\n             \n               RWSResourceList versionList;\n               \n               versionList = RWSClientApi.getRWSResourceConfigList(m_cp, groupname, rancidName);\n               \n               List<String> versionListStr= versionList.getResource();\n               \n               Iterator<String> iter1 = versionListStr.iterator();\n               \n               String vs;\n               \n               while (iter1.hasNext()) {\n                   vs = iter1.next();\n                   InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n                   InventoryWrapper inwr = new InventoryWrapper(in.getVersionId(), in.getCreationDate(), groupname, in.getConfigurationUrl());\n                   ranlist.add(inwr);\n               }\n           }\n           \n           nodeModel.put(\"grouptable\", ranlist);\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public void init(){\n        \n        try {\n            log().debug(\"Setting Up RWS client\");\n            RWSClientApi.init();\n\n            //nel config\n            RWSConfigFactory.init();\n            rwsCfgFactory = RWSConfigFactory.getInstance();\n            \n            \n            burl = rwsCfgFactory.getBaseUrl();\n            _URL = burl.getServer_url();\n            log().debug(\"RWS Url \" + _URL);            \n        }\n        catch (Exception e) {\n            \n        }\n    }","id":84578,"modified_method":"static public void init(){\n        \n        try {\n            log().debug(\"Setting Up RWS client\");\n            RWSClientApi.init();\n\n            //nel config\n            RWSConfigFactory.init();\n            rwsCfgFactory = RWSConfigFactory.getInstance();\n            \n           \n            m_cp = rwsCfgFactory.getBase();\n            \n            log().debug(\"RWS Url \" + m_cp.getUrl());            \n        }\n        catch (Exception e) {\n            \n        }\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getInventoryNode(String rancidName, String group, String version) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getInventoryNode \" + rancidName);\n\n    \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(_URL, group, rancidName);\n       \n           InventoryNode in = (InventoryNode)rn.getNodeVersions().get(version);\n           \n           //InventoryWrapper tmpw = new InventoryWrapper(version, in.getExpirationDate(), group, in.getConfigurationUrl());\n                       \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n   \n           nodeModel.put(\"devicename\", rancidName);\n           nodeModel.put(\"groupname\", group);\n           nodeModel.put(\"version\", version);\n           nodeModel.put(\"status\", in.getParent().getState());\n           nodeModel.put(\"creationdate\", in.getCreationDate());\n           log().debug(\"getInventoryNode date\" + in.getCreationDate());\n           nodeModel.put(\"configurationurl\", in.getConfigurationUrl());\n           nodeModel.put(\"url\", _URL);\n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","id":84579,"modified_method":"static public Map<String, Object> getInventoryNode(String rancidName, String group, String version) throws RancidApiException{\n       \n       try {\n           \n           log().debug(\"getInventoryNode \" + rancidName);\n\n    \n           RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp, group, rancidName);\n       \n           InventoryNode in = (InventoryNode)rn.getNodeVersions().get(version);\n           \n           //InventoryWrapper tmpw = new InventoryWrapper(version, in.getExpirationDate(), group, in.getConfigurationUrl());\n                       \n           Map<String, Object> nodeModel = new TreeMap<String, Object>();\n   \n           nodeModel.put(\"devicename\", rancidName);\n           nodeModel.put(\"groupname\", group);\n           nodeModel.put(\"version\", version);\n           nodeModel.put(\"status\", in.getParent().getState());\n           nodeModel.put(\"creationdate\", in.getCreationDate());\n           nodeModel.put(\"swconfigurationurl\", in.getSoftwareImageUrl());\n           log().debug(\"getInventoryNode date\" + in.getCreationDate());\n           nodeModel.put(\"configurationurl\", in.getConfigurationUrl());\n           nodeModel.put(\"url\", m_cp.getUrl());\n           \n           return nodeModel;\n       }\n       catch (RancidApiException e) {\n           throw e;\n       }\n   }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static public Map<String, Object> getInventoryElement(String rancidName) throws RancidApiException{\n        \n        try {\n        \n            String group = \"laboratorio\";\n            \n            \n            RancidNode rn = RWSClientApi.getRWSRancidNode(_URL, group, rancidName);\n    \n            \n    \n            InventoryNode in = new InventoryNode(rn);\n            InventoryElement ie = new InventoryElement(in);\n            \n            ie.setElementName(\"Router1\");\n            ie.setVendor(\"Cisco\");\n            ie.setSysOid(\"1.1.1.1.1.1.1\");\n            ie.setModelType(\"x123\");\n            ie.setSerialNumber(\"17266577871\");\n            ie.setProductPartNumber(\"21211212\");\n            ie.setHardwareVersion(\"1.1\");\n            ie.setRamSize(8);\n            ie.setNwRamSize(4);\n            ie.setElementId(4);\n            \n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n    //      Integer ii = Integer(ie.getElementId(4));\n    //      nodeModel.put(\"id\", ii.toString());\n    \n            nodeModel.put(\"status\", ie.getParent().getParent().getState());\n            nodeModel.put(\"name\", ie.getElementName());\n            nodeModel.put(\"elementid\", ie.getElementId());\n            nodeModel.put(\"vendor\", ie.getVendor());\n            nodeModel.put(\"sysoid\", ie.getSysOid());\n            nodeModel.put(\"modeltype\", ie.getModelType());\n            nodeModel.put(\"serialnumber\", ie.getSerialNumber());\n            nodeModel.put(\"productpartnumber\", ie.getProductPartNumber());\n            nodeModel.put(\"hardwareversion\", ie.getHardwareVersion());\n            nodeModel.put(\"ramsize\", ie.getRamSize());        \n            nodeModel.put(\"nwramsize\", ie.getNwRamSize());\n            nodeModel.put(\"group\", group);;\n            nodeModel.put(\"url\", _URL);\n\n    \n            \n            return nodeModel;\n        }\n        catch (RancidApiException e) {\n            throw e;\n        }\n    }","id":84580,"modified_method":"static public Map<String, Object> getInventoryElement(String rancidName) throws RancidApiException{\n        \n        try {\n        \n            String group = \"laboratorio\";\n            \n            \n            RancidNode rn = RWSClientApi.getRWSRancidNode(m_cp, group, rancidName);\n    \n            \n    \n            InventoryNode in = new InventoryNode(rn);\n            InventoryElement ie = new InventoryElement(in);\n            \n            ie.setElementName(\"Router1\");\n            ie.setVendor(\"Cisco\");\n            ie.setSysOid(\"1.1.1.1.1.1.1\");\n            ie.setModelType(\"x123\");\n            ie.setSerialNumber(\"17266577871\");\n            ie.setProductPartNumber(\"21211212\");\n            ie.setHardwareVersion(\"1.1\");\n            ie.setRamSize(8);\n            ie.setNwRamSize(4);\n            ie.setElementId(4);\n            \n            Map<String, Object> nodeModel = new TreeMap<String, Object>();\n    //      Integer ii = Integer(ie.getElementId(4));\n    //      nodeModel.put(\"id\", ii.toString());\n    \n            nodeModel.put(\"status\", ie.getParent().getParent().getState());\n            nodeModel.put(\"name\", ie.getElementName());\n            nodeModel.put(\"elementid\", ie.getElementId());\n            nodeModel.put(\"vendor\", ie.getVendor());\n            nodeModel.put(\"sysoid\", ie.getSysOid());\n            nodeModel.put(\"modeltype\", ie.getModelType());\n            nodeModel.put(\"serialnumber\", ie.getSerialNumber());\n            nodeModel.put(\"productpartnumber\", ie.getProductPartNumber());\n            nodeModel.put(\"hardwareversion\", ie.getHardwareVersion());\n            nodeModel.put(\"ramsize\", ie.getRamSize());        \n            nodeModel.put(\"nwramsize\", ie.getNwRamSize());\n            nodeModel.put(\"group\", group);;\n            nodeModel.put(\"url\", m_cp.getUrl());\n\n    \n            \n            return nodeModel;\n        }\n        catch (RancidApiException e) {\n            throw e;\n        }\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        //FIXME this should be done by spring\n            RWSClientApi.init();\n    }","id":84581,"modified_method":"public void afterPropertiesSet() throws Exception {\n        //FIXME this should be done by spring\n            RWSClientApi.init();\n            m_cp = m_rwsConfig.getBase();\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, Object> getRancidNode(int nodeid, boolean adminRole) throws RancidApiException{\n        \n        log().debug(\"getRancidNode start\");\n        \n        OnmsNode node = m_nodeDao.get(nodeid);\n        String rancidName = node.getLabel();\n\n        log().debug(\"getRancidNode: \" + rancidName);\n\n\n        Map<String, Object> nodeModel = new TreeMap<String, Object>();\n        nodeModel.put(\"id\", rancidName);\n        nodeModel.put(\"db_id\", nodeid);\n        nodeModel.put(\"status_general\", node.getType());\n        \n        List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n        \n        // Group list \n        ConnectionProperties cp = new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n        RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(cp);\n        \n        List<String> grouplist = groups.getResource();\n        Iterator<String> iter1 = grouplist.iterator();\n        \n      \n        String groupname;\n        boolean first = true;\n        while (iter1.hasNext()){\n            groupname = iter1.next();\n            log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n            \n            try {\n                if (first){\n                    RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(cp, groupname, rancidName);\n                    nodeModel.put(\"devicename\", rn.getDeviceName());\n                    nodeModel.put(\"status\", rn.getState());\n                    nodeModel.put(\"devicetype\", rn.getDeviceType());\n                    nodeModel.put(\"comment\", rn.getComment());\n                    nodeModel.put(\"groupname\", groupname);\n                    first = false;\n                } \n                RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(cp ,groupname, rancidName);\n                String vs = rn.getHeadRevision();\n                InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n\n                RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                  rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n\n                ranlist.add(rnw); \n                \n            }\n            catch (RancidApiException e){\n                log().debug(\"No inventory information associated to \" + rancidName);\n            }\n        }\n        \n        //Groups invariant            \n        nodeModel.put(\"grouptable\", ranlist);\n        nodeModel.put(\"url\", cp.getUrl());\n        \n        //CLOGIN\n        if (adminRole) {\n\n            RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(cp,rancidName);\n            nodeModel.put(\"isadmin\", \"true\");\n            nodeModel.put(\"cloginuser\", rn5.getUser());\n            nodeModel.put(\"cloginpassword\", rn5.getPassword());\n            nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n            nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n            String autoen = \"0\";\n            if (rn5.isAutoEnable()){\n                autoen = \"1\";\n            }\n            nodeModel.put(\"cloginautoenable\", autoen);\n        }\n        \n        return nodeModel;\n    \n\n    }","id":84582,"modified_method":"public Map<String, Object> getRancidNode(int nodeid, boolean adminRole) {\n        \n        log().debug(\"getRancidNode start\");\n        Map<String, Object> nodeModel = new TreeMap<String, Object>();\n\n        try {\n        \n            OnmsNode node = m_nodeDao.get(nodeid);\n            String rancidName = node.getLabel();\n    \n            log().debug(\"getRancidNode: \" + rancidName);\n    \n    \n            nodeModel.put(\"id\", rancidName);\n            nodeModel.put(\"db_id\", nodeid);\n            nodeModel.put(\"status_general\", node.getType());\n            \n            List<RancidNodeWrapper> ranlist = new ArrayList<RancidNodeWrapper>();\n            \n            // Group list \n           RWSResourceList groups = RWSClientApi.getRWSResourceGroupsList(m_cp);\n            \n            List<String> grouplist = groups.getResource();\n            Iterator<String> iter1 = grouplist.iterator();\n            \n          \n            String groupname;\n            boolean first = true;\n            while (iter1.hasNext()){\n                groupname = iter1.next();\n                log().debug(\"getRancidNode \" + rancidName + \" group \" + groupname);        \n                \n                try {\n                    if (first){\n                        RancidNode rn = RWSClientApi.getRWSRancidNodeTLO(m_cp, groupname, rancidName);\n                        nodeModel.put(\"devicename\", rn.getDeviceName());\n                        nodeModel.put(\"status\", rn.getState());\n                        nodeModel.put(\"devicetype\", rn.getDeviceType());\n                        nodeModel.put(\"comment\", rn.getComment());\n                        nodeModel.put(\"groupname\", groupname);\n                        first = false;\n                    } \n                    RancidNode rn = RWSClientApi.getRWSRancidNodeInventory(m_cp ,groupname, rancidName);\n                    String vs = rn.getHeadRevision();\n                    InventoryNode in = (InventoryNode)rn.getNodeVersions().get(vs);\n    \n                    RancidNodeWrapper rnw = new RancidNodeWrapper(rn.getDeviceName(), groupname, rn.getDeviceType(), rn.getComment(), rn.getHeadRevision(),\n                      rn.getTotalRevisions(), in.getCreationDate(), rn.getRootConfigurationUrl());\n    \n                    ranlist.add(rnw); \n                    \n                }\n                catch (RancidApiException e){\n                    log().debug(\"No inventory information associated to \" + rancidName);\n                }\n            }\n            \n            //Groups invariant            \n            nodeModel.put(\"grouptable\", ranlist);\n            nodeModel.put(\"url\", m_cp.getUrl());\n            \n            //CLOGIN\n            if (adminRole) {\n    \n                RancidNodeAuthentication rn5 = RWSClientApi.getRWSAuthNode(m_cp,rancidName);\n                nodeModel.put(\"isadmin\", \"true\");\n                nodeModel.put(\"cloginuser\", rn5.getUser());\n                nodeModel.put(\"cloginpassword\", rn5.getPassword());\n                nodeModel.put(\"cloginconnmethod\", rn5.getConnectionMethodString());\n                nodeModel.put(\"cloginenablepass\", rn5.getEnablePass());\n                String autoen = \"0\";\n                if (rn5.isAutoEnable()){\n                    autoen = \"1\";\n                }\n                nodeModel.put(\"cloginautoenable\", autoen);\n            }\n        }catch (Exception e){\n            log().debug(\"getRancidNode has given exception \" + e.getMessage());\n        }\n        return nodeModel;\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n       \n            \n        \n\n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"inventory/rancid\",\"model\",model);\n        return modelAndView;\n    }","id":84583,"modified_method":"public ModelAndView handleRequest(HttpServletRequest request,\n            HttpServletResponse arg1) throws Exception {\n       \n        String node = request.getParameter(\"node\");\n        int nodeid = WebSecurityUtils.safeParseInt(node);\n        Map<String, Object> model = m_inventoryService.getRancidNode(nodeid,request.isUserInRole(Authentication.ADMIN_ROLE));\n        ModelAndView modelAndView = new ModelAndView(\"inventory/rancid\",\"model\",model);\n        return modelAndView;\n    }","commit_id":"4ef816671cfec485bf5ede3e709afffe529ef1e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public void vectorToParams(double[] theta) {\n    if (TRAIN_WORD_VECTORS) {\n      vectorToParams(theta,\n                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                     wordVectors.values().iterator());\n    } else {\n      vectorToParams(theta,\n                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84584,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public void vectorToParams(double[] theta) {\n    if (TRAIN_WORD_VECTORS) {\n      RNNUtils.vectorToParams(theta,\n                              binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                              binaryScore.valueIterator(), unaryScore.values().iterator(),\n                              wordVectors.values().iterator());\n    } else {\n      RNNUtils.vectorToParams(theta,\n                              binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                              binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    System.err.println(\"Reading in the word vector file: \" + op.lexOptions.wordVectorFile);\n    int dimOfWords = 0;\n    boolean warned = false;\n    for (String line : IOUtils.readLines(op.lexOptions.wordVectorFile, \"utf-8\")) {\n      String[]  lineSplit = line.split(\"\\\\s+\");\n      String word = lineSplit[0];\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n      dimOfWords = lineSplit.length - 1;\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = dimOfWords;\n        System.err.println(\"Dimensionality of numHid not set.  The length of the word vectors in the given file appears to be \" + dimOfWords);\n      }\n      // the first entry is the word itself\n      // the other entries will all be entries in the word vector\n      if (dimOfWords > op.lexOptions.numHid) {\n        if (!warned) {\n          warned = true;\n          System.err.println(\"WARNING: Dimensionality of numHid parameter and word vectors do not match, deleting word vector dimensions to fit!\");\n        }\n        dimOfWords = op.lexOptions.numHid;\n      } else if (dimOfWords < op.lexOptions.numHid) {\n        throw new RuntimeException(\"Word vectors file has dimension too small for requested numHid of \" + op.lexOptions.numHid);\n      }\n      double vec[][] = new double[dimOfWords][1];\n      for (int i = 1; i <= dimOfWords; i++) {\n        vec[i-1][0] = Double.parseDouble(lineSplit[i]);\n      }\n      SimpleMatrix vector = new SimpleMatrix(vec);\n      wordVectors.put(word, vector);\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","id":84585,"modified_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.lexOptions.wordVectorFile, op.lexOptions.numHid);\n\n    for (String word : rawWordVectors.keySet()) {\n      SimpleMatrix vector = rawWordVectors.get(word);\n\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = vector.getNumElements();\n      }\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector() {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return paramsToVector(totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator(),\n                            wordVectors.values().iterator());\n    } else {\n      return paramsToVector(totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84586,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector() {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return RNNUtils.paramsToVector(totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                                     wordVectors.values().iterator());\n    } else {\n      return RNNUtils.paramsToVector(totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector(double scale) {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return paramsToVector(scale, totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator(),\n                            wordVectors.values().iterator());\n    } else {\n      return paramsToVector(scale, totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84587,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector(double scale) {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return RNNUtils.paramsToVector(scale, totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                                     wordVectors.values().iterator());\n    } else {\n      return RNNUtils.paramsToVector(scale, totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void calculate(double[] theta) {\r\n    dvModel.vectorToParams(theta);\r\n\r\n    double localValue = 0.0;\r\n    double[] localDerivative = new double[theta.length];\r\n\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfsG,binaryW_dfsB;\r\n    binaryW_dfsG = TwoDimensionalMap.treeMap();\r\n    binaryW_dfsB = TwoDimensionalMap.treeMap();\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivativesG,binaryScoreDerivativesB ;\r\n    binaryScoreDerivativesG = TwoDimensionalMap.treeMap();\r\n    binaryScoreDerivativesB = TwoDimensionalMap.treeMap();\r\n    Map<String, SimpleMatrix> unaryW_dfsG,unaryW_dfsB ;\r\n    unaryW_dfsG = new TreeMap<String, SimpleMatrix>();\r\n    unaryW_dfsB = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> unaryScoreDerivativesG,unaryScoreDerivativesB ;\r\n    unaryScoreDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    unaryScoreDerivativesB= new TreeMap<String, SimpleMatrix>();\r\n\r\n    Map<String, SimpleMatrix> wordVectorDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> wordVectorDerivativesB = new TreeMap<String, SimpleMatrix>();\r\n\r\n    for (TwoDimensionalMap.Entry<String, String, SimpleMatrix> entry : dvModel.binaryTransform) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      binaryW_dfsG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryW_dfsB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryScoreDerivativesG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n      binaryScoreDerivativesB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    for (Map.Entry<String, SimpleMatrix> entry : dvModel.unaryTransform.entrySet()) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      unaryW_dfsG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryW_dfsB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryScoreDerivativesG.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n      unaryScoreDerivativesB.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      for (Map.Entry<String, SimpleMatrix> entry : dvModel.wordVectors.entrySet()) {\r\n        int numRows = entry.getValue().numRows();\r\n        int numCols = entry.getValue().numCols();\r\n        wordVectorDerivativesG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n        wordVectorDerivativesB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      }\r\n    }\r\n\r\n    // Some optimization methods prints out a line without an end, so our\r\n    // debugging statements are misaligned\r\n    Timing scoreTiming = new Timing();\r\n    scoreTiming.doing(\"Scoring trees\");\r\n    int treeNum = 0;\r\n    MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>> wrapper = new MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>>(op.trainOptions.trainingThreads, new ScoringProcessor());\r\n    for (Tree tree : trainingBatch) {\r\n      wrapper.put(tree);\r\n    }\r\n    wrapper.join();\r\n    scoreTiming.done();\r\n    while (wrapper.peek()) {\r\n      Pair<DeepTree, DeepTree> result = wrapper.poll();\r\n      DeepTree goldTree = result.first;\r\n      DeepTree bestTree = result.second;\r\n\r\n      StringBuilder treeDebugLine = new StringBuilder();\r\n      Formatter formatter = new Formatter(treeDebugLine);\r\n      boolean isDone = (Math.abs(bestTree.getScore() - goldTree.getScore()) <= 0.00001 || goldTree.getScore() > bestTree.getScore());\r\n      String done = isDone ? \"done\" : \"\";\r\n      formatter.format(\"Tree %6d Highest tree: %12.4f Correct tree: %12.4f %s\", treeNum, bestTree.getScore(), goldTree.getScore(), done);\r\n      System.err.println(treeDebugLine.toString());\r\n      if (!isDone){\r\n        // if the gold tree is better than the best hypothesis tree by\r\n        // a large enough margin, then the score difference will be 0\r\n        // and we ignore the tree\r\n\r\n        double valueDelta = bestTree.getScore() - goldTree.getScore();\r\n        //double valueDelta = Math.max(0.0, - scoreGold + bestScore);\r\n        localValue += valueDelta;\r\n\r\n        // get the context words for this tree - should be the same\r\n        // for either goldTree or bestTree\r\n        List<String> words = getContextWords(goldTree.getTree());\r\n\r\n        // The derivatives affected by this tree are only based on the\r\n        // nodes present in this tree, eg not all matrix derivatives\r\n        // will be affected by this tree\r\n        backpropDerivative(goldTree.getTree(), words, goldTree.getVectors(),\r\n                           binaryW_dfsG, unaryW_dfsG,\r\n                           binaryScoreDerivativesG, unaryScoreDerivativesG,\r\n                           wordVectorDerivativesG);\r\n\r\n        backpropDerivative(bestTree.getTree(), words, bestTree.getVectors(),\r\n                           binaryW_dfsB, unaryW_dfsB,\r\n                           binaryScoreDerivativesB, unaryScoreDerivativesB,\r\n                           wordVectorDerivativesB);\r\n\r\n      }\r\n      ++treeNum;\r\n    }\r\n\r\n    double[] localDerivativeGood;\r\n    double[] localDerivativeB;\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      localDerivativeGood = DVModel.paramsToVector(theta.length,\r\n                                                   binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                   binaryScoreDerivativesG.valueIterator(),\r\n                                                   unaryScoreDerivativesG.values().iterator(),\r\n                                                   wordVectorDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = DVModel.paramsToVector(theta.length,\r\n                                                binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                binaryScoreDerivativesB.valueIterator(),\r\n                                                unaryScoreDerivativesB.values().iterator(),\r\n                                                wordVectorDerivativesB.values().iterator());\r\n    } else {\r\n      localDerivativeGood = DVModel.paramsToVector(theta.length,\r\n                                                   binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                   binaryScoreDerivativesG.valueIterator(),\r\n                                                   unaryScoreDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = DVModel.paramsToVector(theta.length,\r\n                                                binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                binaryScoreDerivativesB.valueIterator(),\r\n                                                unaryScoreDerivativesB.values().iterator());\r\n    }\r\n\r\n    // correct - highest\r\n    for (int i =0 ;i<localDerivativeGood.length;i++){\r\n      localDerivative[i] = localDerivativeB[i] - localDerivativeGood[i];\r\n    }\r\n\r\n    // TODO: this is where we would combine multiple costs if we had parallelized the calculation\r\n    value = localValue;\r\n    derivative = localDerivative;\r\n\r\n    // normalizing by training batch size\r\n    value = (1.0/trainingBatch.size()) * value;\r\n    ArrayMath.multiplyInPlace(derivative, (1.0/trainingBatch.size()));\r\n\r\n    // add regularization to cost:\r\n    double[] currentParams = dvModel.paramsToVector();\r\n    double regCost = 0;\r\n    for (int i = 0 ; i<currentParams.length;i++){\r\n      regCost += currentParams[i] * currentParams[i];\r\n    }\r\n    regCost = op.trainOptions.regCost * 0.5 * regCost;\r\n    value  += regCost;\r\n    // add regularization to gradient\r\n    ArrayMath.multiplyInPlace(currentParams, op.trainOptions.regCost);\r\n    ArrayMath.pairwiseAddInPlace(derivative, currentParams);\r\n\r\n  }","id":84588,"modified_method":"public void calculate(double[] theta) {\r\n    dvModel.vectorToParams(theta);\r\n\r\n    double localValue = 0.0;\r\n    double[] localDerivative = new double[theta.length];\r\n\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfsG,binaryW_dfsB;\r\n    binaryW_dfsG = TwoDimensionalMap.treeMap();\r\n    binaryW_dfsB = TwoDimensionalMap.treeMap();\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivativesG,binaryScoreDerivativesB ;\r\n    binaryScoreDerivativesG = TwoDimensionalMap.treeMap();\r\n    binaryScoreDerivativesB = TwoDimensionalMap.treeMap();\r\n    Map<String, SimpleMatrix> unaryW_dfsG,unaryW_dfsB ;\r\n    unaryW_dfsG = new TreeMap<String, SimpleMatrix>();\r\n    unaryW_dfsB = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> unaryScoreDerivativesG,unaryScoreDerivativesB ;\r\n    unaryScoreDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    unaryScoreDerivativesB= new TreeMap<String, SimpleMatrix>();\r\n\r\n    Map<String, SimpleMatrix> wordVectorDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> wordVectorDerivativesB = new TreeMap<String, SimpleMatrix>();\r\n\r\n    for (TwoDimensionalMap.Entry<String, String, SimpleMatrix> entry : dvModel.binaryTransform) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      binaryW_dfsG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryW_dfsB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryScoreDerivativesG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n      binaryScoreDerivativesB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    for (Map.Entry<String, SimpleMatrix> entry : dvModel.unaryTransform.entrySet()) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      unaryW_dfsG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryW_dfsB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryScoreDerivativesG.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n      unaryScoreDerivativesB.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      for (Map.Entry<String, SimpleMatrix> entry : dvModel.wordVectors.entrySet()) {\r\n        int numRows = entry.getValue().numRows();\r\n        int numCols = entry.getValue().numCols();\r\n        wordVectorDerivativesG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n        wordVectorDerivativesB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      }\r\n    }\r\n\r\n    // Some optimization methods prints out a line without an end, so our\r\n    // debugging statements are misaligned\r\n    Timing scoreTiming = new Timing();\r\n    scoreTiming.doing(\"Scoring trees\");\r\n    int treeNum = 0;\r\n    MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>> wrapper = new MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>>(op.trainOptions.trainingThreads, new ScoringProcessor());\r\n    for (Tree tree : trainingBatch) {\r\n      wrapper.put(tree);\r\n    }\r\n    wrapper.join();\r\n    scoreTiming.done();\r\n    while (wrapper.peek()) {\r\n      Pair<DeepTree, DeepTree> result = wrapper.poll();\r\n      DeepTree goldTree = result.first;\r\n      DeepTree bestTree = result.second;\r\n\r\n      StringBuilder treeDebugLine = new StringBuilder();\r\n      Formatter formatter = new Formatter(treeDebugLine);\r\n      boolean isDone = (Math.abs(bestTree.getScore() - goldTree.getScore()) <= 0.00001 || goldTree.getScore() > bestTree.getScore());\r\n      String done = isDone ? \"done\" : \"\";\r\n      formatter.format(\"Tree %6d Highest tree: %12.4f Correct tree: %12.4f %s\", treeNum, bestTree.getScore(), goldTree.getScore(), done);\r\n      System.err.println(treeDebugLine.toString());\r\n      if (!isDone){\r\n        // if the gold tree is better than the best hypothesis tree by\r\n        // a large enough margin, then the score difference will be 0\r\n        // and we ignore the tree\r\n\r\n        double valueDelta = bestTree.getScore() - goldTree.getScore();\r\n        //double valueDelta = Math.max(0.0, - scoreGold + bestScore);\r\n        localValue += valueDelta;\r\n\r\n        // get the context words for this tree - should be the same\r\n        // for either goldTree or bestTree\r\n        List<String> words = getContextWords(goldTree.getTree());\r\n\r\n        // The derivatives affected by this tree are only based on the\r\n        // nodes present in this tree, eg not all matrix derivatives\r\n        // will be affected by this tree\r\n        backpropDerivative(goldTree.getTree(), words, goldTree.getVectors(),\r\n                           binaryW_dfsG, unaryW_dfsG,\r\n                           binaryScoreDerivativesG, unaryScoreDerivativesG,\r\n                           wordVectorDerivativesG);\r\n\r\n        backpropDerivative(bestTree.getTree(), words, bestTree.getVectors(),\r\n                           binaryW_dfsB, unaryW_dfsB,\r\n                           binaryScoreDerivativesB, unaryScoreDerivativesB,\r\n                           wordVectorDerivativesB);\r\n\r\n      }\r\n      ++treeNum;\r\n    }\r\n\r\n    double[] localDerivativeGood;\r\n    double[] localDerivativeB;\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      localDerivativeGood = RNNUtils.paramsToVector(theta.length,\r\n                                                    binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                    binaryScoreDerivativesG.valueIterator(),\r\n                                                    unaryScoreDerivativesG.values().iterator(),\r\n                                                    wordVectorDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = RNNUtils.paramsToVector(theta.length,\r\n                                                 binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                 binaryScoreDerivativesB.valueIterator(),\r\n                                                 unaryScoreDerivativesB.values().iterator(),\r\n                                                 wordVectorDerivativesB.values().iterator());\r\n    } else {\r\n      localDerivativeGood = RNNUtils.paramsToVector(theta.length,\r\n                                                    binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                    binaryScoreDerivativesG.valueIterator(),\r\n                                                    unaryScoreDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = RNNUtils.paramsToVector(theta.length,\r\n                                                 binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                 binaryScoreDerivativesB.valueIterator(),\r\n                                                 unaryScoreDerivativesB.values().iterator());\r\n    }\r\n\r\n    // correct - highest\r\n    for (int i =0 ;i<localDerivativeGood.length;i++){\r\n      localDerivative[i] = localDerivativeB[i] - localDerivativeGood[i];\r\n    }\r\n\r\n    // TODO: this is where we would combine multiple costs if we had parallelized the calculation\r\n    value = localValue;\r\n    derivative = localDerivative;\r\n\r\n    // normalizing by training batch size\r\n    value = (1.0/trainingBatch.size()) * value;\r\n    ArrayMath.multiplyInPlace(derivative, (1.0/trainingBatch.size()));\r\n\r\n    // add regularization to cost:\r\n    double[] currentParams = dvModel.paramsToVector();\r\n    double regCost = 0;\r\n    for (int i = 0 ; i<currentParams.length;i++){\r\n      regCost += currentParams[i] * currentParams[i];\r\n    }\r\n    regCost = op.trainOptions.regCost * 0.5 * regCost;\r\n    value  += regCost;\r\n    // add regularization to gradient\r\n    ArrayMath.multiplyInPlace(currentParams, op.trainOptions.regCost);\r\n    ArrayMath.pairwiseAddInPlace(derivative, currentParams);\r\n\r\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private SimpleMatrix concatenateContextWords(SimpleMatrix childVec, IntPair span, List<String> words) {\r\n    // TODO: factor out getting the words\r\n    SimpleMatrix left = (span.getSource() < 0) ? dvModel.getStartWordVector() : dvModel.getWordVector(words.get(span.getSource()));\r\n    SimpleMatrix right = (span.getTarget() >= words.size()) ? dvModel.getEndWordVector() : dvModel.getWordVector(words.get(span.getTarget()));\r\n    return concatenate(childVec, left, right);\r\n  }","id":84589,"modified_method":"private SimpleMatrix concatenateContextWords(SimpleMatrix childVec, IntPair span, List<String> words) {\r\n    // TODO: factor out getting the words\r\n    SimpleMatrix left = (span.getSource() < 0) ? dvModel.getStartWordVector() : dvModel.getWordVector(words.get(span.getSource()));\r\n    SimpleMatrix right = (span.getTarget() >= words.size()) ? dvModel.getEndWordVector() : dvModel.getWordVector(words.get(span.getTarget()));\r\n    return RNNUtils.concatenate(childVec, left, right);\r\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void backpropDerivative(Tree tree, List<String> words,\r\n                                 IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfs,\r\n                                 Map<String, SimpleMatrix> unaryW_dfs,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> unaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> wordVectorDerivatives,\r\n                                 SimpleMatrix deltaUp) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n    if (tree.isPreTerminal()) {\r\n      if (DVModel.TRAIN_WORD_VECTORS) {\r\n        String word = tree.children()[0].label().value();\r\n        word = dvModel.getVocabWord(word);\r\n//        SimpleMatrix currentVector = nodeVectors.get(tree);\r\n//        SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n//        SimpleMatrix derivative = deltaUp.elementMult(currentVectorDerivative);\r\n        SimpleMatrix derivative = deltaUp;\r\n        wordVectorDerivatives.put(word, wordVectorDerivatives.get(word).plus(derivative));\r\n      }\r\n      return;\r\n    }\r\n    SimpleMatrix currentVector = nodeVectors.get(tree);\r\n    SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    currentVectorDerivative = currentVectorDerivative.elementMult(scoreW.transpose());\r\n\r\n    // the delta that is used at the current nodes\r\n    SimpleMatrix deltaCurrent = deltaUp.plus(currentVectorDerivative);\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    SimpleMatrix WTdelta = W.transpose().mult(deltaCurrent);\r\n\r\n    if (tree.children().length == 2) {\r\n      //TODO: RS: Change to the nice \"getWForNode\" setup?\r\n      String leftLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n      String rightLabel = dvModel.basicCategory(tree.children()[1].label().value());\r\n\r\n      binaryScoreDerivatives.put(leftLabel, rightLabel,\r\n                                 binaryScoreDerivatives.get(leftLabel, rightLabel).plus(currentVector.transpose()));\r\n\r\n\r\n      SimpleMatrix leftVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix rightVector = nodeVectors.get(tree.children()[1]);\r\n      SimpleMatrix childrenVector = concatenateWithBias(leftVector, rightVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childrenVector = concatenateContextWords(childrenVector, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childrenVector.transpose());\r\n      binaryW_dfs.put(leftLabel, rightLabel, binaryW_dfs.get(leftLabel, rightLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix leftDerivative = nonlinearityVectorToDerivative(leftVector);\r\n      SimpleMatrix rightDerivative = nonlinearityVectorToDerivative(rightVector);\r\n      SimpleMatrix leftWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      SimpleMatrix rightWTDelta = WTdelta.extractMatrix(deltaCurrent.numRows(), deltaCurrent.numRows() * 2, 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         leftDerivative.elementMult(leftWTDelta));\r\n      backpropDerivative(tree.children()[1], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         rightDerivative.elementMult(rightWTDelta));\r\n    } else if (tree.children().length == 1) {\r\n      String childLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n\r\n      unaryScoreDerivatives.put(childLabel,unaryScoreDerivatives.get(childLabel).plus(currentVector.transpose()));\r\n\r\n      SimpleMatrix childVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix childVectorWithBias = concatenateWithBias(childVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childVectorWithBias = concatenateContextWords(childVectorWithBias, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childVectorWithBias.transpose());\r\n\r\n      // System.out.println(\"unary backprop derivative for \" + childLabel);\r\n      // System.out.println(\"Old transform:\");\r\n      // System.out.println(unaryW_dfs.get(childLabel));\r\n      // System.out.println(\" Delta:\");\r\n      // System.out.println(W_df.scale(scale));\r\n      unaryW_dfs.put(childLabel,unaryW_dfs.get(childLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix childDerivative = nonlinearityVectorToDerivative(childVector);\r\n      //SimpleMatrix childDerivative = childVector;\r\n      SimpleMatrix childWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         childDerivative.elementMult(childWTDelta));\r\n    }\r\n  }","id":84590,"modified_method":"public void backpropDerivative(Tree tree, List<String> words,\r\n                                 IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfs,\r\n                                 Map<String, SimpleMatrix> unaryW_dfs,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> unaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> wordVectorDerivatives,\r\n                                 SimpleMatrix deltaUp) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n    if (tree.isPreTerminal()) {\r\n      if (DVModel.TRAIN_WORD_VECTORS) {\r\n        String word = tree.children()[0].label().value();\r\n        word = dvModel.getVocabWord(word);\r\n//        SimpleMatrix currentVector = nodeVectors.get(tree);\r\n//        SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n//        SimpleMatrix derivative = deltaUp.elementMult(currentVectorDerivative);\r\n        SimpleMatrix derivative = deltaUp;\r\n        wordVectorDerivatives.put(word, wordVectorDerivatives.get(word).plus(derivative));\r\n      }\r\n      return;\r\n    }\r\n    SimpleMatrix currentVector = nodeVectors.get(tree);\r\n    SimpleMatrix currentVectorDerivative = RNNUtils.elementwiseApplyTanhDerivative(currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    currentVectorDerivative = currentVectorDerivative.elementMult(scoreW.transpose());\r\n\r\n    // the delta that is used at the current nodes\r\n    SimpleMatrix deltaCurrent = deltaUp.plus(currentVectorDerivative);\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    SimpleMatrix WTdelta = W.transpose().mult(deltaCurrent);\r\n\r\n    if (tree.children().length == 2) {\r\n      //TODO: RS: Change to the nice \"getWForNode\" setup?\r\n      String leftLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n      String rightLabel = dvModel.basicCategory(tree.children()[1].label().value());\r\n\r\n      binaryScoreDerivatives.put(leftLabel, rightLabel,\r\n                                 binaryScoreDerivatives.get(leftLabel, rightLabel).plus(currentVector.transpose()));\r\n\r\n\r\n      SimpleMatrix leftVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix rightVector = nodeVectors.get(tree.children()[1]);\r\n      SimpleMatrix childrenVector = RNNUtils.concatenateWithBias(leftVector, rightVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childrenVector = concatenateContextWords(childrenVector, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childrenVector.transpose());\r\n      binaryW_dfs.put(leftLabel, rightLabel, binaryW_dfs.get(leftLabel, rightLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix leftDerivative = RNNUtils.elementwiseApplyTanhDerivative(leftVector);\r\n      SimpleMatrix rightDerivative = RNNUtils.elementwiseApplyTanhDerivative(rightVector);\r\n      SimpleMatrix leftWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      SimpleMatrix rightWTDelta = WTdelta.extractMatrix(deltaCurrent.numRows(), deltaCurrent.numRows() * 2, 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         leftDerivative.elementMult(leftWTDelta));\r\n      backpropDerivative(tree.children()[1], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         rightDerivative.elementMult(rightWTDelta));\r\n    } else if (tree.children().length == 1) {\r\n      String childLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n\r\n      unaryScoreDerivatives.put(childLabel,unaryScoreDerivatives.get(childLabel).plus(currentVector.transpose()));\r\n\r\n      SimpleMatrix childVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix childVectorWithBias = RNNUtils.concatenateWithBias(childVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childVectorWithBias = concatenateContextWords(childVectorWithBias, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childVectorWithBias.transpose());\r\n\r\n      // System.out.println(\"unary backprop derivative for \" + childLabel);\r\n      // System.out.println(\"Old transform:\");\r\n      // System.out.println(unaryW_dfs.get(childLabel));\r\n      // System.out.println(\" Delta:\");\r\n      // System.out.println(W_df.scale(scale));\r\n      unaryW_dfs.put(childLabel,unaryW_dfs.get(childLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix childDerivative = RNNUtils.elementwiseApplyTanhDerivative(childVector);\r\n      //SimpleMatrix childDerivative = childVector;\r\n      SimpleMatrix childWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         childDerivative.elementMult(childWTDelta));\r\n    }\r\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void forwardPropagateTree(Tree tree, List<String> words,\r\n                                    IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                    IdentityHashMap<Tree, Double> scores) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n\r\n    if (tree.isPreTerminal()) {\r\n      Tree wordNode = tree.children()[0];\r\n      String word = wordNode.label().value();\r\n      SimpleMatrix wordVector = dvModel.getWordVector(word);\r\n      wordVector = elementwiseApplyNonlinearity(wordVector);\r\n      nodeVectors.put(tree, wordVector);\r\n      return;\r\n    }\r\n\r\n    for (Tree child : tree.children()) {\r\n      forwardPropagateTree(child, words, nodeVectors, scores);\r\n    }\r\n\r\n    // at this point, nodeVectors contains the vectors for all of\r\n    // the children of tree\r\n\r\n    SimpleMatrix childVec;\r\n    if (tree.children().length == 2) {\r\n      childVec = concatenateWithBias(nodeVectors.get(tree.children()[0]), nodeVectors.get(tree.children()[1]));\r\n    } else {\r\n      childVec = concatenateWithBias(nodeVectors.get(tree.children()[0]));\r\n    }\r\n    if (op.trainOptions.useContextWords) {\r\n      childVec = concatenateContextWords(childVec, tree.getSpan(), words);\r\n    }\r\n\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    if (W == null) {\r\n      String error = \"Could not find W for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    SimpleMatrix currentVector = W.mult(childVec);\r\n    currentVector = elementwiseApplyNonlinearity(currentVector);\r\n    nodeVectors.put(tree, currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    if (scoreW == null) {\r\n      String error = \"Could not find scoreW for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    double score = scoreW.dot(currentVector);\r\n    //score = sigmoid(score);\r\n    scores.put(tree, score);\r\n    //System.err.print(Double.toString(score)+\" \");\r\n  }","id":84591,"modified_method":"private void forwardPropagateTree(Tree tree, List<String> words,\r\n                                    IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                    IdentityHashMap<Tree, Double> scores) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n\r\n    if (tree.isPreTerminal()) {\r\n      Tree wordNode = tree.children()[0];\r\n      String word = wordNode.label().value();\r\n      SimpleMatrix wordVector = dvModel.getWordVector(word);\r\n      wordVector = RNNUtils.elementwiseApplyTanh(wordVector);\r\n      nodeVectors.put(tree, wordVector);\r\n      return;\r\n    }\r\n\r\n    for (Tree child : tree.children()) {\r\n      forwardPropagateTree(child, words, nodeVectors, scores);\r\n    }\r\n\r\n    // at this point, nodeVectors contains the vectors for all of\r\n    // the children of tree\r\n\r\n    SimpleMatrix childVec;\r\n    if (tree.children().length == 2) {\r\n      childVec = RNNUtils.concatenateWithBias(nodeVectors.get(tree.children()[0]), nodeVectors.get(tree.children()[1]));\r\n    } else {\r\n      childVec = RNNUtils.concatenateWithBias(nodeVectors.get(tree.children()[0]));\r\n    }\r\n    if (op.trainOptions.useContextWords) {\r\n      childVec = concatenateContextWords(childVec, tree.getSpan(), words);\r\n    }\r\n\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    if (W == null) {\r\n      String error = \"Could not find W for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    SimpleMatrix currentVector = W.mult(childVec);\r\n    currentVector = RNNUtils.elementwiseApplyTanh(currentVector);\r\n    nodeVectors.put(tree, currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    if (scoreW == null) {\r\n      String error = \"Could not find scoreW for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    double score = scoreW.dot(currentVector);\r\n    //score = RNNUtils.sigmoid(score);\r\n    scores.put(tree, score);\r\n    //System.err.print(Double.toString(score)+\" \");\r\n  }","commit_id":"609d4f898d579312f48c1ffd878b918c46507cb4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    System.err.println(\"Reading in the word vector file: \" + op.lexOptions.wordVectorFile);\n    int dimOfWords = 0;\n    boolean warned = false;\n    for (String line : IOUtils.readLines(op.lexOptions.wordVectorFile, \"utf-8\")) {\n      String[]  lineSplit = line.split(\"\\\\s+\");\n      String word = lineSplit[0];\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n      dimOfWords = lineSplit.length - 1;\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = dimOfWords;\n        System.err.println(\"Dimensionality of numHid not set.  The length of the word vectors in the given file appears to be \" + dimOfWords);\n      }\n      // the first entry is the word itself\n      // the other entries will all be entries in the word vector\n      if (dimOfWords > op.lexOptions.numHid) {\n        if (!warned) {\n          warned = true;\n          System.err.println(\"WARNING: Dimensionality of numHid parameter and word vectors do not match, deleting word vector dimensions to fit!\");\n        }\n        dimOfWords = op.lexOptions.numHid;\n      } else if (dimOfWords < op.lexOptions.numHid) {\n        throw new RuntimeException(\"Word vectors file has dimension too small for requested numHid of \" + op.lexOptions.numHid);\n      }\n      double vec[][] = new double[dimOfWords][1];\n      for (int i = 1; i <= dimOfWords; i++) {\n        vec[i-1][0] = Double.parseDouble(lineSplit[i]);\n      }\n      SimpleMatrix vector = new SimpleMatrix(vec);\n      wordVectors.put(word, vector);\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","id":84592,"modified_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.lexOptions.wordVectorFile, op.lexOptions.numHid);\n\n    for (String word : rawWordVectors.keySet()) {\n      SimpleMatrix vector = rawWordVectors.get(word);\n\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = vector.getNumElements();\n      }\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public void vectorToParams(double[] theta) {\n    if (TRAIN_WORD_VECTORS) {\n      vectorToParams(theta,\n                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                     wordVectors.values().iterator());\n    } else {\n      vectorToParams(theta,\n                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84593,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public void vectorToParams(double[] theta) {\n    if (TRAIN_WORD_VECTORS) {\n      RNNUtils.vectorToParams(theta,\n                              binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                              binaryScore.valueIterator(), unaryScore.values().iterator(),\n                              wordVectors.values().iterator());\n    } else {\n      RNNUtils.vectorToParams(theta,\n                              binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                              binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector(double scale) {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return paramsToVector(scale, totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator(),\n                            wordVectors.values().iterator());\n    } else {\n      return paramsToVector(scale, totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84594,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector(double scale) {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return RNNUtils.paramsToVector(scale, totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                                     wordVectors.values().iterator());\n    } else {\n      return RNNUtils.paramsToVector(scale, totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector() {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return paramsToVector(totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator(),\n                            wordVectors.values().iterator());\n    } else {\n      return paramsToVector(totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84595,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector() {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return RNNUtils.paramsToVector(totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                                     wordVectors.values().iterator());\n    } else {\n      return RNNUtils.paramsToVector(totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void calculate(double[] theta) {\r\n    dvModel.vectorToParams(theta);\r\n\r\n    double localValue = 0.0;\r\n    double[] localDerivative = new double[theta.length];\r\n\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfsG,binaryW_dfsB;\r\n    binaryW_dfsG = TwoDimensionalMap.treeMap();\r\n    binaryW_dfsB = TwoDimensionalMap.treeMap();\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivativesG,binaryScoreDerivativesB ;\r\n    binaryScoreDerivativesG = TwoDimensionalMap.treeMap();\r\n    binaryScoreDerivativesB = TwoDimensionalMap.treeMap();\r\n    Map<String, SimpleMatrix> unaryW_dfsG,unaryW_dfsB ;\r\n    unaryW_dfsG = new TreeMap<String, SimpleMatrix>();\r\n    unaryW_dfsB = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> unaryScoreDerivativesG,unaryScoreDerivativesB ;\r\n    unaryScoreDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    unaryScoreDerivativesB= new TreeMap<String, SimpleMatrix>();\r\n\r\n    Map<String, SimpleMatrix> wordVectorDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> wordVectorDerivativesB = new TreeMap<String, SimpleMatrix>();\r\n\r\n    for (TwoDimensionalMap.Entry<String, String, SimpleMatrix> entry : dvModel.binaryTransform) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      binaryW_dfsG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryW_dfsB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryScoreDerivativesG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n      binaryScoreDerivativesB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    for (Map.Entry<String, SimpleMatrix> entry : dvModel.unaryTransform.entrySet()) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      unaryW_dfsG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryW_dfsB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryScoreDerivativesG.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n      unaryScoreDerivativesB.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      for (Map.Entry<String, SimpleMatrix> entry : dvModel.wordVectors.entrySet()) {\r\n        int numRows = entry.getValue().numRows();\r\n        int numCols = entry.getValue().numCols();\r\n        wordVectorDerivativesG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n        wordVectorDerivativesB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      }\r\n    }\r\n\r\n    // Some optimization methods prints out a line without an end, so our\r\n    // debugging statements are misaligned\r\n    Timing scoreTiming = new Timing();\r\n    scoreTiming.doing(\"Scoring trees\");\r\n    int treeNum = 0;\r\n    MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>> wrapper = new MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>>(op.trainOptions.trainingThreads, new ScoringProcessor());\r\n    for (Tree tree : trainingBatch) {\r\n      wrapper.put(tree);\r\n    }\r\n    wrapper.join();\r\n    scoreTiming.done();\r\n    while (wrapper.peek()) {\r\n      Pair<DeepTree, DeepTree> result = wrapper.poll();\r\n      DeepTree goldTree = result.first;\r\n      DeepTree bestTree = result.second;\r\n\r\n      StringBuilder treeDebugLine = new StringBuilder();\r\n      Formatter formatter = new Formatter(treeDebugLine);\r\n      boolean isDone = (Math.abs(bestTree.getScore() - goldTree.getScore()) <= 0.00001 || goldTree.getScore() > bestTree.getScore());\r\n      String done = isDone ? \"done\" : \"\";\r\n      formatter.format(\"Tree %6d Highest tree: %12.4f Correct tree: %12.4f %s\", treeNum, bestTree.getScore(), goldTree.getScore(), done);\r\n      System.err.println(treeDebugLine.toString());\r\n      if (!isDone){\r\n        // if the gold tree is better than the best hypothesis tree by\r\n        // a large enough margin, then the score difference will be 0\r\n        // and we ignore the tree\r\n\r\n        double valueDelta = bestTree.getScore() - goldTree.getScore();\r\n        //double valueDelta = Math.max(0.0, - scoreGold + bestScore);\r\n        localValue += valueDelta;\r\n\r\n        // get the context words for this tree - should be the same\r\n        // for either goldTree or bestTree\r\n        List<String> words = getContextWords(goldTree.getTree());\r\n\r\n        // The derivatives affected by this tree are only based on the\r\n        // nodes present in this tree, eg not all matrix derivatives\r\n        // will be affected by this tree\r\n        backpropDerivative(goldTree.getTree(), words, goldTree.getVectors(),\r\n                           binaryW_dfsG, unaryW_dfsG,\r\n                           binaryScoreDerivativesG, unaryScoreDerivativesG,\r\n                           wordVectorDerivativesG);\r\n\r\n        backpropDerivative(bestTree.getTree(), words, bestTree.getVectors(),\r\n                           binaryW_dfsB, unaryW_dfsB,\r\n                           binaryScoreDerivativesB, unaryScoreDerivativesB,\r\n                           wordVectorDerivativesB);\r\n\r\n      }\r\n      ++treeNum;\r\n    }\r\n\r\n    double[] localDerivativeGood;\r\n    double[] localDerivativeB;\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      localDerivativeGood = DVModel.paramsToVector(theta.length,\r\n                                                   binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                   binaryScoreDerivativesG.valueIterator(),\r\n                                                   unaryScoreDerivativesG.values().iterator(),\r\n                                                   wordVectorDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = DVModel.paramsToVector(theta.length,\r\n                                                binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                binaryScoreDerivativesB.valueIterator(),\r\n                                                unaryScoreDerivativesB.values().iterator(),\r\n                                                wordVectorDerivativesB.values().iterator());\r\n    } else {\r\n      localDerivativeGood = DVModel.paramsToVector(theta.length,\r\n                                                   binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                   binaryScoreDerivativesG.valueIterator(),\r\n                                                   unaryScoreDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = DVModel.paramsToVector(theta.length,\r\n                                                binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                binaryScoreDerivativesB.valueIterator(),\r\n                                                unaryScoreDerivativesB.values().iterator());\r\n    }\r\n\r\n    // correct - highest\r\n    for (int i =0 ;i<localDerivativeGood.length;i++){\r\n      localDerivative[i] = localDerivativeB[i] - localDerivativeGood[i];\r\n    }\r\n\r\n    // TODO: this is where we would combine multiple costs if we had parallelized the calculation\r\n    value = localValue;\r\n    derivative = localDerivative;\r\n\r\n    // normalizing by training batch size\r\n    value = (1.0/trainingBatch.size()) * value;\r\n    ArrayMath.multiplyInPlace(derivative, (1.0/trainingBatch.size()));\r\n\r\n    // add regularization to cost:\r\n    double[] currentParams = dvModel.paramsToVector();\r\n    double regCost = 0;\r\n    for (int i = 0 ; i<currentParams.length;i++){\r\n      regCost += currentParams[i] * currentParams[i];\r\n    }\r\n    regCost = op.trainOptions.regCost * 0.5 * regCost;\r\n    value  += regCost;\r\n    // add regularization to gradient\r\n    ArrayMath.multiplyInPlace(currentParams, op.trainOptions.regCost);\r\n    ArrayMath.pairwiseAddInPlace(derivative, currentParams);\r\n\r\n  }","id":84596,"modified_method":"public void calculate(double[] theta) {\r\n    dvModel.vectorToParams(theta);\r\n\r\n    double localValue = 0.0;\r\n    double[] localDerivative = new double[theta.length];\r\n\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfsG,binaryW_dfsB;\r\n    binaryW_dfsG = TwoDimensionalMap.treeMap();\r\n    binaryW_dfsB = TwoDimensionalMap.treeMap();\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivativesG,binaryScoreDerivativesB ;\r\n    binaryScoreDerivativesG = TwoDimensionalMap.treeMap();\r\n    binaryScoreDerivativesB = TwoDimensionalMap.treeMap();\r\n    Map<String, SimpleMatrix> unaryW_dfsG,unaryW_dfsB ;\r\n    unaryW_dfsG = new TreeMap<String, SimpleMatrix>();\r\n    unaryW_dfsB = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> unaryScoreDerivativesG,unaryScoreDerivativesB ;\r\n    unaryScoreDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    unaryScoreDerivativesB= new TreeMap<String, SimpleMatrix>();\r\n\r\n    Map<String, SimpleMatrix> wordVectorDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> wordVectorDerivativesB = new TreeMap<String, SimpleMatrix>();\r\n\r\n    for (TwoDimensionalMap.Entry<String, String, SimpleMatrix> entry : dvModel.binaryTransform) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      binaryW_dfsG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryW_dfsB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryScoreDerivativesG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n      binaryScoreDerivativesB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    for (Map.Entry<String, SimpleMatrix> entry : dvModel.unaryTransform.entrySet()) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      unaryW_dfsG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryW_dfsB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryScoreDerivativesG.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n      unaryScoreDerivativesB.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      for (Map.Entry<String, SimpleMatrix> entry : dvModel.wordVectors.entrySet()) {\r\n        int numRows = entry.getValue().numRows();\r\n        int numCols = entry.getValue().numCols();\r\n        wordVectorDerivativesG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n        wordVectorDerivativesB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      }\r\n    }\r\n\r\n    // Some optimization methods prints out a line without an end, so our\r\n    // debugging statements are misaligned\r\n    Timing scoreTiming = new Timing();\r\n    scoreTiming.doing(\"Scoring trees\");\r\n    int treeNum = 0;\r\n    MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>> wrapper = new MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>>(op.trainOptions.trainingThreads, new ScoringProcessor());\r\n    for (Tree tree : trainingBatch) {\r\n      wrapper.put(tree);\r\n    }\r\n    wrapper.join();\r\n    scoreTiming.done();\r\n    while (wrapper.peek()) {\r\n      Pair<DeepTree, DeepTree> result = wrapper.poll();\r\n      DeepTree goldTree = result.first;\r\n      DeepTree bestTree = result.second;\r\n\r\n      StringBuilder treeDebugLine = new StringBuilder();\r\n      Formatter formatter = new Formatter(treeDebugLine);\r\n      boolean isDone = (Math.abs(bestTree.getScore() - goldTree.getScore()) <= 0.00001 || goldTree.getScore() > bestTree.getScore());\r\n      String done = isDone ? \"done\" : \"\";\r\n      formatter.format(\"Tree %6d Highest tree: %12.4f Correct tree: %12.4f %s\", treeNum, bestTree.getScore(), goldTree.getScore(), done);\r\n      System.err.println(treeDebugLine.toString());\r\n      if (!isDone){\r\n        // if the gold tree is better than the best hypothesis tree by\r\n        // a large enough margin, then the score difference will be 0\r\n        // and we ignore the tree\r\n\r\n        double valueDelta = bestTree.getScore() - goldTree.getScore();\r\n        //double valueDelta = Math.max(0.0, - scoreGold + bestScore);\r\n        localValue += valueDelta;\r\n\r\n        // get the context words for this tree - should be the same\r\n        // for either goldTree or bestTree\r\n        List<String> words = getContextWords(goldTree.getTree());\r\n\r\n        // The derivatives affected by this tree are only based on the\r\n        // nodes present in this tree, eg not all matrix derivatives\r\n        // will be affected by this tree\r\n        backpropDerivative(goldTree.getTree(), words, goldTree.getVectors(),\r\n                           binaryW_dfsG, unaryW_dfsG,\r\n                           binaryScoreDerivativesG, unaryScoreDerivativesG,\r\n                           wordVectorDerivativesG);\r\n\r\n        backpropDerivative(bestTree.getTree(), words, bestTree.getVectors(),\r\n                           binaryW_dfsB, unaryW_dfsB,\r\n                           binaryScoreDerivativesB, unaryScoreDerivativesB,\r\n                           wordVectorDerivativesB);\r\n\r\n      }\r\n      ++treeNum;\r\n    }\r\n\r\n    double[] localDerivativeGood;\r\n    double[] localDerivativeB;\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      localDerivativeGood = RNNUtils.paramsToVector(theta.length,\r\n                                                    binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                    binaryScoreDerivativesG.valueIterator(),\r\n                                                    unaryScoreDerivativesG.values().iterator(),\r\n                                                    wordVectorDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = RNNUtils.paramsToVector(theta.length,\r\n                                                 binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                 binaryScoreDerivativesB.valueIterator(),\r\n                                                 unaryScoreDerivativesB.values().iterator(),\r\n                                                 wordVectorDerivativesB.values().iterator());\r\n    } else {\r\n      localDerivativeGood = RNNUtils.paramsToVector(theta.length,\r\n                                                    binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                    binaryScoreDerivativesG.valueIterator(),\r\n                                                    unaryScoreDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = RNNUtils.paramsToVector(theta.length,\r\n                                                 binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                 binaryScoreDerivativesB.valueIterator(),\r\n                                                 unaryScoreDerivativesB.values().iterator());\r\n    }\r\n\r\n    // correct - highest\r\n    for (int i =0 ;i<localDerivativeGood.length;i++){\r\n      localDerivative[i] = localDerivativeB[i] - localDerivativeGood[i];\r\n    }\r\n\r\n    // TODO: this is where we would combine multiple costs if we had parallelized the calculation\r\n    value = localValue;\r\n    derivative = localDerivative;\r\n\r\n    // normalizing by training batch size\r\n    value = (1.0/trainingBatch.size()) * value;\r\n    ArrayMath.multiplyInPlace(derivative, (1.0/trainingBatch.size()));\r\n\r\n    // add regularization to cost:\r\n    double[] currentParams = dvModel.paramsToVector();\r\n    double regCost = 0;\r\n    for (int i = 0 ; i<currentParams.length;i++){\r\n      regCost += currentParams[i] * currentParams[i];\r\n    }\r\n    regCost = op.trainOptions.regCost * 0.5 * regCost;\r\n    value  += regCost;\r\n    // add regularization to gradient\r\n    ArrayMath.multiplyInPlace(currentParams, op.trainOptions.regCost);\r\n    ArrayMath.pairwiseAddInPlace(derivative, currentParams);\r\n\r\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void forwardPropagateTree(Tree tree, List<String> words,\r\n                                    IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                    IdentityHashMap<Tree, Double> scores) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n\r\n    if (tree.isPreTerminal()) {\r\n      Tree wordNode = tree.children()[0];\r\n      String word = wordNode.label().value();\r\n      SimpleMatrix wordVector = dvModel.getWordVector(word);\r\n      wordVector = elementwiseApplyNonlinearity(wordVector);\r\n      nodeVectors.put(tree, wordVector);\r\n      return;\r\n    }\r\n\r\n    for (Tree child : tree.children()) {\r\n      forwardPropagateTree(child, words, nodeVectors, scores);\r\n    }\r\n\r\n    // at this point, nodeVectors contains the vectors for all of\r\n    // the children of tree\r\n\r\n    SimpleMatrix childVec;\r\n    if (tree.children().length == 2) {\r\n      childVec = concatenateWithBias(nodeVectors.get(tree.children()[0]), nodeVectors.get(tree.children()[1]));\r\n    } else {\r\n      childVec = concatenateWithBias(nodeVectors.get(tree.children()[0]));\r\n    }\r\n    if (op.trainOptions.useContextWords) {\r\n      childVec = concatenateContextWords(childVec, tree.getSpan(), words);\r\n    }\r\n\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    if (W == null) {\r\n      String error = \"Could not find W for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    SimpleMatrix currentVector = W.mult(childVec);\r\n    currentVector = elementwiseApplyNonlinearity(currentVector);\r\n    nodeVectors.put(tree, currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    if (scoreW == null) {\r\n      String error = \"Could not find scoreW for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    double score = scoreW.dot(currentVector);\r\n    //score = sigmoid(score);\r\n    scores.put(tree, score);\r\n    //System.err.print(Double.toString(score)+\" \");\r\n  }","id":84597,"modified_method":"private void forwardPropagateTree(Tree tree, List<String> words,\r\n                                    IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                    IdentityHashMap<Tree, Double> scores) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n\r\n    if (tree.isPreTerminal()) {\r\n      Tree wordNode = tree.children()[0];\r\n      String word = wordNode.label().value();\r\n      SimpleMatrix wordVector = dvModel.getWordVector(word);\r\n      wordVector = RNNUtils.elementwiseApplyTanh(wordVector);\r\n      nodeVectors.put(tree, wordVector);\r\n      return;\r\n    }\r\n\r\n    for (Tree child : tree.children()) {\r\n      forwardPropagateTree(child, words, nodeVectors, scores);\r\n    }\r\n\r\n    // at this point, nodeVectors contains the vectors for all of\r\n    // the children of tree\r\n\r\n    SimpleMatrix childVec;\r\n    if (tree.children().length == 2) {\r\n      childVec = RNNUtils.concatenateWithBias(nodeVectors.get(tree.children()[0]), nodeVectors.get(tree.children()[1]));\r\n    } else {\r\n      childVec = RNNUtils.concatenateWithBias(nodeVectors.get(tree.children()[0]));\r\n    }\r\n    if (op.trainOptions.useContextWords) {\r\n      childVec = concatenateContextWords(childVec, tree.getSpan(), words);\r\n    }\r\n\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    if (W == null) {\r\n      String error = \"Could not find W for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    SimpleMatrix currentVector = W.mult(childVec);\r\n    currentVector = RNNUtils.elementwiseApplyTanh(currentVector);\r\n    nodeVectors.put(tree, currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    if (scoreW == null) {\r\n      String error = \"Could not find scoreW for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    double score = scoreW.dot(currentVector);\r\n    //score = RNNUtils.sigmoid(score);\r\n    scores.put(tree, score);\r\n    //System.err.print(Double.toString(score)+\" \");\r\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private SimpleMatrix concatenateContextWords(SimpleMatrix childVec, IntPair span, List<String> words) {\r\n    // TODO: factor out getting the words\r\n    SimpleMatrix left = (span.getSource() < 0) ? dvModel.getStartWordVector() : dvModel.getWordVector(words.get(span.getSource()));\r\n    SimpleMatrix right = (span.getTarget() >= words.size()) ? dvModel.getEndWordVector() : dvModel.getWordVector(words.get(span.getTarget()));\r\n    return concatenate(childVec, left, right);\r\n  }","id":84598,"modified_method":"private SimpleMatrix concatenateContextWords(SimpleMatrix childVec, IntPair span, List<String> words) {\r\n    // TODO: factor out getting the words\r\n    SimpleMatrix left = (span.getSource() < 0) ? dvModel.getStartWordVector() : dvModel.getWordVector(words.get(span.getSource()));\r\n    SimpleMatrix right = (span.getTarget() >= words.size()) ? dvModel.getEndWordVector() : dvModel.getWordVector(words.get(span.getTarget()));\r\n    return RNNUtils.concatenate(childVec, left, right);\r\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void backpropDerivative(Tree tree, List<String> words,\r\n                                 IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfs,\r\n                                 Map<String, SimpleMatrix> unaryW_dfs,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> unaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> wordVectorDerivatives,\r\n                                 SimpleMatrix deltaUp) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n    if (tree.isPreTerminal()) {\r\n      if (DVModel.TRAIN_WORD_VECTORS) {\r\n        String word = tree.children()[0].label().value();\r\n        word = dvModel.getVocabWord(word);\r\n//        SimpleMatrix currentVector = nodeVectors.get(tree);\r\n//        SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n//        SimpleMatrix derivative = deltaUp.elementMult(currentVectorDerivative);\r\n        SimpleMatrix derivative = deltaUp;\r\n        wordVectorDerivatives.put(word, wordVectorDerivatives.get(word).plus(derivative));\r\n      }\r\n      return;\r\n    }\r\n    SimpleMatrix currentVector = nodeVectors.get(tree);\r\n    SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    currentVectorDerivative = currentVectorDerivative.elementMult(scoreW.transpose());\r\n\r\n    // the delta that is used at the current nodes\r\n    SimpleMatrix deltaCurrent = deltaUp.plus(currentVectorDerivative);\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    SimpleMatrix WTdelta = W.transpose().mult(deltaCurrent);\r\n\r\n    if (tree.children().length == 2) {\r\n      //TODO: RS: Change to the nice \"getWForNode\" setup?\r\n      String leftLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n      String rightLabel = dvModel.basicCategory(tree.children()[1].label().value());\r\n\r\n      binaryScoreDerivatives.put(leftLabel, rightLabel,\r\n                                 binaryScoreDerivatives.get(leftLabel, rightLabel).plus(currentVector.transpose()));\r\n\r\n\r\n      SimpleMatrix leftVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix rightVector = nodeVectors.get(tree.children()[1]);\r\n      SimpleMatrix childrenVector = concatenateWithBias(leftVector, rightVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childrenVector = concatenateContextWords(childrenVector, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childrenVector.transpose());\r\n      binaryW_dfs.put(leftLabel, rightLabel, binaryW_dfs.get(leftLabel, rightLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix leftDerivative = nonlinearityVectorToDerivative(leftVector);\r\n      SimpleMatrix rightDerivative = nonlinearityVectorToDerivative(rightVector);\r\n      SimpleMatrix leftWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      SimpleMatrix rightWTDelta = WTdelta.extractMatrix(deltaCurrent.numRows(), deltaCurrent.numRows() * 2, 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         leftDerivative.elementMult(leftWTDelta));\r\n      backpropDerivative(tree.children()[1], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         rightDerivative.elementMult(rightWTDelta));\r\n    } else if (tree.children().length == 1) {\r\n      String childLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n\r\n      unaryScoreDerivatives.put(childLabel,unaryScoreDerivatives.get(childLabel).plus(currentVector.transpose()));\r\n\r\n      SimpleMatrix childVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix childVectorWithBias = concatenateWithBias(childVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childVectorWithBias = concatenateContextWords(childVectorWithBias, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childVectorWithBias.transpose());\r\n\r\n      // System.out.println(\"unary backprop derivative for \" + childLabel);\r\n      // System.out.println(\"Old transform:\");\r\n      // System.out.println(unaryW_dfs.get(childLabel));\r\n      // System.out.println(\" Delta:\");\r\n      // System.out.println(W_df.scale(scale));\r\n      unaryW_dfs.put(childLabel,unaryW_dfs.get(childLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix childDerivative = nonlinearityVectorToDerivative(childVector);\r\n      //SimpleMatrix childDerivative = childVector;\r\n      SimpleMatrix childWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         childDerivative.elementMult(childWTDelta));\r\n    }\r\n  }","id":84599,"modified_method":"public void backpropDerivative(Tree tree, List<String> words,\r\n                                 IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfs,\r\n                                 Map<String, SimpleMatrix> unaryW_dfs,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> unaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> wordVectorDerivatives,\r\n                                 SimpleMatrix deltaUp) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n    if (tree.isPreTerminal()) {\r\n      if (DVModel.TRAIN_WORD_VECTORS) {\r\n        String word = tree.children()[0].label().value();\r\n        word = dvModel.getVocabWord(word);\r\n//        SimpleMatrix currentVector = nodeVectors.get(tree);\r\n//        SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n//        SimpleMatrix derivative = deltaUp.elementMult(currentVectorDerivative);\r\n        SimpleMatrix derivative = deltaUp;\r\n        wordVectorDerivatives.put(word, wordVectorDerivatives.get(word).plus(derivative));\r\n      }\r\n      return;\r\n    }\r\n    SimpleMatrix currentVector = nodeVectors.get(tree);\r\n    SimpleMatrix currentVectorDerivative = RNNUtils.elementwiseApplyTanhDerivative(currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    currentVectorDerivative = currentVectorDerivative.elementMult(scoreW.transpose());\r\n\r\n    // the delta that is used at the current nodes\r\n    SimpleMatrix deltaCurrent = deltaUp.plus(currentVectorDerivative);\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    SimpleMatrix WTdelta = W.transpose().mult(deltaCurrent);\r\n\r\n    if (tree.children().length == 2) {\r\n      //TODO: RS: Change to the nice \"getWForNode\" setup?\r\n      String leftLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n      String rightLabel = dvModel.basicCategory(tree.children()[1].label().value());\r\n\r\n      binaryScoreDerivatives.put(leftLabel, rightLabel,\r\n                                 binaryScoreDerivatives.get(leftLabel, rightLabel).plus(currentVector.transpose()));\r\n\r\n\r\n      SimpleMatrix leftVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix rightVector = nodeVectors.get(tree.children()[1]);\r\n      SimpleMatrix childrenVector = RNNUtils.concatenateWithBias(leftVector, rightVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childrenVector = concatenateContextWords(childrenVector, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childrenVector.transpose());\r\n      binaryW_dfs.put(leftLabel, rightLabel, binaryW_dfs.get(leftLabel, rightLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix leftDerivative = RNNUtils.elementwiseApplyTanhDerivative(leftVector);\r\n      SimpleMatrix rightDerivative = RNNUtils.elementwiseApplyTanhDerivative(rightVector);\r\n      SimpleMatrix leftWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      SimpleMatrix rightWTDelta = WTdelta.extractMatrix(deltaCurrent.numRows(), deltaCurrent.numRows() * 2, 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         leftDerivative.elementMult(leftWTDelta));\r\n      backpropDerivative(tree.children()[1], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         rightDerivative.elementMult(rightWTDelta));\r\n    } else if (tree.children().length == 1) {\r\n      String childLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n\r\n      unaryScoreDerivatives.put(childLabel,unaryScoreDerivatives.get(childLabel).plus(currentVector.transpose()));\r\n\r\n      SimpleMatrix childVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix childVectorWithBias = RNNUtils.concatenateWithBias(childVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childVectorWithBias = concatenateContextWords(childVectorWithBias, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childVectorWithBias.transpose());\r\n\r\n      // System.out.println(\"unary backprop derivative for \" + childLabel);\r\n      // System.out.println(\"Old transform:\");\r\n      // System.out.println(unaryW_dfs.get(childLabel));\r\n      // System.out.println(\" Delta:\");\r\n      // System.out.println(W_df.scale(scale));\r\n      unaryW_dfs.put(childLabel,unaryW_dfs.get(childLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix childDerivative = RNNUtils.elementwiseApplyTanhDerivative(childVector);\r\n      //SimpleMatrix childDerivative = childVector;\r\n      SimpleMatrix childWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         childDerivative.elementMult(childWTDelta));\r\n    }\r\n  }","commit_id":"e24884b3820083745e6eb71200e5805193bc84bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    System.err.println(\"Reading in the word vector file: \" + op.lexOptions.wordVectorFile);\n    int dimOfWords = 0;\n    boolean warned = false;\n    for (String line : IOUtils.readLines(op.lexOptions.wordVectorFile, \"utf-8\")) {\n      String[]  lineSplit = line.split(\"\\\\s+\");\n      String word = lineSplit[0];\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n      dimOfWords = lineSplit.length - 1;\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = dimOfWords;\n        System.err.println(\"Dimensionality of numHid not set.  The length of the word vectors in the given file appears to be \" + dimOfWords);\n      }\n      // the first entry is the word itself\n      // the other entries will all be entries in the word vector\n      if (dimOfWords > op.lexOptions.numHid) {\n        if (!warned) {\n          warned = true;\n          System.err.println(\"WARNING: Dimensionality of numHid parameter and word vectors do not match, deleting word vector dimensions to fit!\");\n        }\n        dimOfWords = op.lexOptions.numHid;\n      } else if (dimOfWords < op.lexOptions.numHid) {\n        throw new RuntimeException(\"Word vectors file has dimension too small for requested numHid of \" + op.lexOptions.numHid);\n      }\n      double vec[][] = new double[dimOfWords][1];\n      for (int i = 1; i <= dimOfWords; i++) {\n        vec[i-1][0] = Double.parseDouble(lineSplit[i]);\n      }\n      SimpleMatrix vector = new SimpleMatrix(vec);\n      wordVectors.put(word, vector);\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","id":84600,"modified_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.lexOptions.wordVectorFile, op.lexOptions.numHid);\n\n    for (String word : rawWordVectors.keySet()) {\n      SimpleMatrix vector = rawWordVectors.get(word);\n\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = vector.getNumElements();\n      }\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","commit_id":"1c07c3d38bc8aa873075799f9d4ba59075dd8f9a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public SentimentModel(Options op, TwoDimensionalSet<String, String> binaryProductions) {\n    this.op = op;\n    rand = (op.randomSeed != 0) ? new Random(op.randomSeed) : new Random(); \n\n    // TODO: extract this from the word vector file\n    this.numHid = op.numHid;\n    readWordVectors();\n    identity = SimpleMatrix.identity(numHid);\n\n    binaryTransform = TwoDimensionalMap.treeMap();\n    binaryClassification = TwoDimensionalMap.treeMap();\n    \n    // When making a flat model (no symantic untying) the\n    // basicCategory function will return the same basic category for\n    // all labels, so all entries will map to the same matrix\n    for (Pair<String, String> binary : binaryProductions) {\n      String left = basicCategory(binary.first);\n      String right = basicCategory(binary.second);\n      if (binaryTransform.get(left, right) == null) {\n        continue;\n      }\n      binaryTransform.put(left, right, randomTransformMatrix());\n      binaryClassification.put(left, right, randomClassificationMatrix());\n    }\n    numBinaryMatrices = binaryTransform.size();\n    binaryTransformSize = numHid * (2 * numHid + 1);\n    binaryClassificationSize = numClasses * (numHid + 1);\n  }","id":84601,"modified_method":"public SentimentModel(Options op, TwoDimensionalSet<String, String> binaryProductions) {\n    this.op = op;\n    rand = (op.randomSeed != 0) ? new Random(op.randomSeed) : new Random(); \n\n    readWordVectors();\n    if (op.numHid > 0) {\n      this.numHid = op.numHid;\n    } else {\n      int size = 0;\n      for (SimpleMatrix vector : wordVectors.values()) {\n        size = vector.getNumElements();\n        break;\n      }\n      this.numHid = size;\n    }\n    identity = SimpleMatrix.identity(numHid);\n\n    binaryTransform = TwoDimensionalMap.treeMap();\n    binaryClassification = TwoDimensionalMap.treeMap();\n    \n    // When making a flat model (no symantic untying) the\n    // basicCategory function will return the same basic category for\n    // all labels, so all entries will map to the same matrix\n    for (Pair<String, String> binary : binaryProductions) {\n      String left = basicCategory(binary.first);\n      String right = basicCategory(binary.second);\n      if (binaryTransform.get(left, right) == null) {\n        continue;\n      }\n      binaryTransform.put(left, right, randomTransformMatrix());\n      binaryClassification.put(left, right, randomClassificationMatrix());\n    }\n    numBinaryMatrices = binaryTransform.size();\n    binaryTransformSize = numHid * (2 * numHid + 1);\n    binaryClassificationSize = numClasses * (numHid + 1);\n  }","commit_id":"1c07c3d38bc8aa873075799f9d4ba59075dd8f9a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"void readWordVectors() {\n    // TODO: this needs to be factored out from DVModel\n  }","id":84602,"modified_method":"void readWordVectors() {\n    this.wordVectors = Generics.newTreeMap();\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.wordVectors, op.numHid);\n    for (String word : rawWordVectors.keySet()) {\n      // TODO: factor out unknown word vector code from DVParser\n      wordVectors.put(word, rawWordVectors.get(word));\n    }\n\n    String unkWord = op.unkWord;\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n  }","commit_id":"1c07c3d38bc8aa873075799f9d4ba59075dd8f9a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String getVocabWord(String word) {\n    if (op.lowercaseWordVectors) {\n      word = word.toLowerCase();\n    }\n    if (wordVectors.containsKey(word)) {\n      return word;\n    }\n    // TODO: go through unknown words here\n    return null;\n  }","id":84603,"modified_method":"public String getVocabWord(String word) {\n    if (op.lowercaseWordVectors) {\n      word = word.toLowerCase();\n    }\n    if (wordVectors.containsKey(word)) {\n      return word;\n    }\n    // TODO: go through unknown words here\n    return UNKNOWN_WORD;\n  }","commit_id":"1c07c3d38bc8aa873075799f9d4ba59075dd8f9a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    System.err.println(\"Reading in the word vector file: \" + op.lexOptions.wordVectorFile);\n    int dimOfWords = 0;\n    boolean warned = false;\n    for (String line : IOUtils.readLines(op.lexOptions.wordVectorFile, \"utf-8\")) {\n      String[]  lineSplit = line.split(\"\\\\s+\");\n      String word = lineSplit[0];\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n      dimOfWords = lineSplit.length - 1;\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = dimOfWords;\n        System.err.println(\"Dimensionality of numHid not set.  The length of the word vectors in the given file appears to be \" + dimOfWords);\n      }\n      // the first entry is the word itself\n      // the other entries will all be entries in the word vector\n      if (dimOfWords > op.lexOptions.numHid) {\n        if (!warned) {\n          warned = true;\n          System.err.println(\"WARNING: Dimensionality of numHid parameter and word vectors do not match, deleting word vector dimensions to fit!\");\n        }\n        dimOfWords = op.lexOptions.numHid;\n      } else if (dimOfWords < op.lexOptions.numHid) {\n        throw new RuntimeException(\"Word vectors file has dimension too small for requested numHid of \" + op.lexOptions.numHid);\n      }\n      double vec[][] = new double[dimOfWords][1];\n      for (int i = 1; i <= dimOfWords; i++) {\n        vec[i-1][0] = Double.parseDouble(lineSplit[i]);\n      }\n      SimpleMatrix vector = new SimpleMatrix(vec);\n      wordVectors.put(word, vector);\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","id":84604,"modified_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.lexOptions.wordVectorFile, op.lexOptions.numHid);\n\n    for (String word : rawWordVectors.keySet()) {\n      SimpleMatrix vector = rawWordVectors.get(word);\n\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = vector.getNumElements();\n      }\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","commit_id":"97191a2350a150082003303c1b944a1bf076e036","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"void readWordVectors() {\n    // TODO: this needs to be factored out from DVModel\n  }","id":84605,"modified_method":"void readWordVectors() {\n    this.wordVectors = Generics.newTreeMap();\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.wordVectors, op.numHid);\n    for (String word : rawWordVectors.keySet()) {\n      // TODO: factor out unknown word vector code from DVParser\n      wordVectors.put(word, rawWordVectors.get(word));\n    }\n\n    String unkWord = op.unkWord;\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n  }","commit_id":"97191a2350a150082003303c1b944a1bf076e036","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String getVocabWord(String word) {\n    if (op.lowercaseWordVectors) {\n      word = word.toLowerCase();\n    }\n    if (wordVectors.containsKey(word)) {\n      return word;\n    }\n    // TODO: go through unknown words here\n    return null;\n  }","id":84606,"modified_method":"public String getVocabWord(String word) {\n    if (op.lowercaseWordVectors) {\n      word = word.toLowerCase();\n    }\n    if (wordVectors.containsKey(word)) {\n      return word;\n    }\n    // TODO: go through unknown words here\n    return UNKNOWN_WORD;\n  }","commit_id":"97191a2350a150082003303c1b944a1bf076e036","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public SentimentModel(Options op, TwoDimensionalSet<String, String> binaryProductions) {\n    this.op = op;\n    rand = (op.randomSeed != 0) ? new Random(op.randomSeed) : new Random(); \n\n    // TODO: extract this from the word vector file\n    this.numHid = op.numHid;\n    readWordVectors();\n    identity = SimpleMatrix.identity(numHid);\n\n    binaryTransform = TwoDimensionalMap.treeMap();\n    binaryClassification = TwoDimensionalMap.treeMap();\n    \n    // When making a flat model (no symantic untying) the\n    // basicCategory function will return the same basic category for\n    // all labels, so all entries will map to the same matrix\n    for (Pair<String, String> binary : binaryProductions) {\n      String left = basicCategory(binary.first);\n      String right = basicCategory(binary.second);\n      if (binaryTransform.get(left, right) == null) {\n        continue;\n      }\n      binaryTransform.put(left, right, randomTransformMatrix());\n      binaryClassification.put(left, right, randomClassificationMatrix());\n    }\n    numBinaryMatrices = binaryTransform.size();\n    binaryTransformSize = numHid * (2 * numHid + 1);\n    binaryClassificationSize = numClasses * (numHid + 1);\n  }","id":84607,"modified_method":"public SentimentModel(Options op, TwoDimensionalSet<String, String> binaryProductions) {\n    this.op = op;\n    rand = (op.randomSeed != 0) ? new Random(op.randomSeed) : new Random(); \n\n    readWordVectors();\n    if (op.numHid > 0) {\n      this.numHid = op.numHid;\n    } else {\n      int size = 0;\n      for (SimpleMatrix vector : wordVectors.values()) {\n        size = vector.getNumElements();\n        break;\n      }\n      this.numHid = size;\n    }\n    identity = SimpleMatrix.identity(numHid);\n\n    binaryTransform = TwoDimensionalMap.treeMap();\n    binaryClassification = TwoDimensionalMap.treeMap();\n    \n    // When making a flat model (no symantic untying) the\n    // basicCategory function will return the same basic category for\n    // all labels, so all entries will map to the same matrix\n    for (Pair<String, String> binary : binaryProductions) {\n      String left = basicCategory(binary.first);\n      String right = basicCategory(binary.second);\n      if (binaryTransform.get(left, right) == null) {\n        continue;\n      }\n      binaryTransform.put(left, right, randomTransformMatrix());\n      binaryClassification.put(left, right, randomClassificationMatrix());\n    }\n    numBinaryMatrices = binaryTransform.size();\n    binaryTransformSize = numHid * (2 * numHid + 1);\n    binaryClassificationSize = numClasses * (numHid + 1);\n  }","commit_id":"97191a2350a150082003303c1b944a1bf076e036","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public void vectorToParams(double[] theta) {\n    if (TRAIN_WORD_VECTORS) {\n      vectorToParams(theta,\n                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                     wordVectors.values().iterator());\n    } else {\n      vectorToParams(theta,\n                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84608,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public void vectorToParams(double[] theta) {\n    if (TRAIN_WORD_VECTORS) {\n      RNNUtils.vectorToParams(theta,\n                              binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                              binaryScore.valueIterator(), unaryScore.values().iterator(),\n                              wordVectors.values().iterator());\n    } else {\n      RNNUtils.vectorToParams(theta,\n                              binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                              binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector(double scale) {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return paramsToVector(scale, totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator(),\n                            wordVectors.values().iterator());\n    } else {\n      return paramsToVector(scale, totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84609,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector(double scale) {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return RNNUtils.paramsToVector(scale, totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                                     wordVectors.values().iterator());\n    } else {\n      return RNNUtils.paramsToVector(scale, totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector() {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return paramsToVector(totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator(),\n                            wordVectors.values().iterator());\n    } else {\n      return paramsToVector(totalSize,\n                            binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                            binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","id":84610,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public double[] paramsToVector() {\n    int totalSize = totalParamSize();\n    if (TRAIN_WORD_VECTORS) {\n      return RNNUtils.paramsToVector(totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator(),\n                                     wordVectors.values().iterator());\n    } else {\n      return RNNUtils.paramsToVector(totalSize,\n                                     binaryTransform.valueIterator(), unaryTransform.values().iterator(),\n                                     binaryScore.valueIterator(), unaryScore.values().iterator());\n    }\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    System.err.println(\"Reading in the word vector file: \" + op.lexOptions.wordVectorFile);\n    int dimOfWords = 0;\n    boolean warned = false;\n    for (String line : IOUtils.readLines(op.lexOptions.wordVectorFile, \"utf-8\")) {\n      String[]  lineSplit = line.split(\"\\\\s+\");\n      String word = lineSplit[0];\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n      dimOfWords = lineSplit.length - 1;\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = dimOfWords;\n        System.err.println(\"Dimensionality of numHid not set.  The length of the word vectors in the given file appears to be \" + dimOfWords);\n      }\n      // the first entry is the word itself\n      // the other entries will all be entries in the word vector\n      if (dimOfWords > op.lexOptions.numHid) {\n        if (!warned) {\n          warned = true;\n          System.err.println(\"WARNING: Dimensionality of numHid parameter and word vectors do not match, deleting word vector dimensions to fit!\");\n        }\n        dimOfWords = op.lexOptions.numHid;\n      } else if (dimOfWords < op.lexOptions.numHid) {\n        throw new RuntimeException(\"Word vectors file has dimension too small for requested numHid of \" + op.lexOptions.numHid);\n      }\n      double vec[][] = new double[dimOfWords][1];\n      for (int i = 1; i <= dimOfWords; i++) {\n        vec[i-1][0] = Double.parseDouble(lineSplit[i]);\n      }\n      SimpleMatrix vector = new SimpleMatrix(vec);\n      wordVectors.put(word, vector);\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","id":84611,"modified_method":"public void readWordVectors() {\n    SimpleMatrix unknownNumberVector = null;\n    SimpleMatrix unknownCapsVector = null;\n    SimpleMatrix unknownChineseYearVector = null;\n    SimpleMatrix unknownChineseNumberVector = null;\n    SimpleMatrix unknownChinesePercentVector = null;\n\n    wordVectors = Generics.newTreeMap();\n    int numberCount = 0;\n    int capsCount = 0;\n    int chineseYearCount = 0;\n    int chineseNumberCount = 0;\n    int chinesePercentCount = 0;\n\n    Map<String, SimpleMatrix> rawWordVectors = RNNUtils.readRawWordVectors(op.lexOptions.wordVectorFile, op.lexOptions.numHid);\n\n    for (String word : rawWordVectors.keySet()) {\n      SimpleMatrix vector = rawWordVectors.get(word);\n\n      if (op.wordFunction != null) {\n        word = op.wordFunction.apply(word);\n      }\n\n      if (op.lexOptions.numHid <= 0) {\n        op.lexOptions.numHid = vector.getNumElements();\n      }\n\n      // TODO: factor out all of these identical blobs\n      if (op.trainOptions.unknownNumberVector &&\n          (NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++numberCount;\n        if (unknownNumberVector == null) {\n          unknownNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownNumberVector = unknownNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownCapsVector && CAPS_PATTERN.matcher(word).matches()) {\n        ++capsCount;\n        if (unknownCapsVector == null) {\n          unknownCapsVector = new SimpleMatrix(vector);\n        } else {\n          unknownCapsVector = unknownCapsVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseYearVector && CHINESE_YEAR_PATTERN.matcher(word).matches()) {\n        ++chineseYearCount;\n        if (unknownChineseYearVector == null) {\n          unknownChineseYearVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseYearVector = unknownChineseYearVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChineseNumberVector &&\n          (CHINESE_NUMBER_PATTERN.matcher(word).matches() || DG_PATTERN.matcher(word).matches())) {\n        ++chineseNumberCount;\n        if (unknownChineseNumberVector == null) {\n          unknownChineseNumberVector = new SimpleMatrix(vector);\n        } else {\n          unknownChineseNumberVector = unknownChineseNumberVector.plus(vector);\n        }\n      }\n\n      if (op.trainOptions.unknownChinesePercentVector && CHINESE_PERCENT_PATTERN.matcher(word).matches()) {\n        ++chinesePercentCount;\n        if (unknownChinesePercentVector == null) {\n          unknownChinesePercentVector = new SimpleMatrix(vector);\n        } else {\n          unknownChinesePercentVector = unknownChinesePercentVector.plus(vector);\n        }\n      }\n    }\n\n    String unkWord = op.trainOptions.unkWord;\n    if (op.wordFunction != null) {\n      unkWord = op.wordFunction.apply(unkWord);\n    }\n    SimpleMatrix unknownWordVector = wordVectors.get(unkWord);\n    wordVectors.put(UNKNOWN_WORD, unknownWordVector);\n    if (unknownWordVector == null) {\n      throw new RuntimeException(\"Unknown word vector not specified in the word vector file\");\n    }\n\n    if (op.trainOptions.unknownNumberVector) {\n      if (numberCount > 0) {\n        unknownNumberVector = unknownNumberVector.divide(numberCount);\n      } else {\n        unknownNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_NUMBER, unknownNumberVector);\n    }\n\n    if (op.trainOptions.unknownCapsVector) {\n      if (capsCount > 0) {\n        unknownCapsVector = unknownCapsVector.divide(capsCount);\n      } else {\n        unknownCapsVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CAPS, unknownCapsVector);\n    }\n\n    if (op.trainOptions.unknownChineseYearVector) {\n      System.err.println(\"Matched \" + chineseYearCount + \" chinese year vectors\");\n      if (chineseYearCount > 0) {\n        unknownChineseYearVector = unknownChineseYearVector.divide(chineseYearCount);\n      } else {\n        unknownChineseYearVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_YEAR, unknownChineseYearVector);\n    }\n\n    if (op.trainOptions.unknownChineseNumberVector) {\n      System.err.println(\"Matched \" + chineseNumberCount + \" chinese number vectors\");\n      if (chineseNumberCount > 0) {\n        unknownChineseNumberVector = unknownChineseNumberVector.divide(chineseNumberCount);\n      } else {\n        unknownChineseNumberVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_NUMBER, unknownChineseNumberVector);\n    }\n\n    if (op.trainOptions.unknownChinesePercentVector) {\n      System.err.println(\"Matched \" + chinesePercentCount + \" chinese percent vectors\");\n      if (chinesePercentCount > 0) {\n        unknownChinesePercentVector = unknownChinesePercentVector.divide(chinesePercentCount);\n      } else {\n        unknownChinesePercentVector = new SimpleMatrix(unknownWordVector);\n      }\n      wordVectors.put(UNKNOWN_CHINESE_PERCENT, unknownChinesePercentVector);\n    }\n\n    if (op.trainOptions.useContextWords) {\n      SimpleMatrix start = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      SimpleMatrix end = SimpleMatrix.random(op.lexOptions.numHid, 1, -0.5, 0.5, rand);\n      wordVectors.put(START_WORD, start);\n      wordVectors.put(END_WORD, end);\n    }\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void backpropDerivative(Tree tree, List<String> words,\r\n                                 IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfs,\r\n                                 Map<String, SimpleMatrix> unaryW_dfs,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> unaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> wordVectorDerivatives,\r\n                                 SimpleMatrix deltaUp) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n    if (tree.isPreTerminal()) {\r\n      if (DVModel.TRAIN_WORD_VECTORS) {\r\n        String word = tree.children()[0].label().value();\r\n        word = dvModel.getVocabWord(word);\r\n//        SimpleMatrix currentVector = nodeVectors.get(tree);\r\n//        SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n//        SimpleMatrix derivative = deltaUp.elementMult(currentVectorDerivative);\r\n        SimpleMatrix derivative = deltaUp;\r\n        wordVectorDerivatives.put(word, wordVectorDerivatives.get(word).plus(derivative));\r\n      }\r\n      return;\r\n    }\r\n    SimpleMatrix currentVector = nodeVectors.get(tree);\r\n    SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    currentVectorDerivative = currentVectorDerivative.elementMult(scoreW.transpose());\r\n\r\n    // the delta that is used at the current nodes\r\n    SimpleMatrix deltaCurrent = deltaUp.plus(currentVectorDerivative);\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    SimpleMatrix WTdelta = W.transpose().mult(deltaCurrent);\r\n\r\n    if (tree.children().length == 2) {\r\n      //TODO: RS: Change to the nice \"getWForNode\" setup?\r\n      String leftLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n      String rightLabel = dvModel.basicCategory(tree.children()[1].label().value());\r\n\r\n      binaryScoreDerivatives.put(leftLabel, rightLabel,\r\n                                 binaryScoreDerivatives.get(leftLabel, rightLabel).plus(currentVector.transpose()));\r\n\r\n\r\n      SimpleMatrix leftVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix rightVector = nodeVectors.get(tree.children()[1]);\r\n      SimpleMatrix childrenVector = concatenateWithBias(leftVector, rightVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childrenVector = concatenateContextWords(childrenVector, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childrenVector.transpose());\r\n      binaryW_dfs.put(leftLabel, rightLabel, binaryW_dfs.get(leftLabel, rightLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix leftDerivative = nonlinearityVectorToDerivative(leftVector);\r\n      SimpleMatrix rightDerivative = nonlinearityVectorToDerivative(rightVector);\r\n      SimpleMatrix leftWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      SimpleMatrix rightWTDelta = WTdelta.extractMatrix(deltaCurrent.numRows(), deltaCurrent.numRows() * 2, 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         leftDerivative.elementMult(leftWTDelta));\r\n      backpropDerivative(tree.children()[1], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         rightDerivative.elementMult(rightWTDelta));\r\n    } else if (tree.children().length == 1) {\r\n      String childLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n\r\n      unaryScoreDerivatives.put(childLabel,unaryScoreDerivatives.get(childLabel).plus(currentVector.transpose()));\r\n\r\n      SimpleMatrix childVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix childVectorWithBias = concatenateWithBias(childVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childVectorWithBias = concatenateContextWords(childVectorWithBias, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childVectorWithBias.transpose());\r\n\r\n      // System.out.println(\"unary backprop derivative for \" + childLabel);\r\n      // System.out.println(\"Old transform:\");\r\n      // System.out.println(unaryW_dfs.get(childLabel));\r\n      // System.out.println(\" Delta:\");\r\n      // System.out.println(W_df.scale(scale));\r\n      unaryW_dfs.put(childLabel,unaryW_dfs.get(childLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix childDerivative = nonlinearityVectorToDerivative(childVector);\r\n      //SimpleMatrix childDerivative = childVector;\r\n      SimpleMatrix childWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         childDerivative.elementMult(childWTDelta));\r\n    }\r\n  }","id":84612,"modified_method":"public void backpropDerivative(Tree tree, List<String> words,\r\n                                 IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfs,\r\n                                 Map<String, SimpleMatrix> unaryW_dfs,\r\n                                 TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> unaryScoreDerivatives,\r\n                                 Map<String, SimpleMatrix> wordVectorDerivatives,\r\n                                 SimpleMatrix deltaUp) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n    if (tree.isPreTerminal()) {\r\n      if (DVModel.TRAIN_WORD_VECTORS) {\r\n        String word = tree.children()[0].label().value();\r\n        word = dvModel.getVocabWord(word);\r\n//        SimpleMatrix currentVector = nodeVectors.get(tree);\r\n//        SimpleMatrix currentVectorDerivative = nonlinearityVectorToDerivative(currentVector);\r\n//        SimpleMatrix derivative = deltaUp.elementMult(currentVectorDerivative);\r\n        SimpleMatrix derivative = deltaUp;\r\n        wordVectorDerivatives.put(word, wordVectorDerivatives.get(word).plus(derivative));\r\n      }\r\n      return;\r\n    }\r\n    SimpleMatrix currentVector = nodeVectors.get(tree);\r\n    SimpleMatrix currentVectorDerivative = RNNUtils.elementwiseApplyTanhDerivative(currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    currentVectorDerivative = currentVectorDerivative.elementMult(scoreW.transpose());\r\n\r\n    // the delta that is used at the current nodes\r\n    SimpleMatrix deltaCurrent = deltaUp.plus(currentVectorDerivative);\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    SimpleMatrix WTdelta = W.transpose().mult(deltaCurrent);\r\n\r\n    if (tree.children().length == 2) {\r\n      //TODO: RS: Change to the nice \"getWForNode\" setup?\r\n      String leftLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n      String rightLabel = dvModel.basicCategory(tree.children()[1].label().value());\r\n\r\n      binaryScoreDerivatives.put(leftLabel, rightLabel,\r\n                                 binaryScoreDerivatives.get(leftLabel, rightLabel).plus(currentVector.transpose()));\r\n\r\n\r\n      SimpleMatrix leftVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix rightVector = nodeVectors.get(tree.children()[1]);\r\n      SimpleMatrix childrenVector = RNNUtils.concatenateWithBias(leftVector, rightVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childrenVector = concatenateContextWords(childrenVector, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childrenVector.transpose());\r\n      binaryW_dfs.put(leftLabel, rightLabel, binaryW_dfs.get(leftLabel, rightLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix leftDerivative = RNNUtils.elementwiseApplyTanhDerivative(leftVector);\r\n      SimpleMatrix rightDerivative = RNNUtils.elementwiseApplyTanhDerivative(rightVector);\r\n      SimpleMatrix leftWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      SimpleMatrix rightWTDelta = WTdelta.extractMatrix(deltaCurrent.numRows(), deltaCurrent.numRows() * 2, 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         leftDerivative.elementMult(leftWTDelta));\r\n      backpropDerivative(tree.children()[1], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         rightDerivative.elementMult(rightWTDelta));\r\n    } else if (tree.children().length == 1) {\r\n      String childLabel = dvModel.basicCategory(tree.children()[0].label().value());\r\n\r\n      unaryScoreDerivatives.put(childLabel,unaryScoreDerivatives.get(childLabel).plus(currentVector.transpose()));\r\n\r\n      SimpleMatrix childVector = nodeVectors.get(tree.children()[0]);\r\n      SimpleMatrix childVectorWithBias = RNNUtils.concatenateWithBias(childVector);\r\n      if (op.trainOptions.useContextWords) {\r\n        childVectorWithBias = concatenateContextWords(childVectorWithBias, tree.getSpan(), words);\r\n      }\r\n      SimpleMatrix W_df = deltaCurrent.mult(childVectorWithBias.transpose());\r\n\r\n      // System.out.println(\"unary backprop derivative for \" + childLabel);\r\n      // System.out.println(\"Old transform:\");\r\n      // System.out.println(unaryW_dfs.get(childLabel));\r\n      // System.out.println(\" Delta:\");\r\n      // System.out.println(W_df.scale(scale));\r\n      unaryW_dfs.put(childLabel,unaryW_dfs.get(childLabel).plus(W_df));\r\n\r\n      // and then recurse\r\n      SimpleMatrix childDerivative = RNNUtils.elementwiseApplyTanhDerivative(childVector);\r\n      //SimpleMatrix childDerivative = childVector;\r\n      SimpleMatrix childWTDelta = WTdelta.extractMatrix(0, deltaCurrent.numRows(), 0, 1);\r\n      backpropDerivative(tree.children()[0], words, nodeVectors,\r\n                         binaryW_dfs, unaryW_dfs,\r\n                         binaryScoreDerivatives, unaryScoreDerivatives, wordVectorDerivatives,\r\n                         childDerivative.elementMult(childWTDelta));\r\n    }\r\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void calculate(double[] theta) {\r\n    dvModel.vectorToParams(theta);\r\n\r\n    double localValue = 0.0;\r\n    double[] localDerivative = new double[theta.length];\r\n\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfsG,binaryW_dfsB;\r\n    binaryW_dfsG = TwoDimensionalMap.treeMap();\r\n    binaryW_dfsB = TwoDimensionalMap.treeMap();\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivativesG,binaryScoreDerivativesB ;\r\n    binaryScoreDerivativesG = TwoDimensionalMap.treeMap();\r\n    binaryScoreDerivativesB = TwoDimensionalMap.treeMap();\r\n    Map<String, SimpleMatrix> unaryW_dfsG,unaryW_dfsB ;\r\n    unaryW_dfsG = new TreeMap<String, SimpleMatrix>();\r\n    unaryW_dfsB = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> unaryScoreDerivativesG,unaryScoreDerivativesB ;\r\n    unaryScoreDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    unaryScoreDerivativesB= new TreeMap<String, SimpleMatrix>();\r\n\r\n    Map<String, SimpleMatrix> wordVectorDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> wordVectorDerivativesB = new TreeMap<String, SimpleMatrix>();\r\n\r\n    for (TwoDimensionalMap.Entry<String, String, SimpleMatrix> entry : dvModel.binaryTransform) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      binaryW_dfsG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryW_dfsB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryScoreDerivativesG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n      binaryScoreDerivativesB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    for (Map.Entry<String, SimpleMatrix> entry : dvModel.unaryTransform.entrySet()) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      unaryW_dfsG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryW_dfsB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryScoreDerivativesG.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n      unaryScoreDerivativesB.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      for (Map.Entry<String, SimpleMatrix> entry : dvModel.wordVectors.entrySet()) {\r\n        int numRows = entry.getValue().numRows();\r\n        int numCols = entry.getValue().numCols();\r\n        wordVectorDerivativesG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n        wordVectorDerivativesB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      }\r\n    }\r\n\r\n    // Some optimization methods prints out a line without an end, so our\r\n    // debugging statements are misaligned\r\n    Timing scoreTiming = new Timing();\r\n    scoreTiming.doing(\"Scoring trees\");\r\n    int treeNum = 0;\r\n    MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>> wrapper = new MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>>(op.trainOptions.trainingThreads, new ScoringProcessor());\r\n    for (Tree tree : trainingBatch) {\r\n      wrapper.put(tree);\r\n    }\r\n    wrapper.join();\r\n    scoreTiming.done();\r\n    while (wrapper.peek()) {\r\n      Pair<DeepTree, DeepTree> result = wrapper.poll();\r\n      DeepTree goldTree = result.first;\r\n      DeepTree bestTree = result.second;\r\n\r\n      StringBuilder treeDebugLine = new StringBuilder();\r\n      Formatter formatter = new Formatter(treeDebugLine);\r\n      boolean isDone = (Math.abs(bestTree.getScore() - goldTree.getScore()) <= 0.00001 || goldTree.getScore() > bestTree.getScore());\r\n      String done = isDone ? \"done\" : \"\";\r\n      formatter.format(\"Tree %6d Highest tree: %12.4f Correct tree: %12.4f %s\", treeNum, bestTree.getScore(), goldTree.getScore(), done);\r\n      System.err.println(treeDebugLine.toString());\r\n      if (!isDone){\r\n        // if the gold tree is better than the best hypothesis tree by\r\n        // a large enough margin, then the score difference will be 0\r\n        // and we ignore the tree\r\n\r\n        double valueDelta = bestTree.getScore() - goldTree.getScore();\r\n        //double valueDelta = Math.max(0.0, - scoreGold + bestScore);\r\n        localValue += valueDelta;\r\n\r\n        // get the context words for this tree - should be the same\r\n        // for either goldTree or bestTree\r\n        List<String> words = getContextWords(goldTree.getTree());\r\n\r\n        // The derivatives affected by this tree are only based on the\r\n        // nodes present in this tree, eg not all matrix derivatives\r\n        // will be affected by this tree\r\n        backpropDerivative(goldTree.getTree(), words, goldTree.getVectors(),\r\n                           binaryW_dfsG, unaryW_dfsG,\r\n                           binaryScoreDerivativesG, unaryScoreDerivativesG,\r\n                           wordVectorDerivativesG);\r\n\r\n        backpropDerivative(bestTree.getTree(), words, bestTree.getVectors(),\r\n                           binaryW_dfsB, unaryW_dfsB,\r\n                           binaryScoreDerivativesB, unaryScoreDerivativesB,\r\n                           wordVectorDerivativesB);\r\n\r\n      }\r\n      ++treeNum;\r\n    }\r\n\r\n    double[] localDerivativeGood;\r\n    double[] localDerivativeB;\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      localDerivativeGood = DVModel.paramsToVector(theta.length,\r\n                                                   binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                   binaryScoreDerivativesG.valueIterator(),\r\n                                                   unaryScoreDerivativesG.values().iterator(),\r\n                                                   wordVectorDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = DVModel.paramsToVector(theta.length,\r\n                                                binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                binaryScoreDerivativesB.valueIterator(),\r\n                                                unaryScoreDerivativesB.values().iterator(),\r\n                                                wordVectorDerivativesB.values().iterator());\r\n    } else {\r\n      localDerivativeGood = DVModel.paramsToVector(theta.length,\r\n                                                   binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                   binaryScoreDerivativesG.valueIterator(),\r\n                                                   unaryScoreDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = DVModel.paramsToVector(theta.length,\r\n                                                binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                binaryScoreDerivativesB.valueIterator(),\r\n                                                unaryScoreDerivativesB.values().iterator());\r\n    }\r\n\r\n    // correct - highest\r\n    for (int i =0 ;i<localDerivativeGood.length;i++){\r\n      localDerivative[i] = localDerivativeB[i] - localDerivativeGood[i];\r\n    }\r\n\r\n    // TODO: this is where we would combine multiple costs if we had parallelized the calculation\r\n    value = localValue;\r\n    derivative = localDerivative;\r\n\r\n    // normalizing by training batch size\r\n    value = (1.0/trainingBatch.size()) * value;\r\n    ArrayMath.multiplyInPlace(derivative, (1.0/trainingBatch.size()));\r\n\r\n    // add regularization to cost:\r\n    double[] currentParams = dvModel.paramsToVector();\r\n    double regCost = 0;\r\n    for (int i = 0 ; i<currentParams.length;i++){\r\n      regCost += currentParams[i] * currentParams[i];\r\n    }\r\n    regCost = op.trainOptions.regCost * 0.5 * regCost;\r\n    value  += regCost;\r\n    // add regularization to gradient\r\n    ArrayMath.multiplyInPlace(currentParams, op.trainOptions.regCost);\r\n    ArrayMath.pairwiseAddInPlace(derivative, currentParams);\r\n\r\n  }","id":84613,"modified_method":"public void calculate(double[] theta) {\r\n    dvModel.vectorToParams(theta);\r\n\r\n    double localValue = 0.0;\r\n    double[] localDerivative = new double[theta.length];\r\n\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryW_dfsG,binaryW_dfsB;\r\n    binaryW_dfsG = TwoDimensionalMap.treeMap();\r\n    binaryW_dfsB = TwoDimensionalMap.treeMap();\r\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreDerivativesG,binaryScoreDerivativesB ;\r\n    binaryScoreDerivativesG = TwoDimensionalMap.treeMap();\r\n    binaryScoreDerivativesB = TwoDimensionalMap.treeMap();\r\n    Map<String, SimpleMatrix> unaryW_dfsG,unaryW_dfsB ;\r\n    unaryW_dfsG = new TreeMap<String, SimpleMatrix>();\r\n    unaryW_dfsB = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> unaryScoreDerivativesG,unaryScoreDerivativesB ;\r\n    unaryScoreDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    unaryScoreDerivativesB= new TreeMap<String, SimpleMatrix>();\r\n\r\n    Map<String, SimpleMatrix> wordVectorDerivativesG = new TreeMap<String, SimpleMatrix>();\r\n    Map<String, SimpleMatrix> wordVectorDerivativesB = new TreeMap<String, SimpleMatrix>();\r\n\r\n    for (TwoDimensionalMap.Entry<String, String, SimpleMatrix> entry : dvModel.binaryTransform) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      binaryW_dfsG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryW_dfsB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(numRows, numCols));\r\n      binaryScoreDerivativesG.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n      binaryScoreDerivativesB.put(entry.getFirstKey(), entry.getSecondKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    for (Map.Entry<String, SimpleMatrix> entry : dvModel.unaryTransform.entrySet()) {\r\n      int numRows = entry.getValue().numRows();\r\n      int numCols = entry.getValue().numCols();\r\n      unaryW_dfsG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryW_dfsB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      unaryScoreDerivativesG.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n      unaryScoreDerivativesB.put(entry.getKey(), new SimpleMatrix(1, numRows));\r\n    }\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      for (Map.Entry<String, SimpleMatrix> entry : dvModel.wordVectors.entrySet()) {\r\n        int numRows = entry.getValue().numRows();\r\n        int numCols = entry.getValue().numCols();\r\n        wordVectorDerivativesG.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n        wordVectorDerivativesB.put(entry.getKey(), new SimpleMatrix(numRows, numCols));\r\n      }\r\n    }\r\n\r\n    // Some optimization methods prints out a line without an end, so our\r\n    // debugging statements are misaligned\r\n    Timing scoreTiming = new Timing();\r\n    scoreTiming.doing(\"Scoring trees\");\r\n    int treeNum = 0;\r\n    MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>> wrapper = new MulticoreWrapper<Tree, Pair<DeepTree, DeepTree>>(op.trainOptions.trainingThreads, new ScoringProcessor());\r\n    for (Tree tree : trainingBatch) {\r\n      wrapper.put(tree);\r\n    }\r\n    wrapper.join();\r\n    scoreTiming.done();\r\n    while (wrapper.peek()) {\r\n      Pair<DeepTree, DeepTree> result = wrapper.poll();\r\n      DeepTree goldTree = result.first;\r\n      DeepTree bestTree = result.second;\r\n\r\n      StringBuilder treeDebugLine = new StringBuilder();\r\n      Formatter formatter = new Formatter(treeDebugLine);\r\n      boolean isDone = (Math.abs(bestTree.getScore() - goldTree.getScore()) <= 0.00001 || goldTree.getScore() > bestTree.getScore());\r\n      String done = isDone ? \"done\" : \"\";\r\n      formatter.format(\"Tree %6d Highest tree: %12.4f Correct tree: %12.4f %s\", treeNum, bestTree.getScore(), goldTree.getScore(), done);\r\n      System.err.println(treeDebugLine.toString());\r\n      if (!isDone){\r\n        // if the gold tree is better than the best hypothesis tree by\r\n        // a large enough margin, then the score difference will be 0\r\n        // and we ignore the tree\r\n\r\n        double valueDelta = bestTree.getScore() - goldTree.getScore();\r\n        //double valueDelta = Math.max(0.0, - scoreGold + bestScore);\r\n        localValue += valueDelta;\r\n\r\n        // get the context words for this tree - should be the same\r\n        // for either goldTree or bestTree\r\n        List<String> words = getContextWords(goldTree.getTree());\r\n\r\n        // The derivatives affected by this tree are only based on the\r\n        // nodes present in this tree, eg not all matrix derivatives\r\n        // will be affected by this tree\r\n        backpropDerivative(goldTree.getTree(), words, goldTree.getVectors(),\r\n                           binaryW_dfsG, unaryW_dfsG,\r\n                           binaryScoreDerivativesG, unaryScoreDerivativesG,\r\n                           wordVectorDerivativesG);\r\n\r\n        backpropDerivative(bestTree.getTree(), words, bestTree.getVectors(),\r\n                           binaryW_dfsB, unaryW_dfsB,\r\n                           binaryScoreDerivativesB, unaryScoreDerivativesB,\r\n                           wordVectorDerivativesB);\r\n\r\n      }\r\n      ++treeNum;\r\n    }\r\n\r\n    double[] localDerivativeGood;\r\n    double[] localDerivativeB;\r\n    if (DVModel.TRAIN_WORD_VECTORS) {\r\n      localDerivativeGood = RNNUtils.paramsToVector(theta.length,\r\n                                                    binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                    binaryScoreDerivativesG.valueIterator(),\r\n                                                    unaryScoreDerivativesG.values().iterator(),\r\n                                                    wordVectorDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = RNNUtils.paramsToVector(theta.length,\r\n                                                 binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                 binaryScoreDerivativesB.valueIterator(),\r\n                                                 unaryScoreDerivativesB.values().iterator(),\r\n                                                 wordVectorDerivativesB.values().iterator());\r\n    } else {\r\n      localDerivativeGood = RNNUtils.paramsToVector(theta.length,\r\n                                                    binaryW_dfsG.valueIterator(), unaryW_dfsG.values().iterator(),\r\n                                                    binaryScoreDerivativesG.valueIterator(),\r\n                                                    unaryScoreDerivativesG.values().iterator());\r\n\r\n      localDerivativeB = RNNUtils.paramsToVector(theta.length,\r\n                                                 binaryW_dfsB.valueIterator(), unaryW_dfsB.values().iterator(),\r\n                                                 binaryScoreDerivativesB.valueIterator(),\r\n                                                 unaryScoreDerivativesB.values().iterator());\r\n    }\r\n\r\n    // correct - highest\r\n    for (int i =0 ;i<localDerivativeGood.length;i++){\r\n      localDerivative[i] = localDerivativeB[i] - localDerivativeGood[i];\r\n    }\r\n\r\n    // TODO: this is where we would combine multiple costs if we had parallelized the calculation\r\n    value = localValue;\r\n    derivative = localDerivative;\r\n\r\n    // normalizing by training batch size\r\n    value = (1.0/trainingBatch.size()) * value;\r\n    ArrayMath.multiplyInPlace(derivative, (1.0/trainingBatch.size()));\r\n\r\n    // add regularization to cost:\r\n    double[] currentParams = dvModel.paramsToVector();\r\n    double regCost = 0;\r\n    for (int i = 0 ; i<currentParams.length;i++){\r\n      regCost += currentParams[i] * currentParams[i];\r\n    }\r\n    regCost = op.trainOptions.regCost * 0.5 * regCost;\r\n    value  += regCost;\r\n    // add regularization to gradient\r\n    ArrayMath.multiplyInPlace(currentParams, op.trainOptions.regCost);\r\n    ArrayMath.pairwiseAddInPlace(derivative, currentParams);\r\n\r\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void forwardPropagateTree(Tree tree, List<String> words,\r\n                                    IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                    IdentityHashMap<Tree, Double> scores) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n\r\n    if (tree.isPreTerminal()) {\r\n      Tree wordNode = tree.children()[0];\r\n      String word = wordNode.label().value();\r\n      SimpleMatrix wordVector = dvModel.getWordVector(word);\r\n      wordVector = elementwiseApplyNonlinearity(wordVector);\r\n      nodeVectors.put(tree, wordVector);\r\n      return;\r\n    }\r\n\r\n    for (Tree child : tree.children()) {\r\n      forwardPropagateTree(child, words, nodeVectors, scores);\r\n    }\r\n\r\n    // at this point, nodeVectors contains the vectors for all of\r\n    // the children of tree\r\n\r\n    SimpleMatrix childVec;\r\n    if (tree.children().length == 2) {\r\n      childVec = concatenateWithBias(nodeVectors.get(tree.children()[0]), nodeVectors.get(tree.children()[1]));\r\n    } else {\r\n      childVec = concatenateWithBias(nodeVectors.get(tree.children()[0]));\r\n    }\r\n    if (op.trainOptions.useContextWords) {\r\n      childVec = concatenateContextWords(childVec, tree.getSpan(), words);\r\n    }\r\n\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    if (W == null) {\r\n      String error = \"Could not find W for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    SimpleMatrix currentVector = W.mult(childVec);\r\n    currentVector = elementwiseApplyNonlinearity(currentVector);\r\n    nodeVectors.put(tree, currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    if (scoreW == null) {\r\n      String error = \"Could not find scoreW for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    double score = scoreW.dot(currentVector);\r\n    //score = sigmoid(score);\r\n    scores.put(tree, score);\r\n    //System.err.print(Double.toString(score)+\" \");\r\n  }","id":84614,"modified_method":"private void forwardPropagateTree(Tree tree, List<String> words,\r\n                                    IdentityHashMap<Tree, SimpleMatrix> nodeVectors,\r\n                                    IdentityHashMap<Tree, Double> scores) {\r\n    if (tree.isLeaf()) {\r\n      return;\r\n    }\r\n\r\n    if (tree.isPreTerminal()) {\r\n      Tree wordNode = tree.children()[0];\r\n      String word = wordNode.label().value();\r\n      SimpleMatrix wordVector = dvModel.getWordVector(word);\r\n      wordVector = RNNUtils.elementwiseApplyTanh(wordVector);\r\n      nodeVectors.put(tree, wordVector);\r\n      return;\r\n    }\r\n\r\n    for (Tree child : tree.children()) {\r\n      forwardPropagateTree(child, words, nodeVectors, scores);\r\n    }\r\n\r\n    // at this point, nodeVectors contains the vectors for all of\r\n    // the children of tree\r\n\r\n    SimpleMatrix childVec;\r\n    if (tree.children().length == 2) {\r\n      childVec = RNNUtils.concatenateWithBias(nodeVectors.get(tree.children()[0]), nodeVectors.get(tree.children()[1]));\r\n    } else {\r\n      childVec = RNNUtils.concatenateWithBias(nodeVectors.get(tree.children()[0]));\r\n    }\r\n    if (op.trainOptions.useContextWords) {\r\n      childVec = concatenateContextWords(childVec, tree.getSpan(), words);\r\n    }\r\n\r\n    SimpleMatrix W = dvModel.getWForNode(tree);\r\n    if (W == null) {\r\n      String error = \"Could not find W for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    SimpleMatrix currentVector = W.mult(childVec);\r\n    currentVector = RNNUtils.elementwiseApplyTanh(currentVector);\r\n    nodeVectors.put(tree, currentVector);\r\n\r\n    SimpleMatrix scoreW = dvModel.getScoreWForNode(tree);\r\n    if (scoreW == null) {\r\n      String error = \"Could not find scoreW for tree \" + tree;\r\n      if (op.testOptions.verbose) {\r\n        System.err.println(error);\r\n      }\r\n      throw new NoSuchParseException(error);\r\n    }\r\n    double score = scoreW.dot(currentVector);\r\n    //score = RNNUtils.sigmoid(score);\r\n    scores.put(tree, score);\r\n    //System.err.print(Double.toString(score)+\" \");\r\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private SimpleMatrix concatenateContextWords(SimpleMatrix childVec, IntPair span, List<String> words) {\r\n    // TODO: factor out getting the words\r\n    SimpleMatrix left = (span.getSource() < 0) ? dvModel.getStartWordVector() : dvModel.getWordVector(words.get(span.getSource()));\r\n    SimpleMatrix right = (span.getTarget() >= words.size()) ? dvModel.getEndWordVector() : dvModel.getWordVector(words.get(span.getTarget()));\r\n    return concatenate(childVec, left, right);\r\n  }","id":84615,"modified_method":"private SimpleMatrix concatenateContextWords(SimpleMatrix childVec, IntPair span, List<String> words) {\r\n    // TODO: factor out getting the words\r\n    SimpleMatrix left = (span.getSource() < 0) ? dvModel.getStartWordVector() : dvModel.getWordVector(words.get(span.getSource()));\r\n    SimpleMatrix right = (span.getTarget() >= words.size()) ? dvModel.getEndWordVector() : dvModel.getWordVector(words.get(span.getTarget()));\r\n    return RNNUtils.concatenate(childVec, left, right);\r\n  }","commit_id":"760ae22d815d20c9ddd60de7a82b59040fc7613c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n\t * This method maps OpenNMS alarm to an OSS/J alarms and adds additional information\n\t * @param _openNMSalarm data to use to populate the OSS/J alarm\n\t * @param alarmValueSpecification AlarmValue object to be populated - Invariant (Specifcation) values should be already populated\n\t * @rerun the _av OSS/J AlarmValue populated with opennms data\n\t */\n\tpublic  AlarmValue populateOssjAlarmFromOpenNMSAlarm(AlarmValue alarmValueSpecification, OnmsAlarm _openNMSalarm) throws IllegalArgumentException, UnsupportedAttributeException {\n\t\tLogger log = getLog();\n\t\tString logheader=\"\\t\\t\"+this.getClass().getSimpleName()+\"populateOssjAlarmFromOpenNMSAlarm():\";\n\n\t\t//Node node = null;\n\t\tOnmsNode node = null;\n\n\t\t// Asset asset = null;\n\t\tOnmsAssetRecord asset = null;\n\n\t\tboolean isQoSDrxAlarm=false; // true if alarm is received from Qosdrx\n\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Populating alarm\");\n\n\t\t// test to see if opennms alarm already has type and instance information set. If yes then it has most likely\n\t\t// come from Qosdrx. \n\t\tif ((_openNMSalarm.getManagedObjectInstance()!=null) && (_openNMSalarm.getManagedObjectType()!=null)\n\t\t\t\t&& (!_openNMSalarm.getManagedObjectInstance().equals(\"\")) && (!_openNMSalarm.getManagedObjectType().equals(\"\"))){\n\t\t\tisQoSDrxAlarm=true;\t\t\t\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm TRUE - because OpenNMS alarm has ManagedObjectInstance and ManagedObjectType\");\n\t\t} else {\n\t\t\tisQoSDrxAlarm=false;\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm FALSE - because OpenNMS alarm NOT POPULATED ManagedObjectInstance and ManagedObjectType\");\n\t\t}\n\n\n\t\ttry {\n\t\t\t// If the alarm has both an acknowledge time and an acknowledge user\n\t\t\t// then the alarm has been acknowledged. Set the corrsponding parameters\n\t\t\t// in the OSS/J alarm\n\t\t\tif((null != _openNMSalarm.getAlarmAckTime() ) && ( null!= _openNMSalarm.getAlarmAckUser() ) )\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAckUserId(_openNMSalarm.getAlarmAckUser());\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAckTime(new Date(_openNMSalarm.getAlarmAckTime().getTime()));\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.ACKNOWLEDGED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.UNACKNOWLEDGED);\n\t\t\t}\n\n\t\t\t// if the alarm is cleared, then set the alarm cleared time\n\t\t\t// to that of the lasteventtime as this must be the time\n\t\t\t// the clear occured.\n\t\t\tif(_openNMSalarm.getSeverity() == org.opennms.web.alarm.Alarm.CLEARED_SEVERITY) {\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(null);\n\t\t\t}\n\n\t\t\t// Set the alarmRaisedTime to the FirstEventTime of the OpenNMS\n\t\t\t// alarm. Set the alarm changed time to the last event time.\n\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\tif(null != _openNMSalarm.getFirstEventTime() ){\n\t\t\t\talarmValueSpecification.setAlarmRaisedTime(new Date(_openNMSalarm.getFirstEventTime().getTime()));\n\t\t\t}\n\t\t\tif(null != _openNMSalarm.getLastEventTime() ) {\n\t\t\t\talarmValueSpecification.setAlarmChangedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\n\n\t\t} catch (Exception e ){\n\t\t\tlog.error(logheader+\": Problem getting ACK time information\", e);\n\t\t}\n\n\n\t\tString _uei_no_html =\"NOT_SET\";\n\t\ttry{\n\t\t\tString uei = _openNMSalarm.getUei();\n\t\t\tif (null != uei) {\n\t\t\t\tmatcher = p.matcher(uei);\n\t\t\t\t_uei_no_html = matcher.replaceAll(\" \"); // remove any HTML tags from uei\n\t\t\t}\n\t\t\talarmValueSpecification.setAlarmType((_openNMSalarm.getX733AlarmType()==null) ? javax.oss.fm.monitor.AlarmType.EQUIPMENT_ALARM :  _openNMSalarm.getX733AlarmType());\n\t\t} catch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting  X733AlarmType or Uei\", e);\n\t\t}\n\n\t\t// Get some local node information as to where the alarm came from\n\t\t// This includes, what type of managed element the node is\n\t\t// and what its node id and label are.*/\n//\t\tString mftr = \"NOT_SET\"; // FIXME: Not read\n//\t\tString modelNo = \"NOT_SET\"; // FIXME: Not read\n//\t\tString assetserno = \"NOT_SET\"; // FIXME: Not read\n//\t\tString nodelabel = \"NOT_SET\"; // FIXME: Not read\n//\t\tString alarmIP = \"NOT_SET\"; // FIXME: Not read\n\t\tString managedObjectType = \"NOT_SET\";\n\t\tString managedObjectInstance =  \"NOT_SET\"; \n\t\tString assetManagedObjectType = \"NOT_SET\";\n\t\tString assetManagedObjectInstance =  \"NOT_SET\"; \n\n\t\tString assetDescription =  \"NOT_SET\";\n\t\tString assetAddress2 =  \"NOT_SET\";\n\n\t\tif (!isQoSDrxAlarm ) { // if is locally generated alarm\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnode=ossDao.findNodeByID(_openNMSalarm.getNode().getId());\n\n\t\t\t\tasset =node.getAssetRecord();\n\n//\t\t\t\talarmIP = _openNMSalarm.getIpAddr(); // Not read\n//\t\t\t\tif (node != null) {\n//\t\t\t\t\tnodelabel = node.getLabel(); // Not read\n//\t\t\t\t}\n\t\t\t\tif (asset != null) {\n//\t\t\t\t\tif (asset.getManufacturer()!= null) mftr = asset.getManufacturer(); // Not read\n//\t\t\t\t\tif (asset.getModelNumber()!= null) modelNo = asset.getModelNumber(); // Not read\n//\t\t\t\t\tif (asset.getSerialNumber()!= null) assetserno = asset.getSerialNumber(); // Not read\n\t\t\t\t\tif (asset.getDescription()!= null) assetDescription = asset.getDescription();  // TODO was used for managed object class as is 128 char long\n\t\t\t\t\tif (asset.getAddress2()!= null) assetAddress2 = asset.getAddress2();        // TODO was used for managed object instance - as is 256 char long string\n\t\t\t\t\tif (asset.getManagedObjectInstance()!= null) assetManagedObjectInstance = asset.getManagedObjectInstance();\n\t\t\t\t\tif (asset.getManagedObjectType()!= null) assetManagedObjectType = asset.getManagedObjectType();\n\t\t\t\t}\n\n\t\t\t\tmanagedObjectInstance= assetManagedObjectInstance;\n\t\t\t\tmanagedObjectType = assetManagedObjectType;\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=FALSE  OpenNMS type and instance not set. Using from Node Asset record: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t}\n\t\t\tcatch(Exception ex) {\n\t\t\t\tlog.error(logheader+\": Problem getting node and asset information\", ex);\n\t\t\t}\n\t\t} else { // is a received alarm\n\t\t\ttry {\n\t\t\t\tmanagedObjectInstance= _openNMSalarm.getManagedObjectInstance();\n\t\t\t\tmanagedObjectType =_openNMSalarm.getManagedObjectType();\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=TRUE  OpenNMS type and instance set. Using from OnmsAlarm: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t} \n\t\t\tcatch(Exception ex)\t{\n\t\t\t\tlog.error(logheader+\": Problem managedObjectInstance or managedObjectType\", ex);\n\t\t\t}\n\n\t\t}\n\n\t\talarmValueSpecification.setManagedObjectClass(managedObjectType);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectClass set to: \"+ managedObjectType);\n\n\t\talarmValueSpecification.setManagedObjectInstance(managedObjectInstance);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectInstance set to: \"+ managedObjectInstance);\n\n\t\t// set severity and probable cause\n\t\ttry {\t\t\t\n\t\t\talarmValueSpecification.setPerceivedSeverity(onmsSeverityToOssjSeverity(_openNMSalarm.getSeverity()));\n\n//\t\t\talarmValueSpecification.setProbableCause((short)-1); // OSS/J set to -1  then text contains description\n\t\t\talarmValueSpecification.setProbableCause((short)_openNMSalarm.getX733ProbableCause());\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting severity or probable cause: \", e );\n\t\t}\n\n\t\tif (!isQoSDrxAlarm ) { // if is a locally generated alarm\n\n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null != _opinstr) {\n\t\t\t\t\tmatcher = p.matcher(_opinstr);\n\t\t\t\t\t_opinstr = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null != _logmsg ) {\n\t\t\t\t\tmatcher = p.matcher(_logmsg );\n\t\t\t\t\t_logmsg  = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _logmsg = \"NOT_SET\";\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null != _description ) {\n\t\t\t\t\tmatcher = p.matcher(_description );\n\t\t\t\t\t_description  = matcher.replaceAll(\" \"); // remove all HTML tags from description\n\t\t\t\t}\n\t\t\t\telse _description = \"NOT_SET\";\n\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\t\t\t\tInteger alarmid= _openNMSalarm.getId();\n\t\t\t\tInteger counter= _openNMSalarm.getCounter();\n\t\t\t\tString reductionkey= _openNMSalarm.getReductionKey();\n\t\t\t\tInteger nodeid= _openNMSalarm.getNode().getId();\n\t\t\t\tString onmsnodelabel= _openNMSalarm.getNode().getLabel();\n\t\t\t\tString ipaddress= _openNMSalarm.getIpAddr();\n\t\t\t\tString x733AlarmType= _openNMSalarm.getX733AlarmType();\n\t\t\t\tString x733ProbableCause;\n\t\t\t\ttry {\n\t\t\t\t\tx733ProbableCause= OOSSProbableCause.getStringforEnum((short) _openNMSalarm.getX733ProbableCause());\n\t\t\t\t}catch (Exception e){\n\t\t\t\t\tx733ProbableCause=\"X733 Probable Cause Incorrectly Defined\";\n\t\t\t\t}\n\n\t\t\t\talarmValueSpecification.setAdditionalText(\n\t\t\t\t\t\t\"<alarmid>\"  + alarmid + \"<\/alarmid>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<logmsg>\"+ _logmsg +\"<\/logmsg>\"+   \"\\n            \" +\n\t\t\t\t\t\t\"<uei>\" + \t_uei_no_html + \"<uei>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<x733AlarmType>\"  + x733AlarmType + \"<\/x733AlarmType>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<x733ProbableCause>\"  + x733ProbableCause + \"<\/x733ProbableCause>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<counter>\" + counter + \"<\/counter>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<reductionkey>\" + reductionkey + \"<\/reductionkey>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodeid>\" + nodeid + \"<\/nodeid>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodelabel>\" + onmsnodelabel + \"<\/nodelabel>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<ipaddress>\" + ipaddress + \"<\/ipaddress>\" +   \"\\n            \" +\n\t\t\t\t\t\t\"<description>\"+ _description +\"<\/description>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<opinstr>\" + _opinstr + \"<\/opinstr>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<asset.managedobjectinstance>\" + assetManagedObjectInstance + \"<\/asset.managedobjectinstance>\" + \"\\n            \"+              //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.managedobjecttype>\" + assetManagedObjectType + \"<\/asset.managedobjecttype>\" + \"\\n            \"+ \n\t\t\t\t\t\t\"<asset.address2>\" + assetAddress2 + \"<\/asset.address2>\" + \"\\n            \"+  //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.description>\" + assetDescription + \"<\/asset.description>\" + \"\\n\");    //TODO - was used for object instancetype\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\n\t\t} else { // is a received alarm \n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null == _opinstr) _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null == _logmsg ) _logmsg = \"NOT_SET\";\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null == _description ) _description = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setAdditionalText(_description);\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\t\t}\n\n\t\t// TODO replacement method to populate the alarm key\n\t\ttry {\n\t\t\t//populate alarm key\n\t\t\t//TODO was AlarmKey ak = new OOSSAlarmKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tAlarmKey ak= alarmValueSpecification.getAlarmKey();\n\t\t\tak.setAlarmPrimaryKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tak.setPrimaryKey(ak.getAlarmPrimaryKey());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem setting AlarmKey: \", e );\n\t\t}\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Alarm Populated\");\n\n\t\treturn alarmValueSpecification;\n\t}","id":84616,"modified_method":"/**\n\t * This method maps OpenNMS alarm to an OSS/J alarms and adds additional information\n\t * @param _openNMSalarm data to use to populate the OSS/J alarm\n\t * @param alarmValueSpecification AlarmValue object to be populated - Invariant (Specifcation) values should be already populated\n\t * @rerun the _av OSS/J AlarmValue populated with opennms data\n\t */\n\tpublic  AlarmValue populateOssjAlarmFromOpenNMSAlarm(AlarmValue alarmValueSpecification, OnmsAlarm _openNMSalarm) throws IllegalArgumentException, UnsupportedAttributeException {\n\t\tLogger log = getLog();\n\t\tString logheader=\"\\t\\t\"+this.getClass().getSimpleName()+\"populateOssjAlarmFromOpenNMSAlarm():\";\n\n\t\t//Node node = null;\n\t\tOnmsNode node = null;\n\n\t\t// Asset asset = null;\n\t\tOnmsAssetRecord asset = null;\n\n\t\tboolean isQoSDrxAlarm=false; // true if alarm is received from Qosdrx\n\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Populating alarm\");\n\n\t\t// test to see if opennms alarm already has type and instance information set. If yes then it has most likely\n\t\t// come from Qosdrx. \n\t\tif ((_openNMSalarm.getManagedObjectInstance()!=null) && (_openNMSalarm.getManagedObjectType()!=null)\n\t\t\t\t&& (!_openNMSalarm.getManagedObjectInstance().equals(\"\")) && (!_openNMSalarm.getManagedObjectType().equals(\"\"))){\n\t\t\tisQoSDrxAlarm=true;\t\t\t\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm TRUE - because OpenNMS alarm has ManagedObjectInstance and ManagedObjectType\");\n\t\t} else {\n\t\t\tisQoSDrxAlarm=false;\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm FALSE - because OpenNMS alarm NOT POPULATED ManagedObjectInstance and ManagedObjectType\");\n\t\t}\n\n\n\t\ttry {\n\t\t\t// If the alarm has both an acknowledge time and an acknowledge user\n\t\t\t// then the alarm has been acknowledged. Set the corrsponding parameters\n\t\t\t// in the OSS/J alarm\n\t\t\tif((null != _openNMSalarm.getAlarmAckTime() ) && ( null!= _openNMSalarm.getAlarmAckUser() ) )\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAckUserId(_openNMSalarm.getAlarmAckUser());\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAckTime(new Date(_openNMSalarm.getAlarmAckTime().getTime()));\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.ACKNOWLEDGED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.UNACKNOWLEDGED);\n\t\t\t}\n\n\t\t\t// if the alarm is cleared, then set the alarm cleared time\n\t\t\t// to that of the lasteventtime as this must be the time\n\t\t\t// the clear occured.\n\t\t\tif(_openNMSalarm.getSeverity() == org.opennms.web.alarm.Alarm.CLEARED_SEVERITY) {\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(null);\n\t\t\t}\n\n\t\t\t// Set the alarmRaisedTime to the FirstEventTime of the OpenNMS\n\t\t\t// alarm. Set the alarm changed time to the last event time.\n\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\tif(null != _openNMSalarm.getFirstEventTime() ){\n\t\t\t\talarmValueSpecification.setAlarmRaisedTime(new Date(_openNMSalarm.getFirstEventTime().getTime()));\n\t\t\t}\n\t\t\tif(null != _openNMSalarm.getLastEventTime() ) {\n\t\t\t\talarmValueSpecification.setAlarmChangedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\n\n\t\t} catch (Exception e ){\n\t\t\tlog.error(logheader+\": Problem getting ACK time information\", e);\n\t\t}\n\n\n\t\tString _uei_no_html =\"NOT_SET\";\n\t\ttry{\n\t\t\tString uei = _openNMSalarm.getUei();\n\t\t\tif (null != uei) {\n\t\t\t\tmatcher = p.matcher(uei);\n\t\t\t\t_uei_no_html = matcher.replaceAll(\" \"); // remove any HTML tags from uei\n\t\t\t}\n\t\t\talarmValueSpecification.setAlarmType((_openNMSalarm.getX733AlarmType()==null) ? javax.oss.fm.monitor.AlarmType.EQUIPMENT_ALARM :  _openNMSalarm.getX733AlarmType());\n\t\t} catch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting  X733AlarmType or Uei\", e);\n\t\t}\n\n\t\t// Get some local node information as to where the alarm came from\n\t\t// This includes, what type of managed element the node is\n\t\t// and what its node id and label are.*/\n//\t\tString mftr = \"NOT_SET\"; // FIXME: Not read\n//\t\tString modelNo = \"NOT_SET\"; // FIXME: Not read\n//\t\tString assetserno = \"NOT_SET\"; // FIXME: Not read\n//\t\tString nodelabel = \"NOT_SET\"; // FIXME: Not read\n//\t\tString alarmIP = \"NOT_SET\"; // FIXME: Not read\n\t\tString managedObjectType = \"NOT_SET\";\n\t\tString managedObjectInstance =  \"NOT_SET\"; \n\t\tString assetManagedObjectType = \"NOT_SET\";\n\t\tString assetManagedObjectInstance =  \"NOT_SET\"; \n\n\t\tString assetDescription =  \"NOT_SET\";\n\t\tString assetAddress2 =  \"NOT_SET\";\n\n\t\tif (!isQoSDrxAlarm ) { // if is locally generated alarm\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// some opennms alarms don't have node information\n\t\t\t\t// set default values if no node information present\n\t\t\t\tif (_openNMSalarm.getNode()!=null) {\n\t\t\t\t\tnode=ossDao.findNodeByID(_openNMSalarm.getNode().getId());\n\n\t\t\t\t\tasset =node.getAssetRecord();\n\n//\t\t\t\t\talarmIP = _openNMSalarm.getIpAddr(); // Not read\n//\t\t\t\t\tif (node != null) {\n//\t\t\t\t\tnodelabel = node.getLabel(); // Not read\n//\t\t\t\t\t}\n\t\t\t\t\tif (asset != null) {\n//\t\t\t\t\t\tif (asset.getManufacturer()!= null) mftr = asset.getManufacturer(); // Not read\n//\t\t\t\t\t\tif (asset.getModelNumber()!= null) modelNo = asset.getModelNumber(); // Not read\n//\t\t\t\t\t\tif (asset.getSerialNumber()!= null) assetserno = asset.getSerialNumber(); // Not read\n\t\t\t\t\t\tif (asset.getDescription()!= null) assetDescription = asset.getDescription();  // TODO was used for managed object class as is 128 char long\n\t\t\t\t\t\tif (asset.getAddress2()!= null) assetAddress2 = asset.getAddress2();        // TODO was used for managed object instance - as is 256 char long string\n\t\t\t\t\t\tif (asset.getManagedObjectInstance()!= null) assetManagedObjectInstance = asset.getManagedObjectInstance();\n\t\t\t\t\t\tif (asset.getManagedObjectType()!= null) assetManagedObjectType = asset.getManagedObjectType();\n\t\t\t\t\t}\n\n\t\t\t\t\tmanagedObjectInstance= assetManagedObjectInstance;\n\t\t\t\t\tmanagedObjectType = assetManagedObjectType;\n\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=FALSE  OpenNMS type and instance not set. Using from Node Asset record: ManagedObjectInstance: \"\n\t\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception ex) {\n\t\t\t\tlog.error(logheader+\": Problem getting node and asset information\", ex);\n\t\t\t}\n\t\t} else { // is a received alarm\n\t\t\ttry {\n\t\t\t\tmanagedObjectInstance= _openNMSalarm.getManagedObjectInstance();\n\t\t\t\tmanagedObjectType =_openNMSalarm.getManagedObjectType();\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=TRUE  OpenNMS type and instance set. Using from OnmsAlarm: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t} \n\t\t\tcatch(Exception ex)\t{\n\t\t\t\tlog.error(logheader+\": Problem managedObjectInstance or managedObjectType\", ex);\n\t\t\t}\n\n\t\t}\n\n\t\talarmValueSpecification.setManagedObjectClass(managedObjectType);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectClass set to: \"+ managedObjectType);\n\n\t\talarmValueSpecification.setManagedObjectInstance(managedObjectInstance);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectInstance set to: \"+ managedObjectInstance);\n\n\t\t// set severity and probable cause\n\t\ttry {\t\t\t\n\t\t\talarmValueSpecification.setPerceivedSeverity(onmsSeverityToOssjSeverity(_openNMSalarm.getSeverity()));\n\n//\t\t\talarmValueSpecification.setProbableCause((short)-1); // OSS/J set to -1  then text contains description\n\t\t\talarmValueSpecification.setProbableCause((short)_openNMSalarm.getX733ProbableCause());\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting severity or probable cause: \", e );\n\t\t}\n\n\t\tif (!isQoSDrxAlarm ) { // if is a locally generated alarm\n\n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null != _opinstr) {\n\t\t\t\t\tmatcher = p.matcher(_opinstr);\n\t\t\t\t\t_opinstr = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null != _logmsg ) {\n\t\t\t\t\tmatcher = p.matcher(_logmsg );\n\t\t\t\t\t_logmsg  = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _logmsg = \"NOT_SET\";\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null != _description ) {\n\t\t\t\t\tmatcher = p.matcher(_description );\n\t\t\t\t\t_description  = matcher.replaceAll(\" \"); // remove all HTML tags from description\n\t\t\t\t}\n\t\t\t\telse _description = \"NOT_SET\";\n\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\t\t\t\tInteger alarmid= _openNMSalarm.getId();\n\t\t\t\tInteger counter= _openNMSalarm.getCounter();\n\t\t\t\tString reductionkey= _openNMSalarm.getReductionKey();\n\t\t\t\t\n\t\t\t\t// note some OnmsAlarms can have null nodes - we use a default value of 0 for ID\n\t\t\t\tInteger nodeid=0;\n\t\t\t\tString onmsnodelabel=\"\";\n\t\t\t\tif (_openNMSalarm.getNode()!= null) {\n\t\t\t\t\tnodeid= _openNMSalarm.getNode().getId();\n\t\t\t\t\tonmsnodelabel= _openNMSalarm.getNode().getLabel();\n\t\t\t\t}\n\t\t\t\tString ipaddress= _openNMSalarm.getIpAddr();\n\t\t\t\tString x733AlarmType= _openNMSalarm.getX733AlarmType();\n\t\t\t\tString x733ProbableCause;\n\t\t\t\ttry {\n\t\t\t\t\tx733ProbableCause= OOSSProbableCause.getStringforEnum((short) _openNMSalarm.getX733ProbableCause());\n\t\t\t\t}catch (Exception e){\n\t\t\t\t\tx733ProbableCause=\"X733 Probable Cause Incorrectly Defined\";\n\t\t\t\t}\n\n\t\t\t\talarmValueSpecification.setAdditionalText(\n\t\t\t\t\t\t\"<alarmid>\"  + alarmid + \"<\/alarmid>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<logmsg>\"+ _logmsg +\"<\/logmsg>\"+   \"\\n            \" +\n\t\t\t\t\t\t\"<uei>\" + \t_uei_no_html + \"<uei>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<x733AlarmType>\"  + x733AlarmType + \"<\/x733AlarmType>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<x733ProbableCause>\"  + x733ProbableCause + \"<\/x733ProbableCause>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<counter>\" + counter + \"<\/counter>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<reductionkey>\" + reductionkey + \"<\/reductionkey>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodeid>\" + nodeid + \"<\/nodeid>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodelabel>\" + onmsnodelabel + \"<\/nodelabel>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<ipaddress>\" + ipaddress + \"<\/ipaddress>\" +   \"\\n            \" +\n\t\t\t\t\t\t\"<description>\"+ _description +\"<\/description>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<opinstr>\" + _opinstr + \"<\/opinstr>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<asset.managedobjectinstance>\" + assetManagedObjectInstance + \"<\/asset.managedobjectinstance>\" + \"\\n            \"+              //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.managedobjecttype>\" + assetManagedObjectType + \"<\/asset.managedobjecttype>\" + \"\\n            \"+ \n\t\t\t\t\t\t\"<asset.address2>\" + assetAddress2 + \"<\/asset.address2>\" + \"\\n            \"+  //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.description>\" + assetDescription + \"<\/asset.description>\" + \"\\n\");    //TODO - was used for object instancetype\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\n\t\t} else { // is a received alarm \n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null == _opinstr) _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null == _logmsg ) _logmsg = \"NOT_SET\";\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null == _description ) _description = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setAdditionalText(_description);\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\t\t}\n\n\t\t// TODO replacement method to populate the alarm key\n\t\ttry {\n\t\t\t//populate alarm key\n\t\t\t//TODO was AlarmKey ak = new OOSSAlarmKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tAlarmKey ak= alarmValueSpecification.getAlarmKey();\n\t\t\tak.setAlarmPrimaryKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tak.setPrimaryKey(ak.getAlarmPrimaryKey());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem setting AlarmKey: \", e );\n\t\t}\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Alarm Populated\");\n\n\t\treturn alarmValueSpecification;\n\t}","commit_id":"283dd09e20ced671fd07c72f17115d5f35827d01","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * method to run in transaction to update from database\n\t */\n\tprivate void localUpdateAlarmCacheTransaction(){\n\t\tLogger log = getLog();\t\n\n\n\t\tCollection<OnmsAlarm> c = _alarmDao.findAll();\n\n\t\talarmCacheByID= new Hashtable<Integer,OnmsAlarm>(); // clear previous hashtable\n\t\talarmCacheByUniqueKey = new Hashtable<String,OnmsAlarm>();\n\t\tOnmsAlarm[] alarms= (OnmsAlarm[]) c.toArray(new OnmsAlarm[c.size()]);\n\t\t//TODO - ISSUE if too many alarms?\n\t\tfor (int i=0; i<alarms.length; i++){\n\t\t\tOnmsAlarm newalarm=alarms[i];\n\t\t\tnewalarm.getNode().getLabel(); // force node to retreive inner contents\n\n\t\t\talarmCacheByID.put(new Integer (newalarm.getId()), newalarm);\n\n\t\t\t// only update alarmCacheByUniqueKey if key is not null or empty\n\t\t\tif ( ! (\n\t\t\t\t\t(newalarm.getApplicationDN()==null)||\n\t\t\t\t\t(newalarm.getOssPrimaryKey()==null)||\n\t\t\t\t\t(newalarm.getApplicationDN().equals(\"\")) ||\n\t\t\t\t\t(newalarm.getOssPrimaryKey().equals(\"\")) )\n\t\t\t) {\n\t\t\t\tString uniqueKey=newalarm.getApplicationDN()+newalarm.getOssPrimaryKey();\n\t\t\t\tif (alarmCacheByUniqueKey.get(uniqueKey)==null) {\n\t\t\t\t\talarmCacheByUniqueKey.put(uniqueKey, newalarm);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().localUpdateAlarmCache(): ERROR - duplicate alarm uniqueKey in database =\"+ uniqueKey +\" AlarmID:\"+newalarm.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","id":84617,"modified_method":"/**\n\t * method to run in transaction to update from database\n\t */\n\tprivate void localUpdateAlarmCacheTransaction(){\n\t\tLogger log = getLog();\t\n\n\n\t\tCollection<OnmsAlarm> c = _alarmDao.findAll();\n\n\t\talarmCacheByID= new Hashtable<Integer,OnmsAlarm>(); // clear previous hashtable\n\t\talarmCacheByUniqueKey = new Hashtable<String,OnmsAlarm>();\n\t\tOnmsAlarm[] alarms= (OnmsAlarm[]) c.toArray(new OnmsAlarm[c.size()]);\n\t\t//TODO - ISSUE if too many alarms?\n\t\tfor (int i=0; i<alarms.length; i++){\n\t\t\tOnmsAlarm newalarm=alarms[i];\n\t\t\t// retrieve inner contents of alarm node if there is a node associated with the alarm\n\t\t\tif (newalarm.getNode()!=null) {\n\t\t\t\tnewalarm.getNode().getLabel();\n\t\t\t}\n\n\t\t\talarmCacheByID.put(new Integer (newalarm.getId()), newalarm);\n\n\t\t\t// only update alarmCacheByUniqueKey if key is not null or empty\n\t\t\tif ( ! (\n\t\t\t\t\t(newalarm.getApplicationDN()==null)||\n\t\t\t\t\t(newalarm.getOssPrimaryKey()==null)||\n\t\t\t\t\t(newalarm.getApplicationDN().equals(\"\")) ||\n\t\t\t\t\t(newalarm.getOssPrimaryKey().equals(\"\")) )\n\t\t\t) {\n\t\t\t\tString uniqueKey=newalarm.getApplicationDN()+newalarm.getOssPrimaryKey();\n\t\t\t\tif (alarmCacheByUniqueKey.get(uniqueKey)==null) {\n\t\t\t\t\talarmCacheByUniqueKey.put(uniqueKey, newalarm);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().localUpdateAlarmCache(): ERROR - duplicate alarm uniqueKey in database =\"+ uniqueKey +\" AlarmID:\"+newalarm.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"283dd09e20ced671fd07c72f17115d5f35827d01","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Update the node cache from the OpenNMS database\n\t * This must be run at least once to ensure that node data is available\n\t * Not Thread Safe - only to be called from within the synchronised methods\n\t */\n\tprivate void localUpdateNodeCaches(){\n\t\tLogger log = getLog();\t\n\t\ttry{\n\t\t\tnodeCacheByID=new Hashtable<Integer,OnmsNode>();\n\t\t\tnodeCacheByLabel=new Hashtable<String,OnmsNode>();\n\t\t\tnodeCacheByUniqueID=new Hashtable<String,OnmsNode>();\t\n\n\t\t\tif (log.isDebugEnabled()) log.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updating Node Caches :\");\n\n\t\t\tCollection<OnmsNode> c = _nodeDao.findAll();\n\t\t\tOnmsNode[] nodelist= (OnmsNode[]) c.toArray(new OnmsNode[c.size()]);\n\t\t\tfor (int i=0; i<nodelist.length; i++){\n\t\t\t\tOnmsNode node=(OnmsNode)nodelist[i];\n\t\t\t\ttry {\n\t\t\t\t\t// update node by ID cache\n\t\t\t\t\tthis.nodeCacheByID.put((Integer)node.getId(), node);\n\n\t\t\t\t\t// update node by Label cache\n\t\t\t\t\tif (node.getLabel()!=null) {\n\t\t\t\t\t\tif (nodeCacheByLabel.get((String)node.getLabel())!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label:\"+node.getId()+\" is duplicated\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByLabel.put((String)node.getLabel(), node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label is Not putting node in nodeCacheByLabel\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// update node by Unique ID -managedObjectInstance+ManagedObjectType \n\t\t\t\t\tOnmsAssetRecord assetRecord = node.getAssetRecord();\n\t\t\t\t\tif (assetRecord==null) {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" assetRecord is NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif ((assetRecord.getManagedObjectInstance()==null) || (assetRecord.getManagedObjectType()==null)){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" ManagedObjectInstance and/or ManagedObjectType are NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString uniqueid=assetRecord.getManagedObjectInstance()+assetRecord.getManagedObjectType();\n\t\t\t\t\t\t\tif (nodeCacheByUniqueID.get((String)uniqueid)!=null){\n\t\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\n\t\t\t\t\t\t\t\t\t\t\"Unique ID is duplicated. Unique ID = ManagedObjectInstance:\"+assetRecord.getManagedObjectInstance()+\"+ ManagedObjectType:\"+assetRecord.getManagedObjectType());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnodeCacheByUniqueID.put(uniqueid, node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t} catch (Exception ex){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches Error updating node caches: ERROR : \", ex);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByID : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (Integer id : nodeCacheByID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByID.get(id);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Node ID:\"+id+\"\\tNodeLabel:\"+node.getLabel());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents Error:\",e);\n\t\t\t\t}\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByLabel : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (String label : nodeCacheByLabel.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByLabel.get(label);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Label:\"+label+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents. Error:\",e);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByUniqueID : contents :\");\n\t\t\t\t\tfor (String uniqueID : nodeCacheByUniqueID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByUniqueID.get(uniqueID);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: uniqueID:\"+uniqueID+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByUniqueID contents Error:\",e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex){\n\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches ERROR : \", ex);\n\t\t}\n\t}","id":84618,"modified_method":"/**\n\t * Update the node cache from the OpenNMS database\n\t * This must be run at least once to ensure that node data is available\n\t * Not Thread Safe - only to be called from within the synchronised methods\n\t */\n\tprivate void localUpdateNodeCaches(){\n\t\tLogger log = getLog();\t\n\t\ttry{\n\t\t\tnodeCacheByID=new Hashtable<Integer,OnmsNode>();\n\t\t\tnodeCacheByLabel=new Hashtable<String,OnmsNode>();\n\t\t\tnodeCacheByUniqueID=new Hashtable<String,OnmsNode>();\t\n\n\t\t\tif (log.isDebugEnabled()) log.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updating Node Caches :\");\n\n\t\t\tCollection<OnmsNode> c = _nodeDao.findAll();\n\t\t\tOnmsNode[] nodelist= (OnmsNode[]) c.toArray(new OnmsNode[c.size()]);\n\t\t\tfor (int i=0; i<nodelist.length; i++){\n\t\t\t\tOnmsNode node=(OnmsNode)nodelist[i];\n\t\t\t\ttry {\n\t\t\t\t\t// update node by ID cache\n\t\t\t\t\tthis.nodeCacheByID.put((Integer)node.getId(), node);\n\n\t\t\t\t\t// update node by Label cache\n\t\t\t\t\tif (node.getLabel()!=null) {\n\t\t\t\t\t\tif (nodeCacheByLabel.get((String)node.getLabel())!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label:\"+node.getId()+\" is duplicated\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByLabel.put((String)node.getLabel(), node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label is NULL. Not putting node in nodeCacheByLabel\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// update node by Unique ID -managedObjectInstance+ManagedObjectType \n\t\t\t\t\tfinal OnmsAssetRecord assetRecord = node.getAssetRecord();\n\t\t\t\t\tif (assetRecord==null) {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" assetRecord is NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Note that the node asset record data for instance and type are only filled \n\t\t\t\t\t\t// given default values once - subsequently changes must be explicitly set directly\n\t\t\t\t\t\t// in the database\n\t\t\t\t\t\tString moi=assetRecord.getManagedObjectInstance();\n\t\t\t\t\t\tif ((moi==null)||(\"\".equals(moi))){\n\t\t\t\t\t\t\tString fid  = (node.getForeignId()==null) ? \"\" : node.getForeignId();\n\t\t\t\t\t\t\tString fsrc = (node.getForeignSource()==null) ? \"\" : node.getForeignSource() ;\n\t\t\t\t\t\t\tString label= (node.getLabel()==null) ? \"\" : node.getLabel();\n\t\t\t\t\t\t\tmoi  = \"Label:\"+label+\":ForeignSource:\"+fsrc+\":ForeignId():\"+fid;\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()\n\t\t\t\t\t\t\t\t\t+\" ManagedObjectInstance is NULL. Setting  ManagedObjectInstance to: \"+moi);\n\t\t\t\t\t\t\tassetRecord.setManagedObjectInstance(moi);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString mot=assetRecord.getManagedObjectType();\n\t\t\t\t\t\tif ((mot==null)||(\"\".equals(mot))){\n\t\t\t\t\t\t\tmot=\"UNSPECIFIED_TYPE\";\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"\n\t\t\t\t\t\t\t\t\t+node.getId()+\"ManagedObjectType was NULL. Setting ManagedObjectType to: \"+mot);\n\t\t\t\t\t\t\tassetRecord.setManagedObjectType(mot);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// save asset data back with new node information \n\t\t\t\t\t\t// (Note - data may not have changed)\n\t\t\t\t\t\ttransTemplate.execute(new TransactionCallback() {\n\t\t\t\t\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\t\t\t\t\t_assetRecordDao.update(assetRecord);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// update nodeCacheByUniqueID\n\t\t\t\t\t\tString uniqueid=assetRecord.getManagedObjectInstance()+assetRecord.getManagedObjectType();\n\t\t\t\t\t\tif (nodeCacheByUniqueID.get((String)uniqueid)!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\n\t\t\t\t\t\t\t\t\t\t\" Unique ID is duplicated. Unique ID = ManagedObjectInstance:\"+assetRecord.getManagedObjectInstance()+\"+ ManagedObjectType:\"+assetRecord.getManagedObjectType());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByUniqueID.put(uniqueid, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches Error updating node caches: ERROR : \", ex);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByID : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (Integer id : nodeCacheByID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByID.get(id);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Node ID:\"+id+\"\\tNodeLabel:\"+node.getLabel());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents Error:\",e);\n\t\t\t\t}\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByLabel : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (String label : nodeCacheByLabel.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByLabel.get(label);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Label:\"+label+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents. Error:\",e);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByUniqueID : contents :\");\n\t\t\t\t\tfor (String uniqueID : nodeCacheByUniqueID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByUniqueID.get(uniqueID);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: uniqueID:\"+uniqueID+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByUniqueID contents Error:\",e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex){\n\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches ERROR : \", ex);\n\t\t}\n\t}","commit_id":"283dd09e20ced671fd07c72f17115d5f35827d01","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onNotifyNewAlarmEvent(NotifyNewAlarmEvent nnae, OssBeanAlarmEventReceiver callingAer) {\n\t\t//\tGet a reference to the QoSD logger instance assigned by OpenNMS\n\t\tLogger log = getLog();\t\n\t\tString logheader=\"RX:\"+callingAer.getName()+\":\"+this.getClass().getSimpleName()+\".onNotifyNewAlarmEvent(): \";\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\"\\n    Statistics:\" +callingAer.getRuntimeStatistics());\n\t\tif (!initialised ){\n\t\t\tlog.error(logheader+\"event handler not initialised. init() must be called by receiver before handling any events\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//TODO ADD IN BUSINESS LOGIC\n\n\t\ttry{\n\t\t\tOnmsAlarm alarm=null;\n\t\t\tString ossPrimaryKey=nnae.getAlarmKey().getAlarmPrimaryKey();\n\t\t\tString applicationDN=nnae.getAlarmKey().getApplicationDN();\n\t\t\tif (log.isDebugEnabled()) \n\t\t\t\tlog.debug(logheader+\": Received an onNotifyNewAlarmEvent() - AlarmPrimaryKey: \"\n\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN +\" eventtime: \" + nnae.getEventTime());\n\t\t\tif (log.isDebugEnabled())log.debug(logheader+\":Using this OssDao (toString):\"+ossDao.toString());\n\t\t\tif ((applicationDN==null)||(applicationDN.equals(\"\")) || (ossPrimaryKey==null)||(ossPrimaryKey.equals(\"\"))) {\n\t\t\t\tlog.error(logheader+\" ApplicatioDN or PrimaryKey not set\");\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating new alarm\");\n\n//\t\t\t\talarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);\n//\t\t\t\tif (alarm!=null) { // already an alarm with this unique id - log error\n//\t\t\t\tlog.error(logheader+\" Alarm Already exists with this Unique ID\");\n//\t\t\t\t} else {\n\t\t\t\talarm=new OnmsAlarm();\n\t\t\t\t\n\t\t\t\talarm.setUei(onmsAlarmOssjMapper.ossjAlarmTypeToUei(nnae.getAlarmType()));\n\t\t\t\t\n\t\t\t\talarm.setX733AlarmType((nnae.getAlarmType()==null) ? \"\" : nnae.getAlarmType());\n\t\t\t\talarm.setX733ProbableCause(nnae.getProbableCause());\n\n\t\t\t\talarm.setTTicketState(null); // needed?\n\t\t\t\talarm.setTTicketId(\"\"); // TODO changed\n\t\t\t\talarm.setQosAlarmState(\"external_type\"); // TODO changed\t\t\t\t\n\t\t\t\talarm.setSuppressedUser(\"\"); // needed?\n\t\t\t\talarm.setSuppressedUntil(new Date()); // needed?\n\t\t\t\talarm.setSuppressedTime(new Date()); // needed?\n\n\t\t\t\tInteger onmsseverity;\n\t\t\t\ttry{\n\t\t\t\t\tonmsseverity= onmsAlarmOssjMapper.ossjSeveritytoOnmsSeverity(nnae.getPerceivedSeverity());\n\t\t\t\t} catch (IllegalArgumentException iae){\n\t\t\t\t\tlog.error(logheader+\" problem setting severity used default:'WARNING'. Exception:\"+ iae);\n\t\t\t\t\tonmsseverity=new Integer(org.opennms.web.alarm.Alarm.WARNING_SEVERITY);\n\t\t\t\t}\n\t\t\t\talarm.setSeverity(onmsseverity); \n\n//TODO not needed\n//\t\t\t\tOnmsServiceType service= new OnmsServiceType();\n//\t\t\t\tservice.setId(new Integer(-1));\n//\t\t\t\talarm.setServiceType(new OnmsServiceType()); // needed?\n\n\n\t\t\t\talarm.setReductionKey(\":managedObjectInstance:\"+nnae.getManagedObjectInstance()+\n\t\t\t\t\t\t\":managedObjectType:\"+nnae.getManagedObjectClass()+\n\t\t\t\t\t\t\":ossPrimaryKey:-\"+ossPrimaryKey+\n\t\t\t\t\t\t\":applicationDN:-\"+applicationDN); // must be unique because of alarm_reductionkey_idx\n\n\t\t\t\talarm.setOssPrimaryKey(ossPrimaryKey);\n\t\t\t\talarm.setOperInstruct(nnae.getProposedRepairActions()); \n\n\t\t\t\t// defaultvalue if search fails - will update node with ID 1\n\t\t\t\tOnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\talarm.setNode(node); // \n\n\t\t\t\tif (almUpdateBehaviour==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse if (callingAer.getName()==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver has no name: default alarms will update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour);\n\n\t\t\t\t\tif (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {\n\t\t\t\t\t\t// this will look for first match of node label to callingAer.getName()\n\t\t\t\t\t\t// and set node id to this value.\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" SPECIFY_OUTSTATION looking for node with nodelabel:\"+callingAer.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// TODO temp remove ?\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tnode =ossDao.findNodeByLabel(callingAer.getName());\n\t\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node \"+ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} \n\t\t\t\t\telse if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){\n\t\t\t\t\t\t// this will look for first match of node Managed object Instance and Managed Object type\n\t\t\t\t\t\t// and set node id to this value. \n\t\t\t\t\t\tString managedObjectType=nnae.getManagedObjectClass();\n\t\t\t\t\t\tString managedObjectInstance=nnae.getManagedObjectInstance();\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" USE_TYPE_INSTANCE looking for node with managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnode =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();\n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.error(logheader+\" Invalid value for alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour+\" defaulting to update nodeID:1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\talarm.setMouseOverText(\"\"); // needed?\n\t\t\t\talarm.setManagedObjectType(nnae.getManagedObjectClass());\n\t\t\t\talarm.setManagedObjectInstance(nnae.getManagedObjectInstance());\n\t\t\t\talarm.setLogMsg(nnae.getSpecificProblem());\n\n\t\t\t\t// NOTE - this has no effect here as .setLastEvent nulls value\n\t\t\t\t// alarm.setLastEventTime(nnae.getEventTime());\n//TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo\n//\t\t\t\tOnmsEvent event= new OnmsEvent();\n//\t\t\t\t//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table\n//\t\t\t\talarm.setLastEvent(event); \n\n\t\t\t\talarm.setIpAddr(\"localhost\"); // needed?\n\t\t\t\talarm.setId(null); // set null as updating alarm\n\t\t\t\talarm.setFirstEventTime(nnae.getEventTime());\n\t\t\t\talarm.setLastEventTime(nnae.getEventTime());\n\t\t\t\t\n// TODO removed - do create distpoller with hibernate dao\t\t\t\t\n//\t\t\t\talarm.setDistPoller(new OnmsDistPoller(\"undefined\",\"localhost\")); //simple constructor\n\t\t\t\talarm.setDistPoller(distPollerDao.get(\"localhost\"));\n\t\t\t\t\n\t\t\t\talarm.setDescription(nnae.getAdditionalText()); //TODO need Qosd Not to generate this if remote\n\t\t\t\talarm.setCounter(new Integer(1));\n\t\t\t\talarm.setClearUei(\"\");\n\t\t\t\talarm.setApplicationDN(applicationDN);\n\t\t\t\talarm.setAlarmType(new Integer(1)); // set to raise alarm\n\t\t\t\t//alarm.setAlarmAckUser(arg0);\n\t\t\t\t//alarm.setAlarmAckTime(arg0);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating Alarm: \" );\n\t\t\t\t\tOnmsAlarm updatedAlarm = ossDao.addCurrentAlarmForUniqueKey(alarm);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(logheader+\": Created alarm:\"\n\t\t\t\t\t\t\t\t+ ossDao.alarmToString(updatedAlarm));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( Exception ex ) {\n\t\t\t\t\tlog.error(logheader+\": problem creating new alarm AlarmPrimaryKey: \"\n\t\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN+\": \"+ ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO remove\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tlog.error(logheader+\" Error : \", e);\n\t\t}\n\t}","id":84619,"modified_method":"public void onNotifyNewAlarmEvent(NotifyNewAlarmEvent nnae, OssBeanAlarmEventReceiver callingAer) {\n\t\t//\tGet a reference to the QoSD logger instance assigned by OpenNMS\n\t\tLogger log = getLog();\t\n\t\tString logheader=\"RX:\"+callingAer.getName()+\":\"+this.getClass().getSimpleName()+\".onNotifyNewAlarmEvent(): \";\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\"\\n    Statistics:\" +callingAer.getRuntimeStatistics());\n\t\tif (!initialised ){\n\t\t\tlog.error(logheader+\"event handler not initialised. init() must be called by receiver before handling any events\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//TODO ADD IN BUSINESS LOGIC\n\n\t\ttry{\n\t\t\tOnmsAlarm alarm=null;\n\t\t\tString ossPrimaryKey=nnae.getAlarmKey().getAlarmPrimaryKey();\n\t\t\tString applicationDN=nnae.getAlarmKey().getApplicationDN();\n\t\t\tif (log.isDebugEnabled()) \n\t\t\t\tlog.debug(logheader+\": Received an onNotifyNewAlarmEvent() - AlarmPrimaryKey: \"\n\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN +\" eventtime: \" + nnae.getEventTime());\n\t\t\tif (log.isDebugEnabled())log.debug(logheader+\":Using this OssDao (toString):\"+ossDao.toString());\n\t\t\tif ((applicationDN==null)||(applicationDN.equals(\"\")) || (ossPrimaryKey==null)||(ossPrimaryKey.equals(\"\"))) {\n\t\t\t\tlog.error(logheader+\" ApplicatioDN or PrimaryKey not set\");\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating new alarm\");\n\n//\t\t\t\talarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);\n//\t\t\t\tif (alarm!=null) { // already an alarm with this unique id - log error\n//\t\t\t\tlog.error(logheader+\" Alarm Already exists with this Unique ID\");\n//\t\t\t\t} else {\n\t\t\t\talarm=new OnmsAlarm();\n\t\t\t\t\n\t\t\t\talarm.setUei(onmsAlarmOssjMapper.ossjAlarmTypeToUei(nnae.getAlarmType()));\n\t\t\t\t\n\t\t\t\talarm.setX733AlarmType((nnae.getAlarmType()==null) ? \"\" : nnae.getAlarmType());\n\t\t\t\talarm.setX733ProbableCause(nnae.getProbableCause());\n\n\t\t\t\talarm.setTTicketState(null); // needed?\n\t\t\t\talarm.setTTicketId(\"\"); // TODO changed\n\t\t\t\talarm.setQosAlarmState(\"external_type\"); // TODO changed\t\t\t\t\n\t\t\t\talarm.setSuppressedUser(\"\"); // needed?\n\t\t\t\talarm.setSuppressedUntil(new Date()); // needed?\n\t\t\t\talarm.setSuppressedTime(new Date()); // needed?\n\n\t\t\t\tInteger onmsseverity;\n\t\t\t\ttry{\n\t\t\t\t\tonmsseverity= onmsAlarmOssjMapper.ossjSeveritytoOnmsSeverity(nnae.getPerceivedSeverity());\n\t\t\t\t} catch (IllegalArgumentException iae){\n\t\t\t\t\tlog.error(logheader+\" problem setting severity used default:'WARNING'. Exception:\"+ iae);\n\t\t\t\t\tonmsseverity=new Integer(org.opennms.web.alarm.Alarm.WARNING_SEVERITY);\n\t\t\t\t}\n\t\t\t\talarm.setSeverity(onmsseverity); \n\n//TODO not needed\n//\t\t\t\tOnmsServiceType service= new OnmsServiceType();\n//\t\t\t\tservice.setId(new Integer(-1));\n//\t\t\t\talarm.setServiceType(new OnmsServiceType()); // needed?\n\n\n\t\t\t\talarm.setReductionKey(\":managedObjectInstance:\"+nnae.getManagedObjectInstance()+\n\t\t\t\t\t\t\":managedObjectType:\"+nnae.getManagedObjectClass()+\n\t\t\t\t\t\t\":ossPrimaryKey:-\"+ossPrimaryKey+\n\t\t\t\t\t\t\":applicationDN:-\"+applicationDN); // must be unique because of alarm_reductionkey_idx\n\n\t\t\t\talarm.setOssPrimaryKey(ossPrimaryKey);\n\t\t\t\talarm.setOperInstruct(nnae.getProposedRepairActions()); \n\n\t\t\t\t// defaultvalue if search fails - will update node with ID 1\n\t\t\t\tOnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\talarm.setNode(node); // \n\n\t\t\t\tif (almUpdateBehaviour==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse if (callingAer.getName()==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver has no name: default alarms will update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour);\n\n\t\t\t\t\tif (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {\n\t\t\t\t\t\t// this will look for first match of node label to callingAer.getName()\n\t\t\t\t\t\t// and set node id to this value.\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" SPECIFY_OUTSTATION looking for node with nodelabel:\"+callingAer.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// TODO temp remove ?\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tnode =ossDao.findNodeByLabel(callingAer.getName());\n\t\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node \"+ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} \n\t\t\t\t\telse if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){\n\t\t\t\t\t\t// this will look for first match of node Managed object Instance and Managed Object type\n\t\t\t\t\t\t// and set node id to this value. \n\t\t\t\t\t\tString managedObjectType=nnae.getManagedObjectClass();\n\t\t\t\t\t\tString managedObjectInstance=nnae.getManagedObjectInstance();\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" USE_TYPE_INSTANCE looking for node with managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnode =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();\n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.error(logheader+\" Invalid value for alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour+\" defaulting to update nodeID:1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\talarm.setMouseOverText(\"\"); // needed?\n\t\t\t\talarm.setManagedObjectType(nnae.getManagedObjectClass());\n\t\t\t\talarm.setManagedObjectInstance(nnae.getManagedObjectInstance());\n\t\t\t\talarm.setLogMsg(nnae.getSpecificProblem());\n\n\t\t\t\t// NOTE - this has no effect here as .setLastEvent nulls value\n\t\t\t\t// alarm.setLastEventTime(nnae.getEventTime());\n//TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo\n//\t\t\t\tOnmsEvent event= new OnmsEvent();\n//\t\t\t\t//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table\n//\t\t\t\talarm.setLastEvent(event); \n\n\t\t\t\talarm.setIpAddr(\"localhost\"); // needed?\n\t\t\t\talarm.setId(null); // set null as updating alarm\n\t\t\t\talarm.setFirstEventTime(nnae.getEventTime());\n\t\t\t\talarm.setLastEventTime(nnae.getEventTime());\n\t\t\t\t\n// TODO removed - do create distpoller with hibernate dao\t\t\t\t\n//\t\t\t\talarm.setDistPoller(new OnmsDistPoller(\"undefined\",\"localhost\")); //simple constructor\n\t\t\t\talarm.setDistPoller(distPollerDao.get(\"localhost\"));\n\t\t\t\t\n\t\t\t\talarm.setDescription(nnae.getAdditionalText()); //TODO need Qosd Not to generate this if remote\n\t\t\t\talarm.setCounter(new Integer(1));\n\t\t\t\talarm.setClearUei(\"\");\n\t\t\t\talarm.setApplicationDN(applicationDN);\n\t\t\t\talarm.setAlarmType(new Integer(1)); // set to raise alarm\n\t\t\t\t//alarm.setAlarmAckUser(arg0);\n\t\t\t\t//alarm.setAlarmAckTime(arg0);\n\t\t\t\t\n\t\t\t\t//TODO added for new alarm field\n\t\t\t\tHashMap<String, String> m_details = new HashMap();\n\t\t\t\talarm.setDetails(m_details);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating Alarm: \" );\n\t\t\t\t\tOnmsAlarm updatedAlarm = ossDao.addCurrentAlarmForUniqueKey(alarm);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(logheader+\": Created alarm:\"\n\t\t\t\t\t\t\t\t+ ossDao.alarmToString(updatedAlarm));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( Exception ex ) {\n\t\t\t\t\tlog.error(logheader+\": problem creating new alarm AlarmPrimaryKey: \"\n\t\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN+\": \"+ ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO remove\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tlog.error(logheader+\" Error : \", e);\n\t\t}\n\t}","commit_id":"283dd09e20ced671fd07c72f17115d5f35827d01","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * This method maps OpenNMS alarm to an OSS/J alarms and adds additional information\n\t * @param _openNMSalarm data to use to populate the OSS/J alarm\n\t * @param alarmValueSpecification AlarmValue object to be populated - Invariant (Specifcation) values should be already populated\n\t * @rerun the _av OSS/J AlarmValue populated with opennms data\n\t */\n\tpublic  AlarmValue populateOssjAlarmFromOpenNMSAlarm(AlarmValue alarmValueSpecification, OnmsAlarm _openNMSalarm) throws IllegalArgumentException, UnsupportedAttributeException {\n\t\tLogger log = getLog();\n\t\tString logheader=\"\\t\\t\"+this.getClass().getSimpleName()+\"populateOssjAlarmFromOpenNMSAlarm():\";\n\n\t\t//Node node = null;\n\t\tOnmsNode node = null;\n\n\t\t// Asset asset = null;\n\t\tOnmsAssetRecord asset = null;\n\n\t\tboolean isQoSDrxAlarm=false; // true if alarm is received from Qosdrx\n\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Populating alarm\");\n\n\t\t// test to see if opennms alarm already has type and instance information set. If yes then it has most likely\n\t\t// come from Qosdrx. \n\t\tif ((_openNMSalarm.getManagedObjectInstance()!=null) && (_openNMSalarm.getManagedObjectType()!=null)\n\t\t\t\t&& (!_openNMSalarm.getManagedObjectInstance().equals(\"\")) && (!_openNMSalarm.getManagedObjectType().equals(\"\"))){\n\t\t\tisQoSDrxAlarm=true;\t\t\t\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm TRUE - because OpenNMS alarm has ManagedObjectInstance and ManagedObjectType\");\n\t\t} else {\n\t\t\tisQoSDrxAlarm=false;\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm FALSE - because OpenNMS alarm NOT POPULATED ManagedObjectInstance and ManagedObjectType\");\n\t\t}\n\n\n\t\ttry {\n\t\t\t// If the alarm has both an acknowledge time and an acknowledge user\n\t\t\t// then the alarm has been acknowledged. Set the corrsponding parameters\n\t\t\t// in the OSS/J alarm\n\t\t\tif((null != _openNMSalarm.getAlarmAckTime() ) && ( null!= _openNMSalarm.getAlarmAckUser() ) )\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAckUserId(_openNMSalarm.getAlarmAckUser());\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAckTime(new Date(_openNMSalarm.getAlarmAckTime().getTime()));\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.ACKNOWLEDGED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.UNACKNOWLEDGED);\n\t\t\t}\n\n\t\t\t// if the alarm is cleared, then set the alarm cleared time\n\t\t\t// to that of the lasteventtime as this must be the time\n\t\t\t// the clear occured.\n\t\t\tif(_openNMSalarm.getSeverity() == org.opennms.web.alarm.Alarm.CLEARED_SEVERITY) {\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(null);\n\t\t\t}\n\n\t\t\t// Set the alarmRaisedTime to the FirstEventTime of the OpenNMS\n\t\t\t// alarm. Set the alarm changed time to the last event time.\n\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\tif(null != _openNMSalarm.getFirstEventTime() ){\n\t\t\t\talarmValueSpecification.setAlarmRaisedTime(new Date(_openNMSalarm.getFirstEventTime().getTime()));\n\t\t\t}\n\t\t\tif(null != _openNMSalarm.getLastEventTime() ) {\n\t\t\t\talarmValueSpecification.setAlarmChangedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\n\n\t\t} catch (Exception e ){\n\t\t\tlog.error(logheader+\": Problem getting ACK time information\", e);\n\t\t}\n\n\n\t\tString _uei_no_html =\"NOT_SET\";\n\t\ttry{\n\t\t\tString uei = _openNMSalarm.getUei();\n\t\t\tif (null != uei) {\n\t\t\t\tmatcher = p.matcher(uei);\n\t\t\t\t_uei_no_html = matcher.replaceAll(\" \"); // remove any HTML tags from uei\n\t\t\t}\n\t\t\talarmValueSpecification.setAlarmType((_openNMSalarm.getX733AlarmType()==null) ? javax.oss.fm.monitor.AlarmType.EQUIPMENT_ALARM :  _openNMSalarm.getX733AlarmType());\n\t\t} catch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting  X733AlarmType or Uei\", e);\n\t\t}\n\n\t\t// Get some local node information as to where the alarm came from\n\t\t// This includes, what type of managed element the node is\n\t\t// and what its node id and label are.*/\n//\t\tString mftr = \"NOT_SET\"; // FIXME: Not read\n//\t\tString modelNo = \"NOT_SET\"; // FIXME: Not read\n//\t\tString assetserno = \"NOT_SET\"; // FIXME: Not read\n//\t\tString nodelabel = \"NOT_SET\"; // FIXME: Not read\n//\t\tString alarmIP = \"NOT_SET\"; // FIXME: Not read\n\t\tString managedObjectType = \"NOT_SET\";\n\t\tString managedObjectInstance =  \"NOT_SET\"; \n\t\tString assetManagedObjectType = \"NOT_SET\";\n\t\tString assetManagedObjectInstance =  \"NOT_SET\"; \n\n\t\tString assetDescription =  \"NOT_SET\";\n\t\tString assetAddress2 =  \"NOT_SET\";\n\n\t\tif (!isQoSDrxAlarm ) { // if is locally generated alarm\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnode=ossDao.findNodeByID(_openNMSalarm.getNode().getId());\n\n\t\t\t\tasset =node.getAssetRecord();\n\n//\t\t\t\talarmIP = _openNMSalarm.getIpAddr(); // Not read\n//\t\t\t\tif (node != null) {\n//\t\t\t\t\tnodelabel = node.getLabel(); // Not read\n//\t\t\t\t}\n\t\t\t\tif (asset != null) {\n//\t\t\t\t\tif (asset.getManufacturer()!= null) mftr = asset.getManufacturer(); // Not read\n//\t\t\t\t\tif (asset.getModelNumber()!= null) modelNo = asset.getModelNumber(); // Not read\n//\t\t\t\t\tif (asset.getSerialNumber()!= null) assetserno = asset.getSerialNumber(); // Not read\n\t\t\t\t\tif (asset.getDescription()!= null) assetDescription = asset.getDescription();  // TODO was used for managed object class as is 128 char long\n\t\t\t\t\tif (asset.getAddress2()!= null) assetAddress2 = asset.getAddress2();        // TODO was used for managed object instance - as is 256 char long string\n\t\t\t\t\tif (asset.getManagedObjectInstance()!= null) assetManagedObjectInstance = asset.getManagedObjectInstance();\n\t\t\t\t\tif (asset.getManagedObjectType()!= null) assetManagedObjectType = asset.getManagedObjectType();\n\t\t\t\t}\n\n\t\t\t\tmanagedObjectInstance= assetManagedObjectInstance;\n\t\t\t\tmanagedObjectType = assetManagedObjectType;\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=FALSE  OpenNMS type and instance not set. Using from Node Asset record: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t}\n\t\t\tcatch(Exception ex) {\n\t\t\t\tlog.error(logheader+\": Problem getting node and asset information\", ex);\n\t\t\t}\n\t\t} else { // is a received alarm\n\t\t\ttry {\n\t\t\t\tmanagedObjectInstance= _openNMSalarm.getManagedObjectInstance();\n\t\t\t\tmanagedObjectType =_openNMSalarm.getManagedObjectType();\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=TRUE  OpenNMS type and instance set. Using from OnmsAlarm: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t} \n\t\t\tcatch(Exception ex)\t{\n\t\t\t\tlog.error(logheader+\": Problem managedObjectInstance or managedObjectType\", ex);\n\t\t\t}\n\n\t\t}\n\n\t\talarmValueSpecification.setManagedObjectClass(managedObjectType);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectClass set to: \"+ managedObjectType);\n\n\t\talarmValueSpecification.setManagedObjectInstance(managedObjectInstance);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectInstance set to: \"+ managedObjectInstance);\n\n\t\t// set severity and probable cause\n\t\ttry {\t\t\t\n\t\t\talarmValueSpecification.setPerceivedSeverity(onmsSeverityToOssjSeverity(_openNMSalarm.getSeverity()));\n\n//\t\t\talarmValueSpecification.setProbableCause((short)-1); // OSS/J set to -1  then text contains description\n\t\t\talarmValueSpecification.setProbableCause((short)_openNMSalarm.getX733ProbableCause());\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting severity or probable cause: \", e );\n\t\t}\n\n\t\tif (!isQoSDrxAlarm ) { // if is a locally generated alarm\n\n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null != _opinstr) {\n\t\t\t\t\tmatcher = p.matcher(_opinstr);\n\t\t\t\t\t_opinstr = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null != _logmsg ) {\n\t\t\t\t\tmatcher = p.matcher(_logmsg );\n\t\t\t\t\t_logmsg  = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _logmsg = \"NOT_SET\";\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null != _description ) {\n\t\t\t\t\tmatcher = p.matcher(_description );\n\t\t\t\t\t_description  = matcher.replaceAll(\" \"); // remove all HTML tags from description\n\t\t\t\t}\n\t\t\t\telse _description = \"NOT_SET\";\n\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\t\t\t\tInteger alarmid= _openNMSalarm.getId();\n\t\t\t\tInteger counter= _openNMSalarm.getCounter();\n\t\t\t\tString reductionkey= _openNMSalarm.getReductionKey();\n\t\t\t\tInteger nodeid= _openNMSalarm.getNode().getId();\n\t\t\t\tString onmsnodelabel= _openNMSalarm.getNode().getLabel();\n\t\t\t\tString ipaddress= _openNMSalarm.getIpAddr();\n\t\t\t\tString x733AlarmType= _openNMSalarm.getX733AlarmType();\n\t\t\t\tString x733ProbableCause;\n\t\t\t\ttry {\n\t\t\t\t\tx733ProbableCause= OOSSProbableCause.getStringforEnum((short) _openNMSalarm.getX733ProbableCause());\n\t\t\t\t}catch (Exception e){\n\t\t\t\t\tx733ProbableCause=\"X733 Probable Cause Incorrectly Defined\";\n\t\t\t\t}\n\n\t\t\t\talarmValueSpecification.setAdditionalText(\n\t\t\t\t\t\t\"<alarmid>\"  + alarmid + \"<\/alarmid>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<logmsg>\"+ _logmsg +\"<\/logmsg>\"+   \"\\n            \" +\n\t\t\t\t\t\t\"<uei>\" + \t_uei_no_html + \"<uei>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<x733AlarmType>\"  + x733AlarmType + \"<\/x733AlarmType>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<x733ProbableCause>\"  + x733ProbableCause + \"<\/x733ProbableCause>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<counter>\" + counter + \"<\/counter>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<reductionkey>\" + reductionkey + \"<\/reductionkey>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodeid>\" + nodeid + \"<\/nodeid>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodelabel>\" + onmsnodelabel + \"<\/nodelabel>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<ipaddress>\" + ipaddress + \"<\/ipaddress>\" +   \"\\n            \" +\n\t\t\t\t\t\t\"<description>\"+ _description +\"<\/description>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<opinstr>\" + _opinstr + \"<\/opinstr>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<asset.managedobjectinstance>\" + assetManagedObjectInstance + \"<\/asset.managedobjectinstance>\" + \"\\n            \"+              //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.managedobjecttype>\" + assetManagedObjectType + \"<\/asset.managedobjecttype>\" + \"\\n            \"+ \n\t\t\t\t\t\t\"<asset.address2>\" + assetAddress2 + \"<\/asset.address2>\" + \"\\n            \"+  //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.description>\" + assetDescription + \"<\/asset.description>\" + \"\\n\");    //TODO - was used for object instancetype\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\n\t\t} else { // is a received alarm \n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null == _opinstr) _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null == _logmsg ) _logmsg = \"NOT_SET\";\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null == _description ) _description = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setAdditionalText(_description);\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\t\t}\n\n\t\t// TODO replacement method to populate the alarm key\n\t\ttry {\n\t\t\t//populate alarm key\n\t\t\t//TODO was AlarmKey ak = new OOSSAlarmKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tAlarmKey ak= alarmValueSpecification.getAlarmKey();\n\t\t\tak.setAlarmPrimaryKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tak.setPrimaryKey(ak.getAlarmPrimaryKey());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem setting AlarmKey: \", e );\n\t\t}\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Alarm Populated\");\n\n\t\treturn alarmValueSpecification;\n\t}","id":84620,"modified_method":"/**\n\t * This method maps OpenNMS alarm to an OSS/J alarms and adds additional information\n\t * @param _openNMSalarm data to use to populate the OSS/J alarm\n\t * @param alarmValueSpecification AlarmValue object to be populated - Invariant (Specifcation) values should be already populated\n\t * @rerun the _av OSS/J AlarmValue populated with opennms data\n\t */\n\tpublic  AlarmValue populateOssjAlarmFromOpenNMSAlarm(AlarmValue alarmValueSpecification, OnmsAlarm _openNMSalarm) throws IllegalArgumentException, UnsupportedAttributeException {\n\t\tLogger log = getLog();\n\t\tString logheader=\"\\t\\t\"+this.getClass().getSimpleName()+\"populateOssjAlarmFromOpenNMSAlarm():\";\n\n\t\t//Node node = null;\n\t\tOnmsNode node = null;\n\n\t\t// Asset asset = null;\n\t\tOnmsAssetRecord asset = null;\n\n\t\tboolean isQoSDrxAlarm=false; // true if alarm is received from Qosdrx\n\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Populating alarm\");\n\n\t\t// test to see if opennms alarm already has type and instance information set. If yes then it has most likely\n\t\t// come from Qosdrx. \n\t\tif ((_openNMSalarm.getManagedObjectInstance()!=null) && (_openNMSalarm.getManagedObjectType()!=null)\n\t\t\t\t&& (!_openNMSalarm.getManagedObjectInstance().equals(\"\")) && (!_openNMSalarm.getManagedObjectType().equals(\"\"))){\n\t\t\tisQoSDrxAlarm=true;\t\t\t\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm TRUE - because OpenNMS alarm has ManagedObjectInstance and ManagedObjectType\");\n\t\t} else {\n\t\t\tisQoSDrxAlarm=false;\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm FALSE - because OpenNMS alarm NOT POPULATED ManagedObjectInstance and ManagedObjectType\");\n\t\t}\n\n\n\t\ttry {\n\t\t\t// If the alarm has both an acknowledge time and an acknowledge user\n\t\t\t// then the alarm has been acknowledged. Set the corrsponding parameters\n\t\t\t// in the OSS/J alarm\n\t\t\tif((null != _openNMSalarm.getAlarmAckTime() ) && ( null!= _openNMSalarm.getAlarmAckUser() ) )\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAckUserId(_openNMSalarm.getAlarmAckUser());\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAckTime(new Date(_openNMSalarm.getAlarmAckTime().getTime()));\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.ACKNOWLEDGED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.UNACKNOWLEDGED);\n\t\t\t}\n\n\t\t\t// if the alarm is cleared, then set the alarm cleared time\n\t\t\t// to that of the lasteventtime as this must be the time\n\t\t\t// the clear occured.\n\t\t\tif(_openNMSalarm.getSeverity() == org.opennms.web.alarm.Alarm.CLEARED_SEVERITY) {\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(null);\n\t\t\t}\n\n\t\t\t// Set the alarmRaisedTime to the FirstEventTime of the OpenNMS\n\t\t\t// alarm. Set the alarm changed time to the last event time.\n\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\tif(null != _openNMSalarm.getFirstEventTime() ){\n\t\t\t\talarmValueSpecification.setAlarmRaisedTime(new Date(_openNMSalarm.getFirstEventTime().getTime()));\n\t\t\t}\n\t\t\tif(null != _openNMSalarm.getLastEventTime() ) {\n\t\t\t\talarmValueSpecification.setAlarmChangedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\n\n\t\t} catch (Exception e ){\n\t\t\tlog.error(logheader+\": Problem getting ACK time information\", e);\n\t\t}\n\n\n\t\tString _uei_no_html =\"NOT_SET\";\n\t\ttry{\n\t\t\tString uei = _openNMSalarm.getUei();\n\t\t\tif (null != uei) {\n\t\t\t\tmatcher = p.matcher(uei);\n\t\t\t\t_uei_no_html = matcher.replaceAll(\" \"); // remove any HTML tags from uei\n\t\t\t}\n\t\t\talarmValueSpecification.setAlarmType((_openNMSalarm.getX733AlarmType()==null) ? javax.oss.fm.monitor.AlarmType.EQUIPMENT_ALARM :  _openNMSalarm.getX733AlarmType());\n\t\t} catch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting  X733AlarmType or Uei\", e);\n\t\t}\n\n\t\t// Get some local node information as to where the alarm came from\n\t\t// This includes, what type of managed element the node is\n\t\t// and what its node id and label are.*/\n//\t\tString mftr = \"NOT_SET\"; // FIXME: Not read\n//\t\tString modelNo = \"NOT_SET\"; // FIXME: Not read\n//\t\tString assetserno = \"NOT_SET\"; // FIXME: Not read\n//\t\tString nodelabel = \"NOT_SET\"; // FIXME: Not read\n//\t\tString alarmIP = \"NOT_SET\"; // FIXME: Not read\n\t\tString managedObjectType = \"NOT_SET\";\n\t\tString managedObjectInstance =  \"NOT_SET\"; \n\t\tString assetManagedObjectType = \"NOT_SET\";\n\t\tString assetManagedObjectInstance =  \"NOT_SET\"; \n\n\t\tString assetDescription =  \"NOT_SET\";\n\t\tString assetAddress2 =  \"NOT_SET\";\n\n\t\tif (!isQoSDrxAlarm ) { // if is locally generated alarm\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// some opennms alarms don't have node information\n\t\t\t\t// set default values if no node information present\n\t\t\t\tif (_openNMSalarm.getNode()!=null) {\n\t\t\t\t\tnode=ossDao.findNodeByID(_openNMSalarm.getNode().getId());\n\n\t\t\t\t\tasset =node.getAssetRecord();\n\n//\t\t\t\t\talarmIP = _openNMSalarm.getIpAddr(); // Not read\n//\t\t\t\t\tif (node != null) {\n//\t\t\t\t\tnodelabel = node.getLabel(); // Not read\n//\t\t\t\t\t}\n\t\t\t\t\tif (asset != null) {\n//\t\t\t\t\t\tif (asset.getManufacturer()!= null) mftr = asset.getManufacturer(); // Not read\n//\t\t\t\t\t\tif (asset.getModelNumber()!= null) modelNo = asset.getModelNumber(); // Not read\n//\t\t\t\t\t\tif (asset.getSerialNumber()!= null) assetserno = asset.getSerialNumber(); // Not read\n\t\t\t\t\t\tif (asset.getDescription()!= null) assetDescription = asset.getDescription();  // TODO was used for managed object class as is 128 char long\n\t\t\t\t\t\tif (asset.getAddress2()!= null) assetAddress2 = asset.getAddress2();        // TODO was used for managed object instance - as is 256 char long string\n\t\t\t\t\t\tif (asset.getManagedObjectInstance()!= null) assetManagedObjectInstance = asset.getManagedObjectInstance();\n\t\t\t\t\t\tif (asset.getManagedObjectType()!= null) assetManagedObjectType = asset.getManagedObjectType();\n\t\t\t\t\t}\n\n\t\t\t\t\tmanagedObjectInstance= assetManagedObjectInstance;\n\t\t\t\t\tmanagedObjectType = assetManagedObjectType;\n\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=FALSE  OpenNMS type and instance not set. Using from Node Asset record: ManagedObjectInstance: \"\n\t\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception ex) {\n\t\t\t\tlog.error(logheader+\": Problem getting node and asset information\", ex);\n\t\t\t}\n\t\t} else { // is a received alarm\n\t\t\ttry {\n\t\t\t\tmanagedObjectInstance= _openNMSalarm.getManagedObjectInstance();\n\t\t\t\tmanagedObjectType =_openNMSalarm.getManagedObjectType();\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=TRUE  OpenNMS type and instance set. Using from OnmsAlarm: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t} \n\t\t\tcatch(Exception ex)\t{\n\t\t\t\tlog.error(logheader+\": Problem managedObjectInstance or managedObjectType\", ex);\n\t\t\t}\n\n\t\t}\n\n\t\talarmValueSpecification.setManagedObjectClass(managedObjectType);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectClass set to: \"+ managedObjectType);\n\n\t\talarmValueSpecification.setManagedObjectInstance(managedObjectInstance);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectInstance set to: \"+ managedObjectInstance);\n\n\t\t// set severity and probable cause\n\t\ttry {\t\t\t\n\t\t\talarmValueSpecification.setPerceivedSeverity(onmsSeverityToOssjSeverity(_openNMSalarm.getSeverity()));\n\n//\t\t\talarmValueSpecification.setProbableCause((short)-1); // OSS/J set to -1  then text contains description\n\t\t\talarmValueSpecification.setProbableCause((short)_openNMSalarm.getX733ProbableCause());\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting severity or probable cause: \", e );\n\t\t}\n\n\t\tif (!isQoSDrxAlarm ) { // if is a locally generated alarm\n\n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null != _opinstr) {\n\t\t\t\t\tmatcher = p.matcher(_opinstr);\n\t\t\t\t\t_opinstr = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null != _logmsg ) {\n\t\t\t\t\tmatcher = p.matcher(_logmsg );\n\t\t\t\t\t_logmsg  = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _logmsg = \"NOT_SET\";\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null != _description ) {\n\t\t\t\t\tmatcher = p.matcher(_description );\n\t\t\t\t\t_description  = matcher.replaceAll(\" \"); // remove all HTML tags from description\n\t\t\t\t}\n\t\t\t\telse _description = \"NOT_SET\";\n\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\t\t\t\tInteger alarmid= _openNMSalarm.getId();\n\t\t\t\tInteger counter= _openNMSalarm.getCounter();\n\t\t\t\tString reductionkey= _openNMSalarm.getReductionKey();\n\t\t\t\t\n\t\t\t\t// note some OnmsAlarms can have null nodes - we use a default value of 0 for ID\n\t\t\t\tInteger nodeid=0;\n\t\t\t\tString onmsnodelabel=\"\";\n\t\t\t\tif (_openNMSalarm.getNode()!= null) {\n\t\t\t\t\tnodeid= _openNMSalarm.getNode().getId();\n\t\t\t\t\tonmsnodelabel= _openNMSalarm.getNode().getLabel();\n\t\t\t\t}\n\t\t\t\tString ipaddress= _openNMSalarm.getIpAddr();\n\t\t\t\tString x733AlarmType= _openNMSalarm.getX733AlarmType();\n\t\t\t\tString x733ProbableCause;\n\t\t\t\ttry {\n\t\t\t\t\tx733ProbableCause= OOSSProbableCause.getStringforEnum((short) _openNMSalarm.getX733ProbableCause());\n\t\t\t\t}catch (Exception e){\n\t\t\t\t\tx733ProbableCause=\"X733 Probable Cause Incorrectly Defined\";\n\t\t\t\t}\n\n\t\t\t\talarmValueSpecification.setAdditionalText(\n\t\t\t\t\t\t\"<alarmid>\"  + alarmid + \"<\/alarmid>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<logmsg>\"+ _logmsg +\"<\/logmsg>\"+   \"\\n            \" +\n\t\t\t\t\t\t\"<uei>\" + \t_uei_no_html + \"<uei>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<x733AlarmType>\"  + x733AlarmType + \"<\/x733AlarmType>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<x733ProbableCause>\"  + x733ProbableCause + \"<\/x733ProbableCause>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<counter>\" + counter + \"<\/counter>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<reductionkey>\" + reductionkey + \"<\/reductionkey>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodeid>\" + nodeid + \"<\/nodeid>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodelabel>\" + onmsnodelabel + \"<\/nodelabel>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<ipaddress>\" + ipaddress + \"<\/ipaddress>\" +   \"\\n            \" +\n\t\t\t\t\t\t\"<description>\"+ _description +\"<\/description>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<opinstr>\" + _opinstr + \"<\/opinstr>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<asset.managedobjectinstance>\" + assetManagedObjectInstance + \"<\/asset.managedobjectinstance>\" + \"\\n            \"+              //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.managedobjecttype>\" + assetManagedObjectType + \"<\/asset.managedobjecttype>\" + \"\\n            \"+ \n\t\t\t\t\t\t\"<asset.address2>\" + assetAddress2 + \"<\/asset.address2>\" + \"\\n            \"+  //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.description>\" + assetDescription + \"<\/asset.description>\" + \"\\n\");    //TODO - was used for object instancetype\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\n\t\t} else { // is a received alarm \n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null == _opinstr) _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null == _logmsg ) _logmsg = \"NOT_SET\";\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null == _description ) _description = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setAdditionalText(_description);\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\t\t}\n\n\t\t// TODO replacement method to populate the alarm key\n\t\ttry {\n\t\t\t//populate alarm key\n\t\t\t//TODO was AlarmKey ak = new OOSSAlarmKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tAlarmKey ak= alarmValueSpecification.getAlarmKey();\n\t\t\tak.setAlarmPrimaryKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tak.setPrimaryKey(ak.getAlarmPrimaryKey());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem setting AlarmKey: \", e );\n\t\t}\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Alarm Populated\");\n\n\t\treturn alarmValueSpecification;\n\t}","commit_id":"b7e8a9ee6977eec0e7c80a4192091a38d7b298c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * method to run in transaction to update from database\n\t */\n\tprivate void localUpdateAlarmCacheTransaction(){\n\t\tLogger log = getLog();\t\n\n\n\t\tCollection<OnmsAlarm> c = _alarmDao.findAll();\n\n\t\talarmCacheByID= new Hashtable<Integer,OnmsAlarm>(); // clear previous hashtable\n\t\talarmCacheByUniqueKey = new Hashtable<String,OnmsAlarm>();\n\t\tOnmsAlarm[] alarms= (OnmsAlarm[]) c.toArray(new OnmsAlarm[c.size()]);\n\t\t//TODO - ISSUE if too many alarms?\n\t\tfor (int i=0; i<alarms.length; i++){\n\t\t\tOnmsAlarm newalarm=alarms[i];\n\t\t\tnewalarm.getNode().getLabel(); // force node to retreive inner contents\n\n\t\t\talarmCacheByID.put(new Integer (newalarm.getId()), newalarm);\n\n\t\t\t// only update alarmCacheByUniqueKey if key is not null or empty\n\t\t\tif ( ! (\n\t\t\t\t\t(newalarm.getApplicationDN()==null)||\n\t\t\t\t\t(newalarm.getOssPrimaryKey()==null)||\n\t\t\t\t\t(newalarm.getApplicationDN().equals(\"\")) ||\n\t\t\t\t\t(newalarm.getOssPrimaryKey().equals(\"\")) )\n\t\t\t) {\n\t\t\t\tString uniqueKey=newalarm.getApplicationDN()+newalarm.getOssPrimaryKey();\n\t\t\t\tif (alarmCacheByUniqueKey.get(uniqueKey)==null) {\n\t\t\t\t\talarmCacheByUniqueKey.put(uniqueKey, newalarm);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().localUpdateAlarmCache(): ERROR - duplicate alarm uniqueKey in database =\"+ uniqueKey +\" AlarmID:\"+newalarm.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","id":84621,"modified_method":"/**\n\t * method to run in transaction to update from database\n\t */\n\tprivate void localUpdateAlarmCacheTransaction(){\n\t\tLogger log = getLog();\t\n\n\n\t\tCollection<OnmsAlarm> c = _alarmDao.findAll();\n\n\t\talarmCacheByID= new Hashtable<Integer,OnmsAlarm>(); // clear previous hashtable\n\t\talarmCacheByUniqueKey = new Hashtable<String,OnmsAlarm>();\n\t\tOnmsAlarm[] alarms= (OnmsAlarm[]) c.toArray(new OnmsAlarm[c.size()]);\n\t\t//TODO - ISSUE if too many alarms?\n\t\tfor (int i=0; i<alarms.length; i++){\n\t\t\tOnmsAlarm newalarm=alarms[i];\n\t\t\t// retrieve inner contents of alarm node if there is a node associated with the alarm\n\t\t\tif (newalarm.getNode()!=null) {\n\t\t\t\tnewalarm.getNode().getLabel();\n\t\t\t}\n\n\t\t\talarmCacheByID.put(new Integer (newalarm.getId()), newalarm);\n\n\t\t\t// only update alarmCacheByUniqueKey if key is not null or empty\n\t\t\tif ( ! (\n\t\t\t\t\t(newalarm.getApplicationDN()==null)||\n\t\t\t\t\t(newalarm.getOssPrimaryKey()==null)||\n\t\t\t\t\t(newalarm.getApplicationDN().equals(\"\")) ||\n\t\t\t\t\t(newalarm.getOssPrimaryKey().equals(\"\")) )\n\t\t\t) {\n\t\t\t\tString uniqueKey=newalarm.getApplicationDN()+newalarm.getOssPrimaryKey();\n\t\t\t\tif (alarmCacheByUniqueKey.get(uniqueKey)==null) {\n\t\t\t\t\talarmCacheByUniqueKey.put(uniqueKey, newalarm);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().localUpdateAlarmCache(): ERROR - duplicate alarm uniqueKey in database =\"+ uniqueKey +\" AlarmID:\"+newalarm.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"b7e8a9ee6977eec0e7c80a4192091a38d7b298c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Update the node cache from the OpenNMS database\n\t * This must be run at least once to ensure that node data is available\n\t * Not Thread Safe - only to be called from within the synchronised methods\n\t */\n\tprivate void localUpdateNodeCaches(){\n\t\tLogger log = getLog();\t\n\t\ttry{\n\t\t\tnodeCacheByID=new Hashtable<Integer,OnmsNode>();\n\t\t\tnodeCacheByLabel=new Hashtable<String,OnmsNode>();\n\t\t\tnodeCacheByUniqueID=new Hashtable<String,OnmsNode>();\t\n\n\t\t\tif (log.isDebugEnabled()) log.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updating Node Caches :\");\n\n\t\t\tCollection<OnmsNode> c = _nodeDao.findAll();\n\t\t\tOnmsNode[] nodelist= (OnmsNode[]) c.toArray(new OnmsNode[c.size()]);\n\t\t\tfor (int i=0; i<nodelist.length; i++){\n\t\t\t\tOnmsNode node=(OnmsNode)nodelist[i];\n\t\t\t\ttry {\n\t\t\t\t\t// update node by ID cache\n\t\t\t\t\tthis.nodeCacheByID.put((Integer)node.getId(), node);\n\n\t\t\t\t\t// update node by Label cache\n\t\t\t\t\tif (node.getLabel()!=null) {\n\t\t\t\t\t\tif (nodeCacheByLabel.get((String)node.getLabel())!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label:\"+node.getId()+\" is duplicated\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByLabel.put((String)node.getLabel(), node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label is Not putting node in nodeCacheByLabel\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// update node by Unique ID -managedObjectInstance+ManagedObjectType \n\t\t\t\t\tOnmsAssetRecord assetRecord = node.getAssetRecord();\n\t\t\t\t\tif (assetRecord==null) {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" assetRecord is NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif ((assetRecord.getManagedObjectInstance()==null) || (assetRecord.getManagedObjectType()==null)){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" ManagedObjectInstance and/or ManagedObjectType are NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString uniqueid=assetRecord.getManagedObjectInstance()+assetRecord.getManagedObjectType();\n\t\t\t\t\t\t\tif (nodeCacheByUniqueID.get((String)uniqueid)!=null){\n\t\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\n\t\t\t\t\t\t\t\t\t\t\"Unique ID is duplicated. Unique ID = ManagedObjectInstance:\"+assetRecord.getManagedObjectInstance()+\"+ ManagedObjectType:\"+assetRecord.getManagedObjectType());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnodeCacheByUniqueID.put(uniqueid, node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t} catch (Exception ex){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches Error updating node caches: ERROR : \", ex);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByID : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (Integer id : nodeCacheByID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByID.get(id);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Node ID:\"+id+\"\\tNodeLabel:\"+node.getLabel());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents Error:\",e);\n\t\t\t\t}\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByLabel : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (String label : nodeCacheByLabel.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByLabel.get(label);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Label:\"+label+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents. Error:\",e);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByUniqueID : contents :\");\n\t\t\t\t\tfor (String uniqueID : nodeCacheByUniqueID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByUniqueID.get(uniqueID);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: uniqueID:\"+uniqueID+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByUniqueID contents Error:\",e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex){\n\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches ERROR : \", ex);\n\t\t}\n\t}","id":84622,"modified_method":"/**\n\t * Update the node cache from the OpenNMS database\n\t * This must be run at least once to ensure that node data is available\n\t * Not Thread Safe - only to be called from within the synchronised methods\n\t */\n\tprivate void localUpdateNodeCaches(){\n\t\tLogger log = getLog();\t\n\t\ttry{\n\t\t\tnodeCacheByID=new Hashtable<Integer,OnmsNode>();\n\t\t\tnodeCacheByLabel=new Hashtable<String,OnmsNode>();\n\t\t\tnodeCacheByUniqueID=new Hashtable<String,OnmsNode>();\t\n\n\t\t\tif (log.isDebugEnabled()) log.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updating Node Caches :\");\n\n\t\t\tCollection<OnmsNode> c = _nodeDao.findAll();\n\t\t\tOnmsNode[] nodelist= (OnmsNode[]) c.toArray(new OnmsNode[c.size()]);\n\t\t\tfor (int i=0; i<nodelist.length; i++){\n\t\t\t\tOnmsNode node=(OnmsNode)nodelist[i];\n\t\t\t\ttry {\n\t\t\t\t\t// update node by ID cache\n\t\t\t\t\tthis.nodeCacheByID.put((Integer)node.getId(), node);\n\n\t\t\t\t\t// update node by Label cache\n\t\t\t\t\tif (node.getLabel()!=null) {\n\t\t\t\t\t\tif (nodeCacheByLabel.get((String)node.getLabel())!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label:\"+node.getId()+\" is duplicated\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByLabel.put((String)node.getLabel(), node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label is NULL. Not putting node in nodeCacheByLabel\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// update node by Unique ID -managedObjectInstance+ManagedObjectType \n\t\t\t\t\tfinal OnmsAssetRecord assetRecord = node.getAssetRecord();\n\t\t\t\t\tif (assetRecord==null) {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" assetRecord is NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Note that the node asset record data for instance and type are only filled \n\t\t\t\t\t\t// given default values once - subsequently changes must be explicitly set directly\n\t\t\t\t\t\t// in the database\n\t\t\t\t\t\tString moi=assetRecord.getManagedObjectInstance();\n\t\t\t\t\t\tif ((moi==null)||(\"\".equals(moi))){\n\t\t\t\t\t\t\tString fid  = (node.getForeignId()==null) ? \"\" : node.getForeignId();\n\t\t\t\t\t\t\tString fsrc = (node.getForeignSource()==null) ? \"\" : node.getForeignSource() ;\n\t\t\t\t\t\t\tString label= (node.getLabel()==null) ? \"\" : node.getLabel();\n\t\t\t\t\t\t\tmoi  = \"Label:\"+label+\":ForeignSource:\"+fsrc+\":ForeignId():\"+fid;\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()\n\t\t\t\t\t\t\t\t\t+\" ManagedObjectInstance is NULL. Setting  ManagedObjectInstance to: \"+moi);\n\t\t\t\t\t\t\tassetRecord.setManagedObjectInstance(moi);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString mot=assetRecord.getManagedObjectType();\n\t\t\t\t\t\tif ((mot==null)||(\"\".equals(mot))){\n\t\t\t\t\t\t\tmot=\"UNSPECIFIED_TYPE\";\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"\n\t\t\t\t\t\t\t\t\t+node.getId()+\"ManagedObjectType was NULL. Setting ManagedObjectType to: \"+mot);\n\t\t\t\t\t\t\tassetRecord.setManagedObjectType(mot);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// save asset data back with new node information \n\t\t\t\t\t\t// (Note - data may not have changed)\n\t\t\t\t\t\ttransTemplate.execute(new TransactionCallback() {\n\t\t\t\t\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\t\t\t\t\t_assetRecordDao.update(assetRecord);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// update nodeCacheByUniqueID\n\t\t\t\t\t\tString uniqueid=assetRecord.getManagedObjectInstance()+assetRecord.getManagedObjectType();\n\t\t\t\t\t\tif (nodeCacheByUniqueID.get((String)uniqueid)!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\n\t\t\t\t\t\t\t\t\t\t\" Unique ID is duplicated. Unique ID = ManagedObjectInstance:\"+assetRecord.getManagedObjectInstance()+\"+ ManagedObjectType:\"+assetRecord.getManagedObjectType());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByUniqueID.put(uniqueid, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches Error updating node caches: ERROR : \", ex);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByID : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (Integer id : nodeCacheByID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByID.get(id);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Node ID:\"+id+\"\\tNodeLabel:\"+node.getLabel());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents Error:\",e);\n\t\t\t\t}\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByLabel : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (String label : nodeCacheByLabel.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByLabel.get(label);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Label:\"+label+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents. Error:\",e);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByUniqueID : contents :\");\n\t\t\t\t\tfor (String uniqueID : nodeCacheByUniqueID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByUniqueID.get(uniqueID);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: uniqueID:\"+uniqueID+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByUniqueID contents Error:\",e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex){\n\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches ERROR : \", ex);\n\t\t}\n\t}","commit_id":"b7e8a9ee6977eec0e7c80a4192091a38d7b298c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onNotifyNewAlarmEvent(NotifyNewAlarmEvent nnae, OssBeanAlarmEventReceiver callingAer) {\n\t\t//\tGet a reference to the QoSD logger instance assigned by OpenNMS\n\t\tLogger log = getLog();\t\n\t\tString logheader=\"RX:\"+callingAer.getName()+\":\"+this.getClass().getSimpleName()+\".onNotifyNewAlarmEvent(): \";\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\"\\n    Statistics:\" +callingAer.getRuntimeStatistics());\n\t\tif (!initialised ){\n\t\t\tlog.error(logheader+\"event handler not initialised. init() must be called by receiver before handling any events\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//TODO ADD IN BUSINESS LOGIC\n\n\t\ttry{\n\t\t\tOnmsAlarm alarm=null;\n\t\t\tString ossPrimaryKey=nnae.getAlarmKey().getAlarmPrimaryKey();\n\t\t\tString applicationDN=nnae.getAlarmKey().getApplicationDN();\n\t\t\tif (log.isDebugEnabled()) \n\t\t\t\tlog.debug(logheader+\": Received an onNotifyNewAlarmEvent() - AlarmPrimaryKey: \"\n\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN +\" eventtime: \" + nnae.getEventTime());\n\t\t\tif (log.isDebugEnabled())log.debug(logheader+\":Using this OssDao (toString):\"+ossDao.toString());\n\t\t\tif ((applicationDN==null)||(applicationDN.equals(\"\")) || (ossPrimaryKey==null)||(ossPrimaryKey.equals(\"\"))) {\n\t\t\t\tlog.error(logheader+\" ApplicatioDN or PrimaryKey not set\");\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating new alarm\");\n\n//\t\t\t\talarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);\n//\t\t\t\tif (alarm!=null) { // already an alarm with this unique id - log error\n//\t\t\t\tlog.error(logheader+\" Alarm Already exists with this Unique ID\");\n//\t\t\t\t} else {\n\t\t\t\talarm=new OnmsAlarm();\n\t\t\t\t\n\t\t\t\talarm.setUei(onmsAlarmOssjMapper.ossjAlarmTypeToUei(nnae.getAlarmType()));\n\t\t\t\t\n\t\t\t\talarm.setX733AlarmType((nnae.getAlarmType()==null) ? \"\" : nnae.getAlarmType());\n\t\t\t\talarm.setX733ProbableCause(nnae.getProbableCause());\n\n\t\t\t\talarm.setTTicketState(null); // needed?\n\t\t\t\talarm.setTTicketId(\"\"); // TODO changed\n\t\t\t\talarm.setQosAlarmState(\"external_type\"); // TODO changed\t\t\t\t\n\t\t\t\talarm.setSuppressedUser(\"\"); // needed?\n\t\t\t\talarm.setSuppressedUntil(new Date()); // needed?\n\t\t\t\talarm.setSuppressedTime(new Date()); // needed?\n\n\t\t\t\tInteger onmsseverity;\n\t\t\t\ttry{\n\t\t\t\t\tonmsseverity= onmsAlarmOssjMapper.ossjSeveritytoOnmsSeverity(nnae.getPerceivedSeverity());\n\t\t\t\t} catch (IllegalArgumentException iae){\n\t\t\t\t\tlog.error(logheader+\" problem setting severity used default:'WARNING'. Exception:\"+ iae);\n\t\t\t\t\tonmsseverity=new Integer(org.opennms.web.alarm.Alarm.WARNING_SEVERITY);\n\t\t\t\t}\n\t\t\t\talarm.setSeverity(onmsseverity); \n\n//TODO not needed\n//\t\t\t\tOnmsServiceType service= new OnmsServiceType();\n//\t\t\t\tservice.setId(new Integer(-1));\n//\t\t\t\talarm.setServiceType(new OnmsServiceType()); // needed?\n\n\n\t\t\t\talarm.setReductionKey(\":managedObjectInstance:\"+nnae.getManagedObjectInstance()+\n\t\t\t\t\t\t\":managedObjectType:\"+nnae.getManagedObjectClass()+\n\t\t\t\t\t\t\":ossPrimaryKey:-\"+ossPrimaryKey+\n\t\t\t\t\t\t\":applicationDN:-\"+applicationDN); // must be unique because of alarm_reductionkey_idx\n\n\t\t\t\talarm.setOssPrimaryKey(ossPrimaryKey);\n\t\t\t\talarm.setOperInstruct(nnae.getProposedRepairActions()); \n\n\t\t\t\t// defaultvalue if search fails - will update node with ID 1\n\t\t\t\tOnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\talarm.setNode(node); // \n\n\t\t\t\tif (almUpdateBehaviour==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse if (callingAer.getName()==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver has no name: default alarms will update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour);\n\n\t\t\t\t\tif (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {\n\t\t\t\t\t\t// this will look for first match of node label to callingAer.getName()\n\t\t\t\t\t\t// and set node id to this value.\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" SPECIFY_OUTSTATION looking for node with nodelabel:\"+callingAer.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// TODO temp remove ?\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tnode =ossDao.findNodeByLabel(callingAer.getName());\n\t\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node \"+ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} \n\t\t\t\t\telse if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){\n\t\t\t\t\t\t// this will look for first match of node Managed object Instance and Managed Object type\n\t\t\t\t\t\t// and set node id to this value. \n\t\t\t\t\t\tString managedObjectType=nnae.getManagedObjectClass();\n\t\t\t\t\t\tString managedObjectInstance=nnae.getManagedObjectInstance();\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" USE_TYPE_INSTANCE looking for node with managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnode =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();\n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.error(logheader+\" Invalid value for alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour+\" defaulting to update nodeID:1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\talarm.setMouseOverText(\"\"); // needed?\n\t\t\t\talarm.setManagedObjectType(nnae.getManagedObjectClass());\n\t\t\t\talarm.setManagedObjectInstance(nnae.getManagedObjectInstance());\n\t\t\t\talarm.setLogMsg(nnae.getSpecificProblem());\n\n\t\t\t\t// NOTE - this has no effect here as .setLastEvent nulls value\n\t\t\t\t// alarm.setLastEventTime(nnae.getEventTime());\n//TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo\n//\t\t\t\tOnmsEvent event= new OnmsEvent();\n//\t\t\t\t//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table\n//\t\t\t\talarm.setLastEvent(event); \n\n\t\t\t\talarm.setIpAddr(\"localhost\"); // needed?\n\t\t\t\talarm.setId(null); // set null as updating alarm\n\t\t\t\talarm.setFirstEventTime(nnae.getEventTime());\n\t\t\t\talarm.setLastEventTime(nnae.getEventTime());\n\t\t\t\t\n// TODO removed - do create distpoller with hibernate dao\t\t\t\t\n//\t\t\t\talarm.setDistPoller(new OnmsDistPoller(\"undefined\",\"localhost\")); //simple constructor\n\t\t\t\talarm.setDistPoller(distPollerDao.get(\"localhost\"));\n\t\t\t\t\n\t\t\t\talarm.setDescription(nnae.getAdditionalText()); //TODO need Qosd Not to generate this if remote\n\t\t\t\talarm.setCounter(new Integer(1));\n\t\t\t\talarm.setClearUei(\"\");\n\t\t\t\talarm.setApplicationDN(applicationDN);\n\t\t\t\talarm.setAlarmType(new Integer(1)); // set to raise alarm\n\t\t\t\t//alarm.setAlarmAckUser(arg0);\n\t\t\t\t//alarm.setAlarmAckTime(arg0);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating Alarm: \" );\n\t\t\t\t\tOnmsAlarm updatedAlarm = ossDao.addCurrentAlarmForUniqueKey(alarm);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(logheader+\": Created alarm:\"\n\t\t\t\t\t\t\t\t+ ossDao.alarmToString(updatedAlarm));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( Exception ex ) {\n\t\t\t\t\tlog.error(logheader+\": problem creating new alarm AlarmPrimaryKey: \"\n\t\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN+\": \"+ ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO remove\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tlog.error(logheader+\" Error : \", e);\n\t\t}\n\t}","id":84623,"modified_method":"public void onNotifyNewAlarmEvent(NotifyNewAlarmEvent nnae, OssBeanAlarmEventReceiver callingAer) {\n\t\t//\tGet a reference to the QoSD logger instance assigned by OpenNMS\n\t\tLogger log = getLog();\t\n\t\tString logheader=\"RX:\"+callingAer.getName()+\":\"+this.getClass().getSimpleName()+\".onNotifyNewAlarmEvent(): \";\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\"\\n    Statistics:\" +callingAer.getRuntimeStatistics());\n\t\tif (!initialised ){\n\t\t\tlog.error(logheader+\"event handler not initialised. init() must be called by receiver before handling any events\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//TODO ADD IN BUSINESS LOGIC\n\n\t\ttry{\n\t\t\tOnmsAlarm alarm=null;\n\t\t\tString ossPrimaryKey=nnae.getAlarmKey().getAlarmPrimaryKey();\n\t\t\tString applicationDN=nnae.getAlarmKey().getApplicationDN();\n\t\t\tif (log.isDebugEnabled()) \n\t\t\t\tlog.debug(logheader+\": Received an onNotifyNewAlarmEvent() - AlarmPrimaryKey: \"\n\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN +\" eventtime: \" + nnae.getEventTime());\n\t\t\tif (log.isDebugEnabled())log.debug(logheader+\":Using this OssDao (toString):\"+ossDao.toString());\n\t\t\tif ((applicationDN==null)||(applicationDN.equals(\"\")) || (ossPrimaryKey==null)||(ossPrimaryKey.equals(\"\"))) {\n\t\t\t\tlog.error(logheader+\" ApplicatioDN or PrimaryKey not set\");\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating new alarm\");\n\n//\t\t\t\talarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);\n//\t\t\t\tif (alarm!=null) { // already an alarm with this unique id - log error\n//\t\t\t\tlog.error(logheader+\" Alarm Already exists with this Unique ID\");\n//\t\t\t\t} else {\n\t\t\t\talarm=new OnmsAlarm();\n\t\t\t\t\n\t\t\t\talarm.setUei(onmsAlarmOssjMapper.ossjAlarmTypeToUei(nnae.getAlarmType()));\n\t\t\t\t\n\t\t\t\talarm.setX733AlarmType((nnae.getAlarmType()==null) ? \"\" : nnae.getAlarmType());\n\t\t\t\talarm.setX733ProbableCause(nnae.getProbableCause());\n\n\t\t\t\talarm.setTTicketState(null); // needed?\n\t\t\t\talarm.setTTicketId(\"\"); // TODO changed\n\t\t\t\talarm.setQosAlarmState(\"external_type\"); // TODO changed\t\t\t\t\n\t\t\t\talarm.setSuppressedUser(\"\"); // needed?\n\t\t\t\talarm.setSuppressedUntil(new Date()); // needed?\n\t\t\t\talarm.setSuppressedTime(new Date()); // needed?\n\n\t\t\t\tInteger onmsseverity;\n\t\t\t\ttry{\n\t\t\t\t\tonmsseverity= onmsAlarmOssjMapper.ossjSeveritytoOnmsSeverity(nnae.getPerceivedSeverity());\n\t\t\t\t} catch (IllegalArgumentException iae){\n\t\t\t\t\tlog.error(logheader+\" problem setting severity used default:'WARNING'. Exception:\"+ iae);\n\t\t\t\t\tonmsseverity=new Integer(org.opennms.web.alarm.Alarm.WARNING_SEVERITY);\n\t\t\t\t}\n\t\t\t\talarm.setSeverity(onmsseverity); \n\n//TODO not needed\n//\t\t\t\tOnmsServiceType service= new OnmsServiceType();\n//\t\t\t\tservice.setId(new Integer(-1));\n//\t\t\t\talarm.setServiceType(new OnmsServiceType()); // needed?\n\n\n\t\t\t\talarm.setReductionKey(\":managedObjectInstance:\"+nnae.getManagedObjectInstance()+\n\t\t\t\t\t\t\":managedObjectType:\"+nnae.getManagedObjectClass()+\n\t\t\t\t\t\t\":ossPrimaryKey:-\"+ossPrimaryKey+\n\t\t\t\t\t\t\":applicationDN:-\"+applicationDN); // must be unique because of alarm_reductionkey_idx\n\n\t\t\t\talarm.setOssPrimaryKey(ossPrimaryKey);\n\t\t\t\talarm.setOperInstruct(nnae.getProposedRepairActions()); \n\n\t\t\t\t// defaultvalue if search fails - will update node with ID 1\n\t\t\t\tOnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\talarm.setNode(node); // \n\n\t\t\t\tif (almUpdateBehaviour==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse if (callingAer.getName()==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver has no name: default alarms will update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour);\n\n\t\t\t\t\tif (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {\n\t\t\t\t\t\t// this will look for first match of node label to callingAer.getName()\n\t\t\t\t\t\t// and set node id to this value.\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" SPECIFY_OUTSTATION looking for node with nodelabel:\"+callingAer.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// TODO temp remove ?\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tnode =ossDao.findNodeByLabel(callingAer.getName());\n\t\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node \"+ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} \n\t\t\t\t\telse if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){\n\t\t\t\t\t\t// this will look for first match of node Managed object Instance and Managed Object type\n\t\t\t\t\t\t// and set node id to this value. \n\t\t\t\t\t\tString managedObjectType=nnae.getManagedObjectClass();\n\t\t\t\t\t\tString managedObjectInstance=nnae.getManagedObjectInstance();\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" USE_TYPE_INSTANCE looking for node with managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnode =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();\n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.error(logheader+\" Invalid value for alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour+\" defaulting to update nodeID:1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\talarm.setMouseOverText(\"\"); // needed?\n\t\t\t\talarm.setManagedObjectType(nnae.getManagedObjectClass());\n\t\t\t\talarm.setManagedObjectInstance(nnae.getManagedObjectInstance());\n\t\t\t\talarm.setLogMsg(nnae.getSpecificProblem());\n\n\t\t\t\t// NOTE - this has no effect here as .setLastEvent nulls value\n\t\t\t\t// alarm.setLastEventTime(nnae.getEventTime());\n//TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo\n//\t\t\t\tOnmsEvent event= new OnmsEvent();\n//\t\t\t\t//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table\n//\t\t\t\talarm.setLastEvent(event); \n\n\t\t\t\talarm.setIpAddr(\"localhost\"); // needed?\n\t\t\t\talarm.setId(null); // set null as updating alarm\n\t\t\t\talarm.setFirstEventTime(nnae.getEventTime());\n\t\t\t\talarm.setLastEventTime(nnae.getEventTime());\n\t\t\t\t\n// TODO removed - do create distpoller with hibernate dao\t\t\t\t\n//\t\t\t\talarm.setDistPoller(new OnmsDistPoller(\"undefined\",\"localhost\")); //simple constructor\n\t\t\t\talarm.setDistPoller(distPollerDao.get(\"localhost\"));\n\t\t\t\t\n\t\t\t\talarm.setDescription(nnae.getAdditionalText()); //TODO need Qosd Not to generate this if remote\n\t\t\t\talarm.setCounter(new Integer(1));\n\t\t\t\talarm.setClearUei(\"\");\n\t\t\t\talarm.setApplicationDN(applicationDN);\n\t\t\t\talarm.setAlarmType(new Integer(1)); // set to raise alarm\n\t\t\t\t//alarm.setAlarmAckUser(arg0);\n\t\t\t\t//alarm.setAlarmAckTime(arg0);\n\t\t\t\t\n\t\t\t\t//TODO added for new alarm field\n\t\t\t\tHashMap<String, String> m_details = new HashMap();\n\t\t\t\talarm.setDetails(m_details);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating Alarm: \" );\n\t\t\t\t\tOnmsAlarm updatedAlarm = ossDao.addCurrentAlarmForUniqueKey(alarm);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(logheader+\": Created alarm:\"\n\t\t\t\t\t\t\t\t+ ossDao.alarmToString(updatedAlarm));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( Exception ex ) {\n\t\t\t\t\tlog.error(logheader+\": problem creating new alarm AlarmPrimaryKey: \"\n\t\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN+\": \"+ ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO remove\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tlog.error(logheader+\" Error : \", e);\n\t\t}\n\t}","commit_id":"b7e8a9ee6977eec0e7c80a4192091a38d7b298c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * This method maps OpenNMS alarm to an OSS/J alarms and adds additional information\n\t * @param _openNMSalarm data to use to populate the OSS/J alarm\n\t * @param alarmValueSpecification AlarmValue object to be populated - Invariant (Specifcation) values should be already populated\n\t * @rerun the _av OSS/J AlarmValue populated with opennms data\n\t */\n\tpublic  AlarmValue populateOssjAlarmFromOpenNMSAlarm(AlarmValue alarmValueSpecification, OnmsAlarm _openNMSalarm) throws IllegalArgumentException, UnsupportedAttributeException {\n\t\tLogger log = getLog();\n\t\tString logheader=\"\\t\\t\"+this.getClass().getSimpleName()+\"populateOssjAlarmFromOpenNMSAlarm():\";\n\n\t\t//Node node = null;\n\t\tOnmsNode node = null;\n\n\t\t// Asset asset = null;\n\t\tOnmsAssetRecord asset = null;\n\n\t\tboolean isQoSDrxAlarm=false; // true if alarm is received from Qosdrx\n\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Populating alarm\");\n\n\t\t// test to see if opennms alarm already has type and instance information set. If yes then it has most likely\n\t\t// come from Qosdrx. \n\t\tif ((_openNMSalarm.getManagedObjectInstance()!=null) && (_openNMSalarm.getManagedObjectType()!=null)\n\t\t\t\t&& (!_openNMSalarm.getManagedObjectInstance().equals(\"\")) && (!_openNMSalarm.getManagedObjectType().equals(\"\"))){\n\t\t\tisQoSDrxAlarm=true;\t\t\t\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm TRUE - because OpenNMS alarm has ManagedObjectInstance and ManagedObjectType\");\n\t\t} else {\n\t\t\tisQoSDrxAlarm=false;\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm FALSE - because OpenNMS alarm NOT POPULATED ManagedObjectInstance and ManagedObjectType\");\n\t\t}\n\n\n\t\ttry {\n\t\t\t// If the alarm has both an acknowledge time and an acknowledge user\n\t\t\t// then the alarm has been acknowledged. Set the corrsponding parameters\n\t\t\t// in the OSS/J alarm\n\t\t\tif((null != _openNMSalarm.getAlarmAckTime() ) && ( null!= _openNMSalarm.getAlarmAckUser() ) )\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAckUserId(_openNMSalarm.getAlarmAckUser());\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAckTime(new Date(_openNMSalarm.getAlarmAckTime().getTime()));\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.ACKNOWLEDGED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.UNACKNOWLEDGED);\n\t\t\t}\n\n\t\t\t// if the alarm is cleared, then set the alarm cleared time\n\t\t\t// to that of the lasteventtime as this must be the time\n\t\t\t// the clear occured.\n\t\t\tif(_openNMSalarm.getSeverity() == org.opennms.web.alarm.Alarm.CLEARED_SEVERITY) {\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(null);\n\t\t\t}\n\n\t\t\t// Set the alarmRaisedTime to the FirstEventTime of the OpenNMS\n\t\t\t// alarm. Set the alarm changed time to the last event time.\n\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\tif(null != _openNMSalarm.getFirstEventTime() ){\n\t\t\t\talarmValueSpecification.setAlarmRaisedTime(new Date(_openNMSalarm.getFirstEventTime().getTime()));\n\t\t\t}\n\t\t\tif(null != _openNMSalarm.getLastEventTime() ) {\n\t\t\t\talarmValueSpecification.setAlarmChangedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\n\n\t\t} catch (Exception e ){\n\t\t\tlog.error(logheader+\": Problem getting ACK time information\", e);\n\t\t}\n\n\n\t\tString _uei_no_html =\"NOT_SET\";\n\t\ttry{\n\t\t\tString uei = _openNMSalarm.getUei();\n\t\t\tif (null != uei) {\n\t\t\t\tmatcher = p.matcher(uei);\n\t\t\t\t_uei_no_html = matcher.replaceAll(\" \"); // remove any HTML tags from uei\n\t\t\t}\n\t\t\talarmValueSpecification.setAlarmType((_openNMSalarm.getX733AlarmType()==null) ? javax.oss.fm.monitor.AlarmType.EQUIPMENT_ALARM :  _openNMSalarm.getX733AlarmType());\n\t\t} catch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting  X733AlarmType or Uei\", e);\n\t\t}\n\n\t\t// Get some local node information as to where the alarm came from\n\t\t// This includes, what type of managed element the node is\n\t\t// and what its node id and label are.*/\n//\t\tString mftr = \"NOT_SET\"; // FIXME: Not read\n//\t\tString modelNo = \"NOT_SET\"; // FIXME: Not read\n//\t\tString assetserno = \"NOT_SET\"; // FIXME: Not read\n//\t\tString nodelabel = \"NOT_SET\"; // FIXME: Not read\n//\t\tString alarmIP = \"NOT_SET\"; // FIXME: Not read\n\t\tString managedObjectType = \"NOT_SET\";\n\t\tString managedObjectInstance =  \"NOT_SET\"; \n\t\tString assetManagedObjectType = \"NOT_SET\";\n\t\tString assetManagedObjectInstance =  \"NOT_SET\"; \n\n\t\tString assetDescription =  \"NOT_SET\";\n\t\tString assetAddress2 =  \"NOT_SET\";\n\n\t\tif (!isQoSDrxAlarm ) { // if is locally generated alarm\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnode=ossDao.findNodeByID(_openNMSalarm.getNode().getId());\n\n\t\t\t\tasset =node.getAssetRecord();\n\n//\t\t\t\talarmIP = _openNMSalarm.getIpAddr(); // Not read\n//\t\t\t\tif (node != null) {\n//\t\t\t\t\tnodelabel = node.getLabel(); // Not read\n//\t\t\t\t}\n\t\t\t\tif (asset != null) {\n//\t\t\t\t\tif (asset.getManufacturer()!= null) mftr = asset.getManufacturer(); // Not read\n//\t\t\t\t\tif (asset.getModelNumber()!= null) modelNo = asset.getModelNumber(); // Not read\n//\t\t\t\t\tif (asset.getSerialNumber()!= null) assetserno = asset.getSerialNumber(); // Not read\n\t\t\t\t\tif (asset.getDescription()!= null) assetDescription = asset.getDescription();  // TODO was used for managed object class as is 128 char long\n\t\t\t\t\tif (asset.getAddress2()!= null) assetAddress2 = asset.getAddress2();        // TODO was used for managed object instance - as is 256 char long string\n\t\t\t\t\tif (asset.getManagedObjectInstance()!= null) assetManagedObjectInstance = asset.getManagedObjectInstance();\n\t\t\t\t\tif (asset.getManagedObjectType()!= null) assetManagedObjectType = asset.getManagedObjectType();\n\t\t\t\t}\n\n\t\t\t\tmanagedObjectInstance= assetManagedObjectInstance;\n\t\t\t\tmanagedObjectType = assetManagedObjectType;\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=FALSE  OpenNMS type and instance not set. Using from Node Asset record: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t}\n\t\t\tcatch(Exception ex) {\n\t\t\t\tlog.error(logheader+\": Problem getting node and asset information\", ex);\n\t\t\t}\n\t\t} else { // is a received alarm\n\t\t\ttry {\n\t\t\t\tmanagedObjectInstance= _openNMSalarm.getManagedObjectInstance();\n\t\t\t\tmanagedObjectType =_openNMSalarm.getManagedObjectType();\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=TRUE  OpenNMS type and instance set. Using from OnmsAlarm: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t} \n\t\t\tcatch(Exception ex)\t{\n\t\t\t\tlog.error(logheader+\": Problem managedObjectInstance or managedObjectType\", ex);\n\t\t\t}\n\n\t\t}\n\n\t\talarmValueSpecification.setManagedObjectClass(managedObjectType);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectClass set to: \"+ managedObjectType);\n\n\t\talarmValueSpecification.setManagedObjectInstance(managedObjectInstance);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectInstance set to: \"+ managedObjectInstance);\n\n\t\t// set severity and probable cause\n\t\ttry {\t\t\t\n\t\t\talarmValueSpecification.setPerceivedSeverity(onmsSeverityToOssjSeverity(_openNMSalarm.getSeverity()));\n\n//\t\t\talarmValueSpecification.setProbableCause((short)-1); // OSS/J set to -1  then text contains description\n\t\t\talarmValueSpecification.setProbableCause((short)_openNMSalarm.getX733ProbableCause());\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting severity or probable cause: \", e );\n\t\t}\n\n\t\tif (!isQoSDrxAlarm ) { // if is a locally generated alarm\n\n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null != _opinstr) {\n\t\t\t\t\tmatcher = p.matcher(_opinstr);\n\t\t\t\t\t_opinstr = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null != _logmsg ) {\n\t\t\t\t\tmatcher = p.matcher(_logmsg );\n\t\t\t\t\t_logmsg  = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _logmsg = \"NOT_SET\";\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null != _description ) {\n\t\t\t\t\tmatcher = p.matcher(_description );\n\t\t\t\t\t_description  = matcher.replaceAll(\" \"); // remove all HTML tags from description\n\t\t\t\t}\n\t\t\t\telse _description = \"NOT_SET\";\n\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\t\t\t\tInteger alarmid= _openNMSalarm.getId();\n\t\t\t\tInteger counter= _openNMSalarm.getCounter();\n\t\t\t\tString reductionkey= _openNMSalarm.getReductionKey();\n\t\t\t\tInteger nodeid= _openNMSalarm.getNode().getId();\n\t\t\t\tString onmsnodelabel= _openNMSalarm.getNode().getLabel();\n\t\t\t\tString ipaddress= _openNMSalarm.getIpAddr();\n\t\t\t\tString x733AlarmType= _openNMSalarm.getX733AlarmType();\n\t\t\t\tString x733ProbableCause;\n\t\t\t\ttry {\n\t\t\t\t\tx733ProbableCause= OOSSProbableCause.getStringforEnum((short) _openNMSalarm.getX733ProbableCause());\n\t\t\t\t}catch (Exception e){\n\t\t\t\t\tx733ProbableCause=\"X733 Probable Cause Incorrectly Defined\";\n\t\t\t\t}\n\n\t\t\t\talarmValueSpecification.setAdditionalText(\n\t\t\t\t\t\t\"<alarmid>\"  + alarmid + \"<\/alarmid>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<logmsg>\"+ _logmsg +\"<\/logmsg>\"+   \"\\n            \" +\n\t\t\t\t\t\t\"<uei>\" + \t_uei_no_html + \"<uei>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<x733AlarmType>\"  + x733AlarmType + \"<\/x733AlarmType>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<x733ProbableCause>\"  + x733ProbableCause + \"<\/x733ProbableCause>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<counter>\" + counter + \"<\/counter>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<reductionkey>\" + reductionkey + \"<\/reductionkey>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodeid>\" + nodeid + \"<\/nodeid>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodelabel>\" + onmsnodelabel + \"<\/nodelabel>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<ipaddress>\" + ipaddress + \"<\/ipaddress>\" +   \"\\n            \" +\n\t\t\t\t\t\t\"<description>\"+ _description +\"<\/description>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<opinstr>\" + _opinstr + \"<\/opinstr>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<asset.managedobjectinstance>\" + assetManagedObjectInstance + \"<\/asset.managedobjectinstance>\" + \"\\n            \"+              //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.managedobjecttype>\" + assetManagedObjectType + \"<\/asset.managedobjecttype>\" + \"\\n            \"+ \n\t\t\t\t\t\t\"<asset.address2>\" + assetAddress2 + \"<\/asset.address2>\" + \"\\n            \"+  //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.description>\" + assetDescription + \"<\/asset.description>\" + \"\\n\");    //TODO - was used for object instancetype\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\n\t\t} else { // is a received alarm \n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null == _opinstr) _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null == _logmsg ) _logmsg = \"NOT_SET\";\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null == _description ) _description = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setAdditionalText(_description);\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\t\t}\n\n\t\t// TODO replacement method to populate the alarm key\n\t\ttry {\n\t\t\t//populate alarm key\n\t\t\t//TODO was AlarmKey ak = new OOSSAlarmKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tAlarmKey ak= alarmValueSpecification.getAlarmKey();\n\t\t\tak.setAlarmPrimaryKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tak.setPrimaryKey(ak.getAlarmPrimaryKey());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem setting AlarmKey: \", e );\n\t\t}\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Alarm Populated\");\n\n\t\treturn alarmValueSpecification;\n\t}","id":84624,"modified_method":"/**\n\t * This method maps OpenNMS alarm to an OSS/J alarms and adds additional information\n\t * @param _openNMSalarm data to use to populate the OSS/J alarm\n\t * @param alarmValueSpecification AlarmValue object to be populated - Invariant (Specifcation) values should be already populated\n\t * @rerun the _av OSS/J AlarmValue populated with opennms data\n\t */\n\tpublic  AlarmValue populateOssjAlarmFromOpenNMSAlarm(AlarmValue alarmValueSpecification, OnmsAlarm _openNMSalarm) throws IllegalArgumentException, UnsupportedAttributeException {\n\t\tLogger log = getLog();\n\t\tString logheader=\"\\t\\t\"+this.getClass().getSimpleName()+\"populateOssjAlarmFromOpenNMSAlarm():\";\n\n\t\t//Node node = null;\n\t\tOnmsNode node = null;\n\n\t\t// Asset asset = null;\n\t\tOnmsAssetRecord asset = null;\n\n\t\tboolean isQoSDrxAlarm=false; // true if alarm is received from Qosdrx\n\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Populating alarm\");\n\n\t\t// test to see if opennms alarm already has type and instance information set. If yes then it has most likely\n\t\t// come from Qosdrx. \n\t\tif ((_openNMSalarm.getManagedObjectInstance()!=null) && (_openNMSalarm.getManagedObjectType()!=null)\n\t\t\t\t&& (!_openNMSalarm.getManagedObjectInstance().equals(\"\")) && (!_openNMSalarm.getManagedObjectType().equals(\"\"))){\n\t\t\tisQoSDrxAlarm=true;\t\t\t\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm TRUE - because OpenNMS alarm has ManagedObjectInstance and ManagedObjectType\");\n\t\t} else {\n\t\t\tisQoSDrxAlarm=false;\n\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm FALSE - because OpenNMS alarm NOT POPULATED ManagedObjectInstance and ManagedObjectType\");\n\t\t}\n\n\n\t\ttry {\n\t\t\t// If the alarm has both an acknowledge time and an acknowledge user\n\t\t\t// then the alarm has been acknowledged. Set the corrsponding parameters\n\t\t\t// in the OSS/J alarm\n\t\t\tif((null != _openNMSalarm.getAlarmAckTime() ) && ( null!= _openNMSalarm.getAlarmAckUser() ) )\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAckUserId(_openNMSalarm.getAlarmAckUser());\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAckTime(new Date(_openNMSalarm.getAlarmAckTime().getTime()));\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.ACKNOWLEDGED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talarmValueSpecification.setAlarmAckState(AlarmAckState.UNACKNOWLEDGED);\n\t\t\t}\n\n\t\t\t// if the alarm is cleared, then set the alarm cleared time\n\t\t\t// to that of the lasteventtime as this must be the time\n\t\t\t// the clear occured.\n\t\t\tif(_openNMSalarm.getSeverity() == org.opennms.web.alarm.Alarm.CLEARED_SEVERITY) {\n\t\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\talarmValueSpecification.setAlarmClearedTime(null);\n\t\t\t}\n\n\t\t\t// Set the alarmRaisedTime to the FirstEventTime of the OpenNMS\n\t\t\t// alarm. Set the alarm changed time to the last event time.\n\t\t\t// OnmsAlarm can contain java.sql.Timestamp - convert to Date\n\t\t\tif(null != _openNMSalarm.getFirstEventTime() ){\n\t\t\t\talarmValueSpecification.setAlarmRaisedTime(new Date(_openNMSalarm.getFirstEventTime().getTime()));\n\t\t\t}\n\t\t\tif(null != _openNMSalarm.getLastEventTime() ) {\n\t\t\t\talarmValueSpecification.setAlarmChangedTime(new Date(_openNMSalarm.getLastEventTime().getTime()));\n\t\t\t}\n\n\n\t\t} catch (Exception e ){\n\t\t\tlog.error(logheader+\": Problem getting ACK time information\", e);\n\t\t}\n\n\n\t\tString _uei_no_html =\"NOT_SET\";\n\t\ttry{\n\t\t\tString uei = _openNMSalarm.getUei();\n\t\t\tif (null != uei) {\n\t\t\t\tmatcher = p.matcher(uei);\n\t\t\t\t_uei_no_html = matcher.replaceAll(\" \"); // remove any HTML tags from uei\n\t\t\t}\n\t\t\talarmValueSpecification.setAlarmType((_openNMSalarm.getX733AlarmType()==null) ? javax.oss.fm.monitor.AlarmType.EQUIPMENT_ALARM :  _openNMSalarm.getX733AlarmType());\n\t\t} catch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting  X733AlarmType or Uei\", e);\n\t\t}\n\n\t\t// Get some local node information as to where the alarm came from\n\t\t// This includes, what type of managed element the node is\n\t\t// and what its node id and label are.*/\n//\t\tString mftr = \"NOT_SET\"; // FIXME: Not read\n//\t\tString modelNo = \"NOT_SET\"; // FIXME: Not read\n//\t\tString assetserno = \"NOT_SET\"; // FIXME: Not read\n//\t\tString nodelabel = \"NOT_SET\"; // FIXME: Not read\n//\t\tString alarmIP = \"NOT_SET\"; // FIXME: Not read\n\t\tString managedObjectType = \"NOT_SET\";\n\t\tString managedObjectInstance =  \"NOT_SET\"; \n\t\tString assetManagedObjectType = \"NOT_SET\";\n\t\tString assetManagedObjectInstance =  \"NOT_SET\"; \n\n\t\tString assetDescription =  \"NOT_SET\";\n\t\tString assetAddress2 =  \"NOT_SET\";\n\n\t\tif (!isQoSDrxAlarm ) { // if is locally generated alarm\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// some opennms alarms don't have node information\n\t\t\t\t// set default values if no node information present\n\t\t\t\tif (_openNMSalarm.getNode()!=null) {\n\t\t\t\t\tnode=ossDao.findNodeByID(_openNMSalarm.getNode().getId());\n\n\t\t\t\t\tasset =node.getAssetRecord();\n\n//\t\t\t\t\talarmIP = _openNMSalarm.getIpAddr(); // Not read\n//\t\t\t\t\tif (node != null) {\n//\t\t\t\t\tnodelabel = node.getLabel(); // Not read\n//\t\t\t\t\t}\n\t\t\t\t\tif (asset != null) {\n//\t\t\t\t\t\tif (asset.getManufacturer()!= null) mftr = asset.getManufacturer(); // Not read\n//\t\t\t\t\t\tif (asset.getModelNumber()!= null) modelNo = asset.getModelNumber(); // Not read\n//\t\t\t\t\t\tif (asset.getSerialNumber()!= null) assetserno = asset.getSerialNumber(); // Not read\n\t\t\t\t\t\tif (asset.getDescription()!= null) assetDescription = asset.getDescription();  // TODO was used for managed object class as is 128 char long\n\t\t\t\t\t\tif (asset.getAddress2()!= null) assetAddress2 = asset.getAddress2();        // TODO was used for managed object instance - as is 256 char long string\n\t\t\t\t\t\tif (asset.getManagedObjectInstance()!= null) assetManagedObjectInstance = asset.getManagedObjectInstance();\n\t\t\t\t\t\tif (asset.getManagedObjectType()!= null) assetManagedObjectType = asset.getManagedObjectType();\n\t\t\t\t\t}\n\n\t\t\t\t\tmanagedObjectInstance= assetManagedObjectInstance;\n\t\t\t\t\tmanagedObjectType = assetManagedObjectType;\n\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=FALSE  OpenNMS type and instance not set. Using from Node Asset record: ManagedObjectInstance: \"\n\t\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception ex) {\n\t\t\t\tlog.error(logheader+\": Problem getting node and asset information\", ex);\n\t\t\t}\n\t\t} else { // is a received alarm\n\t\t\ttry {\n\t\t\t\tmanagedObjectInstance= _openNMSalarm.getManagedObjectInstance();\n\t\t\t\tmanagedObjectType =_openNMSalarm.getManagedObjectType();\n\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": isQoSDrxAlarm=TRUE  OpenNMS type and instance set. Using from OnmsAlarm: ManagedObjectInstance: \"\n\t\t\t\t\t\t+ managedObjectInstance +\" ManagedObjectType:\"+managedObjectType);\n\t\t\t} \n\t\t\tcatch(Exception ex)\t{\n\t\t\t\tlog.error(logheader+\": Problem managedObjectInstance or managedObjectType\", ex);\n\t\t\t}\n\n\t\t}\n\n\t\talarmValueSpecification.setManagedObjectClass(managedObjectType);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectClass set to: \"+ managedObjectType);\n\n\t\talarmValueSpecification.setManagedObjectInstance(managedObjectInstance);\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": _av.setManagedObjectInstance set to: \"+ managedObjectInstance);\n\n\t\t// set severity and probable cause\n\t\ttry {\t\t\t\n\t\t\talarmValueSpecification.setPerceivedSeverity(onmsSeverityToOssjSeverity(_openNMSalarm.getSeverity()));\n\n//\t\t\talarmValueSpecification.setProbableCause((short)-1); // OSS/J set to -1  then text contains description\n\t\t\talarmValueSpecification.setProbableCause((short)_openNMSalarm.getX733ProbableCause());\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem getting severity or probable cause: \", e );\n\t\t}\n\n\t\tif (!isQoSDrxAlarm ) { // if is a locally generated alarm\n\n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null != _opinstr) {\n\t\t\t\t\tmatcher = p.matcher(_opinstr);\n\t\t\t\t\t_opinstr = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null != _logmsg ) {\n\t\t\t\t\tmatcher = p.matcher(_logmsg );\n\t\t\t\t\t_logmsg  = matcher.replaceAll(\" \"); // remove all HTML tags from operator instructions\n\t\t\t\t}\n\t\t\t\telse _logmsg = \"NOT_SET\";\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null != _description ) {\n\t\t\t\t\tmatcher = p.matcher(_description );\n\t\t\t\t\t_description  = matcher.replaceAll(\" \"); // remove all HTML tags from description\n\t\t\t\t}\n\t\t\t\telse _description = \"NOT_SET\";\n\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\t\t\t\tInteger alarmid= _openNMSalarm.getId();\n\t\t\t\tInteger counter= _openNMSalarm.getCounter();\n\t\t\t\tString reductionkey= _openNMSalarm.getReductionKey();\n\t\t\t\t\n\t\t\t\t// note some OnmsAlarms can have null nodes - we use a default value of 0 for ID\n\t\t\t\tInteger nodeid=0;\n\t\t\t\tString onmsnodelabel=\"\";\n\t\t\t\tif (_openNMSalarm.getNode()!= null) {\n\t\t\t\t\tnodeid= _openNMSalarm.getNode().getId();\n\t\t\t\t\tonmsnodelabel= _openNMSalarm.getNode().getLabel();\n\t\t\t\t}\n\t\t\t\tString ipaddress= _openNMSalarm.getIpAddr();\n\t\t\t\tString x733AlarmType= _openNMSalarm.getX733AlarmType();\n\t\t\t\tString x733ProbableCause;\n\t\t\t\ttry {\n\t\t\t\t\tx733ProbableCause= OOSSProbableCause.getStringforEnum((short) _openNMSalarm.getX733ProbableCause());\n\t\t\t\t}catch (Exception e){\n\t\t\t\t\tx733ProbableCause=\"X733 Probable Cause Incorrectly Defined\";\n\t\t\t\t}\n\n\t\t\t\talarmValueSpecification.setAdditionalText(\n\t\t\t\t\t\t\"<alarmid>\"  + alarmid + \"<\/alarmid>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<logmsg>\"+ _logmsg +\"<\/logmsg>\"+   \"\\n            \" +\n\t\t\t\t\t\t\"<uei>\" + \t_uei_no_html + \"<uei>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<x733AlarmType>\"  + x733AlarmType + \"<\/x733AlarmType>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<x733ProbableCause>\"  + x733ProbableCause + \"<\/x733ProbableCause>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<counter>\" + counter + \"<\/counter>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<reductionkey>\" + reductionkey + \"<\/reductionkey>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodeid>\" + nodeid + \"<\/nodeid>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<nodelabel>\" + onmsnodelabel + \"<\/nodelabel>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<ipaddress>\" + ipaddress + \"<\/ipaddress>\" +   \"\\n            \" +\n\t\t\t\t\t\t\"<description>\"+ _description +\"<\/description>\" +  \"\\n            \" +\n\t\t\t\t\t\t\"<opinstr>\" + _opinstr + \"<\/opinstr>\" + \"\\n            \" +\n\t\t\t\t\t\t\"<asset.managedobjectinstance>\" + assetManagedObjectInstance + \"<\/asset.managedobjectinstance>\" + \"\\n            \"+              //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.managedobjecttype>\" + assetManagedObjectType + \"<\/asset.managedobjecttype>\" + \"\\n            \"+ \n\t\t\t\t\t\t\"<asset.address2>\" + assetAddress2 + \"<\/asset.address2>\" + \"\\n            \"+  //TODO - was used for object instance\n\t\t\t\t\t\t\"<asset.description>\" + assetDescription + \"<\/asset.description>\" + \"\\n\");    //TODO - was used for object instancetype\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\n\t\t} else { // is a received alarm \n\t\t\ttry {\t\t\n\t\t\t\tString _opinstr = _openNMSalarm.getOperInstruct();\n\t\t\t\tif (null == _opinstr) _opinstr = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setProposedRepairActions(_opinstr);\n\n\t\t\t\tString _logmsg = _openNMSalarm.getLogMsg();\n\t\t\t\tif (null == _logmsg ) _logmsg = \"NOT_SET\";\n\t\t\t\t// using manufacturers own definition of specific problem here ( OSS/J )\n\t\t\t\talarmValueSpecification.setSpecificProblem( _logmsg );\n\n\t\t\t\tString _description = _openNMSalarm.getDescription();\n\t\t\t\tif (null == _description ) _description = \"NOT_SET\";\n\t\t\t\talarmValueSpecification.setAdditionalText(_description);\n\n\t\t\t} catch (Exception e){\n\t\t\t\tlog.error(logheader+\": Problem setting description, logmessage or operator instrctions: \", e );\n\t\t\t}\n\t\t}\n\n\t\t// TODO replacement method to populate the alarm key\n\t\ttry {\n\t\t\t//populate alarm key\n\t\t\t//TODO was AlarmKey ak = new OOSSAlarmKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tAlarmKey ak= alarmValueSpecification.getAlarmKey();\n\t\t\tak.setAlarmPrimaryKey(Integer.toString(_openNMSalarm.getId()));\n\t\t\tak.setPrimaryKey(ak.getAlarmPrimaryKey());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(logheader+\": Problem setting AlarmKey: \", e );\n\t\t}\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Alarm Populated\");\n\n\t\treturn alarmValueSpecification;\n\t}","commit_id":"d05017e63242a20b2bc8f5d36108b746397417ac","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * method to run in transaction to update from database\n\t */\n\tprivate void localUpdateAlarmCacheTransaction(){\n\t\tLogger log = getLog();\t\n\n\n\t\tCollection<OnmsAlarm> c = _alarmDao.findAll();\n\n\t\talarmCacheByID= new Hashtable<Integer,OnmsAlarm>(); // clear previous hashtable\n\t\talarmCacheByUniqueKey = new Hashtable<String,OnmsAlarm>();\n\t\tOnmsAlarm[] alarms= (OnmsAlarm[]) c.toArray(new OnmsAlarm[c.size()]);\n\t\t//TODO - ISSUE if too many alarms?\n\t\tfor (int i=0; i<alarms.length; i++){\n\t\t\tOnmsAlarm newalarm=alarms[i];\n\t\t\tnewalarm.getNode().getLabel(); // force node to retreive inner contents\n\n\t\t\talarmCacheByID.put(new Integer (newalarm.getId()), newalarm);\n\n\t\t\t// only update alarmCacheByUniqueKey if key is not null or empty\n\t\t\tif ( ! (\n\t\t\t\t\t(newalarm.getApplicationDN()==null)||\n\t\t\t\t\t(newalarm.getOssPrimaryKey()==null)||\n\t\t\t\t\t(newalarm.getApplicationDN().equals(\"\")) ||\n\t\t\t\t\t(newalarm.getOssPrimaryKey().equals(\"\")) )\n\t\t\t) {\n\t\t\t\tString uniqueKey=newalarm.getApplicationDN()+newalarm.getOssPrimaryKey();\n\t\t\t\tif (alarmCacheByUniqueKey.get(uniqueKey)==null) {\n\t\t\t\t\talarmCacheByUniqueKey.put(uniqueKey, newalarm);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().localUpdateAlarmCache(): ERROR - duplicate alarm uniqueKey in database =\"+ uniqueKey +\" AlarmID:\"+newalarm.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","id":84625,"modified_method":"/**\n\t * method to run in transaction to update from database\n\t */\n\tprivate void localUpdateAlarmCacheTransaction(){\n\t\tLogger log = getLog();\t\n\n\n\t\tCollection<OnmsAlarm> c = _alarmDao.findAll();\n\n\t\talarmCacheByID= new Hashtable<Integer,OnmsAlarm>(); // clear previous hashtable\n\t\talarmCacheByUniqueKey = new Hashtable<String,OnmsAlarm>();\n\t\tOnmsAlarm[] alarms= (OnmsAlarm[]) c.toArray(new OnmsAlarm[c.size()]);\n\t\t//TODO - ISSUE if too many alarms?\n\t\tfor (int i=0; i<alarms.length; i++){\n\t\t\tOnmsAlarm newalarm=alarms[i];\n\t\t\t// retrieve inner contents of alarm node if there is a node associated with the alarm\n\t\t\tif (newalarm.getNode()!=null) {\n\t\t\t\tnewalarm.getNode().getLabel();\n\t\t\t}\n\n\t\t\talarmCacheByID.put(new Integer (newalarm.getId()), newalarm);\n\n\t\t\t// only update alarmCacheByUniqueKey if key is not null or empty\n\t\t\tif ( ! (\n\t\t\t\t\t(newalarm.getApplicationDN()==null)||\n\t\t\t\t\t(newalarm.getOssPrimaryKey()==null)||\n\t\t\t\t\t(newalarm.getApplicationDN().equals(\"\")) ||\n\t\t\t\t\t(newalarm.getOssPrimaryKey().equals(\"\")) )\n\t\t\t) {\n\t\t\t\tString uniqueKey=newalarm.getApplicationDN()+newalarm.getOssPrimaryKey();\n\t\t\t\tif (alarmCacheByUniqueKey.get(uniqueKey)==null) {\n\t\t\t\t\talarmCacheByUniqueKey.put(uniqueKey, newalarm);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().localUpdateAlarmCache(): ERROR - duplicate alarm uniqueKey in database =\"+ uniqueKey +\" AlarmID:\"+newalarm.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"d05017e63242a20b2bc8f5d36108b746397417ac","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Update the node cache from the OpenNMS database\n\t * This must be run at least once to ensure that node data is available\n\t * Not Thread Safe - only to be called from within the synchronised methods\n\t */\n\tprivate void localUpdateNodeCaches(){\n\t\tLogger log = getLog();\t\n\t\ttry{\n\t\t\tnodeCacheByID=new Hashtable<Integer,OnmsNode>();\n\t\t\tnodeCacheByLabel=new Hashtable<String,OnmsNode>();\n\t\t\tnodeCacheByUniqueID=new Hashtable<String,OnmsNode>();\t\n\n\t\t\tif (log.isDebugEnabled()) log.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updating Node Caches :\");\n\n\t\t\tCollection<OnmsNode> c = _nodeDao.findAll();\n\t\t\tOnmsNode[] nodelist= (OnmsNode[]) c.toArray(new OnmsNode[c.size()]);\n\t\t\tfor (int i=0; i<nodelist.length; i++){\n\t\t\t\tOnmsNode node=(OnmsNode)nodelist[i];\n\t\t\t\ttry {\n\t\t\t\t\t// update node by ID cache\n\t\t\t\t\tthis.nodeCacheByID.put((Integer)node.getId(), node);\n\n\t\t\t\t\t// update node by Label cache\n\t\t\t\t\tif (node.getLabel()!=null) {\n\t\t\t\t\t\tif (nodeCacheByLabel.get((String)node.getLabel())!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label:\"+node.getId()+\" is duplicated\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByLabel.put((String)node.getLabel(), node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label is Not putting node in nodeCacheByLabel\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// update node by Unique ID -managedObjectInstance+ManagedObjectType \n\t\t\t\t\tOnmsAssetRecord assetRecord = node.getAssetRecord();\n\t\t\t\t\tif (assetRecord==null) {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" assetRecord is NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif ((assetRecord.getManagedObjectInstance()==null) || (assetRecord.getManagedObjectType()==null)){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" ManagedObjectInstance and/or ManagedObjectType are NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString uniqueid=assetRecord.getManagedObjectInstance()+assetRecord.getManagedObjectType();\n\t\t\t\t\t\t\tif (nodeCacheByUniqueID.get((String)uniqueid)!=null){\n\t\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\n\t\t\t\t\t\t\t\t\t\t\"Unique ID is duplicated. Unique ID = ManagedObjectInstance:\"+assetRecord.getManagedObjectInstance()+\"+ ManagedObjectType:\"+assetRecord.getManagedObjectType());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnodeCacheByUniqueID.put(uniqueid, node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t} catch (Exception ex){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches Error updating node caches: ERROR : \", ex);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByID : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (Integer id : nodeCacheByID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByID.get(id);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Node ID:\"+id+\"\\tNodeLabel:\"+node.getLabel());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents Error:\",e);\n\t\t\t\t}\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByLabel : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (String label : nodeCacheByLabel.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByLabel.get(label);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Label:\"+label+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents. Error:\",e);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByUniqueID : contents :\");\n\t\t\t\t\tfor (String uniqueID : nodeCacheByUniqueID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByUniqueID.get(uniqueID);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: uniqueID:\"+uniqueID+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByUniqueID contents Error:\",e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex){\n\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches ERROR : \", ex);\n\t\t}\n\t}","id":84626,"modified_method":"/**\n\t * Update the node cache from the OpenNMS database\n\t * This must be run at least once to ensure that node data is available\n\t * Not Thread Safe - only to be called from within the synchronised methods\n\t */\n\tprivate void localUpdateNodeCaches(){\n\t\tLogger log = getLog();\t\n\t\ttry{\n\t\t\tnodeCacheByID=new Hashtable<Integer,OnmsNode>();\n\t\t\tnodeCacheByLabel=new Hashtable<String,OnmsNode>();\n\t\t\tnodeCacheByUniqueID=new Hashtable<String,OnmsNode>();\t\n\n\t\t\tif (log.isDebugEnabled()) log.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updating Node Caches :\");\n\n\t\t\tCollection<OnmsNode> c = _nodeDao.findAll();\n\t\t\tOnmsNode[] nodelist= (OnmsNode[]) c.toArray(new OnmsNode[c.size()]);\n\t\t\tfor (int i=0; i<nodelist.length; i++){\n\t\t\t\tOnmsNode node=(OnmsNode)nodelist[i];\n\t\t\t\ttry {\n\t\t\t\t\t// update node by ID cache\n\t\t\t\t\tthis.nodeCacheByID.put((Integer)node.getId(), node);\n\n\t\t\t\t\t// update node by Label cache\n\t\t\t\t\tif (node.getLabel()!=null) {\n\t\t\t\t\t\tif (nodeCacheByLabel.get((String)node.getLabel())!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label:\"+node.getId()+\" is duplicated\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByLabel.put((String)node.getLabel(), node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" Node Label is NULL. Not putting node in nodeCacheByLabel\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// update node by Unique ID -managedObjectInstance+ManagedObjectType \n\t\t\t\t\tfinal OnmsAssetRecord assetRecord = node.getAssetRecord();\n\t\t\t\t\tif (assetRecord==null) {\n\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\" assetRecord is NULL. Not putting node in nodeCacheByUniqueID\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Note that the node asset record data for instance and type are only filled \n\t\t\t\t\t\t// given default values once - subsequently changes must be explicitly set directly\n\t\t\t\t\t\t// in the database\n\t\t\t\t\t\tString moi=assetRecord.getManagedObjectInstance();\n\t\t\t\t\t\tif ((moi==null)||(\"\".equals(moi))){\n\t\t\t\t\t\t\tString fid  = (node.getForeignId()==null) ? \"\" : node.getForeignId();\n\t\t\t\t\t\t\tString fsrc = (node.getForeignSource()==null) ? \"\" : node.getForeignSource() ;\n\t\t\t\t\t\t\tString label= (node.getLabel()==null) ? \"\" : node.getLabel();\n\t\t\t\t\t\t\tmoi  = \"Label:\"+label+\":ForeignSource:\"+fsrc+\":ForeignId():\"+fid;\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()\n\t\t\t\t\t\t\t\t\t+\" ManagedObjectInstance is NULL. Setting  ManagedObjectInstance to: \"+moi);\n\t\t\t\t\t\t\tassetRecord.setManagedObjectInstance(moi);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString mot=assetRecord.getManagedObjectType();\n\t\t\t\t\t\tif ((mot==null)||(\"\".equals(mot))){\n\t\t\t\t\t\t\tmot=\"UNSPECIFIED_TYPE\";\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"\n\t\t\t\t\t\t\t\t\t+node.getId()+\"ManagedObjectType was NULL. Setting ManagedObjectType to: \"+mot);\n\t\t\t\t\t\t\tassetRecord.setManagedObjectType(mot);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// save asset data back with new node information \n\t\t\t\t\t\t// (Note - data may not have changed)\n\t\t\t\t\t\ttransTemplate.execute(new TransactionCallback() {\n\t\t\t\t\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\t\t\t\t\t_assetRecordDao.update(assetRecord);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// update nodeCacheByUniqueID\n\t\t\t\t\t\tString uniqueid=assetRecord.getManagedObjectInstance()+assetRecord.getManagedObjectType();\n\t\t\t\t\t\tif (nodeCacheByUniqueID.get((String)uniqueid)!=null){\n\t\t\t\t\t\t\tlog.info(\"\\tOssDaoOpenNMSImpl().updateNodeCaches WARNING node.getId():\"+node.getId()+\n\t\t\t\t\t\t\t\t\t\t\" Unique ID is duplicated. Unique ID = ManagedObjectInstance:\"+assetRecord.getManagedObjectInstance()+\"+ ManagedObjectType:\"+assetRecord.getManagedObjectType());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeCacheByUniqueID.put(uniqueid, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches Error updating node caches: ERROR : \", ex);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByID : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (Integer id : nodeCacheByID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByID.get(id);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Node ID:\"+id+\"\\tNodeLabel:\"+node.getLabel());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents Error:\",e);\n\t\t\t\t}\n\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByLabel : contents :\");\n\t\t\t\ttry {\n\t\t\t\t    for (String label : nodeCacheByLabel.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByLabel.get(label);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: Label:\"+label+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByLabel contents. Error:\",e);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlog.debug(\"\\tOssDaoOpenNMSImpl().updateNodeCaches - Updated nodeCacheByUniqueID : contents :\");\n\t\t\t\t\tfor (String uniqueID : nodeCacheByUniqueID.keySet()) {\n\t\t\t\t\t\tOnmsNode node =(OnmsNode)nodeCacheByUniqueID.get(uniqueID);\n\t\t\t\t\t\tlog.debug(\"\\t\\tKey: uniqueID:\"+uniqueID+\"\\tNodeID:\"+node.getId());\n\t\t\t\t\t}\n\t\t\t\t}catch ( Exception e){\n\t\t\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches: Problem listing nodeCacheByUniqueID contents Error:\",e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex){\n\t\t\tlog.error(\"\\tOssDaoOpenNMSImpl().updateNodeCaches ERROR : \", ex);\n\t\t}\n\t}","commit_id":"d05017e63242a20b2bc8f5d36108b746397417ac","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onNotifyNewAlarmEvent(NotifyNewAlarmEvent nnae, OssBeanAlarmEventReceiver callingAer) {\n\t\t//\tGet a reference to the QoSD logger instance assigned by OpenNMS\n\t\tLogger log = getLog();\t\n\t\tString logheader=\"RX:\"+callingAer.getName()+\":\"+this.getClass().getSimpleName()+\".onNotifyNewAlarmEvent(): \";\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\"\\n    Statistics:\" +callingAer.getRuntimeStatistics());\n\t\tif (!initialised ){\n\t\t\tlog.error(logheader+\"event handler not initialised. init() must be called by receiver before handling any events\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//TODO ADD IN BUSINESS LOGIC\n\n\t\ttry{\n\t\t\tOnmsAlarm alarm=null;\n\t\t\tString ossPrimaryKey=nnae.getAlarmKey().getAlarmPrimaryKey();\n\t\t\tString applicationDN=nnae.getAlarmKey().getApplicationDN();\n\t\t\tif (log.isDebugEnabled()) \n\t\t\t\tlog.debug(logheader+\": Received an onNotifyNewAlarmEvent() - AlarmPrimaryKey: \"\n\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN +\" eventtime: \" + nnae.getEventTime());\n\t\t\tif (log.isDebugEnabled())log.debug(logheader+\":Using this OssDao (toString):\"+ossDao.toString());\n\t\t\tif ((applicationDN==null)||(applicationDN.equals(\"\")) || (ossPrimaryKey==null)||(ossPrimaryKey.equals(\"\"))) {\n\t\t\t\tlog.error(logheader+\" ApplicatioDN or PrimaryKey not set\");\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating new alarm\");\n\n//\t\t\t\talarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);\n//\t\t\t\tif (alarm!=null) { // already an alarm with this unique id - log error\n//\t\t\t\tlog.error(logheader+\" Alarm Already exists with this Unique ID\");\n//\t\t\t\t} else {\n\t\t\t\talarm=new OnmsAlarm();\n\t\t\t\t\n\t\t\t\talarm.setUei(onmsAlarmOssjMapper.ossjAlarmTypeToUei(nnae.getAlarmType()));\n\t\t\t\t\n\t\t\t\talarm.setX733AlarmType((nnae.getAlarmType()==null) ? \"\" : nnae.getAlarmType());\n\t\t\t\talarm.setX733ProbableCause(nnae.getProbableCause());\n\n\t\t\t\talarm.setTTicketState(null); // needed?\n\t\t\t\talarm.setTTicketId(\"\"); // TODO changed\n\t\t\t\talarm.setQosAlarmState(\"external_type\"); // TODO changed\t\t\t\t\n\t\t\t\talarm.setSuppressedUser(\"\"); // needed?\n\t\t\t\talarm.setSuppressedUntil(new Date()); // needed?\n\t\t\t\talarm.setSuppressedTime(new Date()); // needed?\n\n\t\t\t\tInteger onmsseverity;\n\t\t\t\ttry{\n\t\t\t\t\tonmsseverity= onmsAlarmOssjMapper.ossjSeveritytoOnmsSeverity(nnae.getPerceivedSeverity());\n\t\t\t\t} catch (IllegalArgumentException iae){\n\t\t\t\t\tlog.error(logheader+\" problem setting severity used default:'WARNING'. Exception:\"+ iae);\n\t\t\t\t\tonmsseverity=new Integer(org.opennms.web.alarm.Alarm.WARNING_SEVERITY);\n\t\t\t\t}\n\t\t\t\talarm.setSeverity(onmsseverity); \n\n//TODO not needed\n//\t\t\t\tOnmsServiceType service= new OnmsServiceType();\n//\t\t\t\tservice.setId(new Integer(-1));\n//\t\t\t\talarm.setServiceType(new OnmsServiceType()); // needed?\n\n\n\t\t\t\talarm.setReductionKey(\":managedObjectInstance:\"+nnae.getManagedObjectInstance()+\n\t\t\t\t\t\t\":managedObjectType:\"+nnae.getManagedObjectClass()+\n\t\t\t\t\t\t\":ossPrimaryKey:-\"+ossPrimaryKey+\n\t\t\t\t\t\t\":applicationDN:-\"+applicationDN); // must be unique because of alarm_reductionkey_idx\n\n\t\t\t\talarm.setOssPrimaryKey(ossPrimaryKey);\n\t\t\t\talarm.setOperInstruct(nnae.getProposedRepairActions()); \n\n\t\t\t\t// defaultvalue if search fails - will update node with ID 1\n\t\t\t\tOnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\talarm.setNode(node); // \n\n\t\t\t\tif (almUpdateBehaviour==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse if (callingAer.getName()==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver has no name: default alarms will update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour);\n\n\t\t\t\t\tif (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {\n\t\t\t\t\t\t// this will look for first match of node label to callingAer.getName()\n\t\t\t\t\t\t// and set node id to this value.\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" SPECIFY_OUTSTATION looking for node with nodelabel:\"+callingAer.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// TODO temp remove ?\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tnode =ossDao.findNodeByLabel(callingAer.getName());\n\t\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node \"+ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} \n\t\t\t\t\telse if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){\n\t\t\t\t\t\t// this will look for first match of node Managed object Instance and Managed Object type\n\t\t\t\t\t\t// and set node id to this value. \n\t\t\t\t\t\tString managedObjectType=nnae.getManagedObjectClass();\n\t\t\t\t\t\tString managedObjectInstance=nnae.getManagedObjectInstance();\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" USE_TYPE_INSTANCE looking for node with managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnode =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();\n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.error(logheader+\" Invalid value for alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour+\" defaulting to update nodeID:1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\talarm.setMouseOverText(\"\"); // needed?\n\t\t\t\talarm.setManagedObjectType(nnae.getManagedObjectClass());\n\t\t\t\talarm.setManagedObjectInstance(nnae.getManagedObjectInstance());\n\t\t\t\talarm.setLogMsg(nnae.getSpecificProblem());\n\n\t\t\t\t// NOTE - this has no effect here as .setLastEvent nulls value\n\t\t\t\t// alarm.setLastEventTime(nnae.getEventTime());\n//TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo\n//\t\t\t\tOnmsEvent event= new OnmsEvent();\n//\t\t\t\t//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table\n//\t\t\t\talarm.setLastEvent(event); \n\n\t\t\t\talarm.setIpAddr(\"localhost\"); // needed?\n\t\t\t\talarm.setId(null); // set null as updating alarm\n\t\t\t\talarm.setFirstEventTime(nnae.getEventTime());\n\t\t\t\talarm.setLastEventTime(nnae.getEventTime());\n\t\t\t\t\n// TODO removed - do create distpoller with hibernate dao\t\t\t\t\n//\t\t\t\talarm.setDistPoller(new OnmsDistPoller(\"undefined\",\"localhost\")); //simple constructor\n\t\t\t\talarm.setDistPoller(distPollerDao.get(\"localhost\"));\n\t\t\t\t\n\t\t\t\talarm.setDescription(nnae.getAdditionalText()); //TODO need Qosd Not to generate this if remote\n\t\t\t\talarm.setCounter(new Integer(1));\n\t\t\t\talarm.setClearUei(\"\");\n\t\t\t\talarm.setApplicationDN(applicationDN);\n\t\t\t\talarm.setAlarmType(new Integer(1)); // set to raise alarm\n\t\t\t\t//alarm.setAlarmAckUser(arg0);\n\t\t\t\t//alarm.setAlarmAckTime(arg0);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating Alarm: \" );\n\t\t\t\t\tOnmsAlarm updatedAlarm = ossDao.addCurrentAlarmForUniqueKey(alarm);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(logheader+\": Created alarm:\"\n\t\t\t\t\t\t\t\t+ ossDao.alarmToString(updatedAlarm));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( Exception ex ) {\n\t\t\t\t\tlog.error(logheader+\": problem creating new alarm AlarmPrimaryKey: \"\n\t\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN+\": \"+ ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO remove\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tlog.error(logheader+\" Error : \", e);\n\t\t}\n\t}","id":84627,"modified_method":"public void onNotifyNewAlarmEvent(NotifyNewAlarmEvent nnae, OssBeanAlarmEventReceiver callingAer) {\n\t\t//\tGet a reference to the QoSD logger instance assigned by OpenNMS\n\t\tLogger log = getLog();\t\n\t\tString logheader=\"RX:\"+callingAer.getName()+\":\"+this.getClass().getSimpleName()+\".onNotifyNewAlarmEvent(): \";\n\n\t\tif (log.isDebugEnabled()) log.debug(logheader+\"\\n    Statistics:\" +callingAer.getRuntimeStatistics());\n\t\tif (!initialised ){\n\t\t\tlog.error(logheader+\"event handler not initialised. init() must be called by receiver before handling any events\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//TODO ADD IN BUSINESS LOGIC\n\n\t\ttry{\n\t\t\tOnmsAlarm alarm=null;\n\t\t\tString ossPrimaryKey=nnae.getAlarmKey().getAlarmPrimaryKey();\n\t\t\tString applicationDN=nnae.getAlarmKey().getApplicationDN();\n\t\t\tif (log.isDebugEnabled()) \n\t\t\t\tlog.debug(logheader+\": Received an onNotifyNewAlarmEvent() - AlarmPrimaryKey: \"\n\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN +\" eventtime: \" + nnae.getEventTime());\n\t\t\tif (log.isDebugEnabled())log.debug(logheader+\":Using this OssDao (toString):\"+ossDao.toString());\n\t\t\tif ((applicationDN==null)||(applicationDN.equals(\"\")) || (ossPrimaryKey==null)||(ossPrimaryKey.equals(\"\"))) {\n\t\t\t\tlog.error(logheader+\" ApplicatioDN or PrimaryKey not set\");\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating new alarm\");\n\n//\t\t\t\talarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);\n//\t\t\t\tif (alarm!=null) { // already an alarm with this unique id - log error\n//\t\t\t\tlog.error(logheader+\" Alarm Already exists with this Unique ID\");\n//\t\t\t\t} else {\n\t\t\t\talarm=new OnmsAlarm();\n\t\t\t\t\n\t\t\t\talarm.setUei(onmsAlarmOssjMapper.ossjAlarmTypeToUei(nnae.getAlarmType()));\n\t\t\t\t\n\t\t\t\talarm.setX733AlarmType((nnae.getAlarmType()==null) ? \"\" : nnae.getAlarmType());\n\t\t\t\talarm.setX733ProbableCause(nnae.getProbableCause());\n\n\t\t\t\talarm.setTTicketState(null); // needed?\n\t\t\t\talarm.setTTicketId(\"\"); // TODO changed\n\t\t\t\talarm.setQosAlarmState(\"external_type\"); // TODO changed\t\t\t\t\n\t\t\t\talarm.setSuppressedUser(\"\"); // needed?\n\t\t\t\talarm.setSuppressedUntil(new Date()); // needed?\n\t\t\t\talarm.setSuppressedTime(new Date()); // needed?\n\n\t\t\t\tInteger onmsseverity;\n\t\t\t\ttry{\n\t\t\t\t\tonmsseverity= onmsAlarmOssjMapper.ossjSeveritytoOnmsSeverity(nnae.getPerceivedSeverity());\n\t\t\t\t} catch (IllegalArgumentException iae){\n\t\t\t\t\tlog.error(logheader+\" problem setting severity used default:'WARNING'. Exception:\"+ iae);\n\t\t\t\t\tonmsseverity=new Integer(org.opennms.web.alarm.Alarm.WARNING_SEVERITY);\n\t\t\t\t}\n\t\t\t\talarm.setSeverity(onmsseverity); \n\n//TODO not needed\n//\t\t\t\tOnmsServiceType service= new OnmsServiceType();\n//\t\t\t\tservice.setId(new Integer(-1));\n//\t\t\t\talarm.setServiceType(new OnmsServiceType()); // needed?\n\n\n\t\t\t\talarm.setReductionKey(\":managedObjectInstance:\"+nnae.getManagedObjectInstance()+\n\t\t\t\t\t\t\":managedObjectType:\"+nnae.getManagedObjectClass()+\n\t\t\t\t\t\t\":ossPrimaryKey:-\"+ossPrimaryKey+\n\t\t\t\t\t\t\":applicationDN:-\"+applicationDN); // must be unique because of alarm_reductionkey_idx\n\n\t\t\t\talarm.setOssPrimaryKey(ossPrimaryKey);\n\t\t\t\talarm.setOperInstruct(nnae.getProposedRepairActions()); \n\n\t\t\t\t// defaultvalue if search fails - will update node with ID 1\n\t\t\t\tOnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\talarm.setNode(node); // \n\n\t\t\t\tif (almUpdateBehaviour==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse if (callingAer.getName()==null) {\n\t\t\t\t\tlog.error(\"RX:\"+callingAer.getName()+\": This receiver has no name: default alarms will update nodeID:1\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour);\n\n\t\t\t\t\tif (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {\n\t\t\t\t\t\t// this will look for first match of node label to callingAer.getName()\n\t\t\t\t\t\t// and set node id to this value.\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" SPECIFY_OUTSTATION looking for node with nodelabel:\"+callingAer.getName());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// TODO temp remove ?\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tnode =ossDao.findNodeByLabel(callingAer.getName());\n\t\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node \"+ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); \n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} \n\t\t\t\t\telse if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){\n\t\t\t\t\t\t// this will look for first match of node Managed object Instance and Managed Object type\n\t\t\t\t\t\t// and set node id to this value. \n\t\t\t\t\t\tString managedObjectType=nnae.getManagedObjectClass();\n\t\t\t\t\t\tString managedObjectInstance=nnae.getManagedObjectInstance();\n\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(logheader+\" USE_TYPE_INSTANCE looking for node with managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnode =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);\n\n\t\t\t\t\t\t\tif (node!=null) {\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\t\t\tlog.debug(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t\t+\"NODE FOUND for this RX Name:\"+callingAer.getName()+\" setting node id to NodeLabel:\"+node.getLabel()+\" NodeID:\"+node.getId());\n\t\t\t\t\t\t\t\talarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE):\"\n\t\t\t\t\t\t\t\t\t\t+\"NODE NOT FOUND for this managedObjectType:\"+managedObjectType+\" managedObjectInstance:\"+managedObjectInstance+\" setting node id to default NodeID: 1\");\n\t\t\t\t\t\t\t\tnode=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();\n\t\t\t\t\t\t\t\tnode.setId(new Integer(1));  // node id cannot be null\n\t\t\t\t\t\t\t\talarm.setNode(node); // \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex){\n\t\t\t\t\t\t\tlog.error(logheader+\" alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1\"+ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.error(logheader+\" Invalid value for alarmUpdateBehaviour:\"+almUpdateBehaviour+\" \"+alarmUpdateBehaviour+\" defaulting to update nodeID:1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\talarm.setMouseOverText(\"\"); // needed?\n\t\t\t\talarm.setManagedObjectType(nnae.getManagedObjectClass());\n\t\t\t\talarm.setManagedObjectInstance(nnae.getManagedObjectInstance());\n\t\t\t\talarm.setLogMsg(nnae.getSpecificProblem());\n\n\t\t\t\t// NOTE - this has no effect here as .setLastEvent nulls value\n\t\t\t\t// alarm.setLastEventTime(nnae.getEventTime());\n//TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo\n//\t\t\t\tOnmsEvent event= new OnmsEvent();\n//\t\t\t\t//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table\n//\t\t\t\talarm.setLastEvent(event); \n\n\t\t\t\talarm.setIpAddr(\"localhost\"); // needed?\n\t\t\t\talarm.setId(null); // set null as updating alarm\n\t\t\t\talarm.setFirstEventTime(nnae.getEventTime());\n\t\t\t\talarm.setLastEventTime(nnae.getEventTime());\n\t\t\t\t\n// TODO removed - do create distpoller with hibernate dao\t\t\t\t\n//\t\t\t\talarm.setDistPoller(new OnmsDistPoller(\"undefined\",\"localhost\")); //simple constructor\n\t\t\t\talarm.setDistPoller(distPollerDao.get(\"localhost\"));\n\t\t\t\t\n\t\t\t\talarm.setDescription(nnae.getAdditionalText()); //TODO need Qosd Not to generate this if remote\n\t\t\t\talarm.setCounter(new Integer(1));\n\t\t\t\talarm.setClearUei(\"\");\n\t\t\t\talarm.setApplicationDN(applicationDN);\n\t\t\t\talarm.setAlarmType(new Integer(1)); // set to raise alarm\n\t\t\t\t//alarm.setAlarmAckUser(arg0);\n\t\t\t\t//alarm.setAlarmAckTime(arg0);\n\t\t\t\t\n\t\t\t\t//TODO added for new alarm field\n\t\t\t\tHashMap<String, String> m_details = new HashMap();\n\t\t\t\talarm.setDetails(m_details);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(logheader+\": Creating Alarm: \" );\n\t\t\t\t\tOnmsAlarm updatedAlarm = ossDao.addCurrentAlarmForUniqueKey(alarm);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(logheader+\": Created alarm:\"\n\t\t\t\t\t\t\t\t+ ossDao.alarmToString(updatedAlarm));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch ( Exception ex ) {\n\t\t\t\t\tlog.error(logheader+\": problem creating new alarm AlarmPrimaryKey: \"\n\t\t\t\t\t\t\t+ ossPrimaryKey +\" ApplictionDN: \" + applicationDN+\": \"+ ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO remove\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tlog.error(logheader+\" Error : \", e);\n\t\t}\n\t}","commit_id":"d05017e63242a20b2bc8f5d36108b746397417ac","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      if (tempResult instanceof List<?>) {\r\n        final List<OIdentifiable> t = (List<OIdentifiable>) tempResult;\r\n        final int start = Math.min(skip, t.size());\r\n        final int tot = Math.min(limit + start, t.size());\r\n        for (int i = start; i < tot; ++i)\r\n          newList.add(t.get(i));\r\n\r\n        t.clear();\r\n      }\r\n\r\n      tempResult = newList;\r\n    }\r\n  }","id":84628,"modified_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      final int start = Math.min(skip, tempResult.size());\r\n      final int tot = Math.min(limit + start, tempResult.size());\r\n      for (int i = start; i < tot; ++i)\r\n        newList.add(tempResult.get(i));\r\n\r\n      tempResult.clear();\r\n      tempResult = newList;\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort((List<? extends OIdentifiable>) tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","id":84629,"modified_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort(tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      ((Collection<OIdentifiable>) tempResult).add(iRecord);\r\n    }\r\n  }","id":84630,"modified_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      tempResult.add(iRecord);\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      OFlattenIterator finalResult = new OFlattenIterator();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            finalResult.add((Collection<OIdentifiable>) fieldValue);\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            finalResult.add(((Map<?, OIdentifiable>) fieldValue).values());\r\n          } else if (fieldValue instanceof OFlattenIterator) {\r\n            finalResult = (OFlattenIterator) fieldValue;\r\n          } else if (fieldValue instanceof OIdentifiable)\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","id":84631,"modified_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            tempResult.add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              tempResult.add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      final List<OIdentifiable> finalResult = new ArrayList<OIdentifiable>();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            for (Object o : ((Collection<?>) fieldValue)) {\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            for (Map.Entry<?, ?> entry : ((Map<?, ?>) fieldValue).entrySet()) {\r\n              final Object o = entry.getValue();\r\n\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            ((List<OIdentifiable>) tempResult).add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","id":84632,"modified_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            tempResult.add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          ((Collection<OIdentifiable>) tempResult).add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","id":84633,"modified_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          tempResult.add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    iteratorOfInternalCollections = iterator;\r\n    getNextPartial();\r\n  }","id":84634,"modified_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    subIterator = iterator;\r\n    getNextPartial();\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  protected boolean getNextPartial() {\r\n    if (iteratorOfInternalCollections != null)\r\n      while (iteratorOfInternalCollections.hasNext()) {\r\n        final Object next = iteratorOfInternalCollections.next();\r\n        if (next != null) {\r\n          if (next instanceof Iterator<?>) {\r\n            if (((Iterator<OIdentifiable>) next).hasNext()) {\r\n              partialIterator = (Iterator<OIdentifiable>) next;\r\n              return true;\r\n            }\r\n          } else if (next instanceof Collection<?>) {\r\n            if (!((Collection<OIdentifiable>) next).isEmpty()) {\r\n              partialIterator = ((Collection<OIdentifiable>) next).iterator();\r\n              return true;\r\n            }\r\n          } else if (next instanceof OIdentifiable) {\r\n            final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n            list.add((OIdentifiable) next);\r\n            partialIterator = list.iterator();\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","id":84635,"modified_method":"protected boolean getNextPartial() {\r\n    if (subIterator != null)\r\n      while (subIterator.hasNext()) {\r\n        final Collection<OIdentifiable> next = subIterator.next();\r\n        if (next != null && !next.isEmpty()) {\r\n          partialIterator = next.iterator();\r\n          return true;\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public boolean hasNext() {\r\n    if (internalCollections != null) {\r\n      // THE FIRST TIME CREATE THE ITERATOR\r\n      iteratorOfInternalCollections = internalCollections.iterator();\r\n      internalCollections = null;\r\n      getNextPartial();\r\n    }\r\n\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (iteratorOfInternalCollections.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","id":84636,"modified_method":"@Override\r\n  public boolean hasNext() {\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (subIterator.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84637,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84638,"modified_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final List<Collection<OIdentifiable>> result = new ArrayList<Collection<OIdentifiable>>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          result.add((Collection<OIdentifiable>) value);\r\n        }\r\n      }\r\n\r\n      return new OFlattenIterator(result);\r\n    }\r\n  }","id":84639,"modified_method":"public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final HashSet<Object> result = new HashSet<Object>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          OMultiValue.add(result, value);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }","commit_id":"4fb5c44d6f72cc7563431a45ffc06c6a8daf1c16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      if (tempResult instanceof List<?>) {\r\n        final List<OIdentifiable> t = (List<OIdentifiable>) tempResult;\r\n        final int start = Math.min(skip, t.size());\r\n        final int tot = Math.min(limit + start, t.size());\r\n        for (int i = start; i < tot; ++i)\r\n          newList.add(t.get(i));\r\n\r\n        t.clear();\r\n      }\r\n\r\n      tempResult = newList;\r\n    }\r\n  }","id":84640,"modified_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      final int start = Math.min(skip, tempResult.size());\r\n      final int tot = Math.min(limit + start, tempResult.size());\r\n      for (int i = start; i < tot; ++i)\r\n        newList.add(tempResult.get(i));\r\n\r\n      tempResult.clear();\r\n      tempResult = newList;\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      OFlattenIterator finalResult = new OFlattenIterator();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            finalResult.add((Collection<OIdentifiable>) fieldValue);\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            finalResult.add(((Map<?, OIdentifiable>) fieldValue).values());\r\n          } else if (fieldValue instanceof OFlattenIterator) {\r\n            finalResult = (OFlattenIterator) fieldValue;\r\n          } else if (fieldValue instanceof OIdentifiable)\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","id":84641,"modified_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            tempResult.add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              tempResult.add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      final List<OIdentifiable> finalResult = new ArrayList<OIdentifiable>();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            for (Object o : ((Collection<?>) fieldValue)) {\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            for (Map.Entry<?, ?> entry : ((Map<?, ?>) fieldValue).entrySet()) {\r\n              final Object o = entry.getValue();\r\n\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      ((Collection<OIdentifiable>) tempResult).add(iRecord);\r\n    }\r\n  }","id":84642,"modified_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      tempResult.add(iRecord);\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort((List<? extends OIdentifiable>) tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","id":84643,"modified_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort(tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            ((List<OIdentifiable>) tempResult).add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","id":84644,"modified_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            tempResult.add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          ((Collection<OIdentifiable>) tempResult).add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","id":84645,"modified_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          tempResult.add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    iteratorOfInternalCollections = iterator;\r\n    getNextPartial();\r\n  }","id":84646,"modified_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    subIterator = iterator;\r\n    getNextPartial();\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public boolean hasNext() {\r\n    if (internalCollections != null) {\r\n      // THE FIRST TIME CREATE THE ITERATOR\r\n      iteratorOfInternalCollections = internalCollections.iterator();\r\n      internalCollections = null;\r\n      getNextPartial();\r\n    }\r\n\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (iteratorOfInternalCollections.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","id":84647,"modified_method":"@Override\r\n  public boolean hasNext() {\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (subIterator.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  protected boolean getNextPartial() {\r\n    if (iteratorOfInternalCollections != null)\r\n      while (iteratorOfInternalCollections.hasNext()) {\r\n        final Object next = iteratorOfInternalCollections.next();\r\n        if (next != null) {\r\n          if (next instanceof Iterator<?>) {\r\n            if (((Iterator<OIdentifiable>) next).hasNext()) {\r\n              partialIterator = (Iterator<OIdentifiable>) next;\r\n              return true;\r\n            }\r\n          } else if (next instanceof Collection<?>) {\r\n            if (!((Collection<OIdentifiable>) next).isEmpty()) {\r\n              partialIterator = ((Collection<OIdentifiable>) next).iterator();\r\n              return true;\r\n            }\r\n          } else if (next instanceof OIdentifiable) {\r\n            final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n            list.add((OIdentifiable) next);\r\n            partialIterator = list.iterator();\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","id":84648,"modified_method":"protected boolean getNextPartial() {\r\n    if (subIterator != null)\r\n      while (subIterator.hasNext()) {\r\n        final Collection<OIdentifiable> next = subIterator.next();\r\n        if (next != null && !next.isEmpty()) {\r\n          partialIterator = next.iterator();\r\n          return true;\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84649,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84650,"modified_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final List<Collection<OIdentifiable>> result = new ArrayList<Collection<OIdentifiable>>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          result.add((Collection<OIdentifiable>) value);\r\n        }\r\n      }\r\n\r\n      return new OFlattenIterator(result);\r\n    }\r\n  }","id":84651,"modified_method":"public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final HashSet<Object> result = new HashSet<Object>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          OMultiValue.add(result, value);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }","commit_id":"8a674e5d5cc2a1a503ff77eee0c88b936b246e4d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      if (tempResult instanceof List<?>) {\r\n        final List<OIdentifiable> t = (List<OIdentifiable>) tempResult;\r\n        final int start = Math.min(skip, t.size());\r\n        final int tot = Math.min(limit + start, t.size());\r\n        for (int i = start; i < tot; ++i)\r\n          newList.add(t.get(i));\r\n\r\n        t.clear();\r\n      }\r\n\r\n      tempResult = newList;\r\n    }\r\n  }","id":84652,"modified_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      final int start = Math.min(skip, tempResult.size());\r\n      final int tot = Math.min(limit + start, tempResult.size());\r\n      for (int i = start; i < tot; ++i)\r\n        newList.add(tempResult.get(i));\r\n\r\n      tempResult.clear();\r\n      tempResult = newList;\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          ((Collection<OIdentifiable>) tempResult).add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","id":84653,"modified_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          tempResult.add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort((List<? extends OIdentifiable>) tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","id":84654,"modified_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort(tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      ((Collection<OIdentifiable>) tempResult).add(iRecord);\r\n    }\r\n  }","id":84655,"modified_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      tempResult.add(iRecord);\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      OFlattenIterator finalResult = new OFlattenIterator();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            finalResult.add((Collection<OIdentifiable>) fieldValue);\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            finalResult.add(((Map<?, OIdentifiable>) fieldValue).values());\r\n          } else if (fieldValue instanceof OFlattenIterator) {\r\n            finalResult = (OFlattenIterator) fieldValue;\r\n          } else if (fieldValue instanceof OIdentifiable)\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","id":84656,"modified_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            tempResult.add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              tempResult.add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      final List<OIdentifiable> finalResult = new ArrayList<OIdentifiable>();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            for (Object o : ((Collection<?>) fieldValue)) {\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            for (Map.Entry<?, ?> entry : ((Map<?, ?>) fieldValue).entrySet()) {\r\n              final Object o = entry.getValue();\r\n\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            ((List<OIdentifiable>) tempResult).add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","id":84657,"modified_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            tempResult.add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public boolean hasNext() {\r\n    if (internalCollections != null) {\r\n      // THE FIRST TIME CREATE THE ITERATOR\r\n      iteratorOfInternalCollections = internalCollections.iterator();\r\n      internalCollections = null;\r\n      getNextPartial();\r\n    }\r\n\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (iteratorOfInternalCollections.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","id":84658,"modified_method":"@Override\r\n  public boolean hasNext() {\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (subIterator.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  protected boolean getNextPartial() {\r\n    if (iteratorOfInternalCollections != null)\r\n      while (iteratorOfInternalCollections.hasNext()) {\r\n        final Object next = iteratorOfInternalCollections.next();\r\n        if (next != null) {\r\n          if (next instanceof Iterator<?>) {\r\n            if (((Iterator<OIdentifiable>) next).hasNext()) {\r\n              partialIterator = (Iterator<OIdentifiable>) next;\r\n              return true;\r\n            }\r\n          } else if (next instanceof Collection<?>) {\r\n            if (!((Collection<OIdentifiable>) next).isEmpty()) {\r\n              partialIterator = ((Collection<OIdentifiable>) next).iterator();\r\n              return true;\r\n            }\r\n          } else if (next instanceof OIdentifiable) {\r\n            final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n            list.add((OIdentifiable) next);\r\n            partialIterator = list.iterator();\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","id":84659,"modified_method":"protected boolean getNextPartial() {\r\n    if (subIterator != null)\r\n      while (subIterator.hasNext()) {\r\n        final Collection<OIdentifiable> next = subIterator.next();\r\n        if (next != null && !next.isEmpty()) {\r\n          partialIterator = next.iterator();\r\n          return true;\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    iteratorOfInternalCollections = iterator;\r\n    getNextPartial();\r\n  }","id":84660,"modified_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    subIterator = iterator;\r\n    getNextPartial();\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84661,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84662,"modified_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final List<Collection<OIdentifiable>> result = new ArrayList<Collection<OIdentifiable>>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          result.add((Collection<OIdentifiable>) value);\r\n        }\r\n      }\r\n\r\n      return new OFlattenIterator(result);\r\n    }\r\n  }","id":84663,"modified_method":"public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final HashSet<Object> result = new HashSet<Object>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          OMultiValue.add(result, value);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }","commit_id":"fe77b5d5ba92f046f955b7627f9b50f4218a5858","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      if (tempResult instanceof List<?>) {\r\n        final List<OIdentifiable> t = (List<OIdentifiable>) tempResult;\r\n        final int start = Math.min(skip, t.size());\r\n        final int tot = Math.min(limit + start, t.size());\r\n        for (int i = start; i < tot; ++i)\r\n          newList.add(t.get(i));\r\n\r\n        t.clear();\r\n      }\r\n\r\n      tempResult = newList;\r\n    }\r\n  }","id":84664,"modified_method":"protected void applyLimitAndSkip() {\r\n    if (tempResult != null && (limit > 0 || skip > 0)) {\r\n      final List<OIdentifiable> newList = new ArrayList<OIdentifiable>();\r\n\r\n      // APPLY LIMIT\r\n      final int start = Math.min(skip, tempResult.size());\r\n      final int tot = Math.min(limit + start, tempResult.size());\r\n      for (int i = start; i < tot; ++i)\r\n        newList.add(tempResult.get(i));\r\n\r\n      tempResult.clear();\r\n      tempResult = newList;\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      OFlattenIterator finalResult = new OFlattenIterator();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            finalResult.add((Collection<OIdentifiable>) fieldValue);\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            finalResult.add(((Map<?, OIdentifiable>) fieldValue).values());\r\n          } else if (fieldValue instanceof OFlattenIterator) {\r\n            finalResult = (OFlattenIterator) fieldValue;\r\n          } else if (fieldValue instanceof OIdentifiable)\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","id":84665,"modified_method":"/**\r\n   * Extract the content of collections and/or links and put it as result\r\n   */\r\n  private void applyFlatten() {\r\n    if (flattenTarget == null)\r\n      return;\r\n\r\n    Object fieldValue;\r\n\r\n    if (tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n      if (flattenTarget instanceof OSQLFilterItemVariable) {\r\n        Object r = ((OSQLFilterItemVariable) flattenTarget).getValue(null, context);\r\n        if (r != null) {\r\n          if (r instanceof OIdentifiable)\r\n            tempResult.add((OIdentifiable) r);\r\n          else if (OMultiValue.isMultiValue(r)) {\r\n            for (Object o : OMultiValue.getMultiValueIterable(r))\r\n              tempResult.add((OIdentifiable) o);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      final List<OIdentifiable> finalResult = new ArrayList<OIdentifiable>();\r\n      for (OIdentifiable id : tempResult) {\r\n        if (flattenTarget instanceof OSQLFilterItem)\r\n          fieldValue = ((OSQLFilterItem) flattenTarget).getValue(id.getRecord(), context);\r\n        else if (flattenTarget instanceof OSQLFunctionRuntime)\r\n          fieldValue = ((OSQLFunctionRuntime) flattenTarget).getResult();\r\n        else\r\n          fieldValue = flattenTarget.toString();\r\n\r\n        if (fieldValue != null)\r\n          if (fieldValue instanceof Collection<?>) {\r\n            for (Object o : ((Collection<?>) fieldValue)) {\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else if (fieldValue instanceof Map<?, ?>) {\r\n            for (Map.Entry<?, ?> entry : ((Map<?, ?>) fieldValue).entrySet()) {\r\n              final Object o = entry.getValue();\r\n\r\n              if (o instanceof OIdentifiable)\r\n                finalResult.add(((OIdentifiable) o).getRecord());\r\n              else if (o instanceof List) {\r\n                List<OIdentifiable> list = (List<OIdentifiable>) o;\r\n                for (int i = 0; i < list.size(); i++)\r\n                  finalResult.add(list.get(i).getRecord());\r\n              }\r\n            }\r\n          } else\r\n            finalResult.add((OIdentifiable) fieldValue);\r\n      }\r\n      tempResult = finalResult;\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          ((Collection<OIdentifiable>) tempResult).add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","id":84666,"modified_method":"protected boolean optimizeExecution() {\r\n    if ((compiledFilter == null || (compiledFilter != null && compiledFilter.getRootCondition() == null)) && groupByFields == null\r\n        && projections != null && projections.size() == 1) {\r\n      final Map.Entry<String, Object> entry = projections.entrySet().iterator().next();\r\n\r\n      if (entry.getValue() instanceof OSQLFunctionRuntime) {\r\n        final OSQLFunctionRuntime rf = (OSQLFunctionRuntime) entry.getValue();\r\n        if (rf.function instanceof OSQLFunctionCount && rf.configuredParameters.length == 1\r\n            && \"*\".equals(rf.configuredParameters[0])) {\r\n          long count = 0;\r\n\r\n          if (parsedTarget.getTargetClasses() != null) {\r\n            final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n            count = cls.count();\r\n          } else if (parsedTarget.getTargetClusters() != null) {\r\n            for (String cluster : parsedTarget.getTargetClusters().keySet()) {\r\n              count += getDatabase().countClusterElements(cluster);\r\n            }\r\n          } else if (parsedTarget.getTargetIndex() != null) {\r\n            count += getDatabase().getMetadata().getIndexManager().getIndex(parsedTarget.getTargetIndex()).getSize();\r\n          }\r\n\r\n          if (tempResult == null)\r\n            tempResult = new ArrayList<OIdentifiable>();\r\n          tempResult.add(new ODocument().field(entry.getKey(), count));\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (orderedFields != null && !orderedFields.isEmpty()) {\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n        final OPair<String, String> orderByFirstField = orderedFields.iterator().next();\r\n        final OProperty p = cls.getProperty(orderByFirstField.getKey());\r\n        if (p != null) {\r\n          final Set<OIndex<?>> involvedIndexes = cls.getInvolvedIndexes(orderByFirstField.getKey());\r\n          if (involvedIndexes != null && !involvedIndexes.isEmpty()) {\r\n            for (OIndex<?> idx : involvedIndexes) {\r\n              if (idx.getKeyTypes().length == 1 && idx.supportsOrderedIterations()) {\r\n                if (orderByFirstField.getValue().equalsIgnoreCase(\"asc\"))\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesIterator();\r\n                else\r\n                  target = (Iterator<? extends OIdentifiable>) idx.valuesInverseIterator();\r\n                orderedFields = null;\r\n\r\n                fetchLimit = getQueryFetchLimit();\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      ((Collection<OIdentifiable>) tempResult).add(iRecord);\r\n    }\r\n  }","id":84667,"modified_method":"protected void addResult(OIdentifiable iRecord) {\r\n    if (iRecord == null)\r\n      return;\r\n\r\n    if (projections != null || groupByFields != null && !groupByFields.isEmpty()) {\r\n      if (groupedResult == null) {\r\n        // APPLY PROJECTIONS IN LINE\r\n        iRecord = ORuntimeResult.getProjectionResult(resultCount, projections, context, iRecord);\r\n        if (iRecord == null)\r\n          return;\r\n      } else {\r\n        // AGGREGATION/GROUP BY\r\n        final ODocument doc = (ODocument) iRecord.getRecord();\r\n        Object fieldValue = null;\r\n        if (groupByFields != null && !groupByFields.isEmpty()) {\r\n          if (groupByFields.size() > 1) {\r\n            // MULTI-FIELD FROUP BY\r\n            final Object[] fields = new Object[groupByFields.size()];\r\n            for (int i = 0; i < groupByFields.size(); ++i)\r\n              fields[i] = doc.field(groupByFields.get(i));\r\n\r\n            fieldValue = fields;\r\n          } else\r\n            fieldValue = doc.field(groupByFields.get(0));\r\n        }\r\n\r\n        getProjectionGroup(fieldValue).applyRecord(iRecord);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (orderedFields == null && flattenTarget == null) {\r\n      // SEND THE RESULT INLINE\r\n      if (request.getResultListener() != null)\r\n        request.getResultListener().result(iRecord);\r\n\r\n    } else {\r\n\r\n      // COLLECT ALL THE RECORDS AND ORDER THEM AT THE END\r\n      if (tempResult == null)\r\n        tempResult = new ArrayList<OIdentifiable>();\r\n      tempResult.add(iRecord);\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            ((List<OIdentifiable>) tempResult).add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","id":84668,"modified_method":"private void handleGroupBy() {\r\n    if (groupedResult != null && tempResult == null) {\r\n      tempResult = new ArrayList<OIdentifiable>();\r\n\r\n      for (Entry<Object, ORuntimeResult> g : groupedResult.entrySet()) {\r\n        if (g.getKey() != null || groupedResult.size() == 1) {\r\n          final ODocument doc = g.getValue().getResult();\r\n          if (doc != null && !doc.isEmpty())\r\n            tempResult.add(doc);\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort((List<? extends OIdentifiable>) tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","id":84669,"modified_method":"private void applyOrderBy() {\r\n    if (orderedFields == null)\r\n      return;\r\n\r\n    ODocumentHelper.sort(tempResult, orderedFields);\r\n    orderedFields.clear();\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    iteratorOfInternalCollections = iterator;\r\n    getNextPartial();\r\n  }","id":84670,"modified_method":"public OFlattenIterator(final Iterator<? extends Collection<OIdentifiable>> iterator) {\r\n    subIterator = iterator;\r\n    getNextPartial();\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  protected boolean getNextPartial() {\r\n    if (iteratorOfInternalCollections != null)\r\n      while (iteratorOfInternalCollections.hasNext()) {\r\n        final Object next = iteratorOfInternalCollections.next();\r\n        if (next != null) {\r\n          if (next instanceof Iterator<?>) {\r\n            if (((Iterator<OIdentifiable>) next).hasNext()) {\r\n              partialIterator = (Iterator<OIdentifiable>) next;\r\n              return true;\r\n            }\r\n          } else if (next instanceof Collection<?>) {\r\n            if (!((Collection<OIdentifiable>) next).isEmpty()) {\r\n              partialIterator = ((Collection<OIdentifiable>) next).iterator();\r\n              return true;\r\n            }\r\n          } else if (next instanceof OIdentifiable) {\r\n            final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n            list.add((OIdentifiable) next);\r\n            partialIterator = list.iterator();\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","id":84671,"modified_method":"protected boolean getNextPartial() {\r\n    if (subIterator != null)\r\n      while (subIterator.hasNext()) {\r\n        final Collection<OIdentifiable> next = subIterator.next();\r\n        if (next != null && !next.isEmpty()) {\r\n          partialIterator = next.iterator();\r\n          return true;\r\n        }\r\n      }\r\n\r\n    return false;\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public boolean hasNext() {\r\n    if (internalCollections != null) {\r\n      // THE FIRST TIME CREATE THE ITERATOR\r\n      iteratorOfInternalCollections = internalCollections.iterator();\r\n      internalCollections = null;\r\n      getNextPartial();\r\n    }\r\n\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (iteratorOfInternalCollections.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","id":84672,"modified_method":"@Override\r\n  public boolean hasNext() {\r\n    if (partialIterator == null)\r\n      return false;\r\n\r\n    if (partialIterator.hasNext())\r\n      return true;\r\n    else if (subIterator.hasNext())\r\n      return getNextPartial();\r\n\r\n    return false;\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84673,"modified_method":"public Iterator<OIdentifiable> valuesIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(map.values().iterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":84674,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n  public Iterator<OIdentifiable> valuesInverseIterator() {\r\n\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      return new OFlattenIterator<OIdentifiable>(((OMVRBTree.Values) map.values()).inverseIterator());\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final List<Collection<OIdentifiable>> result = new ArrayList<Collection<OIdentifiable>>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          result.add((Collection<OIdentifiable>) value);\r\n        }\r\n      }\r\n\r\n      return new OFlattenIterator(result);\r\n    }\r\n  }","id":84675,"modified_method":"public Object execute(final OIdentifiable iCurrentRecord, ODocument iCurrentResult, final Object[] iParameters,\r\n      OCommandContext iContext) {\r\n    if (iParameters.length == 1) {\r\n      // AGGREGATION MODE (STATEFULL)\r\n      Object value = iParameters[0];\r\n      if (value != null) {\r\n\r\n        if (value instanceof OSQLFilterItemVariable)\r\n          value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n        if (context == null)\r\n          context = new HashSet<Object>();\r\n\r\n        OMultiValue.add(context, value);\r\n      }\r\n\r\n      return context;\r\n    } else {\r\n      // IN-LINE MODE (STATELESS)\r\n      final HashSet<Object> result = new HashSet<Object>();\r\n      for (Object value : iParameters) {\r\n        if (value != null) {\r\n\r\n          if (value instanceof OSQLFilterItemVariable)\r\n            value = ((OSQLFilterItemVariable) value).getValue(iCurrentRecord, iContext);\r\n\r\n          OMultiValue.add(result, value);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }","commit_id":"62dd1b36b94edd66f76b0c4d2d33947607e7f80f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n    public void testZeroPrediction() {\n        try {\n            client()\n                    .prepareSearch(\"idx\")\n                    .addAggregation(\n                            histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(windowSize)\n                                            .modelBuilder(randomModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .predict(0)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a prediction size that is zero\");\n\n        } catch (SearchPhaseExecutionException exception) {\n           // All Good\n        }\n    }","id":84676,"modified_method":"@Test\n    public void testZeroPrediction() {\n        try {\n            client()\n                    .prepareSearch(\"idx\").setTypes(\"type\")\n                    .addAggregation(\n                            histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(windowSize)\n                                            .modelBuilder(randomModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .predict(0)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a prediction size that is zero\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            // All Good\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Big gap, but with prediction at the end.\n     */\n    @Test\n    public void testGiantGapWithPredict() {\n\n        MovAvgModelBuilder model = randomModelBuilder();\n        int numPredictions = randomIntBetween(1, 10);\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(model)\n                                        .gapPolicy(gapPolicy)\n                                        .predict(numPredictions)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets + numPredictions));\n\n        double lastValue = ((SimpleValue)(buckets.get(0).getAggregations().get(\"movavg_counts\"))).value();\n        assertThat(Double.compare(lastValue, 0.0d), greaterThanOrEqualTo(0));\n\n        double currentValue;\n        for (int i = 1; i < numValueBuckets - 2; i++) {\n            currentValue = ((SimpleValue)(buckets.get(i).getAggregations().get(\"movavg_counts\"))).value();\n\n            // Since there are only two values in this test, at the beginning and end, the moving average should\n            // decrease every step (until it reaches zero).  Crude way to check that it's doing the right thing\n            // without actually verifying the computed values.  Should work for all types of moving avgs and\n            // gap policies\n            assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n            lastValue = currentValue;\n        }\n\n        // The last bucket has a real value, so this should always increase the moving avg\n        currentValue = ((SimpleValue)(buckets.get(numValueBuckets - 1).getAggregations().get(\"movavg_counts\"))).value();\n        assertThat(Double.compare(lastValue, currentValue), equalTo(-1));\n\n        // Now check predictions\n        for (int i = numValueBuckets; i < numValueBuckets + numPredictions; i++) {\n            // Unclear at this point which direction the predictions will go, just verify they are\n            // not null, and that we don't have the_metric anymore\n            assertThat((buckets.get(i).getAggregations().get(\"movavg_counts\")), notNullValue());\n            assertThat((buckets.get(i).getAggregations().get(\"the_metric\")), nullValue());\n        }\n    }","id":84677,"modified_method":"/**\n     * Big gap, but with prediction at the end.\n     */\n    @Test\n    public void testGiantGapWithPredict() {\n        int numPredictions = randomIntBetween(1, 10);\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"gap_type\")\n                .addAggregation(\n                        histogram(\"histo\").field(INTERVAL_FIELD).interval(1).minDocCount(0).extendedBounds(0L, 49L)\n                                .subAggregation(min(\"the_metric\").field(GAP_FIELD))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(randomModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\")\n                                        .predict(numPredictions))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(50 + numPredictions));\n\n        double lastValue = ((SimpleValue)(buckets.get(0).getAggregations().get(\"movavg_values\"))).value();\n        assertThat(Double.compare(lastValue, 0.0d), greaterThanOrEqualTo(0));\n\n        double currentValue;\n        for (int i = 1; i < 49; i++) {\n            SimpleValue current = buckets.get(i).getAggregations().get(\"movavg_values\");\n            if (current != null) {\n                currentValue = current.value();\n\n                // Since there are only two values in this test, at the beginning and end, the moving average should\n                // decrease every step (until it reaches zero).  Crude way to check that it's doing the right thing\n                // without actually verifying the computed values.  Should work for all types of moving avgs and\n                // gap policies\n                assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n                lastValue = currentValue;\n            }\n        }\n\n        SimpleValue current = buckets.get(49).getAggregations().get(\"movavg_values\");\n        assertThat(current, notNullValue());\n        currentValue = current.value();\n\n        if (gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {\n            // If we ignore missing, there will only be two values in this histo, so movavg will stay the same\n            assertThat(Double.compare(lastValue, currentValue), equalTo(0));\n        } else if (gapPolicy.equals(BucketHelpers.GapPolicy.INSERT_ZEROS)) {\n            // If we insert zeros, this should always increase the moving avg since the last bucket has a real value\n            assertThat(Double.compare(lastValue, currentValue), equalTo(-1));\n        }\n\n        // Now check predictions\n        for (int i = 50; i < 50 + numPredictions; i++) {\n            // Unclear at this point which direction the predictions will go, just verify they are\n            // not null, and that we don't have the_metric anymore\n            assertThat((buckets.get(i).getAggregations().get(\"movavg_values\")), notNullValue());\n            assertThat((buckets.get(i).getAggregations().get(\"the_metric\")), nullValue());\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test linear moving average on single value field\n     */\n    @Test\n    public void linearSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new LinearModel.LinearModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new LinearModel.LinearModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        for (int i = 0; i < numValueBuckets; ++i) {\n            Histogram.Bucket bucket = buckets.get(i);\n            checkBucketKeyAndDocCount(\"Bucket \" + i, bucket, i * interval, docCounts[i]);\n            SimpleValue docCountMovAvg = bucket.getAggregations().get(\"movavg_counts\");\n            assertThat(docCountMovAvg, notNullValue());\n            assertThat(docCountMovAvg.value(), equalTo(linearDocCounts[i]));\n\n            SimpleValue valuesMovAvg = bucket.getAggregations().get(\"movavg_values\");\n            assertThat(valuesMovAvg, notNullValue());\n            assertThat(valuesMovAvg.value(), equalTo(linearDocValues[i]));\n        }\n    }","id":84678,"modified_method":"@Test\n    public void linearSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"type\")\n                .addAggregation(\n                        histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                .subAggregation(metric)\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new LinearModel.LinearModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new LinearModel.LinearModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(mockHisto.size()));\n\n        List<Double> expectedCounts = testValues.get(MovAvgType.LINEAR.toString() + \"_\" + MetricTarget.COUNT.toString());\n        List<Double> expectedValues = testValues.get(MovAvgType.LINEAR.toString() + \"_\" + MetricTarget.VALUE.toString());\n\n        Iterator<? extends Histogram.Bucket> actualIter = buckets.iterator();\n        Iterator<ReducerTestHelpers.MockBucket> expectedBucketIter = mockHisto.iterator();\n        Iterator<Double> expectedCountsIter = expectedCounts.iterator();\n        Iterator<Double> expectedValuesIter = expectedValues.iterator();\n\n        while (actualIter.hasNext()) {\n            assertValidIterators(expectedBucketIter, expectedCountsIter, expectedValuesIter);\n\n            Histogram.Bucket actual = actualIter.next();\n            ReducerTestHelpers.MockBucket expected = expectedBucketIter.next();\n            Double expectedCount = expectedCountsIter.next();\n            Double expectedValue = expectedValuesIter.next();\n\n            assertThat(\"keys do not match\", ((Number) actual.getKey()).longValue(), equalTo(expected.key));\n            assertThat(\"doc counts do not match\", actual.getDocCount(), equalTo((long)expected.count));\n\n            assertBucketContents(actual, expectedCount, expectedValue);\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testNegativePrediction() {\n        try {\n            client()\n                    .prepareSearch(\"idx\")\n                    .addAggregation(\n                            histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(windowSize)\n                                            .modelBuilder(randomModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .predict(-10)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a prediction size that is negative\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            // All Good\n        }\n    }","id":84679,"modified_method":"@Test\n    public void testNegativePrediction() {\n        try {\n            client()\n                    .prepareSearch(\"idx\").setTypes(\"type\")\n                    .addAggregation(\n                            histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(windowSize)\n                                            .modelBuilder(randomModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .predict(-10)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a prediction size that is negative\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            // All Good\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * This test filters the \"gap\" data so that the first doc is excluded.  This leaves a long stretch of empty\n     * buckets until the final bucket.  The moving avg should be zero up until the last bucket, and should work\n     * regardless of mov avg type or gap policy.\n     */\n    @Test\n    public void testLeftGap() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(\"gap_test\").from(1)).subAggregation(\n                                histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                        .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_counts\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .setBucketsPaths(\"the_metric\"))\n                        )\n\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        double currentValue;\n        double lastValue = 0.0;\n        for (int i = 0; i < numValueBuckets - 1; i++) {\n            currentValue = ((SimpleValue)(buckets.get(i).getAggregations().get(\"movavg_counts\"))).value();\n\n            assertThat(Double.compare(lastValue, currentValue), lessThanOrEqualTo(0));\n            lastValue = currentValue;\n        }\n\n    }","id":84680,"modified_method":"/**\n     * This test filters the \"gap\" data so that the first doc is excluded.  This leaves a long stretch of empty\n     * buckets until the final bucket.  The moving avg should be zero up until the last bucket, and should work\n     * regardless of mov avg type or gap policy.\n     */\n    @Test\n    public void testLeftGap() {\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"gap_type\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(INTERVAL_FIELD).from(1)).subAggregation(\n                                histogram(\"histo\").field(INTERVAL_FIELD).interval(1).minDocCount(0).extendedBounds(0L, 49L)\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_values\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .setBucketsPaths(\"the_metric\"))\n                        ))\n                .execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(50));\n\n        double lastValue = 0;\n\n        double currentValue;\n        for (int i = 0; i < 50; i++) {\n            SimpleValue current = buckets.get(i).getAggregations().get(\"movavg_values\");\n            if (current != null) {\n                currentValue = current.value();\n\n                assertThat(Double.compare(lastValue, currentValue), lessThanOrEqualTo(0));\n                lastValue = currentValue;\n            }\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test simple moving average on single value field\n     */\n    @Test\n    public void simpleSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        for (int i = 0; i < numValueBuckets; ++i) {\n            Histogram.Bucket bucket = buckets.get(i);\n            checkBucketKeyAndDocCount(\"Bucket \" + i, bucket, i * interval, docCounts[i]);\n            SimpleValue docCountMovAvg = bucket.getAggregations().get(\"movavg_counts\");\n            assertThat(docCountMovAvg, notNullValue());\n            assertThat(docCountMovAvg.value(), equalTo(simpleDocCounts[i]));\n\n            SimpleValue valuesMovAvg = bucket.getAggregations().get(\"movavg_values\");\n            assertThat(valuesMovAvg, notNullValue());\n            assertThat(valuesMovAvg.value(), equalTo(simpleDocValues[i]));\n        }\n    }","id":84681,"modified_method":"/**\n     * test simple moving average on single value field\n     */\n    @Test\n    public void simpleSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"type\")\n                .addAggregation(\n                        histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                .subAggregation(metric)\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(mockHisto.size()));\n\n        List<Double> expectedCounts = testValues.get(MovAvgType.SIMPLE.toString() + \"_\" + MetricTarget.COUNT.toString());\n        List<Double> expectedValues = testValues.get(MovAvgType.SIMPLE.toString() + \"_\" + MetricTarget.VALUE.toString());\n\n        Iterator<? extends Histogram.Bucket> actualIter = buckets.iterator();\n        Iterator<ReducerTestHelpers.MockBucket> expectedBucketIter = mockHisto.iterator();\n        Iterator<Double> expectedCountsIter = expectedCounts.iterator();\n        Iterator<Double> expectedValuesIter = expectedValues.iterator();\n\n        while (actualIter.hasNext()) {\n            assertValidIterators(expectedBucketIter, expectedCountsIter, expectedValuesIter);\n\n            Histogram.Bucket actual = actualIter.next();\n            ReducerTestHelpers.MockBucket expected = expectedBucketIter.next();\n            Double expectedCount = expectedCountsIter.next();\n            Double expectedValue = expectedValuesIter.next();\n\n            assertThat(\"keys do not match\", ((Number) actual.getKey()).longValue(), equalTo(expected.key));\n            assertThat(\"doc counts do not match\", actual.getDocCount(), equalTo((long)expected.count));\n\n            assertBucketContents(actual, expectedCount, expectedValue);\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * This test uses the \"gap\" dataset, which is simply a doc at the beginning and end of\n     * the SINGLE_VALUED_FIELD_NAME range.  These docs have a value of 1 in the `g_field`.\n     * This test verifies that large gaps don't break things, and that the mov avg roughly works\n     * in the correct manner (checks direction of change, but not actual values)\n     */\n    @Test\n    public void testGiantGap() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(randomModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        double lastValue = ((SimpleValue)(buckets.get(0).getAggregations().get(\"movavg_counts\"))).value();\n        assertThat(Double.compare(lastValue, 0.0d), greaterThanOrEqualTo(0));\n\n        double currentValue;\n        for (int i = 1; i < numValueBuckets - 2; i++) {\n            currentValue = ((SimpleValue)(buckets.get(i).getAggregations().get(\"movavg_counts\"))).value();\n\n            // Since there are only two values in this test, at the beginning and end, the moving average should\n            // decrease every step (until it reaches zero).  Crude way to check that it's doing the right thing\n            // without actually verifying the computed values.  Should work for all types of moving avgs and\n            // gap policies\n            assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n            lastValue = currentValue;\n        }\n\n        // The last bucket has a real value, so this should always increase the moving avg\n        currentValue = ((SimpleValue)(buckets.get(numValueBuckets - 1).getAggregations().get(\"movavg_counts\"))).value();\n        assertThat(Double.compare(lastValue, currentValue), equalTo(-1));\n    }","id":84682,"modified_method":"/**\n     * This test uses the \"gap\" dataset, which is simply a doc at the beginning and end of\n     * the INTERVAL_FIELD range.  These docs have a value of 1 in GAP_FIELD.\n     * This test verifies that large gaps don't break things, and that the mov avg roughly works\n     * in the correct manner (checks direction of change, but not actual values)\n     */\n    @Test\n    public void testGiantGap() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"gap_type\")\n                .addAggregation(\n                        histogram(\"histo\").field(INTERVAL_FIELD).interval(1).minDocCount(0).extendedBounds(0L, 49L)\n                                .subAggregation(min(\"the_metric\").field(GAP_FIELD))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(randomModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(50));\n\n        double lastValue = ((SimpleValue)(buckets.get(0).getAggregations().get(\"movavg_values\"))).value();\n        assertThat(Double.compare(lastValue, 0.0d), greaterThanOrEqualTo(0));\n\n        double currentValue;\n        for (int i = 1; i < 49; i++) {\n            SimpleValue current = buckets.get(i).getAggregations().get(\"movavg_values\");\n            if (current != null) {\n                currentValue = current.value();\n\n                // Since there are only two values in this test, at the beginning and end, the moving average should\n                // decrease every step (until it reaches zero).  Crude way to check that it's doing the right thing\n                // without actually verifying the computed values.  Should work for all types of moving avgs and\n                // gap policies\n                assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n                lastValue = currentValue;\n            }\n        }\n\n\n        SimpleValue current = buckets.get(49).getAggregations().get(\"movavg_values\");\n        assertThat(current, notNullValue());\n        currentValue = current.value();\n\n        if (gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {\n            // if we are ignoring, movavg could go up (double_exp) or stay the same (simple, linear, single_exp)\n            assertThat(Double.compare(lastValue, currentValue), lessThanOrEqualTo(0));\n        } else if (gapPolicy.equals(BucketHelpers.GapPolicy.INSERT_ZEROS)) {\n            // If we insert zeros, this should always increase the moving avg since the last bucket has a real value\n            assertThat(Double.compare(lastValue, currentValue), equalTo(-1));\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testRightGapWithPredictions() {\n\n        int numPredictions = randomIntBetween(0, 10);\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(\"gap_test\").to((interval * (numValueBuckets - 1) - interval))).subAggregation(\n                                histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                        .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_counts\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .predict(numPredictions)\n                                                .setBucketsPaths(\"the_metric\"))\n                        )\n\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets + numPredictions));\n\n        double currentValue;\n        double lastValue = ((SimpleValue)(buckets.get(0).getAggregations().get(\"movavg_counts\"))).value();\n        for (int i = 1; i < numValueBuckets - 1; i++) {\n            currentValue = ((SimpleValue)(buckets.get(i).getAggregations().get(\"movavg_counts\"))).value();\n\n            assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n            lastValue = currentValue;\n        }\n\n        // Now check predictions\n        for (int i = numValueBuckets; i < numValueBuckets + numPredictions; i++) {\n            // Unclear at this point which direction the predictions will go, just verify they are\n            // not null, and that we don't have the_metric anymore\n            assertThat((buckets.get(i).getAggregations().get(\"movavg_counts\")), notNullValue());\n            assertThat((buckets.get(i).getAggregations().get(\"the_metric\")), nullValue());\n        }\n    }","id":84683,"modified_method":"@Test\n    public void testRightGapWithPredict() {\n        int numPredictions = randomIntBetween(1, 10);\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"gap_type\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(INTERVAL_FIELD).to(1)).subAggregation(\n                                histogram(\"histo\").field(INTERVAL_FIELD).interval(1).minDocCount(0).extendedBounds(0L, 49L)\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_values\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .setBucketsPaths(\"the_metric\")\n                                                .predict(numPredictions))\n                        ))\n                .execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(50 + numPredictions));\n\n\n        SimpleValue current = buckets.get(0).getAggregations().get(\"movavg_values\");\n        assertThat(current, notNullValue());\n\n        double lastValue = current.value();\n\n        double currentValue;\n        for (int i = 1; i < 50; i++) {\n            current = buckets.get(i).getAggregations().get(\"movavg_values\");\n            if (current != null) {\n                currentValue = current.value();\n\n                assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n                lastValue = currentValue;\n            }\n        }\n\n        // Now check predictions\n        for (int i = 50; i < 50 + numPredictions; i++) {\n            // Unclear at this point which direction the predictions will go, just verify they are\n            // not null, and that we don't have the_metric anymore\n            assertThat((buckets.get(i).getAggregations().get(\"movavg_values\")), notNullValue());\n            assertThat((buckets.get(i).getAggregations().get(\"the_metric\")), nullValue());\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test double exponential moving average on single value field\n     */\n    @Test\n    public void doubleExpSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new DoubleExpModel.DoubleExpModelBuilder().alpha(0.5).beta(0.5))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new DoubleExpModel.DoubleExpModelBuilder().alpha(0.5).beta(0.5))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        for (int i = 0; i < numValueBuckets; ++i) {\n            Histogram.Bucket bucket = buckets.get(i);\n            checkBucketKeyAndDocCount(\"Bucket \" + i, bucket, i * interval, docCounts[i]);\n            SimpleValue docCountMovAvg = bucket.getAggregations().get(\"movavg_counts\");\n            assertThat(docCountMovAvg, notNullValue());\n            assertThat(docCountMovAvg.value(), equalTo(doubleDocCounts[i]));\n\n            SimpleValue valuesMovAvg = bucket.getAggregations().get(\"movavg_values\");\n            assertThat(valuesMovAvg, notNullValue());\n            assertThat(valuesMovAvg.value(), equalTo(doubleDocValues[i]));\n        }\n    }","id":84684,"modified_method":"@Test\n    public void doubleSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"type\")\n                .addAggregation(\n                        histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                .subAggregation(metric)\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new DoubleExpModel.DoubleExpModelBuilder().alpha(alpha).beta(beta))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new DoubleExpModel.DoubleExpModelBuilder().alpha(alpha).beta(beta))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(mockHisto.size()));\n\n        List<Double> expectedCounts = testValues.get(MovAvgType.DOUBLE.toString() + \"_\" + MetricTarget.COUNT.toString());\n        List<Double> expectedValues = testValues.get(MovAvgType.DOUBLE.toString() + \"_\" + MetricTarget.VALUE.toString());\n\n        Iterator<? extends Histogram.Bucket> actualIter = buckets.iterator();\n        Iterator<ReducerTestHelpers.MockBucket> expectedBucketIter = mockHisto.iterator();\n        Iterator<Double> expectedCountsIter = expectedCounts.iterator();\n        Iterator<Double> expectedValuesIter = expectedValues.iterator();\n\n        while (actualIter.hasNext()) {\n            assertValidIterators(expectedBucketIter, expectedCountsIter, expectedValuesIter);\n\n            Histogram.Bucket actual = actualIter.next();\n            ReducerTestHelpers.MockBucket expected = expectedBucketIter.next();\n            Double expectedCount = expectedCountsIter.next();\n            Double expectedValue = expectedValuesIter.next();\n\n            assertThat(\"keys do not match\", ((Number) actual.getKey()).longValue(), equalTo(expected.key));\n            assertThat(\"doc counts do not match\", actual.getDocCount(), equalTo((long)expected.count));\n\n            assertBucketContents(actual, expectedCount, expectedValue);\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\");\n        createIndex(\"idx_unmapped\");\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n\n        interval = 5;\n        numValueBuckets = randomIntBetween(6, 80);\n        numFilledValueBuckets = numValueBuckets;\n        windowSize = randomIntBetween(3,10);\n        gapPolicy = randomBoolean() ? BucketHelpers.GapPolicy.IGNORE : BucketHelpers.GapPolicy.INSERT_ZEROS;\n                \n                \n        docCounts = new long[numValueBuckets];\n        docValues = new long[numValueBuckets];\n        for (int i = 0; i < numValueBuckets; i++) {\n            docCounts[i] = randomIntBetween(0, 20);\n            docValues[i] = randomIntBetween(1,20);    //this will be used as a constant for all values within a bucket\n        }\n\n        // Used for the gap tests\n        builders.add(client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder().startObject()\n                .field(\"gap_test\", 0)\n                .field(GAP_FIELD, 1).endObject()));\n        builders.add(client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder().startObject()\n                .field(\"gap_test\", (numValueBuckets - 1) * interval)\n                .field(GAP_FIELD, 1).endObject()));\n\n        this.setupSimple();\n        this.setupLinear();\n        this.setupSingle();\n        this.setupDouble();\n        \n        for (int i = 0; i < numValueBuckets; i++) {\n            for (int docs = 0; docs < docCounts[i]; docs++) {\n                builders.add(client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder().startObject()\n                        .field(SINGLE_VALUED_FIELD_NAME, i * interval)\n                        .field(SINGLE_VALUED_VALUE_FIELD_NAME, docValues[i]).endObject()));\n            }\n        }\n\n        indexRandom(true, builders);\n        ensureSearchable();\n    }","id":84685,"modified_method":"@Override\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\");\n        createIndex(\"idx_unmapped\");\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n\n\n        interval = 5;\n        numBuckets = randomIntBetween(6, 80);\n        windowSize = randomIntBetween(3, 10);\n        alpha = randomDouble();\n        beta = randomDouble();\n\n        gapPolicy = randomBoolean() ? BucketHelpers.GapPolicy.IGNORE : BucketHelpers.GapPolicy.INSERT_ZEROS;\n        metric = randomMetric(\"the_metric\", VALUE_FIELD);\n        mockHisto = ReducerTestHelpers.generateHistogram(interval, numBuckets, randomDouble(), randomDouble());\n\n        testValues = new HashMap<>(8);\n\n        for (MovAvgType type : MovAvgType.values()) {\n            for (MetricTarget target : MetricTarget.values()) {\n                setupExpected(type, target);\n            }\n        }\n\n        for (ReducerTestHelpers.MockBucket mockBucket : mockHisto) {\n            for (double value : mockBucket.docValues) {\n                builders.add(client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder().startObject()\n                        .field(INTERVAL_FIELD, mockBucket.key)\n                        .field(VALUE_FIELD, value).endObject()));\n            }\n        }\n\n        // Used for specially crafted gap tests\n        builders.add(client().prepareIndex(\"idx\", \"gap_type\").setSource(jsonBuilder().startObject()\n                .field(INTERVAL_FIELD, 0)\n                .field(GAP_FIELD, 1).endObject()));\n\n        builders.add(client().prepareIndex(\"idx\", \"gap_type\").setSource(jsonBuilder().startObject()\n                .field(INTERVAL_FIELD, 49)\n                .field(GAP_FIELD, 1).endObject()));\n\n        indexRandom(true, builders);\n        ensureSearchable();\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPredictWithNoBuckets() {\n\n        int numPredictions = randomIntBetween(0, 10);\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        // Filter so we are above all values\n                        filter(\"filtered\").filter(new RangeFilterBuilder(\"gap_test\").from((interval * (numValueBuckets - 1) + interval))).subAggregation(\n                                histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_counts\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .predict(numPredictions)\n                                                .setBucketsPaths(\"the_metric\"))\n                        )\n\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(0));\n    }","id":84686,"modified_method":"@Test\n    public void testNoBucketsInHistogramWithPredict() {\n        int numPredictions = randomIntBetween(1,10);\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"type\")\n                .addAggregation(\n                        histogram(\"histo\").field(\"test\").interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\")\n                                        .predict(numPredictions))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(0));\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testNegativeWindow() {\n        try {\n            client()\n                    .prepareSearch(\"idx\")\n                    .addAggregation(\n                            histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(-10)\n                                            .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .setBucketsPaths(\"_count\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a window that is negative\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            //Throwable rootCause = exception.unwrapCause();\n            //assertThat(rootCause, instanceOf(SearchParseException.class));\n            //assertThat(\"[window] value must be a positive, non-zero integer.  Value supplied was [0] in [movingAvg].\", equalTo(exception.getMessage()));\n        }\n    }","id":84687,"modified_method":"@Test\n    public void testNegativeWindow() {\n        try {\n            client()\n                    .prepareSearch(\"idx\").setTypes(\"type\")\n                    .addAggregation(\n                            histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(-10)\n                                            .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .setBucketsPaths(\"_count\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a window that is negative\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            //Throwable rootCause = exception.unwrapCause();\n            //assertThat(rootCause, instanceOf(SearchParseException.class));\n            //assertThat(\"[window] value must be a positive, non-zero integer.  Value supplied was [0] in [movingAvg].\", equalTo(exception.getMessage()));\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test single exponential moving average on single value field\n     */\n    @Test\n    public void singleExpSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SingleExpModel.SingleExpModelBuilder().alpha(0.5))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SingleExpModel.SingleExpModelBuilder().alpha(0.5))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        for (int i = 0; i < numValueBuckets; ++i) {\n            Histogram.Bucket bucket = buckets.get(i);\n            checkBucketKeyAndDocCount(\"Bucket \" + i, bucket, i * interval, docCounts[i]);\n            SimpleValue docCountMovAvg = bucket.getAggregations().get(\"movavg_counts\");\n            assertThat(docCountMovAvg, notNullValue());\n            assertThat(docCountMovAvg.value(), equalTo(singleDocCounts[i]));\n\n            SimpleValue valuesMovAvg = bucket.getAggregations().get(\"movavg_values\");\n            assertThat(valuesMovAvg, notNullValue());\n            assertThat(valuesMovAvg.value(), equalTo(singleDocValues[i]));\n        }\n    }","id":84688,"modified_method":"@Test\n    public void singleSingleValuedField() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"type\")\n                .addAggregation(\n                        histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                .subAggregation(metric)\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SingleExpModel.SingleExpModelBuilder().alpha(alpha))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"_count\"))\n                                .subAggregation(movingAvg(\"movavg_values\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SingleExpModel.SingleExpModelBuilder().alpha(alpha))\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(mockHisto.size()));\n\n        List<Double> expectedCounts = testValues.get(MovAvgType.SINGLE.toString() + \"_\" + MetricTarget.COUNT.toString());\n        List<Double> expectedValues = testValues.get(MovAvgType.SINGLE.toString() + \"_\" + MetricTarget.VALUE.toString());\n\n        Iterator<? extends Histogram.Bucket> actualIter = buckets.iterator();\n        Iterator<ReducerTestHelpers.MockBucket> expectedBucketIter = mockHisto.iterator();\n        Iterator<Double> expectedCountsIter = expectedCounts.iterator();\n        Iterator<Double> expectedValuesIter = expectedValues.iterator();\n\n        while (actualIter.hasNext()) {\n            assertValidIterators(expectedBucketIter, expectedCountsIter, expectedValuesIter);\n\n            Histogram.Bucket actual = actualIter.next();\n            ReducerTestHelpers.MockBucket expected = expectedBucketIter.next();\n            Double expectedCount = expectedCountsIter.next();\n            Double expectedValue = expectedValuesIter.next();\n\n            assertThat(\"keys do not match\", ((Number) actual.getKey()).longValue(), equalTo(expected.key));\n            assertThat(\"doc counts do not match\", actual.getDocCount(), equalTo((long)expected.count));\n\n            assertBucketContents(actual, expectedCount, expectedValue);\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testNoBucketsInHistogram() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        histogram(\"histo\").field(\"test\").interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(0));\n    }","id":84689,"modified_method":"@Test\n    public void testNoBucketsInHistogram() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"type\")\n                .addAggregation(\n                        histogram(\"histo\").field(\"test\").interval(interval).minDocCount(0)\n                                .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                .subAggregation(movingAvg(\"movavg_counts\")\n                                        .window(windowSize)\n                                        .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                        .gapPolicy(gapPolicy)\n                                        .setBucketsPaths(\"the_metric\"))\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalHistogram<Bucket> histo = response.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(0));\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSizeZeroWindow() {\n        try {\n            client()\n                    .prepareSearch(\"idx\")\n                    .addAggregation(\n                            histogram(\"histo\").field(SINGLE_VALUED_FIELD_NAME).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(0)\n                                            .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a window that is zero\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            //Throwable rootCause = exception.unwrapCause();\n            //assertThat(rootCause, instanceOf(SearchParseException.class));\n            //assertThat(\"[window] value must be a positive, non-zero integer.  Value supplied was [0] in [movingAvg].\", equalTo(exception.getMessage()));\n        }\n    }","id":84690,"modified_method":"@Test\n    public void testSizeZeroWindow() {\n        try {\n            client()\n                    .prepareSearch(\"idx\").setTypes(\"type\")\n                    .addAggregation(\n                            histogram(\"histo\").field(INTERVAL_FIELD).interval(interval).minDocCount(0)\n                                    .extendedBounds(0L, (long) (interval * (numBuckets - 1)))\n                                    .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(0)\n                                            .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept a window that is zero\");\n\n        } catch (SearchPhaseExecutionException exception) {\n           // All good\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLeftGapWithPrediction() {\n\n        int numPredictions = randomIntBetween(0, 10);\n        \n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(\"gap_test\").from(1)).subAggregation(\n                                histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                        .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_counts\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .predict(numPredictions)\n                                                .setBucketsPaths(\"the_metric\"))\n                        )\n\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets + numPredictions));\n\n        double currentValue;\n        double lastValue = 0.0;\n        for (int i = 0; i < numValueBuckets - 1; i++) {\n            currentValue = ((SimpleValue)(buckets.get(i).getAggregations().get(\"movavg_counts\"))).value();\n\n            assertThat(Double.compare(lastValue, currentValue), lessThanOrEqualTo(0));\n            lastValue = currentValue;\n        }\n\n        // Now check predictions\n        for (int i = numValueBuckets; i < numValueBuckets + numPredictions; i++) {\n            // Unclear at this point which direction the predictions will go, just verify they are\n            // not null, and that we don't have the_metric anymore\n            assertThat((buckets.get(i).getAggregations().get(\"movavg_counts\")), notNullValue());\n            assertThat((buckets.get(i).getAggregations().get(\"the_metric\")), nullValue());\n        }\n    }","id":84691,"modified_method":"@Test\n    public void testLeftGapWithPredict() {\n        int numPredictions = randomIntBetween(1, 10);\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"gap_type\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(INTERVAL_FIELD).from(1)).subAggregation(\n                                histogram(\"histo\").field(INTERVAL_FIELD).interval(1).minDocCount(0).extendedBounds(0L, 49L)\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_values\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .setBucketsPaths(\"the_metric\")\n                                                .predict(numPredictions))\n                        ))\n                .execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(50 + numPredictions));\n\n        double lastValue = 0;\n\n        double currentValue;\n        for (int i = 0; i < 50; i++) {\n            SimpleValue current = buckets.get(i).getAggregations().get(\"movavg_values\");\n            if (current != null) {\n                currentValue = current.value();\n\n                assertThat(Double.compare(lastValue, currentValue), lessThanOrEqualTo(0));\n                lastValue = currentValue;\n            }\n        }\n\n        // Now check predictions\n        for (int i = 50; i < 50 + numPredictions; i++) {\n            // Unclear at this point which direction the predictions will go, just verify they are\n            // not null, and that we don't have the_metric anymore\n            assertThat((buckets.get(i).getAggregations().get(\"movavg_values\")), notNullValue());\n            assertThat((buckets.get(i).getAggregations().get(\"the_metric\")), nullValue());\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * This test filters the \"gap\" data so that the last doc is excluded.  This leaves a long stretch of empty\n     * buckets after the first bucket.  The moving avg should be one at the beginning, then zero for the rest\n     * regardless of mov avg type or gap policy.\n     */\n    @Test\n    public void testRightGap() {\n\n        SearchResponse response = client()\n                .prepareSearch(\"idx\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(\"gap_test\").to((interval * (numValueBuckets - 1) - interval))).subAggregation(\n                                histogram(\"histo\").field(\"gap_test\").interval(interval).minDocCount(0)\n                                        .extendedBounds(0L, (long) (interval * (numValueBuckets - 1)))\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_counts\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .setBucketsPaths(\"the_metric\"))\n                        )\n\n                ).execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(buckets.size(), equalTo(numValueBuckets));\n\n        double currentValue;\n        double lastValue = ((SimpleValue)(buckets.get(0).getAggregations().get(\"movavg_counts\"))).value();\n        for (int i = 1; i < numValueBuckets - 1; i++) {\n            currentValue = ((SimpleValue)(buckets.get(i).getAggregations().get(\"movavg_counts\"))).value();\n\n            assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n            lastValue = currentValue;\n        }\n\n    }","id":84692,"modified_method":"/**\n     * This test filters the \"gap\" data so that the last doc is excluded.  This leaves a long stretch of empty\n     * buckets after the first bucket.  The moving avg should be one at the beginning, then zero for the rest\n     * regardless of mov avg type or gap policy.\n     */\n    @Test\n    public void testRightGap() {\n        SearchResponse response = client()\n                .prepareSearch(\"idx\").setTypes(\"gap_type\")\n                .addAggregation(\n                        filter(\"filtered\").filter(new RangeFilterBuilder(INTERVAL_FIELD).to(1)).subAggregation(\n                                histogram(\"histo\").field(INTERVAL_FIELD).interval(1).minDocCount(0).extendedBounds(0L, 49L)\n                                        .subAggregation(randomMetric(\"the_metric\", GAP_FIELD))\n                                        .subAggregation(movingAvg(\"movavg_values\")\n                                                .window(windowSize)\n                                                .modelBuilder(randomModelBuilder())\n                                                .gapPolicy(gapPolicy)\n                                                .setBucketsPaths(\"the_metric\"))\n                        ))\n                .execute().actionGet();\n\n        assertSearchResponse(response);\n\n        InternalFilter filtered = response.getAggregations().get(\"filtered\");\n        assertThat(filtered, notNullValue());\n        assertThat(filtered.getName(), equalTo(\"filtered\"));\n\n        InternalHistogram<Bucket> histo = filtered.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        assertThat(histo.getName(), equalTo(\"histo\"));\n        List<? extends Bucket> buckets = histo.getBuckets();\n        assertThat(\"Size of buckets array is not correct.\", buckets.size(), equalTo(50));\n\n\n        SimpleValue current = buckets.get(0).getAggregations().get(\"movavg_values\");\n        assertThat(current, notNullValue());\n\n        double lastValue = current.value();\n\n        double currentValue;\n        for (int i = 1; i < 50; i++) {\n            current = buckets.get(i).getAggregations().get(\"movavg_values\");\n            if (current != null) {\n                currentValue = current.value();\n\n                assertThat(Double.compare(lastValue, currentValue), greaterThanOrEqualTo(0));\n                lastValue = currentValue;\n            }\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testBadParent() {\n        try {\n            client()\n                    .prepareSearch(\"idx\")\n                    .addAggregation(\n                            range(\"histo\").field(SINGLE_VALUED_FIELD_NAME).addRange(0, 10)\n                                    .subAggregation(randomMetric(\"the_metric\", SINGLE_VALUED_VALUE_FIELD_NAME))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(0)\n                                            .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept non-histogram as parent\");\n\n        } catch (SearchPhaseExecutionException exception) {\n           // All good\n        }\n    }","id":84693,"modified_method":"@Test\n    public void testBadParent() {\n        try {\n            client()\n                    .prepareSearch(\"idx\").setTypes(\"type\")\n                    .addAggregation(\n                            range(\"histo\").field(INTERVAL_FIELD).addRange(0, 10)\n                                    .subAggregation(randomMetric(\"the_metric\", VALUE_FIELD))\n                                    .subAggregation(movingAvg(\"movavg_counts\")\n                                            .window(0)\n                                            .modelBuilder(new SimpleModel.SimpleModelBuilder())\n                                            .gapPolicy(gapPolicy)\n                                            .setBucketsPaths(\"the_metric\"))\n                    ).execute().actionGet();\n            fail(\"MovingAvg should not accept non-histogram as parent\");\n\n        } catch (SearchPhaseExecutionException exception) {\n            // All good\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private MovAvgModelBuilder randomModelBuilder() {\n        int rand = randomIntBetween(0,3);\n\n        switch (rand) {\n            case 0:\n                return new SimpleModel.SimpleModelBuilder();\n            case 1:\n                return new LinearModel.LinearModelBuilder();\n            case 2:\n                return new SingleExpModel.SingleExpModelBuilder().alpha(randomDouble());\n            case 3:\n                return new DoubleExpModel.DoubleExpModelBuilder().alpha(randomDouble()).beta(randomDouble());\n            default:\n                return new SimpleModel.SimpleModelBuilder();\n        }\n    }","id":84694,"modified_method":"private MovAvgModelBuilder randomModelBuilder() {\n        int rand = randomIntBetween(0,3);\n\n        switch (rand) {\n            case 0:\n                return new SimpleModel.SimpleModelBuilder();\n            case 1:\n                return new LinearModel.LinearModelBuilder();\n            case 2:\n                return new SingleExpModel.SingleExpModelBuilder().alpha(alpha);\n            case 3:\n                return new DoubleExpModel.DoubleExpModelBuilder().alpha(alpha).beta(beta);\n            default:\n                return new SimpleModel.SimpleModelBuilder();\n        }\n    }","commit_id":"114d10e5a96b071121ac7862e176b1e15112aadb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void submit(Runnable change)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Queued change {}\", change);\n\n        try (SpinLock.Lock lock = _lock.lock())\n        {\n            _actions.offer(change);\n            if (_selecting)\n            {\n                _selector.wakeup();\n                // To avoid the extra select wakeup.\n                _selecting=false;\n            }\n        }\n    }","id":84695,"modified_method":"public void submit(Runnable change)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Queued change {}\", change);\n\n        try (SpinLock.Lock lock = _lock.lock())\n        {\n            _actions.offer(change);\n            if (_selecting)\n            {\n                if (_selector!=null)\n                    _selector.wakeup();\n                // To avoid the extra select wakeup.\n                _selecting=false;\n            }\n        }\n    }","commit_id":"c4a49110efe47c7f5554dc52b829b4ae53884f95","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void run()\n        {\n            Selector selector=_selector;\n            _selector=null;\n            closeNoExceptions(selector);\n            _latch.countDown();\n        }","id":84696,"modified_method":"@Override\n        public void run()\n        {\n            Selector selector;\n            try(SpinLock.Lock lock = _lock.lock())\n            {\n                selector=_selector;\n                _selector=null;\n            }\n            closeNoExceptions(selector);\n            _latch.countDown();\n        }","commit_id":"c4a49110efe47c7f5554dc52b829b4ae53884f95","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n       super.stop();\n      serverStopping = true;\n\n       if(reaper != null)\n           reaper.stop();\n\n      // Stop the main selector\n      m_acceptSelector.wakeup();\n\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].queue.put(new Shutdown());\n            m_writeHandlers[i].selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      if(m_requestProcessors instanceof ThreadPoolExecutor)\n         ((ThreadPoolExecutor)m_requestProcessors).shutdownNow();\n\n       if(m_requestProcessors instanceof ThreadPoolExecutor){\n\t    try{\n\t\t((ThreadPoolExecutor) m_requestProcessors).awaitTermination(Global.THREADPOOL_SHUTDOWN_WAIT_TIME,\n\t\t\t\t\t\t\t\t\t    TimeUnit.MILLISECONDS);\n\t    }catch(InterruptedException e){\n\t    }\n\t}\n\n      // then close the connections\n      synchronized(conns) {\n          Iterator it=conns.values().iterator();\n          while(it.hasNext()) {\n              Connection conn=(Connection)it.next();\n              conn.destroy();\n          }\n          conns.clear();\n      }\n\n      while(!m_backGroundThreads.isEmpty()) {\n          Thread t =m_backGroundThreads.remove(0);\n          try {\n            t.join();\n          } catch(InterruptedException e) {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while waiting on thread \" + t.getName() + \" to finish.\");\n          }\n      }\n      m_backGroundThreads.clear();\n\n   }","id":84697,"modified_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n       super.stop();\n      serverStopping = true;\n\n       if(reaper != null)\n           reaper.stop();\n\n      // Stop the main selector\n      if(m_acceptSelector != null)\n          m_acceptSelector.wakeup();\n\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].queue.put(new Shutdown());\n            m_writeHandlers[i].selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      if(m_requestProcessors instanceof ThreadPoolExecutor)\n         ((ThreadPoolExecutor)m_requestProcessors).shutdownNow();\n\n       if(m_requestProcessors instanceof ThreadPoolExecutor){\n\t    try{\n\t\t((ThreadPoolExecutor) m_requestProcessors).awaitTermination(Global.THREADPOOL_SHUTDOWN_WAIT_TIME,\n\t\t\t\t\t\t\t\t\t    TimeUnit.MILLISECONDS);\n\t    }catch(InterruptedException e){\n\t    }\n\t}\n\n      // then close the connections\n      synchronized(conns) {\n          Iterator it=conns.values().iterator();\n          while(it.hasNext()) {\n              Connection conn=(Connection)it.next();\n              conn.destroy();\n          }\n          conns.clear();\n      }\n\n      while(!m_backGroundThreads.isEmpty()) {\n          Thread t =m_backGroundThreads.remove(0);\n          try {\n            t.join();\n          } catch(InterruptedException e) {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while waiting on thread \" + t.getName() + \" to finish.\");\n          }\n      }\n      m_backGroundThreads.clear();\n\n   }","commit_id":"473e1a623dad30ef375a840d6fa0c0469af5f7d5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n       super.stop();\n      serverStopping = true;\n\n       if(reaper != null)\n           reaper.stop();\n\n      // Stop the main selector\n      m_acceptSelector.wakeup();\n\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].queue.put(new Shutdown());\n            m_writeHandlers[i].selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      if(m_requestProcessors instanceof ThreadPoolExecutor)\n         ((ThreadPoolExecutor)m_requestProcessors).shutdownNow();\n\n       if(m_requestProcessors instanceof ThreadPoolExecutor){\n\t    try{\n\t\t((ThreadPoolExecutor) m_requestProcessors).awaitTermination(Global.THREADPOOL_SHUTDOWN_WAIT_TIME,\n\t\t\t\t\t\t\t\t\t    TimeUnit.MILLISECONDS);\n\t    }catch(InterruptedException e){\n\t    }\n\t}\n\n      // then close the connections\n      synchronized(conns) {\n          Iterator it=conns.values().iterator();\n          while(it.hasNext()) {\n              Connection conn=(Connection)it.next();\n              conn.destroy();\n          }\n          conns.clear();\n      }\n\n      while(!m_backGroundThreads.isEmpty()) {\n          Thread t =m_backGroundThreads.remove(0);\n          try {\n            t.join();\n          } catch(InterruptedException e) {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while waiting on thread \" + t.getName() + \" to finish.\");\n          }\n      }\n      m_backGroundThreads.clear();\n\n   }","id":84698,"modified_method":"/**\n    * Closes all open sockets, the server socket and all threads waiting for incoming messages\n    */\n   public void stop()\n   {\n       super.stop();\n      serverStopping = true;\n\n       if(reaper != null)\n           reaper.stop();\n\n      // Stop the main selector\n      if(m_acceptSelector != null)\n          m_acceptSelector.wakeup();\n\n      // Stop selector threads\n      for (int i = 0; i < m_readHandlers.length; i++)\n      {\n         try\n         {\n            m_readHandlers[i].add(new Shutdown());\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n      for (int i = 0; i < m_writeHandlers.length; i++)\n      {\n         try\n         {\n            m_writeHandlers[i].queue.put(new Shutdown());\n            m_writeHandlers[i].selector.wakeup();\n         } catch (InterruptedException e)\n         {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted, failed to shutdown selector\", e);\n         }\n      }\n\n      // Stop the callback thread pool\n      if(m_requestProcessors instanceof ThreadPoolExecutor)\n         ((ThreadPoolExecutor)m_requestProcessors).shutdownNow();\n\n       if(m_requestProcessors instanceof ThreadPoolExecutor){\n\t    try{\n\t\t((ThreadPoolExecutor) m_requestProcessors).awaitTermination(Global.THREADPOOL_SHUTDOWN_WAIT_TIME,\n\t\t\t\t\t\t\t\t\t    TimeUnit.MILLISECONDS);\n\t    }catch(InterruptedException e){\n\t    }\n\t}\n\n      // then close the connections\n      synchronized(conns) {\n          Iterator it=conns.values().iterator();\n          while(it.hasNext()) {\n              Connection conn=(Connection)it.next();\n              conn.destroy();\n          }\n          conns.clear();\n      }\n\n      while(!m_backGroundThreads.isEmpty()) {\n          Thread t =m_backGroundThreads.remove(0);\n          try {\n            t.join();\n          } catch(InterruptedException e) {\n            log.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while waiting on thread \" + t.getName() + \" to finish.\");\n          }\n      }\n      m_backGroundThreads.clear();\n\n   }","commit_id":"820a270c927a51953319c6ce81e91a3db7148de5","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message        msg;\n        Address        dst, src;\n        UnicastHeader  hdr;\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                dst=msg.getDest();\n\n                if(dst == null || dst.isMulticastAddress())  // only handle unicast messages\n                    break;  // pass up\n\n                // changed from removeHeader(): we cannot remove the header because if we do loopback=true at the\n                // transport level, we will not have the header on retransmit ! (bela Aug 22 2006)\n                hdr=(UnicastHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break;\n                src=msg.getSrc();\n                switch(hdr.type) {\n                    case UnicastHeader.DATA:      // received regular message\n                        handleDataReceived(src, hdr.seqno, hdr.conn_id, hdr.first, msg);\n                        return null; // we pass the deliverable message up in handleDataReceived()\n                    case UnicastHeader.ACK:  // received ACK for previously sent message\n                        handleAckReceived(src, hdr.seqno);\n                        break;\n                    case UnicastHeader.SEND_FIRST_SEQNO:\n                        handleResendingOfFirstMessage(src);\n                        break;\n                    default:\n                        log.error(\"UnicastHeader type \" + hdr.type + \" not known !\");\n                        break;\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);   // Pass up to the layer above us\n    }","id":84699,"modified_method":"public Object up(Event evt) {\n        Message        msg;\n        Address        dst, src;\n        UnicastHeader  hdr;\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                dst=msg.getDest();\n\n                if(dst == null || dst.isMulticastAddress())  // only handle unicast messages\n                    break;  // pass up\n\n                // changed from removeHeader(): we cannot remove the header because if we do loopback=true at the\n                // transport level, we will not have the header on retransmit ! (bela Aug 22 2006)\n                hdr=(UnicastHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break;\n                src=msg.getSrc();\n                switch(hdr.type) {\n                    case UnicastHeader.DATA:      // received regular message\n                        handleDataReceived(src, hdr.seqno, hdr.conn_id, hdr.first, msg, evt);\n                        return null; // we pass the deliverable message up in handleDataReceived()\n                    case UnicastHeader.ACK:  // received ACK for previously sent message\n                        handleAckReceived(src, hdr.seqno);\n                        break;\n                    case UnicastHeader.SEND_FIRST_SEQNO:\n                        handleResendingOfFirstMessage(src);\n                        break;\n                    default:\n                        log.error(\"UnicastHeader type \" + hdr.type + \" not known !\");\n                        break;\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);   // Pass up to the layer above us\n    }","commit_id":"e33277d17b853ec5791c42f519740eedd592c721","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        ReceiverEntry entry=recv_table.get(sender);\n        AckReceiverWindow win=entry != null? entry.received_msgs : null;\n\n        if(first) {\n            if(entry == null) {\n                entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                win=entry.received_msgs;\n            }\n            else {  // entry != null && win != null\n                if(conn_id != entry.recv_conn_id) {\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n\n                    ReceiverEntry entry2=recv_table.remove(sender);\n                    if(entry2 != null)\n                        entry2.received_msgs.reset();\n                    \n                    entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                    win=entry.received_msgs;\n                }\n                else {\n                    ;\n                }\n            }\n        }\n        else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n            if(win == null || entry.recv_conn_id != conn_id) {\n                sendRequestForFirstSeqno(sender); // drops the message and returns (see below)\n                return;\n            }\n        }\n\n        byte result=win.add2(seqno, msg); // win is guaranteed to be non-null if we get here\n        boolean added=result > 0;\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        if(added && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // Cannot be replaced with if(!added), see https://jira.jboss.org/jira/browse/JGRP-1043 comment 15/Sep/09 06:57 AM\n\n        // We *have* to do send the ACK, to cover the following scenario:\n        // - A sends #3 to B\n        // - B removes #3 and sends ACK(3) to A. B's next_to_remove is now 4\n        // - B's ACK(3) to A is dropped by the network\n        // - A keeps retransmitting #3 to B, until it gets an ACK(3)\n        // -B will never ACK #3 if the 2 lines below are commented ==> endless retransmission of A's #3 !\n        if(result == -1) { // only ack if seqno was < next_to_remove !\n            sendAck(msg.getSrc(), seqno);\n        }\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added)\n                up_prot.up(new Event(Event.MSG, msg));\n            long highest_oob_seqno=win.removeOOBMessages();\n            if(!(undelivered_msgs.get() > 0 && win.hasMessagesToRemove())) {\n                if(highest_oob_seqno != -1)\n                    sendAck(sender, highest_oob_seqno);\n                return;\n            }\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n        int num_regular_msgs_removed=0;\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                List<Message> msgs=win.removeMany();\n                if(msgs.isEmpty())\n                    return;\n\n                Message highest_removed=msgs.get(msgs.size() -1);\n                sendAckForMessage(highest_removed); // guaranteed not to throw an exception !\n                for(Message m: msgs) {\n                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                    if(m.isFlagSet(Message.OOB))\n                        continue;\n                    num_regular_msgs_removed++;\n                    try {\n                        up_prot.up(new Event(Event.MSG, m));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + m, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n            processing.set(false);\n        }\n    }","id":84700,"modified_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg, Event evt) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        ReceiverEntry entry=recv_table.get(sender);\n        AckReceiverWindow win=entry != null? entry.received_msgs : null;\n\n        if(first) {\n            if(entry == null) {\n                entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                win=entry.received_msgs;\n            }\n            else {  // entry != null && win != null\n                if(conn_id != entry.recv_conn_id) {\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n\n                    ReceiverEntry entry2=recv_table.remove(sender);\n                    if(entry2 != null)\n                        entry2.received_msgs.reset();\n                    \n                    entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                    win=entry.received_msgs;\n                }\n                else {\n                    ;\n                }\n            }\n        }\n        else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n            if(win == null || entry.recv_conn_id != conn_id) {\n                sendRequestForFirstSeqno(sender); // drops the message and returns (see below)\n                return;\n            }\n        }\n\n        byte result=win.add2(seqno, msg); // win is guaranteed to be non-null if we get here\n        boolean added=result > 0;\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        // Cannot be replaced with if(!added), see https://jira.jboss.org/jira/browse/JGRP-1043 comment 15/Sep/09 06:57 AM\n\n        // We *have* to do send the ACK, to cover the following scenario:\n        // - A sends #3 to B\n        // - B removes #3 and sends ACK(3) to A. B's next_to_remove is now 4\n        // - B's ACK(3) to A is dropped by the network\n        // - A keeps retransmitting #3 to B, until it gets an ACK(3)\n        // -B will never ACK #3 if the 2 lines below are commented ==> endless retransmission of A's #3 !\n        if(result == -1) { // only ack if seqno was < next_to_remove !\n            sendAck(sender, seqno);\n        }\n\n        // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB) && added) {\n            try {\n                up_prot.up(evt);\n            }\n            catch(Throwable t) {\n                log.error(\"couldn't deliver OOB message \" + msg, t);\n            }\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a concurrent stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                Tuple<List<Message>,Long> tuple=win.removeMany(max_msg_batch_size);\n                List<Message> msgs=tuple.getVal1();\n                if(msgs.isEmpty())\n                    return;\n\n                long highest_removed=tuple.getVal2();\n                if(highest_removed > 0)\n                    sendAck(sender, highest_removed); // guaranteed not to throw an exception !\n\n                for(Message m: msgs) {\n                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                    if(m.isFlagSet(Message.OOB))\n                        continue;\n                    try {\n                        up_prot.up(new Event(Event.MSG, m));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + m, t);\n                    }\n                }\n            }\n        }\n        finally {\n            processing.set(false);\n        }\n    }","commit_id":"e33277d17b853ec5791c42f519740eedd592c721","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedAttribute\n    public int getUndeliveredMessages() {\n        return undelivered_msgs.get();\n    }","id":84701,"modified_method":"@Deprecated @ManagedAttribute\n    public static int getUndeliveredMessages() {\n        return 0;\n    }","commit_id":"e33277d17b853ec5791c42f519740eedd592c721","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        started=false;\n        removeAllConnections();\n        undelivered_msgs.set(0);\n    }","id":84702,"modified_method":"public void stop() {\n        started=false;\n        removeAllConnections();\n    }","commit_id":"e33277d17b853ec5791c42f519740eedd592c721","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        started=false;\n        removeAllConnections();\n        undelivered_msgs.set(0);\n    }","id":84703,"modified_method":"public void stop() {\n        started=false;\n        removeAllConnections();\n    }","commit_id":"48f17d6cdf008c7f29c1d52099307d11d51580a4","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedAttribute\n    public int getUndeliveredMessages() {\n        return undelivered_msgs.get();\n    }","id":84704,"modified_method":"@Deprecated @ManagedAttribute\n    public static int getUndeliveredMessages() {\n        return 0;\n    }","commit_id":"48f17d6cdf008c7f29c1d52099307d11d51580a4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        ReceiverEntry entry=recv_table.get(sender);\n        AckReceiverWindow win=entry != null? entry.received_msgs : null;\n\n        if(first) {\n            if(entry == null) {\n                entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                win=entry.received_msgs;\n            }\n            else {  // entry != null && win != null\n                if(conn_id != entry.recv_conn_id) {\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n\n                    ReceiverEntry entry2=recv_table.remove(sender);\n                    if(entry2 != null)\n                        entry2.received_msgs.reset();\n                    \n                    entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                    win=entry.received_msgs;\n                }\n                else {\n                    ;\n                }\n            }\n        }\n        else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n            if(win == null || entry.recv_conn_id != conn_id) {\n                sendRequestForFirstSeqno(sender); // drops the message and returns (see below)\n                return;\n            }\n        }\n\n        byte result=win.add2(seqno, msg); // win is guaranteed to be non-null if we get here\n        boolean added=result > 0;\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        if(added && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // Cannot be replaced with if(!added), see https://jira.jboss.org/jira/browse/JGRP-1043 comment 15/Sep/09 06:57 AM\n\n        // We *have* to do send the ACK, to cover the following scenario:\n        // - A sends #3 to B\n        // - B removes #3 and sends ACK(3) to A. B's next_to_remove is now 4\n        // - B's ACK(3) to A is dropped by the network\n        // - A keeps retransmitting #3 to B, until it gets an ACK(3)\n        // -B will never ACK #3 if the 2 lines below are commented ==> endless retransmission of A's #3 !\n        if(result == -1) { // only ack if seqno was < next_to_remove !\n            sendAck(msg.getSrc(), seqno);\n        }\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added)\n                up_prot.up(new Event(Event.MSG, msg));\n            long highest_oob_seqno=win.removeOOBMessages();\n            if(!(undelivered_msgs.get() > 0 && win.hasMessagesToRemove())) {\n                if(highest_oob_seqno != -1)\n                    sendAck(sender, highest_oob_seqno);\n                return;\n            }\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n        int num_regular_msgs_removed=0;\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                List<Message> msgs=win.removeMany();\n                if(msgs.isEmpty())\n                    return;\n\n                Message highest_removed=msgs.get(msgs.size() -1);\n                sendAckForMessage(highest_removed); // guaranteed not to throw an exception !\n                for(Message m: msgs) {\n                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                    if(m.isFlagSet(Message.OOB))\n                        continue;\n                    num_regular_msgs_removed++;\n                    try {\n                        up_prot.up(new Event(Event.MSG, m));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + m, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n            processing.set(false);\n        }\n    }","id":84705,"modified_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg, Event evt) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        ReceiverEntry entry=recv_table.get(sender);\n        AckReceiverWindow win=entry != null? entry.received_msgs : null;\n\n        if(first) {\n            if(entry == null) {\n                entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                win=entry.received_msgs;\n            }\n            else {  // entry != null && win != null\n                if(conn_id != entry.recv_conn_id) {\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n\n                    ReceiverEntry entry2=recv_table.remove(sender);\n                    if(entry2 != null)\n                        entry2.received_msgs.reset();\n                    \n                    entry=getOrCreateReceiverEntry(sender, seqno, conn_id);\n                    win=entry.received_msgs;\n                }\n                else {\n                    ;\n                }\n            }\n        }\n        else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n            if(win == null || entry.recv_conn_id != conn_id) {\n                sendRequestForFirstSeqno(sender); // drops the message and returns (see below)\n                return;\n            }\n        }\n\n        byte result=win.add2(seqno, msg); // win is guaranteed to be non-null if we get here\n        boolean added=result > 0;\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        // Cannot be replaced with if(!added), see https://jira.jboss.org/jira/browse/JGRP-1043 comment 15/Sep/09 06:57 AM\n\n        // We *have* to do send the ACK, to cover the following scenario:\n        // - A sends #3 to B\n        // - B removes #3 and sends ACK(3) to A. B's next_to_remove is now 4\n        // - B's ACK(3) to A is dropped by the network\n        // - A keeps retransmitting #3 to B, until it gets an ACK(3)\n        // -B will never ACK #3 if the 2 lines below are commented ==> endless retransmission of A's #3 !\n        if(result == -1) { // only ack if seqno was < next_to_remove !\n            sendAck(sender, seqno);\n        }\n\n        // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB) && added) {\n            try {\n                up_prot.up(evt);\n            }\n            catch(Throwable t) {\n                log.error(\"couldn't deliver OOB message \" + msg, t);\n            }\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a concurrent stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                Tuple<List<Message>,Long> tuple=win.removeMany(max_msg_batch_size);\n                List<Message> msgs=tuple.getVal1();\n                if(msgs.isEmpty())\n                    return;\n\n                long highest_removed=tuple.getVal2();\n                if(highest_removed > 0)\n                    sendAck(sender, highest_removed); // guaranteed not to throw an exception !\n\n                for(Message m: msgs) {\n                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                    if(m.isFlagSet(Message.OOB))\n                        continue;\n                    try {\n                        up_prot.up(new Event(Event.MSG, m));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + m, t);\n                    }\n                }\n            }\n        }\n        finally {\n            processing.set(false);\n        }\n    }","commit_id":"48f17d6cdf008c7f29c1d52099307d11d51580a4","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message        msg;\n        Address        dst, src;\n        UnicastHeader  hdr;\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                dst=msg.getDest();\n\n                if(dst == null || dst.isMulticastAddress())  // only handle unicast messages\n                    break;  // pass up\n\n                // changed from removeHeader(): we cannot remove the header because if we do loopback=true at the\n                // transport level, we will not have the header on retransmit ! (bela Aug 22 2006)\n                hdr=(UnicastHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break;\n                src=msg.getSrc();\n                switch(hdr.type) {\n                    case UnicastHeader.DATA:      // received regular message\n                        handleDataReceived(src, hdr.seqno, hdr.conn_id, hdr.first, msg);\n                        return null; // we pass the deliverable message up in handleDataReceived()\n                    case UnicastHeader.ACK:  // received ACK for previously sent message\n                        handleAckReceived(src, hdr.seqno);\n                        break;\n                    case UnicastHeader.SEND_FIRST_SEQNO:\n                        handleResendingOfFirstMessage(src);\n                        break;\n                    default:\n                        log.error(\"UnicastHeader type \" + hdr.type + \" not known !\");\n                        break;\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);   // Pass up to the layer above us\n    }","id":84706,"modified_method":"public Object up(Event evt) {\n        Message        msg;\n        Address        dst, src;\n        UnicastHeader  hdr;\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                dst=msg.getDest();\n\n                if(dst == null || dst.isMulticastAddress())  // only handle unicast messages\n                    break;  // pass up\n\n                // changed from removeHeader(): we cannot remove the header because if we do loopback=true at the\n                // transport level, we will not have the header on retransmit ! (bela Aug 22 2006)\n                hdr=(UnicastHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break;\n                src=msg.getSrc();\n                switch(hdr.type) {\n                    case UnicastHeader.DATA:      // received regular message\n                        handleDataReceived(src, hdr.seqno, hdr.conn_id, hdr.first, msg, evt);\n                        return null; // we pass the deliverable message up in handleDataReceived()\n                    case UnicastHeader.ACK:  // received ACK for previously sent message\n                        handleAckReceived(src, hdr.seqno);\n                        break;\n                    case UnicastHeader.SEND_FIRST_SEQNO:\n                        handleResendingOfFirstMessage(src);\n                        break;\n                    default:\n                        log.error(\"UnicastHeader type \" + hdr.type + \" not known !\");\n                        break;\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);   // Pass up to the layer above us\n    }","commit_id":"48f17d6cdf008c7f29c1d52099307d11d51580a4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see XWikiAction#render(XWikiContext)\n     */\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        XWiki xwiki = context.getWiki();\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n        VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n\n        String language = ((EditForm) form).getLanguage();\n\n        // Make sure it is not considered as new\n        XWikiDocument doc2 = doc.clone();\n        context.put(\"doc\", doc2);\n\n        int sectionNumber = 0;\n        if (request.getParameter(\"section\") != null && context.getWiki().hasSectionEdit(context)) {\n            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n        }\n        vcontext.put(\"sectionNumber\", new Integer(sectionNumber));\n\n        if ((language == null) || (language.equals(\"\")) || (language.equals(\"default\"))\n            || (language.equals(doc.getDefaultLanguage()))) {\n            context.put(\"tdoc\", doc2);\n            vcontext.put(\"doc\", doc2.newDocument(context));\n            vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n            vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n            doc2.readFromTemplate(((EditForm) form).getTemplate(), context);\n            doc2.readFromForm((EditForm) form, context);\n            doc2.setAuthor(context.getUser());\n            doc2.setContentAuthor(context.getUser());\n            if (doc2.isNew()) {\n                doc2.setCreator(context.getUser());\n            }\n        } else {\n            // Need to save parent and defaultLanguage if they have changed\n            XWikiDocument tdoc = doc.getTranslatedDocument(language, context).clone();\n            tdoc.setLanguage(language);\n            tdoc.setTranslation(1);\n            context.put(\"tdoc\", tdoc);\n            vcontext.put(\"tdoc\", tdoc.newDocument(context));\n            vcontext.put(\"cdoc\", vcontext.get(\"tdoc\"));\n            tdoc.readFromTemplate(((EditForm) form).getTemplate(), context);\n            tdoc.readFromForm((EditForm) form, context);\n            tdoc.setAuthor(context.getUser());\n            tdoc.setContentAuthor(context.getUser());\n            if (tdoc.isNew()) {\n                tdoc.setCreator(context.getUser());\n            }\n        }\n        // reconfirm edit (captcha) when jcaptcha is not correct\n        if ((context.get(\"recheckcaptcha\") != null) && ((Boolean) context.get(\"recheckcaptcha\")).booleanValue()) {\n            return \"captcha\";\n        } else {\n            return \"preview\";\n        }\n    }","id":84707,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see XWikiAction#render(XWikiContext)\n     */\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n        EditForm form = (EditForm) context.getForm();\n        VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n\n        String language = form.getLanguage();\n\n        // Make sure it is not considered as new\n        XWikiDocument doc2 = doc.clone();\n        context.put(\"doc\", doc2);\n\n        int sectionNumber = 0;\n        if (request.getParameter(\"section\") != null && context.getWiki().hasSectionEdit(context)) {\n            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n        }\n        vcontext.put(\"sectionNumber\", new Integer(sectionNumber));\n\n        if ((language == null) || (language.equals(\"\")) || (language.equals(\"default\"))\n            || (language.equals(doc.getDefaultLanguage()))) {\n            context.put(\"tdoc\", doc2);\n            vcontext.put(\"doc\", doc2.newDocument(context));\n            vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n            vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n            doc2.readFromTemplate(form.getTemplate(), context);\n            doc2.readFromForm(form, context);\n            doc2.setAuthorReference(context.getUserReference());\n            doc2.setContentAuthorReference(context.getUserReference());\n            if (doc2.isNew()) {\n                doc2.setCreatorReference(context.getUserReference());\n            }\n        } else {\n            // Need to save parent and defaultLanguage if they have changed\n            XWikiDocument tdoc = doc.getTranslatedDocument(language, context).clone();\n            tdoc.setLanguage(language);\n            tdoc.setTranslation(1);\n            context.put(\"tdoc\", tdoc);\n            vcontext.put(\"tdoc\", tdoc.newDocument(context));\n            vcontext.put(\"cdoc\", vcontext.get(\"tdoc\"));\n            tdoc.readFromTemplate(form.getTemplate(), context);\n            tdoc.readFromForm(form, context);\n            tdoc.setAuthorReference(context.getUserReference());\n            tdoc.setContentAuthorReference(context.getUserReference());\n            if (tdoc.isNew()) {\n                tdoc.setCreatorReference(context.getUserReference());\n            }\n        }\n        // reconfirm edit (captcha) when jcaptcha is not correct\n        if ((context.get(\"recheckcaptcha\") != null) && ((Boolean) context.get(\"recheckcaptcha\")).booleanValue()) {\n            return \"captcha\";\n        } else {\n            return \"preview\";\n        }\n    }","commit_id":"2fd0bcb01fa2a30408ed16a3d582b81e7d7b52df","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void createFormContent(IManagedForm managedForm) {\r\n\t\t\r\n\t\tTestSuite testSuite = null;\r\n\t\ttry {\r\n\t\t\tFileEditorInput fileEditorInput = ((FileEditorInput)getEditorInput());\r\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(fileEditorInput.getFile().getName()));\r\n\t\t\tUnmarshaller unmarshaller = new Unmarshaller(TestSuite.class);\r\n\t\t\ttestSuite = (TestSuite) unmarshaller.unmarshal(br);\r\n\t\t}catch (Exception e) {\t\r\n\t\t\tMessageDialog.openError(this.getSite().getShell(), \"Error\", e.getMessage());\r\n\t\t}\r\n\t\t\r\n\t\tfinal ScrolledForm form = managedForm.getForm();\r\n\t\tFormToolkit toolkit = managedForm.getToolkit();\r\n\t\tform.setText(\"Rtl Input Capture\"); //$NON-NLS-1$\r\n\t\tTableWrapLayout layout = new TableWrapLayout();\r\n\t\tlayout.numColumns = 2;\r\n\t\tform.getBody().setLayout(layout);\r\n\t\t\r\n\t\tSection section = toolkit.createSection(form.getBody(), \r\n\t\tSection.DESCRIPTION|Section.TITLE_BAR|\r\n\t\tSection.TWISTIE|Section.EXPANDED);\r\n\t\tTableWrapData td = new TableWrapData(TableWrapData.FILL);\r\n\t\ttd.colspan = 2;\r\n\r\n\t\tsection.setLayoutData(td);\r\n\t\tsection.addExpansionListener(new ExpansionAdapter() {\r\n\t\tpublic void expansionStateChanged(ExpansionEvent e) {\r\n\t\t\tform.reflow(true);\r\n\t\t  \t}\r\n\t\t });\r\n\t\t section.setText(\"Test Suite\");\r\n\t\t section.setDescription(\"This is the test suite information \"+\r\n\t\t      \"generated from the supplied rtl file.\");\r\n\r\n\t\t Composite sectionClient = toolkit.createComposite(section);\r\n\t\t sectionClient.setLayout(new GridLayout());\r\n\t\t Label label = toolkit.createLabel(sectionClient, \"Suite Name:\");\r\n\t\t Text text = toolkit.createText(sectionClient, testSuite.getName());\r\n\t\t section.setClient(sectionClient);\r\n\t\t\r\n\r\n\r\n\t\t\r\n\t}","id":84708,"modified_method":"protected void createFormContent(IManagedForm managedForm) {\r\n\t\t\r\n\t\tTestSuite testSuite = null;\r\n\t\ttry {\r\n\t\t\tFileEditorInput fileEditorInput = ((FileEditorInput)getEditorInput());\r\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(fileEditorInput.getFile().getName()));\r\n\t\t\tUnmarshaller unmarshaller = new Unmarshaller(TestSuite.class);\r\n\t\t\ttestSuite = (TestSuite) unmarshaller.unmarshal(br);\r\n\t\t}catch (Exception e) {\t\r\n\t\t\tMessageDialog.openError(this.getSite().getShell(), \"Error\", e.getMessage());\r\n\t\t}\r\n\t\r\n\t\tform = managedForm.getForm();\r\n\t\ttoolkit = managedForm.getToolkit();\r\n\t\tform.setText(Messages.getString(\"InputForm.title\")); //$NON-NLS-1$\r\n\t\tform.setBackgroundImage(TestResourcesPlugin.getDefault().getImage(TestResourcesPlugin.IMG_FORM_BG));\r\n\t\t\r\n\t\tTableWrapLayout layout = new TableWrapLayout();\r\n\t\tform.getBody().setLayout(layout);\r\n\t\tlayout.numColumns = 2;\r\n\t\t\r\n\t\ttoolkit.createLabel(form.getBody(), Messages.getString(\"FormView.testLabel\")); //$NON-NLS-1$\r\n\t\tText text = toolkit.createText(form.getBody(), \"Foo\"); //$NON-NLS-1$\r\n\t\tTableWrapData td = new TableWrapData(TableWrapData.FILL_GRAB);\r\n\t\ttext.setLayoutData(td);\r\n\t\t\r\n\t\tSection section = toolkit.createSection(form.getBody(), \r\n\t\tSection.DESCRIPTION|Section.TITLE_BAR|\r\n\t\tSection.TWISTIE|Section.EXPANDED);\r\n\t\ttd = new TableWrapData(TableWrapData.FILL_GRAB);\r\n\t\ttd.colspan = 2;\r\n\r\n\t\tsection.setLayoutData(td);\r\n\t\tsection.addExpansionListener(new ExpansionAdapter() {\r\n\t\tpublic void expansionStateChanged(ExpansionEvent e) {\r\n\t\t\tform.reflow(true);\r\n\t\t  \t}\r\n\t\t});\r\n\t\tsection.setText(Messages.getString(\"InputForm.testSuiteSection\"));\r\n\t\tsection.setDescription(Messages.getString(\"InputForm.testSuiteSection.descr\"));\r\n\r\n\t\tComposite sectionClient = toolkit.createComposite(section);\r\n\t\tGridLayout gd = new GridLayout();\r\n\t\tgd.numColumns = 2;\r\n\t\tsectionClient.setLayout(gd);\r\n\t\ttoolkit.createLabel(sectionClient, Messages.getString(\"InputForm.testSuiteSection.nameLabel\"));\r\n\t\ttoolkit.createText(sectionClient, testSuite.getName());\r\n\t\tsection.setClient(sectionClient);\r\n\t\t\r\n\r\n\t\t toolkit.paintBordersFor(form.getBody());\r\n\t\t\r\n\t}","commit_id":"b2abc8e5ba861fd2c357be2ad4d4485ab56177ac","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Saves the current document, updated according to the parameters sent in the request.\n     *\n     * @param context The current request {@link XWikiContext context}.\n     * @return <code>true<\/code> if there was an error and the response needs to render an error page,\n     *         <code>false<\/code> if the document was correctly saved.\n     * @throws XWikiException If an error occured: cannot communicate with the storage module, or cannot update the\n     *             document because the request contains invalid parameters.\n     */\n    public boolean save(XWikiContext context) throws XWikiException\n    {\n        XWiki xwiki = context.getWiki();\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        // Check save session\n        int sectionNumber = 0;\n        if (request.getParameter(\"section\") != null && xwiki.hasSectionEdit(context)) {\n            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n        }\n\n        // We need to clone this document first, since a cached storage would return the same object for the\n        // following requests, so concurrent request might get a partially modified object, or worse, if an error\n        // occurs during the save, the cached object will not reflect the actual document at all.\n        doc = doc.clone();\n\n        String language = ((EditForm) form).getLanguage();\n        // FIXME Which one should be used: doc.getDefaultLanguage or\n        // form.getDefaultLanguage()?\n        // String defaultLanguage = ((EditForm) form).getDefaultLanguage();\n        XWikiDocument tdoc;\n\n        if (doc.isNew() || (language == null) || (language.equals(\"\")) || (language.equals(\"default\"))\n            || (language.equals(doc.getDefaultLanguage()))) {\n            // Saving the default document translation.\n            // Need to save parent and defaultLanguage if they have changed\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if ((tdoc == doc) && xwiki.isMultiLingual(context)) {\n                // Saving a new document translation.\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            } else if (tdoc != doc) {\n                // Saving an existing document translation (but not the default one).\n                // Same as above, clone the object retrieved from the store cache.\n                tdoc = tdoc.clone();\n            }\n        }\n\n        if (doc.isNew()) {\n            doc.setLocale(Locale.ROOT);\n            if (doc.getDefaultLocale() == Locale.ROOT) {\n                doc.setDefaultLocale(LocaleUtils\n                    .toLocale(context.getWiki().getLanguagePreference(context), Locale.ROOT));\n            }\n        }\n\n        try {\n            tdoc.readFromTemplate(((EditForm) form).getTemplate(), context);\n        } catch (XWikiException e) {\n            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                context.put(\"exception\", e);\n                return true;\n            }\n        }\n\n        if (sectionNumber != 0) {\n            XWikiDocument sectionDoc = tdoc.clone();\n            sectionDoc.readFromForm((EditForm) form, context);\n            String sectionContent = sectionDoc.getContent() + \"\\n\";\n            String content = tdoc.updateDocumentSection(sectionNumber, sectionContent);\n            tdoc.setContent(content);\n            tdoc.setComment(sectionDoc.getComment());\n            tdoc.setMinorEdit(sectionDoc.isMinorEdit());\n        } else {\n            tdoc.readFromForm((EditForm) form, context);\n        }\n\n        // TODO: handle Author\n        String username = context.getUser();\n        tdoc.setAuthor(username);\n        if (tdoc.isNew()) {\n            tdoc.setCreator(username);\n        }\n\n        // Make sure we have at least the meta data dirty status\n        tdoc.setMetaDataDirty(true);\n\n        // Validate the document if we have xvalidate=1 in the request\n        if (\"1\".equals(request.getParameter(\"xvalidate\"))) {\n            boolean validationResult = tdoc.validate(context);\n            // If the validation fails we should show the \"Inline form\" edit mode\n            if (validationResult == false) {\n                // Set display context to 'edit'\n                context.put(\"display\", \"edit\");\n                // Set the action used by the \"Inline form\" edit mode as the context action. See #render(XWikiContext).\n                context.setAction(tdoc.getDefaultEditMode(context));\n                // Set the document in the context\n                context.put(\"doc\", doc);\n                context.put(\"cdoc\", tdoc);\n                context.put(\"tdoc\", tdoc);\n                Document vdoc = tdoc.newDocument(context);\n                VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n                vcontext.put(\"doc\", doc.newDocument(context));\n                vcontext.put(\"cdoc\", vdoc);\n                vcontext.put(\"tdoc\", vdoc);\n                // Force the \"Inline form\" edit mode.\n                vcontext.put(\"editor\", \"inline\");\n                return true;\n            }\n        }\n\n        // We get the comment to be used from the document\n        // It was read using readFromForm\n        xwiki.saveDocument(tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);\n        XWikiLock lock = tdoc.getLock(context);\n        if (lock != null) {\n            tdoc.removeLock(context);\n        }\n\n        return false;\n    }","id":84709,"modified_method":"/**\n     * Saves the current document, updated according to the parameters sent in the request.\n     *\n     * @param context The current request {@link XWikiContext context}.\n     * @return <code>true<\/code> if there was an error and the response needs to render an error page,\n     *         <code>false<\/code> if the document was correctly saved.\n     * @throws XWikiException If an error occured: cannot communicate with the storage module, or cannot update the\n     *             document because the request contains invalid parameters.\n     */\n    public boolean save(XWikiContext context) throws XWikiException\n    {\n        XWiki xwiki = context.getWiki();\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n        EditForm form = (EditForm) context.getForm();\n\n        // Check save session\n        int sectionNumber = 0;\n        if (request.getParameter(\"section\") != null && xwiki.hasSectionEdit(context)) {\n            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n        }\n\n        // We need to clone this document first, since a cached storage would return the same object for the\n        // following requests, so concurrent request might get a partially modified object, or worse, if an error\n        // occurs during the save, the cached object will not reflect the actual document at all.\n        doc = doc.clone();\n\n        String language = form.getLanguage();\n        // FIXME Which one should be used: doc.getDefaultLanguage or\n        // form.getDefaultLanguage()?\n        // String defaultLanguage = ((EditForm) form).getDefaultLanguage();\n        XWikiDocument tdoc;\n\n        if (doc.isNew() || (language == null) || (language.equals(\"\")) || (language.equals(\"default\"))\n            || (language.equals(doc.getDefaultLanguage()))) {\n            // Saving the default document translation.\n            // Need to save parent and defaultLanguage if they have changed\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if ((tdoc == doc) && xwiki.isMultiLingual(context)) {\n                // Saving a new document translation.\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            } else if (tdoc != doc) {\n                // Saving an existing document translation (but not the default one).\n                // Same as above, clone the object retrieved from the store cache.\n                tdoc = tdoc.clone();\n            }\n        }\n\n        if (doc.isNew()) {\n            doc.setLocale(Locale.ROOT);\n            if (doc.getDefaultLocale() == Locale.ROOT) {\n                doc.setDefaultLocale(LocaleUtils\n                    .toLocale(context.getWiki().getLanguagePreference(context), Locale.ROOT));\n            }\n        }\n\n        try {\n            tdoc.readFromTemplate(form.getTemplate(), context);\n        } catch (XWikiException e) {\n            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                context.put(\"exception\", e);\n                return true;\n            }\n        }\n\n        if (sectionNumber != 0) {\n            XWikiDocument sectionDoc = tdoc.clone();\n            sectionDoc.readFromForm(form, context);\n            String sectionContent = sectionDoc.getContent() + \"\\n\";\n            String content = tdoc.updateDocumentSection(sectionNumber, sectionContent);\n            tdoc.setContent(content);\n            tdoc.setComment(sectionDoc.getComment());\n            tdoc.setMinorEdit(sectionDoc.isMinorEdit());\n        } else {\n            tdoc.readFromForm(form, context);\n        }\n\n        // TODO: handle Author\n        String username = context.getUser();\n        tdoc.setAuthor(username);\n        if (tdoc.isNew()) {\n            tdoc.setCreator(username);\n        }\n\n        // Make sure we have at least the meta data dirty status\n        tdoc.setMetaDataDirty(true);\n\n        // Validate the document if we have xvalidate=1 in the request\n        if (\"1\".equals(request.getParameter(\"xvalidate\"))) {\n            boolean validationResult = tdoc.validate(context);\n            // If the validation fails we should show the \"Inline form\" edit mode\n            if (validationResult == false) {\n                // Set display context to 'edit'\n                context.put(\"display\", \"edit\");\n                // Set the action used by the \"Inline form\" edit mode as the context action. See #render(XWikiContext).\n                context.setAction(tdoc.getDefaultEditMode(context));\n                // Set the document in the context\n                context.put(\"doc\", doc);\n                context.put(\"cdoc\", tdoc);\n                context.put(\"tdoc\", tdoc);\n                Document vdoc = tdoc.newDocument(context);\n                VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n                vcontext.put(\"doc\", doc.newDocument(context));\n                vcontext.put(\"cdoc\", vdoc);\n                vcontext.put(\"tdoc\", vdoc);\n                // Force the \"Inline form\" edit mode.\n                vcontext.put(\"editor\", \"inline\");\n                return true;\n            }\n        }\n\n        // We get the comment to be used from the document\n        // It was read using readFromForm\n        xwiki.saveDocument(tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);\n\n        Job createJob = startCreateJob(tdoc.getDocumentReference(), form);\n        if (createJob != null) {\n            if (isAsync(request)) {\n                if (Utils.isAjaxRequest(context)) {\n                    // Redirect to the job status URL of the job we have just launched.\n                    sendRedirect(context.getResponse(), String.format(\"%s/rest/jobstatus/%s?media=json\", context\n                        .getRequest().getContextPath(), serializeJobId(createJob.getRequest().getId())));\n                }\n\n                // else redirect normally and the operation will eventually finish in the background.\n                // Note: It is preferred that async mode is called in an AJAX request that can display the progress.\n            } else {\n                // Sync mode, default, wait for the work to finish.\n                try {\n                    createJob.join();\n                } catch (InterruptedException e) {\n                    throw new XWikiException(String.format(\n                        \"Interrupted while waiting for template [%s] to be processed when creating the document [%s]\",\n                        form.getTemplate(), tdoc.getDocumentReference()), e);\n                }\n            }\n        } else {\n            // Nothing more to do, just unlock the document.\n            XWikiLock lock = tdoc.getLock(context);\n            if (lock != null) {\n                tdoc.removeLock(context);\n            }\n        }\n\n        return false;\n    }","commit_id":"a7f47dadddbdf12383ef283477220bc11867d779","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \"\n\t\t\t\t\t\t\t+ component.toString());\n\t\t}\n\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingResponse);\n\n\t\t// Initialize temporary variables\n\t\tPage page = component.getPage();\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.startComponentRender(component);\n\t\t}\n\n\t\t// Render the component\n\t\tcomponent.renderComponent();\n\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.endComponentRender(component);\n\t\t}\n\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\" + markupId + \"\\\" \");\n\t\tif (encodingResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingResponse.reset();\n\t}","id":84710,"modified_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \"\n\t\t\t\t\t\t\t+ component.toString());\n\t\t}\n\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = component.getPage();\n\t\t\n\t\tif (page==null) {\n\t\t\tthrow new IllegalStateException(\"Ajax request attempted on a component that is not associated with a Page\");\n\t\t}\n\t\t\n\t\tfinal boolean versioned=page.isVersioned();\n\t\tpage.setVersioned(false);\n\t\t\n\t\tpage.startComponentRender(component);\n\t\tcomponent.renderComponent();\n\t\tpage.endComponentRender(component);\n\n\t\tpage.setVersioned(versioned);\n\t\t\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\" + markupId + \"\\\" \");\n\t\tif (encodingResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingResponse.reset();\n\t}","commit_id":"07cafc75a3eac1b203e684cbfaa33bbb88fecadc","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \"\n\t\t\t\t\t\t\t+ component.toString());\n\t\t}\n\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = component.getPage();\n\n\n\t\tfinal boolean versioned=(page!=null)?page.isVersioned():false;\n\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.setVersioned(false);\n\t\t\tpage.startComponentRender(component);\n\t\t}\n\n\t\tcomponent.renderComponent();\n\t\t\n\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.endComponentRender(component);\n\t\t\tpage.setVersioned(versioned);\n\t\t}\n\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\" + markupId + \"\\\" \");\n\t\tif (encodingResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingResponse.reset();\n\t}","id":84711,"modified_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \"\n\t\t\t\t\t\t\t+ component.toString());\n\t\t}\n\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = component.getPage();\n\n\t\tif (page == null)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax request attempted on a component that is not associated with a Page\");\n\t\t}\n\n\t\tfinal boolean versioned = page.isVersioned();\n\t\tpage.setVersioned(false);\n\n\t\tpage.startComponentRender(component);\n\t\tcomponent.renderComponent();\n\t\tpage.endComponentRender(component);\n\n\t\tpage.setVersioned(versioned);\n\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\" + markupId + \"\\\" \");\n\t\tif (encodingResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingResponse.reset();\n\t}","commit_id":"13cfc059e4776b8e89d93c4829c127adbd01519c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \"\n\t\t\t\t\t\t\t+ component.toString());\n\t\t}\n\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = component.getPage();\n\t\t\n\t\tif (page==null) {\n\t\t\tthrow new IllegalStateException(\"Ajax request attempted on a component that is not associated with a Page\");\n\t\t}\n\t\t\n\t\tfinal boolean versioned=page.isVersioned();\n\t\tpage.setVersioned(false);\n\t\t\n\t\tpage.startComponentRender(component);\n\t\tcomponent.renderComponent();\n\t\tpage.endComponentRender(component);\n\n\t\tpage.setVersioned(versioned);\n\t\t\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\" + markupId + \"\\\" \");\n\t\tif (encodingResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingResponse.reset();\n\t}","id":84712,"modified_method":"/**\n\t * \n\t * @param response\n\t * @param markupId\n\t *            id of client-side dom element\n\t * @param component\n\t *            component to render\n\t */\n\tprivate void respondComponent(final Response response, final String markupId,\n\t\t\tfinal Component component)\n\t{\n\t\tif (component.getRenderBodyOnly() == true)\n\t\t{\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Ajax render cannot be called on component that has setRenderBodyOnly enabled. Component: \"\n\t\t\t\t\t\t\t+ component.toString());\n\t\t}\n\n\n\t\t// substitute our encoding response for the real one so we can capture\n\t\t// component's markup in a manner safe for transport inside CDATA block\n\t\tfinal Response originalResponse = response;\n\t\tencodingResponse.reset();\n\t\tRequestCycle.get().setResponse(encodingResponse);\n\n\t\t// Initialize temporary variables\n\t\tfinal Page page = component.getPage();\n\n\n\t\tfinal boolean versioned=(page!=null)?page.isVersioned():false;\n\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.setVersioned(false);\n\t\t\tpage.startComponentRender(component);\n\t\t}\n\n\t\tcomponent.renderComponent();\n\t\t\n\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.endComponentRender(component);\n\t\t\tpage.setVersioned(versioned);\n\t\t}\n\n\t\t// Restore original response\n\t\tRequestCycle.get().setResponse(originalResponse);\n\n\t\tresponse.write(\"<component id=\\\"\" + markupId + \"\\\" \");\n\t\tif (encodingResponse.isContentsEncoded())\n\t\t{\n\t\t\tresponse.write(\" encoding=\\\"\");\n\t\t\tresponse.write(getEncodingName());\n\t\t\tresponse.write(\"\\\" \");\n\t\t}\n\t\tresponse.write(\"><![CDATA[\");\n\t\tresponse.write(encodingResponse.getContents());\n\t\tresponse.write(\"]]><\/component>\");\n\n\t\tencodingResponse.reset();\n\t}","commit_id":"6a198ec1889652bd2cae5e57d457d8f0a9579c93","url":"https://github.com/apache/wicket"},{"original_method":"public Switchboard(final File dataPath, final File appPath, final String initPath, final String configPath) throws IOException {\r\n        super(dataPath, appPath, initPath, configPath);\r\n        MemoryTracker.startSystemProfiling();\r\n        sb=this;\r\n        \r\n        // set loglevel and log\r\n        setLog(new Log(\"PLASMA\"));\r\n        \r\n        // UPnP port mapping\r\n        if (getConfigBool(SwitchboardConstants.UPNP_ENABLED, false))\r\n        \tInstantBusyThread.oneTimeJob(UPnP.class, \"addPortMapping\", UPnP.log, 0);\r\n        \r\n        // init TrayIcon if possible\r\n        Tray.init(this);\r\n        \r\n        // remote proxy configuration\r\n        initRemoteProxy();\r\n        \r\n        // memory configuration\r\n        this.useTailCache = getConfigBool(\"ramcopy\", true);\r\n        if (MemoryControl.available() > 1024 * 1024 * 1024 * 1) this.useTailCache = true;\r\n        this.exceed134217727 = getConfigBool(\"exceed134217727\", true);\r\n        if (MemoryControl.available() > 1024 * 1024 * 1024 * 2) this.exceed134217727 = true;\r\n        \r\n        // load values from configs        \r\n        final File indexPath = getDataPath(SwitchboardConstants.INDEX_PRIMARY_PATH, SwitchboardConstants.INDEX_PATH_DEFAULT);\r\n        this.log.logConfig(\"Index Primary Path: \" + indexPath.toString());\r\n        this.listsPath      = getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\r\n        this.log.logConfig(\"Lists Path:     \" + this.listsPath.toString());\r\n        this.htDocsPath   = getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT);\r\n        this.log.logConfig(\"HTDOCS Path:    \" + this.htDocsPath.toString());\r\n        this.rankingPath   = getDataPath(SwitchboardConstants.RANKING_PATH, SwitchboardConstants.RANKING_PATH_DEFAULT);\r\n        this.log.logConfig(\"Ranking Path:    \" + this.rankingPath.toString());\r\n        this.rankingPermissions = new HashMap<String, String>(); // mapping of permission - to filename.\r\n        this.workPath   = getDataPath(SwitchboardConstants.WORK_PATH, SwitchboardConstants.WORK_PATH_DEFAULT);\r\n        this.log.logConfig(\"Work Path:    \" + this.workPath.toString());\r\n        this.dictionariesPath = getDataPath(SwitchboardConstants.DICTIONARY_SOURCE_PATH, SwitchboardConstants.DICTIONARY_SOURCE_PATH_DEFAULT);\r\n        this.log.logConfig(\"Dictionaries Path:\" + this.dictionariesPath.toString());\r\n\r\n        // init sessionid name file\r\n        final String sessionidNamesFile = getConfig(\"sessionidNamesFile\",\"defaults/sessionid.names\");\r\n        this.log.logConfig(\"Loading sessionid file \" + sessionidNamesFile);\r\n        MultiProtocolURI.initSessionIDNames(FileUtils.loadList(new File(getAppPath(), sessionidNamesFile)));\r\n\r\n        // init tables\r\n        this.tables = new WorkTables(this.workPath);\r\n        \r\n        // init libraries\r\n        this.log.logConfig(\"initializing libraries\");\r\n        LibraryProvider.initialize(this.dictionariesPath);\r\n        \r\n        // set a high maximum cache size to current size; this is adopted later automatically\r\n        final int wordCacheMaxCount = (int) getConfigLong(SwitchboardConstants.WORDCACHE_MAX_COUNT, 20000);\r\n        setConfig(SwitchboardConstants.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\r\n\r\n        // load the network definition\r\n        overwriteNetworkDefinition();\r\n\r\n        // start indexing management\r\n        log.logConfig(\"Starting Indexing Management\");\r\n        final String networkName = getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\r\n        final long fileSizeMax = (OS.isWindows) ? sb.getConfigLong(\"filesize.max.win\", (long) Integer.MAX_VALUE) : sb.getConfigLong(\"filesize.max.other\", (long) Integer.MAX_VALUE);\r\n        final int redundancy = (int) sb.getConfigLong(\"network.unit.dhtredundancy.senior\", 1);\r\n        final int partitionExponent = (int) sb.getConfigLong(\"network.unit.dht.partitionExponent\", 0);\r\n        this.networkRoot = new File(new File(indexPath, networkName), \"NETWORK\");\r\n        this.queuesRoot = new File(new File(indexPath, networkName), \"QUEUES\");\r\n        this.networkRoot.mkdirs();\r\n        this.queuesRoot.mkdirs();\r\n\t\tfinal File mySeedFile = new File(networkRoot, yacySeedDB.DBFILE_OWN_SEED);\r\n        peers = new yacySeedDB(\r\n                networkRoot,\r\n                \"seed.new.heap\",\r\n                \"seed.old.heap\",\r\n                \"seed.pot.heap\",\r\n                mySeedFile,\r\n                redundancy,\r\n                partitionExponent,\r\n                this.useTailCache,\r\n                this.exceed134217727);\r\n        File oldSingleSegment = new File(new File(indexPath, networkName), \"TEXT\");\r\n        File newSegmentsPath = new File(new File(indexPath, networkName), \"SEGMENTS\");\r\n        Segments.migrateOld(oldSingleSegment, newSegmentsPath, getConfig(SwitchboardConstants.SEGMENT_PUBLIC, \"default\"));\r\n        indexSegments = new Segments(\r\n                log,\r\n                newSegmentsPath,\r\n                wordCacheMaxCount,\r\n                fileSizeMax,\r\n                this.useTailCache,\r\n                this.exceed134217727);\r\n        // set the default segment names\r\n        setDefaultSegments();\r\n        \r\n        // create a crawler\r\n        crawler = new CrawlSwitchboard(\r\n                networkName,\r\n                log,\r\n                this.queuesRoot);\r\n\t\t\r\n\t\t\r\n\t\t// init crawl results monitor cache\r\n        crawlResults = new ResultURLs(100);\r\n        \r\n        // start yacy core\r\n        log.logConfig(\"Starting YaCy Protocol Core\");\r\n        this.yc = new yacyCore(this);\r\n        InstantBusyThread.oneTimeJob(this, \"loadSeedLists\", yacyCore.log, 0);\r\n        //final long startedSeedListAquisition = System.currentTimeMillis();\r\n        \r\n        // init a DHT transmission dispatcher\r\n        this.dhtDispatcher = new Dispatcher(\r\n                indexSegments.segment(Segments.Process.LOCALCRAWLING),\r\n                peers,\r\n                true, \r\n                10000);\r\n        \r\n        // set up local robots.txt\r\n        this.robotstxtConfig = RobotsTxtConfig.init(this);\r\n        \r\n        // setting timestamp of last proxy access\r\n        this.proxyLastAccess = System.currentTimeMillis() - 10000;\r\n        this.localSearchLastAccess = System.currentTimeMillis() - 10000;\r\n        this.remoteSearchLastAccess = System.currentTimeMillis() - 10000;\r\n        this.webStructure = new WebStructureGraph(log, rankingPath, \"LOCAL/010_cr/\", getConfig(\"CRDist0Path\", CRDistribution.CR_OWN), new File(queuesRoot, \"webStructure.map\"));\r\n        \r\n        // configuring list path\r\n        if (!(listsPath.exists())) listsPath.mkdirs();\r\n        \r\n        // load coloured lists\r\n        if (blueList == null) {\r\n            // read only once upon first instantiation of this class\r\n            final String f = getConfig(SwitchboardConstants.LIST_BLUE, SwitchboardConstants.LIST_BLUE_DEFAULT);\r\n            final File plasmaBlueListFile = new File(f);\r\n            if (f != null) blueList = SetTools.loadList(plasmaBlueListFile, NaturalOrder.naturalComparator); else blueList= new TreeSet<String>();\r\n            blueListHashes = Word.words2hashesHandles(blueList);\r\n            this.log.logConfig(\"loaded blue-list from file \" + plasmaBlueListFile.getName() + \", \" +\r\n            blueList.size() + \" entries, \" +\r\n            ppRamString(plasmaBlueListFile.length()/1024));\r\n        }\r\n        \r\n        // load blacklist\r\n        this.log.logConfig(\"Loading blacklist ...\");\r\n        final File blacklistsPath = getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\r\n        urlBlacklist = new Blacklist(blacklistsPath);\r\n        listManager.switchboard = this;\r\n        listManager.listsPath = blacklistsPath;        \r\n        listManager.reloadBlacklists();\r\n\r\n        // load badwords (to filter the topwords)\r\n        if (badwords == null || badwords.isEmpty()) {\r\n            final File badwordsFile = new File(appPath, SwitchboardConstants.LIST_BADWORDS_DEFAULT);\r\n            badwords = SetTools.loadList(badwordsFile, NaturalOrder.naturalComparator);\r\n            badwordHashes = Word.words2hashesHandles(badwords);\r\n            this.log.logConfig(\"loaded badwords from file \" + badwordsFile.getName() +\r\n                               \", \" + badwords.size() + \" entries, \" +\r\n                               ppRamString(badwordsFile.length()/1024));\r\n        }\r\n\r\n        // load stopwords\r\n        if (stopwords == null || stopwords.isEmpty()) {\r\n            final File stopwordsFile = new File(appPath, SwitchboardConstants.LIST_STOPWORDS_DEFAULT);\r\n            stopwords = SetTools.loadList(stopwordsFile, NaturalOrder.naturalComparator);\r\n            stopwordHashes = Word.words2hashesHandles(stopwords);\r\n            this.log.logConfig(\"loaded stopwords from file \" + stopwordsFile.getName() + \", \" +\r\n            stopwords.size() + \" entries, \" +\r\n            ppRamString(stopwordsFile.length()/1024));\r\n        }\r\n\r\n        // load ranking tables\r\n        final File YBRPath = new File(appPath, \"ranking/YBR\");\r\n        if (YBRPath.exists()) {\r\n            RankingProcess.loadYBR(YBRPath, 15);\r\n        }\r\n        \r\n        // load the robots.txt db\r\n        this.log.logConfig(\"Initializing robots.txt DB\");\r\n        robots = new RobotsTxt(this.tables.getHeap(WorkTables.TABLE_ROBOTS_NAME));\r\n        this.log.logConfig(\"Loaded robots.txt DB: \" +  robots.size() + \" entries\");\r\n        \r\n        // start a cache manager\r\n        log.logConfig(\"Starting HT Cache Manager\");\r\n        \r\n        // create the cache directory\r\n        htCachePath = getDataPath(SwitchboardConstants.HTCACHE_PATH, SwitchboardConstants.HTCACHE_PATH_DEFAULT);\r\n        this.log.logInfo(\"HTCACHE Path = \" + htCachePath.getAbsolutePath());\r\n        final long maxCacheSize = 1024 * 1024 * Long.parseLong(getConfig(SwitchboardConstants.PROXY_CACHE_SIZE, \"2\")); // this is megabyte\r\n        Cache.init(htCachePath, peers.mySeed().hash, maxCacheSize);\r\n        \r\n        // create the surrogates directories\r\n        surrogatesInPath = getDataPath(SwitchboardConstants.SURROGATES_IN_PATH, SwitchboardConstants.SURROGATES_IN_PATH_DEFAULT);\r\n        this.log.logInfo(\"surrogates.in Path = \" + surrogatesInPath.getAbsolutePath());\r\n        surrogatesInPath.mkdirs();\r\n        surrogatesOutPath = getDataPath(SwitchboardConstants.SURROGATES_OUT_PATH, SwitchboardConstants.SURROGATES_OUT_PATH_DEFAULT);\r\n        this.log.logInfo(\"surrogates.out Path = \" + surrogatesOutPath.getAbsolutePath());\r\n        surrogatesOutPath.mkdirs();\r\n        \r\n        // create the release download directory\r\n        releasePath = getDataPath(SwitchboardConstants.RELEASE_PATH, SwitchboardConstants.RELEASE_PATH_DEFAULT);\r\n        releasePath.mkdirs();\r\n        this.log.logInfo(\"RELEASE Path = \" + releasePath.getAbsolutePath());\r\n       \r\n        // starting message board\r\n        initMessages();\r\n        \r\n        // starting wiki\r\n        initWiki();\r\n        \r\n        //starting blog\r\n        initBlog();\r\n        \r\n        // Init User DB\r\n        this.log.logConfig(\"Loading User DB\");\r\n        final File userDbFile = new File(getDataPath(), \"DATA/SETTINGS/user.heap\");\r\n        this.userDB = new userDB(userDbFile);\r\n        this.log.logConfig(\"Loaded User DB from file \" + userDbFile.getName() +\r\n        \", \" + this.userDB.size() + \" entries\" +\r\n        \", \" + ppRamString(userDbFile.length()/1024));\r\n        \r\n        //Init bookmarks DB\r\n        initBookmarks();\r\n        \r\n        // define a realtime parsable mimetype list\r\n        log.logConfig(\"Parser: Initializing Mime Type deny list\");\r\n        TextParser.setDenyMime(getConfig(SwitchboardConstants.PARSER_MIME_DENY, null));\r\n        \r\n        // start a loader\r\n        log.logConfig(\"Starting Crawl Loader\");\r\n        this.loader = new LoaderDispatcher(this);\r\n        Map<String, File> oaiFriends = OAIListFriendsLoader.loadListFriendsSources(new File(\"defaults/oaiListFriendsSource.xml\"), getDataPath());\r\n        OAIListFriendsLoader.init(this.loader, oaiFriends);\r\n        this.crawlQueues = new CrawlQueues(this, queuesRoot);\r\n        this.crawlQueues.noticeURL.setMinimumDelta(\r\n                this.getConfigLong(\"minimumLocalDelta\", this.crawlQueues.noticeURL.getMinimumLocalDelta()),\r\n                this.getConfigLong(\"minimumGlobalDelta\", this.crawlQueues.noticeURL.getMinimumGlobalDelta()));\r\n\r\n        /*\r\n         * Creating sync objects and loading status for the crawl jobs\r\n         * a) local crawl\r\n         * b) remote triggered crawl\r\n         * c) global crawl trigger\r\n         */\r\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, new Object[]{\r\n                new Object(),\r\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL + \"_isPaused\", \"false\"))});\r\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, new Object[]{\r\n                new Object(),\r\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL + \"_isPaused\", \"false\"))});\r\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER, new Object[]{\r\n                new Object(),\r\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER + \"_isPaused\", \"false\"))});\r\n        \r\n        // init cookie-Monitor\r\n        this.log.logConfig(\"Starting Cookie Monitor\");\r\n        this.outgoingCookies = new ConcurrentHashMap<String, Object[]>();\r\n        this.incomingCookies = new ConcurrentHashMap<String, Object[]>();\r\n        \r\n        // init search history trackers\r\n        this.localSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>(); // String:TreeSet - IP:set of Long(accessTime)\r\n        this.remoteSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>();\r\n        this.localSearches = new ArrayList<QueryParams>(); // contains search result properties as HashMaps\r\n        this.remoteSearches = new ArrayList<QueryParams>();\r\n        \r\n        // init messages: clean up message symbol\r\n        final File notifierSource = new File(getAppPath(), getConfig(SwitchboardConstants.HTROOT_PATH, SwitchboardConstants.HTROOT_PATH_DEFAULT) + \"/env/grafics/empty.gif\");\r\n        final File notifierDest = new File(getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT), \"notifier.gif\");\r\n        try {\r\n            FileUtils.copy(notifierSource, notifierDest);\r\n        } catch (final IOException e) {\r\n        }\r\n        \r\n        // init ranking transmission\r\n        /*\r\n        CRDistOn       = true/false\r\n        CRDist0Path    = GLOBAL/010_owncr\r\n        CRDist0Method  = 1\r\n        CRDist0Percent = 0\r\n        CRDist0Target  =\r\n        CRDist1Path    = GLOBAL/014_othercr/1\r\n        CRDist1Method  = 9\r\n        CRDist1Percent = 30\r\n        CRDist1Target  = kaskelix.de:8080,yacy.dyndns.org:8000,suma-lab.de:8080\r\n         **/\r\n        rankingOn = getConfig(SwitchboardConstants.RANKING_DIST_ON, \"true\").equals(\"true\") && networkName.equals(\"freeworld\");\r\n        rankingOwnDistribution = new CRDistribution(log, peers, new File(rankingPath, getConfig(SwitchboardConstants.RANKING_DIST_0_PATH, CRDistribution.CR_OWN)), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_0_METHOD, CRDistribution.METHOD_ANYSENIOR), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_0_METHOD, 0), getConfig(SwitchboardConstants.RANKING_DIST_0_TARGET, \"\"));\r\n        rankingOtherDistribution = new CRDistribution(log, peers, new File(rankingPath, getConfig(SwitchboardConstants.RANKING_DIST_1_PATH, CRDistribution.CR_OTHER)), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_1_METHOD, CRDistribution.METHOD_MIXEDSENIOR), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_1_METHOD, 30), getConfig(SwitchboardConstants.RANKING_DIST_1_TARGET, \"kaskelix.de:8080,yacy.dyndns.org:8000\"));\r\n\r\n        // init nameCacheNoCachingList\r\n        Domains.setNoCachingPatterns(getConfig(SwitchboardConstants.HTTPC_NAME_CACHE_CACHING_PATTERNS_NO,\"\"));\r\n        \r\n        // generate snippets cache\r\n        log.logConfig(\"Initializing Snippet Cache\");\r\n        \r\n        // init the wiki\r\n        wikiParser = new wikiCode(this.peers.mySeed().getClusterAddress());\r\n        \r\n        // initializing the resourceObserver\r\n        InstantBusyThread.oneTimeJob(ResourceObserver.class, \"initThread\", ResourceObserver.log, 0);\r\n        \r\n        // initializing the stackCrawlThread\r\n        this.crawlStacker = new CrawlStacker(\r\n                this.crawlQueues,\r\n                this.crawler,\r\n                this.indexSegments.segment(Segments.Process.LOCALCRAWLING),\r\n                this.peers,\r\n                \"local.any\".indexOf(getConfig(\"network.unit.domain\", \"global\")) >= 0,\r\n                \"global.any\".indexOf(getConfig(\"network.unit.domain\", \"global\")) >= 0);\r\n        \r\n        // initializing dht chunk generation\r\n        this.dhtMaxReferenceCount = (int) getConfigLong(SwitchboardConstants.INDEX_DIST_CHUNK_SIZE_START, 50);\r\n        \r\n        // init robinson cluster\r\n        // before we do that, we wait some time until the seed list is loaded.\r\n        this.clusterhashes = this.peers.clusterHashes(getConfig(\"cluster.peers.yacydomain\", \"\"));\r\n        \r\n        // deploy blocking threads\r\n        int indexerThreads = Math.max(1, WorkflowProcessor.useCPU / 2);\r\n        this.indexingStorageProcessor      = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"storeDocumentIndex\",\r\n                \"This is the sequencing step of the indexing queue. Files are written as streams, too much councurrency would destroy IO performance. In this process the words are written to the RWI cache, which flushes if it is full.\",\r\n                new String[]{\"RWI/Cache/Collections\"},\r\n                this, \"storeDocumentIndex\", 2 * WorkflowProcessor.useCPU, null, indexerThreads);\r\n        this.indexingAnalysisProcessor     = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"webStructureAnalysis\",\r\n                \"This just stores the link structure of the document into a web structure database.\",\r\n                new String[]{\"storeDocumentIndex\"},\r\n                this, \"webStructureAnalysis\", 2 * WorkflowProcessor.useCPU, indexingStorageProcessor, WorkflowProcessor.useCPU + 1);\r\n        this.indexingCondensementProcessor = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"condenseDocument\",\r\n                \"This does a structural analysis of plain texts: markup of headlines, slicing into phrases (i.e. sentences), markup with position, counting of words, calculation of term frequency.\",\r\n                new String[]{\"webStructureAnalysis\"},\r\n                this, \"condenseDocument\", 4 * WorkflowProcessor.useCPU, indexingAnalysisProcessor, WorkflowProcessor.useCPU + 1);\r\n        this.indexingDocumentProcessor     = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"parseDocument\",\r\n                \"This does the parsing of the newly loaded documents from the web. The result is not only a plain text document, but also a list of URLs that are embedded into the document. The urls are handed over to the CrawlStacker. This process has two child process queues!\",\r\n                new String[]{\"condenseDocument\", \"CrawlStacker\"},\r\n                this, \"parseDocument\", 4 * WorkflowProcessor.useCPU, indexingCondensementProcessor, WorkflowProcessor.useCPU + 1);\r\n        \r\n        // deploy busy threads\r\n        log.logConfig(\"Starting Threads\");\r\n        MemoryControl.gc(10000, \"plasmaSwitchboard, help for profiler\"); // help for profiler - thq\r\n        \r\n        deployThread(SwitchboardConstants.CLEANUP, \"Cleanup\", \"simple cleaning process for monitoring information\", null,\r\n                     new InstantBusyThread(\r\n                         this,\r\n                         SwitchboardConstants.CLEANUP_METHOD_START,\r\n                         SwitchboardConstants.CLEANUP_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CLEANUP_METHOD_FREEMEM,\r\n                         60000, Long.MAX_VALUE, 10000, Long.MAX_VALUE),\r\n                     60000); // all 5 Minutes, wait 1 minute until first run\r\n        deployThread(SwitchboardConstants.SURROGATES, \"Surrogates\", \"A thread that polls the SURROGATES path and puts all Documents in one surroagte file into the indexing queue.\", null,\r\n                     new InstantBusyThread(\r\n                         this,\r\n                         SwitchboardConstants.SURROGATES_METHOD_START,\r\n                         SwitchboardConstants.SURROGATES_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.SURROGATES_METHOD_FREEMEM,\r\n                         20000, Long.MAX_VALUE, 0, Long.MAX_VALUE),\r\n                     10000);\r\n        deployThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"Remote Crawl Job\", \"thread that performes a single crawl/indexing step triggered by a remote peer\", \"/IndexCreateWWWRemoteQueue_p.html\",\r\n                     new InstantBusyThread(\r\n                         crawlQueues,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_START,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_FREEMEM,\r\n                         0, Long.MAX_VALUE, 0, Long.MAX_VALUE),\r\n                     10000);\r\n        deployThread(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER, \"Remote Crawl URL Loader\", \"thread that loads remote crawl lists from other peers\", null,\r\n                     new InstantBusyThread(\r\n                         crawlQueues,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_START,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_FREEMEM,\r\n                         10000, Long.MAX_VALUE, 10000, Long.MAX_VALUE),\r\n                     10000); // error here?\r\n        deployThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"Local Crawl\", \"thread that performes a single crawl step from the local crawl queue\", \"/IndexCreateWWWLocalQueue_p.html\",\r\n                     new InstantBusyThread(\r\n                         crawlQueues,\r\n                         SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_START,\r\n                         SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_FREEMEM,\r\n                         0, Long.MAX_VALUE, 0, Long.MAX_VALUE),\r\n                     10000);\r\n        deployThread(SwitchboardConstants.SEED_UPLOAD, \"Seed-List Upload\", \"task that a principal peer performes to generate and upload a seed-list to a ftp account\", null,\r\n                     new InstantBusyThread(\r\n                         yc,\r\n                         SwitchboardConstants.SEED_UPLOAD_METHOD_START,\r\n                         SwitchboardConstants.SEED_UPLOAD_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.SEED_UPLOAD_METHOD_FREEMEM,\r\n                         600000, Long.MAX_VALUE, 300000, Long.MAX_VALUE),\r\n                     180000);\r\n        deployThread(SwitchboardConstants.PEER_PING, \"YaCy Core\", \"this is the p2p-control and peer-ping task\", null,\r\n                     new InstantBusyThread(\r\n                         yc,\r\n                         SwitchboardConstants.PEER_PING_METHOD_START,\r\n                         SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\r\n                         60000, Long.MAX_VALUE, 60000, Long.MAX_VALUE),\r\n                     2000);\r\n        deployThread(SwitchboardConstants.INDEX_DIST, \"DHT Distribution\", \"selection, transfer and deletion of index entries that are not searched on your peer, but on others\", null,\r\n                     new InstantBusyThread(\r\n                         this,\r\n                         SwitchboardConstants.INDEX_DIST_METHOD_START,\r\n                         SwitchboardConstants.INDEX_DIST_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.INDEX_DIST_METHOD_FREEMEM,\r\n                         10000, Long.MAX_VALUE, 1000, Long.MAX_VALUE),\r\n                     5000,\r\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_IDLESLEEP , \"5000\")),\r\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_BUSYSLEEP , \"0\")),\r\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_MEMPREREQ , \"1000000\")));\r\n\r\n        // set network-specific performance attributes\r\n        if (this.firstInit) {\r\n            setRemotecrawlPPM(Math.max(1, (int) getConfigLong(\"network.unit.remotecrawl.speed\", 60)));\r\n        }\r\n        \r\n        // test routine for snippet fetch\r\n        //Set query = new HashSet();\r\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Weitergabe\"));\r\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Zahl\"));\r\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/mobil/newsticker/meldung/mail/54980\"), query, true);\r\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/security/news/foren/go.shtml?read=1&msg_id=7301419&forum_id=72721\"), query, true);\r\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/kiosk/archiv/ct/2003/4/20\"), query, true, 260);\r\n\r\n        this.trail = new ArrayList<String>();\r\n        \r\n        log.logConfig(\"Finished Switchboard Initialization\");\r\n        sb = this;\r\n    }","id":84713,"modified_method":"public Switchboard(final File dataPath, final File appPath, final String initPath, final String configPath) throws IOException {\r\n        super(dataPath, appPath, initPath, configPath);\r\n        MemoryTracker.startSystemProfiling();\r\n        sb=this;\r\n        \r\n        // set loglevel and log\r\n        setLog(new Log(\"PLASMA\"));\r\n        \r\n        // UPnP port mapping\r\n        if (getConfigBool(SwitchboardConstants.UPNP_ENABLED, false))\r\n        \tInstantBusyThread.oneTimeJob(UPnP.class, \"addPortMapping\", UPnP.log, 0);\r\n        \r\n        // init TrayIcon if possible\r\n        Tray.init(this);\r\n        \r\n        // remote proxy configuration\r\n        initRemoteProxy();\r\n        \r\n        // memory configuration\r\n        this.useTailCache = getConfigBool(\"ramcopy\", true);\r\n        if (MemoryControl.available() > 1024 * 1024 * 1024 * 1) this.useTailCache = true;\r\n        this.exceed134217727 = getConfigBool(\"exceed134217727\", true);\r\n        if (MemoryControl.available() > 1024 * 1024 * 1024 * 2) this.exceed134217727 = true;\r\n        \r\n        // load values from configs        \r\n        final File indexPath = getDataPath(SwitchboardConstants.INDEX_PRIMARY_PATH, SwitchboardConstants.INDEX_PATH_DEFAULT);\r\n        this.log.logConfig(\"Index Primary Path: \" + indexPath.toString());\r\n        this.listsPath      = getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\r\n        this.log.logConfig(\"Lists Path:     \" + this.listsPath.toString());\r\n        this.htDocsPath   = getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT);\r\n        this.log.logConfig(\"HTDOCS Path:    \" + this.htDocsPath.toString());\r\n        this.rankingPath   = getDataPath(SwitchboardConstants.RANKING_PATH, SwitchboardConstants.RANKING_PATH_DEFAULT);\r\n        this.log.logConfig(\"Ranking Path:    \" + this.rankingPath.toString());\r\n        this.rankingPermissions = new HashMap<String, String>(); // mapping of permission - to filename.\r\n        this.workPath   = getDataPath(SwitchboardConstants.WORK_PATH, SwitchboardConstants.WORK_PATH_DEFAULT);\r\n        this.log.logConfig(\"Work Path:    \" + this.workPath.toString());\r\n        this.dictionariesPath = getDataPath(SwitchboardConstants.DICTIONARY_SOURCE_PATH, SwitchboardConstants.DICTIONARY_SOURCE_PATH_DEFAULT);\r\n        this.log.logConfig(\"Dictionaries Path:\" + this.dictionariesPath.toString());\r\n\r\n        // init sessionid name file\r\n        final String sessionidNamesFile = getConfig(\"sessionidNamesFile\",\"defaults/sessionid.names\");\r\n        this.log.logConfig(\"Loading sessionid file \" + sessionidNamesFile);\r\n        MultiProtocolURI.initSessionIDNames(FileUtils.loadList(new File(getAppPath(), sessionidNamesFile)));\r\n\r\n        // init tables\r\n        this.tables = new WorkTables(this.workPath);\r\n        \r\n        // init libraries\r\n        this.log.logConfig(\"initializing libraries\");\r\n        LibraryProvider.initialize(this.dictionariesPath);\r\n        \r\n        // set a high maximum cache size to current size; this is adopted later automatically\r\n        final int wordCacheMaxCount = (int) getConfigLong(SwitchboardConstants.WORDCACHE_MAX_COUNT, 20000);\r\n        setConfig(SwitchboardConstants.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\r\n\r\n        // load the network definition\r\n        overwriteNetworkDefinition();\r\n\r\n        // start indexing management\r\n        log.logConfig(\"Starting Indexing Management\");\r\n        final String networkName = getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\r\n        final long fileSizeMax = (OS.isWindows) ? sb.getConfigLong(\"filesize.max.win\", (long) Integer.MAX_VALUE) : sb.getConfigLong(\"filesize.max.other\", (long) Integer.MAX_VALUE);\r\n        final int redundancy = (int) sb.getConfigLong(\"network.unit.dhtredundancy.senior\", 1);\r\n        final int partitionExponent = (int) sb.getConfigLong(\"network.unit.dht.partitionExponent\", 0);\r\n        this.networkRoot = new File(new File(indexPath, networkName), \"NETWORK\");\r\n        this.queuesRoot = new File(new File(indexPath, networkName), \"QUEUES\");\r\n        this.networkRoot.mkdirs();\r\n        this.queuesRoot.mkdirs();\r\n\t\tfinal File mySeedFile = new File(networkRoot, yacySeedDB.DBFILE_OWN_SEED);\r\n        peers = new yacySeedDB(\r\n                networkRoot,\r\n                \"seed.new.heap\",\r\n                \"seed.old.heap\",\r\n                \"seed.pot.heap\",\r\n                mySeedFile,\r\n                redundancy,\r\n                partitionExponent,\r\n                this.useTailCache,\r\n                this.exceed134217727);\r\n        File oldSingleSegment = new File(new File(indexPath, networkName), \"TEXT\");\r\n        File newSegmentsPath = new File(new File(indexPath, networkName), \"SEGMENTS\");\r\n        Segments.migrateOld(oldSingleSegment, newSegmentsPath, getConfig(SwitchboardConstants.SEGMENT_PUBLIC, \"default\"));\r\n        indexSegments = new Segments(\r\n                log,\r\n                newSegmentsPath,\r\n                wordCacheMaxCount,\r\n                fileSizeMax,\r\n                this.useTailCache,\r\n                this.exceed134217727);\r\n        // set the default segment names\r\n        setDefaultSegments();\r\n        \r\n        // create a crawler\r\n        crawler = new CrawlSwitchboard(\r\n                networkName,\r\n                log,\r\n                this.queuesRoot);\r\n\t\t\r\n\t\t\r\n\t\t// init crawl results monitor cache\r\n        crawlResults = new ResultURLs(100);\r\n        \r\n        // start yacy core\r\n        log.logConfig(\"Starting YaCy Protocol Core\");\r\n        this.yc = new yacyCore(this);\r\n        InstantBusyThread.oneTimeJob(this, \"loadSeedLists\", yacyCore.log, 0);\r\n        //final long startedSeedListAquisition = System.currentTimeMillis();\r\n        \r\n        // init a DHT transmission dispatcher\r\n        this.dhtDispatcher = new Dispatcher(\r\n                indexSegments.segment(Segments.Process.LOCALCRAWLING),\r\n                peers,\r\n                true, \r\n                10000);\r\n        \r\n        // set up local robots.txt\r\n        this.robotstxtConfig = RobotsTxtConfig.init(this);\r\n        \r\n        // setting timestamp of last proxy access\r\n        this.proxyLastAccess = System.currentTimeMillis() - 10000;\r\n        this.localSearchLastAccess = System.currentTimeMillis() - 10000;\r\n        this.remoteSearchLastAccess = System.currentTimeMillis() - 10000;\r\n        this.webStructure = new WebStructureGraph(log, rankingPath, \"LOCAL/010_cr/\", getConfig(\"CRDist0Path\", CRDistribution.CR_OWN), new File(queuesRoot, \"webStructure.map\"));\r\n        \r\n        // configuring list path\r\n        if (!(listsPath.exists())) listsPath.mkdirs();\r\n        \r\n        // load coloured lists\r\n        if (blueList == null) {\r\n            // read only once upon first instantiation of this class\r\n            final String f = getConfig(SwitchboardConstants.LIST_BLUE, SwitchboardConstants.LIST_BLUE_DEFAULT);\r\n            final File plasmaBlueListFile = new File(f);\r\n            if (f != null) blueList = SetTools.loadList(plasmaBlueListFile, NaturalOrder.naturalComparator); else blueList= new TreeSet<String>();\r\n            blueListHashes = Word.words2hashesHandles(blueList);\r\n            this.log.logConfig(\"loaded blue-list from file \" + plasmaBlueListFile.getName() + \", \" +\r\n            blueList.size() + \" entries, \" +\r\n            ppRamString(plasmaBlueListFile.length()/1024));\r\n        }\r\n        \r\n        // load blacklist\r\n        this.log.logConfig(\"Loading blacklist ...\");\r\n        final File blacklistsPath = getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\r\n        urlBlacklist = new Blacklist(blacklistsPath);\r\n        listManager.switchboard = this;\r\n        listManager.listsPath = blacklistsPath;        \r\n        listManager.reloadBlacklists();\r\n\r\n        // load badwords (to filter the topwords)\r\n        if (badwords == null || badwords.isEmpty()) {\r\n            final File badwordsFile = new File(appPath, SwitchboardConstants.LIST_BADWORDS_DEFAULT);\r\n            badwords = SetTools.loadList(badwordsFile, NaturalOrder.naturalComparator);\r\n            badwordHashes = Word.words2hashesHandles(badwords);\r\n            this.log.logConfig(\"loaded badwords from file \" + badwordsFile.getName() +\r\n                               \", \" + badwords.size() + \" entries, \" +\r\n                               ppRamString(badwordsFile.length()/1024));\r\n        }\r\n\r\n        // load stopwords\r\n        if (stopwords == null || stopwords.isEmpty()) {\r\n            final File stopwordsFile = new File(appPath, SwitchboardConstants.LIST_STOPWORDS_DEFAULT);\r\n            stopwords = SetTools.loadList(stopwordsFile, NaturalOrder.naturalComparator);\r\n            stopwordHashes = Word.words2hashesHandles(stopwords);\r\n            this.log.logConfig(\"loaded stopwords from file \" + stopwordsFile.getName() + \", \" +\r\n            stopwords.size() + \" entries, \" +\r\n            ppRamString(stopwordsFile.length()/1024));\r\n        }\r\n\r\n        // load ranking tables\r\n        final File YBRPath = new File(appPath, \"ranking/YBR\");\r\n        if (YBRPath.exists()) {\r\n            RankingProcess.loadYBR(YBRPath, 15);\r\n        }\r\n        \r\n        // load the robots.txt db\r\n        this.log.logConfig(\"Initializing robots.txt DB\");\r\n        robots = new RobotsTxt(this.tables.getHeap(WorkTables.TABLE_ROBOTS_NAME));\r\n        this.log.logConfig(\"Loaded robots.txt DB: \" +  robots.size() + \" entries\");\r\n        \r\n        // start a cache manager\r\n        log.logConfig(\"Starting HT Cache Manager\");\r\n        \r\n        // create the cache directory\r\n        htCachePath = getDataPath(SwitchboardConstants.HTCACHE_PATH, SwitchboardConstants.HTCACHE_PATH_DEFAULT);\r\n        this.log.logInfo(\"HTCACHE Path = \" + htCachePath.getAbsolutePath());\r\n        final long maxCacheSize = 1024 * 1024 * Long.parseLong(getConfig(SwitchboardConstants.PROXY_CACHE_SIZE, \"2\")); // this is megabyte\r\n        Cache.init(htCachePath, peers.mySeed().hash, maxCacheSize);\r\n        \r\n        // create the surrogates directories\r\n        surrogatesInPath = getDataPath(SwitchboardConstants.SURROGATES_IN_PATH, SwitchboardConstants.SURROGATES_IN_PATH_DEFAULT);\r\n        this.log.logInfo(\"surrogates.in Path = \" + surrogatesInPath.getAbsolutePath());\r\n        surrogatesInPath.mkdirs();\r\n        surrogatesOutPath = getDataPath(SwitchboardConstants.SURROGATES_OUT_PATH, SwitchboardConstants.SURROGATES_OUT_PATH_DEFAULT);\r\n        this.log.logInfo(\"surrogates.out Path = \" + surrogatesOutPath.getAbsolutePath());\r\n        surrogatesOutPath.mkdirs();\r\n        \r\n        // create the release download directory\r\n        releasePath = getDataPath(SwitchboardConstants.RELEASE_PATH, SwitchboardConstants.RELEASE_PATH_DEFAULT);\r\n        releasePath.mkdirs();\r\n        this.log.logInfo(\"RELEASE Path = \" + releasePath.getAbsolutePath());\r\n       \r\n        // starting message board\r\n        initMessages();\r\n        \r\n        // starting wiki\r\n        initWiki();\r\n        \r\n        //starting blog\r\n        initBlog();\r\n        \r\n        // Init User DB\r\n        this.log.logConfig(\"Loading User DB\");\r\n        final File userDbFile = new File(getDataPath(), \"DATA/SETTINGS/user.heap\");\r\n        this.userDB = new userDB(userDbFile);\r\n        this.log.logConfig(\"Loaded User DB from file \" + userDbFile.getName() +\r\n        \", \" + this.userDB.size() + \" entries\" +\r\n        \", \" + ppRamString(userDbFile.length()/1024));\r\n        \r\n        //Init bookmarks DB\r\n        initBookmarks();\r\n        \r\n        // define a realtime parsable mimetype list\r\n        log.logConfig(\"Parser: Initializing Mime Type deny list\");\r\n        TextParser.setDenyMime(getConfig(SwitchboardConstants.PARSER_MIME_DENY, null));\r\n        \r\n        // start a loader\r\n        log.logConfig(\"Starting Crawl Loader\");\r\n        this.loader = new LoaderDispatcher(this);\r\n        Map<String, File> oaiFriends = OAIListFriendsLoader.loadListFriendsSources(new File(\"defaults/oaiListFriendsSource.xml\"), getDataPath());\r\n        OAIListFriendsLoader.init(this.loader, oaiFriends);\r\n        this.crawlQueues = new CrawlQueues(this, queuesRoot);\r\n        this.crawlQueues.noticeURL.setMinimumDelta(\r\n                this.getConfigLong(\"minimumLocalDelta\", this.crawlQueues.noticeURL.getMinimumLocalDelta()),\r\n                this.getConfigLong(\"minimumGlobalDelta\", this.crawlQueues.noticeURL.getMinimumGlobalDelta()));\r\n\r\n        /*\r\n         * Creating sync objects and loading status for the crawl jobs\r\n         * a) local crawl\r\n         * b) remote triggered crawl\r\n         * c) global crawl trigger\r\n         */\r\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, new Object[]{\r\n                new Object(),\r\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL + \"_isPaused\", \"false\"))});\r\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, new Object[]{\r\n                new Object(),\r\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL + \"_isPaused\", \"false\"))});\r\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER, new Object[]{\r\n                new Object(),\r\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER + \"_isPaused\", \"false\"))});\r\n        \r\n        // init cookie-Monitor\r\n        this.log.logConfig(\"Starting Cookie Monitor\");\r\n        this.outgoingCookies = new ConcurrentHashMap<String, Object[]>();\r\n        this.incomingCookies = new ConcurrentHashMap<String, Object[]>();\r\n        \r\n        // init search history trackers\r\n        this.localSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>(); // String:TreeSet - IP:set of Long(accessTime)\r\n        this.remoteSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>();\r\n        this.localSearches = new ArrayList<QueryParams>(); // contains search result properties as HashMaps\r\n        this.remoteSearches = new ArrayList<QueryParams>();\r\n        \r\n        // init messages: clean up message symbol\r\n        final File notifierSource = new File(getAppPath(), getConfig(SwitchboardConstants.HTROOT_PATH, SwitchboardConstants.HTROOT_PATH_DEFAULT) + \"/env/grafics/empty.gif\");\r\n        final File notifierDest = new File(getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT), \"notifier.gif\");\r\n        try {\r\n            FileUtils.copy(notifierSource, notifierDest);\r\n        } catch (final IOException e) {\r\n        }\r\n        \r\n        // init ranking transmission\r\n        /*\r\n        CRDistOn       = true/false\r\n        CRDist0Path    = GLOBAL/010_owncr\r\n        CRDist0Method  = 1\r\n        CRDist0Percent = 0\r\n        CRDist0Target  =\r\n        CRDist1Path    = GLOBAL/014_othercr/1\r\n        CRDist1Method  = 9\r\n        CRDist1Percent = 30\r\n        CRDist1Target  = kaskelix.de:8080,yacy.dyndns.org:8000,suma-lab.de:8080\r\n         **/\r\n        rankingOn = getConfig(SwitchboardConstants.RANKING_DIST_ON, \"true\").equals(\"true\") && networkName.equals(\"freeworld\");\r\n        rankingOwnDistribution = new CRDistribution(log, peers, new File(rankingPath, getConfig(SwitchboardConstants.RANKING_DIST_0_PATH, CRDistribution.CR_OWN)), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_0_METHOD, CRDistribution.METHOD_ANYSENIOR), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_0_METHOD, 0), getConfig(SwitchboardConstants.RANKING_DIST_0_TARGET, \"\"));\r\n        rankingOtherDistribution = new CRDistribution(log, peers, new File(rankingPath, getConfig(SwitchboardConstants.RANKING_DIST_1_PATH, CRDistribution.CR_OTHER)), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_1_METHOD, CRDistribution.METHOD_MIXEDSENIOR), (int) getConfigLong(SwitchboardConstants.RANKING_DIST_1_METHOD, 30), getConfig(SwitchboardConstants.RANKING_DIST_1_TARGET, \"kaskelix.de:8080,yacy.dyndns.org:8000\"));\r\n\r\n        // init nameCacheNoCachingList\r\n        Domains.setNoCachingPatterns(getConfig(SwitchboardConstants.HTTPC_NAME_CACHE_CACHING_PATTERNS_NO,\"\"));\r\n        \r\n        // generate snippets cache\r\n        log.logConfig(\"Initializing Snippet Cache\");\r\n        \r\n        // init the wiki\r\n        wikiParser = new wikiCode(this.peers.mySeed().getClusterAddress());\r\n        \r\n        // initializing the resourceObserver\r\n        InstantBusyThread.oneTimeJob(ResourceObserver.class, \"initThread\", ResourceObserver.log, 0);\r\n        \r\n        // initializing the stackCrawlThread\r\n        this.crawlStacker = new CrawlStacker(\r\n                this.crawlQueues,\r\n                this.crawler,\r\n                this.indexSegments.segment(Segments.Process.LOCALCRAWLING),\r\n                this.peers,\r\n                \"local.any\".indexOf(getConfig(\"network.unit.domain\", \"global\")) >= 0,\r\n                \"global.any\".indexOf(getConfig(\"network.unit.domain\", \"global\")) >= 0);\r\n        \r\n        // initializing dht chunk generation\r\n        this.dhtMaxReferenceCount = (int) getConfigLong(SwitchboardConstants.INDEX_DIST_CHUNK_SIZE_START, 50);\r\n        \r\n        // init robinson cluster\r\n        // before we do that, we wait some time until the seed list is loaded.\r\n        this.clusterhashes = this.peers.clusterHashes(getConfig(\"cluster.peers.yacydomain\", \"\"));\r\n        \r\n        // deploy blocking threads\r\n        int indexerThreads = Math.max(1, WorkflowProcessor.useCPU / 2);\r\n        this.indexingStorageProcessor      = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"storeDocumentIndex\",\r\n                \"This is the sequencing step of the indexing queue. Files are written as streams, too much councurrency would destroy IO performance. In this process the words are written to the RWI cache, which flushes if it is full.\",\r\n                new String[]{\"RWI/Cache/Collections\"},\r\n                this, \"storeDocumentIndex\", 2 * WorkflowProcessor.useCPU, null, indexerThreads);\r\n        this.indexingAnalysisProcessor     = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"webStructureAnalysis\",\r\n                \"This just stores the link structure of the document into a web structure database.\",\r\n                new String[]{\"storeDocumentIndex\"},\r\n                this, \"webStructureAnalysis\", 2 * WorkflowProcessor.useCPU, indexingStorageProcessor, WorkflowProcessor.useCPU + 1);\r\n        this.indexingCondensementProcessor = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"condenseDocument\",\r\n                \"This does a structural analysis of plain texts: markup of headlines, slicing into phrases (i.e. sentences), markup with position, counting of words, calculation of term frequency.\",\r\n                new String[]{\"webStructureAnalysis\"},\r\n                this, \"condenseDocument\", 4 * WorkflowProcessor.useCPU, indexingAnalysisProcessor, WorkflowProcessor.useCPU + 1);\r\n        this.indexingDocumentProcessor     = new WorkflowProcessor<indexingQueueEntry>(\r\n                \"parseDocument\",\r\n                \"This does the parsing of the newly loaded documents from the web. The result is not only a plain text document, but also a list of URLs that are embedded into the document. The urls are handed over to the CrawlStacker. This process has two child process queues!\",\r\n                new String[]{\"condenseDocument\", \"CrawlStacker\"},\r\n                this, \"parseDocument\", 4 * WorkflowProcessor.useCPU, indexingCondensementProcessor, WorkflowProcessor.useCPU + 1);\r\n        \r\n        // deploy busy threads\r\n        log.logConfig(\"Starting Threads\");\r\n        MemoryControl.gc(10000, \"plasmaSwitchboard, help for profiler\"); // help for profiler - thq\r\n        \r\n        deployThread(SwitchboardConstants.CLEANUP, \"Cleanup\", \"simple cleaning process for monitoring information\", null,\r\n                     new InstantBusyThread(\r\n                         this,\r\n                         SwitchboardConstants.CLEANUP_METHOD_START,\r\n                         SwitchboardConstants.CLEANUP_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CLEANUP_METHOD_FREEMEM,\r\n                         60000, Long.MAX_VALUE, 10000, Long.MAX_VALUE),\r\n                     60000); // all 5 Minutes, wait 1 minute until first run\r\n        deployThread(SwitchboardConstants.SURROGATES, \"Surrogates\", \"A thread that polls the SURROGATES path and puts all Documents in one surroagte file into the indexing queue.\", null,\r\n                     new InstantBusyThread(\r\n                         this,\r\n                         SwitchboardConstants.SURROGATES_METHOD_START,\r\n                         SwitchboardConstants.SURROGATES_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.SURROGATES_METHOD_FREEMEM,\r\n                         20000, Long.MAX_VALUE, 0, Long.MAX_VALUE),\r\n                     10000);\r\n        deployThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"Remote Crawl Job\", \"thread that performes a single crawl/indexing step triggered by a remote peer\", \"/IndexCreateWWWRemoteQueue_p.html\",\r\n                     new InstantBusyThread(\r\n                         crawlQueues,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_START,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_FREEMEM,\r\n                         0, Long.MAX_VALUE, 0, Long.MAX_VALUE),\r\n                     10000);\r\n        deployThread(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER, \"Remote Crawl URL Loader\", \"thread that loads remote crawl lists from other peers\", null,\r\n                     new InstantBusyThread(\r\n                         crawlQueues,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_START,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_FREEMEM,\r\n                         10000, Long.MAX_VALUE, 10000, Long.MAX_VALUE),\r\n                     10000); // error here?\r\n        deployThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"Local Crawl\", \"thread that performes a single crawl step from the local crawl queue\", \"/IndexCreateWWWLocalQueue_p.html\",\r\n                     new InstantBusyThread(\r\n                         crawlQueues,\r\n                         SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_START,\r\n                         SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_FREEMEM,\r\n                         0, Long.MAX_VALUE, 0, Long.MAX_VALUE),\r\n                     10000);\r\n        deployThread(SwitchboardConstants.SEED_UPLOAD, \"Seed-List Upload\", \"task that a principal peer performes to generate and upload a seed-list to a ftp account\", null,\r\n                     new InstantBusyThread(\r\n                         yc,\r\n                         SwitchboardConstants.SEED_UPLOAD_METHOD_START,\r\n                         SwitchboardConstants.SEED_UPLOAD_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.SEED_UPLOAD_METHOD_FREEMEM,\r\n                         600000, Long.MAX_VALUE, 300000, Long.MAX_VALUE),\r\n                     180000);\r\n        deployThread(SwitchboardConstants.PEER_PING, \"YaCy Core\", \"this is the p2p-control and peer-ping task\", null,\r\n                     new InstantBusyThread(\r\n                         yc,\r\n                         SwitchboardConstants.PEER_PING_METHOD_START,\r\n                         SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\r\n                         60000, Long.MAX_VALUE, 60000, Long.MAX_VALUE),\r\n                     2000);\r\n        deployThread(SwitchboardConstants.INDEX_DIST, \"DHT Distribution\", \"selection, transfer and deletion of index entries that are not searched on your peer, but on others\", null,\r\n                     new InstantBusyThread(\r\n                         this,\r\n                         SwitchboardConstants.INDEX_DIST_METHOD_START,\r\n                         SwitchboardConstants.INDEX_DIST_METHOD_JOBCOUNT,\r\n                         SwitchboardConstants.INDEX_DIST_METHOD_FREEMEM,\r\n                         10000, Long.MAX_VALUE, 1000, Long.MAX_VALUE),\r\n                     5000,\r\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_IDLESLEEP , \"5000\")),\r\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_BUSYSLEEP , \"0\")),\r\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_MEMPREREQ , \"1000000\")));\r\n\r\n        // set network-specific performance attributes\r\n        if (this.firstInit) {\r\n            setRemotecrawlPPM(Math.max(1, (int) getConfigLong(\"network.unit.remotecrawl.speed\", 60)));\r\n        }\r\n        \r\n        // test routine for snippet fetch\r\n        //Set query = new HashSet();\r\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Weitergabe\"));\r\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Zahl\"));\r\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/mobil/newsticker/meldung/mail/54980\"), query, true);\r\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/security/news/foren/go.shtml?read=1&msg_id=7301419&forum_id=72721\"), query, true);\r\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/kiosk/archiv/ct/2003/4/20\"), query, true, 260);\r\n\r\n        this.trail = new LinkedBlockingQueue<String>();\r\n        \r\n        log.logConfig(\"Finished Switchboard Initialization\");\r\n        sb = this;\r\n    }","commit_id":"a83186ac7d183fd065b6bc864e291cbe71c99836","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static Image respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        \r\n        final Switchboard sb = (Switchboard)env;\r\n\r\n        // harvest request information\r\n        StringBuilder connect = new StringBuilder();\r\n        connect.append('{');\r\n        addJSON(connect, \"time\", DateFormatter.formatShortMilliSecond(new Date()));\r\n        addJSON(connect, \"trail\", header.referer().toNormalform(false, false));\r\n        addJSON(connect, \"nick\",  (post == null) ? \"\" : post.get(\"nick\", \"\"));\r\n        addJSON(connect, \"tag\",   (post == null) ? \"\" : post.get(\"tag\", \"\"));\r\n        addJSON(connect, \"icon\",  (post == null) ? \"\" : post.get(\"icon\", \"\"));\r\n        addJSON(connect, \"ip\",    header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\"));\r\n        addJSON(connect, \"agent\", header.get(\"User-Agent\", \"\"));\r\n        connect.append('}');\r\n        \r\n        sb.trail.add(connect.toString());\r\n        //Log.logInfo(\"CYTAG\", \"catched trail - \" + connect.toString());\r\n        \r\n        String defaultimage = \"redpillmini.png\";\r\n        if (post != null && post.get(\"icon\", \"\").equals(\"invisible\")) defaultimage = \"invisible.png\";\r\n        File iconfile = new File(sb.getAppPath(), \"/htroot/env/grafics/\" + defaultimage);\r\n        \r\n        byte[] imgb = null;\r\n        try {\r\n            imgb = FileUtils.read(iconfile);\r\n        } catch (final IOException e) {\r\n             return null;\r\n        }\r\n        if (imgb == null) return null;\r\n        \r\n        // read image\r\n        final Image image = ImageParser.parse(\"cytag.png\", imgb);\r\n\r\n        return image;\r\n    }","id":84714,"modified_method":"public static Image respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        \r\n        final Switchboard sb = (Switchboard)env;\r\n        MultiProtocolURI referer = header.referer();\r\n        \r\n        // harvest request information\r\n        StringBuilder connect = new StringBuilder();\r\n        connect.append('{');\r\n        addJSON(connect, \"time\", DateFormatter.formatShortMilliSecond(new Date()));\r\n        addJSON(connect, \"trail\", (referer == null) ? \"\" : referer.toNormalform(false, false));\r\n        addJSON(connect, \"nick\",  (post == null) ? \"\" : post.get(\"nick\", \"\"));\r\n        addJSON(connect, \"tag\",   (post == null) ? \"\" : post.get(\"tag\", \"\"));\r\n        addJSON(connect, \"icon\",  (post == null) ? \"\" : post.get(\"icon\", \"\"));\r\n        addJSON(connect, \"ip\",    header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\"));\r\n        addJSON(connect, \"agent\", header.get(\"User-Agent\", \"\"));\r\n        connect.append('}');\r\n        \r\n        if (sb.trail.size() >= 100) sb.trail.remove();\r\n        sb.trail.add(connect.toString());\r\n        //Log.logInfo(\"CYTAG\", \"catched trail - \" + connect.toString());\r\n        \r\n        String defaultimage = \"redpillmini.png\";\r\n        if (post != null && post.get(\"icon\", \"\").equals(\"invisible\")) defaultimage = \"invisible.png\";\r\n        File iconfile = new File(sb.getAppPath(), \"/htroot/env/grafics/\" + defaultimage);\r\n        \r\n        byte[] imgb = null;\r\n        try {\r\n            imgb = FileUtils.read(iconfile);\r\n        } catch (final IOException e) {\r\n             return null;\r\n        }\r\n        if (imgb == null) return null;\r\n        \r\n        // read image\r\n        final Image image = ImageParser.parse(\"cytag.png\", imgb);\r\n\r\n        return image;\r\n    }","commit_id":"a83186ac7d183fd065b6bc864e291cbe71c99836","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * discover all urls that start with a given url stub\n     * @param stub\n     * @return an iterator for all matching urls\n     */\n    public Iterator<DigestURI> urlSelector(MultiProtocolURI stub) {\n        final String host = stub.getHost();\n        String hh = DigestURI.hosthash(host);\n        final BlockingQueue<SolrDocument> docQueue = this.fulltext.getSolr().concurrentQuery(YaCySchema.host_id_s + \":\\\"\" + hh + \"\\\"\", 0, Integer.MAX_VALUE, 600000L, 100000, YaCySchema.id.getSolrFieldName(), YaCySchema.sku.getSolrFieldName());\n\n        final String urlstub = stub.toNormalform(true);\n\n        // now filter the stub from the iterated urls\n        return new LookAheadIterator<DigestURI>() {\n            @Override\n            protected DigestURI next0() {\n                while (true) {\n                    SolrDocument doc;\n                    try {\n                        doc = docQueue.take();\n                    } catch (InterruptedException e) {\n                        Log.logException(e);\n                        return null;\n                    }\n                    if (doc == null || doc == AbstractSolrConnector.POISON_DOCUMENT) return null;\n                    String u = (String) doc.getFieldValue(YaCySchema.sku.getSolrFieldName());\n                    String id =  (String) doc.getFieldValue(YaCySchema.id.getSolrFieldName());\n                    DigestURI url;\n                    try {\n                        url = new DigestURI(u, ASCII.getBytes(id));\n                    } catch (MalformedURLException e) {\n                        continue;\n                    }\n                    if (u.startsWith(urlstub)) return url;\n                }\n            }\n        };\n    }","id":84715,"modified_method":"/**\n     * discover all urls that start with a given url stub\n     * @param stub\n     * @return an iterator for all matching urls\n     */\n    public Iterator<DigestURI> urlSelector(final MultiProtocolURI stub, final long maxtime, final int maxcount) {\n        final BlockingQueue<SolrDocument> docQueue;\n        final String urlstub;\n        if (stub == null) {\n            docQueue = this.fulltext.getSolr().concurrentQuery(\"*:*\", 0, Integer.MAX_VALUE, maxtime, maxcount, YaCySchema.id.getSolrFieldName(), YaCySchema.sku.getSolrFieldName());\n            urlstub = null;\n        } else {\n            final String host = stub.getHost();\n            String hh = DigestURI.hosthash(host);\n            docQueue = this.fulltext.getSolr().concurrentQuery(YaCySchema.host_id_s + \":\\\"\" + hh + \"\\\"\", 0, Integer.MAX_VALUE, maxtime, maxcount, YaCySchema.id.getSolrFieldName(), YaCySchema.sku.getSolrFieldName());\n            urlstub = stub.toNormalform(true);\n        }\n\n        // now filter the stub from the iterated urls\n        return new LookAheadIterator<DigestURI>() {\n            @Override\n            protected DigestURI next0() {\n                while (true) {\n                    SolrDocument doc;\n                    try {\n                        doc = docQueue.take();\n                    } catch (InterruptedException e) {\n                        Log.logException(e);\n                        return null;\n                    }\n                    if (doc == null || doc == AbstractSolrConnector.POISON_DOCUMENT) return null;\n                    String u = (String) doc.getFieldValue(YaCySchema.sku.getSolrFieldName());\n                    String id =  (String) doc.getFieldValue(YaCySchema.id.getSolrFieldName());\n                    DigestURI url;\n                    try {\n                        url = new DigestURI(u, ASCII.getBytes(id));\n                    } catch (MalformedURLException e) {\n                        continue;\n                    }\n                    if (urlstub == null || u.startsWith(urlstub)) return url;\n                }\n            }\n        };\n    }","commit_id":"a2160054d790ea4f5a20e7d2ade236ecafef2a04","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public URL releaseLicense(String license) {\n        URL url = null;\n        synchronized (permissions) {\n            url = (URL) permissions.remove(license);\n        }\n        if (url == null) {\n            System.out.println(\"DEBUG-URLLICENSE: no URL license present for code=\" + license);\n        } else {\n            System.out.println(\"DEBUG-URLLICENSE: granted download of \" + url.toString());\n        }\n        return url;\n    }","id":84716,"modified_method":"public URL releaseLicense(String license) {\n        URL url = null;\n        synchronized (permissions) {\n            url = (URL) permissions.remove(license);\n        }\n        /*\n        if (url == null) {\n            System.out.println(\"DEBUG-URLLICENSE: no URL license present for code=\" + license);\n        } else {\n            System.out.println(\"DEBUG-URLLICENSE: granted download of \" + url.toString());\n        }\n        */\n        return url;\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static Image respond(httpHeader header, serverObjects post, serverSwitch env) {\n        \n        plasmaSwitchboard sb = (plasmaSwitchboard)env;     \n        \n        // the url to the image can be either submitted with an url in clear text, or using a license key\n        // if the url is given as clear text, the user must be authorized as admin\n        // the license can be used also from non-authorized users\n        \n        String urlString = post.get(\"url\", \"\");\n        String urlLicense = post.get(\"code\", \"\");\n        boolean auth = ((String) header.get(\"CLIENTIP\", \"\")).equals(\"localhost\") || sb.verifyAuthentication(header, true); // handle access rights\n        \n        URL url = null;\n        if ((urlString.length() > 0) && (auth)) try {\n            url = new URL(urlString);\n        } catch (MalformedURLException e1) {\n            url = null;\n        }\n        \n        if ((url == null) && (urlLicense.length() > 0)) {\n            url = sb.licensedURLs.releaseLicense(urlLicense);\n            urlString = url.toNormalform(true, true);\n        }\n        \n        if (url == null) return null;\n        System.out.println(\"loading image from \" + url.toString());\n        \n        int width = post.getInt(\"width\", 0);\n        int height = post.getInt(\"height\", 0);\n        int maxwidth = post.getInt(\"maxwidth\", 0);\n        int maxheight = post.getInt(\"maxheight\", 0);\n        int timeout = post.getInt(\"timeout\", 5000);\n        \n        // getting the image as stream\n        Object[] resource = plasmaSnippetCache.getResource(url, true, timeout, false);\n        byte[] imgb = null;\n        if (resource == null) {\n            if (urlString.endsWith(\".ico\")) {\n                // load default favicon dfltfvcn.ico\n                try {\n                    imgb = serverFileUtils.read(new File(sb.getRootPath(), \"htroot/env/grafics/dfltfvcn.ico\"));\n                } catch (IOException e) {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            InputStream imgStream = (InputStream) resource[0];\n            if (imgStream == null) return null;\n        \n            // read image data\n            try {\n                imgb = serverFileUtils.read(imgStream);\n            } catch (IOException e) {\n                return null;\n            } finally {\n                try { imgStream.close(); } catch (Exception e) {/* ignore this */}\n            }\n        }\n        \n        // read image\n        Image image = ymageImageParser.parse(urlString.toString(), imgb);\n        \n        if ((auth) && ((width == 0) || (height == 0)) && (maxwidth == 0) && (maxheight == 0)) return image;\n\n        // find original size\n        int h = image.getHeight(null);\n        int w = image.getWidth(null);\n        \n        //System.out.println(\"DEBUG: get access to image \" + url.toNormalform() + \" is \" + ((auth) ? \"authorized\" : \"NOT authorized\"));\n        \n        // in case of not-authorized access shrink the image to prevent copyright problems\n        // so that images are not larger than thumbnails\n        if (!auth) {\n            maxwidth = (int) Math.min(64.0, w * 0.6);\n            maxheight = (int) Math.min(64.0, h * 0.6);\n        }\n        \n        // calculate width & height from maxwidth & maxheight\n        if ((maxwidth != 0) || (maxheight != 0)) {\n            double hs = (w <= maxwidth) ? 1.0 : ((double) maxwidth) / ((double) w);\n            double vs = (h <= maxheight) ? 1.0 : ((double) maxheight) / ((double) h);\n            double scale = Math.min(hs, vs);\n            if (!auth) scale = Math.min(scale, 0.6); // this is for copyright purpose\n            if (scale < 1.0) {\n                width = (int) (((double) w) * scale);\n                height = (int) (((double) h) * scale);\n            } else {\n                width = w;\n                height = h;\n            }\n        } else {\n            width = w;\n            height = h;\n        }\n        \n        // check for minimum values\n        width = Math.max(width, 1);\n        height = Math.max(height, 1);\n        \n        // scale image \n        Image scaled = image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING); \n        MediaTracker mediaTracker = new MediaTracker(new Container()); \n        mediaTracker.addImage(scaled, 0); \n        try {mediaTracker.waitForID(0);} catch (InterruptedException e) {} \n\n        return scaled;\n    }","id":84717,"modified_method":"public static Image respond(httpHeader header, serverObjects post, serverSwitch env) {\n        \n        plasmaSwitchboard sb = (plasmaSwitchboard)env;     \n        \n        // the url to the image can be either submitted with an url in clear text, or using a license key\n        // if the url is given as clear text, the user must be authorized as admin\n        // the license can be used also from non-authorized users\n        \n        String urlString = post.get(\"url\", \"\");\n        String urlLicense = post.get(\"code\", \"\");\n        boolean auth = ((String) header.get(\"CLIENTIP\", \"\")).equals(\"localhost\") || sb.verifyAuthentication(header, true); // handle access rights\n        \n        URL url = null;\n        if ((urlString.length() > 0) && (auth)) try {\n            url = new URL(urlString);\n        } catch (MalformedURLException e1) {\n            url = null;\n        }\n        \n        if ((url == null) && (urlLicense.length() > 0)) {\n            url = sb.licensedURLs.releaseLicense(urlLicense);\n            urlString = (url == null) ? null : url.toNormalform(true, true);\n        }\n        \n        if (url == null) return null;\n        System.out.println(\"loading image from \" + url.toString());\n        \n        int width = post.getInt(\"width\", 0);\n        int height = post.getInt(\"height\", 0);\n        int maxwidth = post.getInt(\"maxwidth\", 0);\n        int maxheight = post.getInt(\"maxheight\", 0);\n        int timeout = post.getInt(\"timeout\", 5000);\n        \n        // getting the image as stream\n        Object[] resource = plasmaSnippetCache.getResource(url, true, timeout, false);\n        byte[] imgb = null;\n        if (resource == null) {\n            if (urlString.endsWith(\".ico\")) {\n                // load default favicon dfltfvcn.ico\n                try {\n                    imgb = serverFileUtils.read(new File(sb.getRootPath(), \"htroot/env/grafics/dfltfvcn.ico\"));\n                } catch (IOException e) {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            InputStream imgStream = (InputStream) resource[0];\n            if (imgStream == null) return null;\n        \n            // read image data\n            try {\n                imgb = serverFileUtils.read(imgStream);\n            } catch (IOException e) {\n                return null;\n            } finally {\n                try { imgStream.close(); } catch (Exception e) {/* ignore this */}\n            }\n        }\n        \n        // read image\n        Image image = ymageImageParser.parse(urlString.toString(), imgb);\n        \n        if ((auth) && ((width == 0) || (height == 0)) && (maxwidth == 0) && (maxheight == 0)) return image;\n\n        // find original size\n        int h = image.getHeight(null);\n        int w = image.getWidth(null);\n        \n        //System.out.println(\"DEBUG: get access to image \" + url.toNormalform() + \" is \" + ((auth) ? \"authorized\" : \"NOT authorized\"));\n        \n        // in case of not-authorized access shrink the image to prevent copyright problems\n        // so that images are not larger than thumbnails\n        if (!auth) {\n            maxwidth = (int) Math.min(64.0, w * 0.6);\n            maxheight = (int) Math.min(64.0, h * 0.6);\n        }\n        \n        // calculate width & height from maxwidth & maxheight\n        if ((maxwidth != 0) || (maxheight != 0)) {\n            double hs = (w <= maxwidth) ? 1.0 : ((double) maxwidth) / ((double) w);\n            double vs = (h <= maxheight) ? 1.0 : ((double) maxheight) / ((double) h);\n            double scale = Math.min(hs, vs);\n            if (!auth) scale = Math.min(scale, 0.6); // this is for copyright purpose\n            if (scale < 1.0) {\n                width = (int) (((double) w) * scale);\n                height = (int) (((double) h) * scale);\n            } else {\n                width = w;\n                height = h;\n            }\n        } else {\n            width = w;\n            height = h;\n        }\n        \n        // check for minimum values\n        width = Math.max(width, 1);\n        height = Math.max(height, 1);\n        \n        // scale image \n        Image scaled = image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING); \n        MediaTracker mediaTracker = new MediaTracker(new Container()); \n        mediaTracker.addImage(scaled, 0); \n        try {mediaTracker.waitForID(0);} catch (InterruptedException e) {} \n\n        return scaled;\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void doResponse(Properties conProp, httpHeader requestHeader, OutputStream out, InputStream body) {\r\n        \r\n        String path = null;\r\n        try {\r\n            // getting some connection properties            \r\n            String method = conProp.getProperty(httpHeader.CONNECTION_PROP_METHOD);\r\n            path = conProp.getProperty(httpHeader.CONNECTION_PROP_PATH);\r\n            String argsString = conProp.getProperty(httpHeader.CONNECTION_PROP_ARGS); // is null if no args were given\r\n            String httpVersion= conProp.getProperty(httpHeader.CONNECTION_PROP_HTTP_VER);\r\n            \r\n            // check hack attacks in path\r\n            if (path.indexOf(\"..\") >= 0) {\r\n                httpd.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\r\n                return;\r\n            }\r\n            \r\n            // url decoding of path\r\n            try {\r\n                path = URLDecoder.decode(path, \"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                // This should never occur\r\n                assert(false) : \"UnsupportedEncodingException: \" + e.getMessage();\r\n            }\r\n            \r\n            // check permission/granted access\r\n            String authorization = (String) requestHeader.get(httpHeader.AUTHORIZATION);\r\n            String adminAccountBase64MD5 = switchboard.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\");\r\n            \r\n            int pos = path.lastIndexOf(\".\");\r\n            \r\n            if ((path.substring(0,(pos==-1)?path.length():pos)).endsWith(\"_p\") && (adminAccountBase64MD5.length() != 0)) {\r\n                //authentication required\r\n                //userDB\r\n                if(sb.userDB.hasAdminRight(authorization, conProp.getProperty(\"CLIENTIP\"), requestHeader.getHeaderCookies())){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //static\r\n                }else if(authorization != null && httpd.staticAdminAuthenticated(authorization.trim().substring(6), switchboard)==4){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //no auth\r\n                }else if (authorization == null) {\r\n                    // no authorization given in response. Ask for that\r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    //httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    servletProperties tp=new servletProperties();\r\n                    tp.put(\"returnto\", path);\r\n                    //TODO: separate errorpage Wrong Login / No Login\r\n                    httpd.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, headers);\r\n                    return;\r\n                } else {\r\n                    // a wrong authentication was given or the userDB user does not have admin access. Ask again\r\n                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                    serverLog.logInfo(\"HTTPD\", \"Wrong log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                    if (attempts == null)\r\n                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                    else\r\n                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n    \r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    return;\r\n                }\r\n            }\r\n        \r\n        \r\n            // parse arguments\r\n            serverObjects args = new serverObjects();\r\n            int argc;\r\n            if (argsString == null) {\r\n                // no args here, maybe a POST with multipart extension\r\n                int length = 0;\r\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\r\n                if (method.equals(httpHeader.METHOD_POST)) {\r\n    \r\n                    GZIPInputStream gzipBody = null;\r\n                    if (requestHeader.containsKey(httpHeader.CONTENT_LENGTH)) {\r\n                        length = Integer.parseInt((String) requestHeader.get(httpHeader.CONTENT_LENGTH));\r\n                    } else if (requestHeader.gzip()) {\r\n                        length = -1;\r\n                        gzipBody = new GZIPInputStream(body);\r\n                    }\r\n    //                } else {\r\n    //                    httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null); \r\n    //                    return;\r\n    //                }\r\n                    \r\n                    // if its a POST, it can be either multipart or as args in the body\r\n                    if ((requestHeader.containsKey(httpHeader.CONTENT_TYPE)) &&\r\n                            (((String) requestHeader.get(httpHeader.CONTENT_TYPE)).toLowerCase().startsWith(\"multipart\"))) {\r\n                        // parse multipart\r\n                        HashMap files = httpd.parseMultipart(requestHeader, args, (gzipBody!=null)?gzipBody:body, length);\r\n                        // integrate these files into the args\r\n                        if (files != null) {\r\n                            Iterator fit = files.entrySet().iterator();\r\n                            Map.Entry entry;\r\n                            while (fit.hasNext()) {\r\n                                entry = (Map.Entry) fit.next();\r\n                                args.put(((String) entry.getKey()) + \"$file\", entry.getValue());\r\n                            }\r\n                        }\r\n                        argc = Integer.parseInt((String) requestHeader.get(\"ARGC\"));\r\n                    } else {\r\n                        // parse args in body\r\n                        argc = httpd.parseArgs(args, (gzipBody!=null)?gzipBody:body, length);\r\n                    }\r\n                } else {\r\n                    // no args\r\n                    argsString = null;\r\n                    args = null;\r\n                    argc = 0;\r\n                }\r\n            } else {\r\n                // simple args in URL (stuff after the \"?\")\r\n                argc = httpd.parseArgs(args, argsString);\r\n            }\r\n        \r\n            // check for cross site scripting - attacks in request arguments\r\n            if (argc > 0) {\r\n                // check all values for occurrences of script values\r\n                Enumeration e = args.elements(); // enumeration of values\r\n                Object val;\r\n                while (e.hasMoreElements()) {\r\n                    val = e.nextElement();\r\n                    if ((val != null) && (val instanceof String) && (((String) val).indexOf(\"<script\") >= 0)) {\r\n                        // deny request\r\n                        httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        \r\n            // we are finished with parsing\r\n            // the result of value hand-over is in args and argc\r\n            if (path.length() == 0) {\r\n                httpd.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\r\n                out.flush();\r\n                return;\r\n            }\r\n            File targetClass=null;\r\n\r\n            // locate the file\r\n            if (!(path.startsWith(\"/\"))) path = \"/\" + path; // attach leading slash\r\n            \r\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\r\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\r\n            if (args != null && (args.containsKey(\"language\"))) \r\n            {\r\n                // TODO 9.11.06 Bost: a class with information about available languages is needed. \r\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\r\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\r\n                localeSelection = args.get(\"language\", localeSelection);\r\n                if (localeSelection.indexOf(\".\") != -1)\r\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf(\".\"));\r\n            }\r\n            \r\n            File   targetFile  = getLocalizedFile(path, localeSelection);\r\n            String targetExt   = conProp.getProperty(\"EXT\",\"\");\r\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\r\n            if (path.endsWith(\"/\")) {\r\n                String testpath;\r\n                // attach default file name\r\n                for (int i = 0; i < defaultFiles.length; i++) {\r\n                    testpath = path + defaultFiles[i];\r\n                    targetFile = getOverlayedFile(testpath);\r\n                    targetClass=getOverlayedClass(testpath);\r\n                    if (targetFile.exists()) {\r\n                        path = testpath;\r\n                        break;\r\n                    }\r\n                }\r\n                //no defaultfile, send a dirlisting\r\n                if(targetFile == null || !targetFile.exists()){\r\n                \tString dirlistFormat = (args==null)?\"html\":args.get(\"format\",\"html\");\r\n                \ttargetExt = dirlistFormat; // this is needed to set the mime type correctly\r\n                    targetFile = getOverlayedFile(\"/htdocsdefault/dir.\" + dirlistFormat);\r\n                    targetClass=getOverlayedClass(\"/htdocsdefault/dir.\" + dirlistFormat);\r\n                    if(! (( targetFile != null && targetFile.exists()) && ( targetClass != null && targetClass.exists())) ){\r\n                        httpd.sendRespondError(conProp, out, 3, 500, \"dir.\" + dirlistFormat + \" or dir.class not found.\", null, null);\r\n                    }\r\n                }\r\n            }else{\r\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\r\n                    if ( !(targetFile.exists()) && !((path.endsWith(\"png\")||path.endsWith(\"gif\")||path.endsWith(\".stream\"))&&targetClass!=null ) ){\r\n                        targetFile = new File(htDocsPath, path);\r\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\r\n                    }\r\n                \r\n            }\r\n            \r\n            //File targetClass = rewriteClassFile(targetFile);\r\n            //We need tp here\r\n            servletProperties tp = new servletProperties();\r\n            Date targetDate;\r\n            boolean nocache = false;\r\n            \r\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\r\n                // call an image-servlet to produce an on-the-fly - generated image\r\n                Object img = null;\r\n                try {\r\n                    requestHeader.put(httpHeader.CONNECTION_PROP_CLIENTIP, conProp.getProperty(\"CLIENTIP\"));\r\n                    requestHeader.put(httpHeader.CONNECTION_PROP_PATH, path);\r\n                    // in case that there are no args given, args = null or empty hashmap\r\n                    img = invokeServlet(targetClass, requestHeader, args);\r\n                } catch (InvocationTargetException e) {\r\n                    theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                    e.getMessage() +\r\n                    \" target exception at \" + targetClass + \": \" +\r\n                    e.getTargetException().toString() + \":\" +\r\n                    e.getTargetException().getMessage() +\r\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\",e);\r\n                    targetClass = null;\r\n                }\r\n                if (img == null) {\r\n                    // error with image generation; send file-not-found\r\n                    httpd.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\r\n                } else {\r\n                    if (img instanceof ymageMatrix) {\r\n                        ymageMatrix yp = (ymageMatrix) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        // ymagePNGEncoderJDE jde = new\r\n                        // ymagePNGEncoderJDE((ymageMatrixPainter) yp,\r\n                        // ymagePNGEncoderJDE.FILTER_NONE, 0);\r\n                        // byte[] result = jde.pngEncode();\r\n                        ImageIO.write(yp.getImage(), targetExt, baos);\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length, targetDate, null, null, null, null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            //Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                    if (img instanceof Image) {\r\n                        Image i = (Image) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\r\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\r\n                        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null); \r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        ImageIO.write(bi, targetExt, baos);\r\n\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length, targetDate, null, null, null, null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            //Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                }\r\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\r\n                // call rewrite-class\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_CLIENTIP, conProp.getProperty(\"CLIENTIP\"));\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_PATH, path);\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\r\n             \r\n                httpd.sendRespondHeader(conProp, out, httpVersion, 200, null);                \r\n                \r\n                // in case that there are no args given, args = null or empty hashmap\r\n                /* servletProperties tp = (servlerObjects) */ invokeServlet(targetClass, requestHeader, args);\r\n                forceConnectionClose(conProp);\r\n                return;                \r\n            } else if ((targetFile.exists()) && (targetFile.canRead())) {\r\n                // we have found a file that can be written to the client\r\n                // if this file uses templates, then we use the template\r\n                // re-write - method to create an result\r\n                String mimeType = mimeTable.getProperty(targetExt,\"text/html\");\r\n                boolean zipContent = requestHeader.acceptGzip() && httpd.shallTransportZipped(\".\" + conProp.getProperty(\"EXT\",\"\"));\r\n                if (path.endsWith(\"html\") || \r\n                        path.endsWith(\"xml\") || \r\n                        path.endsWith(\"rss\") || \r\n                        path.endsWith(\"csv\") ||\r\n                        path.endsWith(\"pac\") ||\r\n                        path.endsWith(\"src\") ||\r\n                        path.endsWith(\"vcf\") ||\r\n                        path.endsWith(\"/\") ||\r\n                        path.equals(\"/robots.txt\")) {\r\n                            \r\n                    /*targetFile = getLocalizedFile(path);\r\n\t\t\t\t\tif (!(targetFile.exists())) {\r\n\t\t                // try to find that file in the htDocsPath\r\n\t\t\t\t        File trialFile = new File(htDocsPath, path);\r\n\t\t\t\t\t\tif (trialFile.exists()) targetFile = trialFile;\r\n\t\t            }*/\r\n            \r\n                    \r\n                    // call rewrite-class\r\n                   \r\n                    if (targetClass == null) {\r\n                        targetDate = new Date(targetFile.lastModified());\r\n                    } else {\r\n                        // CGI-class: call the class to create a property for rewriting\r\n                        try {\r\n                            requestHeader.put(httpHeader.CONNECTION_PROP_CLIENTIP, conProp.getProperty(\"CLIENTIP\"));\r\n                            requestHeader.put(httpHeader.CONNECTION_PROP_PATH, path);\r\n                            // in case that there are no args given, args = null or empty hashmap\r\n                            Object tmp = invokeServlet(targetClass, requestHeader, args);\r\n                            if (tmp == null) {\r\n                                // if no args given, then tp will be an empty Hashtable object (not null)\r\n                                tp = new servletProperties();\r\n                            } else if (tmp instanceof servletProperties) {\r\n                                tp = (servletProperties) tmp;\r\n                            } else {\r\n                                tp = new servletProperties((serverObjects) tmp);\r\n                            }\r\n                            // check if the servlets requests authentification\r\n                            if (tp.containsKey(servletProperties.ACTION_AUTHENTICATE)) {\r\n                                // handle brute-force protection\r\n                                if (authorization != null) {\r\n                                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                                    serverLog.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                                    if (attempts == null)\r\n                                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                                    else\r\n                                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n                                }\r\n                                // send authentication request to browser\r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + tp.get(servletProperties.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                                return;\r\n                            } else if (tp.containsKey(servletProperties.ACTION_LOCATION)) {\r\n                                String location = tp.get(servletProperties.ACTION_LOCATION, \"\");\r\n                                if (location.length() == 0) location = path;\r\n                                \r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.setCookieVector(tp.getOutgoingHeader().getCookieVector()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n                                headers.put(httpHeader.LOCATION,location);\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,302,headers);\r\n                                return;\r\n                            }\r\n                            // add the application version, the uptime and the client name to every rewrite table\r\n                            tp.put(servletProperties.PEER_STAT_VERSION, switchboard.getConfig(\"version\", \"\"));\r\n                            tp.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\r\n                            tp.put(servletProperties.PEER_STAT_CLIENTNAME, switchboard.getConfig(\"peerName\", \"anomic\"));\r\n                            tp.put(servletProperties.PEER_STAT_MYTIME, serverDate.shortSecondTime());\r\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\r\n                        } catch (InvocationTargetException e) {\r\n                            if (e.getCause() instanceof InterruptedException) {\r\n                                throw new InterruptedException(e.getCause().getMessage());\r\n                            }                            \r\n                            \r\n                            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                                    e.getMessage() +\r\n                                    \" target exception at \" + targetClass + \": \" +\r\n                                    e.getTargetException().toString() + \":\" +\r\n                                    e.getTargetException().getMessage(),e);\r\n                            targetClass = null;\r\n                            throw e;\r\n                        }\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                    }\r\n                    // read templates\r\n                    tp.putAll(templates);\r\n                    \r\n                    // rewrite the file\r\n                    InputStream fis = null;\r\n                    \r\n                    // read the file/template\r\n                    byte[] templateContent = null;\r\n                    if (useTemplateCache) {\r\n                        long fileSize = targetFile.length();\r\n                        if (fileSize <= 512 * 1024) {\r\n                            // read from cache\r\n                            SoftReference ref = (SoftReference) templateCache.get(targetFile);\r\n                            if (ref != null) {\r\n                                templateContent = (byte[]) ref.get();\r\n                                if (templateContent == null) templateCache.remove(targetFile);\r\n                            }\r\n\r\n                            if (templateContent == null) {\r\n                                // loading the content of the template file into\r\n                                // a byte array\r\n                                templateContent = serverFileUtils.read(targetFile);\r\n\r\n                                // storing the content into the cache\r\n                                ref = new SoftReference(templateContent);\r\n                                templateCache.put(targetFile, ref);\r\n                                if (theLogger.isLoggable(Level.FINEST))\r\n                                    theLogger.logFinest(\"Cache MISS for file \" + targetFile);\r\n                            } else {\r\n                                if (theLogger.isLoggable(Level.FINEST))\r\n                                    theLogger.logFinest(\"Cache HIT for file \" + targetFile);\r\n                            }\r\n\r\n                            // creating an inputstream needed by the template\r\n                            // rewrite function\r\n                            fis = new ByteArrayInputStream(templateContent);\r\n                            templateContent = null;\r\n                        } else {\r\n                            // read from file directly\r\n                            fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                        }\r\n                    } else {\r\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                    }\r\n\r\n                    // write the array to the client\r\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\r\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\r\n                    boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\r\n                    boolean chunked = !method.equals(httpHeader.METHOD_HEAD) && !yacyClient && httpVersion.equals(httpHeader.HTTP_VERSION_1_1);\r\n                    if (chunked) {\r\n                        // send page in chunks and parse SSIs\r\n                        serverByteBuffer o = new serverByteBuffer();\r\n                        // apply templates\r\n                        httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        httpd.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, -1, targetDate, null, tp.getOutgoingHeader(), null, \"chunked\", nocache);\r\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\r\n                        httpChunkedOutputStream chos = new httpChunkedOutputStream(out);\r\n                        httpSSI.writeSSI(o, chos);\r\n                        //chos.write(result);\r\n                        chos.finish();\r\n                    } else {\r\n                        // send page as whole thing, SSIs are not possible\r\n                        String contentEncoding = (zipContent) ? \"gzip\" : null;\r\n                        // apply templates\r\n                        serverByteBuffer o1 = new serverByteBuffer();\r\n                        httpTemplate.writeTemplate(fis, o1, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        \r\n                        serverByteBuffer o = new serverByteBuffer();\r\n                        \r\n                        if (zipContent) {\r\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\r\n                            httpSSI.writeSSI(o1, zippedOut);\r\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                            zippedOut.finish();\r\n                            zippedOut.flush();\r\n                            zippedOut.close();\r\n                            zippedOut = null;\r\n                        } else {\r\n                            httpSSI.writeSSI(o1, o);\r\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        }\r\n                        if (method.equals(httpHeader.METHOD_HEAD)) {\r\n                            httpd.sendRespondHeader(conProp, out,\r\n                                    httpVersion, 200, null, mimeType, o.length(),\r\n                                    targetDate, null, tp.getOutgoingHeader(),\r\n                                    contentEncoding, null, nocache);\r\n                        } else {\r\n                            byte[] result = o.toByteArray(); // this interrupts streaming (bad idea!)\r\n                            httpd.sendRespondHeader(conProp, out,\r\n                                    httpVersion, 200, null, mimeType, result.length,\r\n                                    targetDate, null, tp.getOutgoingHeader(),\r\n                                    contentEncoding, null, nocache);\r\n                            serverFileUtils.write(result, out);\r\n                        }  \r\n                    }\r\n                } else { // no html\r\n                    \r\n                    int statusCode = 200;\r\n                    int rangeStartOffset = 0;\r\n                    httpHeader header = new httpHeader();\r\n                    \r\n                    // adding the accept ranges header\r\n                    header.put(httpHeader.ACCEPT_RANGES, \"bytes\");\r\n                    \r\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\r\n                    String targetMD5 = null;\r\n                    File targetMd5File = new File(targetFile + \".md5\");\r\n                    try {\r\n                        if (targetMd5File.exists()) {\r\n                            //String description = null;\r\n                            targetMD5 = new String(serverFileUtils.read(targetMd5File));\r\n                            pos = targetMD5.indexOf('\\n');\r\n                           if (pos >= 0) {\r\n                               //description = targetMD5.substring(pos + 1);\r\n                               targetMD5 = targetMD5.substring(0, pos);\r\n                           }         \r\n                           \r\n                           // using the checksum as ETAG header\r\n                           header.put(httpHeader.ETAG, targetMD5);\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }                        \r\n                    \r\n                    if (requestHeader.containsKey(httpHeader.RANGE)) {\r\n                        Object ifRange = requestHeader.ifRange();\r\n                        if ((ifRange == null)||\r\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\r\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\r\n                            String rangeHeaderVal = ((String) requestHeader.get(httpHeader.RANGE)).trim();\r\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\r\n                                String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\r\n                                String[] ranges = rangesVal.split(\",\");\r\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\r\n                                    rangeStartOffset = Integer.valueOf(ranges[0].substring(0,ranges[0].length()-1)).intValue();\r\n                                    statusCode = 206;\r\n                                    if (header == null) header = new httpHeader();\r\n                                    header.put(httpHeader.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    // write the file to the client\r\n                    targetDate = new Date(targetFile.lastModified());\r\n                    long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\r\n                    String contentEncoding  = (zipContent)?\"gzip\":null;\r\n                    String transferEncoding = (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1))?null:(zipContent)?\"chunked\":null;\r\n                    if (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\r\n                    \r\n                    httpd.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, null, header, contentEncoding, transferEncoding, nocache);\r\n                \r\n                    if (!method.equals(httpHeader.METHOD_HEAD)) {                        \r\n                        httpChunkedOutputStream chunkedOut = null;\r\n                        GZIPOutputStream zipped = null;\r\n                        OutputStream newOut = out;\r\n                        \r\n                        if (transferEncoding != null) {\r\n                            chunkedOut = new httpChunkedOutputStream(newOut);\r\n                            newOut = chunkedOut;\r\n                        }\r\n                        if (contentEncoding != null) {\r\n                            zipped = new GZIPOutputStream(newOut);\r\n                            newOut = zipped;\r\n                        }\r\n                        \r\n                        serverFileUtils.copyRange(targetFile,newOut,rangeStartOffset);\r\n                        \r\n                        if (zipped != null) {\r\n                            zipped.flush();\r\n                            zipped.finish();\r\n                        }\r\n                        if (chunkedOut != null) {\r\n                            chunkedOut.finish();\r\n                        }\r\n                    }   \r\n                    \r\n                    // check mime type again using the result array: these are 'magics'\r\n//                    if (serverByteBuffer.equals(result, 1, \"PNG\".getBytes())) mimeType = mimeTable.getProperty(\"png\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 0, \"GIF89\".getBytes())) mimeType = mimeTable.getProperty(\"gif\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 6, \"JFIF\".getBytes())) mimeType = mimeTable.getProperty(\"jpg\",\"text/html\");\r\n                    //System.out.print(\"MAGIC:\"); for (int i = 0; i < 10; i++) System.out.print(Integer.toHexString((int) result[i]) + \",\"); System.out.println();\r\n                }\r\n            } else {\r\n                httpd.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\r\n                return;\r\n            }\r\n        } catch (Exception e) {     \r\n            try {\r\n                // doing some errorhandling ...\r\n                int httpStatusCode = 400; \r\n                String httpStatusText = null; \r\n                StringBuffer errorMessage = new StringBuffer(); \r\n                Exception errorExc = null;            \r\n                \r\n                String errorMsg = e.getMessage();\r\n                if (\r\n                        (e instanceof InterruptedException) ||\r\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\r\n                   ) {\r\n                    errorMessage.append(\"Interruption detected while processing query.\");\r\n                    httpStatusCode = 503;\r\n                } else {\r\n                    if ((errorMsg != null) && \r\n                        (\r\n                           errorMsg.startsWith(\"Broken pipe\") || \r\n                           errorMsg.startsWith(\"Connection reset\") ||\r\n                           errorMsg.startsWith(\"Software caused connection abort\")                           \r\n                       )) {\r\n                        // client closed the connection, so we just end silently\r\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\r\n                    } else if ((errorMsg != null) && (errorMsg.startsWith(\"Connection timed out\"))) {\r\n                        errorMessage.append(\"Connection timed out.\");\r\n                    } else {\r\n                        errorMessage.append(\"Unexpected error while processing query.\");\r\n                        httpStatusCode = 500;\r\n                        errorExc = e;\r\n                    }\r\n                }\r\n                \r\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\r\n                            .append(\"\\nQuery:   \").append(path)\r\n                            .append(\"\\nClient:  \").append(conProp.getProperty(httpHeader.CONNECTION_PROP_CLIENTIP,\"unknown\")) \r\n                            .append(\"\\nReason:  \").append(e.toString());    \r\n                \r\n                if (!conProp.containsKey(httpHeader.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\r\n                    // sending back an error message to the client \r\n                    // if we have not already send an http header\r\n                    httpd.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, new String(errorMessage),errorExc);\r\n                } else {\r\n                    // otherwise we close the connection\r\n                    forceConnectionClose(conProp);\r\n                }    \r\n                \r\n                // if it is an unexpected error we log it \r\n                if (httpStatusCode == 500) {\r\n                    theLogger.logWarning(new String(errorMessage),e);\r\n                }\r\n                \r\n            } catch (Exception ee) {\r\n                forceConnectionClose(conProp);\r\n            }            \r\n            \r\n        } finally {\r\n            try {out.flush();}catch (Exception e) {}\r\n            if (((String)requestHeader.get(httpHeader.CONNECTION, \"close\")).indexOf(\"keep-alive\") == -1) {\r\n                // wait a little time until everything closes so that clients can read from the streams/sockets\r\n                try {Thread.sleep(200);} catch (InterruptedException e) {}\r\n            }\r\n        }\r\n    }","id":84718,"modified_method":"public static void doResponse(Properties conProp, httpHeader requestHeader, OutputStream out, InputStream body) {\r\n        \r\n        String path = null;\r\n        try {\r\n            // getting some connection properties            \r\n            String method = conProp.getProperty(httpHeader.CONNECTION_PROP_METHOD);\r\n            path = conProp.getProperty(httpHeader.CONNECTION_PROP_PATH);\r\n            String argsString = conProp.getProperty(httpHeader.CONNECTION_PROP_ARGS); // is null if no args were given\r\n            String httpVersion= conProp.getProperty(httpHeader.CONNECTION_PROP_HTTP_VER);\r\n            \r\n            // check hack attacks in path\r\n            if (path.indexOf(\"..\") >= 0) {\r\n                httpd.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\r\n                return;\r\n            }\r\n            \r\n            // url decoding of path\r\n            try {\r\n                path = URLDecoder.decode(path, \"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                // This should never occur\r\n                assert(false) : \"UnsupportedEncodingException: \" + e.getMessage();\r\n            }\r\n            \r\n            // check permission/granted access\r\n            String authorization = (String) requestHeader.get(httpHeader.AUTHORIZATION);\r\n            String adminAccountBase64MD5 = switchboard.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\");\r\n            \r\n            int pos = path.lastIndexOf(\".\");\r\n            \r\n            if ((path.substring(0,(pos==-1)?path.length():pos)).endsWith(\"_p\") && (adminAccountBase64MD5.length() != 0)) {\r\n                //authentication required\r\n                //userDB\r\n                if(sb.userDB.hasAdminRight(authorization, conProp.getProperty(\"CLIENTIP\"), requestHeader.getHeaderCookies())){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //static\r\n                }else if(authorization != null && httpd.staticAdminAuthenticated(authorization.trim().substring(6), switchboard)==4){\r\n                    //Authentication successful. remove brute-force flag\r\n                    serverCore.bfHost.remove(conProp.getProperty(\"CLIENTIP\"));\r\n                //no auth\r\n                }else if (authorization == null) {\r\n                    // no authorization given in response. Ask for that\r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    //httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    servletProperties tp=new servletProperties();\r\n                    tp.put(\"returnto\", path);\r\n                    //TODO: separate errorpage Wrong Login / No Login\r\n                    httpd.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, headers);\r\n                    return;\r\n                } else {\r\n                    // a wrong authentication was given or the userDB user does not have admin access. Ask again\r\n                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                    serverLog.logInfo(\"HTTPD\", \"Wrong log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                    if (attempts == null)\r\n                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                    else\r\n                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n    \r\n                    httpHeader headers = getDefaultHeaders(path);\r\n                    headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\r\n                    httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                    return;\r\n                }\r\n            }\r\n        \r\n        \r\n            // parse arguments\r\n            serverObjects args = new serverObjects();\r\n            int argc;\r\n            if (argsString == null) {\r\n                // no args here, maybe a POST with multipart extension\r\n                int length = 0;\r\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\r\n                if (method.equals(httpHeader.METHOD_POST)) {\r\n    \r\n                    GZIPInputStream gzipBody = null;\r\n                    if (requestHeader.containsKey(httpHeader.CONTENT_LENGTH)) {\r\n                        length = Integer.parseInt((String) requestHeader.get(httpHeader.CONTENT_LENGTH));\r\n                    } else if (requestHeader.gzip()) {\r\n                        length = -1;\r\n                        gzipBody = new GZIPInputStream(body);\r\n                    }\r\n    //                } else {\r\n    //                    httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null); \r\n    //                    return;\r\n    //                }\r\n                    \r\n                    // if its a POST, it can be either multipart or as args in the body\r\n                    if ((requestHeader.containsKey(httpHeader.CONTENT_TYPE)) &&\r\n                            (((String) requestHeader.get(httpHeader.CONTENT_TYPE)).toLowerCase().startsWith(\"multipart\"))) {\r\n                        // parse multipart\r\n                        HashMap files = httpd.parseMultipart(requestHeader, args, (gzipBody!=null)?gzipBody:body, length);\r\n                        // integrate these files into the args\r\n                        if (files != null) {\r\n                            Iterator fit = files.entrySet().iterator();\r\n                            Map.Entry entry;\r\n                            while (fit.hasNext()) {\r\n                                entry = (Map.Entry) fit.next();\r\n                                args.put(((String) entry.getKey()) + \"$file\", entry.getValue());\r\n                            }\r\n                        }\r\n                        argc = Integer.parseInt((String) requestHeader.get(\"ARGC\"));\r\n                    } else {\r\n                        // parse args in body\r\n                        argc = httpd.parseArgs(args, (gzipBody!=null)?gzipBody:body, length);\r\n                    }\r\n                } else {\r\n                    // no args\r\n                    argsString = null;\r\n                    args = null;\r\n                    argc = 0;\r\n                }\r\n            } else {\r\n                // simple args in URL (stuff after the \"?\")\r\n                argc = httpd.parseArgs(args, argsString);\r\n            }\r\n        \r\n            // check for cross site scripting - attacks in request arguments\r\n            if (argc > 0) {\r\n                // check all values for occurrences of script values\r\n                Enumeration e = args.elements(); // enumeration of values\r\n                Object val;\r\n                while (e.hasMoreElements()) {\r\n                    val = e.nextElement();\r\n                    if ((val != null) && (val instanceof String) && (((String) val).indexOf(\"<script\") >= 0)) {\r\n                        // deny request\r\n                        httpd.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        \r\n            // we are finished with parsing\r\n            // the result of value hand-over is in args and argc\r\n            if (path.length() == 0) {\r\n                httpd.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\r\n                out.flush();\r\n                return;\r\n            }\r\n            File targetClass=null;\r\n\r\n            // locate the file\r\n            if (!(path.startsWith(\"/\"))) path = \"/\" + path; // attach leading slash\r\n            \r\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\r\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\r\n            if (args != null && (args.containsKey(\"language\"))) \r\n            {\r\n                // TODO 9.11.06 Bost: a class with information about available languages is needed. \r\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\r\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\r\n                localeSelection = args.get(\"language\", localeSelection);\r\n                if (localeSelection.indexOf(\".\") != -1)\r\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf(\".\"));\r\n            }\r\n            \r\n            File   targetFile  = getLocalizedFile(path, localeSelection);\r\n            String targetExt   = conProp.getProperty(\"EXT\",\"\");\r\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\r\n            if (path.endsWith(\"/\")) {\r\n                String testpath;\r\n                // attach default file name\r\n                for (int i = 0; i < defaultFiles.length; i++) {\r\n                    testpath = path + defaultFiles[i];\r\n                    targetFile = getOverlayedFile(testpath);\r\n                    targetClass=getOverlayedClass(testpath);\r\n                    if (targetFile.exists()) {\r\n                        path = testpath;\r\n                        break;\r\n                    }\r\n                }\r\n                //no defaultfile, send a dirlisting\r\n                if(targetFile == null || !targetFile.exists()){\r\n                \tString dirlistFormat = (args==null)?\"html\":args.get(\"format\",\"html\");\r\n                \ttargetExt = dirlistFormat; // this is needed to set the mime type correctly\r\n                    targetFile = getOverlayedFile(\"/htdocsdefault/dir.\" + dirlistFormat);\r\n                    targetClass=getOverlayedClass(\"/htdocsdefault/dir.\" + dirlistFormat);\r\n                    if(! (( targetFile != null && targetFile.exists()) && ( targetClass != null && targetClass.exists())) ){\r\n                        httpd.sendRespondError(conProp, out, 3, 500, \"dir.\" + dirlistFormat + \" or dir.class not found.\", null, null);\r\n                    }\r\n                }\r\n            }else{\r\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\r\n                    if ( !(targetFile.exists()) && !((path.endsWith(\"png\")||path.endsWith(\"gif\")||path.endsWith(\".stream\"))&&targetClass!=null ) ){\r\n                        targetFile = new File(htDocsPath, path);\r\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\r\n                    }\r\n                \r\n            }\r\n            \r\n            //File targetClass = rewriteClassFile(targetFile);\r\n            //We need tp here\r\n            servletProperties tp = new servletProperties();\r\n            Date targetDate;\r\n            boolean nocache = false;\r\n            \r\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\r\n                // call an image-servlet to produce an on-the-fly - generated image\r\n                Object img = null;\r\n                try {\r\n                    requestHeader.put(httpHeader.CONNECTION_PROP_CLIENTIP, conProp.getProperty(\"CLIENTIP\"));\r\n                    requestHeader.put(httpHeader.CONNECTION_PROP_PATH, path);\r\n                    // in case that there are no args given, args = null or empty hashmap\r\n                    img = invokeServlet(targetClass, requestHeader, args);\r\n                } catch (InvocationTargetException e) {\r\n                    theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                    e.getMessage() +\r\n                    \" target exception at \" + targetClass + \": \" +\r\n                    e.getTargetException().toString() + \":\" +\r\n                    e.getTargetException().getMessage() +\r\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\",e);\r\n                    targetClass = null;\r\n                }\r\n                if (img == null) {\r\n                    // error with image generation; send file-not-found\r\n                    httpd.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\r\n                } else {\r\n                    if (img instanceof ymageMatrix) {\r\n                        ymageMatrix yp = (ymageMatrix) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        // ymagePNGEncoderJDE jde = new\r\n                        // ymagePNGEncoderJDE((ymageMatrixPainter) yp,\r\n                        // ymagePNGEncoderJDE.FILTER_NONE, 0);\r\n                        // byte[] result = jde.pngEncode();\r\n                        ImageIO.write(yp.getImage(), targetExt, baos);\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length, targetDate, null, null, null, null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            //Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                    if (img instanceof Image) {\r\n                        Image i = (Image) img;\r\n                        // send an image to client\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                        String mimeType = mimeTable.getProperty(targetExt, \"text/html\");\r\n\r\n                        // generate an byte array from the generated image\r\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\r\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\r\n                        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null); \r\n                        serverByteBuffer baos = new serverByteBuffer();\r\n                        ImageIO.write(bi, targetExt, baos);\r\n\r\n                        byte[] result = baos.toByteArray();\r\n                        baos.close();\r\n                        baos = null;\r\n\r\n                        // write the array to the client\r\n                        httpd.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length, targetDate, null, null, null, null, nocache);\r\n                        if (!method.equals(httpHeader.METHOD_HEAD)) {\r\n                            //Thread.sleep(200); // see below\r\n                            serverFileUtils.write(result, out);\r\n                        }\r\n                    }\r\n                }\r\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\r\n                // call rewrite-class\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_CLIENTIP, conProp.getProperty(\"CLIENTIP\"));\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_PATH, path);\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\r\n                requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\r\n             \r\n                httpd.sendRespondHeader(conProp, out, httpVersion, 200, null);                \r\n                \r\n                // in case that there are no args given, args = null or empty hashmap\r\n                /* servletProperties tp = (servlerObjects) */ invokeServlet(targetClass, requestHeader, args);\r\n                forceConnectionClose(conProp);\r\n                return;                \r\n            } else if ((targetFile.exists()) && (targetFile.canRead())) {\r\n                // we have found a file that can be written to the client\r\n                // if this file uses templates, then we use the template\r\n                // re-write - method to create an result\r\n                String mimeType = mimeTable.getProperty(targetExt,\"text/html\");\r\n                boolean zipContent = requestHeader.acceptGzip() && httpd.shallTransportZipped(\".\" + conProp.getProperty(\"EXT\",\"\"));\r\n                if (path.endsWith(\"html\") || \r\n                        path.endsWith(\"xml\") || \r\n                        path.endsWith(\"rss\") || \r\n                        path.endsWith(\"csv\") ||\r\n                        path.endsWith(\"pac\") ||\r\n                        path.endsWith(\"src\") ||\r\n                        path.endsWith(\"vcf\") ||\r\n                        path.endsWith(\"/\") ||\r\n                        path.equals(\"/robots.txt\")) {\r\n                            \r\n                    /*targetFile = getLocalizedFile(path);\r\n\t\t\t\t\tif (!(targetFile.exists())) {\r\n\t\t                // try to find that file in the htDocsPath\r\n\t\t\t\t        File trialFile = new File(htDocsPath, path);\r\n\t\t\t\t\t\tif (trialFile.exists()) targetFile = trialFile;\r\n\t\t            }*/\r\n            \r\n                    \r\n                    // call rewrite-class\r\n                   \r\n                    if (targetClass == null) {\r\n                        targetDate = new Date(targetFile.lastModified());\r\n                    } else {\r\n                        // CGI-class: call the class to create a property for rewriting\r\n                        try {\r\n                            requestHeader.put(httpHeader.CONNECTION_PROP_CLIENTIP, conProp.getProperty(\"CLIENTIP\"));\r\n                            requestHeader.put(httpHeader.CONNECTION_PROP_PATH, path);\r\n                            // in case that there are no args given, args = null or empty hashmap\r\n                            Object tmp = invokeServlet(targetClass, requestHeader, args);\r\n                            if (tmp == null) {\r\n                                // if no args given, then tp will be an empty Hashtable object (not null)\r\n                                tp = new servletProperties();\r\n                            } else if (tmp instanceof servletProperties) {\r\n                                tp = (servletProperties) tmp;\r\n                            } else {\r\n                                tp = new servletProperties((serverObjects) tmp);\r\n                            }\r\n                            // check if the servlets requests authentification\r\n                            if (tp.containsKey(servletProperties.ACTION_AUTHENTICATE)) {\r\n                                // handle brute-force protection\r\n                                if (authorization != null) {\r\n                                    String clientIP = conProp.getProperty(\"CLIENTIP\", \"unknown-host\");\r\n                                    serverLog.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\r\n                                    Integer attempts = (Integer) serverCore.bfHost.get(clientIP);\r\n                                    if (attempts == null)\r\n                                        serverCore.bfHost.put(clientIP, new Integer(1));\r\n                                    else\r\n                                        serverCore.bfHost.put(clientIP, new Integer(attempts.intValue() + 1));\r\n                                }\r\n                                // send authentication request to browser\r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.put(httpHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + tp.get(servletProperties.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,401,headers);\r\n                                return;\r\n                            } else if (tp.containsKey(servletProperties.ACTION_LOCATION)) {\r\n                                String location = tp.get(servletProperties.ACTION_LOCATION, \"\");\r\n                                if (location.length() == 0) location = path;\r\n                                \r\n                                httpHeader headers = getDefaultHeaders(path);\r\n                                headers.setCookieVector(tp.getOutgoingHeader().getCookieVector()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n                                headers.put(httpHeader.LOCATION,location);\r\n                                httpd.sendRespondHeader(conProp,out,httpVersion,302,headers);\r\n                                return;\r\n                            }\r\n                            // add the application version, the uptime and the client name to every rewrite table\r\n                            tp.put(servletProperties.PEER_STAT_VERSION, switchboard.getConfig(\"version\", \"\"));\r\n                            tp.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\r\n                            tp.put(servletProperties.PEER_STAT_CLIENTNAME, switchboard.getConfig(\"peerName\", \"anomic\"));\r\n                            tp.put(servletProperties.PEER_STAT_MYTIME, serverDate.shortSecondTime());\r\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\r\n                        } catch (InvocationTargetException e) {\r\n                            if (e.getCause() instanceof InterruptedException) {\r\n                                throw new InterruptedException(e.getCause().getMessage());\r\n                            }                            \r\n                            \r\n                            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\r\n                                    e.getMessage() +\r\n                                    \" target exception at \" + targetClass + \": \" +\r\n                                    e.getTargetException().toString() + \":\" +\r\n                                    e.getTargetException().getMessage(),e);\r\n                            targetClass = null;\r\n                            throw e;\r\n                        }\r\n                        targetDate = new Date(System.currentTimeMillis());\r\n                        nocache = true;\r\n                    }\r\n                    // read templates\r\n                    tp.putAll(templates);\r\n                    \r\n                    // rewrite the file\r\n                    InputStream fis = null;\r\n                    \r\n                    // read the file/template\r\n                    byte[] templateContent = null;\r\n                    if (useTemplateCache) {\r\n                        long fileSize = targetFile.length();\r\n                        if (fileSize <= 512 * 1024) {\r\n                            // read from cache\r\n                            SoftReference ref = (SoftReference) templateCache.get(targetFile);\r\n                            if (ref != null) {\r\n                                templateContent = (byte[]) ref.get();\r\n                                if (templateContent == null) templateCache.remove(targetFile);\r\n                            }\r\n\r\n                            if (templateContent == null) {\r\n                                // loading the content of the template file into\r\n                                // a byte array\r\n                                templateContent = serverFileUtils.read(targetFile);\r\n\r\n                                // storing the content into the cache\r\n                                ref = new SoftReference(templateContent);\r\n                                templateCache.put(targetFile, ref);\r\n                                if (theLogger.isLoggable(Level.FINEST))\r\n                                    theLogger.logFinest(\"Cache MISS for file \" + targetFile);\r\n                            } else {\r\n                                if (theLogger.isLoggable(Level.FINEST))\r\n                                    theLogger.logFinest(\"Cache HIT for file \" + targetFile);\r\n                            }\r\n\r\n                            // creating an inputstream needed by the template\r\n                            // rewrite function\r\n                            fis = new ByteArrayInputStream(templateContent);\r\n                            templateContent = null;\r\n                        } else {\r\n                            // read from file directly\r\n                            fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                        }\r\n                    } else {\r\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                    }\r\n\r\n                    // write the array to the client\r\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\r\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\r\n                    boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\r\n                    boolean chunked = !method.equals(httpHeader.METHOD_HEAD) && !yacyClient && httpVersion.equals(httpHeader.HTTP_VERSION_1_1);\r\n                    if (chunked) {\r\n                        // send page in chunks and parse SSIs\r\n                        serverByteBuffer o = new serverByteBuffer();\r\n                        // apply templates\r\n                        httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        httpd.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, -1, targetDate, null, tp.getOutgoingHeader(), null, \"chunked\", nocache);\r\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\r\n                        httpChunkedOutputStream chos = new httpChunkedOutputStream(out);\r\n                        httpSSI.writeSSI(o, chos);\r\n                        //chos.write(result);\r\n                        chos.finish();\r\n                    } else {\r\n                        // send page as whole thing, SSIs are not possible\r\n                        String contentEncoding = (zipContent) ? \"gzip\" : null;\r\n                        // apply templates\r\n                        serverByteBuffer o1 = new serverByteBuffer();\r\n                        httpTemplate.writeTemplate(fis, o1, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        \r\n                        serverByteBuffer o = new serverByteBuffer();\r\n                        \r\n                        if (zipContent) {\r\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\r\n                            httpSSI.writeSSI(o1, zippedOut);\r\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                            zippedOut.finish();\r\n                            zippedOut.flush();\r\n                            zippedOut.close();\r\n                            zippedOut = null;\r\n                        } else {\r\n                            httpSSI.writeSSI(o1, o);\r\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\r\n                        }\r\n                        if (method.equals(httpHeader.METHOD_HEAD)) {\r\n                            httpd.sendRespondHeader(conProp, out,\r\n                                    httpVersion, 200, null, mimeType, o.length(),\r\n                                    targetDate, null, tp.getOutgoingHeader(),\r\n                                    contentEncoding, null, nocache);\r\n                        } else {\r\n                            byte[] result = o.toByteArray(); // this interrupts streaming (bad idea!)\r\n                            httpd.sendRespondHeader(conProp, out,\r\n                                    httpVersion, 200, null, mimeType, result.length,\r\n                                    targetDate, null, tp.getOutgoingHeader(),\r\n                                    contentEncoding, null, nocache);\r\n                            serverFileUtils.write(result, out);\r\n                        }  \r\n                    }\r\n                } else { // no html\r\n                    \r\n                    int statusCode = 200;\r\n                    int rangeStartOffset = 0;\r\n                    httpHeader header = new httpHeader();\r\n                    \r\n                    // adding the accept ranges header\r\n                    header.put(httpHeader.ACCEPT_RANGES, \"bytes\");\r\n                    \r\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\r\n                    String targetMD5 = null;\r\n                    File targetMd5File = new File(targetFile + \".md5\");\r\n                    try {\r\n                        if (targetMd5File.exists()) {\r\n                            //String description = null;\r\n                            targetMD5 = new String(serverFileUtils.read(targetMd5File));\r\n                            pos = targetMD5.indexOf('\\n');\r\n                           if (pos >= 0) {\r\n                               //description = targetMD5.substring(pos + 1);\r\n                               targetMD5 = targetMD5.substring(0, pos);\r\n                           }         \r\n                           \r\n                           // using the checksum as ETAG header\r\n                           header.put(httpHeader.ETAG, targetMD5);\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }                        \r\n                    \r\n                    if (requestHeader.containsKey(httpHeader.RANGE)) {\r\n                        Object ifRange = requestHeader.ifRange();\r\n                        if ((ifRange == null)||\r\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\r\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\r\n                            String rangeHeaderVal = ((String) requestHeader.get(httpHeader.RANGE)).trim();\r\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\r\n                                String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\r\n                                String[] ranges = rangesVal.split(\",\");\r\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\r\n                                    rangeStartOffset = Integer.valueOf(ranges[0].substring(0,ranges[0].length()-1)).intValue();\r\n                                    statusCode = 206;\r\n                                    if (header == null) header = new httpHeader();\r\n                                    header.put(httpHeader.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    // write the file to the client\r\n                    targetDate = new Date(targetFile.lastModified());\r\n                    long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\r\n                    String contentEncoding  = (zipContent)?\"gzip\":null;\r\n                    String transferEncoding = (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1))?null:(zipContent)?\"chunked\":null;\r\n                    if (!httpVersion.equals(httpHeader.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\r\n                    \r\n                    httpd.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, null, header, contentEncoding, transferEncoding, nocache);\r\n                \r\n                    if (!method.equals(httpHeader.METHOD_HEAD)) {                        \r\n                        httpChunkedOutputStream chunkedOut = null;\r\n                        GZIPOutputStream zipped = null;\r\n                        OutputStream newOut = out;\r\n                        \r\n                        if (transferEncoding != null) {\r\n                            chunkedOut = new httpChunkedOutputStream(newOut);\r\n                            newOut = chunkedOut;\r\n                        }\r\n                        if (contentEncoding != null) {\r\n                            zipped = new GZIPOutputStream(newOut);\r\n                            newOut = zipped;\r\n                        }\r\n                        \r\n                        serverFileUtils.copyRange(targetFile,newOut,rangeStartOffset);\r\n                        \r\n                        if (zipped != null) {\r\n                            zipped.flush();\r\n                            zipped.finish();\r\n                        }\r\n                        if (chunkedOut != null) {\r\n                            chunkedOut.finish();\r\n                        }\r\n                    }   \r\n                    \r\n                    // check mime type again using the result array: these are 'magics'\r\n//                    if (serverByteBuffer.equals(result, 1, \"PNG\".getBytes())) mimeType = mimeTable.getProperty(\"png\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 0, \"GIF89\".getBytes())) mimeType = mimeTable.getProperty(\"gif\",\"text/html\");\r\n//                    else if (serverByteBuffer.equals(result, 6, \"JFIF\".getBytes())) mimeType = mimeTable.getProperty(\"jpg\",\"text/html\");\r\n                    //System.out.print(\"MAGIC:\"); for (int i = 0; i < 10; i++) System.out.print(Integer.toHexString((int) result[i]) + \",\"); System.out.println();\r\n                }\r\n            } else {\r\n                httpd.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\r\n                return;\r\n            }\r\n        } catch (Exception e) {     \r\n            try {\r\n                // doing some errorhandling ...\r\n                int httpStatusCode = 400; \r\n                String httpStatusText = null; \r\n                StringBuffer errorMessage = new StringBuffer(); \r\n                Exception errorExc = null;            \r\n                \r\n                String errorMsg = e.getMessage();\r\n                if (\r\n                        (e instanceof InterruptedException) ||\r\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\r\n                   ) {\r\n                    errorMessage.append(\"Interruption detected while processing query.\");\r\n                    httpStatusCode = 503;\r\n                } else {\r\n                    if ((errorMsg != null) && \r\n                        (\r\n                           errorMsg.startsWith(\"Broken pipe\") || \r\n                           errorMsg.startsWith(\"Connection reset\") ||\r\n                           errorMsg.startsWith(\"Software caused connection abort\")                           \r\n                       )) {\r\n                        // client closed the connection, so we just end silently\r\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\r\n                    } else if ((errorMsg != null) && (errorMsg.startsWith(\"Connection timed out\"))) {\r\n                        errorMessage.append(\"Connection timed out.\");\r\n                    } else {\r\n                        errorMessage.append(\"Unexpected error while processing query.\");\r\n                        httpStatusCode = 500;\r\n                        errorExc = e;\r\n                    }\r\n                }\r\n                \r\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\r\n                            .append(\"\\nQuery:   \").append(path)\r\n                            .append(\"\\nClient:  \").append(conProp.getProperty(httpHeader.CONNECTION_PROP_CLIENTIP,\"unknown\")) \r\n                            .append(\"\\nReason:  \").append(e.toString());    \r\n                \r\n                if (!conProp.containsKey(httpHeader.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\r\n                    // sending back an error message to the client \r\n                    // if we have not already send an http header\r\n                    httpd.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, new String(errorMessage),errorExc);\r\n                } else {\r\n                    // otherwise we close the connection\r\n                    forceConnectionClose(conProp);\r\n                }    \r\n                \r\n                // if it is an unexpected error we log it \r\n                if (httpStatusCode == 500) {\r\n                    theLogger.logWarning(new String(errorMessage),e);\r\n                }\r\n                \r\n            } catch (Exception ee) {\r\n                forceConnectionClose(conProp);\r\n            }            \r\n            \r\n        } finally {\r\n            try {out.flush();}catch (Exception e) {}\r\n            if (((String)requestHeader.get(httpHeader.CONNECTION, \"close\")).indexOf(\"keep-alive\") == -1) {\r\n                // wait a little time until everything closes so that clients can read from the streams/sockets\r\n                //try {Thread.sleep(200);} catch (InterruptedException e) {} // FIXME: is this necessary?\r\n            }\r\n        }\r\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public indexContainer search() {\r\n        // combine the local and global (if any) result and order\r\n        if ((rcGlobal != null) && (rcGlobal.size() > 0)) {\r\n            globalcount = rcGlobal.size();\r\n            if ((this.sortedResults == null) || (this.lastglobal != globalcount)) {\r\n                indexContainer searchResult = plasmaWordIndex.emptyContainer(null, rcLocal.size() + rcGlobal.size());\r\n                searchResult.addAllUnique(rcLocal);\r\n                searchResult.addAllUnique(rcGlobal);\r\n                searchResult.sort();\r\n                searchResult.uniq(100);\r\n                lastglobal = globalcount;\r\n                plasmaSearchPreOrder pre = new plasmaSearchPreOrder(query, profileLocal, ranking, searchResult);\r\n                this.filteredCount = pre.filteredCount();\r\n                this.sortedResults = pre.strippedContainer(200);\r\n            }\r\n        } else {\r\n            if (this.sortedResults == null) {\r\n                plasmaSearchPreOrder pre = new plasmaSearchPreOrder(query, profileLocal, ranking, rcLocal);\r\n                this.filteredCount = pre.filteredCount();\r\n                this.sortedResults = pre.strippedContainer(200);\r\n            }\r\n        }\r\n        \r\n        return this.sortedResults;\r\n    }","id":84719,"modified_method":"private indexContainer search() {\r\n        // combine the local and global (if any) result and order\r\n        if ((rcGlobal != null) && (rcGlobal.size() > 0)) {\r\n            globalcount = rcGlobal.size();\r\n            if ((this.sortedResults == null) || (this.lastglobal != globalcount)) {\r\n                indexContainer searchResult = plasmaWordIndex.emptyContainer(null, rcLocal.size() + rcGlobal.size());\r\n                searchResult.addAllUnique(rcLocal);\r\n                searchResult.addAllUnique(rcGlobal);\r\n                searchResult.sort();\r\n                searchResult.uniq(100);\r\n                lastglobal = globalcount;\r\n                plasmaSearchPreOrder pre = new plasmaSearchPreOrder(query, profileLocal, ranking, searchResult);\r\n                this.filteredCount = pre.filteredCount();\r\n                this.sortedResults = pre.strippedContainer(200);\r\n            }\r\n        } else {\r\n            if (this.sortedResults == null) {\r\n                plasmaSearchPreOrder pre = new plasmaSearchPreOrder(query, profileLocal, ranking, rcLocal);\r\n                this.filteredCount = pre.filteredCount();\r\n                this.sortedResults = pre.strippedContainer(200);\r\n            }\r\n        }\r\n        \r\n        return this.sortedResults;\r\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static plasmaSearchEvent getEvent(plasmaSearchQuery query,\r\n            plasmaSearchRankingProfile ranking,\r\n            plasmaSearchProcessing localTiming,\r\n            plasmaSearchProcessing remoteTiming,\r\n            plasmaWordIndex wordIndex,\r\n            TreeMap preselectedPeerHashes) {\r\n        plasmaSearchEvent event = (plasmaSearchEvent) lastEvents.get(query.id());\r\n        if (event == null) {\r\n            event = new plasmaSearchEvent(query, ranking, localTiming, remoteTiming, wordIndex, preselectedPeerHashes);\r\n        } else {\r\n            //re-new the event time for this event, so it is not deleted next time too early\r\n            event.eventTime = System.currentTimeMillis();\r\n        }\r\n        return event;\r\n    }","id":84720,"modified_method":"public static plasmaSearchEvent getEvent(plasmaSearchQuery query,\r\n            plasmaSearchRankingProfile ranking,\r\n            plasmaSearchProcessing localTiming,\r\n            plasmaSearchProcessing remoteTiming,\r\n            plasmaWordIndex wordIndex,\r\n            TreeMap preselectedPeerHashes,\r\n            boolean generateAbstracts,\r\n            TreeSet abstractSet) {\r\n        plasmaSearchEvent event = (plasmaSearchEvent) lastEvents.get(query.id());\r\n        if (event == null) {\r\n            event = new plasmaSearchEvent(query, ranking, localTiming, remoteTiming, wordIndex, preselectedPeerHashes, generateAbstracts, abstractSet);\r\n        } else {\r\n            //re-new the event time for this event, so it is not deleted next time too early\r\n            event.eventTime = System.currentTimeMillis();\r\n        }\r\n        return event;\r\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private plasmaSearchEvent(plasmaSearchQuery query,\r\n                             plasmaSearchRankingProfile ranking,\r\n                             plasmaSearchProcessing localTiming,\r\n                             plasmaSearchProcessing remoteTiming,\r\n                             plasmaWordIndex wordIndex,\r\n                             TreeMap preselectedPeerHashes) {\r\n        this.eventTime = System.currentTimeMillis(); // for lifetime check\r\n        this.wordIndex = wordIndex;\r\n        this.query = query;\r\n        this.ranking = ranking;\r\n        this.rcLocal = null;\r\n        this.rcGlobal = plasmaWordIndex.emptyContainer(null, 0);;\r\n        this.rcAbstracts = (query.queryHashes.size() > 1) ? new TreeMap() : null; // generate abstracts only for combined searches\r\n        this.profileLocal = localTiming;\r\n        this.profileGlobal = remoteTiming;\r\n        this.primarySearchThreads = null;\r\n        this.secondarySearchThreads = null;\r\n        this.preselectedPeerHashes = preselectedPeerHashes;\r\n        this.localcount = 0;\r\n        this.globalcount = 0;\r\n        this.sortedResults = null;\r\n        this.lastglobal = 0;\r\n        this.display = new ArrayList();\r\n        \r\n        long start = System.currentTimeMillis();\r\n        if ((query.domType == plasmaSearchQuery.SEARCHDOM_GLOBALDHT) ||\r\n            (query.domType == plasmaSearchQuery.SEARCHDOM_CLUSTERALL)) {\r\n            int fetchpeers = (int) (query.maximumTime / 500L); // number of target peers; means 10 peers in 10 seconds\r\n            if (fetchpeers > 50) fetchpeers = 50;\r\n            if (fetchpeers < 30) fetchpeers = 30;\r\n\r\n            // do a global search\r\n            // the result of the fetch is then in the rcGlobal\r\n            serverLog.logFine(\"SEARCH_EVENT\", \"STARTING \" + fetchpeers + \" THREADS TO CATCH EACH \" + profileGlobal.getTargetCount(plasmaSearchProcessing.PROCESS_POSTSORT) + \" URLs WITHIN \" + (profileGlobal.duetime() / 1000) + \" SECONDS\");\r\n            long secondaryTimeout = System.currentTimeMillis() + profileGlobal.duetime() / 3 * 2;\r\n            long primaryTimeout = System.currentTimeMillis() + profileGlobal.duetime();\r\n            primarySearchThreads = yacySearch.primaryRemoteSearches(\r\n                    plasmaSearchQuery.hashSet2hashString(query.queryHashes),\r\n                    plasmaSearchQuery.hashSet2hashString(query.excludeHashes),\r\n                    \"\",\r\n                    query.prefer,\r\n                    query.urlMask,\r\n                    query.maxDistance,\r\n                    wordIndex,\r\n                    rcGlobal, \r\n                    rcAbstracts,\r\n                    fetchpeers,\r\n                    plasmaSwitchboard.urlBlacklist,\r\n                    profileGlobal,\r\n                    ranking,\r\n                    query.constraint,\r\n                    (query.domType == plasmaSearchQuery.SEARCHDOM_GLOBALDHT) ? null : preselectedPeerHashes);\r\n\r\n            // meanwhile do a local search\r\n            Map[] searchContainerMaps = profileLocal.localSearchContainers(query, wordIndex, null);\r\n            \r\n            // use the search containers to fill up rcAbstracts locally\r\n            /*\r\n            if ((rcAbstracts != null) && (searchContainerMap != null)) {\r\n                Iterator i, ci = searchContainerMap.entrySet().iterator();\r\n                Map.Entry entry;\r\n                String wordhash;\r\n                indexContainer container;\r\n                TreeMap singleAbstract;\r\n                String mypeerhash = yacyCore.seedDB.mySeed.hash;\r\n                while (ci.hasNext()) {\r\n                    entry = (Map.Entry) ci.next();\r\n                    wordhash = (String) entry.getKey();\r\n                    container = (indexContainer) entry.getValue();\r\n                    // collect all urlhashes from the container\r\n                    synchronized (rcAbstracts) {\r\n                        singleAbstract = (TreeMap) rcAbstracts.get(wordhash); // a mapping from url-hashes to a string of peer-hashes\r\n                        if (singleAbstract == null) singleAbstract = new TreeMap();\r\n                        i = container.entries();\r\n                        while (i.hasNext()) singleAbstract.put(((indexEntry) i.next()).urlHash(), mypeerhash);\r\n                        rcAbstracts.put(wordhash, singleAbstract);\r\n                    }\r\n                }\r\n            }\r\n            */\r\n\r\n            // join and exlcude the local result\r\n            this.rcLocal =\r\n                (searchContainerMaps == null) ?\r\n                  plasmaWordIndex.emptyContainer(null, 0) :\r\n                      profileLocal.localSearchJoinExclude(\r\n                          searchContainerMaps[0].values(),\r\n                          searchContainerMaps[1].values(),\r\n                          (query.queryHashes.size() == 0) ?\r\n                            0 :\r\n                            profileLocal.getTargetTime(plasmaSearchProcessing.PROCESS_JOIN) * query.queryHashes.size() / (query.queryHashes.size() + query.excludeHashes.size()),\r\n                          query.maxDistance);\r\n\r\n            // sort the local containers and truncate it to a limited count,\r\n            // so following sortings together with the global results will be fast\r\n            plasmaSearchPreOrder firstsort = new plasmaSearchPreOrder(query, profileLocal, ranking, rcLocal);\r\n            rcLocal = firstsort.strippedContainer(200);\r\n            \r\n            int prefetchIndex = 0;\r\n            HashSet unknownURLs = new HashSet();\r\n            String urlhash;\r\n            \r\n            // while we wait for the first time-out for index abstracts, we fetch urls form the url-db\r\n            while ((System.currentTimeMillis() < secondaryTimeout) && (prefetchIndex < rcLocal.size())) {\r\n                if (yacySearch.remainingWaiting(primarySearchThreads) == 0) break; // all threads have finished\r\n                urlhash = new String(rcLocal.get(prefetchIndex).getColBytes(0));\r\n                if (wordIndex.loadedURL.load(urlhash, null) == null) unknownURLs.add(urlhash);\r\n                prefetchIndex++;\r\n            }\r\n            \r\n            // eventually wait some more time to retrieve index abstracts from primary search\r\n            while (System.currentTimeMillis() < secondaryTimeout) {\r\n                if (yacySearch.remainingWaiting(primarySearchThreads) == 0) break; // all threads have finished\r\n                try {Thread.sleep(100);} catch (InterruptedException e) {}\r\n            }\r\n            \r\n            // evaluate index abstracts and start a secondary search\r\n            if (rcAbstracts != null) prepareSecondarySearch();\r\n            \r\n            // while we wait for the second time-out for index abstracts, we fetch more urls form the url-db\r\n            while ((System.currentTimeMillis() < primaryTimeout) && (prefetchIndex < rcLocal.size())) {\r\n                if (yacySearch.remainingWaiting(primarySearchThreads) == 0) break; // all threads have finished\r\n                urlhash = new String(rcLocal.get(prefetchIndex).getColBytes(0));\r\n                if (wordIndex.loadedURL.load(urlhash, null) == null) unknownURLs.add(urlhash);\r\n                prefetchIndex++;\r\n            }\r\n            \r\n            // when we have found some non-existing urls in the local collection, we delete them now\r\n            wordIndex.removeEntriesMultiple(query.queryHashes, unknownURLs);\r\n            rcLocal.removeEntriesMultiple(query.queryHashes, unknownURLs);\r\n            localcount = rcLocal.size();\r\n            \r\n            // catch up global results:\r\n            // wait until primary timeout passed\r\n            while (System.currentTimeMillis() < primaryTimeout) {\r\n                if ((yacySearch.remainingWaiting(primarySearchThreads) == 0) &&\r\n                    ((secondarySearchThreads == null) || (yacySearch.remainingWaiting(secondarySearchThreads) == 0))) break; // all threads have finished\r\n                try {Thread.sleep(100);} catch (InterruptedException e) {}\r\n            }\r\n            \r\n            // finished searching\r\n            serverLog.logFine(\"SEARCH_EVENT\", \"SEARCH TIME AFTER GLOBAL-TRIGGER TO \" + primarySearchThreads.length + \" PEERS: \" + ((System.currentTimeMillis() - start) / 1000) + \" seconds\");\r\n        } else {\r\n            Map[] searchContainerMaps = profileLocal.localSearchContainers(query, wordIndex, null);\r\n            \r\n            rcLocal =\r\n                (searchContainerMaps == null) ?\r\n                  plasmaWordIndex.emptyContainer(null, 0) :\r\n                      profileLocal.localSearchJoinExclude(\r\n                          searchContainerMaps[0].values(),\r\n                          searchContainerMaps[1].values(),\r\n                          (query.queryHashes.size() == 0) ?\r\n                            0 :\r\n                            profileLocal.getTargetTime(plasmaSearchProcessing.PROCESS_JOIN) * query.queryHashes.size() / (query.queryHashes.size() + query.excludeHashes.size()),\r\n                          query.maxDistance);\r\n            this.localcount = rcLocal.size();\r\n        }\r\n\r\n        // log the event\r\n        serverLog.logFine(\"SEARCH_EVENT\", \"SEARCHRESULT: \" + profileLocal.reportToString());\r\n        \r\n        // set link for statistic\r\n        //lastEvent = this;\r\n        \r\n        // remove old events in the event cache\r\n        Iterator i = lastEvents.entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            if (((plasmaSearchEvent) ((Map.Entry) i.next()).getValue()).eventTime + eventLifetime < System.currentTimeMillis()) i.remove();\r\n        }\r\n        \r\n        // store this search to a cache so it can be re-used\r\n        lastEvents.put(query.id(), this);\r\n        lastEventID = query.id();\r\n    }","id":84721,"modified_method":"private plasmaSearchEvent(plasmaSearchQuery query,\r\n                             plasmaSearchRankingProfile ranking,\r\n                             plasmaSearchProcessing localTiming,\r\n                             plasmaSearchProcessing remoteTiming,\r\n                             plasmaWordIndex wordIndex,\r\n                             TreeMap preselectedPeerHashes,\r\n                             boolean generateAbstracts,\r\n                             TreeSet abstractSet) {\r\n        this.eventTime = System.currentTimeMillis(); // for lifetime check\r\n        this.wordIndex = wordIndex;\r\n        this.query = query;\r\n        this.ranking = ranking;\r\n        this.rcLocal = null;\r\n        this.rcGlobal = plasmaWordIndex.emptyContainer(null, 0);;\r\n        this.rcAbstracts = (query.queryHashes.size() > 1) ? new TreeMap() : null; // generate abstracts only for combined searches\r\n        this.profileLocal = localTiming;\r\n        this.profileGlobal = remoteTiming;\r\n        this.primarySearchThreads = null;\r\n        this.secondarySearchThreads = null;\r\n        this.preselectedPeerHashes = preselectedPeerHashes;\r\n        this.localcount = 0;\r\n        this.globalcount = 0;\r\n        this.sortedResults = null;\r\n        this.lastglobal = 0;\r\n        this.display = new ArrayList();\r\n        this.references = new String[0];\r\n        this.IAResults = new TreeMap();\r\n        this.IACount = new TreeMap();\r\n        this.IAmaxcounthash = null;\r\n        this.IAneardhthash = null;\r\n        \r\n        long start = System.currentTimeMillis();\r\n        if ((query.domType == plasmaSearchQuery.SEARCHDOM_GLOBALDHT) ||\r\n            (query.domType == plasmaSearchQuery.SEARCHDOM_CLUSTERALL)) {\r\n            int fetchpeers = (int) (query.maximumTime / 500L); // number of target peers; means 10 peers in 10 seconds\r\n            if (fetchpeers > 50) fetchpeers = 50;\r\n            if (fetchpeers < 30) fetchpeers = 30;\r\n\r\n            // do a global search\r\n            // the result of the fetch is then in the rcGlobal\r\n            serverLog.logFine(\"SEARCH_EVENT\", \"STARTING \" + fetchpeers + \" THREADS TO CATCH EACH \" + profileGlobal.getTargetCount(plasmaSearchProcessing.PROCESS_POSTSORT) + \" URLs WITHIN \" + (profileGlobal.duetime() / 1000) + \" SECONDS\");\r\n            long secondaryTimeout = System.currentTimeMillis() + profileGlobal.duetime() / 3 * 2;\r\n            long primaryTimeout = System.currentTimeMillis() + profileGlobal.duetime();\r\n            primarySearchThreads = yacySearch.primaryRemoteSearches(\r\n                    plasmaSearchQuery.hashSet2hashString(query.queryHashes),\r\n                    plasmaSearchQuery.hashSet2hashString(query.excludeHashes),\r\n                    \"\",\r\n                    query.prefer,\r\n                    query.urlMask,\r\n                    query.maxDistance,\r\n                    wordIndex,\r\n                    rcGlobal, \r\n                    rcAbstracts,\r\n                    fetchpeers,\r\n                    plasmaSwitchboard.urlBlacklist,\r\n                    profileGlobal,\r\n                    ranking,\r\n                    query.constraint,\r\n                    (query.domType == plasmaSearchQuery.SEARCHDOM_GLOBALDHT) ? null : preselectedPeerHashes);\r\n\r\n            // meanwhile do a local search\r\n            Map[] searchContainerMaps = profileLocal.localSearchContainers(query, wordIndex, null);\r\n            \r\n            // use the search containers to fill up rcAbstracts locally\r\n            /*\r\n            if ((rcAbstracts != null) && (searchContainerMap != null)) {\r\n                Iterator i, ci = searchContainerMap.entrySet().iterator();\r\n                Map.Entry entry;\r\n                String wordhash;\r\n                indexContainer container;\r\n                TreeMap singleAbstract;\r\n                String mypeerhash = yacyCore.seedDB.mySeed.hash;\r\n                while (ci.hasNext()) {\r\n                    entry = (Map.Entry) ci.next();\r\n                    wordhash = (String) entry.getKey();\r\n                    container = (indexContainer) entry.getValue();\r\n                    // collect all urlhashes from the container\r\n                    synchronized (rcAbstracts) {\r\n                        singleAbstract = (TreeMap) rcAbstracts.get(wordhash); // a mapping from url-hashes to a string of peer-hashes\r\n                        if (singleAbstract == null) singleAbstract = new TreeMap();\r\n                        i = container.entries();\r\n                        while (i.hasNext()) singleAbstract.put(((indexEntry) i.next()).urlHash(), mypeerhash);\r\n                        rcAbstracts.put(wordhash, singleAbstract);\r\n                    }\r\n                }\r\n            }\r\n            */\r\n\r\n            // join and exlcude the local result\r\n            this.rcLocal =\r\n                (searchContainerMaps == null) ?\r\n                  plasmaWordIndex.emptyContainer(null, 0) :\r\n                      profileLocal.localSearchJoinExclude(\r\n                          searchContainerMaps[0].values(),\r\n                          searchContainerMaps[1].values(),\r\n                          (query.queryHashes.size() == 0) ?\r\n                            0 :\r\n                            profileLocal.getTargetTime(plasmaSearchProcessing.PROCESS_JOIN) * query.queryHashes.size() / (query.queryHashes.size() + query.excludeHashes.size()),\r\n                          query.maxDistance);\r\n\r\n            // sort the local containers and truncate it to a limited count,\r\n            // so following sortings together with the global results will be fast\r\n            plasmaSearchPreOrder firstsort = new plasmaSearchPreOrder(query, profileLocal, ranking, rcLocal);\r\n            rcLocal = firstsort.strippedContainer(200);\r\n            \r\n            int prefetchIndex = 0;\r\n            HashSet unknownURLs = new HashSet();\r\n            String urlhash;\r\n            \r\n            // while we wait for the first time-out for index abstracts, we fetch urls form the url-db\r\n            while ((System.currentTimeMillis() < secondaryTimeout) && (prefetchIndex < rcLocal.size())) {\r\n                if (yacySearch.remainingWaiting(primarySearchThreads) == 0) break; // all threads have finished\r\n                urlhash = new String(rcLocal.get(prefetchIndex).getColBytes(0));\r\n                if (wordIndex.loadedURL.load(urlhash, null) == null) unknownURLs.add(urlhash);\r\n                prefetchIndex++;\r\n            }\r\n            \r\n            // eventually wait some more time to retrieve index abstracts from primary search\r\n            while (System.currentTimeMillis() < secondaryTimeout) {\r\n                if (yacySearch.remainingWaiting(primarySearchThreads) == 0) break; // all threads have finished\r\n                try {Thread.sleep(100);} catch (InterruptedException e) {}\r\n            }\r\n            \r\n            // evaluate index abstracts and start a secondary search\r\n            if (rcAbstracts != null) prepareSecondarySearch();\r\n            \r\n            // while we wait for the second time-out for index abstracts, we fetch more urls form the url-db\r\n            while ((System.currentTimeMillis() < primaryTimeout) && (prefetchIndex < rcLocal.size())) {\r\n                if (yacySearch.remainingWaiting(primarySearchThreads) == 0) break; // all threads have finished\r\n                urlhash = new String(rcLocal.get(prefetchIndex).getColBytes(0));\r\n                if (wordIndex.loadedURL.load(urlhash, null) == null) unknownURLs.add(urlhash);\r\n                prefetchIndex++;\r\n            }\r\n            \r\n            // when we have found some non-existing urls in the local collection, we delete them now\r\n            wordIndex.removeEntriesMultiple(query.queryHashes, unknownURLs);\r\n            rcLocal.removeEntriesMultiple(query.queryHashes, unknownURLs);\r\n            localcount = rcLocal.size();\r\n            \r\n            // catch up global results:\r\n            // wait until primary timeout passed\r\n            while (System.currentTimeMillis() < primaryTimeout) {\r\n                if ((yacySearch.remainingWaiting(primarySearchThreads) == 0) &&\r\n                    ((secondarySearchThreads == null) || (yacySearch.remainingWaiting(secondarySearchThreads) == 0))) break; // all threads have finished\r\n                try {Thread.sleep(100);} catch (InterruptedException e) {}\r\n            }\r\n            \r\n            // finished searching\r\n            serverLog.logFine(\"SEARCH_EVENT\", \"SEARCH TIME AFTER GLOBAL-TRIGGER TO \" + primarySearchThreads.length + \" PEERS: \" + ((System.currentTimeMillis() - start) / 1000) + \" seconds\");\r\n        } else {\r\n            Map[] searchContainerMaps = profileLocal.localSearchContainers(query, wordIndex, null);\r\n            \r\n            if (generateAbstracts) {\r\n                // compute index abstracts\r\n                Iterator ci = searchContainerMaps[0].entrySet().iterator();\r\n                Map.Entry entry;\r\n                int maxcount = -1;\r\n                double mindhtdistance = 1.1, d;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = (Map.Entry) ci.next();\r\n                    wordhash = (String) entry.getKey();\r\n                    indexContainer container = (indexContainer) entry.getValue();\r\n                    assert (container.getWordHash().equals(wordhash));\r\n                    if (container.size() > maxcount) {\r\n                        IAmaxcounthash = wordhash;\r\n                        maxcount = container.size();\r\n                    }\r\n                    d = yacyDHTAction.dhtDistance(yacyCore.seedDB.mySeed.hash, wordhash);\r\n                    if (d < mindhtdistance) {\r\n                        // calculate the word hash that is closest to our dht position\r\n                        mindhtdistance = d;\r\n                        IAneardhthash = wordhash;\r\n                    }\r\n                    IACount.put(wordhash, new Integer(container.size()));\r\n                    IAResults.put(wordhash, plasmaURL.compressIndex(container, null, 1000).toString());\r\n                }\r\n            }\r\n            \r\n            rcLocal =\r\n                (searchContainerMaps == null) ?\r\n                  plasmaWordIndex.emptyContainer(null, 0) :\r\n                      profileLocal.localSearchJoinExclude(\r\n                          searchContainerMaps[0].values(),\r\n                          searchContainerMaps[1].values(),\r\n                          (query.queryHashes.size() == 0) ?\r\n                            0 :\r\n                            profileLocal.getTargetTime(plasmaSearchProcessing.PROCESS_JOIN) * query.queryHashes.size() / (query.queryHashes.size() + query.excludeHashes.size()),\r\n                          query.maxDistance);\r\n            this.localcount = rcLocal.size();\r\n        }\r\n\r\n        // log the event\r\n        serverLog.logFine(\"SEARCH_EVENT\", \"SEARCHRESULT: \" + profileLocal.reportToString());\r\n        \r\n        // set link for statistic\r\n        //lastEvent = this;\r\n        \r\n        // remove old events in the event cache\r\n        Iterator i = lastEvents.entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            if (((plasmaSearchEvent) ((Map.Entry) i.next()).getValue()).eventTime + eventLifetime < System.currentTimeMillis()) i.remove();\r\n        }\r\n        \r\n        // store this search to a cache so it can be re-used\r\n        lastEvents.put(query.id(), this);\r\n        lastEventID = query.id();\r\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        \r\n        //System.out.println(\"yacy: search received request = \" + post.toString());\r\n\r\n        final String  oseed  = post.get(\"myseed\", \"\"); // complete seed of the requesting peer\r\n//      final String  youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n        final String  key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String  query  = post.get(\"query\", \"\");  // a string of word hashes that shall be searched and combined\r\n        final String  exclude= post.get(\"exclude\", \"\");// a string of word hashes that shall not be within the search result\r\n        String  urls   = post.get(\"urls\", \"\");         // a string of url hashes that are preselected for the search: no other may be returned\r\n        String abstracts = post.get(\"abstracts\", \"\");  // a string of word hashes for abstracts that shall be generated, or 'auto' (for maxcount-word), or '' (for none)\r\n//      final String  fwdep  = post.get(\"fwdep\", \"\");  // forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n//      final String  fwden  = post.get(\"fwden\", \"\");  // forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        final long    duetime= Math.min(60000, post.getLong(\"duetime\", 3000));\r\n        final int     count  = Math.min(100, post.getInt(\"count\", 10)); // maximum number of wanted results\r\n        final int     maxdist= post.getInt(\"maxdist\", Integer.MAX_VALUE);\r\n        final String  prefer = post.get(\"prefer\", \"\");\r\n        final String  contentdom = post.get(\"contentdom\", \"text\");\r\n        final String  filter = post.get(\"filter\", \".*\");\r\n        final int     partitions = post.getInt(\"partitions\", 30);\r\n        String  profile = post.get(\"profile\", \"\"); // remote profile hand-over\r\n        if (profile.length() > 0) profile = crypt.simpleDecode(profile, null);\r\n        //final boolean includesnippet = post.get(\"includesnippet\", \"false\").equals(\"true\");\r\n        final kelondroBitfield constraint = new kelondroBitfield(4, post.get(\"constraint\", \"______\"));\r\n//      final boolean global = ((String) post.get(\"resource\", \"global\")).equals(\"global\"); // if true, then result may consist of answers from other peers\r\n//      Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME));        // read remote time\r\n\r\n        // test:\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Q (search for linux)\r\n        // http://localhost:8080/yacy/search.html?query=gh8DKIhGKXws (search for book)\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Qgh8DKIhGKXws&abstracts=auto (search for linux and book, generate abstract automatically)\r\n        // http://localhost:8080/yacy/search.html?query=&abstracts=4galTpdpDM5Q (only abstracts for linux)\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n             \t (!((sb.isPublicRobinson()) ||\r\n             \t    (sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))))) {\r\n                 // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.putASIS(\"links\", \"\");\r\n            prop.putASIS(\"linkcount\", \"0\");\r\n            prop.putASIS(\"references\", \"\");\r\n        \treturn prop;\r\n        }\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(2 * duetime);\r\n\r\n        TreeSet abstractSet = ((abstracts.length() == 0) || (abstracts.equals(\"auto\"))) ? null : plasmaSearchQuery.hashes2Set(abstracts);\r\n        \r\n        // store accessing peer\r\n        if (yacyCore.seedDB == null) {\r\n            yacyCore.log.logSevere(\"yacy.search: seed cache not initialized\");\r\n        } else {\r\n            yacyCore.peerActions.peerArrival(yacySeed.genRemoteSeed(oseed, key, true), true);\r\n        }\r\n\r\n        // prepare search\r\n        final TreeSet queryhashes = plasmaSearchQuery.hashes2Set(query);\r\n        final TreeSet excludehashes = (exclude.length() == 0) ? new TreeSet(kelondroBase64Order.enhancedCoder) : plasmaSearchQuery.hashes2Set(exclude);\r\n        final long timestamp = System.currentTimeMillis();\r\n        \r\n        // prepare an abstract result\r\n        StringBuffer indexabstract = new StringBuffer();\r\n        int indexabstractContainercount = 0;\r\n        int joincount = 0;\r\n        plasmaSearchQuery squery = null;\r\n        //plasmaSearchEvent theSearch = null;\r\n        plasmaSearchResultAccumulator accu = null;\r\n        if ((query.length() == 0) && (abstractSet != null)) {\r\n            // this is _not_ a normal search, only a request for index abstracts\r\n            squery = new plasmaSearchQuery(abstractSet, new TreeSet(kelondroBase64Order.enhancedCoder), maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), count, duetime, filter, plasmaSearchQuery.catchall_constraint);\r\n            squery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (abstracts only): \" + plasmaSearchQuery.anonymizedQueryHashes(squery.queryHashes) + \" - \" + squery.wantedResults + \" links\");\r\n\r\n            // prepare a search profile\r\n            //plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(contentdom) : new plasmaSearchRankingProfile(\"\", profile);\r\n            plasmaSearchProcessing localTiming  = new plasmaSearchProcessing(squery.maximumTime, squery.wantedResults);\r\n            //plasmaSearchProcessing remoteTiming = null;\r\n\r\n            //theSearch = new plasmaSearchEvent(squery, rankingProfile, localTiming, remoteTiming, true, sb.wordIndex, null);\r\n            Map[] containers = localTiming.localSearchContainers(squery, sb.wordIndex, plasmaSearchQuery.hashes2Set(urls));\r\n            if (containers != null) {\r\n                Iterator ci = containers[0].entrySet().iterator();\r\n                Map.Entry entry;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = (Map.Entry) ci.next();\r\n                    wordhash = (String) entry.getKey();\r\n                    indexContainer container = (indexContainer) entry.getValue();\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(plasmaURL.compressIndex(container, null, 1000).toString()).append(serverCore.crlfString);                \r\n                }\r\n            }\r\n            \r\n            prop.putASIS(\"indexcount\", \"\");\r\n            prop.put(\"joincount\", 0);\r\n        } else {\r\n            // retrieve index containers from search request\r\n            squery = new plasmaSearchQuery(queryhashes, excludehashes, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), count, duetime, filter, constraint);\r\n            squery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (query-\" + abstracts + \"): \" + plasmaSearchQuery.anonymizedQueryHashes(squery.queryHashes) + \" - \" + squery.wantedResults + \" links\");\r\n\r\n            // prepare a search profile\r\n            plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(plasmaSearchQuery.contentdomParser(contentdom)) : new plasmaSearchRankingProfile(\"\", profile);\r\n            plasmaSearchProcessing localProcess  = new plasmaSearchProcessing(squery.maximumTime, squery.wantedResults);\r\n            //plasmaSearchProcessing remoteProcess = null;\r\n\r\n            //theSearch = new plasmaSearchEvent(squery, rankingProfile, localProcess, remoteProcess, true, sb.wordIndex, null);\r\n            Map[] containers = localProcess.localSearchContainers(squery, sb.wordIndex, plasmaSearchQuery.hashes2Set(urls));\r\n            // set statistic details of search result and find best result index set\r\n            if (containers == null) {\r\n                prop.putASIS(\"indexcount\", \"\");\r\n                prop.putASIS(\"joincount\", \"0\");\r\n            } else {\r\n                Iterator ci = containers[0].entrySet().iterator();\r\n                StringBuffer indexcount = new StringBuffer();\r\n                Map.Entry entry;\r\n                int maxcount = -1;\r\n                double mindhtdistance = 1.1, d;\r\n                String wordhash;\r\n                String maxcounthash = null, neardhthash = null;\r\n                while (ci.hasNext()) {\r\n                    entry = (Map.Entry) ci.next();\r\n                    wordhash = (String) entry.getKey();\r\n                    indexContainer container = (indexContainer) entry.getValue();\r\n                    if (container.size() > maxcount) {\r\n                        maxcounthash = wordhash;\r\n                        maxcount = container.size();\r\n                    }\r\n                    d = yacyDHTAction.dhtDistance(yacyCore.seedDB.mySeed.hash, wordhash);\r\n                    if (d < mindhtdistance) {\r\n                        // calculate the word hash that is closest to our dht position\r\n                        mindhtdistance = d;\r\n                        neardhthash = wordhash;\r\n                    }\r\n                    indexcount.append(\"indexcount.\").append(container.getWordHash()).append('=').append(Integer.toString(container.size())).append(serverCore.crlfString);\r\n                    if ((abstractSet != null) && (abstractSet.contains(wordhash))) {\r\n                        // if a specific index-abstract is demanded, attach it here\r\n                        indexabstractContainercount += container.size();\r\n                        indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(plasmaURL.compressIndex(container, null,1000).toString()).append(serverCore.crlfString);\r\n                    }\r\n                }\r\n                prop.putASIS(\"indexcount\", new String(indexcount));\r\n\r\n                // join and order the result\r\n                indexContainer localResults =\r\n                    (containers == null) ?\r\n                      plasmaWordIndex.emptyContainer(null, 0) :\r\n                          localProcess.localSearchJoinExclude(\r\n                              containers[0].values(),\r\n                              containers[1].values(),\r\n                              (squery.queryHashes.size() == 0) ?\r\n                                0 :\r\n                                localProcess.getTargetTime(plasmaSearchProcessing.PROCESS_JOIN) * squery.queryHashes.size() / (squery.queryHashes.size() + squery.excludeHashes.size()),\r\n                              squery.maxDistance);\r\n                if (localResults == null) {\r\n                    joincount = 0;\r\n                    prop.put(\"joincount\", 0);\r\n                } else {\r\n                    joincount = localResults.size();\r\n                    prop.putASIS(\"joincount\", Integer.toString(joincount));\r\n                    plasmaSearchPreOrder pre = new plasmaSearchPreOrder(squery, localProcess, rankingProfile, localResults);\r\n                    accu = new plasmaSearchResultAccumulator(squery, localProcess, rankingProfile, pre.strippedContainer(200), sb.wordIndex, plasmaSwitchboard.blueList, false);\r\n                }\r\n                \r\n                // generate compressed index for maxcounthash\r\n                // this is not needed if the search is restricted to specific\r\n                // urls, because it is a re-search\r\n                if ((maxcounthash == null) || (urls.length() != 0) || (queryhashes.size() == 1) || (abstracts.length() == 0)) {\r\n                    prop.putASIS(\"indexabstract\", \"\");\r\n                } else if (abstracts.equals(\"auto\")) {\r\n                    // automatically attach the index abstract for the index that has the most references. This should be our target dht position\r\n                    indexContainer container = (indexContainer) containers[0].get(maxcounthash);\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + maxcounthash + \"=\").append(plasmaURL.compressIndex(container,localResults, 1000).toString()).append(serverCore.crlfString);\r\n                    if ((neardhthash != null) && (!(neardhthash.equals(maxcounthash)))) {\r\n                        // in case that the neardhthash is different from the maxcounthash attach also the neardhthash-container\r\n                        container = (indexContainer) containers[0].get(neardhthash);\r\n                        indexabstractContainercount += container.size();\r\n                        indexabstract.append(\"indexabstract.\" + neardhthash + \"=\").append(plasmaURL.compressIndex(container, localResults, 1000).toString()).append(serverCore.crlfString);\r\n                    }\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: maxcounthash = \" + maxcounthash);\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: neardhthash  = \"+ neardhthash);\r\n                    //yacyCore.log.logFine(\"DEBUG HASH SEARCH: \" + indexabstract);\r\n                }\r\n            }\r\n            if (partitions > 0) sb.requestedQueries = sb.requestedQueries + 1d / (double) partitions; // increase query counter\r\n        }\r\n        prop.putASIS(\"indexabstract\", new String(indexabstract));\r\n        \r\n        // prepare search statistics\r\n        Long trackerHandle = new Long(System.currentTimeMillis());\r\n        String client = (String) header.get(\"CLIENTIP\");\r\n        HashMap searchProfile = squery.resultProfile((accu == null) ? 0 : accu.resultCount(), System.currentTimeMillis() - timestamp);\r\n        searchProfile.put(\"host\", client);\r\n        yacySeed remotepeer = yacyCore.seedDB.lookupByIP(natLib.getInetAddress(client), true, false, false);\r\n        searchProfile.put(\"peername\", (remotepeer == null) ? \"unknown\" : remotepeer.getName());\r\n        searchProfile.put(\"time\", trackerHandle);\r\n        sb.remoteSearches.add(searchProfile);\r\n        \r\n        TreeSet handles = (TreeSet) sb.remoteSearchTracker.get(client);\r\n        if (handles == null) handles = new TreeSet();\r\n        handles.add(trackerHandle);\r\n        sb.remoteSearchTracker.put(client, handles);\r\n        \r\n        // prepare result\r\n        if ((joincount == 0) || (accu == null)) {\r\n            \r\n            // no results\r\n            prop.putASIS(\"links\", \"\");\r\n            prop.putASIS(\"linkcount\", \"0\");\r\n            prop.putASIS(\"references\", \"\");\r\n\r\n        } else {\r\n            // result is a List of urlEntry elements\r\n            StringBuffer links = new StringBuffer();\r\n            String resource = null;\r\n            plasmaSearchResultAccumulator.Entry entry;\r\n            for (int i = 0; i < accu.resultCount(); i++) {\r\n                entry = accu.resultEntry(i);\r\n                resource = entry.resource();\r\n                if (resource != null) {\r\n                    links.append(\"resource\").append(i).append('=').append(resource).append(serverCore.crlfString);\r\n                }\r\n            }\r\n            prop.putASIS(\"links\", new String(links));\r\n            prop.put(\"linkcount\", accu.resultCount());\r\n\r\n            // prepare reference hints\r\n            Object[] ws = accu.references();\r\n            StringBuffer refstr = new StringBuffer();\r\n            for (int j = 0; j < ws.length; j++)\r\n                refstr.append(\",\").append((String) ws[j]);\r\n            prop.putASIS(\"references\", (refstr.length() > 0) ? refstr.substring(1) : new String(refstr));\r\n        }\r\n        \r\n        // add information about forward peers\r\n        prop.putASIS(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n        prop.putASIS(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n        prop.putASIS(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n        \r\n        // log\r\n        yacyCore.log.logInfo(\"EXIT HASH SEARCH: \" +\r\n                plasmaSearchQuery.anonymizedQueryHashes(squery.queryHashes) + \" - \" + joincount + \" links found, \" +\r\n                prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n                indexabstractContainercount + \" index abstract references attached, \" +\r\n                (System.currentTimeMillis() - timestamp) + \" milliseconds\");\r\n \r\n        prop.putASIS(\"searchtime\", Long.toString(System.currentTimeMillis() - timestamp));\r\n\r\n        final int links = Integer.parseInt(prop.get(\"linkcount\",\"0\"));\r\n        yacyCore.seedDB.mySeed.incSI(links);\r\n        yacyCore.seedDB.mySeed.incSU(links);\r\n        return prop;\r\n    }","id":84722,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        \r\n        //System.out.println(\"yacy: search received request = \" + post.toString());\r\n\r\n        final String  oseed  = post.get(\"myseed\", \"\"); // complete seed of the requesting peer\r\n//      final String  youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n        final String  key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String  query  = post.get(\"query\", \"\");  // a string of word hashes that shall be searched and combined\r\n        final String  exclude= post.get(\"exclude\", \"\");// a string of word hashes that shall not be within the search result\r\n        String  urls   = post.get(\"urls\", \"\");         // a string of url hashes that are preselected for the search: no other may be returned\r\n        String abstracts = post.get(\"abstracts\", \"\");  // a string of word hashes for abstracts that shall be generated, or 'auto' (for maxcount-word), or '' (for none)\r\n//      final String  fwdep  = post.get(\"fwdep\", \"\");  // forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n//      final String  fwden  = post.get(\"fwden\", \"\");  // forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        final long    duetime= Math.min(60000, post.getLong(\"duetime\", 3000));\r\n        final int     count  = Math.min(100, post.getInt(\"count\", 10)); // maximum number of wanted results\r\n        final int     maxdist= post.getInt(\"maxdist\", Integer.MAX_VALUE);\r\n        final String  prefer = post.get(\"prefer\", \"\");\r\n        final String  contentdom = post.get(\"contentdom\", \"text\");\r\n        final String  filter = post.get(\"filter\", \".*\");\r\n        final int     partitions = post.getInt(\"partitions\", 30);\r\n        String  profile = post.get(\"profile\", \"\"); // remote profile hand-over\r\n        if (profile.length() > 0) profile = crypt.simpleDecode(profile, null);\r\n        //final boolean includesnippet = post.get(\"includesnippet\", \"false\").equals(\"true\");\r\n        final kelondroBitfield constraint = new kelondroBitfield(4, post.get(\"constraint\", \"______\"));\r\n//      final boolean global = ((String) post.get(\"resource\", \"global\")).equals(\"global\"); // if true, then result may consist of answers from other peers\r\n//      Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME));        // read remote time\r\n\r\n        // test:\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Q (search for linux)\r\n        // http://localhost:8080/yacy/search.html?query=gh8DKIhGKXws (search for book)\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Qgh8DKIhGKXws&abstracts=auto (search for linux and book, generate abstract automatically)\r\n        // http://localhost:8080/yacy/search.html?query=&abstracts=4galTpdpDM5Q (only abstracts for linux)\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n             \t (!((sb.isPublicRobinson()) ||\r\n             \t    (sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))))) {\r\n                 // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.putASIS(\"links\", \"\");\r\n            prop.putASIS(\"linkcount\", \"0\");\r\n            prop.putASIS(\"references\", \"\");\r\n        \treturn prop;\r\n        }\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(2 * duetime);\r\n\r\n        TreeSet abstractSet = ((abstracts.length() == 0) || (abstracts.equals(\"auto\"))) ? null : plasmaSearchQuery.hashes2Set(abstracts);\r\n        \r\n        // store accessing peer\r\n        if (yacyCore.seedDB == null) {\r\n            yacyCore.log.logSevere(\"yacy.search: seed cache not initialized\");\r\n        } else {\r\n            yacyCore.peerActions.peerArrival(yacySeed.genRemoteSeed(oseed, key, true), true);\r\n        }\r\n\r\n        // prepare search\r\n        final TreeSet queryhashes = plasmaSearchQuery.hashes2Set(query);\r\n        final TreeSet excludehashes = (exclude.length() == 0) ? new TreeSet(kelondroBase64Order.enhancedCoder) : plasmaSearchQuery.hashes2Set(exclude);\r\n        final long timestamp = System.currentTimeMillis();\r\n        \r\n        // prepare an abstract result\r\n        StringBuffer indexabstract = new StringBuffer();\r\n        int indexabstractContainercount = 0;\r\n        int joincount = 0;\r\n        plasmaSearchQuery theQuery = null;\r\n        ArrayList accu = null;\r\n        if ((query.length() == 0) && (abstractSet != null)) {\r\n            // this is _not_ a normal search, only a request for index abstracts\r\n            theQuery = new plasmaSearchQuery(abstractSet, new TreeSet(kelondroBase64Order.enhancedCoder), maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), count, duetime, filter, plasmaSearchQuery.catchall_constraint);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (abstracts only): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.wantedResults + \" links\");\r\n\r\n            // prepare a search profile\r\n            plasmaSearchProcessing localTiming  = new plasmaSearchProcessing(theQuery.maximumTime, theQuery.wantedResults);\r\n            \r\n            //theSearch = new plasmaSearchEvent(squery, rankingProfile, localTiming, remoteTiming, true, sb.wordIndex, null);\r\n            Map[] containers = localTiming.localSearchContainers(theQuery, sb.wordIndex, plasmaSearchQuery.hashes2Set(urls));\r\n            if (containers != null) {\r\n                Iterator ci = containers[0].entrySet().iterator();\r\n                Map.Entry entry;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = (Map.Entry) ci.next();\r\n                    wordhash = (String) entry.getKey();\r\n                    indexContainer container = (indexContainer) entry.getValue();\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(plasmaURL.compressIndex(container, null, 1000).toString()).append(serverCore.crlfString);                \r\n                }\r\n            }\r\n            \r\n            prop.putASIS(\"indexcount\", \"\");\r\n            prop.put(\"joincount\", 0);\r\n            prop.putASIS(\"references\", \"\");\r\n            \r\n        } else {\r\n            // retrieve index containers from search request\r\n            theQuery = new plasmaSearchQuery(queryhashes, excludehashes, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), count, duetime, filter, constraint);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (query-\" + abstracts + \"): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.wantedResults + \" links\");\r\n\r\n            // prepare a search profile\r\n            plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(plasmaSearchQuery.contentdomParser(contentdom)) : new plasmaSearchRankingProfile(\"\", profile);\r\n            plasmaSearchProcessing localProcess  = new plasmaSearchProcessing(theQuery.maximumTime, theQuery.wantedResults);\r\n            //plasmaSearchProcessing remoteProcess = null;\r\n\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, rankingProfile, localProcess, null, sb.wordIndex, null, true, abstractSet);\r\n            //Map[] containers = localProcess.localSearchContainers(theQuery, sb.wordIndex, plasmaSearchQuery.hashes2Set(urls));\r\n            // set statistic details of search result and find best result index set\r\n            if (theSearch.getLocalCount() == 0) {\r\n                prop.putASIS(\"indexcount\", \"\");\r\n                prop.putASIS(\"joincount\", \"0\");\r\n            } else {\r\n                // attach information about index abstracts\r\n                StringBuffer indexcount = new StringBuffer();\r\n                Map.Entry entry;\r\n                Iterator i = theSearch.IACount.entrySet().iterator();\r\n                while (i.hasNext()) {\r\n                    entry = (Map.Entry) i.next();\r\n                    indexcount.append(\"indexcount.\").append((String) entry.getKey()).append('=').append(((Integer) entry.getValue()).toString()).append(serverCore.crlfString);\r\n                }\r\n                if (abstractSet != null) {\r\n                    // if a specific index-abstract is demanded, attach it here\r\n                    i = abstractSet.iterator();\r\n                    String wordhash;\r\n                    while (i.hasNext()) {\r\n                        wordhash = (String) i.next();\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(wordhash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append((String) theSearch.IAResults.get(wordhash)).append(serverCore.crlfString);\r\n                    }\r\n                }\r\n                prop.putASIS(\"indexcount\", new String(indexcount));\r\n                \r\n                if (theSearch.getLocalCount() == 0) {\r\n                    joincount = 0;\r\n                    prop.put(\"joincount\", 0);\r\n                } else {\r\n                    joincount = theSearch.getLocalCount();\r\n                    prop.putASIS(\"joincount\", Integer.toString(joincount));\r\n                    accu = theSearch.computeResults(plasmaSwitchboard.blueList, false);\r\n                }\r\n                \r\n                // generate compressed index for maxcounthash\r\n                // this is not needed if the search is restricted to specific\r\n                // urls, because it is a re-search\r\n                if ((theSearch.IAmaxcounthash == null) || (urls.length() != 0) || (queryhashes.size() == 1) || (abstracts.length() == 0)) {\r\n                    prop.putASIS(\"indexabstract\", \"\");\r\n                } else if (abstracts.equals(\"auto\")) {\r\n                    // automatically attach the index abstract for the index that has the most references. This should be our target dht position\r\n                    indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAmaxcounthash)).intValue();\r\n                    indexabstract.append(\"indexabstract.\" + theSearch.IAmaxcounthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAmaxcounthash)).append(serverCore.crlfString);\r\n                    if ((theSearch.IAneardhthash != null) && (!(theSearch.IAneardhthash.equals(theSearch.IAmaxcounthash)))) {\r\n                        // in case that the neardhthash is different from the maxcounthash attach also the neardhthash-container\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAneardhthash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + theSearch.IAneardhthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAneardhthash)).append(serverCore.crlfString);\r\n                    }\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: maxcounthash = \" + maxcounthash);\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: neardhthash  = \"+ neardhthash);\r\n                    //yacyCore.log.logFine(\"DEBUG HASH SEARCH: \" + indexabstract);\r\n                }\r\n            }\r\n            if (partitions > 0) sb.requestedQueries = sb.requestedQueries + 1d / (double) partitions; // increase query counter\r\n\r\n            // prepare reference hints\r\n            Object[] ws = theSearch.references();\r\n            StringBuffer refstr = new StringBuffer();\r\n            for (int j = 0; j < ws.length; j++)\r\n                refstr.append(\",\").append((String) ws[j]);\r\n            prop.putASIS(\"references\", (refstr.length() > 0) ? refstr.substring(1) : new String(refstr));\r\n        }\r\n        prop.putASIS(\"indexabstract\", new String(indexabstract));\r\n        \r\n        // prepare search statistics\r\n        Long trackerHandle = new Long(System.currentTimeMillis());\r\n        String client = (String) header.get(\"CLIENTIP\");\r\n        HashMap searchProfile = theQuery.resultProfile((accu == null) ? 0 : accu.size(), System.currentTimeMillis() - timestamp);\r\n        searchProfile.put(\"host\", client);\r\n        yacySeed remotepeer = yacyCore.seedDB.lookupByIP(natLib.getInetAddress(client), true, false, false);\r\n        searchProfile.put(\"peername\", (remotepeer == null) ? \"unknown\" : remotepeer.getName());\r\n        searchProfile.put(\"time\", trackerHandle);\r\n        sb.remoteSearches.add(searchProfile);\r\n        \r\n        TreeSet handles = (TreeSet) sb.remoteSearchTracker.get(client);\r\n        if (handles == null) handles = new TreeSet();\r\n        handles.add(trackerHandle);\r\n        sb.remoteSearchTracker.put(client, handles);\r\n        \r\n        // prepare result\r\n        if ((joincount == 0) || (accu == null)) {\r\n            \r\n            // no results\r\n            prop.putASIS(\"links\", \"\");\r\n            prop.putASIS(\"linkcount\", \"0\");\r\n            prop.putASIS(\"references\", \"\");\r\n\r\n        } else {\r\n            // result is a List of urlEntry elements\r\n            StringBuffer links = new StringBuffer();\r\n            String resource = null;\r\n            plasmaSearchEvent.Entry entry;\r\n            for (int i = 0; i < accu.size(); i++) {\r\n                entry = (plasmaSearchEvent.Entry) accu.get(i);\r\n                resource = entry.resource();\r\n                if (resource != null) {\r\n                    links.append(\"resource\").append(i).append('=').append(resource).append(serverCore.crlfString);\r\n                }\r\n            }\r\n            prop.putASIS(\"links\", new String(links));\r\n            prop.put(\"linkcount\", accu.size());\r\n        }\r\n        \r\n        // add information about forward peers\r\n        prop.putASIS(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n        prop.putASIS(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n        prop.putASIS(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n        \r\n        // log\r\n        yacyCore.log.logInfo(\"EXIT HASH SEARCH: \" +\r\n                plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + joincount + \" links found, \" +\r\n                prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n                indexabstractContainercount + \" index abstract references attached, \" +\r\n                (System.currentTimeMillis() - timestamp) + \" milliseconds\");\r\n \r\n        prop.putASIS(\"searchtime\", Long.toString(System.currentTimeMillis() - timestamp));\r\n\r\n        final int links = Integer.parseInt(prop.get(\"linkcount\",\"0\"));\r\n        yacyCore.seedDB.mySeed.incSI(links);\r\n        yacyCore.seedDB.mySeed.incSU(links);\r\n        return prop;\r\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n\r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n\r\n        // case if no values are requested\r\n        final String referer = (String) header.get(\"Referer\");\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        \r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n\r\n            // save referrer\r\n            // System.out.println(\"HEADER=\" + header.toString());\r\n            if (referer != null) {\r\n                URL url;\r\n                try { url = new URL(referer); } catch (MalformedURLException e) { url = null; }\r\n                if ((url != null) && (!serverDomains.isLocal(url))) {\r\n                    final HashMap referrerprop = new HashMap();\r\n                    referrerprop.put(\"count\", \"1\");\r\n                    referrerprop.put(\"clientip\", header.get(\"CLIENTIP\"));\r\n                    referrerprop.put(\"useragent\", header.get(\"User-Agent\"));\r\n                    referrerprop.put(\"date\", (new serverDate()).toShortString(false));\r\n                    if (sb.facilityDB != null) try { sb.facilityDB.update(\"backlinks\", referer, referrerprop); } catch (IOException e) {}\r\n                }\r\n            }\r\n\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"searchagain\", 0);\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.putASIS(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", 10);\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_time\", 6);\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", plasmaSearchQuery.catchall_constraint.exportB64());\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", 1);\r\n            prop.put(\"input_contentdomCheckAudio\", 0);\r\n            prop.put(\"input_contentdomCheckVideo\", 0);\r\n            prop.put(\"input_contentdomCheckImage\", 0);\r\n            prop.put(\"input_contentdomCheckApp\", 0);\r\n            prop.put(\"type\", 0);\r\n            prop.put(\"type_excluded\", 0);\r\n            prop.put(\"type_combine\", 0);\r\n            prop.put(\"type_results\", \"\");\r\n            prop.put(\"num-results\", (searchAllowed) ? 0 : 6);\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int count = Integer.parseInt(post.get(\"count\", \"10\"));\r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        final long searchtime = 1000 * Long.parseLong(post.get(\"time\", \"10\"));\r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = post.containsKey(\"constraint\") ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : plasmaSearchQuery.catchall_constraint;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield();\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        final boolean offline = yacyCore.seedDB.mySeed.isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (count <= 10)) count = 30;\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if (post.get(\"cat\", \"href\").equals(\"href\")) {\r\n\r\n        final TreeSet[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n        // filter out stopwords\r\n        final TreeSet filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n        if (filtered.size() > 0) {\r\n            kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n        }\r\n\r\n        // if a minus-button was hit, remove a special reference first\r\n        if (post.containsKey(\"deleteref\")) {\r\n            if (!sb.verifyAuthentication(header, true)) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n                \r\n            // delete the index entry locally\r\n            final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n            sb.wordIndex.removeWordReferences(query[0], delHash);\r\n\r\n            // make new news message with negative voting\r\n            HashMap map = new HashMap();\r\n            map.put(\"urlhash\", delHash);\r\n            map.put(\"vote\", \"negative\");\r\n            map.put(\"refid\", \"\");\r\n            yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n        }\r\n\r\n        // if a plus-button was hit, create new voting message\r\n        if (post.containsKey(\"recommendref\")) {\r\n            if (!sb.verifyAuthentication(header, true)) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n            indexURLEntry urlentry = sb.wordIndex.loadedURL.load(recommendHash, null);\r\n            if (urlentry != null) {\r\n                indexURLEntry.Components comp = urlentry.comp();\r\n                plasmaParserDocument document;\r\n                document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true);\r\n                if (document != null) {\r\n                    // create a news message\r\n                    HashMap map = new HashMap();\r\n                    map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                    map.put(\"title\", comp.title().replace(',', ' '));\r\n                    map.put(\"description\", ((document == null) ? comp.title() : document.getTitle()).replace(',', ' '));\r\n                    map.put(\"author\", ((document == null) ? \"\" : document.getAuthor()));\r\n                    map.put(\"tags\", ((document == null) ? \"\" : document.getKeywords(' ')));\r\n                    yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                    document.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        // prepare search properties\r\n        final boolean yacyonline = ((yacyCore.seedDB != null) && (yacyCore.seedDB.mySeed != null) && (yacyCore.seedDB.mySeed.getPublicAddress() != null));\r\n        final boolean globalsearch = (global) && (yacyonline);\r\n        \r\n        // do the search\r\n        TreeSet queryHashes = plasmaCondenser.words2hashes(query[0]);\r\n        plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tplasmaCondenser.words2hashes(query[1]),\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    count,\r\n                    searchtime,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint);\r\n        plasmaSearchRankingProfile ranking = (sb.getConfig(\"rankingProfile\", \"\").length() == 0) ? new plasmaSearchRankingProfile(contentdomCode) : new plasmaSearchRankingProfile(\"\", crypt.simpleDecode(sb.getConfig(\"rankingProfile\", \"\"), null));\r\n        plasmaSearchProcessing localTiming = new plasmaSearchProcessing(4 * theQuery.maximumTime / 10, theQuery.wantedResults);\r\n        plasmaSearchProcessing remoteTiming = new plasmaSearchProcessing(6 * theQuery.maximumTime / 10, theQuery.wantedResults);\r\n\r\n        //**\r\n        //searchFromLocal(thisSearch, ranking, localTiming, remoteTiming, true, (String) header.get(\"CLIENTIP\"))\r\n        String client = (String) header.get(\"CLIENTIP\"); // the search client who initiated the search\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(2 * theQuery.maximumTime);\r\n        \r\n        // filter out words that appear in bluelist\r\n        theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n        // log\r\n        serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.wantedResults + \" links, \" + (theQuery.maximumTime / 1000) + \" seconds\");\r\n        long timestamp = System.currentTimeMillis();\r\n\r\n        // create a new search event\r\n        String wrongregex = null;\r\n        plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, localTiming, remoteTiming, sb.wordIndex, (sb.isRobinsonMode()) ? sb.clusterhashes : null);\r\n        indexContainer preorder = theSearch.search();\r\n            \r\n        // fetch snippets\r\n        serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n        plasmaSearchResultAccumulator accu = new plasmaSearchResultAccumulator(theQuery, localTiming, ranking, preorder, sb.wordIndex, plasmaSwitchboard.blueList, true);\r\n        serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n        // calc some more cross-reference\r\n        long remainingTime = theQuery.maximumTime - (System.currentTimeMillis() - timestamp);\r\n        if (remainingTime < 0) remainingTime = 1000;\r\n        //Object[] ws = acc.getReferences(16);\r\n        serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n        // log\r\n        serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getLocalCount() + theSearch.getGlobalCount()) + \" links found, \" +\r\n                    theSearch.filteredCount() + \" links filtered, \" +\r\n                    accu.resultCount() + \" links ordered, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            \r\n            \r\n        // prepare search statistics\r\n        Long trackerHandle = new Long(System.currentTimeMillis());\r\n        HashMap searchProfile = theQuery.resultProfile(accu.resultCount(), System.currentTimeMillis() - timestamp);\r\n        searchProfile.put(\"querystring\", theQuery.queryString);\r\n        searchProfile.put(\"time\", trackerHandle);\r\n        searchProfile.put(\"host\", client);\r\n        searchProfile.put(\"offset\", new Integer(0));\r\n        searchProfile.put(\"results\", accu);\r\n        sb.localSearches.add(searchProfile);\r\n        TreeSet handles = (TreeSet) sb.localSearchTracker.get(client);\r\n        if (handles == null) handles = new TreeSet();\r\n        handles.add(trackerHandle);\r\n        sb.localSearchTracker.put(client, handles);\r\n        //**\r\n\r\n        //prop=sb.searchFromLocal(thisSearch, ranking, localTiming, remoteTiming, true, (String) header.get(\"CLIENTIP\"));\r\n        prop=new serverObjects();\r\n        //prop.put(\"references\", 0);\r\n        URL wordURL=null;\r\n        prop.put(\"num-results_totalcount\", theSearch.getLocalCount() + theSearch.getGlobalCount());\r\n        prop.put(\"num-results_filteredcount\", theSearch.filteredCount());\r\n        prop.put(\"num-results_orderedcount\", accu.resultCount());\r\n        prop.put(\"num-results_globalresults\", (theSearch.getGlobalCount() == 0) ? 0 : 1);\r\n        prop.put(\"num-results_globalresults_globalcount\", theSearch.getGlobalCount());\r\n        prop.put(\"num-results_linkcount\", 0);\r\n        prop.put(\"type_results\", 0);\r\n\r\n        for (int i = 0; i < accu.resultCount(); i++) {\r\n            plasmaSearchResultAccumulator.Entry result = accu.resultEntry(i);\r\n            prop.put(\"type_results_\" + i + \"_authorized_recommend\", (yacyCore.newsPool.getSpecific(yacyNewsPool.OUTGOING_DB, yacyNewsPool.CATEGORY_SURFTIPP_ADD, \"url\", result.urlstring()) == null) ? 1 : 0);\r\n            prop.put(\"type_results_\" + i + \"_authorized_recommend_deletelink\", \"/yacysearch.html?search=\" + theQuery.queryString + \"&Enter=Search&count=\" + theQuery.wantedResults + \"&order=\" + crypt.simpleEncode(ranking.toExternalString()) + \"&resource=local&time=3&deleteref=\" + result.hash() + \"&urlmaskfilter=.*\");\r\n            prop.put(\"type_results_\" + i + \"_authorized_recommend_recommendlink\", \"/yacysearch.html?search=\" + theQuery.queryString + \"&Enter=Search&count=\" + theQuery.wantedResults + \"&order=\" + crypt.simpleEncode(ranking.toExternalString()) + \"&resource=local&time=3&recommendref=\" + result.hash() + \"&urlmaskfilter=.*\");\r\n            prop.put(\"type_results_\" + i + \"_authorized_urlhash\", result.hash());\r\n            prop.put(\"type_results_\" + i + \"_description\", result.title());\r\n            prop.put(\"type_results_\" + i + \"_url\", result.urlstring());\r\n            int port=result.url().getPort();\r\n            URL faviconURL;\r\n            try {\r\n                faviconURL = new URL(result.url().getProtocol() + \"://\" + result.url().getHost() + ((port != -1) ? (\":\" + String.valueOf(port)) : \"\") + \"/favicon.ico\");\r\n            } catch (MalformedURLException e1) {\r\n                continue;\r\n            }\r\n            prop.put(\"type_results_\" + i + \"_faviconCode\", sb.licensedURLs.aquireLicense(faviconURL)); // aquire license for favicon url loading\r\n            prop.put(\"type_results_\" + i + \"_urlhash\", result.hash());\r\n                prop.put(\"type_results_\" + i + \"_urlhexhash\", yacySeed.b64Hash2hexHash(result.hash()));\r\n                prop.put(\"type_results_\" + i + \"_urlname\", nxTools.shortenURLString(result.urlname(), 120));\r\n                prop.put(\"type_results_\" + i + \"_date\", plasmaSwitchboard.dateString(result.modified()));\r\n                prop.put(\"type_results_\" + i + \"_ybr\", plasmaSearchPreOrder.ybr(result.hash()));\r\n                prop.put(\"type_results_\" + i + \"_size\", Long.toString(result.filesize()));\r\n                try {\r\n                    prop.put(\"type_results_\" + i + \"_words\", URLEncoder.encode(query[0].toString(),\"UTF-8\"));\r\n                } catch (UnsupportedEncodingException e) {}\r\n                prop.put(\"type_results_\" + i + \"_former\", querystring);\r\n                prop.put(\"type_results_\" + i + \"_rankingprops\", result.word().toPropertyForm() + \", domLengthEstimated=\" + plasmaURL.domLengthEstimation(result.hash()) +\r\n                        ((plasmaURL.probablyRootURL(result.hash())) ? \", probablyRootURL\" : \"\") + \r\n                        (((wordURL = plasmaURL.probablyWordURL(result.hash(), query[0])) != null) ? \", probablyWordURL=\" + wordURL.toNormalform(false, true) : \"\"));\r\n                // adding snippet if available\r\n                if (result.hasSnippet()) {\r\n                    prop.put(\"type_results_\" + i + \"_snippet\", 1);\r\n                    prop.putASIS(\"type_results_\" + i + \"_snippet_text\", result.textSnippet().getLineMarked(theQuery.queryHashes));//FIXME: the ASIS should not be needed, if there is no html in .java\r\n                } else {                \t\r\n                \tif (post.containsKey(\"fetchSnippet\")) {\r\n                \t\t// snippet fetch timeout\r\n                        int textsnippet_timeout = Integer.parseInt(env.getConfig(\"timeout_media\", \"10000\"));\r\n                        \r\n                        // boolean line_end_with_punctuation\r\n                        boolean pre = post.get(\"pre\", \"false\").equals(\"true\");\r\n                        \r\n                        // if 'remove' is set to true, then RWI references to URLs that do not have the snippet are removed\r\n                        boolean remove = post.get(\"remove\", \"false\").equals(\"true\");\r\n                        \r\n                        plasmaSnippetCache.TextSnippet snippet = plasmaSnippetCache.retrieveTextSnippet(\r\n                        \t\tresult.url(), \r\n                        \t\tqueryHashes, \r\n                        \t\ttrue, \r\n                        \t\tpre, \r\n                        \t\t260, \r\n                        \t\ttextsnippet_timeout\r\n                        );\r\n                                                \t\r\n                        if (snippet.getErrorCode() < 11) {\r\n                            // no problems occurred\r\n                            //prop.put(\"text\", (snippet.exists()) ? snippet.getLineMarked(queryHashes) : \"unknown\");\r\n                            prop.putASIS(\"type_results_\" + i + \"_snippet_text\", (snippet.exists()) ? snippet.getLineMarked(queryHashes) : \"unknown\");\r\n                        } else {\r\n                            // problems with snippet fetch\r\n                           prop.put(\"type_results_\" + i + \"_snippet_text\", (remove) ? plasmaSnippetCache.failConsequences(snippet, theQuery.id()) : snippet.getError());\r\n                        }          \r\n                        prop.put(\"type_results_\" + i + \"_snippet\", 1);\r\n                \t} else {\r\n                \t\t/* no snippet available (will be fetched later via ajax) */\r\n                \t\tprop.put(\"type_results_\" + i + \"_snippet\", 0);\r\n                \t\tprop.put(\"type_results_\" + i + \"_snippet_text\", \"\");\r\n                \t}\r\n                }\r\n                prop.put(\"type_results\", accu.resultCount());\r\n                prop.put(\"num-results_linkcount\", Integer.toString(accu.resultCount()));\r\n            }\r\n\r\n        // process result of search\r\n        if (filtered.size() > 0) {\r\n            prop.put(\"excluded\", 1);\r\n            prop.put(\"excluded_stopwords\", filtered.toString());\r\n        } else {\r\n            prop.put(\"excluded\", 0);\r\n        }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", 2); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", 1); // no results\r\n                }\r\n            } else {\r\n                final int totalcount = prop.getInt(\"num-results_totalcount\", 0);\r\n                if (totalcount >= 10) {\r\n                    final Object[] references = (Object[]) prop.get( \"references\", new String[0]);\r\n                    prop.put(\"num-results\", 5);\r\n                    int hintcount = references.length;\r\n                    if (hintcount > 0) {\r\n\r\n                        prop.put(\"type_combine\", 1);\r\n                        // get the topwords\r\n                        final TreeSet topwords = new TreeSet(kelondroNaturalOrder.naturalOrder);\r\n                        String tmp = \"\";\r\n                        for (int i = 0; i < hintcount; i++) {\r\n                            tmp = (String) references[i];\r\n                            if (tmp.matches(\"[a-z]+\")) {\r\n                                topwords.add(tmp);\r\n                            // } else {\r\n                            //    topwords.add(\"(\" + tmp + \")\");\r\n                            }\r\n                        }\r\n\r\n                        // filter out the badwords\r\n                        final TreeSet filteredtopwords = kelondroMSetTools.joinConstructive(topwords, plasmaSwitchboard.badwords);\r\n                        if (filteredtopwords.size() > 0) {\r\n                            kelondroMSetTools.excludeDestructive(topwords, plasmaSwitchboard.badwords);\r\n                        }\r\n\r\n\t\t\t\t\t\t//avoid stopwords being topwords\r\n                        if (env.getConfig(\"filterOutStopwordsFromTopwords\", \"true\").equals(\"true\")) {\r\n                        if ((plasmaSwitchboard.stopwords != null) && (plasmaSwitchboard.stopwords.size() > 0)) {\r\n                            kelondroMSetTools.excludeDestructive(topwords, plasmaSwitchboard.stopwords);\r\n                        \t}\r\n                        }\r\n\t\t\t\t\t\t\r\n                        String word;\r\n                        hintcount = 0;\r\n                        final Iterator iter = topwords.iterator();\r\n                        while (iter.hasNext()) {\r\n                            word = (String) iter.next();\r\n                            if (word != null) {\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_word\", word);\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_newsearch\", post.get(\"search\", \"\").replace(' ', '+') + \"+\" + word);\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_count\", count);\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_resource\", ((global) ? \"global\" : \"local\"));\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_time\", (searchtime / 1000));\r\n                            }\r\n                            prop.put(\"type_combine_words\", hintcount);\r\n                            if (hintcount++ > MAX_TOPWORDS) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (wrongregex != null) {\r\n                        prop.put(\"num-results_wrong_regex\", wrongregex);\r\n                        prop.put(\"num-results\", 4);\r\n                    }\r\n                    else if (totalcount == 0) {\r\n                        prop.put(\"num-results\", 3); // long\r\n                    }\r\n                    else {\r\n                        prop.put(\"num-results\", 5);\r\n                    }\r\n                }\r\n            }\r\n\r\n            prop.put(\"type\", (theQuery.contentdom == plasmaSearchQuery.CONTENTDOM_TEXT) ? 0 : ((theQuery.contentdom == plasmaSearchQuery.CONTENTDOM_IMAGE) ? 2 : 1));\r\n            if (prop.getInt(\"type\", 0) == 1) prop.put(\"type_mediatype\", post.get(\"contentdom\", \"text\"));\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"type_eventID\", theQuery.id()); \r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n\r\n        if (post.get(\"cat\", \"href\").equals(\"image\")) {\r\n\r\n            int depth = post.getInt(\"depth\", 0);\r\n            int columns = post.getInt(\"columns\", 6);\r\n            URL url = null;\r\n            try {url = new URL(post.get(\"url\", \"\"));} catch (MalformedURLException e) {}\r\n            plasmaSearchImages si = new plasmaSearchImages(6000, url, depth);\r\n            Iterator i = si.entries();\r\n            htmlFilterImageEntry ie;\r\n            int line = 0;\r\n            while (i.hasNext()) {\r\n                int col = 0;\r\n                for (col = 0; col < columns; col++) {\r\n                    if (!i.hasNext()) break;\r\n                    ie = (htmlFilterImageEntry) i.next();\r\n                    String urls = ie.url().toString();\r\n                    String name = \"\";\r\n                    int p = urls.lastIndexOf('/');\r\n                    if (p > 0) name = urls.substring(p + 1);\r\n                    prop.put(\"type_results_\" + line + \"_line_\" + col + \"_url\", urls);\r\n                    prop.put(\"type_results_\" + line + \"_line_\" + col + \"_name\", name);\r\n                }\r\n                prop.put(\"type_results_\" + line + \"_line\", col);\r\n                line++;\r\n            }\r\n            prop.put(\"type_results\", line);\r\n\r\n            prop.put(\"type\", 3); // set type of result: image list\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", depth);\r\n        }\r\n\r\n        // if user is not authenticated, he may not vote for URLs\r\n        int linkcount = Integer.parseInt(prop.get(\"num-results_linkcount\", \"0\"));\r\n        for (int i=0; i<linkcount; i++)\r\n            prop.put(\"type_results_\" + i + \"_authorized\", (authenticated) ? 1 : 0);\r\n\r\n        prop.put(\"searchagain\", (global) ? 1 : 0);\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.putASIS(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"input_former\", post.get(\"search\", \"\"));\r\n        prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", count);\r\n        prop.put(\"input_resource\", (global) ? \"global\" : \"local\");\r\n        prop.put(\"input_time\", searchtime / 1000);\r\n        prop.put(\"input_urlmaskfilter\", urlmask);\r\n        prop.put(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? 1 : 0);\r\n        prop.put(\"type_former\", post.get(\"search\", \"\")); //the query-string used to get the snippets\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":84723,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n\r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n\r\n        // case if no values are requested\r\n        final String referer = (String) header.get(\"Referer\");\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        \r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n\r\n            // save referrer\r\n            // System.out.println(\"HEADER=\" + header.toString());\r\n            if (referer != null) {\r\n                URL url;\r\n                try { url = new URL(referer); } catch (MalformedURLException e) { url = null; }\r\n                if ((url != null) && (!serverDomains.isLocal(url))) {\r\n                    final HashMap referrerprop = new HashMap();\r\n                    referrerprop.put(\"count\", \"1\");\r\n                    referrerprop.put(\"clientip\", header.get(\"CLIENTIP\"));\r\n                    referrerprop.put(\"useragent\", header.get(\"User-Agent\"));\r\n                    referrerprop.put(\"date\", (new serverDate()).toShortString(false));\r\n                    if (sb.facilityDB != null) try { sb.facilityDB.update(\"backlinks\", referer, referrerprop); } catch (IOException e) {}\r\n                }\r\n            }\r\n\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"searchagain\", 0);\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.putASIS(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", 10);\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_time\", 6);\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", plasmaSearchQuery.catchall_constraint.exportB64());\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", 1);\r\n            prop.put(\"input_contentdomCheckAudio\", 0);\r\n            prop.put(\"input_contentdomCheckVideo\", 0);\r\n            prop.put(\"input_contentdomCheckImage\", 0);\r\n            prop.put(\"input_contentdomCheckApp\", 0);\r\n            prop.put(\"type\", 0);\r\n            prop.put(\"type_excluded\", 0);\r\n            prop.put(\"type_combine\", 0);\r\n            prop.put(\"type_results\", \"\");\r\n            prop.put(\"num-results\", (searchAllowed) ? 0 : 6);\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int count = Integer.parseInt(post.get(\"count\", \"10\"));\r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        final long searchtime = 1000 * Long.parseLong(post.get(\"time\", \"10\"));\r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = post.containsKey(\"constraint\") ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : plasmaSearchQuery.catchall_constraint;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield();\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        final boolean offline = yacyCore.seedDB.mySeed.isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (count <= 10)) count = 30;\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if (post.get(\"cat\", \"href\").equals(\"href\")) {\r\n\r\n        final TreeSet[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n        // filter out stopwords\r\n        final TreeSet filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n        if (filtered.size() > 0) {\r\n            kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n        }\r\n\r\n        // if a minus-button was hit, remove a special reference first\r\n        if (post.containsKey(\"deleteref\")) {\r\n            if (!sb.verifyAuthentication(header, true)) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n                \r\n            // delete the index entry locally\r\n            final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n            sb.wordIndex.removeWordReferences(query[0], delHash);\r\n\r\n            // make new news message with negative voting\r\n            HashMap map = new HashMap();\r\n            map.put(\"urlhash\", delHash);\r\n            map.put(\"vote\", \"negative\");\r\n            map.put(\"refid\", \"\");\r\n            yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n        }\r\n\r\n        // if a plus-button was hit, create new voting message\r\n        if (post.containsKey(\"recommendref\")) {\r\n            if (!sb.verifyAuthentication(header, true)) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n            indexURLEntry urlentry = sb.wordIndex.loadedURL.load(recommendHash, null);\r\n            if (urlentry != null) {\r\n                indexURLEntry.Components comp = urlentry.comp();\r\n                plasmaParserDocument document;\r\n                document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true);\r\n                if (document != null) {\r\n                    // create a news message\r\n                    HashMap map = new HashMap();\r\n                    map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                    map.put(\"title\", comp.title().replace(',', ' '));\r\n                    map.put(\"description\", ((document == null) ? comp.title() : document.getTitle()).replace(',', ' '));\r\n                    map.put(\"author\", ((document == null) ? \"\" : document.getAuthor()));\r\n                    map.put(\"tags\", ((document == null) ? \"\" : document.getKeywords(' ')));\r\n                    yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                    document.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        // prepare search properties\r\n        final boolean yacyonline = ((yacyCore.seedDB != null) && (yacyCore.seedDB.mySeed != null) && (yacyCore.seedDB.mySeed.getPublicAddress() != null));\r\n        final boolean globalsearch = (global) && (yacyonline);\r\n        \r\n        // do the search\r\n        TreeSet queryHashes = plasmaCondenser.words2hashes(query[0]);\r\n        plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tplasmaCondenser.words2hashes(query[1]),\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    count,\r\n                    searchtime,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint);\r\n        plasmaSearchRankingProfile ranking = (sb.getConfig(\"rankingProfile\", \"\").length() == 0) ? new plasmaSearchRankingProfile(contentdomCode) : new plasmaSearchRankingProfile(\"\", crypt.simpleDecode(sb.getConfig(\"rankingProfile\", \"\"), null));\r\n        plasmaSearchProcessing localTiming = new plasmaSearchProcessing(4 * theQuery.maximumTime / 10, theQuery.wantedResults);\r\n        plasmaSearchProcessing remoteTiming = new plasmaSearchProcessing(6 * theQuery.maximumTime / 10, theQuery.wantedResults);\r\n\r\n        //**\r\n        //searchFromLocal(thisSearch, ranking, localTiming, remoteTiming, true, (String) header.get(\"CLIENTIP\"))\r\n        String client = (String) header.get(\"CLIENTIP\"); // the search client who initiated the search\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(2 * theQuery.maximumTime);\r\n        \r\n        // filter out words that appear in bluelist\r\n        theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n        // log\r\n        serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.wantedResults + \" links, \" + (theQuery.maximumTime / 1000) + \" seconds\");\r\n        long timestamp = System.currentTimeMillis();\r\n\r\n        // create a new search event\r\n        String wrongregex = null;\r\n        plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, localTiming, remoteTiming, sb.wordIndex, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false, null);\r\n            \r\n        // generate result object\r\n        serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n        ArrayList accu = theSearch.computeResults(plasmaSwitchboard.blueList, true);\r\n        serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n        // calc some more cross-reference\r\n        long remainingTime = theQuery.maximumTime - (System.currentTimeMillis() - timestamp);\r\n        if (remainingTime < 0) remainingTime = 1000;\r\n        //Object[] ws = acc.getReferences(16);\r\n        serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n        // log\r\n        serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getLocalCount() + theSearch.getGlobalCount()) + \" links found, \" +\r\n                    theSearch.filteredCount() + \" links filtered, \" +\r\n                    accu.size() + \" links ordered, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n        // prepare search statistics\r\n        Long trackerHandle = new Long(System.currentTimeMillis());\r\n        HashMap searchProfile = theQuery.resultProfile(accu.size(), System.currentTimeMillis() - timestamp);\r\n        searchProfile.put(\"querystring\", theQuery.queryString);\r\n        searchProfile.put(\"time\", trackerHandle);\r\n        searchProfile.put(\"host\", client);\r\n        searchProfile.put(\"offset\", new Integer(0));\r\n        searchProfile.put(\"results\", accu);\r\n        sb.localSearches.add(searchProfile);\r\n        TreeSet handles = (TreeSet) sb.localSearchTracker.get(client);\r\n        if (handles == null) handles = new TreeSet();\r\n        handles.add(trackerHandle);\r\n        sb.localSearchTracker.put(client, handles);\r\n        \r\n        //prop=sb.searchFromLocal(thisSearch, ranking, localTiming, remoteTiming, true, (String) header.get(\"CLIENTIP\"));\r\n        prop = new serverObjects();\r\n        //prop.put(\"references\", 0);\r\n        prop.put(\"num-results_totalcount\", theSearch.getLocalCount() + theSearch.getGlobalCount());\r\n        prop.put(\"num-results_filteredcount\", theSearch.filteredCount());\r\n        prop.put(\"num-results_orderedcount\", accu.size());\r\n        prop.put(\"num-results_globalresults\", (theSearch.getGlobalCount() == 0) ? 0 : 1);\r\n        prop.put(\"num-results_globalresults_globalcount\", theSearch.getGlobalCount());\r\n        prop.put(\"num-results_linkcount\", 0);\r\n        \r\n        /*\r\n        for (int i = 0; i < theQuery.wantedResults; i++) {\r\n            prop.put(\"type_results_\" + i + \"_item\", i);\r\n            prop.put(\"type_results_\" + i + \"_eventID\", theQuery.id());\r\n        }\r\n        prop.put(\"type_results\", theQuery.wantedResults);\r\n        */\r\n        //------------------------\r\n        \r\n        prop.put(\"type_results\", 0);\r\n        URL wordURL=null;\r\n        for (int i = 0; i < accu.size(); i++) {\r\n            plasmaSearchEvent.Entry result = (plasmaSearchEvent.Entry) accu.get(i);\r\n            prop.put(\"type_results_\" + i + \"_authorized_recommend\", (yacyCore.newsPool.getSpecific(yacyNewsPool.OUTGOING_DB, yacyNewsPool.CATEGORY_SURFTIPP_ADD, \"url\", result.urlstring()) == null) ? 1 : 0);\r\n            prop.put(\"type_results_\" + i + \"_authorized_recommend_deletelink\", \"/yacysearch.html?search=\" + theQuery.queryString + \"&Enter=Search&count=\" + theQuery.wantedResults + \"&order=\" + crypt.simpleEncode(ranking.toExternalString()) + \"&resource=local&time=3&deleteref=\" + result.hash() + \"&urlmaskfilter=.*\");\r\n            prop.put(\"type_results_\" + i + \"_authorized_recommend_recommendlink\", \"/yacysearch.html?search=\" + theQuery.queryString + \"&Enter=Search&count=\" + theQuery.wantedResults + \"&order=\" + crypt.simpleEncode(ranking.toExternalString()) + \"&resource=local&time=3&recommendref=\" + result.hash() + \"&urlmaskfilter=.*\");\r\n            prop.put(\"type_results_\" + i + \"_authorized_urlhash\", result.hash());\r\n            prop.put(\"type_results_\" + i + \"_description\", result.title());\r\n            prop.put(\"type_results_\" + i + \"_url\", result.urlstring());\r\n            int port=result.url().getPort();\r\n            URL faviconURL;\r\n            try {\r\n                faviconURL = new URL(result.url().getProtocol() + \"://\" + result.url().getHost() + ((port != -1) ? (\":\" + String.valueOf(port)) : \"\") + \"/favicon.ico\");\r\n            } catch (MalformedURLException e1) {\r\n                continue;\r\n            }\r\n            prop.put(\"type_results_\" + i + \"_faviconCode\", sb.licensedURLs.aquireLicense(faviconURL)); // aquire license for favicon url loading\r\n            prop.put(\"type_results_\" + i + \"_urlhash\", result.hash());\r\n                prop.put(\"type_results_\" + i + \"_urlhexhash\", yacySeed.b64Hash2hexHash(result.hash()));\r\n                prop.put(\"type_results_\" + i + \"_urlname\", nxTools.shortenURLString(result.urlname(), 120));\r\n                prop.put(\"type_results_\" + i + \"_date\", plasmaSwitchboard.dateString(result.modified()));\r\n                prop.put(\"type_results_\" + i + \"_ybr\", plasmaSearchPreOrder.ybr(result.hash()));\r\n                prop.put(\"type_results_\" + i + \"_size\", Long.toString(result.filesize()));\r\n                try {\r\n                    prop.put(\"type_results_\" + i + \"_words\", URLEncoder.encode(query[0].toString(),\"UTF-8\"));\r\n                } catch (UnsupportedEncodingException e) {}\r\n                prop.put(\"type_results_\" + i + \"_former\", querystring);\r\n                prop.put(\"type_results_\" + i + \"_rankingprops\", result.word().toPropertyForm() + \", domLengthEstimated=\" + plasmaURL.domLengthEstimation(result.hash()) +\r\n                        ((plasmaURL.probablyRootURL(result.hash())) ? \", probablyRootURL\" : \"\") + \r\n                        (((wordURL = plasmaURL.probablyWordURL(result.hash(), query[0])) != null) ? \", probablyWordURL=\" + wordURL.toNormalform(false, true) : \"\"));\r\n                // adding snippet if available\r\n                if (result.hasSnippet()) {\r\n                    prop.put(\"type_results_\" + i + \"_snippet\", 1);\r\n                    prop.putASIS(\"type_results_\" + i + \"_snippet_text\", result.textSnippet().getLineMarked(theQuery.queryHashes));//FIXME: the ASIS should not be needed, if there is no html in .java\r\n                } else {                \t\r\n                \tif (post.containsKey(\"fetchSnippet\")) {\r\n                \t\t// snippet fetch timeout\r\n                        int textsnippet_timeout = Integer.parseInt(env.getConfig(\"timeout_media\", \"10000\"));\r\n                        \r\n                        // boolean line_end_with_punctuation\r\n                        boolean pre = post.get(\"pre\", \"false\").equals(\"true\");\r\n                        \r\n                        // if 'remove' is set to true, then RWI references to URLs that do not have the snippet are removed\r\n                        boolean remove = post.get(\"remove\", \"false\").equals(\"true\");\r\n                        \r\n                        plasmaSnippetCache.TextSnippet snippet = plasmaSnippetCache.retrieveTextSnippet(\r\n                        \t\tresult.url(), \r\n                        \t\tqueryHashes, \r\n                        \t\ttrue, \r\n                        \t\tpre, \r\n                        \t\t260, \r\n                        \t\ttextsnippet_timeout\r\n                        );\r\n                                                \t\r\n                        if (snippet.getErrorCode() < 11) {\r\n                            // no problems occurred\r\n                            //prop.put(\"text\", (snippet.exists()) ? snippet.getLineMarked(queryHashes) : \"unknown\");\r\n                            prop.putASIS(\"type_results_\" + i + \"_snippet_text\", (snippet.exists()) ? snippet.getLineMarked(queryHashes) : \"unknown\");\r\n                        } else {\r\n                            // problems with snippet fetch\r\n                           prop.put(\"type_results_\" + i + \"_snippet_text\", (remove) ? plasmaSnippetCache.failConsequences(snippet, theQuery.id()) : snippet.getError());\r\n                        }          \r\n                        prop.put(\"type_results_\" + i + \"_snippet\", 1);\r\n                \t} else {\r\n                \t\t// no snippet available (will be fetched later via ajax)\r\n                \t\tprop.put(\"type_results_\" + i + \"_snippet\", 0);\r\n                \t\tprop.put(\"type_results_\" + i + \"_snippet_text\", \"\");\r\n                \t}\r\n                }\r\n                prop.put(\"type_results\", accu.size());\r\n                prop.put(\"num-results_linkcount\", Integer.toString(accu.size()));\r\n            }\r\n            \r\n            //------------------------\r\n        \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", 1);\r\n                prop.put(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", 0);\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", 2); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", 1); // no results\r\n                }\r\n            } else {\r\n                final int totalcount = prop.getInt(\"num-results_totalcount\", 0);\r\n                if (totalcount >= 10) {\r\n                    final Object[] references = (Object[]) prop.get( \"references\", new String[0]);\r\n                    prop.put(\"num-results\", 5);\r\n                    int hintcount = references.length;\r\n                    if (hintcount > 0) {\r\n                        prop.put(\"type_combine\", 1);\r\n                        // get the topwords\r\n                        final TreeSet topwords = new TreeSet(kelondroNaturalOrder.naturalOrder);\r\n                        String tmp = \"\";\r\n                        for (int i = 0; i < hintcount; i++) {\r\n                            tmp = (String) references[i];\r\n                            if (tmp.matches(\"[a-z]+\")) {\r\n                                topwords.add(tmp);\r\n                            }\r\n                        }\r\n\r\n                        // filter out the badwords\r\n                        final TreeSet filteredtopwords = kelondroMSetTools.joinConstructive(topwords, plasmaSwitchboard.badwords);\r\n                        if (filteredtopwords.size() > 0) {\r\n                            kelondroMSetTools.excludeDestructive(topwords, plasmaSwitchboard.badwords);\r\n                        }\r\n\r\n                        // avoid stopwords being topwords\r\n                        if (env.getConfig(\"filterOutStopwordsFromTopwords\", \"true\").equals(\"true\")) {\r\n                            if ((plasmaSwitchboard.stopwords != null) && (plasmaSwitchboard.stopwords.size() > 0)) {\r\n                                kelondroMSetTools.excludeDestructive(topwords, plasmaSwitchboard.stopwords);\r\n                            }\r\n                        }\r\n\t\t \t\t\t\t\r\n                        String word;\r\n                        hintcount = 0;\r\n                        final Iterator iter = topwords.iterator();\r\n                        while (iter.hasNext()) {\r\n                            word = (String) iter.next();\r\n                            if (word != null) {\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_word\", word);\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_newsearch\", post.get(\"search\", \"\").replace(' ', '+') + \"+\" + word);\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_count\", count);\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_resource\", ((global) ? \"global\" : \"local\"));\r\n                                prop.put(\"type_combine_words_\" + hintcount + \"_time\", (searchtime / 1000));\r\n                            }\r\n                            prop.put(\"type_combine_words\", hintcount);\r\n                            if (hintcount++ > MAX_TOPWORDS) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (wrongregex != null) {\r\n                        prop.put(\"num-results_wrong_regex\", wrongregex);\r\n                        prop.put(\"num-results\", 4);\r\n                    } else if (totalcount == 0) {\r\n                        prop.put(\"num-results\", 3); // long\r\n                    } else {\r\n                        prop.put(\"num-results\", 5);\r\n                    }\r\n                }\r\n            }\r\n\r\n            prop.put(\"type\", (theQuery.contentdom == plasmaSearchQuery.CONTENTDOM_TEXT) ? 0 : ((theQuery.contentdom == plasmaSearchQuery.CONTENTDOM_IMAGE) ? 2 : 1));\r\n            if (prop.getInt(\"type\", 0) == 1) prop.put(\"type_mediatype\", post.get(\"contentdom\", \"text\"));\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"type_eventID\", theQuery.id()); \r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n\r\n        if (post.get(\"cat\", \"href\").equals(\"image\")) {\r\n\r\n            int depth = post.getInt(\"depth\", 0);\r\n            int columns = post.getInt(\"columns\", 6);\r\n            URL url = null;\r\n            try {url = new URL(post.get(\"url\", \"\"));} catch (MalformedURLException e) {}\r\n            plasmaSearchImages si = new plasmaSearchImages(6000, url, depth);\r\n            Iterator i = si.entries();\r\n            htmlFilterImageEntry ie;\r\n            int line = 0;\r\n            while (i.hasNext()) {\r\n                int col = 0;\r\n                for (col = 0; col < columns; col++) {\r\n                    if (!i.hasNext()) break;\r\n                    ie = (htmlFilterImageEntry) i.next();\r\n                    String urls = ie.url().toString();\r\n                    String name = \"\";\r\n                    int p = urls.lastIndexOf('/');\r\n                    if (p > 0) name = urls.substring(p + 1);\r\n                    prop.put(\"type_results_\" + line + \"_line_\" + col + \"_url\", urls);\r\n                    prop.put(\"type_results_\" + line + \"_line_\" + col + \"_name\", name);\r\n                }\r\n                prop.put(\"type_results_\" + line + \"_line\", col);\r\n                line++;\r\n            }\r\n            prop.put(\"type_results\", line);\r\n\r\n            prop.put(\"type\", 3); // set type of result: image list\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", depth);\r\n        }\r\n\r\n        // if user is not authenticated, he may not vote for URLs\r\n        int linkcount = Integer.parseInt(prop.get(\"num-results_linkcount\", \"0\"));\r\n        for (int i=0; i<linkcount; i++) {\r\n            prop.put(\"type_results_\" + i + \"_authorized\", (authenticated) ? 1 : 0);\r\n        }\r\n        \r\n        prop.put(\"searchagain\", (global) ? 1 : 0);\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.putASIS(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"input_former\", post.get(\"search\", \"\"));\r\n        prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", count);\r\n        prop.put(\"input_resource\", (global) ? \"global\" : \"local\");\r\n        prop.put(\"input_time\", searchtime / 1000);\r\n        prop.put(\"input_urlmaskfilter\", urlmask);\r\n        prop.put(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? 1 : 0);\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? 1 : 0);\r\n        prop.put(\"type_former\", post.get(\"search\", \"\")); //the query-string used to get the snippets\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"f9e6cf6a3d7a82a99eea16baae1d4cba1b03622f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override public void act (float delta) {\r\n\t\tif (actions.size() == 0) {\r\n\t\t\tcurrAction = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tactions.get(currAction).act(delta);\r\n\t\tif (actions.get(currAction).isDone()) {\r\n\t\t\tOnActionCompleted listener = actions.get(currAction).getCompletionListener();\r\n\t\t\tif (listener != null) listener.completed(actions.get(currAction));\r\n\t\t\tactions.get(currAction).setCompletionListener(null);\r\n\t\t\tcurrAction++;\r\n\t\t\tif (currAction < actions.size()) actions.get(currAction).setTarget(target);\r\n\t\t}\r\n\t}","id":84724,"modified_method":"@Override public void act (float delta) {\r\n\t\tif (actions.size() == 0) {\r\n\t\t\tcurrAction = 1;\r\n\t\t\treturn;\r\n\t\t}\t\r\n\t\t\t\t\r\n\t\tif (actions.get(currAction).isDone()) {\r\n\t\t\tOnActionCompleted listener = actions.get(currAction).getCompletionListener();\r\n\t\t\tif (listener != null) listener.completed(actions.get(currAction));\r\n\t\t\tactions.get(currAction).setCompletionListener(null);\r\n\t\t\tcurrAction++;\r\n\t\t\tif (currAction < actions.size()) actions.get(currAction).setTarget(target);\r\n\t\t} \r\n\t\t\r\n\t\tif(currAction < actions.size()) actions.get(currAction).act(delta);\t\t\r\n\t}","commit_id":"fbc6ff221eee3af2f36767e429406ad0623bd7dc","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Makes the standard streams handles 'uninheritable' for the current process.\n     *\n     * @throws ProcessInitializationException when the operation fails\n     */\n    public void uninheritStandardStreams() throws ProcessInitializationException {\n        Kernel32 kernel32 = INSTANCE;\n\n        try {\n            HANDLE stdin = kernel32.GetStdHandle(Kernel32.STD_INPUT_HANDLE);\n            makeUninheritable(kernel32, stdin);\n        \n            HANDLE stdout = kernel32.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);\n            makeUninheritable(kernel32, stdout);\n        \n            HANDLE stderr = kernel32.GetStdHandle(Kernel32.STD_ERROR_HANDLE);\n            makeUninheritable(kernel32, stderr);\n        } catch (Exception e) {\n            throw new ProcessInitializationException(\"Failed to configure the standard stream handles to be 'uninheritable'.\", e);\n        }\n    }","id":84725,"modified_method":"/**\n     * Makes the standard streams handles 'uninheritable' for the current process.\n     *\n     * @throws ProcessInitializationException when the operation fails\n     */\n    public void uninheritStandardStreams() throws ProcessInitializationException {\n        Kernel32 kernel32 = INSTANCE;\n\n        try {\n            uninheritStream(kernel32, Kernel32.STD_INPUT_HANDLE);\n            uninheritStream(kernel32, Kernel32.STD_OUTPUT_HANDLE);\n            uninheritStream(kernel32, Kernel32.STD_ERROR_HANDLE);\n        } catch (Exception e) {\n            throw new ProcessInitializationException(\"Failed to configure the standard stream handles to be 'uninheritable'.\", e);\n        }\n    }","commit_id":"97f93c35794c2006c2dd99058dd8f618931d735d","url":"https://github.com/gradle/gradle"},{"original_method":"private void makeUninheritable(Kernel32 kernel32, HANDLE handle) throws IOException {\n        if (handle.equals(INVALID_HANDLE_VALUE)) {\n            throw new IOException(\"Invalid handle. Errno: \" + kernel32.GetLastError());\n        }\n        boolean ok = kernel32.SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\n        if (!ok && kernel32.GetLastError() != ERROR_INVALID_PARAMETER) {\n            throw new IOException(\"Could not set flag on handle. Errno: \" + kernel32.GetLastError());\n        }\n    }","id":84726,"modified_method":"private void makeUninheritable(Kernel32 kernel32, HANDLE streamHandle) throws IOException {\n        if (streamHandle.equals(INVALID_HANDLE_VALUE)) {\n            throw new IOException(\"Invalid handle. Errno: \" + kernel32.GetLastError());\n        }\n        boolean ok = kernel32.SetHandleInformation(streamHandle, HANDLE_FLAG_INHERIT, 0);\n        if (!ok && kernel32.GetLastError() != ERROR_INVALID_PARAMETER) {\n            throw new IOException(\"Could not set flag on handle. Errno: \" + kernel32.GetLastError());\n        }\n    }","commit_id":"97f93c35794c2006c2dd99058dd8f618931d735d","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        validator.validate(operation);\n\n        final ModelNode opAddr = operation.get(OP_ADDR);\n        PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n        final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : name;\n\n        final byte[] hash;\n        // clone it, so we can modify it to our own content\n        final ModelNode content = operation.require(CONTENT).clone();\n        // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n        final DeploymentHandlerUtil.ContentItem contentItem;\n        final ModelNode contentItemNode = content.require(0);\n        if (contentItemNode.hasDefined(HASH)) {\n            managedContentValidator.validate(contentItemNode);\n            hash = contentItemNode.require(HASH).asBytes();\n            if (!contentRepository.hasContent(hash))\n                throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n            InputStream in = getInputStream(context, contentItemNode);\n            try {\n                try {\n                    hash = contentRepository.addContent(in);\n                } catch (IOException e) {\n                    throw createFailureException(e.toString());\n                }\n\n            } finally {\n                StreamUtils.safeClose(in);\n            }\n            contentItemNode.clear(); // AS7-1029\n            contentItemNode.get(HASH).set(hash);\n            // TODO: remove the content addition stuff?\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else {\n            unmanagedContentValidator.validate(contentItemNode);\n            final String path = contentItemNode.require(PATH).asString();\n            final String relativeTo = asString(contentItemNode, RELATIVE_TO);\n            final boolean archive = contentItemNode.require(ARCHIVE).asBoolean();\n            contentItem = new DeploymentHandlerUtil.ContentItem(path, relativeTo, archive);\n        }\n\n        final Resource resource = context.createResource(PathAddress.EMPTY_ADDRESS);\n        ModelNode subModel = resource.getModel();\n        subModel.get(NAME).set(name);\n        subModel.get(RUNTIME_NAME).set(runtimeName);\n        // content is a clone\n        subModel.get(CONTENT).set(content);\n        subModel.get(ENABLED).set(operation.has(ENABLED) && operation.get(ENABLED).asBoolean()); // TODO consider starting\n        subModel.get(PERSISTENT).set(!operation.hasDefined(PERSISTENT) || operation.get(PERSISTENT).asBoolean());\n\n        if (subModel.get(ENABLED).asBoolean() && (context.getType() == OperationContext.Type.SERVER)) {\n            DeploymentHandlerUtil.deploy(context, runtimeName, name, contentItem);\n        }\n\n        context.completeStep();\n    }","id":84727,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        validator.validate(operation);\n\n        final ModelNode opAddr = operation.get(OP_ADDR);\n        PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n        final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : name;\n\n        final byte[] hash;\n        // clone it, so we can modify it to our own content\n        final ModelNode content = operation.require(CONTENT).clone();\n        // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n        final DeploymentHandlerUtil.ContentItem contentItem;\n        final ModelNode contentItemNode = content.require(0);\n        if (contentItemNode.hasDefined(HASH)) {\n            managedContentValidator.validate(contentItemNode);\n            hash = contentItemNode.require(HASH).asBytes();\n            if (!contentRepository.hasContent(hash)) {\n                ServerMessages.MESSAGES.noSuchDeploymentContent(HashUtil.bytesToHexString(hash));\n            }\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n            InputStream in = getInputStream(context, contentItemNode);\n            try {\n                try {\n                    hash = contentRepository.addContent(in);\n                } catch (IOException e) {\n                    throw createFailureException(e.toString());\n                }\n\n            } finally {\n                StreamUtils.safeClose(in);\n            }\n            contentItemNode.clear(); // AS7-1029\n            contentItemNode.get(HASH).set(hash);\n            // TODO: remove the content addition stuff?\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else {\n            unmanagedContentValidator.validate(contentItemNode);\n            final String path = contentItemNode.require(PATH).asString();\n            final String relativeTo = asString(contentItemNode, RELATIVE_TO);\n            final boolean archive = contentItemNode.require(ARCHIVE).asBoolean();\n            contentItem = new DeploymentHandlerUtil.ContentItem(path, relativeTo, archive);\n        }\n\n        final Resource resource = context.createResource(PathAddress.EMPTY_ADDRESS);\n        ModelNode subModel = resource.getModel();\n        subModel.get(NAME).set(name);\n        subModel.get(RUNTIME_NAME).set(runtimeName);\n        // content is a clone\n        subModel.get(CONTENT).set(content);\n        subModel.get(ENABLED).set(operation.has(ENABLED) && operation.get(ENABLED).asBoolean()); // TODO consider starting\n        subModel.get(PERSISTENT).set(!operation.hasDefined(PERSISTENT) || operation.get(PERSISTENT).asBoolean());\n\n        if (subModel.get(ENABLED).asBoolean() && (context.getType() == OperationContext.Type.SERVER)) {\n            DeploymentHandlerUtil.deploy(context, runtimeName, name, contentItem);\n        }\n\n        context.completeStep();\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n\n        final String name = operation.require(NAME).asString();\n        final PathAddress address = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(DEPLOYMENT, name));\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        boolean exists = root.hasChild(PathElement.pathElement(DEPLOYMENT, name));\n        if (! exists) {\n            throw createFailureException(\"No deployment with name %s found\", name);\n        }\n\n        final ModelNode replaceNode = context.readResourceForUpdate(address).getModel();\n        final String replacedRuntimeName = replaceNode.require(RUNTIME_NAME).asString();\n        final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedRuntimeName;\n\n        final byte[] hash;\n        // clone it, so we can modify it to our own content\n        final ModelNode content = operation.require(CONTENT).clone();\n        // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n        final DeploymentHandlerUtil.ContentItem contentItem;\n        final ModelNode contentItemNode = content.require(0);\n        if (contentItemNode.hasDefined(HASH)) {\n            managedContentValidator.validate(contentItemNode);\n            hash = contentItemNode.require(HASH).asBytes();\n            if (!contentRepository.hasContent(hash))\n                throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n            InputStream in = getInputStream(context, contentItemNode);\n            try {\n                try {\n                    hash = contentRepository.addContent(in);\n                } catch (IOException e) {\n                    throw createFailureException(e.toString());\n                }\n\n            } finally {\n                StreamUtils.safeClose(in);\n            }\n            contentItemNode.clear(); // AS7-1029\n            contentItemNode.get(HASH).set(hash);\n            // TODO: remove the content addition stuff?\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else {\n            unmanagedContentValidator.validate(contentItemNode);\n            final String path = contentItemNode.require(PATH).asString();\n            final String relativeTo = asString(contentItemNode, RELATIVE_TO);\n            final boolean archive = contentItemNode.require(ARCHIVE).asBoolean();\n            contentItem = new DeploymentHandlerUtil.ContentItem(path, relativeTo, archive);\n        }\n\n        boolean start = replaceNode.get(ENABLED).asBoolean();\n\n        final ModelNode deployNode = context.readResourceForUpdate(address).getModel();\n        deployNode.get(NAME).set(name);\n        deployNode.get(RUNTIME_NAME).set(runtimeName);\n        deployNode.get(CONTENT).set(content);\n        deployNode.get(ENABLED).set(start);\n\n        // the content repo will already have these, note that content should not be empty\n        removeContentAdditions(deployNode.require(CONTENT));\n\n        if (start) {\n            DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedRuntimeName, contentItem);\n        }\n        context.completeStep();\n    }","id":84728,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n\n        final String name = operation.require(NAME).asString();\n        final PathAddress address = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(DEPLOYMENT, name));\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        boolean exists = root.hasChild(PathElement.pathElement(DEPLOYMENT, name));\n        if (! exists) {\n            ServerMessages.MESSAGES.noSuchDeployment(name);\n        }\n\n        final ModelNode replaceNode = context.readResourceForUpdate(address).getModel();\n        final String replacedRuntimeName = replaceNode.require(RUNTIME_NAME).asString();\n        final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedRuntimeName;\n\n        final byte[] hash;\n        // clone it, so we can modify it to our own content\n        final ModelNode content = operation.require(CONTENT).clone();\n        // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n        final DeploymentHandlerUtil.ContentItem contentItem;\n        final ModelNode contentItemNode = content.require(0);\n        if (contentItemNode.hasDefined(HASH)) {\n            managedContentValidator.validate(contentItemNode);\n            hash = contentItemNode.require(HASH).asBytes();\n            if (!contentRepository.hasContent(hash)) {\n                ServerMessages.MESSAGES.noSuchDeploymentContent(HashUtil.bytesToHexString(hash));\n            }\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n            InputStream in = getInputStream(context, contentItemNode);\n            try {\n                try {\n                    hash = contentRepository.addContent(in);\n                } catch (IOException e) {\n                    throw createFailureException(e.toString());\n                }\n\n            } finally {\n                StreamUtils.safeClose(in);\n            }\n            contentItemNode.clear(); // AS7-1029\n            contentItemNode.get(HASH).set(hash);\n            // TODO: remove the content addition stuff?\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else {\n            unmanagedContentValidator.validate(contentItemNode);\n            final String path = contentItemNode.require(PATH).asString();\n            final String relativeTo = asString(contentItemNode, RELATIVE_TO);\n            final boolean archive = contentItemNode.require(ARCHIVE).asBoolean();\n            contentItem = new DeploymentHandlerUtil.ContentItem(path, relativeTo, archive);\n        }\n\n        boolean start = replaceNode.get(ENABLED).asBoolean();\n\n        final ModelNode deployNode = context.readResourceForUpdate(address).getModel();\n        deployNode.get(NAME).set(name);\n        deployNode.get(RUNTIME_NAME).set(runtimeName);\n        deployNode.get(CONTENT).set(content);\n        deployNode.get(ENABLED).set(start);\n\n        // the content repo will already have these, note that content should not be empty\n        removeContentAdditions(deployNode.require(CONTENT));\n\n        if (start) {\n            DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedRuntimeName, contentItem);\n        }\n        context.completeStep();\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void deploy(final OperationContext context, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            //\n            final Resource deployment = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = context.getResourceRegistration();\n            final ManagementResourceRegistration mutableRegistration = context.getResourceRegistrationForUpdate();\n\n            DeploymentModelUtils.cleanup(deployment);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n                    final ServiceController<?> deploymentController = serviceRegistry.getService(deploymentUnitServiceName);\n                    if (deploymentController != null) {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        deploymentController.addListener(verificationHandler);\n                        deploymentController.setMode(ServiceController.Mode.ACTIVE);\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            deploymentController.setMode(ServiceController.Mode.NEVER);\n                        }\n                    } else {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, mutableRegistration, contents);\n\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            for(ServiceController<?> controller : controllers) {\n                                context.removeService(controller.getName());\n                            }\n                            if (context.hasFailureDescription()) {\n                                log.infof(\"Deployment of \\\"%s\\\" was rolled back with failure message %s\", deploymentUnitName, context.getFailureDescription().asString());\n                            } else {\n                                log.infof(\"Deployment of \\\"%s\\\" was rolled back with no failure message\", deploymentUnitName);\n                            }\n                        } else {\n                            log.infof(\"Deployed \\\"%s\\\"\", deploymentUnitName);\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":84729,"modified_method":"public static void deploy(final OperationContext context, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            //\n            final Resource deployment = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = context.getResourceRegistration();\n            final ManagementResourceRegistration mutableRegistration = context.getResourceRegistrationForUpdate();\n\n            DeploymentModelUtils.cleanup(deployment);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n                    final ServiceController<?> deploymentController = serviceRegistry.getService(deploymentUnitServiceName);\n                    if (deploymentController != null) {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        deploymentController.addListener(verificationHandler);\n                        deploymentController.setMode(ServiceController.Mode.ACTIVE);\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            deploymentController.setMode(ServiceController.Mode.NEVER);\n                        }\n                    } else {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, mutableRegistration, contents);\n\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            for(ServiceController<?> controller : controllers) {\n                                context.removeService(controller.getName());\n                            }\n                            if (context.hasFailureDescription()) {\n                                ServerLogger.ROOT_LOGGER.undeploymentRolledBack(deploymentUnitName, context.getFailureDescription().asString());\n                            } else {\n                                ServerLogger.ROOT_LOGGER.undeploymentRolledBackWithNoMessage(deploymentUnitName);\n                            }\n                        } else {\n                            ServerLogger.ROOT_LOGGER.deploymentDeployed(deploymentUnitName);\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void redeploy(final OperationContext operationContext, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            //\n            final Resource deployment = operationContext.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = operationContext.getResourceRegistration();\n            final ManagementResourceRegistration mutableRegistration = operationContext.getResourceRegistrationForUpdate();\n\n            DeploymentModelUtils.cleanup(deployment);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    context.addStep(new OperationStepHandler() {\n                        @Override\n                        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                            ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                            doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, mutableRegistration,  contents);\n                            if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                                if (context.hasFailureDescription()) {\n                                    log.infof(\"Redeploy of deployment \\\"%s\\\" was rolled back with failure message %s\",\n                                            deploymentUnitName, context.getFailureDescription().asString());\n                                } else {\n                                    log.infof(\"Redeploy of deployment \\\"%s\\\" was rolled back with no failure message\",\n                                            deploymentUnitName);\n                                }\n                            } else {\n                                log.infof(\"Redeployed \\\"%s\\\"\", deploymentUnitName);\n                            }\n                        }\n                    }, OperationContext.Stage.IMMEDIATE);\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        // TODO restore\n                        if (context.hasFailureDescription()) {\n                            log.infof(\"Undeploy of deployment \\\"%s\\\" was rolled back with failure message %s\",\n                                    deploymentUnitName, context.getFailureDescription().asString());\n                        } else {\n                            log.infof(\"Undeploy of deployment \\\"%s\\\" was rolled back with no failure message\",\n                                    deploymentUnitName);\n                        }\n                    } else {\n                        log.infof(\"Undeployed \\\"%s\\\"\", deploymentUnitName);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        operationContext.completeStep();\n    }","id":84730,"modified_method":"public static void redeploy(final OperationContext operationContext, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            //\n            final Resource deployment = operationContext.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = operationContext.getResourceRegistration();\n            final ManagementResourceRegistration mutableRegistration = operationContext.getResourceRegistrationForUpdate();\n\n            DeploymentModelUtils.cleanup(deployment);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    context.addStep(new OperationStepHandler() {\n                        @Override\n                        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                            ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                            doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, mutableRegistration,  contents);\n                            if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                                if (context.hasFailureDescription()) {\n                                    ServerLogger.ROOT_LOGGER.redeployRolledBack(deploymentUnitName, context.getFailureDescription().asString());\n                                } else {\n                                    ServerLogger.ROOT_LOGGER.redeployRolledBackWithNoMessage(deploymentUnitName);\n                                }\n                            } else {\n                                ServerLogger.ROOT_LOGGER.deploymentRedeployed(deploymentUnitName);\n                            }\n                        }\n                    }, OperationContext.Stage.IMMEDIATE);\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        // TODO restore\n                        if (context.hasFailureDescription()) {\n                            ServerLogger.ROOT_LOGGER.undeploymentRolledBack(deploymentUnitName, context.getFailureDescription().asString());\n                        } else {\n                            ServerLogger.ROOT_LOGGER.undeploymentRolledBackWithNoMessage(deploymentUnitName);\n                        }\n                    } else {\n                        ServerLogger.ROOT_LOGGER.deploymentUndeployed(deploymentUnitName);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        operationContext.completeStep();\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void undeploy(final OperationContext context, final String deploymentUnitName) {\n        if (context.getType() == OperationContext.Type.SERVER) {\n            final Resource deployment = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = context.getResourceRegistration();\n            final ManagementResourceRegistration mutableRegistration = context.getResourceRegistrationForUpdate();\n            DeploymentModelUtils.cleanup(deployment);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n                        final String name = model.require(NAME).asString();\n                        final String runtimeName = model.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(model.require(CONTENT));\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, deployment, registration, mutableRegistration, contents);\n\n                        if (context.hasFailureDescription()) {\n                            log.infof(\"Undeploy of deployment \\\"%s\\\" was rolled back with failure message %s\",\n                                    deploymentUnitName, context.getFailureDescription().asString());\n                        } else {\n                            log.infof(\"Undeploy of deployment \\\"%s\\\" was rolled back with no failure message\",\n                                    deploymentUnitName);\n                        }\n                    } else {\n                        log.infof(\"Undeployed \\\"%s\\\"\", deploymentUnitName);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":84731,"modified_method":"public static void undeploy(final OperationContext context, final String deploymentUnitName) {\n        if (context.getType() == OperationContext.Type.SERVER) {\n            final Resource deployment = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = context.getResourceRegistration();\n            final ManagementResourceRegistration mutableRegistration = context.getResourceRegistrationForUpdate();\n            DeploymentModelUtils.cleanup(deployment);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n                        final String name = model.require(NAME).asString();\n                        final String runtimeName = model.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(model.require(CONTENT));\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, deployment, registration, mutableRegistration, contents);\n\n                        if (context.hasFailureDescription()) {\n                            ServerLogger.ROOT_LOGGER.undeploymentRolledBack(deploymentUnitName, context.getFailureDescription().asString());\n                        } else {\n                            ServerLogger.ROOT_LOGGER.undeploymentRolledBackWithNoMessage(deploymentUnitName);\n                        }\n                    } else {\n                        ServerLogger.ROOT_LOGGER.deploymentUndeployed(deploymentUnitName);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void replace(final OperationContext operationContext, final ModelNode originalDeployment, final String deploymentUnitName, final String managementName,\n                               final String replacedDeploymentUnitName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            //\n            final PathElement path = PathElement.pathElement(DEPLOYMENT, managementName);\n            final Resource deployment = operationContext.readResourceForUpdate(PathAddress.EMPTY_ADDRESS.append(path));\n            final ImmutableManagementResourceRegistration registration = operationContext.getResourceRegistration().getSubModel(PathAddress.EMPTY_ADDRESS.append(path));\n            final ManagementResourceRegistration mutableRegistration = operationContext.getResourceRegistrationForUpdate().getSubModel(PathAddress.EMPTY_ADDRESS.append(path));\n\n            DeploymentModelUtils.cleanup(deployment);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName replacedDeploymentUnitServiceName = Services.deploymentUnitName(replacedDeploymentUnitName);\n                    final ServiceName replacedContentsServiceName = replacedDeploymentUnitServiceName.append(\"contents\");\n                    operationContext.removeService(replacedContentsServiceName);\n                    operationContext.removeService(replacedDeploymentUnitServiceName);\n\n                    ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, mutableRegistration, contents);\n                    context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        for(ServiceController<?> controller : controllers) {\n                            context.removeService(controller.getName());\n                        }\n\n                        DeploymentModelUtils.cleanup(deployment);\n                        final String name = originalDeployment.require(NAME).asString();\n                        final String runtimeName = originalDeployment.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(originalDeployment.require(CONTENT));\n                        verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, deployment, registration, mutableRegistration, contents);\n\n                        if (context.hasFailureDescription()) {\n                            log.infof(\"Replacement of deployment \\\"%s\\\" by deployment \\\"%s\\\" was rolled back with failure message %s\",\n                                    replacedDeploymentUnitName, deploymentUnitName, context.getFailureDescription().asString());\n                        } else {\n                            log.infof(\"Replacement of deployment \\\"%s\\\" by deployment \\\"%s\\\" was rolled back with no failure message\",\n                                    replacedDeploymentUnitName, deploymentUnitName);\n                        }\n                    } else {\n                        log.infof(\"Replaced deployment \\\"%s\\\" with deployment \\\"%s\\\"\", replacedDeploymentUnitName, deploymentUnitName);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":84732,"modified_method":"public static void replace(final OperationContext operationContext, final ModelNode originalDeployment, final String deploymentUnitName, final String managementName,\n                               final String replacedDeploymentUnitName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            //\n            final PathElement path = PathElement.pathElement(DEPLOYMENT, managementName);\n            final Resource deployment = operationContext.readResourceForUpdate(PathAddress.EMPTY_ADDRESS.append(path));\n            final ImmutableManagementResourceRegistration registration = operationContext.getResourceRegistration().getSubModel(PathAddress.EMPTY_ADDRESS.append(path));\n            final ManagementResourceRegistration mutableRegistration = operationContext.getResourceRegistrationForUpdate().getSubModel(PathAddress.EMPTY_ADDRESS.append(path));\n\n            DeploymentModelUtils.cleanup(deployment);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName replacedDeploymentUnitServiceName = Services.deploymentUnitName(replacedDeploymentUnitName);\n                    final ServiceName replacedContentsServiceName = replacedDeploymentUnitServiceName.append(\"contents\");\n                    operationContext.removeService(replacedContentsServiceName);\n                    operationContext.removeService(replacedDeploymentUnitServiceName);\n\n                    ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, mutableRegistration, contents);\n                    context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        for(ServiceController<?> controller : controllers) {\n                            context.removeService(controller.getName());\n                        }\n\n                        DeploymentModelUtils.cleanup(deployment);\n                        final String name = originalDeployment.require(NAME).asString();\n                        final String runtimeName = originalDeployment.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(originalDeployment.require(CONTENT));\n                        verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, deployment, registration, mutableRegistration, contents);\n\n                        if (context.hasFailureDescription()) {\n                            ServerLogger.ROOT_LOGGER.replaceRolledBack(replacedDeploymentUnitName, deploymentUnitName, context.getFailureDescription().asString());\n                        } else {\n                            ServerLogger.ROOT_LOGGER.replaceRolledBackWithNoMessage(replacedDeploymentUnitName, deploymentUnitName);\n                        }\n                    } else {\n                        ServerLogger.ROOT_LOGGER.deploymentReplaced(replacedDeploymentUnitName, deploymentUnitName);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);\n        final List<byte[]> removedHashes = DeploymentUtils.getDeploymentHash(resource);\n\n        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n\n        context.removeResource(PathAddress.EMPTY_ADDRESS);\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    String deploymentUnitName = null;\n\n                    boolean enabled = model.hasDefined(ENABLED) ? model.get(ENABLED).asBoolean() : true;\n                    if (enabled) {\n                        final ModelNode opAddr = operation.get(OP_ADDR);\n                        final PathAddress address = PathAddress.pathAddress(opAddr);\n                        final String name = address.getLastElement().getValue();\n                        deploymentUnitName = model.hasDefined(RUNTIME_NAME) ? model.get(RUNTIME_NAME).asString() : name;\n                        final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                        context.removeService(deploymentUnitServiceName);\n                        context.removeService(deploymentUnitServiceName.append(\"contents\"));\n                    }\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        recoverServices(context, operation, model);\n\n                        if (enabled && context.hasFailureDescription()) {\n                            log.infof(\"Undeploy of deployment \\\"%s\\\" was rolled back with failure message %s\",\n                                    deploymentUnitName, context.getFailureDescription().asString());\n                        } else if (enabled) {\n                            log.infof(\"Undeploy of deployment \\\"%s\\\" was rolled back with no failure message\",\n                                    deploymentUnitName);\n                        }\n                    } else {\n                        if (enabled) {\n                            log.infof(\"Undeployed \\\"%s\\\"\", deploymentUnitName);\n                        }\n                        if (standalone) {\n                            for (byte[] hash : removedHashes) {\n                                try {\n                                    contentRepository.removeContent(hash);\n                                } catch (Exception e) {\n                                    //TODO\n                                    log.infof(e, \"Exception occurred removing %s\", hash);\n                                }\n                            }\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":84733,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);\n        final List<byte[]> removedHashes = DeploymentUtils.getDeploymentHash(resource);\n\n        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n\n        context.removeResource(PathAddress.EMPTY_ADDRESS);\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    String deploymentUnitName = null;\n\n                    boolean enabled = model.hasDefined(ENABLED) ? model.get(ENABLED).asBoolean() : true;\n                    if (enabled) {\n                        final ModelNode opAddr = operation.get(OP_ADDR);\n                        final PathAddress address = PathAddress.pathAddress(opAddr);\n                        final String name = address.getLastElement().getValue();\n                        deploymentUnitName = model.hasDefined(RUNTIME_NAME) ? model.get(RUNTIME_NAME).asString() : name;\n                        final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                        context.removeService(deploymentUnitServiceName);\n                        context.removeService(deploymentUnitServiceName.append(\"contents\"));\n                    }\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        recoverServices(context, operation, model);\n\n                        if (enabled && context.hasFailureDescription()) {\n                            ServerLogger.ROOT_LOGGER.undeploymentRolledBack(deploymentUnitName, context.getFailureDescription().asString());\n                        } else if (enabled) {\n                            ServerLogger.ROOT_LOGGER.undeploymentRolledBackWithNoMessage(deploymentUnitName);\n                        }\n                    } else {\n                        if (enabled) {\n                            ServerLogger.ROOT_LOGGER.deploymentUndeployed(deploymentUnitName);\n                        }\n                        if (standalone) {\n                            for (byte[] hash : removedHashes) {\n                                try {\n                                    contentRepository.removeContent(hash);\n                                } catch (Exception e) {\n                                    //TODO\n                                    log.infof(e, \"Exception occurred removing %s\", hash);\n                                }\n                            }\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        validator.validate(operation);\n\n        String name = operation.require(NAME).asString();\n        String toReplace = operation.require(TO_REPLACE).asString();\n\n        if (name.equals(toReplace)) {\n            throw operationFailed(String.format(\"Cannot use %s with the same value for parameters %s and %s. \" +\n                    \"Use %s to redeploy the same content or %s to replace content with a new version with the same name.\",\n                    OPERATION_NAME, NAME, TO_REPLACE, DeploymentRedeployHandler.OPERATION_NAME,\n                    DeploymentFullReplaceHandler.OPERATION_NAME));\n        }\n\n        final PathElement deployPath = PathElement.pathElement(DEPLOYMENT, name);\n        final PathElement replacePath = PathElement.pathElement(DEPLOYMENT, toReplace);\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        if (! root.hasChild(replacePath)) {\n            throw operationFailed(String.format(\"No deployment with name %s found\", toReplace));\n        }\n\n        final ModelNode replaceNode = context.readResourceForUpdate(PathAddress.pathAddress(replacePath)).getModel();\n        final String replacedName = replaceNode.require(RUNTIME_NAME).asString();\n\n        ModelNode deployNode;\n        String runtimeName;\n        if (!root.hasChild(deployPath)) {\n            if (!operation.hasDefined(CONTENT)) {\n                throw operationFailed(String.format(\"No deployment with name %s found\", name));\n            }\n            // else -- the HostController handles a server group replace-deployment like an add, so we do too\n\n            // clone it, so we can modify it to our own content\n            final ModelNode content = operation.require(CONTENT).clone();\n            // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n            final ModelNode contentItemNode = content.require(0);\n            if (contentItemNode.hasDefined(HASH)) {\n                managedContentValidator.validate(contentItemNode);\n                byte[] hash = contentItemNode.require(HASH).asBytes();\n                if (!contentRepository.hasContent(hash))\n                    throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            } else {\n                unmanagedContentValidator.validate(contentItemNode);\n            }\n            runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedName;\n\n            // Create the resource\n            final Resource deployResource = context.createResource(PathAddress.pathAddress(deployPath));\n            deployNode = deployResource.getModel();\n            deployNode.get(RUNTIME_NAME).set(runtimeName);\n            deployNode.get(CONTENT).set(content);\n\n        } else {\n            deployNode = context.readResourceForUpdate(PathAddress.pathAddress(deployPath)).getModel();\n            if (deployNode.get(ENABLED).asBoolean()) {\n                throw operationFailed(String.format(\"Deployment %s is already started\", toReplace));\n            }\n            runtimeName = deployNode.require(RUNTIME_NAME).asString();\n        }\n\n        deployNode.get(ENABLED).set(true);\n        replaceNode.get(ENABLED).set(false);\n\n        final DeploymentHandlerUtil.ContentItem[] contents = getContents(deployNode.require(CONTENT));\n        DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedName, contents);\n\n        context.completeStep();\n    }","id":84734,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        validator.validate(operation);\n\n        String name = operation.require(NAME).asString();\n        String toReplace = operation.require(TO_REPLACE).asString();\n\n        if (name.equals(toReplace)) {\n            throw ServerMessages.MESSAGES.cannotReplaceDeployment(OPERATION_NAME, NAME, TO_REPLACE,\n                    DeploymentRedeployHandler.OPERATION_NAME, DeploymentFullReplaceHandler.OPERATION_NAME);\n        }\n\n        final PathElement deployPath = PathElement.pathElement(DEPLOYMENT, name);\n        final PathElement replacePath = PathElement.pathElement(DEPLOYMENT, toReplace);\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        if (! root.hasChild(replacePath)) {\n            throw ServerMessages.MESSAGES.noSuchDeployment(toReplace);\n        }\n\n        final ModelNode replaceNode = context.readResourceForUpdate(PathAddress.pathAddress(replacePath)).getModel();\n        final String replacedName = replaceNode.require(RUNTIME_NAME).asString();\n\n        ModelNode deployNode;\n        String runtimeName;\n        if (!root.hasChild(deployPath)) {\n            if (!operation.hasDefined(CONTENT)) {\n                throw ServerMessages.MESSAGES.noSuchDeployment(name);\n            }\n            // else -- the HostController handles a server group replace-deployment like an add, so we do too\n\n            // clone it, so we can modify it to our own content\n            final ModelNode content = operation.require(CONTENT).clone();\n            // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n            final ModelNode contentItemNode = content.require(0);\n            if (contentItemNode.hasDefined(HASH)) {\n                managedContentValidator.validate(contentItemNode);\n                byte[] hash = contentItemNode.require(HASH).asBytes();\n                if (!contentRepository.hasContent(hash)) {\n                    ServerMessages.MESSAGES.noSuchDeploymentContent(HashUtil.bytesToHexString(hash));\n                }\n            } else {\n                unmanagedContentValidator.validate(contentItemNode);\n            }\n            runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedName;\n\n            // Create the resource\n            final Resource deployResource = context.createResource(PathAddress.pathAddress(deployPath));\n            deployNode = deployResource.getModel();\n            deployNode.get(RUNTIME_NAME).set(runtimeName);\n            deployNode.get(CONTENT).set(content);\n\n        } else {\n            deployNode = context.readResourceForUpdate(PathAddress.pathAddress(deployPath)).getModel();\n            if (deployNode.get(ENABLED).asBoolean()) {\n                throw ServerMessages.MESSAGES.deploymentAlreadyStarted(toReplace);\n            }\n            runtimeName = deployNode.require(RUNTIME_NAME).asString();\n        }\n\n        deployNode.get(ENABLED).set(true);\n        replaceNode.get(ENABLED).set(false);\n\n        final DeploymentHandlerUtil.ContentItem[] contents = getContents(deployNode.require(CONTENT));\n        DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedName, contents);\n\n        context.completeStep();\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        ProtocolChannelClient client;\n        try {\n            ProtocolChannelClient.Configuration configuration = new ProtocolChannelClient.Configuration();\n            configuration.setEndpoint(endpointInjector.getValue());\n            configuration.setUri(new URI(\"remote://\" + hcAddressInjector.getValue().getHostName() + \":\" + hcAddressInjector.getValue().getPort()));\n            client = ProtocolChannelClient.create(configuration);\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n\n        try {\n            connection = client.connectSync(new ClientCallbackHandler());\n            channel = connection.openChannel(ManagementRemotingServices.SERVER_CHANNEL, OptionMap.EMPTY).get();\n            // channel.startReceiving();\n        } catch (IOException e) {\n            throw new StartException(\"Failed to start remote Host Controller connection\", e);\n        }\n    }","id":84735,"modified_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        ProtocolChannelClient client;\n        try {\n            ProtocolChannelClient.Configuration configuration = new ProtocolChannelClient.Configuration();\n            configuration.setEndpoint(endpointInjector.getValue());\n            configuration.setUri(new URI(\"remote://\" + hcAddressInjector.getValue().getHostName() + \":\" + hcAddressInjector.getValue().getPort()));\n            client = ProtocolChannelClient.create(configuration);\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n\n        try {\n            connection = client.connectSync(new ClientCallbackHandler());\n            channel = connection.openChannel(ManagementRemotingServices.SERVER_CHANNEL, OptionMap.EMPTY).get();\n        } catch (IOException e) {\n            throw ServerMessages.MESSAGES.failedToConnectToHC(e);\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void stop(StopContext context) {\n        final ManagementMessageHandler handler = this.handler;\n        if(handler != null) {\n            handler.shutdown();\n            try {\n                handler.awaitCompletion(100, TimeUnit.MILLISECONDS);\n            } catch (Exception e) {\n                ControllerLogger.ROOT_LOGGER.warnf(e , \"service shutdown did not complete\");\n            } finally {\n                handler.shutdownNow();\n            }\n        }\n    }","id":84736,"modified_method":"/** {@inheritDoc} */\n    public synchronized void stop(StopContext context) {\n        final ManagementMessageHandler handler = this.handler;\n        if(handler != null) {\n            handler.shutdown();\n            try {\n                if(! handler.awaitCompletion(100, TimeUnit.MILLISECONDS)) {\n                    ControllerLogger.ROOT_LOGGER.debugf(\"HostController server client did not complete shutdown within timeout\");\n                }\n            } catch (Exception e) {\n                ControllerLogger.ROOT_LOGGER.warnf(e , \"service shutdown did not complete\");\n            } finally {\n                handler.shutdownNow();\n            }\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void start(final StartContext context) throws StartException {\n        final Channel channel = hcChannel.getValue();\n        final HostControllerServerHandler handler = new HostControllerServerHandler(controller.getValue(), executor);\n        channel.addCloseHandler(new CloseHandler<Channel>() {\n            @Override\n            public void handleClose(final Channel closed, final IOException exception) {\n                handler.shutdownNow();\n            }\n        });\n        // Notify MSC asynchronously when the server gets registered\n        context.asynchronous();\n        try {\n            handler.executeRegistrationRequest(channel, new ServerRegisterRequest(), context);\n        } catch (Exception e) {\n            throw new StartException(\"Failed to send registration message to host controller\", e);\n        }\n        this.handler = handler;\n        channel.receiveMessage(ManagementChannelReceiver.createDelegating(handler));\n    }","id":84737,"modified_method":"/** {@inheritDoc} */\n    public synchronized void start(final StartContext context) throws StartException {\n        final Channel channel = hcChannel.getValue();\n        final HostControllerServerHandler handler = new HostControllerServerHandler(controller.getValue(), executor);\n        channel.addCloseHandler(new CloseHandler<Channel>() {\n            @Override\n            public void handleClose(final Channel closed, final IOException exception) {\n                handler.shutdownNow();\n            }\n        });\n        // Notify MSC asynchronously when the server gets registered\n        context.asynchronous();\n        try {\n            handler.executeRegistrationRequest(channel, new ServerRegisterRequest(), context);\n        } catch (Exception e) {\n            throw ServerMessages.MESSAGES.failedToConnectToHC(e);\n        }\n        this.handler = handler;\n        channel.receiveMessage(ManagementChannelReceiver.createDelegating(handler));\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Starts the service.\n     *\n     * @param context The start context\n     * @throws StartException If any errors occur\n     */\n    public synchronized void start(StartContext context) throws StartException {\n        final ModelController modelController = modelControllerValue.getValue();\n        final ExecutorService executorService = executorServiceValue.getValue();\n        final ModelControllerClient modelControllerClient = modelController.createClient(executorService);\n        socketBindingManager = injectedSocketBindingManager.getOptionalValue();\n\n        final SecurityRealmService securityRealmService = securityRealmServiceValue.getOptionalValue();\n\n        InetSocketAddress bindAddress = null;\n        InetSocketAddress secureBindAddress = null;\n\n        SocketBinding basicBinding = injectedSocketBindingValue.getOptionalValue();\n        SocketBinding secureBinding = injectedSecureSocketBindingValue.getOptionalValue();\n        final NetworkInterfaceBinding interfaceBinding = interfaceBindingValue.getOptionalValue();\n        if (interfaceBinding != null) {\n            useUnmanagedBindings = true;\n            final int port = portValue.getOptionalValue();\n            if (port > 0) {\n                bindAddress = new InetSocketAddress(interfaceBinding.getAddress(), port);\n            }\n            final int securePort = securePortValue.getOptionalValue();\n            if (securePort > 0) {\n                secureBindAddress = new InetSocketAddress(interfaceBinding.getAddress(), securePort);\n            }\n        } else {\n            if (basicBinding != null) {\n                bindAddress = basicBinding.getSocketAddress();\n            }\n            if (secureBinding != null) {\n                secureBindAddress = secureBinding.getSocketAddress();\n            }\n        }\n\n        try {\n            serverManagement = ManagementHttpServer.create(bindAddress, secureBindAddress, 50, modelControllerClient, executorService, securityRealmService, consoleMode);\n            serverManagement.start();\n\n            // Register the now-created sockets with the SBM\n            if (socketBindingManager != null) {\n                if (useUnmanagedBindings) {\n                    SocketBindingManager.UnnamedBindingRegistry registry = socketBindingManager.getUnnamedRegistry();\n                    if (bindAddress != null) {\n                        basicManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(\"management-http\", bindAddress, null);\n                        registry.registerBinding(basicManagedBinding);\n                    }\n                    if (secureBindAddress != null) {\n                        secureManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(\"management-https\", secureBindAddress, null);\n                        registry.registerBinding(secureManagedBinding);\n                    }\n                } else {\n                    SocketBindingManager.NamedManagedBindingRegistry registry = socketBindingManager.getNamedRegistry();\n                    if (basicBinding != null) {\n                        basicManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(basicBinding);\n                        registry.registerBinding(basicManagedBinding);\n                    }\n                    if (secureBinding != null) {\n                        secureManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(secureBinding);\n                        registry.registerBinding(secureManagedBinding);\n                    }\n                }\n            }\n        } catch (BindException e) {\n            final StringBuilder sb = new StringBuilder().append(e.getMessage());\n            if (bindAddress != null)\n                sb.append(\" \").append(bindAddress);\n            if (secureBindAddress != null)\n                sb.append(\" \").append(secureBindAddress);\n            throw new StartException(sb.toString(), e);\n        } catch (Exception e) {\n            throw new StartException(\"Failed to start serverManagement socket\", e);\n        }\n    }","id":84738,"modified_method":"/**\n     * Starts the service.\n     *\n     * @param context The start context\n     * @throws StartException If any errors occur\n     */\n    public synchronized void start(StartContext context) throws StartException {\n        final ModelController modelController = modelControllerValue.getValue();\n        final ExecutorService executorService = executorServiceValue.getValue();\n        final ModelControllerClient modelControllerClient = modelController.createClient(executorService);\n        socketBindingManager = injectedSocketBindingManager.getOptionalValue();\n\n        final SecurityRealmService securityRealmService = securityRealmServiceValue.getOptionalValue();\n\n        InetSocketAddress bindAddress = null;\n        InetSocketAddress secureBindAddress = null;\n\n        SocketBinding basicBinding = injectedSocketBindingValue.getOptionalValue();\n        SocketBinding secureBinding = injectedSecureSocketBindingValue.getOptionalValue();\n        final NetworkInterfaceBinding interfaceBinding = interfaceBindingValue.getOptionalValue();\n        if (interfaceBinding != null) {\n            useUnmanagedBindings = true;\n            final int port = portValue.getOptionalValue();\n            if (port > 0) {\n                bindAddress = new InetSocketAddress(interfaceBinding.getAddress(), port);\n            }\n            final int securePort = securePortValue.getOptionalValue();\n            if (securePort > 0) {\n                secureBindAddress = new InetSocketAddress(interfaceBinding.getAddress(), securePort);\n            }\n        } else {\n            if (basicBinding != null) {\n                bindAddress = basicBinding.getSocketAddress();\n            }\n            if (secureBinding != null) {\n                secureBindAddress = secureBinding.getSocketAddress();\n            }\n        }\n\n        try {\n            serverManagement = ManagementHttpServer.create(bindAddress, secureBindAddress, 50, modelControllerClient, executorService, securityRealmService, consoleMode);\n            serverManagement.start();\n\n            // Register the now-created sockets with the SBM\n            if (socketBindingManager != null) {\n                if (useUnmanagedBindings) {\n                    SocketBindingManager.UnnamedBindingRegistry registry = socketBindingManager.getUnnamedRegistry();\n                    if (bindAddress != null) {\n                        basicManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(\"management-http\", bindAddress, null);\n                        registry.registerBinding(basicManagedBinding);\n                    }\n                    if (secureBindAddress != null) {\n                        secureManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(\"management-https\", secureBindAddress, null);\n                        registry.registerBinding(secureManagedBinding);\n                    }\n                } else {\n                    SocketBindingManager.NamedManagedBindingRegistry registry = socketBindingManager.getNamedRegistry();\n                    if (basicBinding != null) {\n                        basicManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(basicBinding);\n                        registry.registerBinding(basicManagedBinding);\n                    }\n                    if (secureBinding != null) {\n                        secureManagedBinding = ManagedBinding.Factory.createSimpleManagedBinding(secureBinding);\n                        registry.registerBinding(secureManagedBinding);\n                    }\n                }\n            }\n        } catch (BindException e) {\n            final StringBuilder sb = new StringBuilder().append(e.getMessage());\n            if (bindAddress != null)\n                sb.append(\" \").append(bindAddress);\n            if (secureBindAddress != null)\n                sb.append(\" \").append(secureBindAddress);\n            throw new StartException(sb.toString(), e);\n        } catch (Exception e) {\n            throw ServerMessages.MESSAGES.failedToStartHttpManagementService(e);\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Loop through associated criteria and build a unique address as follows: 1. Iterate through all criteria, returning\n         * null if any criteria return a null result from\n         * {@linkplain #isAcceptable(java.net.NetworkInterface, java.net.InetAddress)}. 2. Collect the accepted addressed into a\n         * Set. 3. If the set contains a single address, this is returned as the criteria match. 4. If there are more than 2\n         * addresses, log a warning and return null to indicate no match was agreed on. 5. If there are 2 addresses, remove the\n         * input address and if the resulting set has only one address, return it as the criteria match. Otherwise, log a\n         * warning indicating 2 unique criteria addresses were seen and return null to indicate no match was agreed on.\n         *\n         * @return the unique address determined by the all criteria, null if no such address was found\n         * @throws SocketException\n         */\n        @Override\n        public InetAddress isAcceptable(NetworkInterface networkInterface, InetAddress address) throws SocketException {\n            // Build up a set of unique addresses from the criteria\n            HashSet<InetAddress> addresses = new HashSet<InetAddress>();\n            for (InterfaceCriteria criteria : interfaceCriteria) {\n                InetAddress bindAddress = criteria.isAcceptable(networkInterface, address);\n                if (bindAddress == null) {\n                    log.debugf(\"Criteria(%s) failed to accept input\\n\", criteria);\n                    return null;\n                }\n                log.tracef(\"%s accepted input, provided bind address: %s\", criteria, bindAddress);\n                addresses.add(bindAddress);\n            }\n            log.debugf(\"Candidate accepted addresses are: %s\\n\", addresses);\n            // Determine which address to return\n            InetAddress bindAddress = null;\n            if (addresses.size() > 0) {\n                log.tracef(\"Determining unique address from among: %s\\n\", addresses.toString());\n                if (addresses.size() == 1)\n                    bindAddress = addresses.iterator().next();\n                else {\n                    // Remove the input address and see if non-unique addresses exist\n                    if (addresses.size() > 2)\n                        log.warnf(\"More than two unique criteria addresses were seen: %s\\n\", addresses.toString());\n                    else {\n                        log.warnf(\"Checking two unique criteria addresses were seen: %s\\n\", addresses.toString());\n                        addresses.remove(address);\n                        if (addresses.size() == 1)\n                            bindAddress = addresses.iterator().next();\n                        else\n                            log.warnf(\"Two unique criteria addresses were seen: %s\\n\", addresses.toString());\n                    }\n                }\n            }\n            return bindAddress;\n        }","id":84739,"modified_method":"/**\n         * Loop through associated criteria and build a unique address as follows: 1. Iterate through all criteria, returning\n         * null if any criteria return a null result from\n         * {@linkplain #isAcceptable(java.net.NetworkInterface, java.net.InetAddress)}. 2. Collect the accepted addressed into a\n         * Set. 3. If the set contains a single address, this is returned as the criteria match. 4. If there are more than 2\n         * addresses, log a warning and return null to indicate no match was agreed on. 5. If there are 2 addresses, remove the\n         * input address and if the resulting set has only one address, return it as the criteria match. Otherwise, log a\n         * warning indicating 2 unique criteria addresses were seen and return null to indicate no match was agreed on.\n         *\n         * @return the unique address determined by the all criteria, null if no such address was found\n         * @throws SocketException\n         */\n        @Override\n        public InetAddress isAcceptable(NetworkInterface networkInterface, InetAddress address) throws SocketException {\n            // Build up a set of unique addresses from the criteria\n            HashSet<InetAddress> addresses = new HashSet<InetAddress>();\n            for (InterfaceCriteria criteria : interfaceCriteria) {\n                InetAddress bindAddress = criteria.isAcceptable(networkInterface, address);\n                if (bindAddress == null) {\n                    log.debugf(\"Criteria(%s) failed to accept input\\n\", criteria);\n                    return null;\n                }\n                log.tracef(\"%s accepted input, provided bind address: %s\", criteria, bindAddress);\n                addresses.add(bindAddress);\n            }\n            log.debugf(\"Candidate accepted addresses are: %s\\n\", addresses);\n            // Determine which address to return\n            InetAddress bindAddress = null;\n            if (addresses.size() > 0) {\n                log.tracef(\"Determining unique address from among: %s\\n\", addresses.toString());\n                if (addresses.size() == 1)\n                    bindAddress = addresses.iterator().next();\n                else {\n                    // Remove the input address and see if non-unique addresses exist\n                    if (addresses.size() > 2)\n                        ServerLogger.ROOT_LOGGER.moreThanTwoUniqueCriteria(addresses.toString());\n                    else {\n                        ServerLogger.ROOT_LOGGER.checkingTwoUniqueCriteria(addresses.toString());\n                        addresses.remove(address);\n                        if (addresses.size() == 1)\n                            bindAddress = addresses.iterator().next();\n                        else\n                            ServerLogger.ROOT_LOGGER.twoUniqueCriteriaAddresses(addresses.toString());\n                    }\n                }\n            }\n            return bindAddress;\n        }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void start(StartContext arg0) throws StartException {\n        log.debug(\"Starting NetworkInterfaceService\\n\");\n        try {\n            this.interfaceBinding = createBinding(anyLocalV4, anyLocalV6, anyLocal, criteria);\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n        if (this.interfaceBinding == null) {\n            throw new StartException(\"failed to resolve interface \" + name);\n        }\n        log.debugf(\"NetworkInterfaceService matched interface binding: %s\\n\", interfaceBinding);\n    }","id":84740,"modified_method":"public synchronized void start(StartContext arg0) throws StartException {\n        log.debug(\"Starting NetworkInterfaceService\\n\");\n        try {\n            this.interfaceBinding = createBinding(anyLocalV4, anyLocalV6, anyLocal, criteria);\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n        if (this.interfaceBinding == null) {\n            throw ServerMessages.MESSAGES.failedToResolveInterface(name);\n        }\n        log.debugf(\"NetworkInterfaceService matched interface binding: %s\\n\", interfaceBinding);\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"void stopServers(int gracefulTimeout, boolean blockUntilStopped) {\n        stopped = true;\n        Map<String, ProcessInfo> processInfoMap = determineRunningProcesses();\n        for (String serverProcessName : processInfoMap.keySet()) {\n            if (ManagedServer.isServerProcess(serverProcessName)) {\n                String serverName = ManagedServer.getServerName(serverProcessName);\n                stopServer(serverName, gracefulTimeout);\n            }\n        }\n\n        if (blockUntilStopped) {\n            synchronized (shutdownCondition) {\n                for (;;) {\n                    int count = 0;\n                    try {\n                        processInfoMap = determineRunningProcesses();\n                    } catch(RuntimeException e) {\n                        // In case the process-controller connection is broken, the PC most likely got killed\n                        // and we won't receive any further notifications\n                        return;\n                    }\n                    for (ManagedServer server : servers.values()) {\n                        final ProcessInfo info = processInfoMap.get(server.getServerProcessName());\n                        switch (server.getState()) {\n                            case FAILED:\n                            case MAX_FAILED:\n                            case STOPPED:\n                                break;\n                            default:\n                                // Only in case there is still a process registered and running\n                                if(info != null && info.isRunning()) {\n                                    count++;\n                                }\n                        }\n                    }\n\n                    if (count == 0) {\n                        break;\n                    }\n                    try {\n                        shutdownCondition.wait(500);\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                }\n            }\n        }\n    }","id":84741,"modified_method":"void stopServers(int gracefulTimeout, boolean blockUntilStopped) {\n        stopped = true;\n        Map<String, ProcessInfo> processInfoMap = determineRunningProcesses();\n        for (String serverProcessName : processInfoMap.keySet()) {\n            if (ManagedServer.isServerProcess(serverProcessName)) {\n                String serverName = ManagedServer.getServerName(serverProcessName);\n                stopServer(serverName, gracefulTimeout);\n            }\n        }\n\n        if (blockUntilStopped) {\n            synchronized (shutdownCondition) {\n                for (;;) {\n                    int count = 0;\n                    try {\n                        processInfoMap = determineRunningProcesses();\n                    } catch(RuntimeException e) {\n                        // In case the process-controller connection is broken, the PC most likely got killed\n                        // and we won't receive any further notifications\n                        return;\n                    }\n                    for (ManagedServer server : servers.values()) {\n                        final ProcessInfo info = processInfoMap.get(server.getServerProcessName());\n                        switch (server.getState()) {\n                            case FAILED:\n                            case MAX_FAILED:\n                            case STOPPED:\n                                break;\n                            default:\n                                // Only in case there is still a process registered and running\n                                if(info != null) {\n                                    count++;\n                                }\n                        }\n                    }\n\n                    if (count == 0) {\n                        break;\n                    }\n                    try {\n                        shutdownCondition.wait(500);\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                }\n            }\n        }\n    }","commit_id":"3dac49cd3492d87586b53373fca9249b52fa2fa3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@NotNull\n  public List<MavenRepositoryInfo> getRepositories() {\n    final String selectedRepository = (String)myRepositoryUrl.getEditor().getItem();\n    if (StringUtil.isNotEmpty(selectedRepository) && !DEFAULT_REPOSITORY.equals(selectedRepository) && !myRepositories.containsKey(selectedRepository)) {\n      return Collections.singletonList(new MavenRepositoryInfo(\"custom\", null, selectedRepository));\n    }\n    else {\n      final Pair<MavenArtifactInfo, MavenRepositoryInfo> artifactAndRepo = myCoordinates.get(getCoordinateText());\n      final MavenRepositoryInfo repository = artifactAndRepo == null? null : artifactAndRepo.second;\n      return repository != null? Collections.singletonList(repository) : ContainerUtil.findAll(myRepositories.values(), Condition.NOT_NULL);\n    }\n  }","id":84742,"modified_method":"@NotNull\n  public List<MavenRepositoryInfo> getRepositories() {\n    final Pair<MavenArtifactInfo, MavenRepositoryInfo> artifactAndRepo = myCoordinates.get(getCoordinateText());\n    final MavenRepositoryInfo repository = artifactAndRepo == null ? null : artifactAndRepo.second;\n    return repository != null ? Collections.singletonList(repository) : ContainerUtil.findAll(myRepositories.values(), Condition.NOT_NULL);\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateComboboxSelection(boolean force) {\n    final String prevFilter = myFilterString;\n    final JTextComponent field = (JTextComponent)myCombobox.getEditor().getEditorComponent();\n    final String prefix = field.getText();\n    final int caret = field.getCaretPosition();\n    myFilterString = prefix.toUpperCase();\n\n    final Pair<MavenArtifactInfo, MavenRepositoryInfo> pair = myCoordinates.get(getCoordinateText());\n    if (myRepositories.containsKey(myRepositoryUrl.getEditor().getItem())) {\n      myRepositoryUrl.setSelectedItem(pair != null && pair.second != null? pair.second.getUrl() : DEFAULT_REPOSITORY);\n    }\n\n\n    if (!force && myFilterString.equals(prevFilter)) return;\n    myShownItems.clear();\n    final boolean itemSelected = Comparing.equal(myCombobox.getSelectedItem(), prefix);\n    if (itemSelected) {\n      myShownItems.addAll(myCoordinates.keySet());\n    }\n    else {\n      final String[] parts = myFilterString.split(\" \");\n      main:\n      for (String coordinate : myCoordinates.keySet()) {\n        final String candidate = coordinate.toUpperCase();\n        for (String part : parts) {\n          if (!candidate.contains(part)) continue main;\n        }\n        myShownItems.add(coordinate);\n      }\n      if (myShownItems.isEmpty()) {\n        myShownItems.addAll(myCoordinates.keySet());\n      }\n      myCombobox.setSelectedItem(null);\n    }\n    Collections.sort(myShownItems);\n    ((CollectionComboBoxModel)myCombobox.getModel()).update();\n    field.setText(prefix);\n    field.setCaretPosition(caret);\n    updateInfoLabel();\n    if (myCombobox.getEditor().getEditorComponent().hasFocus()) {\n      myCombobox.setPopupVisible(!myShownItems.isEmpty() && !itemSelected);\n    }\n  }","id":84743,"modified_method":"private void updateComboboxSelection(boolean force) {\n    final String prevFilter = myFilterString;\n    final JTextComponent field = (JTextComponent)myCombobox.getEditor().getEditorComponent();\n    final String prefix = field.getText();\n    final int caret = field.getCaretPosition();\n    myFilterString = prefix.toUpperCase();\n\n    if (!force && myFilterString.equals(prevFilter)) return;\n    myShownItems.clear();\n    final boolean itemSelected = Comparing.equal(myCombobox.getSelectedItem(), prefix);\n    if (itemSelected) {\n      myShownItems.addAll(myCoordinates.keySet());\n    }\n    else {\n      final String[] parts = myFilterString.split(\" \");\n      main:\n      for (String coordinate : myCoordinates.keySet()) {\n        final String candidate = coordinate.toUpperCase();\n        for (String part : parts) {\n          if (!candidate.contains(part)) continue main;\n        }\n        myShownItems.add(coordinate);\n      }\n      if (myShownItems.isEmpty()) {\n        myShownItems.addAll(myCoordinates.keySet());\n      }\n      myCombobox.setSelectedItem(null);\n    }\n    Collections.sort(myShownItems);\n    ((CollectionComboBoxModel)myCombobox.getModel()).update();\n    field.setText(prefix);\n    field.setCaretPosition(caret);\n    updateInfoLabel();\n    if (myCombobox.getEditor().getEditorComponent().hasFocus()) {\n      myCombobox.setPopupVisible(!myShownItems.isEmpty() && !itemSelected);\n    }\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    if (!isOKActionEnabled()) return;\n    if (!isValidCoordinateSelected()) {\n      IdeFocusManager.findInstance().requestFocus(myCombobox, true);\n      Messages.showErrorDialog(\"Please enter valid coordinate or select one from the list\",\n                               \"Coordinate not specified\");\n      return;\n    }\n    if (!myManaged) {\n      final File dir = new File(myDirectoryField.getText());\n      if (!dir.exists() && !dir.mkdirs() || !dir.isDirectory()) {\n        IdeFocusManager.findInstance().requestFocus(myDirectoryField.getChildComponent(), true);\n        Messages.showErrorDialog(\"Please enter valid library files path\",\n                                 \"Library files path not specified\");\n        return;\n      }\n    }\n    super.doOKAction();\n  }","id":84744,"modified_method":"@Override\n  protected void doOKAction() {\n    if (!isOKActionEnabled()) return;\n    String errorText = null;\n    JComponent errorComponent = null;\n    if (!isValidCoordinateSelected()) {\n      errorComponent = myCombobox;\n      errorText = \"Please enter valid coordinate, discover it or select one from the list\";\n    }\n    else if (!myManaged) {\n      final File dir = new File(myDirectoryField.getText());\n      if (!dir.exists() && !dir.mkdirs() || !dir.isDirectory()) {\n        errorComponent = myDirectoryField.getTextField();\n        errorText = \"Please enter valid library files path\";\n      }\n    }\n    if (errorText != null && errorComponent != null) {\n      final Point point = new Point(errorComponent.getWidth() / 2, 0);\n      JBPopupFactory.getInstance()\n        .createHtmlTextBalloonBuilder(errorText, MessageType.WARNING, null).\n        setHideOnClickOutside(false).setHideOnKeyOutside(true).\n        createBalloon().show(new RelativePoint(errorComponent, point), Balloon.Position.above);\n      IdeFocusManager.findInstance().requestFocus(errorComponent, true);\n    }\n    else {\n      super.doOKAction();\n    }\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean performSearch() {\n    final String text = getCoordinateText();\n    if (myCoordinates.contains(text)) return false;\n    if (myProgressIcon.isVisible()) return false;\n    myProgressIcon.setVisible(true);\n    myProgressIcon.resume();\n    RepositoryAttachHandler.searchArtifacts(myProject, text, new PairProcessor<Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>>, Boolean>() {\n      public boolean process(Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>> artifacts, Boolean tooMany) {\n        if (myProgressIcon.isDisposed()) return true;\n        myProgressIcon.suspend();\n        myProgressIcon.setVisible(false);\n        final int prevSize = myCoordinates.size();\n        for (Pair<MavenArtifactInfo, MavenRepositoryInfo> each : artifacts) {\n          myCoordinates.put(each.first.getGroupId() + \":\" + each.first.getArtifactId() + \":\" + each.first.getVersion(), each);\n          if (each.second != null && !myRepositories.containsKey(each.second.getUrl())) {\n            myRepositories.put(each.second.getUrl(), each.second);\n          }\n        }\n\n        myRepositoryUrl.setModel(new CollectionComboBoxModel(new ArrayList<String>(myRepositories.keySet()), myRepositoryUrl.getEditor().getItem()));\n        if (Boolean.TRUE.equals(tooMany)) {\n          final Point point = new Point(myCombobox.getWidth() / 2, 0);\n          JBPopupFactory.getInstance().createHtmlTextBalloonBuilder(\"Too many results found, please refine your query.\", MessageType.WARNING, null).\n            setHideOnClickOutside(true).\n            createBalloon().show(new RelativePoint(myCombobox, point), Balloon.Position.above);\n        }\n        updateComboboxSelection(prevSize != myCoordinates.size());\n        return true;\n      }\n    });\n    return true;\n  }","id":84745,"modified_method":"private boolean performSearch() {\n    final String text = getCoordinateText();\n    if (myCoordinates.contains(text)) return false;\n    if (myProgressIcon.isRunning()) return false;\n    myProgressIcon.resume();\n    RepositoryAttachHandler.searchArtifacts(myProject, text, new PairProcessor<Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>>, Boolean>() {\n      public boolean process(Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>> artifacts, Boolean tooMany) {\n        if (myProgressIcon.isDisposed()) return true;\n        myProgressIcon.suspend();\n        final int prevSize = myCoordinates.size();\n        for (Pair<MavenArtifactInfo, MavenRepositoryInfo> each : artifacts) {\n          myCoordinates.put(each.first.getGroupId() + \":\" + each.first.getArtifactId() + \":\" + each.first.getVersion(), each);\n          if (each.second != null && !myRepositories.containsKey(each.second.getUrl())) {\n            myRepositories.put(each.second.getUrl(), each.second);\n          }\n        }\n        if (Boolean.TRUE.equals(tooMany)) {\n          final Point point = new Point(myCombobox.getWidth() / 2, 0);\n          JBPopupFactory.getInstance().createHtmlTextBalloonBuilder(\"Too many results found, please refine your query.\", MessageType.WARNING, null).\n            setHideOnClickOutside(true).\n            createBalloon().show(new RelativePoint(myCombobox, point), Balloon.Position.above);\n        }\n        updateComboboxSelection(prevSize != myCoordinates.size());\n        return true;\n      }\n    });\n    return true;\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateInfoLabel() {\n    myInfoLabel.setText(myCombobox.getModel().getSize() +\"/\" + myCoordinates.size());\n  }","id":84746,"modified_method":"private void updateInfoLabel() {\n    myInfoLabel.setText(\"Found: \" + myCoordinates.size()+ \"\\nShowing: \" + myCombobox.getModel().getSize());\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createNorthPanel() {\n    JPanel panel = new JPanel(new BorderLayout(15, 0));\n    {\n      JLabel iconLabel = new JLabel(Messages.getQuestionIcon());\n      Container container = new Container();\n      container.setLayout(new BorderLayout());\n      container.add(iconLabel, BorderLayout.NORTH);\n      panel.add(container, BorderLayout.WEST);\n    }\n\n    final ArrayList<JComponent> gridComponents = new ArrayList<JComponent>();\n    {\n      JPanel caption = new JPanel(new BorderLayout(15, 0));\n      JLabel textLabel = new JLabel(\"Enter keywords to search by, class name or Maven coordinates: \\ni.e. 'spring', 'jsf' or 'org.hibernate:hibernate-core:3.3.0.GA'\");\n      textLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));\n      textLabel.setUI(new MultiLineLabelUI());\n      caption.add(textLabel, BorderLayout.WEST);\n      final JPanel infoPanel = new JPanel(new BorderLayout());\n      infoPanel.add(myInfoLabel, BorderLayout.WEST);\n      infoPanel.add(myProgressIcon, BorderLayout.EAST);\n      caption.add(infoPanel, BorderLayout.EAST);\n      gridComponents.add(caption);\n\n      final ComponentWithBrowseButton<JComboBox> coordComponent = new ComponentWithBrowseButton<JComboBox>(myCombobox, new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          performSearch();\n        }\n      });\n      coordComponent.setButtonIcon(Icons.SYNCHRONIZE_ICON);\n      gridComponents.add(coordComponent);\n\n      final LabeledComponent<JComboBox> repository = new LabeledComponent<JComboBox>();\n      repository.getLabel().setText(\"Repository URL to Download From:\");\n      myRepositories.put(DEFAULT_REPOSITORY, null);\n      for (MavenRepositoryInfo repo : RepositoryAttachHandler.getDefaultRepositories()) {\n        myRepositories.put(repo.getUrl(), repo);\n      }\n      myRepositoryUrl = new JComboBox(new CollectionComboBoxModel(new ArrayList<String>(myRepositories.keySet()), DEFAULT_REPOSITORY));\n      myRepositoryUrl.setEditable(true);\n      repository.setComponent(myRepositoryUrl);\n      gridComponents.add(repository);\n\n      if (!myManaged) {\n        myDirectoryField = new TextFieldWithBrowseButton();\n        if (myProject != null && !myProject.isDefault()) {\n          final VirtualFile baseDir = myProject.getBaseDir();\n          if (baseDir != null) {\n            myDirectoryField.setText(FileUtil.toSystemDependentName(baseDir.getPath()+\"/lib\"));\n          }\n        }\n        myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                   ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                   FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n        final LabeledComponent<TextFieldWithBrowseButton> dirComponent = new LabeledComponent<TextFieldWithBrowseButton>();\n        dirComponent.getLabel().setText(\"Store Library Files in: \");\n        dirComponent.setComponent(myDirectoryField);\n        gridComponents.add(dirComponent);\n      }\n    }\n    JPanel messagePanel = new JPanel(new GridLayoutManager(gridComponents.size(), 1));\n    for (int i = 0, gridComponentsSize = gridComponents.size(); i < gridComponentsSize; i++) {\n      messagePanel.add(gridComponents.get(i), new GridConstraints(i, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, GridConstraints.FILL_HORIZONTAL,\n                                                          GridConstraints.SIZEPOLICY_CAN_GROW | GridConstraints.SIZEPOLICY_CAN_SHRINK, 0,\n                                                          null, null, null));\n    }\n    panel.add(messagePanel, BorderLayout.CENTER);\n\n    return panel;\n  }","id":84747,"modified_method":"protected JComponent createNorthPanel() {\n    return myPanel;\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void dispose() {\n    Disposer.dispose(myProgressIcon);\n    super.dispose();\n  }","id":84748,"modified_method":"@Override\n  protected void dispose() {\n    Disposer.dispose(myProgressIcon);\n    final PropertiesComponent storage = PropertiesComponent.getInstance(myProject);\n    storage.setValue(PROPERTY_ATTACH_JAVADOC, String.valueOf(myJavaDocCheckBox.isSelected()));\n    storage.setValue(PROPERTY_ATTACH_SOURCES, String.valueOf(mySourcesCheckBox.isSelected()));\n    super.dispose();\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RepositoryAttachDialog(Project project, boolean managed) {\n    super(project, true);\n    myProject = project;\n    myManaged = managed;\n    myProgressIcon = new AsyncProcessIcon(\"Progress\");\n    myProgressIcon.setVisible(false);\n    myProgressIcon.suspend();\n    myInfoLabel = new JLabel(\"\");\n    myCombobox.setEditable(true);\n    final JTextField textField = (JTextField)myCombobox.getEditor().getEditorComponent();\n    textField.setColumns(50);\n    textField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (myProgressIcon.isDisposed()) return;\n            updateComboboxSelection(false);\n          }\n        });\n      }\n    });\n    textField.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyPressed(KeyEvent e) {\n        final boolean popupVisible = myCombobox.isPopupVisible();\n        if (e.getKeyCode() == KeyEvent.VK_ENTER && e.getModifiers() == 0) {\n          //if (true) return;\n          if (popupVisible && !myCoordinates.isEmpty()) {\n            final String item = (String)myCombobox.getSelectedItem();\n            if (StringUtil.isNotEmpty(item)) {\n              ((JTextField)myCombobox.getEditor().getEditorComponent()).setText(item);\n            }\n          }\n          else if (!popupVisible || myCoordinates.isEmpty()) {\n            if (performSearch()) {\n              e.consume();\n            }\n          }\n        }\n      }\n    });\n    updateInfoLabel();\n    init();\n  }","id":84749,"modified_method":"public RepositoryAttachDialog(Project project, boolean managed) {\n    super(project, true);\n    myProject = project;\n    myManaged = managed;\n    myProgressIcon.suspend();\n    myCaptionLabel.setText(\"Enter keywords to search by, class name or Maven coordinates,\\n\" +\n                           \"i.e. 'springframework', 'Logger' or 'org.hibernate:hibernate-core:3.5.0.GA':\");\n    myCaptionLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));\n    myCaptionLabel.setUI(new MultiLineLabelUI());\n    myInfoLabel.setUI(new MultiLineLabelUI());\n    myInfoLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));\n    myInfoLabel.setPreferredSize(new Dimension(myInfoLabel.getFontMetrics(myInfoLabel.getFont()).stringWidth(\"Showing: 1000\"), myInfoLabel.getPreferredSize().height));\n\n    myComboComponent.setButtonIcon(IconLoader.findIcon(\"/actions/menu-find.png\"));\n    myCombobox = myComboComponent.getComboBox();\n    myCombobox.setModel(new CollectionComboBoxModel(myShownItems, null));\n    myCombobox.setEditable(true);\n    final JTextField textField = (JTextField)myCombobox.getEditor().getEditorComponent();\n    textField.setColumns(50);\n    textField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (myProgressIcon.isDisposed()) return;\n            updateComboboxSelection(false);\n          }\n        });\n      }\n    });\n    textField.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyPressed(KeyEvent e) {\n        final boolean popupVisible = myCombobox.isPopupVisible();\n        if (e.getKeyCode() == KeyEvent.VK_ENTER && e.getModifiers() == 0) {\n          //if (true) return;\n          if (popupVisible && !myCoordinates.isEmpty()) {\n            final String item = (String)myCombobox.getSelectedItem();\n            if (StringUtil.isNotEmpty(item)) {\n              ((JTextField)myCombobox.getEditor().getEditorComponent()).setText(item);\n            }\n          }\n          else if (!popupVisible || myCoordinates.isEmpty()) {\n            if (performSearch()) {\n              e.consume();\n            }\n          }\n        }\n      }\n    });\n    if (!myManaged) {\n      if (myProject != null && !myProject.isDefault()) {\n        final VirtualFile baseDir = myProject.getBaseDir();\n        if (baseDir != null) {\n          myDirectoryField.setText(FileUtil.toSystemDependentName(baseDir.getPath() + \"/lib\"));\n        }\n      }\n      myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                               ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                               FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    }\n    else {\n      myDirectoryField.setVisible(false);\n    }\n    final PropertiesComponent storage = PropertiesComponent.getInstance(myProject);\n    myJavaDocCheckBox.setSelected(storage.isValueSet(PROPERTY_ATTACH_JAVADOC) && storage.isTrueValue(PROPERTY_ATTACH_JAVADOC));\n    mySourcesCheckBox.setSelected(storage.isValueSet(PROPERTY_ATTACH_SOURCES) && storage.isTrueValue(PROPERTY_ATTACH_SOURCES));\n    updateInfoLabel();\n    init();\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceLibraryData(Project project,\n                                         Library.ModifiableModel library,\n                                         Collection<MavenArtifact> artifacts,\n                                         String copyTo) {\n    final String repoUrl = getLocalRepositoryUrl(project);\n    for (OrderRootType type : OrderRootType.getAllTypes()) {\n      for (String url : library.getUrls(type)) {\n        if (url.startsWith(repoUrl)) {\n          library.removeRoot(url, type);\n        }\n      }\n    }\n    for (MavenArtifact each : artifacts) {\n      try {\n        File repoFile = each.getFile();\n        File toFile = repoFile;\n        if (copyTo != null) {\n          toFile = new File(copyTo, repoFile.getName());\n          if (repoFile.exists()) {\n            FileUtil.copy(repoFile, toFile);\n          }\n        }\n        String url = VfsUtil.pathToUrl(FileUtil.toSystemIndependentName(toFile.getPath()));\n        library.addRoot(url, OrderRootType.CLASSES);\n      }\n      catch (MalformedURLException e) {\n        MavenLog.LOG.warn(e);\n      }\n      catch (IOException e) {\n        MavenLog.LOG.warn(e);\n      }\n    }\n  }","id":84750,"modified_method":"private static void replaceLibraryData(Project project,\n                                         Library.ModifiableModel library,\n                                         Collection<MavenArtifact> artifacts,\n                                         String copyTo) {\n    final String repoUrl = getLocalRepositoryUrl(project);\n    for (OrderRootType type : OrderRootType.getAllTypes()) {\n      for (String url : library.getUrls(type)) {\n        if (url.startsWith(repoUrl)) {\n          library.removeRoot(url, type);\n        }\n      }\n    }\n    final VirtualFileManager manager = VirtualFileManager.getInstance();\n    for (MavenArtifact each : artifacts) {\n      try {\n        File repoFile = each.getFile();\n        File toFile = repoFile;\n        if (copyTo != null) {\n          toFile = new File(copyTo, repoFile.getName());\n          if (repoFile.exists()) {\n            FileUtil.copy(repoFile, toFile);\n          }\n        }\n        String url = VfsUtil.pathToUrl(FileUtil.toSystemIndependentName(toFile.getPath()));\n        manager.refreshAndFindFileByUrl(url);\n        if (MavenExtraArtifactType.DOCS.getDefaultClassifier().equals(each.getClassifier())) {\n          library.addRoot(url, JavadocOrderRootType.getInstance());\n        }\n        else if (MavenExtraArtifactType.SOURCES.getDefaultClassifier().equals(each.getClassifier())) {\n          library.addRoot(url, OrderRootType.SOURCES);\n        }\n        else {\n          library.addRoot(url, OrderRootType.CLASSES);\n        }\n      }\n      catch (MalformedURLException e) {\n        MavenLog.LOG.warn(e);\n      }\n      catch (IOException e) {\n        MavenLog.LOG.warn(e);\n      }\n    }\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doResolveInner(Project project,\n                                     MavenArtifactInfo artifact,\n                                     Collection<MavenRepositoryInfo> repositories,\n                                     final Processor<List<MavenArtifact>> resultProcessor,\n                                     ProgressIndicator indicator) {\n    final Ref<List<MavenArtifact>> result = new Ref<List<MavenArtifact>>();\n\n    MavenEmbeddersManager manager = MavenProjectsManager.getInstance(project).getEmbeddersManager();\n    MavenEmbedderWrapper embedder = manager.getEmbedder(MavenEmbeddersManager.FOR_DOWNLOAD);\n    try {\n      embedder.customizeForResolve(new SoutMavenConsole(), new MavenProgressIndicator(indicator));\n      List<MavenArtifact> resolved = embedder.resolveTransitively(Collections.singletonList(artifact),\n                                                                  convertRepositories(repositories));\n      result.set(ContainerUtil.findAll(resolved, new Condition<MavenArtifact>() {\n        public boolean value(MavenArtifact mavenArtifact) {\n          return mavenArtifact.isResolved();\n        }\n      }));\n    }\n    catch (MavenProcessCanceledException e) {\n      return;\n    }\n    finally {\n      manager.release(embedder);\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          resultProcessor.process(result.get());\n        }\n      });\n    }\n  }","id":84751,"modified_method":"private static void doResolveInner(Project project,\n                                     List<MavenArtifactInfo> artifacts,\n                                     Collection<MavenRepositoryInfo> repositories,\n                                     final Processor<List<MavenArtifact>> resultProcessor,\n                                     ProgressIndicator indicator) {\n    final Ref<List<MavenArtifact>> result = new Ref<List<MavenArtifact>>();\n\n    MavenEmbeddersManager manager = MavenProjectsManager.getInstance(project).getEmbeddersManager();\n    MavenEmbedderWrapper embedder = manager.getEmbedder(MavenEmbeddersManager.FOR_DOWNLOAD);\n    try {\n      embedder.customizeForResolve(new SoutMavenConsole(), new MavenProgressIndicator(indicator));\n      List<MavenArtifact> resolved = embedder.resolveTransitively(artifacts,\n                                                                  convertRepositories(repositories));\n      result.set(ContainerUtil.findAll(resolved, new Condition<MavenArtifact>() {\n        public boolean value(MavenArtifact mavenArtifact) {\n          return mavenArtifact.isResolved();\n        }\n      }));\n    }\n    catch (MavenProcessCanceledException e) {\n      return;\n    }\n    finally {\n      manager.release(embedder);\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          resultProcessor.process(result.get());\n        }\n      });\n    }\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void resolveLibrary(final Project project,\n                                    final String libName,\n                                    final Collection<MavenRepositoryInfo> repositories,\n                                    boolean modal,\n                                    final Processor<List<MavenArtifact>> resultProcessor) {\n    Task task;\n    if (modal) {\n      task = new Task.Modal(project, \"Maven\", false) {\n        public void run(@NotNull ProgressIndicator indicator) {\n          doResolveInner(project, createTemplate(libName, \"jar\"), repositories, resultProcessor, indicator);\n        }\n      };\n    }\n    else {\n      task = new Task.Backgroundable(project, \"Maven\", false, PerformInBackgroundOption.DEAF) {\n        public void run(@NotNull ProgressIndicator indicator) {\n          doResolveInner(project, createTemplate(libName, \"jar\"), repositories, resultProcessor, indicator);\n        }\n\n        @Override\n        public boolean shouldStartInBackground() {\n          return false;\n        }\n      };\n    }\n\n    ProgressManager.getInstance().run(task);\n  }","id":84752,"modified_method":"public static void resolveLibrary(final Project project,\n                                    final String coord,\n                                    List<MavenExtraArtifactType> extraTypes, final Collection<MavenRepositoryInfo> repositories,\n                                    boolean modal,\n                                    final Processor<List<MavenArtifact>> resultProcessor) {\n    final List<MavenArtifactInfo> artifacts = new ArrayList<MavenArtifactInfo>(3);\n    final MavenId mavenId = getMavenId(coord);\n    artifacts.add(new MavenArtifactInfo(mavenId, \"jar\", null));\n    for (MavenExtraArtifactType extraType : extraTypes) {\n      artifacts.add(new MavenArtifactInfo(mavenId, extraType.getDefaultExtension(), extraType.getDefaultClassifier()));\n    }\n    final Task task;\n    if (modal) {\n      task = new Task.Modal(project, \"Maven\", false) {\n        public void run(@NotNull ProgressIndicator indicator) {\n          doResolveInner(project, artifacts, repositories, resultProcessor, indicator);\n        }\n      };\n    }\n    else {\n      task = new Task.Backgroundable(project, \"Maven\", false, PerformInBackgroundOption.DEAF) {\n        public void run(@NotNull ProgressIndicator indicator) {\n          doResolveInner(project, artifacts, repositories, resultProcessor, indicator);\n        }\n\n        @Override\n        public boolean shouldStartInBackground() {\n          return false;\n        }\n      };\n    }\n\n    ProgressManager.getInstance().run(task);\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void searchArtifacts(final Project project, String coord,\n                                     final PairProcessor<Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>>, Boolean> resultProcessor) {\n    if (coord == null) return;\n    final MavenArtifactInfo template = createTemplate(coord, \"jar\");\n    ProgressManager.getInstance().run(new Task.Backgroundable(project, \"Maven\", false) {\n\n      public void run(@NotNull ProgressIndicator indicator) {\n        final Ref<List<Pair<MavenArtifactInfo, MavenRepositoryInfo>>> result\n          = Ref.create(Collections.<Pair<MavenArtifactInfo, MavenRepositoryInfo>>emptyList());\n        final Ref<List<MavenRepositoryInfo>> result2 = Ref.create(Collections.<MavenRepositoryInfo>emptyList());\n        final Ref<Boolean> tooManyRef = Ref.create(Boolean.FALSE);\n        try {\n          MavenFacadeManager facade = MavenFacadeManager.getInstance();\n          final List<Pair<MavenArtifactInfo, MavenRepositoryInfo>> resultList = new ArrayList<Pair<MavenArtifactInfo, MavenRepositoryInfo>>();\n          final List<MavenRepositoryInfo> result2List = new ArrayList<MavenRepositoryInfo>();\n          for (String nexusUrl : MavenServicesManager.getServiceUrls()) {\n            final List<MavenArtifactInfo> artifacts;\n            try {\n              artifacts = facade.findArtifacts(template, nexusUrl);\n            }\n            catch (Exception ex) {\n              MavenLog.LOG.warn(\"Accessing Nexus at: \" + nexusUrl, ex);\n              continue;\n            }\n            if (artifacts == null) {\n              tooManyRef.set(Boolean.TRUE);\n            }\n            else if (!artifacts.isEmpty()) {\n              final List<MavenRepositoryInfo> repositories = facade.getRepositories(nexusUrl);\n              final HashMap<String, MavenRepositoryInfo> map = new HashMap<String, MavenRepositoryInfo>();\n              for (MavenRepositoryInfo repository : repositories) {\n                map.put(repository.getId(), repository);\n              }\n              result2List.addAll(repositories);\n              for (MavenArtifactInfo artifact : artifacts) {\n                resultList.add(Pair.create(artifact, map.get(artifact.getRepositoryId())));\n              }\n            }\n          }\n          result.set(resultList);\n          result2.set(result2List);\n        }\n        catch (Exception e) {\n          handleError(null, e);\n        }\n        finally {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              resultProcessor.process(result.get(), tooManyRef.get());\n            }\n          });\n        }\n      }\n    });\n  }","id":84753,"modified_method":"public static void searchArtifacts(final Project project, String coord,\n                                     final PairProcessor<Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>>, Boolean> resultProcessor) {\n    if (coord == null || coord.length() == 0) return;\n    final MavenArtifactInfo template;\n    if (coord.indexOf(':') == -1 && Character.isUpperCase(coord.charAt(0))) {\n      template = new MavenArtifactInfo(null, null, null, \"jar\", null, coord, null);\n    }\n    else {\n      template = new MavenArtifactInfo(getMavenId(coord), \"jar\", null);\n    }\n    ProgressManager.getInstance().run(new Task.Backgroundable(project, \"Maven\", false) {\n\n      public void run(@NotNull ProgressIndicator indicator) {\n        final Ref<List<Pair<MavenArtifactInfo, MavenRepositoryInfo>>> result\n          = Ref.create(Collections.<Pair<MavenArtifactInfo, MavenRepositoryInfo>>emptyList());\n        final Ref<List<MavenRepositoryInfo>> result2 = Ref.create(Collections.<MavenRepositoryInfo>emptyList());\n        final Ref<Boolean> tooManyRef = Ref.create(Boolean.FALSE);\n        try {\n          MavenFacadeManager facade = MavenFacadeManager.getInstance();\n          final List<Pair<MavenArtifactInfo, MavenRepositoryInfo>> resultList = new ArrayList<Pair<MavenArtifactInfo, MavenRepositoryInfo>>();\n          final List<MavenRepositoryInfo> result2List = new ArrayList<MavenRepositoryInfo>();\n          for (String nexusUrl : MavenServicesManager.getServiceUrls()) {\n            final List<MavenArtifactInfo> artifacts;\n            try {\n              artifacts = facade.findArtifacts(template, nexusUrl);\n            }\n            catch (Exception ex) {\n              MavenLog.LOG.warn(\"Accessing Nexus at: \" + nexusUrl, ex);\n              continue;\n            }\n            if (artifacts == null) {\n              tooManyRef.set(Boolean.TRUE);\n            }\n            else if (!artifacts.isEmpty()) {\n              final List<MavenRepositoryInfo> repositories = facade.getRepositories(nexusUrl);\n              final HashMap<String, MavenRepositoryInfo> map = new HashMap<String, MavenRepositoryInfo>();\n              for (MavenRepositoryInfo repository : repositories) {\n                map.put(repository.getId(), repository);\n              }\n              result2List.addAll(repositories);\n              for (MavenArtifactInfo artifact : artifacts) {\n                resultList.add(Pair.create(artifact, map.get(artifact.getRepositoryId())));\n              }\n            }\n          }\n          result.set(resultList);\n          result2.set(result2List);\n        }\n        catch (Exception e) {\n          handleError(null, e);\n        }\n        finally {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              resultProcessor.process(result.get(), tooManyRef.get());\n            }\n          });\n        }\n      }\n    });\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ActionCallback performAttach(final Project project, final NullableComputable<Library.ModifiableModel> modelProvider) {\n\n    MavenService.getInstance(project);\n    final RepositoryAttachDialog dialog = new RepositoryAttachDialog(project, false);\n    dialog.setTitle(getLongName());\n    dialog.show();\n    if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n      final ActionCallback callback = new ActionCallback();\n      final String copyTo = dialog.getDirectoryPath();\n      final String coord = dialog.getCoordinateText();\n      resolveLibrary(project, coord, dialog.getRepositories(), false, new Processor<List<MavenArtifact>>() {\n        public boolean process(final List<MavenArtifact> artifacts) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              final Library.ModifiableModel modifiableModel = modelProvider.compute();\n              if (modifiableModel == null) {\n                callback.setRejected();\n              }\n              else {\n                replaceLibraryData(project, modifiableModel, artifacts, copyTo);\n                callback.setDone();\n              }\n            }\n          });\n          final boolean nothingRetrieved = artifacts.isEmpty();\n          final StringBuilder sb = new StringBuilder();\n          if (nothingRetrieved) {\n            sb.append(\"No files were downloaded for \").append(coord);\n          }\n          else {\n            sb.append(\"The following files were downloaded:<br>\");\n            sb.append(\"<ol>\");\n            for (MavenArtifact each : artifacts) {\n              sb.append(\"<li>\");\n              sb.append(each.getFile().getName());\n              sb.append(\"<\/li>\");\n            }\n            sb.append(\"<\/ol>\");\n          }\n          final String title = \"Attach Jars From Repository\";\n          if (nothingRetrieved && ModalityState.current().dominates(ModalityState.NON_MODAL)) {\n            Messages.showErrorDialog(project, sb.toString(), title);\n          }\n          else {\n            Notifications.Bus.notify(new Notification(\"Repository\", sb.toString(), title,\n                                                      nothingRetrieved ? NotificationType.WARNING : NotificationType.INFORMATION),\n                                     NotificationDisplayType.STICKY_BALLOON, project);\n          }\n          return true;\n        }\n      });\n      return callback;\n    }\n    return new ActionCallback.Rejected();\n  }","id":84754,"modified_method":"public ActionCallback performAttach(final Project project, final NullableComputable<Library.ModifiableModel> modelProvider) {\n\n    MavenService.getInstance(project);\n    final RepositoryAttachDialog dialog = new RepositoryAttachDialog(project, false);\n    dialog.setTitle(getLongName());\n    dialog.show();\n    if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n      final ActionCallback callback = new ActionCallback();\n      final String copyTo = dialog.getDirectoryPath();\n      final String coord = dialog.getCoordinateText();\n      final boolean attachJavaDoc = dialog.getAttachJavaDoc();\n      final boolean attachSources = dialog.getAttachSources();\n      final SmartList<MavenExtraArtifactType> extraTypes = new SmartList<MavenExtraArtifactType>();\n      if (attachSources) extraTypes.add(MavenExtraArtifactType.SOURCES);\n      if (attachJavaDoc) extraTypes.add(MavenExtraArtifactType.DOCS);\n      resolveLibrary(project, coord, extraTypes, dialog.getRepositories(), false, new Processor<List<MavenArtifact>>() {\n        public boolean process(final List<MavenArtifact> artifacts) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              final Library.ModifiableModel modifiableModel = modelProvider.compute();\n              if (modifiableModel == null) {\n                callback.setRejected();\n              }\n              else {\n                replaceLibraryData(project, modifiableModel, artifacts, copyTo);\n                callback.setDone();\n              }\n            }\n          });\n          final boolean nothingRetrieved = artifacts.isEmpty();\n          final StringBuilder sb = new StringBuilder();\n          if (nothingRetrieved) {\n            sb.append(\"No files were downloaded for \").append(coord);\n          }\n          else {\n            sb.append(\"The following files were downloaded:<br>\");\n            sb.append(\"<ol>\");\n            for (MavenArtifact each : artifacts) {\n              sb.append(\"<li>\");\n              sb.append(each.getFile().getName());\n              sb.append(\"<\/li>\");\n            }\n            sb.append(\"<\/ol>\");\n          }\n          final String title = \"Attach Jars From Repository\";\n          if (nothingRetrieved && ModalityState.current().dominates(ModalityState.NON_MODAL)) {\n            Messages.showErrorDialog(project, sb.toString(), title);\n          }\n          else {\n            Notifications.Bus.notify(new Notification(\"Repository\", sb.toString(), title,\n                                                      nothingRetrieved ? NotificationType.WARNING : NotificationType.INFORMATION),\n                                     NotificationDisplayType.STICKY_BALLOON, project);\n          }\n          return true;\n        }\n      });\n      return callback;\n    }\n    return new ActionCallback.Rejected();\n  }","commit_id":"8732d4b8bc78836a74fd3495ceb12c8286d7deec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getPreferredFocusedComponent() {\n    return myRbExisting.isSelected() ? myExisitingsCombo : myNewListPanel.getPrefferedFocusedComponent();\n  }","id":84755,"modified_method":"public JComponent getPreferredFocusedComponent() {\n    return myPanel.getPreferredFocusedComponent();\n  }","commit_id":"f67fc6b087ec0cee8446ba224bcfe59557154a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangeListChooser(@NotNull Project project,\n                           @NotNull Collection<? extends ChangeList> changelists,\n                           @Nullable ChangeList defaultSelection,\n                           final String title,\n                           @Nullable final String defaultName) {\n    super(project, false);\n    myProject = project;\n\n    final DefaultComboBoxModel model = new DefaultComboBoxModel();\n    for (ChangeList list : changelists) {\n      model.addElement(list);\n    }\n\n    myExisitingsCombo.setModel(model);\n    if (defaultSelection == null) {\n      myExisitingsCombo.setSelectedIndex(0);\n    }\n    else {\n      myExisitingsCombo.setSelectedItem(defaultSelection);\n    }\n\n    myExisitingsCombo.setRenderer(new ColoredListCellRenderer() {\n      protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        append(((ChangeList)value).getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      }\n    });\n\n    myRbExisting.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        updateEnabledItems();\n      }\n    });\n\n    if (defaultSelection != null) {\n      myRbExisting.setSelected(true);\n    }\n    else {\n      myRbNew.setSelected(true);\n    }\n\n    updateEnabledItems();\n\n    setTitle(title);\n    if (defaultName != null) {\n      myNewListPanel.setName(defaultName);\n    }\n\n    init();\n  }","id":84756,"modified_method":"public ChangeListChooser(@NotNull Project project,\n                           @NotNull Collection<? extends ChangeList> changelists,\n                           @Nullable ChangeList defaultSelection,\n                           final String title,\n                           @Nullable final String defaultName) {\n    super(project, false);\n\n    myPanel = new ChangeListChooserPanel(project);\n    myPanel.setChangeLists(changelists);\n    myPanel.setDefaultSelection(defaultSelection);\n\n    setTitle(title);\n    if (defaultName != null) {\n      myPanel.setDefaultName(defaultName);\n    }\n\n    init();\n  }","commit_id":"f67fc6b087ec0cee8446ba224bcfe59557154a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    if (myRbNew.isSelected()) {\n      String newText = myNewListPanel.getName();\n      if (ChangeListManager.getInstance(myProject).findChangeList(newText) != null) {\n        Messages.showErrorDialog(myProject,\n                                 VcsBundle.message(\"changes.newchangelist.warning.already.exists.text\", newText),\n                                 VcsBundle.message(\"changes.newchangelist.warning.already.exists.title\"));\n        return;\n      }\n    }\n\n    if (myRbExisting.isSelected()) {\n      mySelectedList = (LocalChangeList)myExisitingsCombo.getSelectedItem();\n    }\n    else {\n      mySelectedList = ChangeListManager.getInstance(myProject).addChangeList(myNewListPanel.getName(), myNewListPanel.getDescription());\n    }\n\n    super.doOKAction();\n  }","id":84757,"modified_method":"protected void doOKAction() {\n    mySelectedList = myPanel.getSelectedList();\n    if (mySelectedList != null) {\n      super.doOKAction();\n    }\n  }","commit_id":"f67fc6b087ec0cee8446ba224bcfe59557154a90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    final ApplyPatchDialog dialog = new ApplyPatchDialog(project);\n    final VirtualFile vFile = e.getData(DataKeys.VIRTUAL_FILE);\n    if (vFile != null && vFile.getFileType() == StdFileTypes.PATCH) {\n      dialog.setFileName(vFile.getPresentableUrl());\n    }\n    dialog.show();\n    if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    applyPatch(project, dialog.getPatches(), dialog.getApplyPatchContext());\n  }","id":84758,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    final ApplyPatchDialog dialog = new ApplyPatchDialog(project);\n    final VirtualFile vFile = e.getData(DataKeys.VIRTUAL_FILE);\n    if (vFile != null && vFile.getFileType() == StdFileTypes.PATCH) {\n      dialog.setFileName(vFile.getPresentableUrl());\n    }\n    dialog.show();\n    if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    applyPatch(project, dialog.getPatches(), dialog.getApplyPatchContext(), dialog.getSelectedChangeList());\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ApplyPatchStatus applyPatch(final Project project, final List<FilePatch> patches,\n                                            final ApplyPatchContext context) {\n    List<VirtualFile> filesToMakeWritable = new ArrayList<VirtualFile>();\n    if (!prepareFiles(project, patches, context, filesToMakeWritable)) {\n      return ApplyPatchStatus.FAILURE;\n    }\n    final VirtualFile[] fileArray = filesToMakeWritable.toArray(new VirtualFile[filesToMakeWritable.size()]);\n    final ReadonlyStatusHandler.OperationStatus readonlyStatus = ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(fileArray);\n    if (readonlyStatus.hasReadonlyFiles()) {\n      return ApplyPatchStatus.FAILURE;\n    }\n    return applyFilePatches(project, patches, context, null);\n  }","id":84759,"modified_method":"private static ApplyPatchStatus applyPatch(final Project project, final List<FilePatch> patches,\n                                            final ApplyPatchContext context, final LocalChangeList targetChangeList) {\n    List<VirtualFile> filesToMakeWritable = new ArrayList<VirtualFile>();\n    if (!prepareFiles(project, patches, context, filesToMakeWritable)) {\n      return ApplyPatchStatus.FAILURE;\n    }\n    final VirtualFile[] fileArray = filesToMakeWritable.toArray(new VirtualFile[filesToMakeWritable.size()]);\n    final ReadonlyStatusHandler.OperationStatus readonlyStatus = ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(fileArray);\n    if (readonlyStatus.hasReadonlyFiles()) {\n      return ApplyPatchStatus.FAILURE;\n    }\n    final List<FilePath> affectedPaths = new ArrayList<FilePath>();\n    final ApplyPatchStatus patchStatus = applyFilePatches(project, patches, context, affectedPaths);\n    if (patchStatus != ApplyPatchStatus.FAILURE) {\n      moveChangesToList(project, affectedPaths, targetChangeList);\n    }\n    return patchStatus;\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void dispose() {\n    myLoadPatchAlarm.dispose();\n    super.dispose();\n  }","id":84760,"modified_method":"@Override\n  protected void dispose() {\n    myLoadPatchAlarm.dispose();\n    myVerifyPatchAlarm.dispose();\n    super.dispose();\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Collection<String> verifyPatchPaths() {\n    final ApplyPatchContext context = getApplyPatchContext();\n    myPatchesFailedToLoad.clear();\n    for(FilePatch patch: myPatches) {\n      try {\n        if (context.getBaseDir() == null || patch.findFileToPatch(context) == null) {\n          myPatchesFailedToLoad.add(patch);\n        }\n      }\n      catch (IOException e) {\n        myPatchesFailedToLoad.add(patch);\n      }\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        if (myPatchTableModel != null) {\n          myPatchTableModel.fireTableDataChanged();\n        }\n        myStatusLabel.setText(\"\");\n      }\n    });\n    return context.getMissingDirectories();\n  }","id":84761,"modified_method":"private Collection<String> verifyPatchPaths() {\n    final ApplyPatchContext context = getApplyPatchContext();\n    myPatchesFailedToLoad.clear();\n    for(FilePatch patch: myPatches) {\n      try {\n        if (context.getBaseDir() == null || patch.findFileToPatch(context) == null) {\n          myPatchesFailedToLoad.add(patch);\n        }\n      }\n      catch (IOException e) {\n        myPatchesFailedToLoad.add(patch);\n      }\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        myPatchContentsList.repaint();\n        myStatusLabel.setText(\"\");\n      }\n    });\n    return context.getMissingDirectories();\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    if (myPatches == null) {\n      myLoadPatchAlarm.cancelAllRequests();\n      checkLoadPatches();\n    }\n    if (myLoadPatchError == null) {\n      final Collection<String> missingDirs = verifyPatchPaths();\n      if (missingDirs.size() > 0) {\n        StringBuilder messageBuilder = new StringBuilder(VcsBundle.message(\"apply.patch.create.dirs.prompt.header\"));\n        for(String missingDir: missingDirs) {\n          messageBuilder.append(missingDir).append(\"\\r\\n\");\n        }\n        messageBuilder.append(VcsBundle.message(\"apply.patch.create.dirs.prompt.footer\"));\n        int rc = Messages.showYesNoCancelDialog(myProject, messageBuilder.toString(), VcsBundle.message(\"patch.apply.dialog.title\"),\n                                                Messages.getQuestionIcon());\n        if (rc == 0) {\n          for(String dir: missingDirs) {\n            new File(dir).mkdirs();\n          }\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              for(String dir: missingDirs) {\n                LocalFileSystem.getInstance().refreshAndFindFileByPath(dir);\n              }\n            }\n          });\n        }\n        else if (rc != 1) {\n          return;\n        }\n      }\n      super.doOKAction();\n    }\n  }","id":84762,"modified_method":"@Override\n  protected void doOKAction() {\n    if (myPatches == null) {\n      myLoadPatchAlarm.cancelAllRequests();\n      checkLoadPatches();\n    }\n    if (myLoadPatchError == null) {\n      mySelectedChangeList = myChangeListChooser.getSelectedList(myProject);\n      if (mySelectedChangeList == null) return;\n      final Collection<String> missingDirs = verifyPatchPaths();\n      if (missingDirs.size() > 0 && !checkCreateMissingDirs(missingDirs)) return;\n      super.doOKAction();\n    }\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ApplyPatchDialog(Project project) {\n    super(project, true);\n    myProject = project;\n    setTitle(VcsBundle.message(\"patch.apply.dialog.title\"));\n    final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n      @Override\n      public boolean isFileSelectable(VirtualFile file) {\n        return file.getFileType() == StdFileTypes.PATCH || file.getFileType() == StdFileTypes.PLAIN_TEXT;\n      }\n    };\n    myFileNameField.addBrowseFolderListener(VcsBundle.message(\"patch.apply.select.title\"), \"\", project, descriptor);\n    myFileNameField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        updateOKAction();\n        myStatusLabel.setForeground(UIUtil.getLabelForeground());\n        myStatusLabel.setText(VcsBundle.message(\"patch.load.progress\"));\n        myPatches = null;\n        myLoadPatchAlarm.cancelAllRequests();\n        myLoadPatchAlarm.addRequest(new Runnable() {\n          public void run() {\n            checkLoadPatches();\n          }\n        }, 400);\n      }\n    });\n\n    myBaseDirectoryField.setText(project.getBaseDir().getPresentableUrl());\n    myBaseDirectoryField.addBrowseFolderListener(VcsBundle.message(\"patch.apply.select.base.directory.title\"), \"\", project,\n                                                 new FileChooserDescriptor(false, true, false, false, false, false));\n    myBaseDirectoryField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        if (!myInnerChange) {\n          queueVerifyPatchPaths();\n        }\n      }\n    });\n\n    myStripLeadingDirectoriesSpinner.setModel(new SpinnerNumberModel(0, 0, 256, 1));\n    myStripLeadingDirectoriesSpinner.addChangeListener(new ChangeListener() {\n      public void stateChanged(final ChangeEvent e) {\n        if (!myInnerChange) {\n          queueVerifyPatchPaths();\n        }\n      }\n    });\n\n    init();\n    updateOKAction();\n  }","id":84763,"modified_method":"public ApplyPatchDialog(Project project) {\n    super(project, true);\n    myProject = project;\n    setTitle(VcsBundle.message(\"patch.apply.dialog.title\"));\n    final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n      @Override\n      public boolean isFileSelectable(VirtualFile file) {\n        return file.getFileType() == StdFileTypes.PATCH || file.getFileType() == StdFileTypes.PLAIN_TEXT;\n      }\n    };\n    myFileNameField.addBrowseFolderListener(VcsBundle.message(\"patch.apply.select.title\"), \"\", project, descriptor);\n    myFileNameField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        updateOKAction();\n        myStatusLabel.setForeground(UIUtil.getLabelForeground());\n        myStatusLabel.setText(VcsBundle.message(\"patch.load.progress\"));\n        myPatches = null;\n        myLoadPatchAlarm.cancelAllRequests();\n        myLoadPatchAlarm.addRequest(new Runnable() {\n          public void run() {\n            checkLoadPatches();\n          }\n        }, 400);\n      }\n    });\n\n    myBaseDirectoryField.setText(project.getBaseDir().getPresentableUrl());\n    myBaseDirectoryField.addBrowseFolderListener(VcsBundle.message(\"patch.apply.select.base.directory.title\"), \"\", project,\n                                                 new FileChooserDescriptor(false, true, false, false, false, false));\n    myBaseDirectoryField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        if (!myInnerChange) {\n          queueVerifyPatchPaths();\n        }\n      }\n    });\n\n    myStripLeadingDirectoriesSpinner.setModel(new SpinnerNumberModel(0, 0, 256, 1));\n    myStripLeadingDirectoriesSpinner.addChangeListener(new ChangeListener() {\n      public void stateChanged(final ChangeEvent e) {\n        if (!myInnerChange) {\n          queueVerifyPatchPaths();\n        }\n      }\n    });\n\n    myPatchContentsList.setCellRenderer(new PatchCellRendererPanel());\n\n    ChangeListManager changeListManager = ChangeListManager.getInstance(project);\n    myChangeListChooser.setChangeLists(changeListManager.getChangeLists());\n    myChangeListChooser.setDefaultSelection(changeListManager.getDefaultChangeList());\n\n    init();\n    updateOKAction();\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void customizeCellRenderer(JTable table, Object value, boolean selected, boolean hasFocus, int row, int column) {\n      FilePatch filePatch = (FilePatch) value;\n      String name = filePatch.getAfterNameRelative(getStripLeadingDirectories());\n      if (myPatchesFailedToLoad.contains(filePatch) && !assumeProblemWillBeFixed(filePatch)) {\n        append(name, SimpleTextAttributes.ERROR_ATTRIBUTES);\n      }\n      else if (filePatch.isNewFile()) {\n        append(name, myNewAttributes);\n      }\n      else if (filePatch.isDeletedFile()) {\n        append(name, myDeletedAttributes);\n      }\n      else {\n        append(name, myModifiedAttributes);\n      }\n    }","id":84764,"modified_method":"protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n      FilePatch filePatch = (FilePatch) value;\n      String name = filePatch.getAfterNameRelative(getStripLeadingDirectories());\n\n      final FileType fileType = FileTypeManager.getInstance().getFileTypeByFileName(name);\n      setIcon(fileType.getIcon());\n\n      if (myPatchesFailedToLoad.contains(filePatch) && !assumeProblemWillBeFixed(filePatch)) {\n        append(name, SimpleTextAttributes.ERROR_ATTRIBUTES);\n      }\n      else if (filePatch.isNewFile()) {\n        append(name, myNewAttributes);\n      }\n      else if (filePatch.isDeletedFile()) {\n        append(name, myDeletedAttributes);\n      }\n      else {\n        append(name, myModifiedAttributes);\n      }\n    }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updatePatchTableModel() {\n    if (myPatches != null) {\n      myPatchTableModel = new ListTableModel<FilePatch>(PATH_COLUMN, TYPE_COLUMN);\n      myPatchTableModel.setItems(myPatches);\n      myPatchContentsTable.setModel(myPatchTableModel);\n    }\n    else {\n      myPatchTableModel = null;\n      myPatchContentsTable.setModel(new DefaultTableModel());\n    }\n  }","id":84765,"modified_method":"private void updatePatchTableModel() {\n    if (myPatches != null) {\n      myPatchContentsList.setModel(new AbstractListModel() {\n        public int getSize() {\n          return myPatches.size();\n        }\n\n        public Object getElementAt(int index) {\n          return myPatches.get(index);\n        }\n      });\n    }\n    else {\n      myPatchContentsList.setModel(new DefaultListModel());\n    }\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    mySelectedList = myPanel.getSelectedList();\n    if (mySelectedList != null) {\n      super.doOKAction();\n    }\n  }","id":84766,"modified_method":"protected void doOKAction() {\n    mySelectedList = myPanel.getSelectedList(myProject);\n    if (mySelectedList != null) {\n      super.doOKAction();\n    }\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangeListChooser(@NotNull Project project,\n                           @NotNull Collection<? extends ChangeList> changelists,\n                           @Nullable ChangeList defaultSelection,\n                           final String title,\n                           @Nullable final String defaultName) {\n    super(project, false);\n\n    myPanel = new ChangeListChooserPanel(project);\n    myPanel.setChangeLists(changelists);\n    myPanel.setDefaultSelection(defaultSelection);\n\n    setTitle(title);\n    if (defaultName != null) {\n      myPanel.setDefaultName(defaultName);\n    }\n\n    init();\n  }","id":84767,"modified_method":"public ChangeListChooser(@NotNull Project project,\n                           @NotNull Collection<? extends ChangeList> changelists,\n                           @Nullable ChangeList defaultSelection,\n                           final String title,\n                           @Nullable final String defaultName) {\n    super(project, false);\n    myProject = project;\n\n    myPanel = new ChangeListChooserPanel();\n    myPanel.setChangeLists(changelists);\n    myPanel.setDefaultSelection(defaultSelection);\n\n    setTitle(title);\n    if (defaultName != null) {\n      myPanel.setDefaultName(defaultName);\n    }\n\n    init();\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangeListChooserPanel(Project project) {\n    super(new BorderLayout());\n    myProject = project;\n    add(myPanel, BorderLayout.CENTER);\n\n    myExisitingsCombo.setRenderer(new ColoredListCellRenderer() {\n      protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        append(((ChangeList)value).getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      }\n    });\n\n    myRbExisting.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        updateEnabledItems();\n      }\n    });\n  }","id":84768,"modified_method":"public ChangeListChooserPanel() {\n    super(new BorderLayout());\n    add(myPanel, BorderLayout.CENTER);\n\n    myExisitingsCombo.setRenderer(new ColoredListCellRenderer() {\n      protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value != null) {\n          append(((ChangeList)value).getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n      }\n    });\n\n    myRbExisting.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        updateEnabledItems();\n      }\n    });\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LocalChangeList getSelectedList() {\n    if (myRbNew.isSelected()) {\n      String newText = myNewListPanel.getName();\n      if (ChangeListManager.getInstance(myProject).findChangeList(newText) != null) {\n        Messages.showErrorDialog(myProject,\n                                 VcsBundle.message(\"changes.newchangelist.warning.already.exists.text\", newText),\n                                 VcsBundle.message(\"changes.newchangelist.warning.already.exists.title\"));\n        return null;\n      }\n    }\n\n    if (myRbExisting.isSelected()) {\n      return (LocalChangeList)myExisitingsCombo.getSelectedItem();\n    }\n    else {\n      return ChangeListManager.getInstance(myProject).addChangeList(myNewListPanel.getName(), myNewListPanel.getDescription());\n    }\n  }","id":84769,"modified_method":"@Nullable\n  public LocalChangeList getSelectedList(Project project) {\n    if (myRbNew.isSelected()) {\n      String newText = myNewListPanel.getName();\n      if (ChangeListManager.getInstance(project).findChangeList(newText) != null) {\n        Messages.showErrorDialog(project,\n                                 VcsBundle.message(\"changes.newchangelist.warning.already.exists.text\", newText),\n                                 VcsBundle.message(\"changes.newchangelist.warning.already.exists.title\"));\n        return null;\n      }\n    }\n\n    if (myRbExisting.isSelected()) {\n      return (LocalChangeList)myExisitingsCombo.getSelectedItem();\n    }\n    else {\n      return ChangeListManager.getInstance(project).addChangeList(myNewListPanel.getName(), myNewListPanel.getDescription());\n    }\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    final ShelvedChangeList[] changeLists = e.getData(ShelvedChangesViewManager.SHELVED_CHANGELIST_KEY);\n    List<ShelvedChange> changes = e.getData(ShelvedChangesViewManager.SHELVED_CHANGE_KEY);\n    List<ShelvedBinaryFile> binaryFiles = e.getData(ShelvedChangesViewManager.SHELVED_BINARY_FILE_KEY);\n    if (changes != null && binaryFiles != null && changes.size() == 0 && binaryFiles.size() == 0) {\n      changes = null;\n      binaryFiles = null;\n    }\n    LOG.assertTrue(changeLists != null);\n\n    final ChangeListManager changeListManager = ChangeListManager.getInstance(project);\n    final List<LocalChangeList> allChangeLists = changeListManager.getChangeLists();\n    final LocalChangeList defaultChangeList = changeListManager.getDefaultChangeList();\n    String defaultName = changeLists.length == 1 ? changeLists [0].DESCRIPTION : null;\n    ChangeListChooser chooser = new ChangeListChooser(project, allChangeLists, defaultChangeList,\n                                                      VcsBundle.message(\"unshelve.changelist.chooser.title\"), \n                                                      defaultName);\n    chooser.show();\n    if (!chooser.isOK()) {\n      return;\n    }\n\n    FileDocumentManager.getInstance().saveAllDocuments();\n    List<FilePath> unshelvedFiles = new ArrayList<FilePath>();\n\n    for(ShelvedChangeList changeList: changeLists) {\n      final List<FilePath> result = ShelveChangesManager.getInstance(project).unshelveChangeList(changeList, changes, binaryFiles);\n      if (result == null) {\n        break;\n      }\n      unshelvedFiles.addAll(result);\n    }\n\n    if (chooser.getSelectedList() != changeListManager.getDefaultChangeList()) {\n      changeListManager.ensureUpToDate(false);\n      List<Change> unshelvedChanges = new ArrayList<Change>();\n      for(FilePath file: unshelvedFiles) {\n        final Change change = changeListManager.getChange(file);\n        if (change != null) {\n          unshelvedChanges.add(change);\n        }\n      }\n      changeListManager.moveChangesTo(chooser.getSelectedList(), unshelvedChanges.toArray(new Change[unshelvedChanges.size()]));\n    }\n  }","id":84770,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    final ShelvedChangeList[] changeLists = e.getData(ShelvedChangesViewManager.SHELVED_CHANGELIST_KEY);\n    List<ShelvedChange> changes = e.getData(ShelvedChangesViewManager.SHELVED_CHANGE_KEY);\n    List<ShelvedBinaryFile> binaryFiles = e.getData(ShelvedChangesViewManager.SHELVED_BINARY_FILE_KEY);\n    if (changes != null && binaryFiles != null && changes.size() == 0 && binaryFiles.size() == 0) {\n      changes = null;\n      binaryFiles = null;\n    }\n    LOG.assertTrue(changeLists != null);\n\n    final ChangeListManager changeListManager = ChangeListManager.getInstance(project);\n    final List<LocalChangeList> allChangeLists = changeListManager.getChangeLists();\n    final LocalChangeList defaultChangeList = changeListManager.getDefaultChangeList();\n    String defaultName = changeLists.length == 1 ? changeLists [0].DESCRIPTION : null;\n    ChangeListChooser chooser = new ChangeListChooser(project, allChangeLists, defaultChangeList,\n                                                      VcsBundle.message(\"unshelve.changelist.chooser.title\"), \n                                                      defaultName);\n    chooser.show();\n    if (!chooser.isOK()) {\n      return;\n    }\n\n    FileDocumentManager.getInstance().saveAllDocuments();\n    List<FilePath> unshelvedFiles = new ArrayList<FilePath>();\n\n    for(ShelvedChangeList changeList: changeLists) {\n      final List<FilePath> result = ShelveChangesManager.getInstance(project).unshelveChangeList(changeList, changes, binaryFiles);\n      if (result == null) {\n        break;\n      }\n      unshelvedFiles.addAll(result);\n    }\n\n    ApplyPatchAction.moveChangesToList(project, unshelvedFiles, chooser.getSelectedList());\n  }","commit_id":"0a7419c46e698e7b8edd9bf53ce30abc487fad08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void _check() throws CommitStepException {\n    if (myOptions.getCreateNewLanguage()) {\n      File dir = new File(myPath.getPath());\n      if (!(dir.isAbsolute())) {\n        throw new CommitStepException(\"Path should path\");\n      }\n      if (myNamespace.getText().length() == 0) {\n        throw new CommitStepException(\"Enter namespace\");\n      }\n      if (MPSModuleRepository.getInstance().getModuleByUID(myNamespace.getText()) != null) {\n        throw new CommitStepException(\"Language namespace already exists\");\n      }\n      if (NameUtil.shortNameFromLongName(myNamespace.getText()).length() == 0) {\n        throw new CommitStepException(\"Enter valid namespace\");\n      }\n      if (!(dir.exists())) {\n        dir.mkdirs();\n      }\n    }\n  }","id":84771,"modified_method":"public void _check() throws CommitStepException {\n    if (myOptions.getCreateNewLanguage()) {\n      File dir = new File(myPath.getPath());\n      if (!(dir.isAbsolute())) {\n        throw new CommitStepException(\"Path should path\");\n      }\n      if (myNamespace.getText().length() == 0) {\n        throw new CommitStepException(\"Enter namespace\");\n      }\n      if (MPSModuleRepository.getInstance().getModuleByUID(myNamespace.getText()) != null) {\n        throw new CommitStepException(\"Language namespace already exists\");\n      }\n      if (NameUtil.shortNameFromLongName(myNamespace.getText()).length() == 0) {\n        throw new CommitStepException(\"Enter valid namespace\");\n      }\n    }\n  }","commit_id":"47dabebe80b7e458a3e95095f2c44465d8bab734","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doOKAction() {\n    super.doOKAction();\n\n    ProgressManager.getInstance().run(new Task.Modal(myProject, \"Creating\", false) {\n      public void run(@NotNull()ProgressIndicator indicator) {\n        indicator.setIndeterminate(true);\n        createProject();\n      }\n    });\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        if (myCreatedSolution != null && myCreatedLanguage != null) {\n          addLanguageImportToSolution(myCreatedLanguage, myCreatedSolution);\n        }\n      }\n    });\n\n    if (myCreatedProject == null) return;\n\n    myCreatedProject.save();\n    ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    projectManager.openProject(myCreatedProject);\n  }","id":84772,"modified_method":"protected void doOKAction() {\n    final String[] error = new String[]{null};\n    ProgressManager.getInstance().run(new Task.Modal(myProject, \"Creating\", false) {\n      public void run(@NotNull() ProgressIndicator indicator) {\n        indicator.setIndeterminate(true);\n        error[0] = createDirs();\n        if (error[0] != null) {\n          return;\n        }\n        createProject();\n      }\n    });\n    if (error[0] != null) {\n      Messages.showErrorDialog(getContentPane(), error[0]);\n      return;\n    }\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        if (myCreatedSolution != null && myCreatedLanguage != null) {\n          addLanguageImportToSolution(myCreatedLanguage, myCreatedSolution);\n        }\n      }\n    });\n\n    if (myCreatedProject == null) return;\n\n    myCreatedProject.save();\n    ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    projectManager.openProject(myCreatedProject);\n\n    super.doOKAction();\n  }","commit_id":"47dabebe80b7e458a3e95095f2c44465d8bab734","url":"https://github.com/JetBrains/MPS"},{"original_method":"private IFile createNewSolution() {\n    SNode solutionDescriptor = SConceptOperations.createNewNode(\"jetbrains.mps.projectLanguage.structure.SolutionDescriptor\", null);\n    SPropertyOperations.set(solutionDescriptor, \"externallyVisible\", \"\" + (true));\n    SPropertyOperations.set(solutionDescriptor, \"compileInMPS\", \"\" + true);\n    FileSystemFile solutionFile = new FileSystemFile(myOptions.getSolutionPath() + File.separator + myOptions.getSolutionNamespace() + MPSExtentions.DOT_SOLUTION);\n    String fileName = solutionFile.getName();\n    SPropertyOperations.set(solutionDescriptor, \"name\", fileName.substring(0, fileName.length() - 4));\n    SNode modelRoot = SConceptOperations.createNewNode(\"jetbrains.mps.projectLanguage.structure.ModelRoot\", null);\n    SPropertyOperations.set(modelRoot, \"prefix\", \"\");\n    SPropertyOperations.set(modelRoot, \"path\", solutionFile.getParent().getAbsolutePath());\n    SLinkOperations.addChild(solutionDescriptor, \"modelRoot\", modelRoot);\n    DescriptorsPersistence.saveSolutionDescriptor(solutionFile, (SolutionDescriptor) SNodeOperations.getAdapter(solutionDescriptor));\n\n    return solutionFile;\n  }","id":84773,"modified_method":"private IFile createNewSolution() {\n    SNode solutionDescriptor = SConceptOperations.createNewNode(\"jetbrains.mps.projectLanguage.structure.SolutionDescriptor\", null);\n    SPropertyOperations.set(solutionDescriptor, \"externallyVisible\", \"\" + (true));\n    SPropertyOperations.set(solutionDescriptor, \"compileInMPS\", \"\" + true);\n    FileSystemFile solutionFile = new FileSystemFile(getSolutionFileName());\n    String fileName = solutionFile.getName();\n    SPropertyOperations.set(solutionDescriptor, \"name\", fileName.substring(0, fileName.length() - 4));\n    SNode modelRoot = SConceptOperations.createNewNode(\"jetbrains.mps.projectLanguage.structure.ModelRoot\", null);\n    SPropertyOperations.set(modelRoot, \"prefix\", \"\");\n    SPropertyOperations.set(modelRoot, \"path\", solutionFile.getParent().getAbsolutePath());\n    SLinkOperations.addChild(solutionDescriptor, \"modelRoot\", modelRoot);\n    DescriptorsPersistence.saveSolutionDescriptor(solutionFile, (SolutionDescriptor) SNodeOperations.getAdapter(solutionDescriptor));\n\n    return solutionFile;\n  }","commit_id":"47dabebe80b7e458a3e95095f2c44465d8bab734","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void _check() throws CommitStepException {\n    if (myProjectPath.getPath() == null) {\n      throw new CommitStepException(\"Project path should be specified\");\n    }\n    File projectDirFile = new File(myProjectPath.getPath());\n    if (!(projectDirFile.isAbsolute())) {\n      throw new CommitStepException(\"Path should be absolute\");\n    }\n    if (myProjectName.getText().length() == 0) {\n      throw new CommitStepException(\"Project name shouldn't be empty\");\n    }\n    if (!(projectDirFile.exists())) {\n      projectDirFile.mkdirs();\n    }\n  }","id":84774,"modified_method":"public void _check() throws CommitStepException {\n    if (myProjectPath.getPath() == null) {\n      throw new CommitStepException(\"Project path should be specified\");\n    }\n    File projectDirFile = new File(myProjectPath.getPath());\n    if (!(projectDirFile.isAbsolute())) {\n      throw new CommitStepException(\"Path should be absolute\");\n    }\n    if (myProjectName.getText().length() == 0) {\n      throw new CommitStepException(\"Project name shouldn't be empty\");\n    }\n  }","commit_id":"47dabebe80b7e458a3e95095f2c44465d8bab734","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void _check() throws CommitStepException {\n    if (myOptions.getCreateNewSolution()) {\n      if (myPath.getPath().length() == 0) {\n        throw new CommitStepException(\"Enter solution directory\");\n      }\n      if (myNamespace.getText().length() == 0) {\n        throw new CommitStepException(\"Enter solution name\");\n      }\n      if (MPSModuleRepository.getInstance().getModuleByUID(myNamespace.getText()) != null) {\n        throw new CommitStepException(\"Duplicate solution name\");\n      }\n      String descriptorPath = myPath.getPath() + File.separator + myNamespace.getText() + MPSExtentions.DOT_SOLUTION;\n      File file = new File(descriptorPath);\n      if (file.exists()) {\n        throw new CommitStepException(\"Solution file already exists\");\n      }\n      File dir = file.getParentFile();\n      if (!(dir.isAbsolute())) {\n        throw new CommitStepException(\"Path should be absolute\");\n      }\n      if (!(dir.exists())) {\n        dir.mkdirs();\n      }\n      final File descriptorFile = prepareToCreateNewSolutionDescriptorFile(descriptorPath);\n      if (descriptorFile == null) {\n        throw new CommitStepException(\"Can't create \" + descriptorPath);\n      }\n    }\n  }","id":84775,"modified_method":"public void _check() throws CommitStepException {\n    if (myOptions.getCreateNewSolution()) {\n      if (myPath.getPath().length() == 0) {\n        throw new CommitStepException(\"Enter solution directory\");\n      }\n      if (myNamespace.getText().length() == 0) {\n        throw new CommitStepException(\"Enter solution name\");\n      }\n      if (MPSModuleRepository.getInstance().getModuleByUID(myNamespace.getText()) != null) {\n        throw new CommitStepException(\"Duplicate solution name\");\n      }\n      File file = new File(myPath.getPath());\n      if (file.exists()) {\n        throw new CommitStepException(\"Solution file already exists\");\n      }\n      File dir = file.getParentFile();\n      if (!(dir.isAbsolute())) {\n        throw new CommitStepException(\"Path should be absolute\");\n      }\n    }\n  }","commit_id":"47dabebe80b7e458a3e95095f2c44465d8bab734","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getCommentString() {\n    return\n      \"Solutions are used to store application's code written in MPS languages. \" +\n        \"Each solution is a set of models with a name.\";\n  }","id":84776,"modified_method":"public String getCommentString() {\n    return\n      \"Solutions are used to storeZ code written in MPS languages. \" +\n        \"Each solution is a set of models with a name.\";\n  }","commit_id":"47dabebe80b7e458a3e95095f2c44465d8bab734","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doOKAction(){\n    if(myTemplate == null){\n      return;\n    }\n    String fileName = null;\n    Properties props = myAttrPanel.getProperties();\n    if (!myTemplate.isJavaClassTemplate()){\n      fileName = myAttrPanel.getFileName();\n      if (fileName.length() == 0){\n        Messages.showMessageDialog(myAttrComponent, IdeBundle.message(\"error.please.enter.a.file.name\"),\n                                   CommonBundle.getErrorTitle(), Messages.getErrorIcon());\n        return;\n      }\n    }\n    try{\n      PsiElement[] element = new PsiElement[1];\n      FileTemplateUtil.createFromTemplate(element, myTemplate, fileName, props, myProject, myDirectory);\n      myCreatedElement = element[0];\n      super.doOKAction();\n    }\n    catch (Exception e){\n      showErrorMessage(myAttrComponent, myTemplate, e);\n    }\n  }","id":84777,"modified_method":"protected void doOKAction(){\n    String fileName = myAttrPanel.getFileName();\n    if (fileName != null && fileName.length() == 0) {\n      Messages.showMessageDialog(myAttrComponent, IdeBundle.message(\"error.please.enter.a.file.name\"), CommonBundle.getErrorTitle(),\n                                 Messages.getErrorIcon());\n      return;\n    }\n    doCreate(fileName);\n    if ( myCreatedElement != null ) {\n      super.doOKAction();\n    }\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CreateFromTemplateDialog(Project project, PsiDirectory directory, FileTemplate template) throws ParseException {\n    super(project, true);\n    LOG.assertTrue(directory != null, \"Directory cannot be null\");\n    LOG.assertTrue(template != null, \"Template cannot be null\");\n    myDirectory = directory;\n    myProject = project;\n    myTemplate = template;\n    setTitle(IdeBundle.message(\"title.new.from.template\", template.getName()));\n\n    PsiPackage aPackage = myDirectory.getPackage();\n    String packageName = aPackage == null ? \"\" : aPackage.getQualifiedName();\n    Properties defaultProperties = FileTemplateManager.getInstance().getDefaultProperties();\n    defaultProperties.setProperty(FileTemplateUtil.PACKAGE_ATTR, packageName);\n    myAttrPanel = new CreateFromTemplatePanel(myTemplate, defaultProperties);\n    myAttrComponent = myAttrPanel.getComponent();\n    init();\n  }","id":84778,"modified_method":"public CreateFromTemplateDialog(@NotNull Project project, @NotNull PsiDirectory directory, @NotNull FileTemplate template) {\n    super(project, true);\n    myDirectory = directory;\n    myProject = project;\n    myTemplate = template;\n    setTitle(IdeBundle.message(\"title.new.from.template\", template.getName()));\n\n    PsiPackage aPackage = myDirectory.getPackage();\n    String packageName = aPackage == null ? \"\" : aPackage.getQualifiedName();\n    myDefaultProperties = FileTemplateManager.getInstance().getDefaultProperties();\n    myDefaultProperties.setProperty(FileTemplateUtil.PACKAGE_ATTR, packageName);\n\n    try {\n      myAttrPanel = new CreateFromTemplatePanel(myTemplate.getUnsetAttributes(myDefaultProperties), !myTemplate.isJavaClassTemplate());\n    } catch (ParseException e) {\n      throw new RuntimeException(IdeBundle.message(\"error.unable.to.parse.template\", myTemplate.getName()), e);\n    }\n\n    myAttrComponent = myAttrPanel.getComponent();\n    init();\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AnAction[] getChildren(@Nullable AnActionEvent e){\n    FileTemplateManager manager = FileTemplateManager.getInstance();\n    FileTemplate[] templates = manager.getAllTemplates();\n\n    boolean showAll = templates.length <= FileTemplateManager.RECENT_TEMPLATES_SIZE;\n    if (!showAll) {\n      Collection<String> recentNames = manager.getRecentNames();\n      templates = new FileTemplate[recentNames.size()];\n      int i = 0;\n      for (String name : recentNames) {\n        templates[i] = FileTemplateManager.getInstance().getTemplate(name);\n        i++;\n      }\n    }\n\n    Arrays.sort(templates, new Comparator<FileTemplate>() {\n      public int compare(FileTemplate template1, FileTemplate template2) {\n        // java first\n        if (template1.isJavaClassTemplate() && !template2.isJavaClassTemplate()) {\n          return -1;\n        }\n        if (template2.isJavaClassTemplate() && !template1.isJavaClassTemplate()) {\n          return 1;\n        }\n\n        // group by type\n        int i = template1.getExtension().compareTo(template2.getExtension());\n        if (i != 0) {\n          return i;\n        }\n\n        // group by name if same type\n        return template1.getName().compareTo(template2.getName());\n      }\n    });\n    List<AnAction> result = new ArrayList<AnAction>();\n\n    final CreateFromTemplateActionReplacer[] actionFactories =\n      ApplicationManager.getApplication().getExtensions(CreateFromTemplateActionReplacer.CREATE_FROM_TEMPLATE_REPLACER);\n    for (FileTemplate template : templates) {\n      if (canCreateFromTemplate(e, template)) {\n        AnAction action = null;\n        for (CreateFromTemplateActionReplacer actionFactory : actionFactories) {\n          action = actionFactory.replaceCreateFromFileTemplateAction(template);\n          if (action != null) {\n            break;\n          }\n        }\n        if (action == null) {\n          action = new CreateFromTemplateAction(template);\n        }\n        result.add(action);\n      }\n    }\n\n    if (!result.isEmpty()) {\n      if (!showAll) {\n        result.add(new CreateFromTemplatesAction(IdeBundle.message(\"action.from.file.template\")));\n      }\n\n      result.add(Separator.getInstance());\n      result.add(new EditFileTemplatesAction(IdeBundle.message(\"action.edit.file.templates\")));\n    }\n\n    return result.toArray(new AnAction[result.size()]);\n}","id":84779,"modified_method":"public AnAction[] getChildren(@Nullable AnActionEvent e){\n    FileTemplateManager manager = FileTemplateManager.getInstance();\n    FileTemplate[] templates = manager.getAllTemplates();\n\n    boolean showAll = templates.length <= FileTemplateManager.RECENT_TEMPLATES_SIZE;\n    if (!showAll) {\n      Collection<String> recentNames = manager.getRecentNames();\n      templates = new FileTemplate[recentNames.size()];\n      int i = 0;\n      for (String name : recentNames) {\n        templates[i] = FileTemplateManager.getInstance().getTemplate(name);\n        i++;\n      }\n    }\n\n    Arrays.sort(templates, new Comparator<FileTemplate>() {\n      public int compare(FileTemplate template1, FileTemplate template2) {\n        // java first\n        if (template1.isJavaClassTemplate() && !template2.isJavaClassTemplate()) {\n          return -1;\n        }\n        if (template2.isJavaClassTemplate() && !template1.isJavaClassTemplate()) {\n          return 1;\n        }\n\n        // group by type\n        int i = template1.getExtension().compareTo(template2.getExtension());\n        if (i != 0) {\n          return i;\n        }\n\n        // group by name if same type\n        return template1.getName().compareTo(template2.getName());\n      }\n    });\n    List<AnAction> result = new ArrayList<AnAction>();\n\n    for (FileTemplate template : templates) {\n      if (canCreateFromTemplate(e, template)) {\n        AnAction action = replaceAction(template);\n        if (action == null) {\n          action = new CreateFromTemplateAction(template);\n        }\n        result.add(action);\n      }\n    }\n\n    if (!result.isEmpty()) {\n      if (!showAll) {\n        result.add(new CreateFromTemplatesAction(IdeBundle.message(\"action.from.file.template\")));\n      }\n\n      result.add(Separator.getInstance());\n      result.add(new EditFileTemplatesAction(IdeBundle.message(\"action.edit.file.templates\")));\n    }\n\n    return result.toArray(new AnAction[result.size()]);\n}","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CreateFromTemplatesAction(String title){\n      super(title);\n    }","id":84780,"modified_method":"public CreateFromTemplatesAction(String title){\n      super(title,null,null);\n    }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CreateFromTemplatePanel(FileTemplate template, Properties predefinedProperties){\n    myTemplate = template;\n    myPredefinedProperties = predefinedProperties;\n  }","id":84781,"modified_method":"public CreateFromTemplatePanel(final String[] unsetAttributes, final boolean mustEnterName){\n    this.mustEnterName = mustEnterName;\n    myUnsetAttributes = unsetAttributes;\n    Arrays.sort(myUnsetAttributes);\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Properties getProperties(){\n    Properties result = (Properties) myPredefinedProperties.clone();\n    for (Iterator<Pair<String,JTextField>> i = myAttributes.iterator(); i.hasNext();) {\n      Pair<String,JTextField> pair = i.next();\n      result.put(pair.first, pair.second.getText());\n    }\n    return result;\n  }","id":84782,"modified_method":"public Properties getProperties(Properties predefinedProperties){\n    Properties result = (Properties) predefinedProperties.clone();\n    for (Pair<String, JTextField> pair : myAttributes) {\n      result.put(pair.first, pair.second.getText());\n    }\n    return result;\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getFileName(){\n    String fileName = myFilenameField.getText();\n    return fileName == null ? \"\" : fileName;\n  }","id":84783,"modified_method":"@Nullable\n  public String getFileName(){\n    if (myFilenameField!=null) {\n      String fileName = myFilenameField.getText();\n      return fileName == null ? \"\" : fileName;\n    } else {\n      return null;\n    }\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateShown() throws ParseException{\n    String[] attributes = ArrayUtil.EMPTY_STRING_ARRAY;\n    ParseException thrownException = null;\n\n    try {\n      attributes = myTemplate.getUnsetAttributes(myPredefinedProperties);\n      Arrays.sort(attributes);\n    }\n    catch (ParseException e) {\n      thrownException = e;\n    }\n\n    Insets insets = new Insets(2, 2, 2, 2);\n    myAttrPanel.add(Box.createHorizontalStrut(200), new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, insets, 0, 0));\n    if(!myTemplate.isJavaClassTemplate()){\n      myAttrPanel.add(myFilenameLabel, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, insets, 0, 0));\n      myAttrPanel.add(myFilenameField, new GridBagConstraints(0, 2, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, insets, 0, 0));\n    }\n    else{\n      myAttrPanel.remove(myFilenameLabel);\n      myAttrPanel.remove(myFilenameField);\n    }\n\n    for (int i = 0; i < attributes.length; i++){\n      String attribute = attributes[i];\n      JLabel label = new JLabel(attribute.replace('_', ' ') + \":\");\n      JTextField field = new JTextField();\n      myAttributes.add(new Pair<String,JTextField> (attribute, field));\n      myAttrPanel.add(label,     new GridBagConstraints(0, myLastRow*2+3, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, insets, 0, 0));\n      myAttrPanel.add(field, new GridBagConstraints(0, myLastRow*2+4, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, insets, 0, 0));\n      myLastRow++;\n    }\n\n    myAttrPanel.repaint();\n    myAttrPanel.revalidate();\n    myMainPanel.revalidate();\n    if(thrownException != null){\n      throw thrownException;\n    }\n  }","id":84784,"modified_method":"private void updateShown() {\n    Insets insets = new Insets(2, 2, 2, 2);\n    myAttrPanel.add(Box.createHorizontalStrut(200), new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, insets, 0, 0));\n    if(mustEnterName || Arrays.asList(myUnsetAttributes).contains(FileTemplateUtil.NAME_ATTR)){\n      final JLabel filenameLabel = new JLabel(IdeBundle.message(\"label.file.name\"));\n      myAttrPanel.add(filenameLabel, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, insets, 0, 0));\n      myFilenameField = new JTextField();\n      myAttrPanel.add(myFilenameField, new GridBagConstraints(0, 2, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, insets, 0, 0));\n    }\n\n    for (String attribute : myUnsetAttributes) {\n      if (attribute.equals(FileTemplateUtil.NAME_ATTR)) { // already asked above\n        continue;\n      }\n      JLabel label = new JLabel(attribute.replace('_', ' ') + \":\");\n      JTextField field = new JTextField();\n      myAttributes.add(new Pair<String, JTextField>(attribute, field));\n      myAttrPanel.add(label, new GridBagConstraints(0, myLastRow * 2 + 3, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                                    insets, 0, 0));\n      myAttrPanel.add(field, new GridBagConstraints(0, myLastRow * 2 + 4, 1, 1, 1.0, 0.0, GridBagConstraints.WEST,\n                                                    GridBagConstraints.HORIZONTAL, insets, 0, 0));\n      myLastRow++;\n    }\n\n    myAttrPanel.repaint();\n    myAttrPanel.revalidate();\n    myMainPanel.revalidate();\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement createFromTemplate(final FileTemplate template, @NonNls final String fileName, Properties props, final Project project, final PsiDirectory directory) throws Exception{\n    PsiElement[] result = new PsiElement[1];\n    createFromTemplate(result, template, fileName, props, project, directory);\n    return result[0];\n  }","id":84785,"modified_method":"public static PsiElement createFromTemplate(final FileTemplate template, @NonNls final String fileName, Properties props, final Project project, final PsiDirectory directory) throws Exception{\n    final PsiElement[] result = new PsiElement[1];\n    if (props == null) {\n      props = FileTemplateManager.getInstance().getDefaultProperties();\n    }\n    FileTemplateManager.getInstance().addRecentName(template.getName());\n\n    if ( fileName != null ) {\n      props.setProperty(NAME_ATTR, fileName);\n    }\n\n    //Set escaped references to dummy values to remove leading \"\\\" (if not already explicitely set)\n    String[] dummyRefs = calculateAttributes(template.getText(), props, true);\n    for (String dummyRef : dummyRefs) {\n      props.setProperty(dummyRef, \"\");\n    }\n    String mergedText;\n\n    try{\n      if (template.isJavaClassTemplate()){\n        String packageName = props.getProperty(PACKAGE_ATTR);\n        if(packageName == null || packageName.length() == 0){\n          props = new Properties(props);\n          props.setProperty(PACKAGE_ATTR, PACKAGE_ATTR);\n        }\n      }\n      mergedText = template.getText(props);\n    }\n    catch (Exception e){\n      throw e;\n    }\n    final String templateText = StringUtil.convertLineSeparators(mergedText);\n    final Exception[] commandException = new Exception[1];\n    CommandProcessor.getInstance().executeCommand(project, new Runnable(){\n      public void run(){\n        final Runnable run = new Runnable(){\n          public void run(){\n            try{\n              FileType fileType = FileTypeManagerEx.getInstanceEx().getFileTypeByExtension(template.getExtension());\n              if (fileType.equals(StdFileTypes.JAVA)) {\n                String extension = template.getExtension();\n                result[0] = createClassOrInterface(project, directory, templateText, template.isAdjust(), extension);\n              }\n              else{\n                result[0] = createPsiFile(project, directory, templateText, fileName, template.getExtension());\n              }\n            }\n            catch (Exception ex){\n              commandException[0] = ex;\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(run);\n      }\n    }, template.isJavaClassTemplate()\n       ? IdeBundle.message(\"command.create.class.from.template\")\n       : IdeBundle.message(\"command.create.file.from.template\"), null);\n    if(commandException[0] != null){\n      throw commandException[0];\n    }\n    return result[0];\n  }","commit_id":"977baebf208308c6db94ad504f609bbaba41e252","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group1 = GroupTestUtil.addGroup();\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group1.getGroupId());\n\n\t\tAssetVocabulary vocabulary =\n\t\t\tAssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\t\tserviceContext);\n\n\t\t_vocabularyId = vocabulary.getVocabularyId();\n\n\t\tAssetCategory fashionCategory =\n\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tTestPropsValues.getUserId(), \"Fashion\", _vocabularyId,\n\t\t\t\tserviceContext);\n\n\t\t_fashionCategoryId = fashionCategory.getCategoryId();\n\n\t\tAssetCategory foodCategory = AssetCategoryLocalServiceUtil.addCategory(\n\t\t\tTestPropsValues.getUserId(), \"Food\", _vocabularyId, serviceContext);\n\n\t\t_foodCategoryId = foodCategory.getCategoryId();\n\n\t\tAssetCategory healthCategory =\n\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tTestPropsValues.getUserId(), \"Health\", _vocabularyId,\n\t\t\t\tserviceContext);\n\n\t\t_healthCategoryId = healthCategory.getCategoryId();\n\n\t\tAssetCategory sportCategory = AssetCategoryLocalServiceUtil.addCategory(\n\t\t\tTestPropsValues.getUserId(), \"Sport\", _vocabularyId,\n\t\t\tserviceContext);\n\n\t\t_sportCategoryId = sportCategory.getCategoryId();\n\n\t\tAssetCategory travelCategory =\n\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tTestPropsValues.getUserId(), \"Travel\", _vocabularyId,\n\t\t\t\tserviceContext);\n\n\t\t_travelCategoryId = travelCategory.getCategoryId();\n\n\t\t_assetCategoryIds1 =\n\t\t\tnew long[] {_healthCategoryId, _sportCategoryId, _travelCategoryId};\n\t\t_assetCategoryIds2 = new long[] {\n\t\t\t_fashionCategoryId, _foodCategoryId, _healthCategoryId,\n\t\t\t_sportCategoryId\n\t\t};\n\n\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\tTestPropsValues.getUserId(), \"liferay\", null, serviceContext);\n\n\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\tTestPropsValues.getUserId(), \"architecture\", null, serviceContext);\n\n\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\tTestPropsValues.getUserId(), \"modularity\", null, serviceContext);\n\n\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\tTestPropsValues.getUserId(), \"osgi\", null, serviceContext);\n\n\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\tTestPropsValues.getUserId(), \"services\", null, serviceContext);\n\n\t\t_assetTagsNames1 =\n\t\t\tnew String[] {\"liferay\", \"architecture\", \"modularity\", \"osgi\"};\n\t\t_assetTagsNames2 = new String[] {\"liferay\", \"architecture\", \"services\"};\n\t}","id":84786,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group1 = GroupTestUtil.addGroup();\n\n\t\tServiceContext group1ServiceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group1.getGroupId());\n\n\t\tAssetVocabulary vocabulary =\n\t\t\tAssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\t\tTestPropsValues.getUserId(), RandomTestUtil.randomString(),\n\t\t\t\tgroup1ServiceContext);\n\n\t\t_vocabularyId = vocabulary.getVocabularyId();\n\n\t\tAssetCategory fashionCategory =\n\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tTestPropsValues.getUserId(), \"Fashion\", _vocabularyId,\n\t\t\t\tgroup1ServiceContext);\n\n\t\t_fashionCategoryId = fashionCategory.getCategoryId();\n\n\t\tAssetCategory foodCategory = AssetCategoryLocalServiceUtil.addCategory(\n\t\t\tTestPropsValues.getUserId(), \"Food\", _vocabularyId,\n\t\t\tgroup1ServiceContext);\n\n\t\t_foodCategoryId = foodCategory.getCategoryId();\n\n\t\tAssetCategory healthCategory =\n\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tTestPropsValues.getUserId(), \"Health\", _vocabularyId,\n\t\t\t\tgroup1ServiceContext);\n\n\t\t_healthCategoryId = healthCategory.getCategoryId();\n\n\t\tAssetCategory sportCategory = AssetCategoryLocalServiceUtil.addCategory(\n\t\t\tTestPropsValues.getUserId(), \"Sport\", _vocabularyId,\n\t\t\tgroup1ServiceContext);\n\n\t\t_sportCategoryId = sportCategory.getCategoryId();\n\n\t\tAssetCategory travelCategory =\n\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tTestPropsValues.getUserId(), \"Travel\", _vocabularyId,\n\t\t\t\tgroup1ServiceContext);\n\n\t\t_travelCategoryId = travelCategory.getCategoryId();\n\n\t\t_assetCategoryIds1 =\n\t\t\tnew long[] {_healthCategoryId, _sportCategoryId, _travelCategoryId};\n\t\t_assetCategoryIds2 = new long[] {\n\t\t\t_fashionCategoryId, _foodCategoryId, _healthCategoryId,\n\t\t\t_sportCategoryId\n\t\t};\n\n\t\t_group2 = GroupTestUtil.addGroup();\n\n\t\tServiceContext group2ServiceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group2.getGroupId());\n\n\t\tServiceContext[] serviceContexts = new ServiceContext[] {\n\t\t\tgroup1ServiceContext, group2ServiceContext};\n\n\t\tfor (ServiceContext serviceContext : serviceContexts) {\n\t\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\t\tTestPropsValues.getUserId(), \"liferay\", null, serviceContext);\n\n\t\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\t\tTestPropsValues.getUserId(), \"architecture\", null,\n\t\t\t\tserviceContext);\n\n\t\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\t\tTestPropsValues.getUserId(), \"modularity\", null,\n\t\t\t\tserviceContext);\n\n\t\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\t\tTestPropsValues.getUserId(), \"osgi\", null, serviceContext);\n\n\t\t\tAssetTagLocalServiceUtil.addTag(\n\t\t\t\tTestPropsValues.getUserId(), \"services\", null, serviceContext);\n\t\t}\n\n\t\t_assetTagsNames1 =\n\t\t\tnew String[] {\"liferay\", \"architecture\", \"modularity\", \"osgi\"};\n\t\t_assetTagsNames2 = new String[] {\"liferay\", \"architecture\", \"services\"};\n\t}","commit_id":"771b23901790d8b84c2dc850627231f94aa9f988","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testClassQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { }\");\n\t\twaitForAutoBuild();\n\t\tXtendClass classFoo = fileFoo.getXtendClass();\n\t\tJvmGenericType inferredTypeFoo = associations.getInferredType(classFoo);\n\t\tJvmConstructor inferredConstructor = associations.getInferredConstructor(classFoo);\n\n\t\tIQueryData queryData = createQueryData(classFoo);\n\t\tassertEquals(3, queryData.getTargetURIs().size());\n\t\tassertEquals(queryData.getTargetURIs().get(0), EcoreUtil.getURI(classFoo));\n\t\tassertEquals(queryData.getTargetURIs().get(1), EcoreUtil.getURI(inferredTypeFoo));\n\t\tassertEquals(queryData.getTargetURIs().get(2), EcoreUtil.getURI(inferredConstructor));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(classFoo));\n\t}","id":84787,"modified_method":"public void testClassQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { }\");\n\t\twaitForAutoBuild();\n\t\tXtendClass classFoo = fileFoo.getXtendClass();\n\t\tJvmGenericType inferredTypeFoo = associations.getInferredType(classFoo);\n\t\tJvmConstructor inferredConstructor = associations.getInferredConstructor(classFoo);\n\n\t\tIQueryData queryData = createQueryData(classFoo);\n\t\tassertEquals(3, queryData.getTargetURIs().size());\n\t\tIterator<URI> targetURIs = queryData.getTargetURIs().iterator();\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(classFoo));\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(inferredTypeFoo));\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(inferredConstructor));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(classFoo));\n\t}","commit_id":"954aeb0cb6bfcbf40b336eb87f02594d445b1b2e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testFunctionQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { foo() null }\");\n\t\twaitForAutoBuild();\n\t\tXtendFunction functionFoo = (XtendFunction) fileFoo.getXtendClass().getMembers().get(0);\n\t\tJvmOperation inferredOperation = associations.getDirectlyInferredOperation(functionFoo);\n\n\t\tIQueryData queryData = createQueryData(functionFoo);\n\t\tassertEquals(2, queryData.getTargetURIs().size());\n\t\tassertEquals(queryData.getTargetURIs().get(0), EcoreUtil.getURI(functionFoo));\n\t\tassertEquals(queryData.getTargetURIs().get(1), EcoreUtil.getURI(inferredOperation));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(functionFoo));\n\t}","id":84788,"modified_method":"public void testFunctionQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { foo() null }\");\n\t\twaitForAutoBuild();\n\t\tXtendFunction functionFoo = (XtendFunction) fileFoo.getXtendClass().getMembers().get(0);\n\t\tJvmOperation inferredOperation = associations.getDirectlyInferredOperation(functionFoo);\n\n\t\tIQueryData queryData = createQueryData(functionFoo);\n\t\tassertEquals(2, queryData.getTargetURIs().size());\n\t\tIterator<URI> targetURIs = queryData.getTargetURIs().iterator();\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(functionFoo));\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(inferredOperation));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(functionFoo));\n\t}","commit_id":"954aeb0cb6bfcbf40b336eb87f02594d445b1b2e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected List<URI> createTargetURIs(EObject target) {\n\t\tif (target instanceof XtendClass)\n\t\t\treturn newArrayList(getURI(target), getURI(xtend2jvmAssociations.getInferredType((XtendClass) target)), getURI(xtend2jvmAssociations.getInferredConstructor((XtendClass) target)));\n\t\telse if (target instanceof XtendFunction)\n\t\t\treturn newArrayList(getURI(target), getURI(xtend2jvmAssociations.getDirectlyInferredOperation((XtendFunction) target)));\n\t\telse\n\t\t\treturn singletonList(getURI(target));\n\t}","id":84789,"modified_method":"@Override\n\tprotected Set<URI> createTargetURIs(EObject target) {\n\t\tif (target instanceof XtendClass) {\n\t\t\tSet<URI> targetURIs = newLinkedHashSet();\n\t\t\ttargetURIs.add(getURI(target));\n\t\t\ttargetURIs.add(getURI(xtend2jvmAssociations.getInferredType((XtendClass) target)));\n\t\t\ttargetURIs.add(getURI(xtend2jvmAssociations.getInferredConstructor((XtendClass) target)));\n\t\t\treturn targetURIs;\n\t\t} else if (target instanceof XtendFunction) {\n\t\t\tSet<URI> targetURIs = newLinkedHashSet();\n\t\t\ttargetURIs.add(getURI(target));\n\t\t\ttargetURIs.add(getURI(xtend2jvmAssociations.getDirectlyInferredOperation((XtendFunction) target)));\n\t\t\treturn targetURIs;\n\t\t} else {\n\t\t\treturn singleton(getURI(target));\n\t\t}\n\t}","commit_id":"954aeb0cb6bfcbf40b336eb87f02594d445b1b2e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void findLocalReferences(Resource resource, Iterable<EObject> targets,\n\t\t\tIAcceptor<IReferenceDescription> acceptor, Predicate<IReferenceDescription> filter, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled())\n\t\t\treturn;\n\t\tif (targets != null && !isEmpty(targets)) {\n\t\t\tMap<EObject, Collection<Setting>> targetResourceInternalCrossRefs = CrossReferencer.find(Collections\n\t\t\t\t\t.singletonList(resource));\n\t\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, Messages.ReferenceQuery_monitor, size(targets));\n\t\t\tfor (EObject target : targets) {\n\t\t\t\tCollection<Setting> crossRefSettings = targetResourceInternalCrossRefs.get(target);\n\t\t\t\tif (crossRefSettings != null) {\n\t\t\t\t\tSubMonitor subSubMonitor = subMonitor.newChild(crossRefSettings.size());\n\t\t\t\t\tfor (Setting crossRefSetting : crossRefSettings) {\n\t\t\t\t\t\tif (subSubMonitor.isCanceled())\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tEObject source = crossRefSetting.getEObject();\n\t\t\t\t\t\tif (crossRefSetting.getEStructuralFeature() instanceof EReference) {\n\t\t\t\t\t\t\tEReference reference = (EReference) crossRefSetting.getEStructuralFeature();\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\tif (reference.isMany()) {\n\t\t\t\t\t\t\t\tList<?> values = (List<?>) source.eGet(reference);\n\t\t\t\t\t\t\t\tfor (int i = 0; i < values.size(); ++i) {\n\t\t\t\t\t\t\t\t\tif (target == values.get(i)) {\n\t\t\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIReferenceDescription localReferenceDescription = new DefaultReferenceDescription(source,\n\t\t\t\t\t\t\t\t\ttarget, reference, index, findClosestExportedParentURI(source));\n\t\t\t\t\t\t\tif (filter == null || filter.apply(localReferenceDescription))\n\t\t\t\t\t\t\t\tacceptor.accept(localReferenceDescription);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubSubMonitor.worked(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":84790,"modified_method":"protected void findLocalReferences(Resource resource, Set<EObject> targets,\n\t\t\tIAcceptor<IReferenceDescription> acceptor, Predicate<IReferenceDescription> filter, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled())\n\t\t\treturn;\n\t\tif (targets != null && !targets.isEmpty()) {\n\t\t\tMap<EObject, Collection<Setting>> targetResourceInternalCrossRefs = CrossReferencer.find(Collections\n\t\t\t\t\t.singletonList(resource));\n\t\t\tMap<EObject, URI> exportedElementsMap = null;\n\t\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, Messages.ReferenceQuery_monitor, targets.size());\n\t\t\tfor (EObject target : targets) {\n\t\t\t\tCollection<Setting> crossRefSettings = targetResourceInternalCrossRefs.get(target);\n\t\t\t\tif (crossRefSettings != null) {\n\t\t\t\t\tSubMonitor subSubMonitor = subMonitor.newChild(crossRefSettings.size());\n\t\t\t\t\tfor (Setting crossRefSetting : crossRefSettings) {\n\t\t\t\t\t\tif (subSubMonitor.isCanceled())\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tEObject source = crossRefSetting.getEObject();\n\t\t\t\t\t\tif (crossRefSetting.getEStructuralFeature() instanceof EReference) {\n\t\t\t\t\t\t\tEReference reference = (EReference) crossRefSetting.getEStructuralFeature();\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\tif (reference.isMany()) {\n\t\t\t\t\t\t\t\tList<?> values = (List<?>) source.eGet(reference);\n\t\t\t\t\t\t\t\tfor (int i = 0; i < values.size(); ++i) {\n\t\t\t\t\t\t\t\t\tif (target == values.get(i)) {\n\t\t\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(exportedElementsMap == null)\n\t\t\t\t\t\t\t\texportedElementsMap = createExportedElementsMap(resource);\n\t\t\t\t\t\t\tIReferenceDescription localReferenceDescription = new DefaultReferenceDescription(source,\n\t\t\t\t\t\t\t\t\ttarget, reference, index, findClosestExportedContainerURI(source, exportedElementsMap));\n\t\t\t\t\t\t\tif (filter == null || filter.apply(localReferenceDescription))\n\t\t\t\t\t\t\t\tacceptor.accept(localReferenceDescription);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubSubMonitor.worked(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void findAllReferences(IQueryData queryData, ILocalResourceAccess localResourceAccess,\n\t\t\tfinal IAcceptor<IReferenceDescription> acceptor, IProgressMonitor monitor) {\n\t\tfinal SubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\tif (!isEmpty(queryData.getTargetURIs())) {\n\t\t\tfindLocalReferences(queryData, localResourceAccess, acceptor,\n\t\t\t\t\tsubMonitor.newChild(1));\n\t\t\tfindIndexedReferences(queryData, acceptor, subMonitor.newChild(1));\n\t\t}\n\t}","id":84791,"modified_method":"public void findAllReferences(IQueryData queryData, ILocalResourceAccess localResourceAccess,\n\t\t\tfinal IAcceptor<IReferenceDescription> acceptor, IProgressMonitor monitor) {\n\t\tfinal SubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\tif (!queryData.getTargetURIs().isEmpty()) {\n\t\t\tfindLocalReferences(queryData, localResourceAccess, acceptor,\n\t\t\t\t\tsubMonitor.newChild(1));\n\t\t\tfindIndexedReferences(queryData, acceptor, subMonitor.newChild(1));\n\t\t}\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void findIndexedReferences(Iterable<URI> targetURIs, IAcceptor<IReferenceDescription> acceptor,\n\t\t\tPredicate<IReferenceDescription> filter, IProgressMonitor monitor) {\n\t\tSet<URI> targetResourceURIs = newHashSet(transform(targetURIs, new Function<URI, URI>() {\n\t\t\tpublic URI apply(URI from) {\n\t\t\t\treturn from.trimFragment();\n\t\t\t}\n\t\t}));\n\t\tint numResources = Iterables.size(index.getAllResourceDescriptions());\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, Messages.ReferenceQuery_monitor, numResources);\n\t\tfor (IResourceDescription resourceDescription : index.getAllResourceDescriptions()) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tif (!targetResourceURIs.contains(resourceDescription.getURI())) {\n\t\t\t\tfor (IReferenceDescription referenceDescription : resourceDescription.getReferenceDescriptions()) {\n\t\t\t\t\tif (contains(targetURIs, referenceDescription.getTargetEObjectUri())\n\t\t\t\t\t\t\t&& (filter == null || filter.apply(referenceDescription))) {\n\t\t\t\t\t\tacceptor.accept(referenceDescription);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\t}","id":84792,"modified_method":"protected void findIndexedReferences(Set<URI> targetURIs, IAcceptor<IReferenceDescription> acceptor,\n\t\t\tPredicate<IReferenceDescription> filter, IProgressMonitor monitor) {\n\t\tSet<URI> targetResourceURIs = newHashSet(transform(targetURIs, new Function<URI, URI>() {\n\t\t\tpublic URI apply(URI from) {\n\t\t\t\treturn from.trimFragment();\n\t\t\t}\n\t\t}));\n\t\tint numResources = Iterables.size(index.getAllResourceDescriptions());\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, Messages.ReferenceQuery_monitor, numResources);\n\t\tfor (IResourceDescription resourceDescription : index.getAllResourceDescriptions()) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tif (!targetResourceURIs.contains(resourceDescription.getURI())) {\n\t\t\t\tfor (IReferenceDescription referenceDescription : resourceDescription.getReferenceDescriptions()) {\n\t\t\t\t\tif (targetURIs.contains(referenceDescription.getTargetEObjectUri())\n\t\t\t\t\t\t\t&& (filter == null || filter.apply(referenceDescription))) {\n\t\t\t\t\t\tacceptor.accept(referenceDescription);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected URI findClosestExportedParentURI(EObject element) {\n\t\tURI resourceURI = element.eResource().getURI();\n\t\tLinkedList<URI> parentURIs = newLinkedList();\n\t\tEObject currentParent = element;\n\t\twhile (currentParent != null) {\n\t\t\tparentURIs.addFirst(EcoreUtil.getURI(currentParent));\n\t\t\tcurrentParent = currentParent.eContainer();\n\t\t}\n\t\tint currentBestIndex = -1;\n\t\tIResourceDescription resourceDescription = index.getResourceDescription(resourceURI);\n\t\tif (resourceDescription != null) {\n\t\t\tfor (IEObjectDescription exportedEObject : resourceDescription.getExportedObjects()) {\n\t\t\t\tcurrentBestIndex = Math.max(currentBestIndex, parentURIs.indexOf(exportedEObject.getEObjectURI()));\n\t\t\t}\n\t\t}\n\t\tif (currentBestIndex == -1)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn parentURIs.get(currentBestIndex);\n\t}","id":84793,"modified_method":"protected URI findClosestExportedContainerURI(EObject element, Map<EObject, URI> exportedElementsMap) {\n\t\tEObject current = element;\n\t\twhile(current != null) {\n\t\t\tURI uri = exportedElementsMap.get(current);\n\t\t\tif(uri != null) \n\t\t\t\treturn uri;\n\t\t\tcurrent = current.eContainer();\n\t\t}\n\t\treturn null;\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void findLocalReferences(final IQueryData queryData,\n\t\t\tILocalResourceAccess localResourceAccess, final IAcceptor<IReferenceDescription> acceptor,\n\t\t\tIProgressMonitor monitor) {\n\t\tfinal SubMonitor subMonitor = SubMonitor.convert(monitor, \"Find references\", 1);\n\t\tlocalResourceAccess.readOnly(queryData.getLocalContextResourceURI(), new IUnitOfWork<Boolean, ResourceSet>() {\n\t\t\tpublic Boolean exec(ResourceSet localContext) throws Exception {\n\t\t\t\tResource localResource = localContext.getResource(queryData.getLocalContextResourceURI(), true);\n\t\t\t\tList<EObject> targets = newArrayList();\n\t\t\t\tfor (URI targetURI : queryData.getTargetURIs()) {\n\t\t\t\t\tEObject target = localContext.getEObject(targetURI, true);\n\t\t\t\t\tif (target != null)\n\t\t\t\t\t\ttargets.add(target);\n\t\t\t\t}\n\t\t\t\tfindLocalReferences(localResource, targets, acceptor, queryData.getResultFilter(), subMonitor);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}","id":84794,"modified_method":"public void findLocalReferences(final IQueryData queryData,\n\t\t\tILocalResourceAccess localResourceAccess, final IAcceptor<IReferenceDescription> acceptor,\n\t\t\tIProgressMonitor monitor) {\n\t\tfinal SubMonitor subMonitor = SubMonitor.convert(monitor, \"Find references\", 1);\n\t\tlocalResourceAccess.readOnly(queryData.getLocalContextResourceURI(), new IUnitOfWork<Boolean, ResourceSet>() {\n\t\t\tpublic Boolean exec(ResourceSet localContext) throws Exception {\n\t\t\t\tResource localResource = localContext.getResource(queryData.getLocalContextResourceURI(), true);\n\t\t\t\tSet<EObject> targets = newHashSet();\n\t\t\t\tfor (URI targetURI : queryData.getTargetURIs()) {\n\t\t\t\t\tEObject target = localContext.getEObject(targetURI, true);\n\t\t\t\t\tif (target != null)\n\t\t\t\t\t\ttargets.add(target);\n\t\t\t\t}\n\t\t\t\tfindLocalReferences(localResource, targets, acceptor, queryData.getResultFilter(), subMonitor);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testLocalAndIndexedFiltered() throws Exception {\n\t\tfinal URI uriA = EcoreUtil.getURI(elementA);\n\t\tPredicate<IReferenceDescription> filter = new Predicate<IReferenceDescription>() {\n\t\t\tpublic boolean apply(IReferenceDescription input) {\n\t\t\t\treturn !input.getTargetEObjectUri().equals(uriA);\n\t\t\t}\n\t\t};\n\t\tIReferenceFinder.IQueryData queryData = new ReferenceQueryData(uriA, singletonList(uriA), uriA.trimFragment(),\n\t\t\t\tfilter, \"\");\n\t\tloadResource(\"ref.refactoringtestlanguage\", \"D { ref A }\");\n\t\tfindLocalRefs(queryData);\n\t\tacceptor.assertFinished();\n\t\tfindIndexedRefs(queryData);\n\t\tacceptor.assertFinished();\n\t\tfindAllRefs(queryData);\n\t\tacceptor.assertFinished();\n\t}","id":84795,"modified_method":"public void testLocalAndIndexedFiltered() throws Exception {\n\t\tfinal URI uriA = EcoreUtil.getURI(elementA);\n\t\tPredicate<IReferenceDescription> filter = new Predicate<IReferenceDescription>() {\n\t\t\tpublic boolean apply(IReferenceDescription input) {\n\t\t\t\treturn !input.getTargetEObjectUri().equals(uriA);\n\t\t\t}\n\t\t};\n\t\tIReferenceFinder.IQueryData queryData = new ReferenceQueryData(uriA, singleton(uriA), uriA.trimFragment(),\n\t\t\t\tfilter, \"\");\n\t\tloadResource(\"ref.refactoringtestlanguage\", \"D { ref A }\");\n\t\tfindLocalRefs(queryData);\n\t\tacceptor.assertFinished();\n\t\tfindIndexedRefs(queryData);\n\t\tacceptor.assertFinished();\n\t\tfindAllRefs(queryData);\n\t\tacceptor.assertFinished();\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<URI> createTargetURIs(EObject target) {\n\t\treturn singletonList(EcoreUtil.getURI(target));\n\t}","id":84796,"modified_method":"protected Set<URI> createTargetURIs(EObject target) {\n\t\treturn singleton(EcoreUtil.getURI(target));\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testFunctionQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { foo() null }\");\n\t\twaitForAutoBuild();\n\t\tXtendFunction functionFoo = (XtendFunction) fileFoo.getXtendClass().getMembers().get(0);\n\t\tJvmOperation inferredOperation = associations.getDirectlyInferredOperation(functionFoo);\n\n\t\tIQueryData queryData = createQueryData(functionFoo);\n\t\tassertEquals(2, queryData.getTargetURIs().size());\n\t\tassertEquals(queryData.getTargetURIs().get(0), EcoreUtil.getURI(functionFoo));\n\t\tassertEquals(queryData.getTargetURIs().get(1), EcoreUtil.getURI(inferredOperation));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(functionFoo));\n\t}","id":84797,"modified_method":"public void testFunctionQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { foo() null }\");\n\t\twaitForAutoBuild();\n\t\tXtendFunction functionFoo = (XtendFunction) fileFoo.getXtendClass().getMembers().get(0);\n\t\tJvmOperation inferredOperation = associations.getDirectlyInferredOperation(functionFoo);\n\n\t\tIQueryData queryData = createQueryData(functionFoo);\n\t\tassertEquals(2, queryData.getTargetURIs().size());\n\t\tIterator<URI> targetURIs = queryData.getTargetURIs().iterator();\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(functionFoo));\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(inferredOperation));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(functionFoo));\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testClassQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { }\");\n\t\twaitForAutoBuild();\n\t\tXtendClass classFoo = fileFoo.getXtendClass();\n\t\tJvmGenericType inferredTypeFoo = associations.getInferredType(classFoo);\n\t\tJvmConstructor inferredConstructor = associations.getInferredConstructor(classFoo);\n\n\t\tIQueryData queryData = createQueryData(classFoo);\n\t\tassertEquals(3, queryData.getTargetURIs().size());\n\t\tassertEquals(queryData.getTargetURIs().get(0), EcoreUtil.getURI(classFoo));\n\t\tassertEquals(queryData.getTargetURIs().get(1), EcoreUtil.getURI(inferredTypeFoo));\n\t\tassertEquals(queryData.getTargetURIs().get(2), EcoreUtil.getURI(inferredConstructor));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(classFoo));\n\t}","id":84798,"modified_method":"public void testClassQueryData() throws Exception {\n\t\tXtendFile fileFoo = testHelper.xtendFile(\"Foo\", \"class Foo { }\");\n\t\twaitForAutoBuild();\n\t\tXtendClass classFoo = fileFoo.getXtendClass();\n\t\tJvmGenericType inferredTypeFoo = associations.getInferredType(classFoo);\n\t\tJvmConstructor inferredConstructor = associations.getInferredConstructor(classFoo);\n\n\t\tIQueryData queryData = createQueryData(classFoo);\n\t\tassertEquals(3, queryData.getTargetURIs().size());\n\t\tIterator<URI> targetURIs = queryData.getTargetURIs().iterator();\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(classFoo));\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(inferredTypeFoo));\n\t\tassertEquals(targetURIs.next(), EcoreUtil.getURI(inferredConstructor));\n\t\tassertTrue(queryData.getResultFilter() instanceof Xtend2ReferenceFilter);\n\t\tassertEquals(((Xtend2ReferenceFilter) queryData.getResultFilter()).getExcludedSourceURI(),\n\t\t\t\tEcoreUtil.getURI(classFoo));\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public IReferenceFinder.IQueryData create(ElementRenameArguments args) {\n\t\tURI contextResourceURI = args.getContextResourceURI();\n\t\tif(contextResourceURI == null) \n\t\t\tcontextResourceURI = args.getTargetElementURI().trimFragment();\n\t\treturn new ReferenceQueryData(args.getTargetElementURI(),\n\t\t\t\tnewArrayList(args.getRenamedElementURIs()), contextResourceURI, createFilter(args), \"\");\n\t}","id":84799,"modified_method":"public IReferenceFinder.IQueryData create(ElementRenameArguments args) {\n\t\tURI contextResourceURI = args.getContextResourceURI();\n\t\tif(contextResourceURI == null) \n\t\t\tcontextResourceURI = args.getTargetElementURI().trimFragment();\n\t\treturn new ReferenceQueryData(args.getTargetElementURI(),\n\t\t\t\tnewLinkedHashSet(args.getRenamedElementURIs()), contextResourceURI, createFilter(args), \"\");\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<URI> getTargetURIs() {\n\t\treturn targetURIs;\n\t}","id":84800,"modified_method":"public Set<URI> getTargetURIs() {\n\t\treturn targetURIs;\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public ReferenceQueryData(URI targetURI) {\n\t\tthis(targetURI, singletonList(targetURI), targetURI.trimFragment(), null, \"\");\n\t}","id":84801,"modified_method":"public ReferenceQueryData(URI targetURI) {\n\t\tthis(targetURI, singleton(targetURI), targetURI.trimFragment(), null, \"\");\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public ReferenceQueryData(URI leadElementURI, List<URI> targetURIs, URI localContextResourceURI,\n\t\t\tPredicate<IReferenceDescription> resultFilter, String label) {\n\t\tthis.leadElementURI = leadElementURI;\n\t\tthis.targetURIs = targetURIs;\n\t\tthis.localContextResourceURI = localContextResourceURI.trimFragment();\n\t\tthis.resultFilter = resultFilter;\n\t\tthis.label = label;\n\t}","id":84802,"modified_method":"public ReferenceQueryData(URI leadElementURI, Set<URI> targetURIs, URI localContextResourceURI,\n\t\t\tPredicate<IReferenceDescription> resultFilter, String label) {\n\t\tthis.leadElementURI = leadElementURI;\n\t\tthis.targetURIs = targetURIs;\n\t\tthis.localContextResourceURI = localContextResourceURI.trimFragment();\n\t\tthis.resultFilter = resultFilter;\n\t\tthis.label = label;\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic IStatus runInUIThread(IProgressMonitor monitor) {\n\t\t\tisUIUpdateScheduled = false;\n\t\t\tList<SearchResultEvent> events;\n\t\t\tsynchronized (batchedSearchResultEvents) {\n\t\t\t\tevents = Lists.newArrayList(batchedSearchResultEvents);\n\t\t\t\tbatchedSearchResultEvents.clear();\n\t\t\t}\n\t\t\tfor (SearchResultEvent event : events) {\n\t\t\t\tif (event instanceof Added) {\n\t\t\t\t\taddReference(((Added) event).getReferenceDescription(), true);\n\t\t\t\t} else if (event instanceof Reset) {\n\t\t\t\t\tif (rootNodes != null && !rootNodes.isEmpty()) {\n\t\t\t\t\t\tsynchronized (viewer) {\n\t\t\t\t\t\t\tviewer.remove(viewer.getInput(),\n\t\t\t\t\t\t\t\t\tIterables.toArray(rootNodes, ReferenceSearchViewTreeNode.class));\n\t\t\t\t\t\t\trootNodes = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Status.OK_STATUS;\n\t\t}","id":84803,"modified_method":"@Override\n\t\tpublic IStatus runInUIThread(IProgressMonitor monitor) {\n\t\t\tisUIUpdateScheduled = false;\n\t\t\tList<SearchResultEvent> events;\n\t\t\tsynchronized (batchedSearchResultEvents) {\n\t\t\t\tevents = Lists.newArrayList(batchedSearchResultEvents);\n\t\t\t\tbatchedSearchResultEvents.clear();\n\t\t\t}\n\t\t\tSubMonitor progress = SubMonitor.convert(monitor, events.size());\n\t\t\tfor (SearchResultEvent event : events) {\n\t\t\t\tif (event instanceof Added) {\n\t\t\t\t\taddReference(((Added) event).getReferenceDescription(), true);\n\t\t\t\t} else if (event instanceof Reset) {\n\t\t\t\t\tif (rootNodes != null && !rootNodes.isEmpty()) {\n\t\t\t\t\t\tsynchronized (viewer) {\n\t\t\t\t\t\t\tviewer.remove(viewer.getInput(),\n\t\t\t\t\t\t\t\t\tIterables.toArray(rootNodes, ReferenceSearchViewTreeNode.class));\n\t\t\t\t\t\t\trootNodes = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprogress.worked(1);\n\t\t\t}\n\t\t\tviewer.refresh();\n\t\t\tviewer.expandToLevel(1);\n\t\t\treturn Status.OK_STATUS;\n\t\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void searchResultChanged(final SearchResultEvent e) {\n\t\tsynchronized (batchedSearchResultEvents) {\n\t\t\tbatchedSearchResultEvents.add(e);\n\t\t}\n\t\tif (!isUIUpdateScheduled) {\n\t\t\tnew UIUpdater().schedule();\n\t\t}\n\t}","id":84804,"modified_method":"public void searchResultChanged(final SearchResultEvent e) {\n\t\tsynchronized (batchedSearchResultEvents) {\n\t\t\tbatchedSearchResultEvents.add(e);\n\t\t}\n\t\tif (!isUIUpdateScheduled) {\n\t\t\tisUIUpdateScheduled = true;\n\t\t\tnew UIUpdater().schedule();\n\t\t}\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"private void addReference(IReferenceDescription referenceDescription, boolean isUpdateViewer) {\n\t\tURI containerEObjectURI = referenceDescription.getContainerEObjectURI();\n\t\tfinal URI eObjectURI = (containerEObjectURI == null) ? referenceDescription.getSourceEObjectUri()\n\t\t\t\t: containerEObjectURI;\n\t\tIResourceDescription resourceDescription = resourceDescriptions.getResourceDescription(eObjectURI\n\t\t\t\t.trimFragment());\n\t\tif (resourceDescription != null) {\n\t\t\tReferenceSearchViewTreeNode resourceNode = resourceNode(resourceDescription, isUpdateViewer);\n\t\t\tReferenceSearchViewTreeNode referenceNode = null;\n\t\t\tfor (IEObjectDescription eObjectDescription : resourceDescription.getExportedObjects()) {\n\t\t\t\tif (eObjectDescription.getEObjectURI().equals(eObjectURI)) {\n\t\t\t\t\treferenceNode = new ReferenceSearchViewTreeNode(resourceNode, referenceDescription,\n\t\t\t\t\t\t\teObjectDescription);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (referenceNode == null)\n\t\t\t\treferenceNode = new ReferenceSearchViewTreeNode(resourceNode, referenceDescription,\n\t\t\t\t\t\treferenceDescription);\n\t\t\tif (isUpdateViewer) {\n\t\t\t\tviewer.add(resourceNode, referenceNode);\n\t\t\t\tviewer.expandToLevel(resourceNode, 1);\n\t\t\t}\n\n\t\t}\n\t}","id":84805,"modified_method":"private void addReference(IReferenceDescription referenceDescription, boolean isUpdateViewer) {\n\t\tURI containerEObjectURI = referenceDescription.getContainerEObjectURI();\n\t\tfinal URI eObjectURI = (containerEObjectURI == null) ? referenceDescription.getSourceEObjectUri()\n\t\t\t\t: containerEObjectURI;\n\t\tIResourceDescription resourceDescription = resourceDescriptions.getResourceDescription(eObjectURI\n\t\t\t\t.trimFragment());\n\t\tif (resourceDescription != null) {\n\t\t\tReferenceSearchViewTreeNode resourceNode = resourceNode(resourceDescription, isUpdateViewer);\n\t\t\tReferenceSearchViewTreeNode referenceNode = null;\n\t\t\tfor (IEObjectDescription eObjectDescription : resourceDescription.getExportedObjects()) {\n\t\t\t\tif (eObjectDescription.getEObjectURI().equals(eObjectURI)) {\n\t\t\t\t\treferenceNode = new ReferenceSearchViewTreeNode(resourceNode, referenceDescription,\n\t\t\t\t\t\t\teObjectDescription);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (referenceNode == null)\n\t\t\t\treferenceNode = new ReferenceSearchViewTreeNode(resourceNode, referenceDescription,\n\t\t\t\t\t\treferenceDescription);\n\t\t}\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected List<URI> createTargetURIs(EObject target) {\n\t\tif (target instanceof XtendClass)\n\t\t\treturn newArrayList(getURI(target), getURI(xtend2jvmAssociations.getInferredType((XtendClass) target)), getURI(xtend2jvmAssociations.getInferredConstructor((XtendClass) target)));\n\t\telse if (target instanceof XtendFunction)\n\t\t\treturn newArrayList(getURI(target), getURI(xtend2jvmAssociations.getDirectlyInferredOperation((XtendFunction) target)));\n\t\telse\n\t\t\treturn singletonList(getURI(target));\n\t}","id":84806,"modified_method":"@Override\n\tprotected Set<URI> createTargetURIs(EObject target) {\n\t\tif (target instanceof XtendClass) {\n\t\t\tSet<URI> targetURIs = newLinkedHashSet();\n\t\t\ttargetURIs.add(getURI(target));\n\t\t\ttargetURIs.add(getURI(xtend2jvmAssociations.getInferredType((XtendClass) target)));\n\t\t\ttargetURIs.add(getURI(xtend2jvmAssociations.getInferredConstructor((XtendClass) target)));\n\t\t\treturn targetURIs;\n\t\t} else if (target instanceof XtendFunction) {\n\t\t\tSet<URI> targetURIs = newLinkedHashSet();\n\t\t\ttargetURIs.add(getURI(target));\n\t\t\ttargetURIs.add(getURI(xtend2jvmAssociations.getDirectlyInferredOperation((XtendFunction) target)));\n\t\t\treturn targetURIs;\n\t\t} else {\n\t\t\treturn singleton(getURI(target));\n\t\t}\n\t}","commit_id":"e06de36313db06c17df77389440480f57e32d24e","url":"https://github.com/eclipse/xtext"},{"original_method":"private static List<CommandInfo.URI> getExecutorDependencyURIList() {\n    String dependencyPath =\n        Configuration.get(PropertyKey.INTEGRATION_MESOS_EXECUTOR_DEPENDENCY_PATH);\n    return Lists.newArrayList(\n        CommandInfo.URI.newBuilder()\n            .setValue(PathUtils.concatPath(dependencyPath, \"alluxio.tar.gz\")).setExtract(true)\n            .build(), CommandInfo.URI.newBuilder()\n            .setValue(Configuration.get(PropertyKey.INTEGRATION_MESOS_JRE_URL)).setExtract(true)\n            .build());\n  }","id":84807,"modified_method":"private static List<CommandInfo.URI> getExecutorDependencyURIList() {\n    List<URI> dependencies = new ArrayList<>();\n    if (installJavaFromUrl()) {\n      dependencies.add(CommandInfo.URI.newBuilder()\n          .setValue(Configuration.get(PropertyKey.INTEGRATION_MESOS_JRE_URL)).setExtract(true)\n          .build());\n    }\n    if (installAlluxioFromUrl()) {\n      dependencies.add(CommandInfo.URI.newBuilder()\n          .setValue(Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL))\n          .setExtract(true).build());\n    }\n    return dependencies;\n  }","commit_id":"a2313f4327ad993f1645b73f9a5bd710f3d8c509","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n      long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n      long masterMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n      long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n      long workerMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n      LOG.info(\"Master launched {}, master count {}, \"\n          + \"requested master cpu {} and mem {} MB\",\n          mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n      for (Protos.Offer offer : offers) {\n        Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n        double offerCpu = 0;\n        double offerMem = 0;\n        for (Protos.Resource resource : offer.getResourcesList()) {\n          if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n            offerCpu += resource.getScalar().getValue();\n          } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n            offerMem += resource.getScalar().getValue();\n          } else {\n            // Other resources are currently ignored.\n          }\n        }\n\n        LOG.info(\"Received offer {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n            offer.getId().getValue(), offerCpu, offerMem,\n            OfferUtils.hasAvailableMasterPorts(offer));\n\n        Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n        List<Protos.Resource> resources;\n        if (!mMasterLaunched && offerCpu >= masterCpu && offerMem >= masterMem\n            && mMasterCount < Configuration\n            .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT) && OfferUtils\n            .hasAvailableMasterPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Master executor\");\n          executorBuilder\n              .setName(\"Alluxio Master Executor\")\n              .setSource(\"master\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(\n                          \"export JAVA_HOME=\"\n                              + Configuration.get(PropertyKey.INTEGRATION_MESOS_JRE_PATH)\n                              + \" && export PATH=$PATH:$JAVA_HOME/bin && \"\n                              + \"mv alluxio-* alluxio && \"\n                              + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\",\n                              \"alluxio-master-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getMasterRequiredResources(masterCpu, masterMem);\n          mMasterHostname = offer.getHostname();\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n          mMasterCount++;\n          mMasterTaskId = mLaunchedTasks;\n\n        } else if (mMasterLaunched && !mWorkers.contains(offer.getHostname())\n            && offerCpu >= workerCpu && offerMem >= workerMem\n            && OfferUtils.hasAvailableWorkerPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Worker executor\");\n          final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n          executorBuilder\n              .setName(\"Alluxio Worker Executor\")\n              .setSource(\"worker\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(\n                          \"export JAVA_HOME=\"\n                              + Configuration.get(PropertyKey.INTEGRATION_MESOS_JRE_PATH)\n                              + \" && export PATH=$PATH:$JAVA_HOME/bin && \"\n                              + \"mv alluxio-* alluxio && \"\n                              + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\",\n                              \"alluxio-worker-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getWorkerRequiredResources(workerCpu, workerMem);\n          mWorkers.add(offer.getHostname());\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n        } else {\n          // The resource offer cannot be used to start either master or a worker.\n          LOG.info(\"Declining offer {}\", offer.getId().getValue());\n          driver.declineOffer(offer.getId());\n          continue;\n        }\n\n        Protos.TaskID taskId =\n            Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n        LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n        Protos.TaskInfo task =\n            Protos.TaskInfo\n                .newBuilder()\n                .setName(mTaskName)\n                .setTaskId(taskId)\n                .setSlaveId(offer.getSlaveId())\n                .addAllResources(resources)\n                .setExecutor(executorBuilder).build();\n\n        launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n        mLaunchedTasks++;\n\n        // NOTE: We use the new API `acceptOffers` here to launch tasks.\n        // The 'launchTasks' API will be deprecated.\n        List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n        offerIds.add(offer.getId());\n        List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n        Protos.Offer.Operation operation =\n            Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n                .setLaunch(launch).build();\n        operations.add(operation);\n        Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n        driver.acceptOffers(offerIds, operations, filters);\n      }\n    }","id":84808,"modified_method":"@Override\n    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n      long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n      long masterMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n      long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n      long workerMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n      LOG.info(\"Master launched {}, master count {}, \"\n          + \"requested master cpu {} and mem {} MB\",\n          mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n      for (Protos.Offer offer : offers) {\n        Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n        double offerCpu = 0;\n        double offerMem = 0;\n        for (Protos.Resource resource : offer.getResourcesList()) {\n          if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n            offerCpu += resource.getScalar().getValue();\n          } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n            offerMem += resource.getScalar().getValue();\n          } else {\n            // Other resources are currently ignored.\n          }\n        }\n\n        LOG.info(\"Received offer {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n            offer.getId().getValue(), offerCpu, offerMem,\n            OfferUtils.hasAvailableMasterPorts(offer));\n\n        Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n        List<Protos.Resource> resources;\n        if (!mMasterLaunched && offerCpu >= masterCpu && offerMem >= masterMem\n            && mMasterCount < Configuration\n            .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT) && OfferUtils\n            .hasAvailableMasterPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Master executor\");\n          executorBuilder\n              .setName(\"Alluxio Master Executor\")\n              .setSource(\"master\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getMasterRequiredResources(masterCpu, masterMem);\n          mMasterHostname = offer.getHostname();\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n          mMasterCount++;\n          mMasterTaskId = mLaunchedTasks;\n\n        } else if (mMasterLaunched && !mWorkers.contains(offer.getHostname())\n            && offerCpu >= workerCpu && offerMem >= workerMem\n            && OfferUtils.hasAvailableWorkerPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Worker executor\");\n          final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n          executorBuilder\n              .setName(\"Alluxio Worker Executor\")\n              .setSource(\"worker\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getWorkerRequiredResources(workerCpu, workerMem);\n          mWorkers.add(offer.getHostname());\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n        } else {\n          // The resource offer cannot be used to start either master or a worker.\n          LOG.info(\"Declining offer {}\", offer.getId().getValue());\n          driver.declineOffer(offer.getId());\n          continue;\n        }\n\n        Protos.TaskID taskId =\n            Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n        LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n        Protos.TaskInfo task =\n            Protos.TaskInfo\n                .newBuilder()\n                .setName(mTaskName)\n                .setTaskId(taskId)\n                .setSlaveId(offer.getSlaveId())\n                .addAllResources(resources)\n                .setExecutor(executorBuilder).build();\n\n        launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n        mLaunchedTasks++;\n\n        // NOTE: We use the new API `acceptOffers` here to launch tasks.\n        // The 'launchTasks' API will be deprecated.\n        List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n        offerIds.add(offer.getId());\n        List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n        Protos.Offer.Operation operation =\n            Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n                .setLaunch(launch).build();\n        operations.add(operation);\n        Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n        driver.acceptOffers(offerIds, operations, filters);\n      }\n    }","commit_id":"a2313f4327ad993f1645b73f9a5bd710f3d8c509","url":"https://github.com/amplab/tachyon"},{"original_method":"protected final void updatePreview() {\n    if (!myShouldUpdatePreview) {\n      return;\n    }\n\n    if (myLastDocumentModificationStamp != myEditor.getDocument().getModificationStamp()) {\n      myTextToReformat = myEditor.getDocument().getText();\n    }\n\n    Project project = /*(Project)DataManager.getInstance().getDataContext().getData(DataConstants.PROJECT); //todo uncomment - do not load default project\n    if (project == null) {\n      project =*/ ProjectManager.getInstance().getDefaultProject();\n    //}\n    final Project finalProject = project;\n    CommandProcessor.getInstance().executeCommand(finalProject,\n                                                  new Runnable() {\n                                                    public void run() {\n                                                      replaceText(finalProject);\n                                                    }\n                                                  }, null, null);\n    myEditor.getSettings().setRightMargin(getRightMargin());\n    myLastDocumentModificationStamp = myEditor.getDocument().getModificationStamp();\n  }","id":84809,"modified_method":"protected final void updatePreview() {\n    if (!myShouldUpdatePreview) {\n      return;\n    }\n\n    if (myLastDocumentModificationStamp != myEditor.getDocument().getModificationStamp()) {\n      myTextToReformat = myEditor.getDocument().getText();\n    }\n\n    Project project = (Project)DataManager.getInstance().getDataContext().getData(DataConstants.PROJECT);\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    final Project finalProject = project;\n    CommandProcessor.getInstance().executeCommand(finalProject,\n                                                  new Runnable() {\n                                                    public void run() {\n                                                      replaceText(finalProject);\n                                                    }\n                                                  }, null, null);\n    myEditor.getSettings().setRightMargin(getRightMargin());\n    myLastDocumentModificationStamp = myEditor.getDocument().getModificationStamp();\n  }","commit_id":"1a7cd9f6813aa0cd015aa5015c371ab72b0f1715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Project getProject() {\n    return isUpdate() ? getProjectToUpdate() : ProjectManager.getInstance().getDefaultProject();\n  }","id":84810,"modified_method":"@NotNull\n  private Project getProject() {\n    Project result = isUpdate() ? getProjectToUpdate() : null;\n    if (result == null) result = ProjectManager.getInstance().getDefaultProject();\n    return result;\n  }","commit_id":"42fe40685d4663b6bf9a1bd5981672b46dd4a6a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void checkout(@NotNull String url,\n                       @NotNull String directoryName,\n                       @NotNull VirtualFile parentDirectory,\n                       @NotNull CheckoutProvider.Listener listener) {\n    GitCheckoutProvider.clone(ProjectManager.getInstance().getDefaultProject(), ServiceManager.getService(Git.class),\n                              listener, parentDirectory, url, directoryName, parentDirectory.getPath());\n  }","id":84811,"modified_method":"@Override\n  public boolean checkout(@NotNull final String url,\n                          @NotNull final VirtualFile parentDirectory, @NotNull final String directoryName) {\n\n    IdeFrame frame = IdeFocusManager.getGlobalInstance().getLastFocusedFrame();\n    return GitCheckoutProvider.doClone(frame == null || frame.getProject() == null ? ProjectManager.getInstance().getDefaultProject() : frame.getProject(),\n                                       ServiceManager.getService(Git.class),\n                                       directoryName, parentDirectory.getPath(), url);\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void clone(final Project project, @NotNull final Git git, final Listener listener, final VirtualFile destinationParent,\n                    final String sourceRepositoryURL, final String directoryName, final String parentDirectory) {\n\n    final AtomicBoolean cloneResult = new AtomicBoolean();\n    new Task.Backgroundable(project, DvcsBundle.message(\"cloning.repository\", sourceRepositoryURL)) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        cloneResult.set(doClone(project, indicator, git, directoryName, parentDirectory, sourceRepositoryURL));\n      }\n\n      @Override\n      public void onSuccess() {\n        if (!cloneResult.get()) {\n          return;\n        }\n\n        destinationParent.refresh(true, true, new Runnable() {\n          public void run() {\n            if (project.isOpen() && (!project.isDisposed()) && (!project.isDefault())) {\n              final VcsDirtyScopeManager mgr = VcsDirtyScopeManager.getInstance(project);\n              mgr.fileDirty(destinationParent);\n            }\n          }\n        });\n        listener.directoryCheckedOut(new File(parentDirectory, directoryName), GitVcs.getKey());\n        listener.checkoutCompleted();\n      }\n    }.queue();\n  }","id":84812,"modified_method":"public static void clone(final Project project, @NotNull final Git git, final Listener listener, final VirtualFile destinationParent,\n                    final String sourceRepositoryURL, final String directoryName, final String parentDirectory) {\n\n    final AtomicBoolean cloneResult = new AtomicBoolean();\n    new Task.Backgroundable(project, DvcsBundle.message(\"cloning.repository\", sourceRepositoryURL)) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        cloneResult.set(doClone(project, git, directoryName, parentDirectory, sourceRepositoryURL));\n      }\n\n      @Override\n      public void onSuccess() {\n        if (!cloneResult.get()) {\n          return;\n        }\n\n        destinationParent.refresh(true, true, new Runnable() {\n          public void run() {\n            if (project.isOpen() && (!project.isDisposed()) && (!project.isDefault())) {\n              final VcsDirtyScopeManager mgr = VcsDirtyScopeManager.getInstance(project);\n              mgr.fileDirty(destinationParent);\n            }\n          }\n        });\n        listener.directoryCheckedOut(new File(parentDirectory, directoryName), GitVcs.getKey());\n        listener.checkoutCompleted();\n      }\n    }.queue();\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean doClone(@NotNull Project project, @NotNull ProgressIndicator indicator, @NotNull Git git,\n                                @NotNull String directoryName, @NotNull String parentDirectory, @NotNull String sourceRepositoryURL) {\n    indicator.setIndeterminate(false);\n    GitLineHandlerListener progressListener = GitStandardProgressAnalyzer.createListener(indicator);\n    GitCommandResult result = git.clone(project, new File(parentDirectory), sourceRepositoryURL, directoryName, progressListener);\n    if (result.success()) {\n      return true;\n    }\n    VcsNotifier.getInstance(project).notifyError(\"Clone failed\", result.getErrorOutputAsHtmlString());\n    return false;\n  }","id":84813,"modified_method":"public static boolean doClone(@NotNull Project project, @NotNull Git git,\n                                @NotNull String directoryName, @NotNull String parentDirectory, @NotNull String sourceRepositoryURL) {\n\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    indicator.setIndeterminate(false);\n    GitLineHandlerListener progressListener = GitStandardProgressAnalyzer.createListener(indicator);\n    GitCommandResult result = git.clone(project, new File(parentDirectory), sourceRepositoryURL, directoryName, progressListener);\n    if (result.success()) {\n      return true;\n    }\n    VcsNotifier.getInstance(project).notifyError(\"Clone failed\", result.getErrorOutputAsHtmlString());\n    return false;\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@When(\"I clone (\\\\S+)\")\n  public void I_clone_the_repository(final String url) {\n    myAuthenticator = new TestAuthenticator();\n\n    myHttpAuthService.register(myAuthenticator);\n\n    executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        String projectName = url.substring(url.lastIndexOf('/') + 1).replace(\".git\", \"\");\n        GitCheckoutProvider.doClone(myProject, new EmptyProgressIndicator(), myGit, projectName, myTestRoot, url);\n        myCloneCompleted.countDown();\n      }\n    });\n  }","id":84814,"modified_method":"@When(\"I clone (\\\\S+)\")\n  public void I_clone_the_repository(final String url) {\n    myAuthenticator = new TestAuthenticator();\n\n    myHttpAuthService.register(myAuthenticator);\n\n    executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        String projectName = url.substring(url.lastIndexOf('/') + 1).replace(\".git\", \"\");\n        GitCheckoutProvider.doClone(myProject, myGit, projectName, myTestRoot, url);\n        myCloneCompleted.countDown();\n      }\n    });\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context) {\n    for (Pair<String, String> entry : entries) {\n      if (\"project\".equals(entry.getFirst())) {\n        Project[] projects = ProjectManager.getInstance().getOpenProjects();\n        Project project = ProjectUtil.openProject(entry.getSecond(), ArrayUtil.getFirstElement(projects), false);\n        if (project == null) return false;\n        context.project = project;\n      }\n    }\n    return true;\n  }","id":84815,"modified_method":"@Override\n  public boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context, @NotNull Runnable runNext) {\n    for (Pair<String, String> entry : entries) {\n      if (\"project\".equals(entry.getFirst())) {\n        Project[] projects = ProjectManager.getInstance().getOpenProjects();\n        Project project = ProjectUtil.openProject(entry.getSecond(), ArrayUtil.getFirstElement(projects), false);\n        if (project == null) return false;\n        context.project = project;\n      }\n    }\n    return true;\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context);","id":84816,"modified_method":"public abstract boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context, @NotNull Runnable runNext);","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testVcsCheckoutProcessor() throws IOException {\n    ProjectSetReader reader = new ProjectSetReader();\n\n    PlatformTestUtil.registerExtension(VcsCheckoutProcessor.EXTENSION_POINT_NAME, new VcsCheckoutProcessor() {\n      @NotNull\n      @Override\n      public String getProtocol() {\n        return \"schema\";\n      }\n\n      @Override\n      public void checkout(@NotNull String url,\n                           @NotNull String directoryName,\n                           @NotNull VirtualFile parentDirectory,\n                           @NotNull CheckoutProvider.Listener listener) {\n        assertEquals(\"schema://foo.bar\", url);\n        assertEquals(\"path\", directoryName);\n        listener.checkoutCompleted();\n      }\n    }, myTestRootDisposable);\n\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"vcs.json\"));\n    reader.readDescriptor(descriptor, getSourceRoot());\n  }","id":84817,"modified_method":"public void testVcsCheckoutProcessor() throws IOException {\n    ProjectSetReader reader = new ProjectSetReader();\n\n    PlatformTestUtil.registerExtension(VcsCheckoutProcessor.EXTENSION_POINT_NAME, new VcsCheckoutProcessor() {\n      @NotNull\n      @Override\n      public String getProtocol() {\n        return \"schema\";\n      }\n\n      @Override\n      public boolean checkout(@NotNull String url,\n                              @NotNull VirtualFile parentDirectory, @NotNull String directoryName) {\n        assertEquals(\"schema://foo.bar\", url);\n        assertEquals(\"path\", directoryName);\n        return true;\n      }\n    }, myTestRootDisposable);\n\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"vcs.json\"));\n    reader.readDescriptor(descriptor, getSourceRoot());\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testProjectSetReader() throws IOException {\n    ProjectSetReader reader = new ProjectSetReader();\n\n    final Ref<List<Pair<String, String>>> ref = Ref.create();\n    PlatformTestUtil.registerExtension(ProjectSetProcessor.EXTENSION_POINT_NAME, new ProjectSetProcessor() {\n      @Override\n      public String getId() {\n        return \"test\";\n      }\n\n      @Override\n      public boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context) {\n        ref.set(entries);\n        return true;\n      }\n    }, myTestRootDisposable);\n\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"descriptor.json\"));\n    reader.readDescriptor(descriptor, getSourceRoot());\n\n    List<Pair<String, String>> entries = ref.get();\n    assertEquals(2, entries.size());\n    assertEquals(\"git://foo.bar\", entries.get(0).getSecond());\n    assertEquals(\"{\\\"foo\\\":\\\"bar\\\"}\", entries.get(1).getSecond());\n  }","id":84818,"modified_method":"public void testProjectSetReader() throws IOException {\n    ProjectSetReader reader = new ProjectSetReader();\n\n    final Ref<List<Pair<String, String>>> ref = Ref.create();\n    PlatformTestUtil.registerExtension(ProjectSetProcessor.EXTENSION_POINT_NAME, new ProjectSetProcessor() {\n      @Override\n      public String getId() {\n        return \"test\";\n      }\n\n      @Override\n      public boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context, @NotNull Runnable runNext) {\n        ref.set(entries);\n        return true;\n      }\n    }, myTestRootDisposable);\n\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"descriptor.json\"));\n    reader.readDescriptor(descriptor, getSourceRoot());\n\n    List<Pair<String, String>> entries = ref.get();\n    assertEquals(2, entries.size());\n    assertEquals(\"git://foo.bar\", entries.get(0).getSecond());\n    assertEquals(\"{\\\"foo\\\":\\\"bar\\\"}\", entries.get(1).getSecond());\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract void checkout(@NotNull String url,\n                                @NotNull String directoryName,\n                                @NotNull VirtualFile parentDirectory,\n                                @NotNull CheckoutProvider.Listener listener);","id":84819,"modified_method":"public abstract boolean checkout(@NotNull String url, @NotNull VirtualFile parentDirectory, @NotNull String directoryName);","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processEntries(@NotNull List<Pair<String, String>> entries, @NotNull final Context context) {\n\n    final VirtualFile directory;\n    if (context.directory != null) {\n      directory = context.directory;\n    }\n    else {\n      FileChooserDescriptor descriptor = new FileChooserDescriptor(false, true, false, false, false, false);\n      descriptor.setTitle(\"Select Destination Folder\");\n      descriptor.setDescription(\"\");\n      VirtualFile[] files = FileChooser.chooseFiles(descriptor, null, null);\n      if (files.length == 0) return false;\n      directory = files[0];\n    }\n    for (Pair<String, String> pair: entries) {\n      String vcs = pair.getFirst();\n      VcsCheckoutProcessor processor = VcsCheckoutProcessor.getProcessor(vcs);\n      if (processor == null) {\n        LOG.error(\"Checkout processor not found for \" + vcs);\n        continue;\n      }\n\n      String url = pair.getSecond();\n      String[] split = splitUrl(url);\n      synchronized (myLock) {\n        final AtomicBoolean done = new AtomicBoolean();\n        try {\n          processor.checkout(split[0], split[1], directory, new CheckoutProvider.Listener() {\n            @Override\n            public void directoryCheckedOut(File directory, VcsKey vcs) {\n\n            }\n\n            @Override\n            public void checkoutCompleted() {\n              done.set(true);\n              myLock.notifyAll();\n            }\n          });\n          if (!done.get()) {\n            myLock.wait();\n          }\n        }\n        catch (InterruptedException e) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","id":84820,"modified_method":"@Override\n  public boolean processEntries(@NotNull final List<Pair<String, String>> entries, @NotNull final Context context, @NotNull final Runnable runNext) {\n\n    final VirtualFile directory;\n    if (context.directory != null) {\n      directory = context.directory;\n    }\n    else {\n      directory = getDirectory();\n      if (directory == null) return false;\n    }\n\n    final AtomicBoolean result = new AtomicBoolean();\n    ProgressManager.getInstance().run(new Task.Backgroundable(null, \"Hey\", true) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        for (Pair<String, String> pair : entries) {\n          String vcs = pair.getFirst();\n          final VcsCheckoutProcessor processor = VcsCheckoutProcessor.getProcessor(vcs);\n          if (processor == null) {\n            LOG.error(\"Checkout processor not found for \" + vcs);\n            return;\n          }\n\n          String url = pair.getSecond();\n          final String[] split = splitUrl(url);\n          if (!processor.checkout(split[0], directory, split[1])) return;\n        }\n        result.set(true);\n      }\n    });\n    return result.get();\n  }","commit_id":"d0582ede00569acccdf7ed822c48832639dd4f30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void expandPPConjunction(SemanticGraph sg, IndexedWord gov, \n      List<IndexedWord> conjDeps, IndexedWord ccDep) {\n    \n    IndexedWord nmodGov = sg.getParent(gov);\n    \n    if (nmodGov == null)\n      return;\n    \n    IndexedWord conjGov = nmodGov.getOriginal() != null ? nmodGov.getOriginal() : nmodGov;\n    GrammaticalRelation rel = sg.reln(nmodGov, gov);  \n    List<IndexedWord> newConjDeps = Generics.newLinkedList();\n    for (IndexedWord conjDep : conjDeps) {\n      IndexedWord nmodGovCopy = nmodGov.makeSoftCopy();\n      \n      /* Change conj(nmod-1, nmod-2) to nmod(nmod-1-gov, nmod-2) */\n      SemanticGraphEdge edge = sg.getEdge(gov, conjDep);\n      if (edge != null) {\n        sg.removeEdge(edge);\n        sg.addEdge(nmodGovCopy, conjDep, rel, Double.NEGATIVE_INFINITY, false);\n      }\n      \n      /* Add relation to copy node. */\n      sg.addEdge(conjGov, nmodGovCopy, CONJUNCT, Double.NEGATIVE_INFINITY, false);\n      newConjDeps.add(nmodGovCopy);\n    }\n    \n    /* Attach CC node to conjGov */ \n    SemanticGraphEdge edge = sg.getEdge(gov, ccDep);\n    sg.removeEdge(edge);\n    sg.addEdge(conjGov, ccDep, COORDINATION, Double.NEGATIVE_INFINITY, false);\n    \n    /* Add conjunction information for these relations already at this point.\n     * It could be that we add several coordinating conjunctions while collapsing\n     * and we might not know which conjunction belongs to which conjunct at a later\n     * point.\n     */\n    addConjToReln(sg, conjGov, newConjDeps, ccDep);\n  }","id":84821,"modified_method":"private static void expandPPConjunction(SemanticGraph sg, IndexedWord gov, \n      List<IndexedWord> conjDeps, IndexedWord ccDep) {\n    \n    IndexedWord nmodGov = sg.getParent(gov);\n    \n    if (nmodGov == null)\n      return;\n    \n    IndexedWord conjGov = nmodGov.getOriginal() != null ? nmodGov.getOriginal() : nmodGov;\n    GrammaticalRelation rel = sg.reln(nmodGov, gov);  \n    List<IndexedWord> newConjDeps = Generics.newLinkedList();\n    for (IndexedWord conjDep : conjDeps) {\n      IndexedWord nmodGovCopy = nmodGov.makeSoftCopy();\n      \n      /* Change conj(nmod-1, nmod-2) to nmod(nmod-1-gov, nmod-2) */\n      SemanticGraphEdge edge = sg.getEdge(gov, conjDep);\n      if (edge != null) {\n        sg.removeEdge(edge);\n        sg.addEdge(nmodGovCopy, conjDep, rel, Double.NEGATIVE_INFINITY, false);\n      }\n      \n      /* Add relation to copy node. */\n      sg.addEdge(conjGov, nmodGovCopy, CONJUNCT, Double.NEGATIVE_INFINITY, false);\n      newConjDeps.add(nmodGovCopy);\n    }\n    \n    /* Attach CC node to conjGov */ \n    SemanticGraphEdge edge = sg.getEdge(gov, ccDep);\n    if (edge != null) {\n      sg.removeEdge(edge);\n      sg.addEdge(conjGov, ccDep, COORDINATION, Double.NEGATIVE_INFINITY, false);\n    }\n    \n    /* Add conjunction information for these relations already at this point.\n     * It could be that we add several coordinating conjunctions while collapsing\n     * and we might not know which conjunction belongs to which conjunct at a later\n     * point.\n     */\n    addConjToReln(sg, conjGov, newConjDeps, ccDep);\n  }","commit_id":"56d59f7251c3a4a5e8acfca11c572cb151610a19","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void expandPPConjunction(SemanticGraph sg, IndexedWord gov, \n      List<IndexedWord> conjDeps, IndexedWord ccDep) {\n    \n    IndexedWord nmodGov = sg.getParent(gov);\n    \n    if (nmodGov == null)\n      return;\n    \n    IndexedWord conjGov = nmodGov.getOriginal() != null ? nmodGov.getOriginal() : nmodGov;\n    GrammaticalRelation rel = sg.reln(nmodGov, gov);  \n    List<IndexedWord> newConjDeps = Generics.newLinkedList();\n    for (IndexedWord conjDep : conjDeps) {\n      IndexedWord nmodGovCopy = nmodGov.makeSoftCopy();\n      \n      /* Change conj(nmod-1, nmod-2) to nmod(nmod-1-gov, nmod-2) */\n      SemanticGraphEdge edge = sg.getEdge(gov, conjDep);\n      if (edge != null) {\n        sg.removeEdge(edge);\n        sg.addEdge(nmodGovCopy, conjDep, rel, Double.NEGATIVE_INFINITY, false);\n      }\n      \n      /* Add relation to copy node. */\n      sg.addEdge(conjGov, nmodGovCopy, CONJUNCT, Double.NEGATIVE_INFINITY, false);\n      newConjDeps.add(nmodGovCopy);\n    }\n    \n    /* Attach CC node to conjGov */ \n    SemanticGraphEdge edge = sg.getEdge(gov, ccDep);\n    sg.removeEdge(edge);\n    sg.addEdge(conjGov, ccDep, COORDINATION, Double.NEGATIVE_INFINITY, false);\n    \n    /* Add conjunction information for these relations already at this point.\n     * It could be that we add several coordinating conjunctions while collapsing\n     * and we might not know which conjunction belongs to which conjunct at a later\n     * point.\n     */\n    addConjToReln(sg, conjGov, newConjDeps, ccDep);\n  }","id":84822,"modified_method":"private static void expandPPConjunction(SemanticGraph sg, IndexedWord gov, \n      List<IndexedWord> conjDeps, IndexedWord ccDep) {\n    \n    IndexedWord nmodGov = sg.getParent(gov);\n    \n    if (nmodGov == null)\n      return;\n    \n    IndexedWord conjGov = nmodGov.getOriginal() != null ? nmodGov.getOriginal() : nmodGov;\n    GrammaticalRelation rel = sg.reln(nmodGov, gov);  \n    List<IndexedWord> newConjDeps = Generics.newLinkedList();\n    for (IndexedWord conjDep : conjDeps) {\n      IndexedWord nmodGovCopy = nmodGov.makeSoftCopy();\n      \n      /* Change conj(nmod-1, nmod-2) to nmod(nmod-1-gov, nmod-2) */\n      SemanticGraphEdge edge = sg.getEdge(gov, conjDep);\n      if (edge != null) {\n        sg.removeEdge(edge);\n        sg.addEdge(nmodGovCopy, conjDep, rel, Double.NEGATIVE_INFINITY, false);\n      }\n      \n      /* Add relation to copy node. */\n      sg.addEdge(conjGov, nmodGovCopy, CONJUNCT, Double.NEGATIVE_INFINITY, false);\n      newConjDeps.add(nmodGovCopy);\n    }\n    \n    /* Attach CC node to conjGov */ \n    SemanticGraphEdge edge = sg.getEdge(gov, ccDep);\n    if (edge != null) {\n      sg.removeEdge(edge);\n      sg.addEdge(conjGov, ccDep, COORDINATION, Double.NEGATIVE_INFINITY, false);\n    }\n    \n    /* Add conjunction information for these relations already at this point.\n     * It could be that we add several coordinating conjunctions while collapsing\n     * and we might not know which conjunction belongs to which conjunct at a later\n     * point.\n     */\n    addConjToReln(sg, conjGov, newConjDeps, ccDep);\n  }","commit_id":"be50477f0402a4bef56f9eafdecc869a2739ae2e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * \n   * Returns a GrammaticalRelation which combines the original relation and \n   * the preposition.\n   * \n   */\n  private static GrammaticalRelation getCaseMarkedRelation(GrammaticalRelation reln, String relationName) {\n    GrammaticalRelation newReln = null;\n    \n    if (reln.getSpecific() != null) {\n      reln = reln.getParent();\n    }\n    if (reln == NOMINAL_MODIFIER) {\n      newReln = UniversalEnglishGrammaticalRelations.getNmod(relationName);\n    } else if (reln == ADV_CLAUSE_MODIFIER) {\n      newReln = UniversalEnglishGrammaticalRelations.getAdvcl(relationName);\n    } else if (reln == CLAUSAL_MODIFIER) {\n      newReln = UniversalEnglishGrammaticalRelations.getAcl(relationName);\n    }\n    return newReln;\n  }","id":84823,"modified_method":"/**\n   * \n   * Returns a GrammaticalRelation which combines the original relation and \n   * the preposition.\n   * \n   */\n  private static GrammaticalRelation getCaseMarkedRelation(GrammaticalRelation reln, String relationName) {\n    GrammaticalRelation newReln = reln;\n\n    if (reln.getSpecific() != null) {\n      reln = reln.getParent();\n    }\n    if (reln == NOMINAL_MODIFIER) {\n      newReln = UniversalEnglishGrammaticalRelations.getNmod(relationName);\n    } else if (reln == ADV_CLAUSE_MODIFIER) {\n      newReln = UniversalEnglishGrammaticalRelations.getAdvcl(relationName);\n    } else if (reln == CLAUSAL_MODIFIER) {\n      newReln = UniversalEnglishGrammaticalRelations.getAcl(relationName);\n    }\n    return newReln;\n  }","commit_id":"be50477f0402a4bef56f9eafdecc869a2739ae2e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void checkPending(InstructionImpl instruction) {\n    final PsiElement element = instruction.getElement();\n    if (element == null) {\n      //add all\n      for (Pair<InstructionImpl, GroovyPsiElement> pair : myPending) {\n        addEdge(pair.getFirst(), instruction);\n      }\n      myPending.clear();\n    } else {\n      for (int i = myPending.size() - 1; i >= 0; i--) {\n        final Pair<InstructionImpl, GroovyPsiElement> pair = myPending.get(i);\n        final PsiElement scopeWhenToAdd = pair.getSecond();\n        if (!PsiTreeUtil.isAncestor(scopeWhenToAdd, element, false)) {\n          addEdge(pair.getFirst(), instruction);\n          myPending.remove(i);\n        } else break;\n      }\n    }\n  }","id":84824,"modified_method":"private void checkPending(InstructionImpl instruction) {\n    final PsiElement element = instruction.getElement();\n    if (element == null) {\n      //add all\n      for (Pair<InstructionImpl, GroovyPsiElement> pair : myPending) {\n        addEdge(pair.getFirst(), instruction);\n      }\n      myPending.clear();\n    } else {\n      for (int i = myPending.size() - 1; i >= 0; i--) {\n        final Pair<InstructionImpl, GroovyPsiElement> pair = myPending.get(i);\n        final PsiElement scopeWhenToAdd = pair.getSecond();\n        if (scopeWhenToAdd == null) continue;\n        if (!PsiTreeUtil.isAncestor(scopeWhenToAdd, element, false)) {\n          addEdge(pair.getFirst(), instruction);\n          myPending.remove(i);\n        } else break;\n      }\n    }\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitForStatement(GrForStatement forStatement) {\n    final GrForClause clause = forStatement.getClause();\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrCondition initializer : ((GrTraditionalForClause) clause).getInitialization()) {\n        initializer.accept(this);\n      }\n    } else if (clause instanceof GrForInClause) {\n      final GrExpression expression = ((GrForInClause) clause).getIteratedExpression();\n      expression.accept(this);\n    }\n\n    InstructionImpl instruction = startNode(forStatement);\n\n    final GrStatement body = forStatement.getBody();\n    if (body != null) {\n      InstructionImpl bodyInstruction = startNode(body);\n      body.accept(this);\n      finishNode(bodyInstruction);\n    }\n    checkPending(instruction); //check for breaks targeted here\n\n    if (clause instanceof GrTraditionalForClause) {\n      final GrExpression condition = ((GrTraditionalForClause) clause).getCondition();\n      if (condition != null) {\n        condition.accept(this);\n      }\n    }\n\n    addPendingEdge(forStatement); //break cycle\n\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrExpression expression : ((GrTraditionalForClause) clause).getUpdate()) {\n        expression.accept(this);\n      }\n    }\n    addEdge(myHead, instruction);  //loop\n\n\n    finishNode(instruction);\n  }","id":84825,"modified_method":"public void visitForStatement(GrForStatement forStatement) {\n    final GrForClause clause = forStatement.getClause();\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrCondition initializer : ((GrTraditionalForClause) clause).getInitialization()) {\n        initializer.accept(this);\n      }\n    } else if (clause instanceof GrForInClause) {\n      final GrExpression expression = ((GrForInClause) clause).getIteratedExpression();\n      expression.accept(this);\n    }\n\n    InstructionImpl instruction = startNode(forStatement);\n    if (clause instanceof GrTraditionalForClause) {\n      final GrExpression condition = ((GrTraditionalForClause) clause).getCondition();\n      if (condition != null) {\n        condition.accept(this);\n      }\n    }\n    addPendingEdge(forStatement, myHead); //break cycle\n\n    final GrStatement body = forStatement.getBody();\n    if (body != null) {\n      InstructionImpl bodyInstruction = startNode(body);\n      body.accept(this);\n      finishNode(bodyInstruction);\n    }\n    checkPending(instruction); //check for breaks targeted here\n\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrExpression expression : ((GrTraditionalForClause) clause).getUpdate()) {\n        expression.accept(this);\n      }\n    }\n    if (myHead != null) addEdge(myHead, instruction);  //loop\n    myHead = null;\n\n    finishNode(instruction);\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    super.visitReferenceExpression(referenceExpression);\n    if (referenceExpression.getQualifierExpression() == null) {\n      if (isIncOrDecOperand(referenceExpression)) {\n        addNode(new ReadWriteVariableInstructionImpl(referenceExpression, myInstructionNumber++, false));\n        addNode(new ReadWriteVariableInstructionImpl(referenceExpression, myInstructionNumber++, true));\n      } else {\n        addNode(new ReadWriteVariableInstructionImpl(referenceExpression, myInstructionNumber++, PsiUtil.isLValue(referenceExpression)));\n      }\n    }\n  }","id":84826,"modified_method":"public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    super.visitReferenceExpression(referenceExpression);\n    if (referenceExpression.getQualifierExpression() == null) {\n      if (isIncOrDecOperand(referenceExpression)) {\n        final ReadWriteVariableInstructionImpl i = new ReadWriteVariableInstructionImpl(referenceExpression, myInstructionNumber++, false);\n        addNode(i);\n        addNode(new ReadWriteVariableInstructionImpl(referenceExpression, myInstructionNumber++, true));\n        checkPending(i);\n      } else {\n        final ReadWriteVariableInstructionImpl i = new ReadWriteVariableInstructionImpl(referenceExpression, myInstructionNumber++, PsiUtil.isLValue(referenceExpression));\n        addNode(i);\n        checkPending(i);\n      }\n    }\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReturnStatement(GrReturnStatement returnStatement) {\n    final GrExpression value = returnStatement.getReturnValue();\n    if (value != null) value.accept(this);\n\n    addPendingEdge(null);\n  }","id":84827,"modified_method":"public void visitReturnStatement(GrReturnStatement returnStatement) {\n    final GrExpression value = returnStatement.getReturnValue();\n    if (value != null) value.accept(this);\n\n    addPendingEdge(null, myHead);\n    myHead = null;\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBreakStatement(GrBreakStatement breakStatement) {\n    super.visitBreakStatement(breakStatement);\n    final GrStatement target = breakStatement.getBreakedLoop();\n    if (target != null) {\n      addPendingEdge(target);\n    }\n    myHead = null;\n  }","id":84828,"modified_method":"public void visitBreakStatement(GrBreakStatement breakStatement) {\n    super.visitBreakStatement(breakStatement);\n    final GrStatement target = breakStatement.getBreakedLoop();\n    if (target != null) {\n      addPendingEdge(target, myHead);\n    }\n    myHead = null;\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope, GroovyPsiElement startInScope, GroovyPsiElement endInScope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new Stack<InstructionImpl>();\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 1;\n    myStartInScope = startInScope;\n    myEndInScope = endInScope;\n    myIsInScope = startInScope == null;\n\n    startNode(null);\n    scope.accept(this);\n\n    myHead = null; //to prevent first -> last edge\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n    return myInstructions.toArray(new Instruction[myInstructions.size()]);\n  }","id":84829,"modified_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope, GroovyPsiElement startInScope, GroovyPsiElement endInScope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new Stack<InstructionImpl>();\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 1;\n    myStartInScope = startInScope;\n    myEndInScope = endInScope;\n    myIsInScope = startInScope == null;\n\n    final InstructionImpl first = startNode(null);\n    scope.accept(this);\n\n    if (myHead == first) {\n      myHead = null; //to prevent first -> last edge\n    }\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n    return myInstructions.toArray(new Instruction[myInstructions.size()]);\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addPendingEdge(GroovyPsiElement scopeWhenAdded) {\n    if (myHead == null) return;\n\n    int i = 0;\n    if (scopeWhenAdded != null) {\n      for (; i < myPending.size(); i++) {\n        Pair<InstructionImpl, GroovyPsiElement> pair = myPending.get(i);\n\n        final GroovyPsiElement currScope = pair.getSecond();\n        if (currScope == null) continue;\n        if (!PsiTreeUtil.isAncestor(currScope, scopeWhenAdded, true)) break;\n      }\n    }\n    myPending.add(i, new Pair<InstructionImpl, GroovyPsiElement>(myHead, scopeWhenAdded));\n  }","id":84830,"modified_method":"private void addPendingEdge(GroovyPsiElement scopeWhenAdded, InstructionImpl instruction) {\n    if (instruction == null) return;\n\n    int i = 0;\n    if (scopeWhenAdded != null) {\n      for (; i < myPending.size(); i++) {\n        Pair<InstructionImpl, GroovyPsiElement> pair = myPending.get(i);\n\n        final GroovyPsiElement currScope = pair.getSecond();\n        if (currScope == null) continue;\n        if (!PsiTreeUtil.isAncestor(currScope, scopeWhenAdded, true)) break;\n      }\n    }\n    myPending.add(i, new Pair<InstructionImpl, GroovyPsiElement>(instruction, scopeWhenAdded));\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitWhileStatement(GrWhileStatement whileStatement) {\n    final InstructionImpl instruction = startNode(whileStatement);\n    final GrCondition condition = whileStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n    addPendingEdge(whileStatement); //break\n    final GrCondition body = whileStatement.getBody();\n    if (body != null) {\n      body.accept(this);\n    }\n    checkPending(instruction); //check for breaks targeted here\n    addEdge(myHead, instruction); //loop\n    finishNode(instruction);\n  }","id":84831,"modified_method":"public void visitWhileStatement(GrWhileStatement whileStatement) {\n    final InstructionImpl instruction = startNode(whileStatement);\n    final GrCondition condition = whileStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n    addPendingEdge(whileStatement, myHead); //break\n    final GrCondition body = whileStatement.getBody();\n    if (body != null) {\n      body.accept(this);\n    }\n    checkPending(instruction); //check for breaks targeted here\n    addEdge(myHead, instruction); //loop\n    myHead = null;\n    finishNode(instruction);\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private InstructionImpl findInstruction(GroovyPsiElement element) {\n    for (int i = myProcessingStack.size() - 1; i >= 0; i--) {\n      InstructionImpl instruction = myProcessingStack.get(i);\n      if (element.equals(instruction.getElement())) return instruction;\n    }\n    return null;\n  }","id":84832,"modified_method":"private InstructionImpl findInstruction(PsiElement element) {\n    for (int i = myProcessingStack.size() - 1; i >= 0; i--) {\n      InstructionImpl instruction = myProcessingStack.get(i);\n      if (element.equals(instruction.getElement())) return instruction;\n    }\n    return null;\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addFinallyEdges(InstructionImpl finallyInstruction) {\n    final List<Pair<InstructionImpl, GroovyPsiElement>> copy = myPending;\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    for (Pair<InstructionImpl, GroovyPsiElement> pair : copy) {\n      addEdge(pair.getFirst(), finallyInstruction);\n      addPendingEdge(pair.getSecond());\n    }\n  }","id":84833,"modified_method":"private void addFinallyEdges(InstructionImpl finallyInstruction) {\n    final List<Pair<InstructionImpl, GroovyPsiElement>> copy = myPending;\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    for (Pair<InstructionImpl, GroovyPsiElement> pair : copy) {\n      final CallInstructionImpl call = addCallNode(finallyInstruction, pair.getSecond());\n      addEdge(pair.getFirst(), call);\n    }\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitTryStatement(GrTryCatchStatement tryCatchStatement) {\n    final GrOpenBlock tryBlock = tryCatchStatement.getTryBlock();\n    final GrCatchClause[] catchClauses = tryCatchStatement.getCatchClauses();\n    final GrFinallyClause finallyClause = tryCatchStatement.getFinallyClause();\n    InstructionImpl tryBeg = null;\n    InstructionImpl tryEnd = null;\n    if (tryBlock != null) {\n      tryBeg = startNode(tryBlock);\n      tryBlock.accept(this);\n      tryEnd = myHead != tryBeg ? myHead : null;\n      finishNode(tryBeg);\n    }\n\n    InstructionImpl[] catches = new InstructionImpl[catchClauses.length];\n    for (int i = 0; i < catchClauses.length; i++) {\n      final InstructionImpl catchBeg = startNode(catchClauses[i]);\n      if (tryBeg != null) addEdge(tryBeg, catchBeg);\n      if (tryEnd != null) addEdge(tryEnd, catchBeg);\n      catchClauses[i].accept(this);\n      catches[i] = myHead;\n      finishNode(catchBeg);\n    }\n\n    if (finallyClause != null) {\n      final InstructionImpl finallyInstruction = startNode(finallyClause);\n      if (tryEnd != null) addEdge(tryEnd, finallyInstruction);\n      for (InstructionImpl catchEnd : catches) {\n        addEdge(catchEnd, finallyInstruction);\n      }\n      addFinallyEdges(finallyInstruction);\n      finallyClause.accept(this);\n      finishNode(finallyInstruction);\n    }\n  }","id":84834,"modified_method":"public void visitTryStatement(GrTryCatchStatement tryCatchStatement) {\n    final GrOpenBlock tryBlock = tryCatchStatement.getTryBlock();\n    final GrCatchClause[] catchClauses = tryCatchStatement.getCatchClauses();\n    final GrFinallyClause finallyClause = tryCatchStatement.getFinallyClause();\n    InstructionImpl tryBeg = null;\n    InstructionImpl tryEnd = null;\n    if (tryBlock != null) {\n      tryBeg = startNode(tryBlock);\n      tryBlock.accept(this);\n      tryEnd = myHead != tryBeg ? myHead : null;\n      finishNode(tryBeg);\n    }\n\n    InstructionImpl[] catches = new InstructionImpl[catchClauses.length];\n    for (int i = 0; i < catchClauses.length; i++) {\n      myHead = null;\n      final InstructionImpl catchBeg = startNode(catchClauses[i]);\n      if (tryBeg != null) addEdge(tryBeg, catchBeg);\n      if (tryEnd != null) addEdge(tryEnd, catchBeg);\n      catchClauses[i].accept(this);\n      catches[i] = myHead;\n      finishNode(catchBeg);\n    }\n\n    if (finallyClause != null) {\n      myHead = null;\n      final InstructionImpl finallyInstruction = startNode(finallyClause);\n      addFinallyEdges(finallyInstruction);\n\n      if (tryEnd != null) {\n        addEdge(tryEnd, addCallNode(finallyInstruction, tryCatchStatement));\n      }\n      for (InstructionImpl catchEnd : catches) {\n        addEdge(catchEnd, addCallNode(finallyInstruction, tryCatchStatement));\n      }\n      myHead = finallyInstruction;\n      finallyClause.accept(this);\n      addNode(new RetInstruction(myInstructionNumber++));\n      finishNode(finallyInstruction);\n    }\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n    final GrCondition condition = ifStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n\n    final InstructionImpl head = myHead;\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch != null) {\n      final InstructionImpl thenInstruction = startNode(thenBranch);\n      thenBranch.accept(this);\n      addPendingEdge(ifStatement);\n      finishNode(thenInstruction);\n    }\n\n    myHead = head;\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      final InstructionImpl elseInstruction = startNode(elseBranch);\n      elseBranch.accept(this);\n      addPendingEdge(ifStatement);\n      finishNode(elseInstruction);\n    }\n\n    finishNode(ifInstruction);\n  }","id":84835,"modified_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n    final GrCondition condition = ifStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n\n    final InstructionImpl head = myHead;\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch != null) {\n      final InstructionImpl thenInstruction = startNode(thenBranch);\n      thenBranch.accept(this);\n      addPendingEdge(ifStatement, myHead);\n      finishNode(thenInstruction);\n    }\n\n    myHead = head;\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      final InstructionImpl elseInstruction = startNode(elseBranch);\n      elseBranch.accept(this);\n      addPendingEdge(ifStatement, myHead);\n      finishNode(elseInstruction);\n    }\n\n    finishNode(ifInstruction);\n  }","commit_id":"dcc53212c4483fb49edf29524ebda0bfae93e16c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkPending(InstructionImpl instruction) {\n    final PsiElement element = instruction.getElement();\n    if (element == null) {\n      //add all\n      for (Pair<InstructionImpl, GroovyPsiElement> pair : myPending) {\n        addEdge(pair.getFirst(), instruction);\n      }\n    } else {\n      for (int i = myPending.size(); i >= 0; i--) {\n        final Pair<InstructionImpl, GroovyPsiElement> pair = myPending.get(i);\n        final PsiElement scopeWhenToAdd = pair.getSecond();\n        if (!PsiTreeUtil.isAncestor(scopeWhenToAdd, element, false)) {\n          addEdge(pair.getFirst(), instruction);\n          myPending.remove(i);\n        } else break;\n      }\n    }\n  }","id":84836,"modified_method":"private void checkPending(InstructionImpl instruction) {\n    final PsiElement element = instruction.getElement();\n    if (element == null) {\n      //add all\n      for (Pair<InstructionImpl, GroovyPsiElement> pair : myPending) {\n        addEdge(pair.getFirst(), instruction);\n      }\n      myPending.clear();\n    } else {\n      for (int i = myPending.size() - 1; i >= 0; i--) {\n        final Pair<InstructionImpl, GroovyPsiElement> pair = myPending.get(i);\n        final PsiElement scopeWhenToAdd = pair.getSecond();\n        if (!PsiTreeUtil.isAncestor(scopeWhenToAdd, element, false)) {\n          addEdge(pair.getFirst(), instruction);\n          myPending.remove(i);\n        } else break;\n      }\n    }\n  }","commit_id":"4abced43d5c404d6cdb505de8a93260ea5dda37b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addNode(InstructionImpl instruction) {\n    myInstructions.add(instruction);\n    addEdge(myHead, instruction);\n    myHead = instruction;\n  }","id":84837,"modified_method":"private void addNode(InstructionImpl instruction) {\n    myInstructions.add(instruction);\n    if (myHead != null) {\n      addEdge(myHead, instruction);\n    }\n    myHead = instruction;\n  }","commit_id":"4abced43d5c404d6cdb505de8a93260ea5dda37b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Instruction buildControlFlow(GroovyPsiElement scope, GroovyPsiElement startInScope, GroovyPsiElement endInScope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new Stack<InstructionImpl>();\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 0;\n    myHead = new InstructionImpl(scope, myInstructionNumber++);\n    myStartInScope = startInScope;\n    myEndInScope = endInScope;\n\n    Instruction head = myHead;\n    scope.accept(this);\n\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n    return head;\n  }","id":84838,"modified_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope, GroovyPsiElement startInScope, GroovyPsiElement endInScope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new Stack<InstructionImpl>();\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 1;\n    myStartInScope = startInScope;\n    myEndInScope = endInScope;\n    myIsInScope = startInScope == null;\n\n    startNode(null);\n    scope.accept(this);\n\n    myHead = null; //to prevent first -> last edge\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n    return myInstructions.toArray(new Instruction[myInstructions.size()]);\n  }","commit_id":"4abced43d5c404d6cdb505de8a93260ea5dda37b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n    final GrCondition condition = ifStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch != null) {\n      final InstructionImpl thenInstruction = startNode(thenBranch);\n      addEdge(ifInstruction, thenInstruction);\n      thenBranch.accept(this);\n      finishNode(thenInstruction);\n    }\n\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      final InstructionImpl elseInstruction = startNode(elseBranch);\n      addEdge(ifInstruction, elseInstruction);\n      elseBranch.accept(this);\n      finishNode(elseInstruction);\n    }\n\n    finishNode(ifInstruction);\n  }","id":84839,"modified_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n    final GrCondition condition = ifStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch != null) {\n      final InstructionImpl thenInstruction = startNode(thenBranch);\n      thenBranch.accept(this);\n      addPendingEdge(ifStatement);\n      finishNode(thenInstruction);\n    }\n\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      final InstructionImpl elseInstruction = startNode(elseBranch);\n      elseBranch.accept(this);\n      addPendingEdge(ifStatement);\n      finishNode(elseInstruction);\n    }\n\n    finishNode(ifInstruction);\n  }","commit_id":"4abced43d5c404d6cdb505de8a93260ea5dda37b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    final StringBuilder builder = new StringBuilder();\n    builder.append(myNumber);\n    builder.append(\"(\");\n    for (InstructionImpl instruction : mySucc) {\n      builder.append(instruction.myNumber);\n    }\n    builder.append(\")\");\n    builder.append(\" element: \").append(myPsiElement);\n    return builder.toString();\n  }","id":84840,"modified_method":"public String toString() {\n    final StringBuilder builder = new StringBuilder();\n    builder.append(myNumber);\n    builder.append(\"(\");\n    for (int i = 0; i < mySucc.size(); i++) {\n      if (i > 0) builder.append(',');\n      builder.append(mySucc.get(i).myNumber);\n    }\n    builder.append(\")\");\n    builder.append(\" element: \").append(myPsiElement);\n    return builder.toString();\n  }","commit_id":"4abced43d5c404d6cdb505de8a93260ea5dda37b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitWhileStatement(GrWhileStatement whileStatement) {\n    final InstructionImpl instruction = startNode(whileStatement);\n    final GrCondition condition = whileStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n    addPendingEdge(whileStatement, myHead); //break\n    final GrCondition body = whileStatement.getBody();\n    if (body != null) {\n      body.accept(this);\n    }\n    checkPending(instruction); //check for breaks targeted here\n    addEdge(myHead, instruction); //loop\n    myHead = null;\n    finishNode(instruction);\n  }","id":84841,"modified_method":"public void visitWhileStatement(GrWhileStatement whileStatement) {\n    final InstructionImpl instruction = startNode(whileStatement);\n    final GrCondition condition = whileStatement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n    addPendingEdge(whileStatement, myHead); //break\n    final GrCondition body = whileStatement.getBody();\n    if (body != null) {\n      body.accept(this);\n    }\n    checkPending(instruction); //check for breaks targeted here\n    if (myHead != null) addEdge(myHead, instruction); //loop\n    myHead = null;\n    finishNode(instruction);\n  }","commit_id":"ed874344c9d2547426927b9149b6b1e05e236dc4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure Dummy store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheDummyPersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","id":84842,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure Dummy store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheDummyPersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                // Make initial cache loading from persistent store. This is a\n                // distributed operation and will call CacheStore.loadCache(...)\n                // method on all nodes in topology.\n                loadCache(cache);\n\n                // Start transaction and execute several cache operations with\n                // read/write-through to persistent store.\n                executeTransaction(cache);\n            }\n        }\n    }","commit_id":"135fe35d41cf85e65cc4c62f07999bcc89b31bf3","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure Hibernate store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheHibernatePersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","id":84843,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure Hibernate store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheHibernatePersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                // Make initial cache loading from persistent store. This is a\n                // distributed operation and will call CacheStore.loadCache(...)\n                // method on all nodes in topology.\n                loadCache(cache);\n\n                // Start transaction and execute several cache operations with\n                // read/write-through to persistent store.\n                executeTransaction(cache);\n            }\n        }\n    }","commit_id":"135fe35d41cf85e65cc4c62f07999bcc89b31bf3","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure JDBC store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheJdbcPersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","id":84844,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure JDBC store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheJdbcPersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                // Make initial cache loading from persistent store. This is a\n                // distributed operation and will call CacheStore.loadCache(...)\n                // method on all nodes in topology.\n                loadCache(cache);\n\n                // Start transaction and execute several cache operations with\n                // read/write-through to persistent store.\n                executeTransaction(cache);\n            }\n        }\n    }","commit_id":"135fe35d41cf85e65cc4c62f07999bcc89b31bf3","url":"https://github.com/apache/ignite"},{"original_method":"public void setTexCoord(ArrayList<PVector> data) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n\r\n    firstUpdateIdx = 0;\r\n    lastUpdateIdx = numVertices - 1;\r\n    \r\n    PVector vec;\r\n    for (int i = 0; i < numVertices; i++) {\r\n      vec = (PVector)data.get(i);\r\n      updateTexCoordArray[3 * i + 0] = vec.x;\r\n      updateTexCoordArray[3 * i + 1] = vec.y;\r\n    }\r\n  }","id":84845,"modified_method":"public void setTexCoord(ArrayList<PVector> data) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n\r\n    firstUpdateIdx = 0;\r\n    lastUpdateIdx = numVertices - 1;\r\n    \r\n    PVector vec;\r\n    for (int i = 0; i < numVertices; i++) {\r\n      vec = (PVector)data.get(i);\r\n      \r\n      if (a3d.imageMode == IMAGE) {\r\n        updateTexCoordArray[2 * i + 0] = vec.x / vertGroup[i].textures[selectedTexture].width;\r\n        updateTexCoordArray[2 * i + 1] = vec.y / vertGroup[i].textures[selectedTexture].height;\r\n      } else {\r\n        updateTexCoordArray[2 * i + 0] = vec.x;\r\n        updateTexCoordArray[2 * i + 1] = vec.y;\r\n      }\r\n    }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void beginUpdate(int element) {\r\n    if (updateElement != -1) {\r\n      throw new RuntimeException(\"GLModel: only one element can be updated at the time\");\r\n    }\r\n    \r\n    updateElement = element;\r\n    \r\n    if (updateElement == VERTICES) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glVertexBufferID[0]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateVertexArray == null) {\r\n        updateVertexArray = new float[vertices.capacity()];\r\n        vertices.get(updateVertexArray);\r\n        vertices.rewind();\r\n      }      \r\n    } else if (updateElement == COLORS) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glColorBufferID[0]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateColorArray == null) {\r\n        updateColorArray = new float[colors.capacity()];\r\n        colors.get(updateColorArray);\r\n        colors.rewind();\r\n      }\r\n    } else if (updateElement == NORMALS) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glNormalBufferID[0]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateNormalArray == null) {\r\n        updateNormalArray = new float[normals.capacity()];\r\n        normals.get(updateNormalArray);\r\n        normals.rewind();      \r\n      }\r\n    } else if (updateElement == TEXTURES) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glTexCoordBufferID[selectedTexture]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateTexCoordArray == null) {\r\n        updateTexCoordArray = new float[texCoords[selectedTexture].capacity()];\r\n        texCoords[selectedTexture].get(updateTexCoordArray);\r\n        texCoords[selectedTexture].rewind();      \r\n      }\r\n    } else if (updateElement == GROUPS) {\r\n      groupBreaks.clear();\r\n    } else {\r\n      throw new RuntimeException(\"GLModel: unknown element to update\");  \r\n    }\r\n  }","id":84846,"modified_method":"public void beginUpdate(int element) {\r\n    if (updateElement != -1) {\r\n      throw new RuntimeException(\"GLModel: only one element can be updated at the time\");\r\n    }\r\n    \r\n    updateElement = element;\r\n    \r\n    if (updateElement == VERTICES) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glVertexBufferID[0]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateVertexArray == null) {\r\n        updateVertexArray = new float[vertices.capacity()];\r\n        vertices.get(updateVertexArray);\r\n        vertices.rewind();\r\n      }      \r\n    } else if (updateElement == COLORS) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glColorBufferID[0]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateColorArray == null) {\r\n        updateColorArray = new float[colors.capacity()];\r\n        colors.get(updateColorArray);\r\n        colors.rewind();\r\n      }\r\n    } else if (updateElement == NORMALS) {\r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glNormalBufferID[0]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateNormalArray == null) {\r\n        updateNormalArray = new float[normals.capacity()];\r\n        normals.get(updateNormalArray);\r\n        normals.rewind();      \r\n      }\r\n    } else if (updateElement == TEXTURES) {\r\n       // Check that all the groups have texture assigned.\r\n       for (int i = 0; i < groups.size(); i++)\r\n         if (((VertexGroup)groups.get(i)).textures[selectedTexture] == null)\r\n           throw new RuntimeException(\"GLModel: texture must be set first in group \" + i);\r\n      \r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glTexCoordBufferID[selectedTexture]);\r\n      \r\n      firstUpdateIdx = numVertices;\r\n      lastUpdateIdx = -1;\r\n      \r\n      if (updateTexCoordArray == null) {\r\n        updateTexCoordArray = new float[texCoords[selectedTexture].capacity()];\r\n        texCoords[selectedTexture].get(updateTexCoordArray);\r\n        texCoords[selectedTexture].rewind();      \r\n      }\r\n    } else if (updateElement == GROUPS) {\r\n      groupBreaks.clear();\r\n    } else {\r\n      throw new RuntimeException(\"GLModel: unknown element to update\");  \r\n    }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void render(int first, int last)\r\n\t{\r\n\t\tgl.glColor4f(tintR, tintG, tintB, tintA);\r\n\t\t\r\n\t\tgl.glLineWidth(a3d.strokeWeight);\r\n\t\tgl.glPointSize(PApplet.min(a3d.strokeWeight, maxPointSize));\r\n\t    \r\n        //if (effect != null) effect.start();\r\n\t    \r\n\r\n        \r\n\t    if (normCoordsVBO != null)\r\n\t    {\r\n\t    \tgl.glEnableClientState(GL11.GL_NORMAL_ARRAY);\r\n            gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, normCoordsVBO[0]);\r\n            gl.glNormalPointer(GL11.GL_FLOAT, 0, 0);\r\n\t    }\r\n\t    \t    \r\n\t    if (colorsVBO != null)\r\n\t    {\r\n\t    \tgl.glEnableClientState(GL11.GL_COLOR_ARRAY);\r\n            gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, colorsVBO[0]);\r\n\t        gl.glColorPointer(4, GL11.GL_FLOAT, 0, 0);\r\n\t    }\r\n\r\n\t    if (texCoordsVBO != null)\r\n\t    {\r\n\t    \tgl.glEnable(textures[0].getTextureTarget());\r\n\r\n            // Binding texture units.\r\n            for (int n = 0; n < numTextures; n++)\r\n            {\r\n            \tgl.glActiveTexture(GL11.GL_TEXTURE0 + n);\r\n                gl.glBindTexture(GL11.GL_TEXTURE_2D, textures[n].getTextureID()); \r\n            }\t    \t\r\n\t    \t\r\n            if (usingPointSprites)\r\n            {\r\n            \t// Texturing with point sprites.\r\n            \t\r\n                // This is how will our point sprite's size will be modified by \r\n                // distance from the viewer            \t\r\n            \tfloat quadratic[] = {1.0f, 0.0f, 0.01f, 1};\r\n                ByteBuffer temp = ByteBuffer.allocateDirect(16);\r\n                temp.order(ByteOrder.nativeOrder());            \t\r\n                gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION, (FloatBuffer) temp.asFloatBuffer().put(quadratic).flip());\r\n                                \r\n                // The alpha of a point is calculated to allow the fading of points \r\n                // instead of shrinking them past a defined threshold size. The threshold \r\n                // is defined by GL_POINT_FADE_THRESHOLD_SIZE_ARB and is not clamped to \r\n                // the minimum and maximum point sizes.\r\n                gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE, spriteFadeSize);\r\n                gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN, 1.0f);\r\n                gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX, maxPointSize);\r\n\r\n                // Specify point sprite texture coordinate replacement mode for each \r\n                // texture unit\r\n                gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES, GL11.GL_COORD_REPLACE_OES, GL11.GL_TRUE);\r\n\r\n                gl.glEnable(GL11.GL_POINT_SPRITE_OES);\r\n            }\r\n            else\r\n            {\r\n            \t// Regular texturing.\r\n                gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);\r\n                for (int n = 0; n < numTextures; n++)\r\n                {\r\n                    gl.glClientActiveTexture(GL11.GL_TEXTURE0 + n);\r\n                    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, texCoordsVBO[n]);\r\n                    gl.glTexCoordPointer(2, GL11.GL_FLOAT, 0, 0);\r\n                }\r\n            }\r\n            \r\n            //if (effect != null) effect.setTextures(textures);         \r\n\t    }\t    \r\n\t    \r\n\t    // Drawing the vertices:\r\n\t    gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);\r\n\t    \t    \r\n\t    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, vertCoordsVBO[0]);\r\n\t    \r\n\t    gl.glVertexPointer(3, GL11.GL_FLOAT, 0, 0);\r\n\t    \t   \r\n\t    // Last transformation: inversion of coordinate to make comaptible with Processing's inverted Y axis.\r\n\t\tgl.glPushMatrix();\r\n\t\tgl.glScalef(1, -1, 1);\t   \r\n\t    gl.glDrawArrays(vertexMode, first, last - first + 1);\r\n\t    gl.glPopMatrix();\t    \r\n\t    \r\n\t    //if (effect != null) effect.disableVertexAttribs();\r\n\t    \r\n\t    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, 0);\r\n\t    gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);\r\n\t    \t    \r\n\t    if (texCoordsVBO != null) \r\n\t    {\t\r\n\t    \tif (usingPointSprites)\r\n\t    \t{\r\n\t    \t\tgl.glDisable(GL11.GL_POINT_SPRITE_OES);\r\n\t    \t}\r\n\t    \telse\r\n\t    \t{\r\n\t    \t    gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);\r\n\t    \t}\r\n\t    \tgl.glDisable(textures[0].getTextureTarget());\r\n\t    }\r\n\t    if (colorsVBO != null) gl.glDisableClientState(GL11.GL_COLOR_ARRAY);\r\n\t    if (normCoordsVBO != null) gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);\r\n\t    \r\n        // If there was noblending originally\r\n        if (!blend0 && blend) gl.glDisable(GL11.GL_BLEND);\r\n        // Default blending mode in PGraphicsAndroid3D.\r\n        gl.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);        \r\n        \r\n        //if (effect != null) effect.stop();\r\n\t}","id":84847,"modified_method":"public void render(int first, int last)\r\n\t{\r\n\t   int texTarget = GL11.GL_TEXTURE_2D;\r\n\t   float pointSize;\r\n\t  \r\n\t   // Setting line width and point size from stroke value.\r\n\t\t gl.glLineWidth(a3d.strokeWeight);\r\n\t\t pointSize = PApplet.min(a3d.strokeWeight, MAX_POINTSIZE);\r\n     gl.glPointSize(pointSize);\r\n\t    \r\n     gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);\r\n     gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glNormalBufferID[0]);\r\n     gl.glNormalPointer(GL11.GL_FLOAT, 0, 0);\r\n\r\n     gl.glEnableClientState(GL11.GL_COLOR_ARRAY);\r\n     gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glColorBufferID[0]);\r\n     gl.glColorPointer(4, GL11.GL_FLOAT, 0, 0);\r\n     \r\n     VertexGroup group;\r\n     for (int i = 0; i < groups.size(); i++) {\r\n       group = (VertexGroup)groups.get(i);\r\n\r\n       if (0 < numTextures)  {\r\n         GLTexture[] textures = group.textures;\r\n         texTarget = textures[0].getTextureTarget();\r\n         gl.glEnable(texTarget);\r\n         // Binding texture units.\r\n         for (int n = 0; n < numTextures; n++) {\r\n           gl.glActiveTexture(GL11.GL_TEXTURE0 + n);\r\n           gl.glBindTexture(GL11.GL_TEXTURE_2D, textures[n].getTextureID()); \r\n         }\r\n         if (pointSprites) {\r\n           // Texturing with point sprites.\r\n              \r\n           // This is how will our point sprite's size will be modified by \r\n           // distance from the viewer             \r\n           float quadratic[] = {1.0f, 0.0f, 0.01f, 1};\r\n           ByteBuffer temp = ByteBuffer.allocateDirect(16);\r\n           temp.order(ByteOrder.nativeOrder());              \r\n           gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION, (FloatBuffer)temp.asFloatBuffer().put(quadratic).flip());\r\n           \r\n           // The alpha of a point is calculated to allow the fading of points \r\n           // instead of shrinking them past a defined threshold size. The threshold \r\n           // is defined by GL_POINT_FADE_THRESHOLD_SIZE_ARB and is not clamped to \r\n           // the minimum and maximum point sizes.\r\n           gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE, 0.6f * pointSize);\r\n           gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN, 1.0f);\r\n           gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX, MAX_POINTSIZE);\r\n\r\n           // Specify point sprite texture coordinate replacement mode for each \r\n           // texture unit\r\n           gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES, GL11.GL_COORD_REPLACE_OES, GL11.GL_TRUE);\r\n\r\n           gl.glEnable(GL11.GL_POINT_SPRITE_OES);           \r\n         } else {\r\n           // Regular texturing.\r\n           gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);\r\n           for (int n = 0; n < numTextures; n++) {\r\n             gl.glClientActiveTexture(GL11.GL_TEXTURE0 + n);\r\n             gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glTexCoordBufferID[n]);\r\n             gl.glTexCoordPointer(2, GL11.GL_FLOAT, 0, 0);\r\n           }           \r\n         }\r\n       }\r\n       \r\n      gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);            \r\n      gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, glVertexBufferID[0]);\r\n      gl.glVertexPointer(3, GL11.GL_FLOAT, 0, 0);\r\n       \r\n      // Last transformation: inversion of coordinate to make compatible with Processing's inverted Y axis.\r\n      gl.glPushMatrix();\r\n      gl.glScalef(1, -1, 1);     \r\n      gl.glDrawArrays(glMode, group.first, group.last - group.first + 1);\r\n      gl.glPopMatrix();     \r\n    }\r\n\r\n    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER, 0);\r\n    gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);\r\n\r\n    if (0 < numTextures)  {    \r\n\t    \tif (pointSprites) \t{\r\n\t    \t\tgl.glDisable(GL11.GL_POINT_SPRITE_OES);\r\n\t    \t} \telse \t{\r\n\t    \t    gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);\r\n\t    \t}\r\n\t    \tgl.glDisable(texTarget);\r\n\t    }\r\n\t    \r\n\t  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);\r\n    gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);\r\n\t}","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void setTexCoord(float[] data) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n    \r\n    firstUpdateIdx = 0;\r\n    firstUpdateIdx = numVertices;    \r\n    PApplet.arrayCopy(data, updateTexCoordArray);\r\n  }","id":84848,"modified_method":"public void setTexCoord(float[] data) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n    \r\n    firstUpdateIdx = 0;\r\n    firstUpdateIdx = numVertices;\r\n    \r\n    if (a3d.imageMode == IMAGE) {\r\n      float u, v;\r\n      for (int i = 0; i < numVertices; i++) {\r\n        u = data[2 * i + 0];\r\n        v = data[2 * i + 1];        \r\n        \r\n        u /= vertGroup[i].textures[selectedTexture].width;\r\n        v /= vertGroup[i].textures[selectedTexture].height;\r\n\r\n        updateTexCoordArray[2 * i + 0] = u;\r\n        updateTexCoordArray[2 * i + 1] = v;\r\n      }  \r\n    } else {\r\n      PApplet.arrayCopy(data, updateTexCoordArray);\r\n    }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void setGroupNormals(int gr, float x, float y, float z) {\r\n    VertexGroup group = (VertexGroup)groups.get(gr);\r\n    beginUpdate(NORMALS);\r\n    firstUpdateIdx = group.first;\r\n    lastUpdateIdx = group.last;    \r\n    for (int i = group.first; i < group.last; i++) {\r\n      updateNormalArray[3 * i + 0] = x;\r\n      updateNormalArray[3 * i + 1] = y;\r\n      updateNormalArray[3 * i + 2] = z;\r\n    }\r\n    endUpdate();\r\n  }","id":84849,"modified_method":"public void setGroupNormals(int gr, float x, float y, float z) {\r\n    VertexGroup group = (VertexGroup)groups.get(gr);\r\n    beginUpdate(NORMALS);\r\n    firstUpdateIdx = group.first;\r\n    lastUpdateIdx = group.last;    \r\n    for (int i = group.first; i <= group.last; i++) {\r\n      updateNormalArray[3 * i + 0] = x;\r\n      updateNormalArray[3 * i + 1] = y;\r\n      updateNormalArray[3 * i + 2] = z;\r\n    }\r\n    endUpdate();\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"protected void readParameters(GLModelParameters params) {\r\n    pointSprites = false;\r\n    if (params.drawMode == POINTS) glMode = GL11.GL_POINTS;\r\n    else if (params.drawMode == POINT_SPRITES) {\r\n      glMode = GL11.GL_POINTS;\r\n      pointSprites = true;\r\n      \r\n      \r\n      usingPointSprites = true;\r\n      float[] tmp = { 0.0f };\r\n      gl.glGetFloatv(GL11.GL_POINT_SIZE_MAX, tmp, 0);\r\n      maxPointSize = tmp[0];\r\n      pointSize = maxPointSize;\r\n      spriteFadeSize = 0.6f * pointSize;\r\n      \r\n    }\r\n    else if (params.drawMode == LINES) glMode = GL11.GL_LINES;\r\n    else if (params.drawMode == LINE_STRIP) glMode = GL11.GL_LINE_STRIP;\r\n    else if (params.drawMode == LINE_LOOP) glMode = GL11.GL_LINE_LOOP;\r\n    else if (params.drawMode == TRIANGLES) glMode = GL11.GL_TRIANGLES; \r\n    else if (params.drawMode == TRIANGLE_FAN) glMode = GL11.GL_TRIANGLE_FAN;\r\n    else if (params.drawMode == TRIANGLE_STRIP) glMode = GL11.GL_TRIANGLE_STRIP;\r\n    else {\r\n      throw new RuntimeException(\"GLModel: Unknown draw mode\");\r\n    }\r\n    \r\n    if (params.updateMode == STATIC) glUsage = GL11.GL_STATIC_DRAW;\r\n    else if (params.updateMode == DYNAMIC) glUsage = GL11.GL_DYNAMIC_DRAW;\r\n    else {\r\n      throw new RuntimeException(\"GLModel: Unknown update mode\");\r\n    }\r\n  }","id":84850,"modified_method":"protected void readParameters(GLModelParameters params) {\r\n    pointSprites = false;\r\n    if (params.drawMode == POINTS) glMode = GL11.GL_POINTS;\r\n    else if (params.drawMode == POINT_SPRITES) {\r\n      glMode = GL11.GL_POINTS;\r\n      pointSprites = true;\r\n    }\r\n    else if (params.drawMode == LINES) glMode = GL11.GL_LINES;\r\n    else if (params.drawMode == LINE_STRIP) glMode = GL11.GL_LINE_STRIP;\r\n    else if (params.drawMode == LINE_LOOP) glMode = GL11.GL_LINE_LOOP;\r\n    else if (params.drawMode == TRIANGLES) glMode = GL11.GL_TRIANGLES; \r\n    else if (params.drawMode == TRIANGLE_FAN) glMode = GL11.GL_TRIANGLE_FAN;\r\n    else if (params.drawMode == TRIANGLE_STRIP) glMode = GL11.GL_TRIANGLE_STRIP;\r\n    else {\r\n      throw new RuntimeException(\"GLModel: Unknown draw mode\");\r\n    }\r\n    \r\n    if (params.updateMode == STATIC) glUsage = GL11.GL_STATIC_DRAW;\r\n    else if (params.updateMode == DYNAMIC) glUsage = GL11.GL_DYNAMIC_DRAW;\r\n    else {\r\n      throw new RuntimeException(\"GLModel: Unknown update mode\");\r\n    }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public float[] getTexCoordArray() {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n    \r\n    float[] res = new float[numVertices * 2];\r\n    PApplet.arrayCopy(updateTexCoordArray, res);\r\n    \r\n    return res;\r\n  }","id":84851,"modified_method":"public float[] getTexCoordArray() {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n    \r\n    float[] res = new float[numVertices * 2];\r\n    PApplet.arrayCopy(updateTexCoordArray, res);\r\n    \r\n    if (a3d.imageMode == IMAGE) {\r\n      float u, v;\r\n      for (int i = 0; i < numVertices; i++) {\r\n        u = res[2 * i + 0];\r\n        v = res[2 * i + 1];        \r\n        \r\n        u *= vertGroup[i].textures[selectedTexture].width;\r\n        v *= vertGroup[i].textures[selectedTexture].height;\r\n\r\n        res[2 * i + 0] = u;\r\n        res[2 * i + 1] = v;\r\n      }  \r\n    }\r\n    \r\n    return res;\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"protected void createGroups() {\r\n      // Constructing the intervals given the \"break-point\" vertices.\r\n      int idx0, idx1;\r\n      idx0 = 0;\r\n      Integer idx;\r\n      groups.clear();\r\n      for (int i = 0; i < groupBreaks.size(); i++) {\r\n        // A group ends at idx1. So the interval is (idx0, idx1).\r\n        idx = (Integer)groupBreaks.get(i);\r\n        idx1 = idx.intValue();\r\n      \r\n        if (idx0 <= idx1) {\r\n          groups.add(new VertexGroup(idx0, idx1, numTextures));\r\n          idx0 = idx1 + 1;          \r\n        }\r\n      }\r\n      \r\n      idx1 = numVertices - 1;\r\n      if (idx0 <= idx1) {\r\n        groups.add(new VertexGroup(idx0, idx1, numTextures));\r\n      }\r\n  }","id":84852,"modified_method":"protected void createGroups() {\r\n      // Constructing the intervals given the \"break-point\" vertices.\r\n      VertexGroup group;\r\n      int idx0, idx1;\r\n      idx0 = 0;\r\n      Integer idx;\r\n      groups.clear();\r\n      for (int i = 0; i < groupBreaks.size(); i++) {\r\n        // A group ends at idx1. So the interval is (idx0, idx1).\r\n        idx = (Integer)groupBreaks.get(i);\r\n        idx1 = idx.intValue();\r\n      \r\n        if (idx0 <= idx1) {\r\n          group = new VertexGroup(idx0, idx1, numTextures);\r\n          groups.add(group);\r\n          idx0 = idx1 + 1;\r\n          for (int n = idx0; n <= idx1; n++) {\r\n            vertGroup[n] = group;\r\n          }\r\n        }\r\n      }\r\n      \r\n      idx1 = numVertices - 1;\r\n      if (idx0 <= idx1) {\r\n        group = new VertexGroup(idx0, idx1, numTextures);\r\n        groups.add(group);\r\n        for (int n = idx0; n <= idx1; n++) {\r\n          vertGroup[n] = group;\r\n        }        \r\n      }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public GLModel(PApplet parent, int numVert, int numTex, GLModelParameters params) {\r\n    this.parent = parent;\r\n    a3d = (PGraphicsAndroid3D)parent.g;\r\n    if (a3d.gl instanceof GL11) {\r\n      gl = (GL11)a3d.gl;\r\n    }\r\n    else {\r\n      throw new RuntimeException(\"GLModel: OpenGL ES 1.1 required\");\r\n    }\r\n    \r\n    numVertices = numVert;\r\n    numTextures = numTex;\r\n    \r\n    readParameters(params);\r\n    \r\n    initBufferIDs();\r\n        \r\n    createVertexBuffer();\r\n    createColorBuffer();\r\n    createNormalBuffer();    \r\n    createTexCoordBuffer();\r\n\r\n    initGroups();\r\n\r\n    updateVertexArray = null;\r\n    updateColorArray = null;\r\n    updateNormalArray = null;\r\n    updateTexCoordArray = null;\r\n    \r\n    updateElement = -1;\r\n    selectedTexture = 0;\r\n    \r\n\r\n    \r\n    \r\n    \r\n    imageMode = a3d.imageMode;    \r\n    tintR = a3d.tintR;\r\n    \r\n    tintR = tintG = tintB = tintA = 1.0f;\r\n    shininess[0] = 0.0f;\r\n        \r\n    pointSize = 1.0f;\r\n    lineWidth = 1.0f;\r\n    usingPointSprites = false;\r\n    blend = false;\r\n    blendMode = ADD;\r\n    \r\n    float[] tmp = { 0.0f };\r\n    gl.glGetFloatv(GL11.GL_POINT_SIZE_MAX, tmp, 0);\r\n    maxPointSize = tmp[0];\r\n  }","id":84853,"modified_method":"public GLModel(PApplet parent, int numVert, int numTex, GLModelParameters params) {\r\n    this.parent = parent;\r\n    a3d = (PGraphicsAndroid3D)parent.g;\r\n    if (a3d.gl instanceof GL11) {\r\n      gl = (GL11)a3d.gl;\r\n    } else {\r\n      throw new RuntimeException(\"GLModel: OpenGL ES 1.1 required\");\r\n    }\r\n    \r\n    numVertices = numVert;\r\n    numTextures = numTex;\r\n    \r\n    readParameters(params);\r\n    \r\n    initBufferIDs();\r\n        \r\n    createVertexBuffer();\r\n    createColorBuffer();\r\n    createNormalBuffer();    \r\n    createTexCoordBuffer();\r\n\r\n    initGroups();\r\n\r\n    updateVertexArray = null;\r\n    updateColorArray = null;\r\n    updateNormalArray = null;\r\n    updateTexCoordArray = null;\r\n    \r\n    updateElement = -1;\r\n    selectedTexture = 0;\r\n    \r\n    float[] tmp = { 0.0f };\r\n    gl.glGetFloatv(GL11.GL_POINT_SIZE_MAX, tmp, 0);\r\n    MAX_POINTSIZE = tmp[0];\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"protected void initGroups() {\r\n    groupBreaks = new ArrayList<Integer>();\r\n    groups = new ArrayList<VertexGroup>();\r\n    groups.add(new VertexGroup(0, numVertices - 1, numTextures));\r\n  }","id":84854,"modified_method":"protected void initGroups() {\r\n    groupBreaks = new ArrayList<Integer>();\r\n    groups = new ArrayList<VertexGroup>();\r\n    VertexGroup group = new VertexGroup(0, numVertices - 1, numTextures);\r\n    groups.add(group);\r\n    vertGroup = new VertexGroup[numVertices];\r\n    for (int i = 0; i < numVertices; i++) {\r\n      vertGroup[i] = group;\r\n    }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void setGroupColor(int gr, float r, float g, float b, float a) {\r\n    VertexGroup group = (VertexGroup)groups.get(gr);\r\n    beginUpdate(COLORS);\r\n    firstUpdateIdx = group.first;\r\n    lastUpdateIdx = group.last;    \r\n    for (int i = group.first; i < group.last; i++) {\r\n      updateColorArray[4 * i + 0] = r;\r\n      updateColorArray[4 * i + 1] = g;\r\n      updateColorArray[4 * i + 2] = b;\r\n      updateColorArray[4 * i + 3] = a;      \r\n    }\r\n    endUpdate();\r\n  }","id":84855,"modified_method":"public void setGroupColor(int gr, float r, float g, float b, float a) {\r\n    VertexGroup group = (VertexGroup)groups.get(gr);\r\n    beginUpdate(COLORS);\r\n    firstUpdateIdx = group.first;\r\n    lastUpdateIdx = group.last;    \r\n    for (int i = group.first; i <= group.last; i++) {\r\n      updateColorArray[4 * i + 0] = r;\r\n      updateColorArray[4 * i + 1] = g;\r\n      updateColorArray[4 * i + 2] = b;\r\n      updateColorArray[4 * i + 3] = a;      \r\n    }\r\n    endUpdate();\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void setTexture(GLTexture tex) {\r\n    VertexGroup group;\r\n    for (int i = 0; i < groups.size(); i++) setGroupTexture(i, tex);\r\n  }","id":84856,"modified_method":"public void setTexture(GLTexture tex) {\r\n    for (int i = 0; i < groups.size(); i++) setGroupTexture(i, tex);\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public PVector getTexCoord(int idx) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n\r\n    float s = updateTexCoordArray[2 * idx + 0];\r\n    float t = updateTexCoordArray[2 * idx + 1];\r\n    \r\n    PVector res = new PVector(s, t, 0);\r\n    return res;\r\n  }","id":84857,"modified_method":"public PVector getTexCoord(int idx) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n\r\n    float s = updateTexCoordArray[2 * idx + 0];\r\n    float t = updateTexCoordArray[2 * idx + 1];\r\n    \r\n    if (a3d.imageMode == IMAGE) {\r\n      s *= vertGroup[idx].textures[selectedTexture].width;\r\n      t *= vertGroup[idx].textures[selectedTexture].height;\r\n    }\r\n    \r\n    PVector res = new PVector(s, t, 0);\r\n    return res;\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"public void setTexCoord(int idx, float u, float v) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n\r\n    if (idx < firstUpdateIdx) firstUpdateIdx = idx;\r\n    if (lastUpdateIdx < idx) lastUpdateIdx = idx;\r\n    \r\n    updateTexCoordArray[2 * idx + 0] = u;\r\n    updateTexCoordArray[2 * idx + 1] = v;\r\n  }","id":84858,"modified_method":"public void setTexCoord(int idx, float u, float v) {\r\n    if (updateElement != TEXTURES) {\r\n      throw new RuntimeException(\"GLModel: update mode is not set to TEXTURES\");\r\n    }\r\n\r\n    if (idx < firstUpdateIdx) firstUpdateIdx = idx;\r\n    if (lastUpdateIdx < idx) lastUpdateIdx = idx;\r\n\r\n    if (a3d.imageMode == IMAGE) {\r\n      u /= vertGroup[idx].textures[selectedTexture].width;\r\n      v /= vertGroup[idx].textures[selectedTexture].height; \r\n    }\r\n    \r\n    updateTexCoordArray[2 * idx + 0] = u;\r\n    updateTexCoordArray[2 * idx + 1] = v;\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"/**\r\n     * Enables blending and sets the mode.\r\n     * @param MODE int\r\n     */    \r\n    public void setBlendMode(int MODE)\r\n    {\r\n        blend = true;\r\n        blendMode = MODE;\r\n    }","id":84859,"modified_method":"public void setDrawMode(int mode) {\r\n    pointSprites = false;\r\n    if (mode == POINTS) glMode = GL11.GL_POINTS;\r\n    else if (mode == POINT_SPRITES) {\r\n      glMode = GL11.GL_POINTS;\r\n      pointSprites = true;\r\n    }\r\n    else if (mode == LINES) glMode = GL11.GL_LINES;\r\n    else if (mode == LINE_STRIP) glMode = GL11.GL_LINE_STRIP;\r\n    else if (mode == LINE_LOOP) glMode = GL11.GL_LINE_LOOP;\r\n    else if (mode == TRIANGLES) glMode = GL11.GL_TRIANGLES; \r\n    else if (mode == TRIANGLE_FAN) glMode = GL11.GL_TRIANGLE_FAN;\r\n    else if (mode == TRIANGLE_STRIP) glMode = GL11.GL_TRIANGLE_STRIP;\r\n    else {\r\n      throw new RuntimeException(\"GLModel: Unknown draw mode\");\r\n    }\r\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"GLModelParameters() {\n    updateMode = STATIC;    \n    drawMode= POINTS;\n    pointSize = 1;\n    lineWidth = 1;\n  }","id":84860,"modified_method":"GLModelParameters() {\n    updateMode = STATIC;    \n    drawMode= POINTS;\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"GLModelParameters(GLModelParameters src) {\n    updateMode = src.updateMode;    \n    drawMode= src.drawMode;\n    pointSize = src.pointSize;\n    lineWidth = src.lineWidth;\n  }","id":84861,"modified_method":"GLModelParameters(GLModelParameters src) {\n    updateMode = src.updateMode;    \n    drawMode= src.drawMode;\n  }","commit_id":"25a6ff9e2e79a771d0f5e8e8c5af307d9c8be93c","url":"https://github.com/processing/processing"},{"original_method":"/**\n\t * Constructs a new interleaved VertexBufferObjectWithVAO.\n\t *\n\t * @param isStatic    whether the vertex data is static.\n\t * @param numVertices the maximum number of vertices\n\t * @param attributes  the {@link VertexAttributes}.\n\t */\n\tpublic VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttributes attributes) {\n\t\tthis.isStatic = isStatic;\n\t\tthis.attributes = attributes;\n\n\t\tbyteBuffer = BufferUtils.newUnsafeByteBuffer(this.attributes.vertexSize * numVertices);\n\t\tbuffer = byteBuffer.asFloatBuffer();\n\t\tbuffer.flip();\n\t\tbyteBuffer.flip();\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tusage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;\n\t}","id":84862,"modified_method":"/**\n\t * Constructs a new interleaved VertexBufferObjectWithVAO.\n\t *\n\t * @param isStatic    whether the vertex data is static.\n\t * @param numVertices the maximum number of vertices\n\t * @param attributes  the {@link VertexAttributes}.\n\t */\n\tpublic VertexBufferObjectWithVAO (boolean isStatic, int numVertices, VertexAttributes attributes) {\n\t\tthis.isStatic = isStatic;\n\t\tthis.attributes = attributes;\n\n\t\tbyteBuffer = BufferUtils.newUnsafeByteBuffer(this.attributes.vertexSize * numVertices);\n\t\tbuffer = byteBuffer.asFloatBuffer();\n\t\tbuffer.flip();\n\t\tbyteBuffer.flip();\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tusage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;\n\t\tcreateVAO();\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * Disposes of all resources this VertexBufferObject uses.\n\t */\n\t@Override\n\tpublic void dispose() {\n\t\tGL30 gl = Gdx.gl30;\n\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);\n\t\tgl.glDeleteBuffer(bufferHandle);\n\t\tbufferHandle = 0;\n\t\tBufferUtils.disposeUnsafeByteBuffer(byteBuffer);\n\n\t\tif (gl.glIsVertexArray(vaoHandle)) {\n\t\t\ttmpHandle.clear();\n\t\t\ttmpHandle.put(vaoHandle);\n\t\t\ttmpHandle.flip();\n\t\t\tgl.glDeleteVertexArrays(1, tmpHandle);\n\t\t}\n\t}","id":84863,"modified_method":"/**\n\t * Disposes of all resources this VertexBufferObject uses.\n\t */\n\t@Override\n\tpublic void dispose () {\n\t\tGL30 gl = Gdx.gl30;\n\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);\n\t\tgl.glDeleteBuffer(bufferHandle);\n\t\tbufferHandle = 0;\n\t\tBufferUtils.disposeUnsafeByteBuffer(byteBuffer);\n\t\tdeleteVAO();\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.\n\t */\n\t@Override\n\tpublic void invalidate() {\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tisDirty = true;\n\t\tvaoDirty = true;\n\t}","id":84864,"modified_method":"/**\n\t * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.\n\t */\n\t@Override\n\tpublic void invalidate () {\n\t\tbufferHandle = Gdx.gl30.glGenBuffer();\n\t\tcreateVAO();\n\t\tisDirty = true;\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void bind(ShaderProgram shader, int[] locations) {\n\t\tGL30 gl = Gdx.gl30;\n\t\tif (vaoDirty || !gl.glIsVertexArray(vaoHandle)) {\n\t\t\t//initialize the VAO with our vertex attributes and buffer:\n\t\t\ttmpHandle.clear();\n\t\t\tgl.glGenVertexArrays(1, tmpHandle);\n\t\t\tvaoHandle = tmpHandle.get(0);\n\t\t\tgl.glBindVertexArray(vaoHandle);\n\t\t\tvaoDirty = false;\n\n\t\t} else {\n\t\t\t//else simply bind the VAO.\n\t\t\tgl.glBindVertexArray(vaoHandle);\n\t\t}\n\n\t\tbindAttributes(shader, locations);\n\n\t\t//if our data has changed upload it:\n\t\tbindData(gl);\n\n\t\tisBound = true;\n\t}","id":84865,"modified_method":"@Override\n\tpublic void bind (ShaderProgram shader, int[] locations) {\n\t\tGL30 gl = Gdx.gl30;\n\n\t\tgl.glBindVertexArray(vaoHandle);\n\n\t\tbindAttributes(shader, locations);\n\n\t\t//if our data has changed upload it:\n\t\tbindData(gl);\n\n\t\tisBound = true;\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void bindAttributes(ShaderProgram shader, int[] locations) {\n\t\tfinal GL20 gl = Gdx.gl20;\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\n\t\tfinal int numAttributes = attributes.size();\n\t\tif (locations == null) {\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\n\t\t\t\tif (location < 0) continue;\n\t\t\t\tshader.enableVertexAttribute(location);\n\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\n\t\t\t\t\tattribute.offset);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\n\t\t\t\tfinal int location = locations[i];\n\t\t\t\tif (location < 0) continue;\n\t\t\t\tshader.enableVertexAttribute(location);\n\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\n\t\t\t\t\tattribute.offset);\n\t\t\t}\n\t\t}\n\t}","id":84866,"modified_method":"private void bindAttributes (ShaderProgram shader, int[] locations) {\n\t\tboolean stillValid = this.cachedLocations.size != 0;\n\t\tfinal int numAttributes = attributes.size();\n\n\t\tif (stillValid) {\n\t\t\tif (locations == null) {\n\t\t\t\tfor (int i = 0; stillValid && i < numAttributes; i++) {\n\t\t\t\t\tVertexAttribute attribute = attributes.get(i);\n\t\t\t\t\tint location = shader.getAttributeLocation(attribute.alias);\n\t\t\t\t\tstillValid = location == this.cachedLocations.get(i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstillValid = locations.length == this.cachedLocations.size;\n\t\t\t\tfor (int i = 0; stillValid && i < numAttributes; i++) {\n\t\t\t\t\tstillValid = locations[i] == this.cachedLocations.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!stillValid) {\n\t\t\tGdx.gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\n\t\t\tunbindAttributes(shader);\n\t\t\tthis.cachedLocations.clear();\n\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\n\t\t\t\tVertexAttribute attribute = attributes.get(i);\n\t\t\t\tif (locations == null) {\n\t\t\t\t\tthis.cachedLocations.add(shader.getAttributeLocation(attribute.alias));\n\t\t\t\t} else {\n\t\t\t\t\tthis.cachedLocations.add(locations[i]);\n\t\t\t\t}\n\n\t\t\t\tint location = this.cachedLocations.get(i);\n\t\t\t\tif (location < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tshader.enableVertexAttribute(location);\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize, attribute.offset);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void bindAttributes(ShaderProgram shader, int[] locations) {\n\t\tfinal GL20 gl = Gdx.gl20;\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\n\t\tfinal int numAttributes = attributes.size();\n\t\tif (locations == null) {\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\n\t\t\t\tif (location < 0) continue;\n\t\t\t\tshader.enableVertexAttribute(location);\n\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\n\t\t\t\t\t\tattribute.offset);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\n\t\t\t\tfinal int location = locations[i];\n\t\t\t\tif (location < 0) continue;\n\t\t\t\tshader.enableVertexAttribute(location);\n\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\n\t\t\t\t\t\tattribute.offset);\n\t\t\t}\n\t\t}\n\t}","id":84867,"modified_method":"private void bindAttributes (ShaderProgram shader, int[] locations) {\n\t\tboolean stillValid = this.cachedLocations.size != 0;\n\t\tfinal int numAttributes = attributes.size();\n\n\t\tif (stillValid) {\n\t\t\tif (locations == null) {\n\t\t\t\tfor (int i = 0; stillValid && i < numAttributes; i++) {\n\t\t\t\t\tVertexAttribute attribute = attributes.get(i);\n\t\t\t\t\tint location = shader.getAttributeLocation(attribute.alias);\n\t\t\t\t\tstillValid = location == this.cachedLocations.get(i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstillValid = locations.length == this.cachedLocations.size;\n\t\t\t\tfor (int i = 0; stillValid && i < numAttributes; i++) {\n\t\t\t\t\tstillValid = locations[i] == this.cachedLocations.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!stillValid) {\n\t\t\tGdx.gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\n\t\t\tunbindAttributes(shader);\n\t\t\tthis.cachedLocations.clear();\n\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\n\t\t\t\tVertexAttribute attribute = attributes.get(i);\n\t\t\t\tif (locations == null) {\n\t\t\t\t\tthis.cachedLocations.add(shader.getAttributeLocation(attribute.alias));\n\t\t\t\t} else {\n\t\t\t\t\tthis.cachedLocations.add(locations[i]);\n\t\t\t\t}\n\n\t\t\t\tint location = this.cachedLocations.get(i);\n\t\t\t\tif (location < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tshader.enableVertexAttribute(location);\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize, attribute.offset);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * Disposes of all resources this VertexBufferObject uses.\n\t */\n\t@Override\n\tpublic void dispose() {\n\t\tGL30 gl = Gdx.gl30;\n\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);\n\t\tgl.glDeleteBuffer(bufferHandle);\n\t\tbufferHandle = 0;\n\n\t\tif (gl.glIsVertexArray(vaoHandle)) {\n\t\t\ttmpHandle.clear();\n\t\t\ttmpHandle.put(vaoHandle);\n\t\t\ttmpHandle.flip();\n\t\t\tgl.glDeleteVertexArrays(1, tmpHandle);\n\t\t}\n\t}","id":84868,"modified_method":"/**\n\t * Disposes of all resources this VertexBufferObject uses.\n\t */\n\t@Override\n\tpublic void dispose () {\n\t\tGL30 gl = Gdx.gl30;\n\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);\n\t\tgl.glDeleteBuffer(bufferHandle);\n\t\tbufferHandle = 0;\n\t\tdeleteVAO();\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * Constructs a new interleaved VertexBufferObjectWithVAO.\n\t *\n\t * @param isStatic    whether the vertex data is static.\n\t * @param numVertices the maximum number of vertices\n\t * @param attributes  the {@link VertexAttributes}.\n\t */\n\tpublic VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttributes attributes) {\n\t\tthis.isStatic = isStatic;\n\t\tthis.attributes = attributes;\n\n\t\tbuffer = BufferUtils.newFloatBuffer(this.attributes.vertexSize / 4 * numVertices);\n\t\tbuffer.flip();\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tusage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;\n\t}","id":84869,"modified_method":"/**\n\t * Constructs a new interleaved VertexBufferObjectWithVAO.\n\t *\n\t * @param isStatic    whether the vertex data is static.\n\t * @param numVertices the maximum number of vertices\n\t * @param attributes  the {@link VertexAttributes}.\n\t */\n\tpublic VertexBufferObjectWithVAO (boolean isStatic, int numVertices, VertexAttributes attributes) {\n\t\tthis.isStatic = isStatic;\n\t\tthis.attributes = attributes;\n\n\t\tbuffer = BufferUtils.newFloatBuffer(this.attributes.vertexSize / 4 * numVertices);\n\t\tbuffer.flip();\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tusage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;\n\t\tcreateVAO();\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.\n\t */\n\t@Override\n\tpublic void invalidate() {\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tisDirty = true;\n\t\tvaoDirty = true;\n\t}","id":84870,"modified_method":"/**\n\t * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.\n\t */\n\t@Override\n\tpublic void invalidate () {\n\t\tbufferHandle = Gdx.gl20.glGenBuffer();\n\t\tcreateVAO();\n\t\tisDirty = true;\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void bind(ShaderProgram shader, int[] locations) {\n\t\tGL30 gl = Gdx.gl30;\n\t\tif (vaoDirty || !gl.glIsVertexArray(vaoHandle)) {\n\t\t\ttmpHandle.clear();\n\t\t\tgl.glGenVertexArrays(1, tmpHandle);\n\t\t\tvaoHandle = tmpHandle.get(0);\n\t\t\tgl.glBindVertexArray(vaoHandle);\n\n\t\t\t//initialize the VAO with our vertex attributes and buffer:\n\t\t\tbindAttributes(shader, locations);\n\t\t\tvaoDirty = false;\n\n\t\t} else {\n\t\t\t//else simply bind the VAO.\n\t\t\tgl.glBindVertexArray(vaoHandle);\n\t\t}\n\t\t//if our data has changed upload it:\n\t\tbindData(gl);\n\n\t\tisBound = true;\n\t}","id":84871,"modified_method":"@Override\n\tpublic void bind (ShaderProgram shader, int[] locations) {\n\t\tGL30 gl = Gdx.gl30;\n\n\t\tgl.glBindVertexArray(vaoHandle);\n\n\t\tbindAttributes(shader, locations);\n\n\t\t//if our data has changed upload it:\n\t\tbindData(gl);\n\n\t\tisBound = true;\n\t}","commit_id":"c4fd69ebaad3c6182251bbd9d2c899be30ac15b7","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        if ( scriptEngineManager == null )\n        {\n            out.println( \"Scripting not available, make sure javax.script.* is available on \" +\n            \t\t\"the classpath in the JVM the shell server runs in\" );\n            return null;\n        }\n        \n        String javascriptCode = parser.getLineWithoutApp();\n        javascriptCode = includeImports( javascriptCode );\n        Object scriptEngine = scriptEngineManager.getClass().getMethod( \"getEngineByName\", String.class ).invoke( scriptEngineManager, \"javascript\" );\n        addToContext( scriptEngine,\n                \"db\", getServer().getDb(),\n                \"out\", out,\n                \"current\", getCurrent( session ).asPropertyContainer() );\n        Object result = scriptEngine.getClass().getMethod( \"eval\", String.class ).invoke( scriptEngine, javascriptCode );\n        if ( result != null )\n        {\n            out.println( result.toString() );\n        }\n        return null;\n    }","id":84872,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        scripting = scripting != null ? scripting : new ScriptEngineViaReflection( getServer() );\n        String javascriptCode = parser.getLineWithoutApp();\n        javascriptCode = decorateWithImports( javascriptCode, STANDARD_EVAL_IMPORTS );\n        Object scriptEngine = scripting.getJavascriptEngine();\n        scripting.addDefaultContext( scriptEngine, session, out );\n        Object result = scripting.interpret( scriptEngine, javascriptCode );\n        if ( result != null )\n        {\n            out.println( result.toString() );\n        }\n        return null;\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected static RelationshipExpander toExpander( GraphDatabaseService db, Direction defaultDirection,\n            Map<String, Object> filterMap, boolean caseInsensitiveFilters, boolean looseFilters ) throws ShellException\n    {\n        defaultDirection = defaultDirection != null ? defaultDirection : Direction.BOTH;\n        Expander expander = Traversal.emptyExpander();\n        boolean addedSomething = false;\n        for ( RelationshipType type : db.getRelationshipTypes() )\n        {\n            Direction direction = null;\n            if ( filterMap == null || filterMap.isEmpty() )\n            {\n                direction = defaultDirection;\n            }\n            else\n            {\n                for ( Map.Entry<String, Object> entry : filterMap.entrySet() )\n                {\n                    if ( matches( newPattern( entry.getKey(), caseInsensitiveFilters ),\n                        type.name(), caseInsensitiveFilters, looseFilters ) )\n                    {\n                        direction = getDirection( entry.getValue() != null ? entry.getValue().toString() : null, defaultDirection );\n                        break;\n                    }\n                }\n            }\n    \n            // It matches\n            if ( direction != null )\n            {\n                expander = expander.add( type, direction );\n                addedSomething = true;\n            }\n        }\n        \n        if ( !filterMap.isEmpty() && !addedSomething )\n        {\n            return null;\n        }\n        return expander;\n    }","id":84873,"modified_method":"protected static RelationshipExpander toExpander( GraphDatabaseService db, Direction defaultDirection,\n            Map<String, Object> relationshipTypes, boolean caseInsensitiveFilters, boolean looseFilters ) throws ShellException\n    {\n        defaultDirection = defaultDirection != null ? defaultDirection : Direction.BOTH;\n        Expander expander = Traversal.emptyExpander();\n        boolean addedSomething = false;\n        for ( RelationshipType type : db.getRelationshipTypes() )\n        {\n            Direction direction = null;\n            if ( relationshipTypes == null || relationshipTypes.isEmpty() )\n            {\n                direction = defaultDirection;\n            }\n            else\n            {\n                for ( Map.Entry<String, Object> entry : relationshipTypes.entrySet() )\n                {\n                    if ( matches( newPattern( entry.getKey(), caseInsensitiveFilters ),\n                        type.name(), caseInsensitiveFilters, looseFilters ) )\n                    {\n                        direction = getDirection( entry.getValue() != null ? entry.getValue().toString() : null, defaultDirection );\n                        break;\n                    }\n                }\n            }\n    \n            // It matches\n            if ( direction != null )\n            {\n                expander = expander.add( type, direction );\n                addedSomething = true;\n            }\n        }\n        \n        if ( !relationshipTypes.isEmpty() && !addedSomething )\n        {\n            return null;\n        }\n        return expander;\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static String withArrows( Relationship relationship, String displayName, Node leftNode )\n    {\n        if ( relationship.getStartNode().equals( leftNode ) )\n        {\n            return \" --\" + displayName + \"-> \";\n        }\n        else if ( relationship.getEndNode().equals( leftNode ) )\n        {\n            return \" <-\" + displayName + \"-- \";\n        }\n        throw new IllegalArgumentException( leftNode + \" is neither start nor end node to \" + relationship );\n    }","id":84874,"modified_method":"public static String withArrows( Relationship relationship, String displayName, Node leftNode )\n    {\n        if ( relationship.getStartNode().equals( leftNode ) )\n        {\n            return \" -\" + displayName + \"-> \";\n        }\n        else if ( relationship.getEndNode().equals( leftNode ) )\n        {\n            return \" <-\" + displayName + \"- \";\n        }\n        throw new IllegalArgumentException( leftNode + \" is neither start nor end node to \" + relationship );\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected static <T extends Enum<T>> Enum<T> parseEnum(\n        Class<T> enumClass, String name, Enum<T> defaultValue  )\n    {\n        if ( name == null )\n        {\n            return defaultValue;\n        }\n\n        name = name.toLowerCase();\n        for ( T enumConstant : enumClass.getEnumConstants() )\n        {\n            if ( enumConstant.name().equalsIgnoreCase( name ) )\n            {\n                return enumConstant;\n            }\n        }\n        for ( T enumConstant : enumClass.getEnumConstants() )\n        {\n            if ( enumConstant.name().toLowerCase().startsWith( name ) )\n            {\n                return enumConstant;\n            }\n        }\n        throw new IllegalArgumentException( \"No '\" + name + \"' or '\" +\n            name + \".*' in \" + enumClass );\n    }","id":84875,"modified_method":"protected static <T extends Enum<T>> T parseEnum(\n        Class<T> enumClass, String name, T defaultValue, Pair<String, T>... additionalPairs )\n    {\n        if ( name == null )\n        {\n            return defaultValue;\n        }\n\n        name = name.toLowerCase();\n        for ( T enumConstant : enumClass.getEnumConstants() )\n        {\n            if ( enumConstant.name().equalsIgnoreCase( name ) )\n            {\n                return enumConstant;\n            }\n        }\n        for ( T enumConstant : enumClass.getEnumConstants() )\n        {\n            if ( enumConstant.name().toLowerCase().startsWith( name ) )\n            {\n                return enumConstant;\n            }\n        }\n        \n        for ( Pair<String, T> additional : additionalPairs )\n        {\n            if ( additional.first().equalsIgnoreCase( name ) )\n            {\n                return additional.other();\n            }\n        }\n        for ( Pair<String, T> additional : additionalPairs )\n        {\n            if ( additional.first().toLowerCase().startsWith( name ) )\n            {\n                return additional.other();\n            }\n        }\n        \n        throw new IllegalArgumentException( \"No '\" + name + \"' or '\" +\n            name + \".*' in \" + enumClass );\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean verbose, boolean quiet, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters, boolean brief )\n        throws RemoteException\n    {\n        int longestKey = findLongestKey( thing );\n        int count = 0;\n        for ( String key : sortKeys( thing.getPropertyKeys() ) )\n        {\n            boolean matches = filterMap == null || filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            if ( !matches )\n            {\n                for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n                {\n                    if ( matches( newPattern( filter.getKey(),\n                        caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                        looseFilters ) )\n                    {\n                        String filterValue = filter.getValue() != null ?\n                            filter.getValue().toString() : null;\n                        if ( matches( newPattern( filterValue,\n                            caseInsensitiveFilters ), value.toString(),\n                            caseInsensitiveFilters, looseFilters ) )\n                        {\n                            matches = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n\n            count++;\n            if ( !brief )\n            {\n                StringBuilder builder = new StringBuilder();\n                builder.append( \"*\" + key );\n                if ( !quiet )\n                {\n                    builder.append( multiply( \" \", longestKey - key.length() + 1 ) );\n                    builder.append( \"=\" + format( value, true ) );\n                    if ( verbose )\n                    {\n                        builder.append( \" (\" + getNiceType( value ) + \")\" );\n                    }\n                }\n                out.println( builder.toString() );\n            }\n        }\n        if ( brief )\n        {\n            out.println( \"Property count: \" + count );\n        }\n    }","id":84876,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean verbose, boolean quiet, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters, boolean brief )\n        throws RemoteException\n    {\n        int longestKey = findLongestKey( thing );\n        int count = 0;\n        for ( String key : sortKeys( thing.getPropertyKeys() ) )\n        {\n            Object value = thing.getProperty( key );\n            if ( !filterMatches( filterMap, caseInsensitiveFilters, looseFilters, key, value ) )\n            {\n                continue;\n            }\n\n            count++;\n            if ( !brief )\n            {\n                StringBuilder builder = new StringBuilder();\n                builder.append( \"*\" + key );\n                if ( !quiet )\n                {\n                    builder.append( multiply( \" \", longestKey - key.length() + 1 ) );\n                    builder.append( \"=\" + format( value, true ) );\n                    if ( verbose )\n                    {\n                        builder.append( \" (\" + getNiceType( value ) + \")\" );\n                    }\n                }\n                out.println( builder.toString() );\n            }\n        }\n        if ( brief )\n        {\n            out.println( \"Property count: \" + count );\n        }\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException, RemoteException\n    {\n        assertCurrentIsNode( session );\n\n        Node node = this.getCurrent( session ).asNode();\n        boolean caseInsensitiveFilters = parser.options().containsKey( \"i\" );\n        boolean looseFilters = parser.options().containsKey( \"l\" );\n        Object[] relationshipTypes = parseRelationshipTypes( parser, out,\n            caseInsensitiveFilters, looseFilters );\n        if ( relationshipTypes.length == 0 )\n        {\n            out.println( \"No matching relationship types\" );\n            return null;\n        }\n\n        StopEvaluator stopEvaluator = parseStopEvaluator( parser );\n        ReturnableEvaluator returnableEvaluator =\n            parseReturnableEvaluator( parser );\n        Order order = parseOrder( parser );\n\n        String filterString = parser.options().get( \"f\" );\n        Map<String, Object> filterMap = filterString != null ?\n            parseFilter( filterString, out ) : null;\n        String commandToRun = parser.options().get( \"c\" );\n        Collection<String> commandsToRun = new ArrayList<String>();\n        if ( commandToRun != null )\n        {\n            commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n        }\n        for ( Node traversedNode : node.traverse( order, stopEvaluator,\n            returnableEvaluator, relationshipTypes ) )\n        {\n            boolean hit = false;\n            if ( filterMap == null )\n            {\n                hit = true;\n            }\n            else\n            {\n                Map<String, Boolean> matchPerFilterKey =\n                    new HashMap<String, Boolean>();\n                for ( String key : traversedNode.getPropertyKeys() )\n                {\n                    for ( Map.Entry<String, Object> filterEntry :\n                        filterMap.entrySet() )\n                    {\n                        String filterKey = filterEntry.getKey();\n                        if ( matchPerFilterKey.containsKey( filterKey ) )\n                        {\n                            continue;\n                        }\n\n                        if ( matches( newPattern( filterKey,\n                            caseInsensitiveFilters ), key,\n                            caseInsensitiveFilters, looseFilters ) )\n                        {\n                            Object value = traversedNode.getProperty( key );\n                            String filterPattern =\n                                filterEntry.getValue() != null ?\n                                filterEntry.getValue().toString() : null;\n                            if ( matches( newPattern( filterPattern,\n                                caseInsensitiveFilters ), value.toString(),\n                                caseInsensitiveFilters, looseFilters ) )\n                            {\n                                matchPerFilterKey.put( filterKey, true );\n                            }\n                        }\n                    }\n                }\n\n                if ( matchPerFilterKey.size() == filterMap.size() )\n                {\n                    hit = true;\n                }\n            }\n            if ( hit )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, true, NodeOrRelationship.wrap( traversedNode ),\n                        getServer(), session, out );\n            }\n        }\n        return null;\n    }","id":84877,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException, RemoteException\n    {\n        assertCurrentIsNode( session );\n\n        Node node = this.getCurrent( session ).asNode();\n        boolean caseInsensitiveFilters = parser.options().containsKey( \"i\" );\n        boolean looseFilters = parser.options().containsKey( \"l\" );\n        boolean quiet = parser.options().containsKey( \"q\" );\n        \n        // Order\n        TraversalDescription description = Traversal.description();\n        String order = parser.options().get( \"o\" );\n        if ( order != null )\n        {\n            description = description.order( parseOrder( order ) );\n        }\n        \n        // Relationship types / expander\n        String relationshipTypes = parser.options().get( \"r\" );\n        if ( relationshipTypes != null )\n        {\n            Map<String, Object> types = parseFilter( relationshipTypes, out );\n            description = description.expand( toExpander( getServer().getDb(), null, types,\n                    caseInsensitiveFilters, looseFilters ) );\n        }\n        \n        // Uniqueness\n        String uniqueness = parser.options().get( \"u\" );\n        if ( uniqueness != null )\n        {\n            description = description.uniqueness( parseUniqueness( uniqueness ) );\n        }\n        \n        // Depth limit\n        String depthLimit = parser.options().get( \"d\" );\n        if ( depthLimit != null )\n        {\n            description = description.prune( pruneAfterDepth( parseInt( depthLimit ) ) );\n        }\n        \n        // Custom evaluator\n        String evaluator = parser.options().get( \"e\" );\n        if ( evaluator != null )\n        {\n            description = description.evaluator( parseEvaluator( evaluator ) );\n        }\n\n        String filterString = parser.options().get( \"f\" );\n        Map<String, Object> filterMap = filterString != null ? parseFilter( filterString, out ) : null;\n        String commandToRun = parser.options().get( \"c\" );\n        Collection<String> commandsToRun = new ArrayList<String>();\n        if ( commandToRun != null )\n        {\n            commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n        }\n        for ( Path path : description.traverse( node ) )\n        {\n            boolean hit = false;\n            if ( filterMap == null )\n            {\n                hit = true;\n            }\n            else\n            {\n                Node endNode = path.endNode();\n                Map<String, Boolean> matchPerFilterKey = new HashMap<String, Boolean>();\n                for ( String key : endNode.getPropertyKeys() )\n                {\n                    for ( Map.Entry<String, Object> filterEntry :\n                        filterMap.entrySet() )\n                    {\n                        String filterKey = filterEntry.getKey();\n                        if ( matchPerFilterKey.containsKey( filterKey ) )\n                        {\n                            continue;\n                        }\n\n                        if ( matches( newPattern( filterKey,\n                            caseInsensitiveFilters ), key,\n                            caseInsensitiveFilters, looseFilters ) )\n                        {\n                            Object value = endNode.getProperty( key );\n                            String filterPattern =\n                                filterEntry.getValue() != null ?\n                                filterEntry.getValue().toString() : null;\n                            if ( matches( newPattern( filterPattern,\n                                caseInsensitiveFilters ), value.toString(),\n                                caseInsensitiveFilters, looseFilters ) )\n                            {\n                                matchPerFilterKey.put( filterKey, true );\n                            }\n                        }\n                    }\n                }\n\n                if ( matchPerFilterKey.size() == filterMap.size() )\n                {\n                    hit = true;\n                }\n            }\n            if ( hit )\n            {\n                printPath( path, quiet, session, out );\n            }\n        }\n        return null;\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new command which can traverse the graph.\n     */\n    public Trav()\n    {\n        super();\n        this.addOptionDefinition( \"o\", new OptionDefinition( OptionValueType.MUST,\n            \"The traversal order [BREADTH_FIRST/DEPTH_FIRST/breadth/depth]\" ) );\n        this.addOptionDefinition( \"r\", new OptionDefinition( OptionValueType.MUST,\n            \"The relationship type(s) expressed as a JSON string \" +\n            \"(supports regex matching of the types) f.ex. \" +\n            \"\\\"MY_REL_TYPE:out,.*_HAS_.*:both\\\". Matching is case-insensitive.\" ) );\n        this.addOptionDefinition( \"f\", new OptionDefinition( OptionValueType.MUST,\n            \"Filters node property keys/values. Supplied either as a single \" +\n            \"value or as a JSON string where both keys and values can \" +\n            \"contain regex. Starting/ending {} brackets are optional. Examples:\\n\" +\n            \"\\\"username\\\"\\n\" +\n            \"   nodes which has property 'username' gets listed\\n\" +\n            \"\\\".*name: ma.*, age: ''\\\"\\n\" +\n            \"   nodes which has any key matching '.*name' where the \" +\n            \"property value\\n\" +\n            \"   for that key matches 'ma.*' AND has the 'age' property gets listed\" ) );\n        this.addOptionDefinition( \"i\", new OptionDefinition( OptionValueType.NONE,\n            \"Filters are case-insensitive (case-sensitive by default)\" ) );\n        this.addOptionDefinition( \"l\", new OptionDefinition( OptionValueType.NONE,\n            \"Filters matches more loosely, i.e. it's considered a match if \" +\n            \"just a part of a value matches the pattern, not necessarily \" +\n            \"the whole value\" ) );\n        this.addOptionDefinition( \"c\", OPTION_DEF_FOR_C );\n    }","id":84878,"modified_method":"/**\n     * Constructs a new command which can traverse the graph.\n     */\n    public Trav()\n    {\n        this.addOptionDefinition( \"o\", new OptionDefinition( OptionValueType.MUST,\n            \"The traversal order [BREADTH_FIRST/DEPTH_FIRST/breadth/depth]\" ) );\n        this.addOptionDefinition( \"r\", new OptionDefinition( OptionValueType.MUST,\n            \"The relationship type(s) expressed as a JSON string \" +\n            \"(supports regex matching of the types) f.ex. \" +\n            \"\\\"MY_REL_TYPE:out,.*_HAS_.*:both\\\". Matching is case-insensitive.\" ) );\n        this.addOptionDefinition( \"f\", new OptionDefinition( OptionValueType.MUST,\n            \"Filters node property keys/values. Supplied either as a single \" +\n            \"value or as a JSON string where both keys and values can \" +\n            \"contain regex. Starting/ending {} brackets are optional. Examples:\\n\" +\n            \"\\\"username\\\"\\n\" +\n            \"   nodes which has property 'username' gets listed\\n\" +\n            \"\\\".*name: ma.*, age: ''\\\"\\n\" +\n            \"   nodes which has any key matching '.*name' where the \" +\n            \"property value\\n\" +\n            \"   for that key matches 'ma.*' AND has the 'age' property gets listed\" ) );\n        this.addOptionDefinition( \"i\", new OptionDefinition( OptionValueType.NONE,\n            \"Filters are case-insensitive (case-sensitive by default)\" ) );\n        this.addOptionDefinition( \"l\", new OptionDefinition( OptionValueType.NONE,\n            \"Filters matches more loosely, i.e. it's considered a match if \" +\n            \"just a part of a value matches the pattern, not necessarily \" +\n            \"the whole value\" ) );\n        this.addOptionDefinition( \"c\", OPTION_DEF_FOR_C );\n        this.addOptionDefinition( \"d\", new OptionDefinition( OptionValueType.MUST,\n                \"Depth limit\" ) );\n        this.addOptionDefinition( \"e\", new OptionDefinition( OptionValueType.MUST,\n                \"Custom javascript evaluator\" ) );\n    }","commit_id":"5c7fc5ae0c3dc4e6444332c1dd9eea5b8e244d95","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Future<?> startServerInPooledThread() {\n    if (!started.compareAndSet(false, true)) {\n      return null;\n    }\n\n    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          BuiltInServer mainServer = StartupUtil.getServer();\n          LOG.assertTrue(mainServer != null);\n          server = BuiltInServer.start(mainServer.getEventLoopGroup(), false, getDefaultPort(), PORTS_COUNT, true, null);\n          bindCustomPorts(server);\n        }\n        catch (Throwable e) {\n          LOG.info(e);\n          NOTIFICATION_GROUP.getValue().createNotification(\"Cannot start internal HTTP server. Git integration, JavaScript debugger and LiveEdit may operate with errors. \" +\n                                                           \"Please check your firewall settings and restart \" + ApplicationNamesInfo.getInstance().getFullProductName(),\n                                                           NotificationType.ERROR).notify(null);\n          return;\n        }\n\n        LOG.info(\"built-in server started, port \" + server.getPort());\n\n        Disposer.register(ApplicationManager.getApplication(), server);\n        ShutDownTracker.getInstance().registerShutdownTask(new Runnable() {\n          @Override\n          public void run() {\n            if (!Disposer.isDisposed(server)) {\n              // something went wrong\n              Disposer.dispose(server);\n            }\n          }\n        });\n      }\n    });\n  }","id":84879,"modified_method":"private Future<?> startServerInPooledThread() {\n    if (!started.compareAndSet(false, true)) {\n      return null;\n    }\n\n    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          BuiltInServer mainServer = StartupUtil.getServer();\n          if (mainServer == null && ApplicationManager.getApplication().isUnitTestMode()) {\n            server = BuiltInServer.start(1, getDefaultPort(), PORTS_COUNT, false, null);\n          }\n          else {\n            LOG.assertTrue(mainServer != null);\n            server = BuiltInServer.start(mainServer.getEventLoopGroup(), false, getDefaultPort(), PORTS_COUNT, true, null);\n          }\n          bindCustomPorts(server);\n        }\n        catch (Throwable e) {\n          LOG.info(e);\n          NOTIFICATION_GROUP.getValue().createNotification(\"Cannot start internal HTTP server. Git integration, JavaScript debugger and LiveEdit may operate with errors. \" +\n                                                           \"Please check your firewall settings and restart \" + ApplicationNamesInfo.getInstance().getFullProductName(),\n                                                           NotificationType.ERROR).notify(null);\n          return;\n        }\n\n        LOG.info(\"built-in server started, port \" + server.getPort());\n\n        Disposer.register(ApplicationManager.getApplication(), server);\n        ShutDownTracker.getInstance().registerShutdownTask(new Runnable() {\n          @Override\n          public void run() {\n            if (!Disposer.isDisposed(server)) {\n              // something went wrong\n              Disposer.dispose(server);\n            }\n          }\n        });\n      }\n    });\n  }","commit_id":"d8f9879bd4031965e74d9effe5dec7c21532d693","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public synchronized static BuiltInServer getServer() {\n    return ourLock.getServer();\n  }","id":84880,"modified_method":"@Nullable\n  public synchronized static BuiltInServer getServer() {\n    return ourLock == null ? null : ourLock.getServer();\n  }","commit_id":"d8f9879bd4031965e74d9effe5dec7c21532d693","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void searchInRecords() {\r\n\t\tORecordId rid = new ORecordId();\r\n\t\tORecordInternal<?> record;\r\n\t\tfor (String rec : compiledFilter.getTargetRecords()) {\r\n\t\t\trid.fromString(rec);\r\n\t\t\trecord = database.load(rid);\r\n\t\t\tforeach(record);\r\n\t\t}\r\n\t}","id":84881,"modified_method":"private void searchInRecords() {\r\n\t\tORecordId rid = new ORecordId();\r\n\t\tORecordInternal<?> record;\r\n\t\tfor (String rec : compiledFilter.getTargetRecords()) {\r\n\t\t\trid.fromString(rec);\r\n\t\t\trecord = database.load(rid);\r\n\t\t\tfinal boolean continueResultParsing = foreach(record);\r\n\t\t\tif (!continueResultParsing)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}","commit_id":"013f33654e0831517729d37dc1cc4924575358f5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void searchInClasses() {\r\n\t\tfinal int[] clusterIds;\r\n\t\tfinal OClass cls = compiledFilter.getTargetClasses().keySet().iterator().next();\r\n\r\n\t\tdatabase.checkSecurity(ODatabaseSecurityResources.CLASS, ORole.PERMISSION_READ, cls.getName());\r\n\r\n\t\tclusterIds = cls.getPolymorphicClusterIds();\r\n\r\n\t\t// CHECK PERMISSION TO ACCESS TO ALL THE CONFIGURED CLUSTERS\r\n\t\tfor (int clusterId : clusterIds)\r\n\t\t\tdatabase.checkSecurity(ODatabaseSecurityResources.CLUSTER, ORole.PERMISSION_READ, database.getClusterNameById(clusterId));\r\n\r\n\t\tfinal List<ORecord<?>> resultSet = new ArrayList<ORecord<?>>();\r\n\t\tif (searchForIndexes(resultSet, cls)) {\r\n\t\t\tOProfiler.getInstance().updateCounter(\"Query.indexUsage\", 1);\r\n\r\n\t\t\t// FOUND USING INDEXES\r\n\t\t\tfor (ORecord<?> record : resultSet) {\r\n\t\t\t\tif (filter((ORecordInternal<?>) record))\r\n\t\t\t\t\taddResult(record);\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\t// NO INDEXES: SCAN THE ENTIRE CLUSTER\r\n\t\t\tscanEntireClusters(clusterIds);\r\n\t}","id":84882,"modified_method":"private void searchInClasses() {\r\n\t\tfinal int[] clusterIds;\r\n\t\tfinal OClass cls = compiledFilter.getTargetClasses().keySet().iterator().next();\r\n\r\n\t\tdatabase.checkSecurity(ODatabaseSecurityResources.CLASS, ORole.PERMISSION_READ, cls.getName());\r\n\r\n\t\tclusterIds = cls.getPolymorphicClusterIds();\r\n\r\n\t\t// CHECK PERMISSION TO ACCESS TO ALL THE CONFIGURED CLUSTERS\r\n\t\tfor (int clusterId : clusterIds)\r\n\t\t\tdatabase.checkSecurity(ODatabaseSecurityResources.CLUSTER, ORole.PERMISSION_READ, database.getClusterNameById(clusterId));\r\n\r\n\t\tfinal List<ORecord<?>> resultSet = new ArrayList<ORecord<?>>();\r\n\t\tif (searchForIndexes(resultSet, cls)) {\r\n\t\t\tOProfiler.getInstance().updateCounter(\"Query.indexUsage\", 1);\r\n\r\n\t\t\t// FOUND USING INDEXES\r\n\t\t\tfor (ORecord<?> record : resultSet) {\r\n\t\t\t\tif (filter((ORecordInternal<?>) record)) {\r\n\t\t\t\t\tfinal boolean continueResultParsing = addResult(record);\r\n\t\t\t\t\tif (!continueResultParsing)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\t// NO INDEXES: SCAN THE ENTIRE CLUSTER\r\n\t\t\tscanEntireClusters(clusterIds);\r\n\t}","commit_id":"013f33654e0831517729d37dc1cc4924575358f5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void searchInIndex() {\r\n\t\tfinal OIndex<Object> index = (OIndex<Object>) database.getMetadata().getIndexManager()\r\n\t\t\t\t.getIndex(compiledFilter.getTargetIndex());\r\n\t\tif (index == null)\r\n\t\t\tthrow new OCommandExecutionException(\"Target index '\" + compiledFilter.getTargetIndex() + \"' not found\");\r\n\r\n\t\tif (compiledFilter.getRootCondition() != null) {\r\n\t\t\tif (!\"KEY\".equalsIgnoreCase(compiledFilter.getRootCondition().getLeft().toString()))\r\n\t\t\t\tthrow new OCommandExecutionException(\"'Key' field is required for queries against indexes\");\r\n\r\n\t\t\tfinal OQueryOperator indexOperator = compiledFilter.getRootCondition().getOperator();\r\n\t\t\tif (indexOperator instanceof OQueryOperatorBetween) {\r\n\t\t\t\tfinal Object[] values = (Object[]) compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesBetween(OSQLHelper.getValue(values[0]),\r\n\t\t\t\t\t\tOSQLHelper.getValue(values[2]));\r\n\r\n\t\t\t\tfor (final OIdentifiable r : entries)\r\n\t\t\t\t\taddResult(r);\r\n\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMajor) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMajor(OSQLHelper.getValue(value), false);\r\n\r\n\t\t\t\tfor (final ODocument document : entries)\r\n\t\t\t\t\taddResult(document);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMajorEquals) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMajor(OSQLHelper.getValue(value), true);\r\n\r\n\t\t\t\tfor (final ODocument document : entries)\r\n\t\t\t\t\taddResult(document);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMinor) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMinor(OSQLHelper.getValue(value), false);\r\n\r\n\t\t\t\tfor (final ODocument document : entries)\r\n\t\t\t\t\taddResult(document);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMinorEquals) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMinor(OSQLHelper.getValue(value), true);\r\n\r\n\t\t\t\tfor (final ODocument document : entries)\r\n\t\t\t\t\taddResult(document);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorIn) {\r\n\t\t\t\tfinal List<Object> origValues = (List<Object>) compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal List<Object> values = new ArrayList<Object>(origValues.size());\r\n\t\t\t\tfor (Object val : origValues) {\r\n\t\t\t\t\tval = OSQLHelper.getValue(val);\r\n\t\t\t\t\tval = OType.convert(val, index.getKeyType().getDefaultJavaType());\r\n\t\t\t\t\tvalues.add(val);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntries(values);\r\n\r\n\t\t\t\tfor (final ODocument document : entries)\r\n\t\t\t\t\taddResult(document);\r\n\t\t\t} else {\r\n\t\t\t\tfinal Object right = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Object keyValue = OSQLHelper.getValue(right);\r\n\r\n\t\t\t\tfinal Object res = index.get(keyValue);\r\n\r\n\t\t\t\tif (res != null)\r\n\t\t\t\t\tif (res instanceof Collection<?>)\r\n\t\t\t\t\t\t// MULTI VALUES INDEX\r\n\t\t\t\t\t\tfor (final OIdentifiable r : (Collection<OIdentifiable>) res)\r\n\t\t\t\t\t\t\taddResult(createIndexEntryAsDocument(keyValue, r.getIdentity()));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t// SINGLE VALUE INDEX\r\n\t\t\t\t\t\taddResult(createIndexEntryAsDocument(keyValue, ((OIdentifiable) res).getIdentity()));\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// ADD ALL THE ITEMS AS RESULT\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = index.iterator(); it.hasNext();) {\r\n\t\t\t\tfinal Entry<Object, Object> current = it.next();\r\n\r\n\t\t\t\tif (current.getValue() instanceof Collection<?>)\r\n\t\t\t\t\tfor (Iterator<OIdentifiable> collIt = ((ORecordLazySet) current.getValue()).rawIterator(); collIt.hasNext();)\r\n\t\t\t\t\t\taddResult(createIndexEntryAsDocument(current.getKey(), collIt.next().getIdentity()));\r\n\t\t\t\telse\r\n\t\t\t\t\taddResult(createIndexEntryAsDocument(current.getKey(), (OIdentifiable) current.getValue()));\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (anyFunctionAggregates) {\r\n\t\t\tfor (final Entry<String, Object> projection : projections.entrySet()) {\r\n\t\t\t\tif (projection.getValue() instanceof OSQLFunctionRuntime) {\r\n\t\t\t\t\tfinal OSQLFunctionRuntime f = (OSQLFunctionRuntime) projection.getValue();\r\n\t\t\t\t\tf.setResult(index.getSize());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":84883,"modified_method":"private void searchInIndex() {\r\n\t\tfinal OIndex<Object> index = (OIndex<Object>) database.getMetadata().getIndexManager()\r\n\t\t\t\t.getIndex(compiledFilter.getTargetIndex());\r\n\t\tif (index == null)\r\n\t\t\tthrow new OCommandExecutionException(\"Target index '\" + compiledFilter.getTargetIndex() + \"' not found\");\r\n\r\n\t\tif (compiledFilter.getRootCondition() != null) {\r\n\t\t\tif (!\"KEY\".equalsIgnoreCase(compiledFilter.getRootCondition().getLeft().toString()))\r\n\t\t\t\tthrow new OCommandExecutionException(\"'Key' field is required for queries against indexes\");\r\n\r\n\t\t\tfinal OQueryOperator indexOperator = compiledFilter.getRootCondition().getOperator();\r\n\t\t\tif (indexOperator instanceof OQueryOperatorBetween) {\r\n\t\t\t\tfinal Object[] values = (Object[]) compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesBetween(OSQLHelper.getValue(values[0]),\r\n\t\t\t\t\t\tOSQLHelper.getValue(values[2]));\r\n\r\n\t\t\t\tfor (final OIdentifiable r : entries) {\r\n\t\t\t\t\tfinal boolean continueResultParsing = addResult(r);\r\n\t\t\t\t\tif (!continueResultParsing)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMajor) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMajor(OSQLHelper.getValue(value), false);\r\n\r\n\t\t\t\tparseIndexSearchResult(entries);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMajorEquals) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMajor(OSQLHelper.getValue(value), true);\r\n\r\n\t\t\t\tparseIndexSearchResult(entries);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMinor) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMinor(OSQLHelper.getValue(value), false);\r\n\r\n\t\t\t\tparseIndexSearchResult(entries);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorMinorEquals) {\r\n\t\t\t\tfinal Object value = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntriesMinor(OSQLHelper.getValue(value), true);\r\n\r\n\t\t\t\tparseIndexSearchResult(entries);\r\n\t\t\t} else if (indexOperator instanceof OQueryOperatorIn) {\r\n\t\t\t\tfinal List<Object> origValues = (List<Object>) compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal List<Object> values = new ArrayList<Object>(origValues.size());\r\n\t\t\t\tfor (Object val : origValues) {\r\n\t\t\t\t\tval = OSQLHelper.getValue(val);\r\n\t\t\t\t\tval = OType.convert(val, index.getKeyType().getDefaultJavaType());\r\n\t\t\t\t\tvalues.add(val);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfinal Collection<ODocument> entries = index.getEntries(values);\r\n\r\n\t\t\t\tparseIndexSearchResult(entries);\r\n\t\t\t} else {\r\n\t\t\t\tfinal Object right = compiledFilter.getRootCondition().getRight();\r\n\t\t\t\tfinal Object keyValue = OSQLHelper.getValue(right);\r\n\r\n\t\t\t\tfinal Object res = index.get(keyValue);\r\n\r\n\t\t\t\tif (res != null)\r\n\t\t\t\t\tif (res instanceof Collection<?>)\r\n\t\t\t\t\t\t// MULTI VALUES INDEX\r\n\t\t\t\t\t\tfor (final OIdentifiable r : (Collection<OIdentifiable>) res)\r\n\t\t\t\t\t\t\taddResult(createIndexEntryAsDocument(keyValue, r.getIdentity()));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t// SINGLE VALUE INDEX\r\n\t\t\t\t\t\taddResult(createIndexEntryAsDocument(keyValue, ((OIdentifiable) res).getIdentity()));\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// ADD ALL THE ITEMS AS RESULT\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = index.iterator(); it.hasNext();) {\r\n\t\t\t\tfinal Entry<Object, Object> current = it.next();\r\n\r\n\t\t\t\tif (current.getValue() instanceof Collection<?>)\r\n\t\t\t\t\tfor (Iterator<OIdentifiable> collIt = ((ORecordLazySet) current.getValue()).rawIterator(); collIt.hasNext();)\r\n\t\t\t\t\t\taddResult(createIndexEntryAsDocument(current.getKey(), collIt.next().getIdentity()));\r\n\t\t\t\telse\r\n\t\t\t\t\taddResult(createIndexEntryAsDocument(current.getKey(), (OIdentifiable) current.getValue()));\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (anyFunctionAggregates) {\r\n\t\t\tfor (final Entry<String, Object> projection : projections.entrySet()) {\r\n\t\t\t\tif (projection.getValue() instanceof OSQLFunctionRuntime) {\r\n\t\t\t\t\tfinal OSQLFunctionRuntime f = (OSQLFunctionRuntime) projection.getValue();\r\n\t\t\t\t\tf.setResult(index.getSize());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"013f33654e0831517729d37dc1cc4924575358f5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static void addMethodUsages(final PsiMethod method, final Processor<UsageInfo> result, final FindUsagesOptions options, SearchScope searchScope) {\n    PsiSearchHelper helper = method.getManager().getSearchHelper();\n    if (method.isConstructor()) {\n      if (!options.isIncludeOverloadUsages) {\n        addConstructorUsages(method, helper, searchScope, result, options);\n      } else {\n        PsiMethod[] constructors = method.getContainingClass().getConstructors();\n        for (int i = 0; i < constructors.length; i++) {\n          addConstructorUsages(constructors[i], helper, searchScope, result, options);\n        }\n      }\n    }\n    else {\n      helper.processReferencesIncludingOverriding(new PsiReferenceProcessor() {\n        public boolean execute(PsiReference ref) {\n          addResult(result, ref, options, method);\n          return true;\n        }\n      }, method, searchScope, !options.isIncludeOverloadUsages);\n\n      PsiReference[] refs = EjbUsagesUtil.findEjbMethodReferences(method, helper, searchScope, !options.isIncludeOverloadUsages);\n      addResults(result, refs, options, method);\n    }\n  }","id":84884,"modified_method":"private static void addMethodUsages(final PsiMethod method, final Processor<UsageInfo> result, final FindUsagesOptions options, SearchScope searchScope) {\n    PsiSearchHelper helper = method.getManager().getSearchHelper();\n    if (method.isConstructor()) {\n      if (!options.isIncludeOverloadUsages) {\n        addConstructorUsages(method, helper, searchScope, result, options);\n      } else {\n        PsiMethod[] constructors = method.getContainingClass().getConstructors();\n        for (int i = 0; i < constructors.length; i++) {\n          addConstructorUsages(constructors[i], helper, searchScope, result, options);\n        }\n      }\n    }\n    else {\n      helper.processReferencesIncludingOverriding(new PsiReferenceProcessor() {\n        public boolean execute(PsiReference ref) {\n          return addResult(result, ref, options, method);\n        }\n      }, method, searchScope, !options.isIncludeOverloadUsages);\n\n      PsiReference[] refs = EjbUsagesUtil.findEjbMethodReferences(method, helper, searchScope, !options.isIncludeOverloadUsages);\n      addResults(result, refs, options, method);\n    }\n  }","commit_id":"ee5c4aaab68d068521bd0cc62a54cb903fea338f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addResults(Processor<UsageInfo> results, PsiReference[] refs, FindUsagesOptions options, PsiElement element) {\n    for(int i = 0; i < refs.length; i++){\n      addResult(results, refs[i], options, element);\n    }\n  }","id":84885,"modified_method":"private static void addResults(Processor<UsageInfo> results, PsiReference[] refs, FindUsagesOptions options, PsiElement element) {\n    for(int i = 0; i < refs.length; i++){\n      final boolean shouldContinue = addResult(results, refs[i], options, element);\n      if (!shouldContinue) {\n        break;\n      }\n    }\n  }","commit_id":"ee5c4aaab68d068521bd0cc62a54cb903fea338f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addConstructorUsages(PsiMethod method, PsiSearchHelper helper, SearchScope searchScope, final Processor<UsageInfo> result, final FindUsagesOptions options) {\n    final PsiClass parentClass = method.getContainingClass();\n    if (parentClass == null) return;\n\n    helper.processReferences(new PsiReferenceProcessor() {\n      public boolean execute(PsiReference ref) {\n        addResult(result, ref, options, parentClass);\n        return true;\n      }\n    }, method, searchScope, false);\n\n    addImplicitConstructorCalls(method, result, searchScope);\n  }","id":84886,"modified_method":"private static void addConstructorUsages(PsiMethod method, PsiSearchHelper helper, SearchScope searchScope, final Processor<UsageInfo> result, final FindUsagesOptions options) {\n    final PsiClass parentClass = method.getContainingClass();\n    if (parentClass == null) return;\n\n    helper.processReferences(new PsiReferenceProcessor() {\n      public boolean execute(PsiReference ref) {\n        return addResult(result, ref, options, parentClass);\n      }\n    }, method, searchScope, false);\n\n    addImplicitConstructorCalls(method, result, searchScope);\n  }","commit_id":"ee5c4aaab68d068521bd0cc62a54cb903fea338f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addElementUsages(final PsiElement element, final Processor<UsageInfo> results, final FindUsagesOptions options) {\n    if (element instanceof PsiMethod){\n      addMethodUsages((PsiMethod)element, results, options, options.searchScope);\n    }\n    else{\n      PsiSearchHelper helper = element.getManager().getSearchHelper();\n      helper.processReferences(new PsiReferenceProcessor() {\n        public boolean execute(PsiReference ref) {\n          addResult(results, ref, options, element);\n          return true;\n        }\n      }, element, options.searchScope, false);\n    }\n  }","id":84887,"modified_method":"private static void addElementUsages(final PsiElement element, final Processor<UsageInfo> results, final FindUsagesOptions options) {\n    if (element instanceof PsiMethod){\n      addMethodUsages((PsiMethod)element, results, options, options.searchScope);\n    }\n    else{\n      PsiSearchHelper helper = element.getManager().getSearchHelper();\n      helper.processReferences(new PsiReferenceProcessor() {\n        public boolean execute(PsiReference ref) {\n          return addResult(results, ref, options, element);\n        }\n      }, element, options.searchScope, false);\n    }\n  }","commit_id":"ee5c4aaab68d068521bd0cc62a54cb903fea338f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addResult(Processor<UsageInfo> results, PsiReference ref, FindUsagesOptions options, PsiElement refElement) {\n    if (filterUsage(ref.getElement(), options, refElement)){\n      TextRange rangeInElement = ref.getRangeInElement();\n      results.process(new UsageInfo(ref.getElement(), rangeInElement.getStartOffset(), rangeInElement.getEndOffset(), false));\n    }\n  }","id":84888,"modified_method":"private static boolean addResult(Processor<UsageInfo> results, PsiReference ref, FindUsagesOptions options, PsiElement refElement) {\n    if (filterUsage(ref.getElement(), options, refElement)){\n      TextRange rangeInElement = ref.getRangeInElement();\n      return results.process(new UsageInfo(ref.getElement(), rangeInElement.getStartOffset(), rangeInElement.getEndOffset(), false));\n    }\n    return true;\n  }","commit_id":"ee5c4aaab68d068521bd0cc62a54cb903fea338f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Deprecated\n    public void hide() {\n      super.hide();\n      myFocusTrackback.restoreFocus();\n    }","id":84889,"modified_method":"@Deprecated\n    public void hide() {\n      super.hide();\n      if (myFocusTrackback != null) {\n        myFocusTrackback.restoreFocus();\n      }\n    }","commit_id":"a6cca3c6e0ca6118472232109c4fc73f6c92a1e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n      if (myDisposing) return;\n      myDisposing = true;\n      saveFrameState(myDimensionKey, this);\n      Disposer.dispose(FrameWrapper.this);\n      myDatas.clear();\n      if (myProject != null) {\n        ProjectManager.getInstance().removeProjectManagerListener(myProject, myProjectListener);\n        myProject = null;\n      }\n      myPreferedFocus = null;\n\n      myFocusTrackback.restoreFocus();\n      if (myComponent != null && myFocusWatcher != null) {\n        myFocusWatcher.deinstall(myComponent);\n      }\n      myFocusWatcher = null;\n      myFocusedCallback = null;\n\n      super.dispose();\n    }","id":84890,"modified_method":"public void dispose() {\n      if (myDisposing) return;\n      myDisposing = true;\n      saveFrameState(myDimensionKey, this);\n      Disposer.dispose(FrameWrapper.this);\n      myDatas.clear();\n      if (myProject != null) {\n        ProjectManager.getInstance().removeProjectManagerListener(myProject, myProjectListener);\n        myProject = null;\n      }\n      myPreferedFocus = null;\n\n      if (myFocusTrackback != null) {\n        myFocusTrackback.restoreFocus();\n      }\n      if (myComponent != null && myFocusWatcher != null) {\n        myFocusWatcher.deinstall(myComponent);\n      }\n      myFocusWatcher = null;\n      myFocusedCallback = null;\n\n      super.dispose();\n    }","commit_id":"7e757579d382789dcfbbf78283b7082125712061","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Deprecated\n    public void hide() {\n      super.hide();\n      if (myFocusTrackback != null) {\n        myFocusTrackback.restoreFocus();\n      }\n    }","id":84891,"modified_method":"@Deprecated\n    public void hide() {\n      super.hide();\n      if (myFocusTrackback != null) {\n        myFocusTrackback.restoreFocus();\n        myFocusTrackback = null;\n      }\n    }","commit_id":"449c6d65c6d1f91145927ac60f70bea56f28f7b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void stop() {\n    LOG.assertTrue(!myStoppedAlready);\n    myInstallFunAlarm.cancelAllRequests();\n\n    super.stop();\n    if (myDialog != null) {\n      myDialog.hide();\n      myFocusTrackback.restoreFocus();\n    }\n    myStoppedAlready = true;\n\n    SwingUtilities.invokeLater(EmptyRunnable.INSTANCE); // Just to give blocking dispatching a chance to go out.\n  }","id":84892,"modified_method":"public synchronized void stop() {\n    LOG.assertTrue(!myStoppedAlready);\n    myInstallFunAlarm.cancelAllRequests();\n\n    super.stop();\n    if (myDialog != null) {\n      myDialog.hide();\n      if (myFocusTrackback != null) {\n        myFocusTrackback.restoreFocus();\n        myFocusTrackback = null;\n      }\n    }\n    myStoppedAlready = true;\n\n    SwingUtilities.invokeLater(EmptyRunnable.INSTANCE); // Just to give blocking dispatching a chance to go out.\n  }","commit_id":"449c6d65c6d1f91145927ac60f70bea56f28f7b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reset() {\n        seqno_lock.lock();\n        try {\n            seqno=0;\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        for(NakReceiverWindow win: xmit_table.values()) {\n            win.destroy();\n        }\n        xmit_table.clear();\n        undelivered_msgs.set(0);\n    }","id":84893,"modified_method":"private void reset() {\n        seqno_lock.lock();\n        try {\n            seqno=0;\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        for(NakReceiverWindow win: xmit_table.values()) {\n            win.destroy();\n        }\n        xmit_table.clear();\n    }","commit_id":"deb349d09428579a596ddf81a69a110c7f9c8e07","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     * @param seqno\n     */\n    private void sendXmitRsp(Address dest, Message msg, long seqno) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // xmit_msg.setFlag(Message.OOB);\n\n            if(msg.isFlagSet(Message.OOB)) // set OOB for the wrapping message if the wrapped message is OOB, too\n                xmit_msg.setFlag(Message.OOB);\n\n            xmit_msg.putHeader(this.id, NakAckHeader.createXmitResponseHeader());\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","id":84894,"modified_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     */\n    private void sendXmitRsp(Address dest, Message msg) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // xmit_msg.setFlag(Message.OOB);\n\n            if(msg.isFlagSet(Message.OOB)) // set OOB for the wrapping message if the wrapped message is OOB, too\n                xmit_msg.setFlag(Message.OOB);\n\n            xmit_msg.putHeader(this.id, NakAckHeader.createXmitResponseHeader());\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","commit_id":"deb349d09428579a596ddf81a69a110c7f9c8e07","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Retransmits messsages first_seqno to last_seqno from original_sender from xmit_table to xmit_requester,\n     * called when XMIT_REQ is received.\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n   private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message msg;\n\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno)\n            return;\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.xmit_reqs_received.addAndGet((int)(last_seqno - first_seqno +1));\n            stat.xmit_rsps_sent.addAndGet((int)(last_seqno - first_seqno +1));\n        }\n\n        NakReceiverWindow win=xmit_table.get(original_sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                sb.append(\") \").append(original_sender).append(\" not found in retransmission table\");\n                // don't print the table unless we are in trace mode because it can be LARGE\n                if (log.isTraceEnabled()) {\n                    sb.append(\":\\n\").append(printMessages());\n                } \n                if(print_stability_history_on_failed_xmit) {\n                    sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                }\n                log.error(sb.toString());\n            }\n            return;\n        }\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            msg=win.get(i);\n            if(msg == null) {\n                if(log.isWarnEnabled() && log_not_found_msgs && !local_addr.equals(xmit_requester)) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in retransmission table of \").append(original_sender).append(\":\\n\").append(win);\n                    if(print_stability_history_on_failed_xmit) {\n                        sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                    }\n                    log.warn(sb.toString());\n                }\n                continue;\n            }\n            sendXmitRsp(xmit_requester, msg, i);\n        }\n    }","id":84895,"modified_method":"/**\n     * Retransmits messsages first_seqno to last_seqno from original_sender from xmit_table to xmit_requester,\n     * called when XMIT_REQ is received.\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n   private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message msg;\n\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno)\n            return;\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.xmit_reqs_received.addAndGet((int)(last_seqno - first_seqno +1));\n            stat.xmit_rsps_sent.addAndGet((int)(last_seqno - first_seqno +1));\n        }\n\n        NakReceiverWindow win=xmit_table.get(original_sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                sb.append(\") \").append(original_sender).append(\" not found in retransmission table\");\n                // don't print the table unless we are in trace mode because it can be LARGE\n                if (log.isTraceEnabled()) {\n                    sb.append(\":\\n\").append(printMessages());\n                } \n                if(print_stability_history_on_failed_xmit) {\n                    sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                }\n                log.error(sb.toString());\n            }\n            return;\n        }\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            msg=win.get(i);\n            if(msg == null) {\n                if(log.isWarnEnabled() && log_not_found_msgs && !local_addr.equals(xmit_requester)) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in retransmission table of \").append(original_sender).append(\":\\n\").append(win);\n                    if(print_stability_history_on_failed_xmit) {\n                        sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                    }\n                    log.warn(sb.toString());\n                }\n                continue;\n            }\n            sendXmitRsp(xmit_requester, msg);\n        }\n    }","commit_id":"deb349d09428579a596ddf81a69a110c7f9c8e07","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!running) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as we're not in the 'running' state, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(this.id, NakAckHeader.createMessageHeader(msg_id));\n                if(win.add(msg_id, msg) && !msg.isFlagSet(Message.OOB))\n                    undelivered_msgs.incrementAndGet();\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","id":84896,"modified_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!running) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as we're not in the 'running' state, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(this.id, NakAckHeader.createMessageHeader(msg_id));\n                win.add(msg_id, msg);\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","commit_id":"deb349d09428579a596ddf81a69a110c7f9c8e07","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedAttribute\n    public int getUndeliveredMessages() {\n        return undelivered_msgs.get();\n    }","id":84897,"modified_method":"@Deprecated\n    public static int getUndeliveredMessages() {\n        return 0;\n    }","commit_id":"deb349d09428579a596ddf81a69a110c7f9c8e07","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": dropped message from \" + sender +\n                        \" (not in xmit_table), keys are \" + xmit_table.keySet() +\", view=\" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added) {\n                if(loopback)\n                    msg=win.get(hdr.seqno);\n                if(msg != null && msg.isFlagSet(Message.OOB)) {\n                    if(msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                        up_prot.up(new Event(Event.MSG, msg));\n                }\n            }\n            List<Message> msgs;\n            while(!(msgs=win.removeOOBMessages()).isEmpty()) {\n                for(Message tmp_msg: msgs) {\n                    if(tmp_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                        up_prot.up(new Event(Event.MSG, tmp_msg));\n                    }\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing, max_msg_batch_size);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(final Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg if it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        if(msg_to_deliver.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                            timer.execute(new Runnable() {\n                                public void run() {\n                                    up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                                }\n                            });\n                        }\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":84898,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": dropped message from \" + sender + \" (not in table \" + xmit_table.keySet() +\"), view=\" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added=loopback || win.add(hdr.seqno, msg);\n\n        // OOB msg is passed up. When removed, we discard it. Affects ordering: http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added) {\n                if(loopback)\n                    msg=win.get(hdr.seqno);\n                if(msg != null && msg.isFlagSet(Message.OOB)) {\n                    if(msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                        up_prot.up(new Event(Event.MSG, msg));\n                }\n            }\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing, max_msg_batch_size);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(final Message msg_to_deliver: msgs) {\n                    // discard OOB msg if it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB) && !msg_to_deliver.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                        continue;\n\n                    //msg_to_deliver.removeHeader(getName()); // Changed by bela Jan 29 2003: not needed (see above)\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"deb349d09428579a596ddf81a69a110c7f9c8e07","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void  handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from non-member \" + sender + \", my view is \" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            msg=win.get(hdr.seqno);\n            if(msg != null) {\n                boolean pass_up=msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up)\n                    up_prot.up(new Event(Event.MSG, msg));\n            }\n\n            while(true) {\n                final Message oob_msg=win.removeOOBMessage();\n                if(oob_msg == null)\n                    break;\n                boolean pass_up=oob_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up) {\n                    timer.execute(new Runnable() {\n                        public void run() {\n                            up_prot.up(new Event(Event.MSG, oob_msg));\n                        }\n                    });\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":84899,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": dropped message from \" + sender +\n                        \" (not in retransmission table), members are \" + xmit_table.keySet() +\", view=\" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            msg=win.get(hdr.seqno);\n            if(msg != null && msg.isFlagSet(Message.OOB)) {\n                if(msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                    up_prot.up(new Event(Event.MSG, msg));\n            }\n\n            while(true) {\n                final Message oob_msg=win.removeOOBMessage();\n                if(oob_msg == null)\n                    break;\n                if(oob_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                    timer.execute(new Runnable() {\n                        public void run() {\n                            up_prot.up(new Event(Event.MSG, oob_msg));\n                        }\n                    });\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(final Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg if it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        if(msg_to_deliver.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                            timer.execute(new Runnable() {\n                                public void run() {\n                                    up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                                }\n                            });\n                        }\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"d799effe2711086e047dfeb8e4c7ee6e6cd80399","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void  handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from non-member \" + sender + \", my view is \" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            msg=win.get(hdr.seqno);\n            if(msg != null) {\n                boolean pass_up=msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up)\n                    up_prot.up(new Event(Event.MSG, msg));\n            }\n\n            while(true) {\n                final Message oob_msg=win.removeOOBMessage();\n                if(oob_msg == null)\n                    break;\n                boolean pass_up=oob_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up) {\n                    timer.execute(new Runnable() {\n                        public void run() {\n                            up_prot.up(new Event(Event.MSG, oob_msg));\n                        }\n                    });\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":84900,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": dropped message from \" + sender +\n                        \" (not in retransmission table), members are \" + xmit_table.keySet() +\", view=\" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            msg=win.get(hdr.seqno);\n            if(msg != null && msg.isFlagSet(Message.OOB)) {\n                if(msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                    up_prot.up(new Event(Event.MSG, msg));\n            }\n\n            while(true) {\n                final Message oob_msg=win.removeOOBMessage();\n                if(oob_msg == null)\n                    break;\n                if(oob_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                    timer.execute(new Runnable() {\n                        public void run() {\n                            up_prot.up(new Event(Event.MSG, oob_msg));\n                        }\n                    });\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(final Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg if it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        if(msg_to_deliver.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                            timer.execute(new Runnable() {\n                                public void run() {\n                                    up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                                }\n                            });\n                        }\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"cd8f57a8ed23be81239ce0ee29d831251d00b274","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     * @param seqno\n     */\n    private void sendXmitRsp(Address dest, Message msg, long seqno) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // xmit_msg.setFlag(Message.OOB);\n\n            if(msg.isFlagSet(Message.OOB)) // set OOB for the wrapping message if the wrapped message is OOB, too\n                xmit_msg.setFlag(Message.OOB);\n\n            xmit_msg.putHeader(this.id, NakAckHeader.createXmitResponseHeader());\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","id":84901,"modified_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     */\n    private void sendXmitRsp(Address dest, Message msg) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // xmit_msg.setFlag(Message.OOB);\n\n            if(msg.isFlagSet(Message.OOB)) // set OOB for the wrapping message if the wrapped message is OOB, too\n                xmit_msg.setFlag(Message.OOB);\n\n            xmit_msg.putHeader(this.id, NakAckHeader.createXmitResponseHeader());\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","commit_id":"11d5eef0dcdcaa9f0c79862d0efe54c593f8a4c9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void reset() {\n        seqno_lock.lock();\n        try {\n            seqno=0;\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        for(NakReceiverWindow win: xmit_table.values()) {\n            win.destroy();\n        }\n        xmit_table.clear();\n        undelivered_msgs.set(0);\n    }","id":84902,"modified_method":"private void reset() {\n        seqno_lock.lock();\n        try {\n            seqno=0;\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        for(NakReceiverWindow win: xmit_table.values()) {\n            win.destroy();\n        }\n        xmit_table.clear();\n    }","commit_id":"11d5eef0dcdcaa9f0c79862d0efe54c593f8a4c9","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": dropped message from \" + sender +\n                        \" (not in xmit_table), keys are \" + xmit_table.keySet() +\", view=\" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added) {\n                if(loopback)\n                    msg=win.get(hdr.seqno);\n                if(msg != null && msg.isFlagSet(Message.OOB)) {\n                    if(msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                        up_prot.up(new Event(Event.MSG, msg));\n                }\n            }\n            List<Message> msgs;\n            while(!(msgs=win.removeOOBMessages()).isEmpty()) {\n                for(Message tmp_msg: msgs) {\n                    if(tmp_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                        up_prot.up(new Event(Event.MSG, tmp_msg));\n                    }\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing, max_msg_batch_size);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(final Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg if it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        if(msg_to_deliver.setTransientFlagIfAbsent(Message.OOB_DELIVERED)) {\n                            timer.execute(new Runnable() {\n                                public void run() {\n                                    up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                                }\n                            });\n                        }\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":84903,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": dropped message from \" + sender + \" (not in table \" + xmit_table.keySet() +\"), view=\" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added=loopback || win.add(hdr.seqno, msg);\n\n        // OOB msg is passed up. When removed, we discard it. Affects ordering: http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added) {\n                if(loopback)\n                    msg=win.get(hdr.seqno);\n                if(msg != null && msg.isFlagSet(Message.OOB)) {\n                    if(msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                        up_prot.up(new Event(Event.MSG, msg));\n                }\n            }\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing, max_msg_batch_size);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(final Message msg_to_deliver: msgs) {\n                    // discard OOB msg if it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB) && !msg_to_deliver.setTransientFlagIfAbsent(Message.OOB_DELIVERED))\n                        continue;\n\n                    //msg_to_deliver.removeHeader(getName()); // Changed by bela Jan 29 2003: not needed (see above)\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"11d5eef0dcdcaa9f0c79862d0efe54c593f8a4c9","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedAttribute\n    public int getUndeliveredMessages() {\n        return undelivered_msgs.get();\n    }","id":84904,"modified_method":"@Deprecated\n    public static int getUndeliveredMessages() {\n        return 0;\n    }","commit_id":"11d5eef0dcdcaa9f0c79862d0efe54c593f8a4c9","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!running) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as we're not in the 'running' state, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(this.id, NakAckHeader.createMessageHeader(msg_id));\n                if(win.add(msg_id, msg) && !msg.isFlagSet(Message.OOB))\n                    undelivered_msgs.incrementAndGet();\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","id":84905,"modified_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!running) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as we're not in the 'running' state, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(this.id, NakAckHeader.createMessageHeader(msg_id));\n                win.add(msg_id, msg);\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","commit_id":"11d5eef0dcdcaa9f0c79862d0efe54c593f8a4c9","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Retransmits messsages first_seqno to last_seqno from original_sender from xmit_table to xmit_requester,\n     * called when XMIT_REQ is received.\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n   private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message msg;\n\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno)\n            return;\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.xmit_reqs_received.addAndGet((int)(last_seqno - first_seqno +1));\n            stat.xmit_rsps_sent.addAndGet((int)(last_seqno - first_seqno +1));\n        }\n\n        NakReceiverWindow win=xmit_table.get(original_sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                sb.append(\") \").append(original_sender).append(\" not found in retransmission table\");\n                // don't print the table unless we are in trace mode because it can be LARGE\n                if (log.isTraceEnabled()) {\n                    sb.append(\":\\n\").append(printMessages());\n                } \n                if(print_stability_history_on_failed_xmit) {\n                    sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                }\n                log.error(sb.toString());\n            }\n            return;\n        }\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            msg=win.get(i);\n            if(msg == null) {\n                if(log.isWarnEnabled() && log_not_found_msgs && !local_addr.equals(xmit_requester)) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in retransmission table of \").append(original_sender).append(\":\\n\").append(win);\n                    if(print_stability_history_on_failed_xmit) {\n                        sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                    }\n                    log.warn(sb.toString());\n                }\n                continue;\n            }\n            sendXmitRsp(xmit_requester, msg, i);\n        }\n    }","id":84906,"modified_method":"/**\n     * Retransmits messsages first_seqno to last_seqno from original_sender from xmit_table to xmit_requester,\n     * called when XMIT_REQ is received.\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n   private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message msg;\n\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno)\n            return;\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.xmit_reqs_received.addAndGet((int)(last_seqno - first_seqno +1));\n            stat.xmit_rsps_sent.addAndGet((int)(last_seqno - first_seqno +1));\n        }\n\n        NakReceiverWindow win=xmit_table.get(original_sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                sb.append(\") \").append(original_sender).append(\" not found in retransmission table\");\n                // don't print the table unless we are in trace mode because it can be LARGE\n                if (log.isTraceEnabled()) {\n                    sb.append(\":\\n\").append(printMessages());\n                } \n                if(print_stability_history_on_failed_xmit) {\n                    sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                }\n                log.error(sb.toString());\n            }\n            return;\n        }\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            msg=win.get(i);\n            if(msg == null) {\n                if(log.isWarnEnabled() && log_not_found_msgs && !local_addr.equals(xmit_requester)) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in retransmission table of \").append(original_sender).append(\":\\n\").append(win);\n                    if(print_stability_history_on_failed_xmit) {\n                        sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                    }\n                    log.warn(sb.toString());\n                }\n                continue;\n            }\n            sendXmitRsp(xmit_requester, msg);\n        }\n    }","commit_id":"11d5eef0dcdcaa9f0c79862d0efe54c593f8a4c9","url":"https://github.com/belaban/JGroups"},{"original_method":"protected org.dom4j.io.SAXReader getSAXReader(boolean validate) {\n\t\torg.dom4j.io.SAXReader reader = null;\n\n\t\tif (!PropsValues.XML_VALIDATION_ENABLED) {\n\t\t\tvalidate = false;\n\t\t}\n\n\t\ttry {\n\t\t\treader = new org.dom4j.io.SAXReader(new SAXParser(), validate);\n\n\t\t\treader.setEntityResolver(new EntityResolver());\n\n\t\t\treader.setFeature(_FEATURES_DYNAMIC, validate);\n\t\t\treader.setFeature(_FEATURES_VALIDATION, validate);\n\t\t\treader.setFeature(_FEATURES_VALIDATION_SCHEMA, validate);\n\t\t\treader.setFeature(\n\t\t\t\t_FEATURES_VALIDATION_SCHEMA_FULL_CHECKING, validate);\n\n\t\t\tif (!validate) {\n\t\t\t\treader.setFeature(\n\t\t\t\t\t_FEATURES_EXTERNAL_GENERAL_ENTITIES, validate);\n\t\t\t\treader.setFeature(_FEATURES_LOAD_DTD_GRAMMAR, validate);\n\t\t\t\treader.setFeature(_FEATURES_LOAD_EXTERNAL_DTD, validate);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"XSD validation is disabled because \" + e.getMessage());\n\t\t\t}\n\n\t\t\treader = new org.dom4j.io.SAXReader(false);\n\n\t\t\treader.setEntityResolver(new EntityResolver());\n\t\t}\n\n\t\treturn reader;\n\t}","id":84907,"modified_method":"protected org.dom4j.io.SAXReader getSAXReader(boolean validate) {\n\t\torg.dom4j.io.SAXReader reader = null;\n\n\t\tif (!PropsValues.XML_VALIDATION_ENABLED) {\n\t\t\tvalidate = false;\n\t\t}\n\n\t\ttry {\n\t\t\treader = new org.dom4j.io.SAXReader(new SAXParser(), validate);\n\n\t\t\treader.setEntityResolver(new EntityResolver());\n\n\t\t\treader.setFeature(_FEATURES_DYNAMIC, validate);\n\t\t\treader.setFeature(_FEATURES_EXTERNAL_GENERAL_ENTITIES, validate);\n\t\t\treader.setFeature(_FEATURES_LOAD_DTD_GRAMMAR, validate);\n\t\t\treader.setFeature(_FEATURES_LOAD_EXTERNAL_DTD, validate);\n\t\t\treader.setFeature(_FEATURES_VALIDATION, validate);\n\t\t\treader.setFeature(_FEATURES_VALIDATION_SCHEMA, validate);\n\t\t\treader.setFeature(\n\t\t\t\t_FEATURES_VALIDATION_SCHEMA_FULL_CHECKING, validate);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"XSD validation is disabled because \" + e.getMessage());\n\t\t\t}\n\n\t\t\treader = new org.dom4j.io.SAXReader(false);\n\n\t\t\treader.setEntityResolver(new EntityResolver());\n\t\t}\n\n\t\treturn reader;\n\t}","commit_id":"df6c80ac9b35dba95405d9c28adbfbf8f4c275c8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean matchesCurrentModifiers(ModifiersSpec spec) {\n        return spec.matchWithKnown(alt, shift, ctrl);\n    }","id":84908,"modified_method":"private boolean matchesCurrentModifiers(Map<Modifier, Boolean> spec) {\n        EnumSet<Modifier> modifiers = EnumSet.noneOf(Modifier.class);\n        if (ctrl) {\n            modifiers.add(Modifier.CTRL);\n        }\n        if (alt) {\n            modifiers.add(Modifier.ALT);\n        }\n        if (shift) {\n            modifiers.add(Modifier.SHIFT);\n        }\n        return spec.entrySet().stream().allMatch(entry -> modifiers.contains(entry.getKey()) == entry.getValue().booleanValue());\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"private boolean isModifiersValidForDragMode() {\n        return (!alt && !shift && !ctrl) || matchesCurrentModifiers(snapModifierCombo)\n                || matchesCurrentModifiers(copyTagsModifierCombo);\n    }","id":84909,"modified_method":"private boolean isModifiersValidForDragMode() {\n        return (!alt && !shift && !ctrl) || matchesCurrentModifiers(SNAP_MODIFIER_COMBO)\n                || matchesCurrentModifiers(COPY_TAGS_MODIFIER_COMBO);\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void updateCursor() {\n        Cursor newCursor = null;\n        switch (mode) {\n        case NORMAL:\n            if (matchesCurrentModifiers(setSelectedModifierCombo)) {\n                newCursor = ImageProvider.getCursor(\"normal\", \"parallel\");\n            } else if (matchesCurrentModifiers(addToSelectionModifierCombo)) {\n                newCursor = ImageProvider.getCursor(\"normal\", \"parallel_add\");\n            } else if (matchesCurrentModifiers(toggleSelectedModifierCombo)) {\n                newCursor = ImageProvider.getCursor(\"normal\", \"parallel_remove\");\n            }\n            break;\n        case DRAGGING:\n            newCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);\n            break;\n        default: throw new AssertionError();\n        }\n        if (newCursor != null) {\n            mv.setNewCursor(newCursor, this);\n        }\n    }","id":84910,"modified_method":"private void updateCursor() {\n        Cursor newCursor = null;\n        switch (mode) {\n        case NORMAL:\n            if (matchesCurrentModifiers(SET_SELECTED_MODIFIER_COMBO)) {\n                newCursor = ImageProvider.getCursor(\"normal\", \"parallel\");\n            } else if (matchesCurrentModifiers(ADD_TO_SELECTION_MODIFIER_COMBO)) {\n                newCursor = ImageProvider.getCursor(\"normal\", \"parallel_add\");\n            } else if (matchesCurrentModifiers(TOGGLE_SELECTED_MODIFIER_COMBO)) {\n                newCursor = ImageProvider.getCursor(\"normal\", \"parallel_remove\");\n            }\n            break;\n        case DRAGGING:\n            newCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);\n            break;\n        default: throw new AssertionError();\n        }\n        if (newCursor != null) {\n            mv.setNewCursor(newCursor, this);\n        }\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void updateFlagsOnlyChangeableOnPress() {\n        copyTags = copyTagsDefault != matchesCurrentModifiers(copyTagsModifierCombo);\n    }","id":84911,"modified_method":"private void updateFlagsOnlyChangeableOnPress() {\n        copyTags = COPY_TAGS_DEFAULT.get().booleanValue() != matchesCurrentModifiers(COPY_TAGS_MODIFIER_COMBO);\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void paint(Graphics2D g, MapView mv, Bounds bbox) {\n        if (mode == Mode.DRAGGING) {\n            // sanity checks\n            if (mv == null)\n                return;\n\n            // FIXME: should clip the line (gets insanely slow when zoomed in on a very long line\n            g.setStroke(refLineStroke);\n            g.setColor(mainColor);\n            Point p1 = mv.getPoint(referenceSegment.getFirstNode().getEastNorth());\n            Point p2 = mv.getPoint(referenceSegment.getSecondNode().getEastNorth());\n            g.drawLine(p1.x, p1.y, p2.x, p2.y);\n\n            g.setStroke(helpLineStroke);\n            g.setColor(mainColor);\n            p1 = mv.getPoint(helperLineStart);\n            p2 = mv.getPoint(helperLineEnd);\n            g.drawLine(p1.x, p1.y, p2.x, p2.y);\n        }\n    }","id":84912,"modified_method":"@Override\n    public void paint(Graphics2D g, MapView mv, Bounds bbox) {\n        if (mode == Mode.DRAGGING) {\n            CheckParameterUtil.ensureParameterNotNull(mv, \"mv\");\n\n            Color mainColor = MAIN_COLOR.get();\n            if (mainColor == null) {\n                mainColor = PaintColors.SELECTED.get();\n            }\n\n            // FIXME: should clip the line (gets insanely slow when zoomed in on a very long line\n            g.setStroke(refLineStroke);\n            g.setColor(mainColor);\n            MapPath2D line = new MapPath2D();\n            line.moveTo(mv.getState().getPointFor(referenceSegment.getFirstNode()));\n            line.lineTo(mv.getState().getPointFor(referenceSegment.getSecondNode()));\n            g.draw(line);\n\n            g.setStroke(helpLineStroke);\n            g.setColor(mainColor);\n            line = new MapPath2D();\n            line.moveTo(mv.getState().getPointFor(helperLineStart));\n            line.lineTo(mv.getState().getPointFor(helperLineEnd));\n            g.draw(line);\n        }\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Constructs a new {@code ParallelWayAction}.\n     * @param mapFrame Map frame\n     */\n    public ParallelWayAction(MapFrame mapFrame) {\n        super(tr(\"Parallel\"), \"parallel\", tr(\"Make parallel copies of ways\"),\n            Shortcut.registerShortcut(\"mapmode:parallel\", tr(\"Mode: {0}\",\n                tr(\"Parallel\")), KeyEvent.VK_P, Shortcut.SHIFT),\n            mapFrame, ImageProvider.getCursor(\"normal\", \"parallel\"));\n        putValue(\"help\", ht(\"/Action/Parallel\"));\n        mv = mapFrame.mapView;\n        updateModeLocalPreferences();\n        Main.pref.addPreferenceChangeListener(this);\n    }","id":84913,"modified_method":"/**\n     * Constructs a new {@code ParallelWayAction}.\n     * @param mapFrame Map frame\n     */\n    public ParallelWayAction(MapFrame mapFrame) {\n        super(tr(\"Parallel\"), \"parallel\", tr(\"Make parallel copies of ways\"),\n            Shortcut.registerShortcut(\"mapmode:parallel\", tr(\"Mode: {0}\",\n                tr(\"Parallel\")), KeyEvent.VK_P, Shortcut.SHIFT),\n            mapFrame, ImageProvider.getCursor(\"normal\", \"parallel\"));\n        putValue(\"help\", ht(\"/Action/Parallel\"));\n        mv = mapFrame.mapView;\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void mouseReleased(MouseEvent e) {\n        updateModifiersState(e.getModifiers());\n        // Other buttons are off limit, but we still get events.\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n\n        if (!mouseHasBeenDragged) {\n            // use point from press or click event? (or are these always the same)\n            Way nearestWay = mv.getNearestWay(e.getPoint(), OsmPrimitive::isSelectable);\n            if (nearestWay == null) {\n                if (matchesCurrentModifiers(setSelectedModifierCombo)) {\n                    clearSourceWays();\n                }\n                resetMouseTrackingState();\n                return;\n            }\n            boolean isSelected = nearestWay.isSelected();\n            if (matchesCurrentModifiers(addToSelectionModifierCombo)) {\n                if (!isSelected) {\n                    addSourceWay(nearestWay);\n                }\n            } else if (matchesCurrentModifiers(toggleSelectedModifierCombo)) {\n                if (isSelected) {\n                    removeSourceWay(nearestWay);\n                } else {\n                    addSourceWay(nearestWay);\n                }\n            } else if (matchesCurrentModifiers(setSelectedModifierCombo)) {\n                clearSourceWays();\n                addSourceWay(nearestWay);\n            } // else -> invalid modifier combination\n        } else if (mode == Mode.DRAGGING) {\n            clearSourceWays();\n        }\n\n        setMode(Mode.NORMAL);\n        resetMouseTrackingState();\n        mv.repaint();\n    }","id":84914,"modified_method":"@Override\n    public void mouseReleased(MouseEvent e) {\n        updateModifiersState(e.getModifiers());\n        // Other buttons are off limit, but we still get events.\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n\n        if (!mouseHasBeenDragged) {\n            // use point from press or click event? (or are these always the same)\n            Way nearestWay = mv.getNearestWay(e.getPoint(), OsmPrimitive::isSelectable);\n            if (nearestWay == null) {\n                if (matchesCurrentModifiers(SET_SELECTED_MODIFIER_COMBO)) {\n                    clearSourceWays();\n                }\n                resetMouseTrackingState();\n                return;\n            }\n            boolean isSelected = nearestWay.isSelected();\n            if (matchesCurrentModifiers(ADD_TO_SELECTION_MODIFIER_COMBO)) {\n                if (!isSelected) {\n                    addSourceWay(nearestWay);\n                }\n            } else if (matchesCurrentModifiers(TOGGLE_SELECTED_MODIFIER_COMBO)) {\n                if (isSelected) {\n                    removeSourceWay(nearestWay);\n                } else {\n                    addSourceWay(nearestWay);\n                }\n            } else if (matchesCurrentModifiers(SET_SELECTED_MODIFIER_COMBO)) {\n                clearSourceWays();\n                addSourceWay(nearestWay);\n            } // else -> invalid modifier combination\n        } else if (mode == Mode.DRAGGING) {\n            clearSourceWays();\n        }\n\n        setMode(Mode.NORMAL);\n        resetMouseTrackingState();\n        mv.repaint();\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void mouseDragged(MouseEvent e) {\n        // WTF.. the event passed here doesn't have button info?\n        // Since we get this event from other buttons too, we must check that\n        // _BUTTON1_ is down.\n        if (!mouseIsDown)\n            return;\n\n        boolean modifiersChanged = updateModifiersState(e.getModifiers());\n        updateFlagsChangeableAlways();\n\n        if (modifiersChanged) {\n            // Since this could be remotely slow, do it conditionally\n            updateStatusLine();\n            updateCursor();\n        }\n\n        if ((System.currentTimeMillis() - mousePressedTime) < initialMoveDelay)\n            return;\n        // Assuming this event only is emitted when the mouse has moved\n        // Setting this after the check above means we tolerate clicks with some movement\n        mouseHasBeenDragged = true;\n\n        if (mode == Mode.NORMAL) {\n            // Should we ensure that the copyTags modifiers are still valid?\n\n            // Important to use mouse position from the press, since the drag\n            // event can come quite late\n            if (!isModifiersValidForDragMode())\n                return;\n            if (!initParallelWays(mousePressedPos, copyTags))\n                return;\n            setMode(Mode.DRAGGING);\n        }\n\n        // Calculate distance to the reference line\n        Point p = e.getPoint();\n        EastNorth enp = mv.getEastNorth((int) p.getX(), (int) p.getY());\n        EastNorth nearestPointOnRefLine = Geometry.closestPointToLine(referenceSegment.getFirstNode().getEastNorth(),\n                referenceSegment.getSecondNode().getEastNorth(), enp);\n\n        // Note: d is the distance in _projected units_\n        double d = enp.distance(nearestPointOnRefLine);\n        double realD = mv.getProjection().eastNorth2latlon(enp).greatCircleDistance(mv.getProjection().eastNorth2latlon(nearestPointOnRefLine));\n        double snappedRealD = realD;\n\n        // TODO: abuse of isToTheRightSideOfLine function.\n        boolean toTheRight = Geometry.isToTheRightSideOfLine(referenceSegment.getFirstNode(),\n                referenceSegment.getFirstNode(), referenceSegment.getSecondNode(), new Node(enp));\n\n        if (snap) {\n            // TODO: Very simple snapping\n            // - Snap steps relative to the distance?\n            double snapDistance;\n            SystemOfMeasurement som = SystemOfMeasurement.getSystemOfMeasurement();\n            if (som.equals(SystemOfMeasurement.CHINESE)) {\n                snapDistance = snapDistanceChinese * SystemOfMeasurement.CHINESE.aValue;\n            } else if (som.equals(SystemOfMeasurement.IMPERIAL)) {\n                snapDistance = snapDistanceImperial * SystemOfMeasurement.IMPERIAL.aValue;\n            } else if (som.equals(SystemOfMeasurement.NAUTICAL_MILE)) {\n                snapDistance = snapDistanceNautical * SystemOfMeasurement.NAUTICAL_MILE.aValue;\n            } else {\n                snapDistance = snapDistanceMetric; // Metric system by default\n            }\n            double closestWholeUnit;\n            double modulo = realD % snapDistance;\n            if (modulo < snapDistance/2.0) {\n                closestWholeUnit = realD - modulo;\n            } else {\n                closestWholeUnit = realD + (snapDistance-modulo);\n            }\n            if (Math.abs(closestWholeUnit - realD) < (snapThreshold * snapDistance)) {\n                snappedRealD = closestWholeUnit;\n            } else {\n                snappedRealD = closestWholeUnit + Math.signum(realD - closestWholeUnit) * snapDistance;\n            }\n        }\n        d = snappedRealD * (d/realD); // convert back to projected distance. (probably ok on small scales)\n        helperLineStart = nearestPointOnRefLine;\n        helperLineEnd = enp;\n        if (toTheRight) {\n            d = -d;\n        }\n        pWays.changeOffset(d);\n\n        Main.map.statusLine.setDist(Math.abs(snappedRealD));\n        Main.map.statusLine.repaint();\n        mv.repaint();\n    }","id":84915,"modified_method":"@Override\n    public void mouseDragged(MouseEvent e) {\n        // WTF.. the event passed here doesn't have button info?\n        // Since we get this event from other buttons too, we must check that\n        // _BUTTON1_ is down.\n        if (!mouseIsDown)\n            return;\n\n        boolean modifiersChanged = updateModifiersState(e.getModifiers());\n        updateFlagsChangeableAlways();\n\n        if (modifiersChanged) {\n            // Since this could be remotely slow, do it conditionally\n            updateStatusLine();\n            updateCursor();\n        }\n\n        if ((System.currentTimeMillis() - mousePressedTime) < INITIAL_MOVE_DELAY.get())\n            return;\n        // Assuming this event only is emitted when the mouse has moved\n        // Setting this after the check above means we tolerate clicks with some movement\n        mouseHasBeenDragged = true;\n\n        if (mode == Mode.NORMAL) {\n            // Should we ensure that the copyTags modifiers are still valid?\n\n            // Important to use mouse position from the press, since the drag\n            // event can come quite late\n            if (!isModifiersValidForDragMode())\n                return;\n            if (!initParallelWays(mousePressedPos, copyTags))\n                return;\n            setMode(Mode.DRAGGING);\n        }\n\n        // Calculate distance to the reference line\n        Point p = e.getPoint();\n        EastNorth enp = mv.getEastNorth((int) p.getX(), (int) p.getY());\n        EastNorth nearestPointOnRefLine = Geometry.closestPointToLine(referenceSegment.getFirstNode().getEastNorth(),\n                referenceSegment.getSecondNode().getEastNorth(), enp);\n\n        // Note: d is the distance in _projected units_\n        double d = enp.distance(nearestPointOnRefLine);\n        double realD = mv.getProjection().eastNorth2latlon(enp).greatCircleDistance(mv.getProjection().eastNorth2latlon(nearestPointOnRefLine));\n        double snappedRealD = realD;\n\n        boolean toTheRight = Geometry.angleIsClockwise(\n                referenceSegment.getFirstNode(), referenceSegment.getSecondNode(), new Node(enp));\n\n        if (snap) {\n            // TODO: Very simple snapping\n            // - Snap steps relative to the distance?\n            double snapDistance;\n            SystemOfMeasurement som = SystemOfMeasurement.getSystemOfMeasurement();\n            if (som.equals(SystemOfMeasurement.CHINESE)) {\n                snapDistance = SNAP_DISTANCE_CHINESE.get() * SystemOfMeasurement.CHINESE.aValue;\n            } else if (som.equals(SystemOfMeasurement.IMPERIAL)) {\n                snapDistance = SNAP_DISTANCE_IMPERIAL.get() * SystemOfMeasurement.IMPERIAL.aValue;\n            } else if (som.equals(SystemOfMeasurement.NAUTICAL_MILE)) {\n                snapDistance = SNAP_DISTANCE_NAUTICAL.get() * SystemOfMeasurement.NAUTICAL_MILE.aValue;\n            } else {\n                snapDistance = SNAP_DISTANCE_METRIC.get(); // Metric system by default\n            }\n            double closestWholeUnit;\n            double modulo = realD % snapDistance;\n            if (modulo < snapDistance/2.0) {\n                closestWholeUnit = realD - modulo;\n            } else {\n                closestWholeUnit = realD + (snapDistance-modulo);\n            }\n            if (Math.abs(closestWholeUnit - realD) < (SNAP_THRESHOLD.get() * snapDistance)) {\n                snappedRealD = closestWholeUnit;\n            } else {\n                snappedRealD = closestWholeUnit + Math.signum(realD - closestWholeUnit) * snapDistance;\n            }\n        }\n        d = snappedRealD * (d/realD); // convert back to projected distance. (probably ok on small scales)\n        helperLineStart = nearestPointOnRefLine;\n        helperLineEnd = enp;\n        if (toTheRight) {\n            d = -d;\n        }\n        pWays.changeOffset(d);\n\n        Main.map.statusLine.setDist(Math.abs(snappedRealD));\n        Main.map.statusLine.repaint();\n        mv.repaint();\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void updateFlagsChangeableAlways() {\n        snap = snapDefault != matchesCurrentModifiers(snapModifierCombo);\n    }","id":84916,"modified_method":"private void updateFlagsChangeableAlways() {\n        snap = SNAP_DEFAULT.get().booleanValue() != matchesCurrentModifiers(SNAP_MODIFIER_COMBO);\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void enterMode() {\n        // super.enterMode() updates the status line and cursor so we need our state to be set correctly\n        setMode(Mode.NORMAL);\n        pWays = null;\n        updateAllPreferences(); // All default values should've been set now\n\n        super.enterMode();\n\n        mv.addMouseListener(this);\n        mv.addMouseMotionListener(this);\n        mv.addTemporaryLayer(this);\n\n        helpLineStroke = GuiHelper.getCustomizedStroke(getStringPref(\"stroke.hepler-line\", \"1\"));\n        refLineStroke = GuiHelper.getCustomizedStroke(getStringPref(\"stroke.ref-line\", \"1 2 2\"));\n        mainColor = new ColorProperty(marktr(\"make parallel helper line\"), (Color) null).get();\n        if (mainColor == null)\n            mainColor = PaintColors.SELECTED.get();\n\n        //// Needed to update the mouse cursor if modifiers are changed when the mouse is motionless\n        Main.map.keyDetector.addModifierListener(this);\n        sourceWays = new LinkedHashSet<>(getLayerManager().getEditDataSet().getSelectedWays());\n        for (Way w : sourceWays) {\n            w.setHighlighted(true);\n        }\n        mv.repaint();\n    }","id":84917,"modified_method":"@Override\n    public void enterMode() {\n        // super.enterMode() updates the status line and cursor so we need our state to be set correctly\n        setMode(Mode.NORMAL);\n        pWays = null;\n\n        super.enterMode();\n\n        mv.addMouseListener(this);\n        mv.addMouseMotionListener(this);\n        mv.addTemporaryLayer(this);\n\n        helpLineStroke = GuiHelper.getCustomizedStroke(HELPER_LINE_STROKE.get());\n        refLineStroke = GuiHelper.getCustomizedStroke(REF_LINE_STROKE.get());\n\n        //// Needed to update the mouse cursor if modifiers are changed when the mouse is motionless\n        Main.map.keyDetector.addModifierListener(this);\n        sourceWays = new LinkedHashSet<>(getLayerManager().getEditDataSet().getSelectedWays());\n        for (Way w : sourceWays) {\n            w.setHighlighted(true);\n        }\n        mv.repaint();\n    }","commit_id":"1132d58a68511bb1ee1fee17ee8e9c43630418e9","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void paintBorder(Component c, Graphics graphics, int x, int y, int width, int height) {\n      Graphics2D g = (Graphics2D)graphics;\n      final boolean hasFocus = c.hasFocus();\n      final boolean isDefault = DarculaButtonUI.isDefaultButton((JComponent)c);\n      if (hasFocus || isDefault) {\n        if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n            //todo\n        } else {\n          g.setColor(UIManager.getColor(\"Button.intellij.native.activeBorderColor\"));\n          g.setStroke(new BasicStroke(JBUI.scale(2f)));\n          g.translate(x,y);\n          g.drawRect(JBUI.scale(1), JBUI.scale(1), width-2*JBUI.scale(1), height-2*JBUI.scale(1));\n\n          if (hasFocus) {\n            g.setStroke(new BasicStroke(JBUI.scale(1f)));\n            g.setColor(Gray.x00);\n            UIUtil.drawDottedRectangle(g, JBUI.scale(1) + 1, JBUI.scale(1) + 1, width-2*JBUI.scale(1) - 1, height-2*JBUI.scale(1) - 1);\n          }\n          g.translate(-x,-y);\n        }\n      } else {\n        g.setColor(UIManager.getColor(\"Button.intellij.native.borderColor\"));\n        if (!DarculaButtonUI.isHelpButton((JComponent)c)) {\n          g.translate(x, y);\n          g.drawRect(0, 0, width - 1, height - 1);\n          g.translate(-x, -y);\n        }\n      }\n    }","id":84918,"modified_method":"@Override\n    public void paintBorder(Component c, Graphics graphics, int x, int y, int width, int height) {\n      Graphics2D g = (Graphics2D)graphics;\n      final boolean hasFocus = c.hasFocus();\n      final boolean isDefault = DarculaButtonUI.isDefaultButton((JComponent)c);\n      if (hasFocus || isDefault) {\n        if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n            //todo\n        } else {\n          g.setColor(UIManager.getColor(\"Button.intellij.native.activeBorderColor\"));\n          int d = JBUI.scale(1);\n          int dd = JBUI.scale(2);\n          final Area s1 = new Area(new Rectangle2D.Float(d, d, width - 2 * d, height - 2 * d));\n          final Area s2 = new Area(new Rectangle2D.Float(d + dd, d + dd, width - 2*d - 2*dd, height - 2*d - 2*dd));\n          s1.subtract(s2);\n          g.fill(s1);\n          g.translate(x,y);\n\n          if (hasFocus) {\n            g.setStroke(new BasicStroke(1, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 1, new float[]{1}, 1));\n            g.setColor(Gray.x0F);\n            g.drawRect(2*dd, 2*dd, width - 4*dd - 1, height - 4*dd - 1);\n          }\n          g.translate(-x,-y);\n        }\n      } else {\n        g.setColor(UIManager.getColor(\"Button.intellij.native.borderColor\"));\n        if (!DarculaButtonUI.isHelpButton((JComponent)c)) {\n          g.translate(x, y);\n          g.drawRect(0, 0, width - 1, height - 1);\n          g.translate(-x, -y);\n        }\n      }\n    }","commit_id":"396ee209b5d4fe81876e83e7c8c9bdba73de97b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeSpotlight(final JComponent component){\n    myLightComponents.remove(component);\n  }","id":84919,"modified_method":"public void removeSpotlight(final JComponent component){\n    myLightComponents.remove(component);\n    if (myLightComponents.isEmpty()) {\n      setVisible(false);\n    }\n  }","commit_id":"63a990847a72faadebde2527dc175c483593d3c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paintSpotlight(final Graphics g, final JComponent surfaceComponent) {\n    Dimension size = surfaceComponent.getSize();\n    if (myLightComponents.size() > 0) {\n      int width = size.width - 1;\n      int height = size.height - 1;\n\n      Rectangle2D screen = new Rectangle2D.Double(0, 0, width, height);\n      final Rectangle visibleRect = myPanel.getVisibleRect();\n      final Point leftPoint = SwingUtilities.convertPoint(myPanel, new Point(visibleRect.x, visibleRect.y), surfaceComponent);\n      Area innerPanel = new Area(new Rectangle2D.Double(leftPoint.x, leftPoint.y, visibleRect.width, visibleRect.height));\n      Area mask = new Area(screen);\n      ArrayList<JComponent> components = new ArrayList<JComponent>();\n      for (JComponent lightComponent : myLightComponents) {\n        final Area area = getComponentArea(surfaceComponent, lightComponent, 1);\n        if (area == null) continue;\n        components.add(lightComponent);\n\n        if (lightComponent instanceof JLabel) {\n          final JLabel label = (JLabel)lightComponent;\n          final Component labelFor = label.getLabelFor();\n          if (labelFor instanceof JComponent) {\n            final Area labelForArea = getComponentArea(surfaceComponent, (JComponent)labelFor, 1);\n            if (labelForArea != null) {\n              components.add((JComponent)labelFor);\n              area.add(labelForArea);\n            }\n          }\n        }\n\n        area.intersect(innerPanel);\n        mask.subtract(area);\n      }\n\n      Graphics2D g2 = (Graphics2D)g;\n\n      Color shieldColor = new Color(0.0f, 0.0f, 0.0f, 0.20f);\n      Color boundsColor = Color.gray;\n      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n      g2.setColor(shieldColor);\n      g2.fill(mask);\n\n      g2.setColor(ColorUtil.toAlpha(Color.orange, 25));\n      GraphicsConfig config = GraphicsUtil.setupAAPainting(g2);\n      for (int i = 2; i > 0; i--) {\n        g2.setStroke(new BasicStroke(i));\n        Area arrr = new Area();\n        for (JComponent component : components) {\n          Area area = getComponentArea(surfaceComponent, component, i-1);\n          if (area != null) {\n            arrr.add(area);\n          }\n        }\n        g2.draw(arrr);\n      }\n\n      config.restore();\n    }\n  }","id":84920,"modified_method":"public void paintSpotlight(final Graphics g, final JComponent surfaceComponent) {\n    Dimension size = surfaceComponent.getSize();\n    if (myLightComponents.size() > 0) {\n      int stroke = 2;\n\n      final Rectangle visibleRect = myPanel.getVisibleRect();\n      final Point leftPoint = SwingUtilities.convertPoint(myPanel, new Point(visibleRect.x, visibleRect.y), surfaceComponent);\n      Area innerPanel = new Area(new Rectangle2D.Double(leftPoint.x, leftPoint.y, visibleRect.width, visibleRect.height));\n      Area mask = new Area(new Rectangle(-stroke, -stroke, 2 * stroke + size.width, 2 * stroke + size.height));\n      for (JComponent lightComponent : myLightComponents) {\n        final Area area = getComponentArea(surfaceComponent, lightComponent, 1);\n        if (area == null) continue;\n\n        if (lightComponent instanceof JLabel) {\n          final JLabel label = (JLabel)lightComponent;\n          final Component labelFor = label.getLabelFor();\n          if (labelFor instanceof JComponent) {\n            final Area labelForArea = getComponentArea(surfaceComponent, (JComponent)labelFor, 1);\n            if (labelForArea != null) {\n              area.add(labelForArea);\n            }\n          }\n        }\n\n        area.intersect(innerPanel);\n        mask.subtract(area);\n      }\n      Graphics clip = g.create(0, 0, size.width, size.height);\n      try {\n        Graphics2D g2 = (Graphics2D)clip;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n\n        Color background = surfaceComponent.getBackground();\n        g2.setColor(ColorUtil.toAlpha(background == null ? null : background.darker(), 100));\n        g2.fill(mask);\n\n        g2.setStroke(new BasicStroke(stroke));\n        g2.setColor(ColorUtil.toAlpha(JBColor.ORANGE, 100));\n        g2.draw(mask);\n      }\n      finally {\n        clip.dispose();\n      }\n    }\n  }","commit_id":"63a990847a72faadebde2527dc175c483593d3c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProjectLayoutPanel(final ModuleInsight insight) {\n    super(new BorderLayout());\n    myInsight = insight;\n\n    myEntriesChooser = new ElementsChooser<T>(true) {\n      public String getItemText(@NotNull T element) {\n        return getElementText(element);\n      }\n    };\n    myDependenciesList = createList();\n\n    final Splitter splitter = new Splitter(false);\n\n    final JScrollPane entriesPane = ScrollPaneFactory.createScrollPane(myEntriesChooser);\n    entriesPane.setBorder(IdeBorderFactory.createTitledBorder(getEntriesChooserTitle(), false, false, true));\n    splitter.setFirstComponent(entriesPane);\n\n    final JScrollPane depsPane = ScrollPaneFactory.createScrollPane(myDependenciesList);\n    depsPane.setBorder(BorderFactory.createCompoundBorder(IdeBorderFactory.createTitledBorder(getDependenciesTitle(), true, true, true), depsPane.getBorder()));\n    splitter.setSecondComponent(depsPane);\n    \n    JPanel groupPanel = new JPanel(new BorderLayout());\n    groupPanel.add(createEntriesActionToolbar().getComponent(), BorderLayout.NORTH);\n    groupPanel.add(splitter, BorderLayout.CENTER);\n    groupPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n\n    final MultiLineLabel description = new MultiLineLabel(getStepDescriptionText());\n    description.setBorder(BorderFactory.createEmptyBorder(5, 5, 0, 5));\n    add(description, BorderLayout.NORTH);\n    add(groupPanel, BorderLayout.CENTER);\n    \n    myEntriesChooser.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final List<T> entries = getSelectedEntries();\n        final Collection deps = getDependencies(entries);\n\n        final DefaultListModel depsModel = (DefaultListModel)myDependenciesList.getModel();\n        depsModel.clear();\n        for (Object dep : alphaSortList(new ArrayList(deps))) {\n          depsModel.addElement(dep);\n        }\n      }\n    });\n  }","id":84921,"modified_method":"public ProjectLayoutPanel(final ModuleInsight insight) {\n    super(new BorderLayout());\n    setBorder(BorderFactory.createEmptyBorder(5, 5, 0, 5));\n    myInsight = insight;\n\n    myEntriesChooser = new ElementsChooser<T>(true) {\n      public String getItemText(@NotNull T element) {\n        return getElementText(element);\n      }\n    };\n    myDependenciesList = createList();\n\n    final Splitter splitter = new Splitter(false);\n\n    final JScrollPane entriesPane = ScrollPaneFactory.createScrollPane(myEntriesChooser);\n    final JPanel entriesPanel = new JPanel(new BorderLayout());\n    entriesPanel.add(entriesPane, BorderLayout.CENTER);\n    entriesPanel.setBorder(IdeBorderFactory.createTitledBorder(getEntriesChooserTitle(), false, false, true));\n    splitter.setFirstComponent(entriesPanel);\n\n    final JScrollPane depsPane = ScrollPaneFactory.createScrollPane(myDependenciesList);\n    final JPanel depsPanel = new JPanel(new BorderLayout());\n    depsPanel.add(depsPane, BorderLayout.CENTER);\n    depsPanel.setBorder(IdeBorderFactory.createTitledBorder(getDependenciesTitle(), false, false, true));\n    splitter.setSecondComponent(depsPanel);\n    \n    JPanel groupPanel = new JPanel(new BorderLayout());\n    groupPanel.add(createEntriesActionToolbar().getComponent(), BorderLayout.NORTH);\n    groupPanel.add(splitter, BorderLayout.CENTER);\n    groupPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n\n    final MultiLineLabel description = new MultiLineLabel(getStepDescriptionText());\n    add(description, BorderLayout.NORTH);\n    add(groupPanel, BorderLayout.CENTER);\n    \n    myEntriesChooser.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final List<T> entries = getSelectedEntries();\n        final Collection deps = getDependencies(entries);\n\n        final DefaultListModel depsModel = (DefaultListModel)myDependenciesList.getModel();\n        depsModel.clear();\n        for (Object dep : alphaSortList(new ArrayList(deps))) {\n          depsModel.addElement(dep);\n        }\n      }\n    });\n  }","commit_id":"6dc7e9bdcca43e5561481cd0a945d4b7c4be8a99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProjectLayoutPanel(final ModuleInsight insight) {\n    super(new BorderLayout());\n    myInsight = insight;\n\n    myEntriesChooser = new ElementsChooser<T>(true) {\n      public String getItemText(@NotNull T element) {\n        return getElementText(element);\n      }\n    };\n    myDependenciesList = createList();\n\n    final Splitter splitter = new Splitter(false);\n\n    final JScrollPane entriesPane = ScrollPaneFactory.createScrollPane(myEntriesChooser);\n    entriesPane.setBorder(IdeBorderFactory.createTitledBorder(getEntriesChooserTitle(), false, false, true));\n    splitter.setFirstComponent(entriesPane);\n\n    final JScrollPane depsPane = ScrollPaneFactory.createScrollPane(myDependenciesList);\n    depsPane.setBorder(BorderFactory.createCompoundBorder(IdeBorderFactory.createTitledBorder(getDependenciesTitle(), true, true, true), depsPane.getBorder()));\n    splitter.setSecondComponent(depsPane);\n    \n    JPanel groupPanel = new JPanel(new BorderLayout());\n    groupPanel.add(createEntriesActionToolbar().getComponent(), BorderLayout.NORTH);\n    groupPanel.add(splitter, BorderLayout.CENTER);\n    groupPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n\n    final MultiLineLabel description = new MultiLineLabel(getStepDescriptionText());\n    description.setBorder(BorderFactory.createEmptyBorder(5, 5, 0, 5));\n    add(description, BorderLayout.NORTH);\n    add(groupPanel, BorderLayout.CENTER);\n    \n    myEntriesChooser.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final List<T> entries = getSelectedEntries();\n        final Collection deps = getDependencies(entries);\n\n        final DefaultListModel depsModel = (DefaultListModel)myDependenciesList.getModel();\n        depsModel.clear();\n        for (Object dep : alphaSortList(new ArrayList(deps))) {\n          depsModel.addElement(dep);\n        }\n      }\n    });\n  }","id":84922,"modified_method":"public ProjectLayoutPanel(final ModuleInsight insight) {\n    super(new BorderLayout());\n    setBorder(BorderFactory.createEmptyBorder(5, 5, 0, 5));\n    myInsight = insight;\n\n    myEntriesChooser = new ElementsChooser<T>(true) {\n      public String getItemText(@NotNull T element) {\n        return getElementText(element);\n      }\n    };\n    myDependenciesList = createList();\n\n    final Splitter splitter = new Splitter(false);\n\n    final JScrollPane entriesPane = ScrollPaneFactory.createScrollPane(myEntriesChooser);\n    final JPanel entriesPanel = new JPanel(new BorderLayout());\n    entriesPanel.add(entriesPane, BorderLayout.CENTER);\n    entriesPanel.setBorder(IdeBorderFactory.createTitledBorder(getEntriesChooserTitle(), false, false, true));\n    splitter.setFirstComponent(entriesPanel);\n\n    final JScrollPane depsPane = ScrollPaneFactory.createScrollPane(myDependenciesList);\n    final JPanel depsPanel = new JPanel(new BorderLayout());\n    depsPanel.add(depsPane, BorderLayout.CENTER);\n    depsPanel.setBorder(IdeBorderFactory.createTitledBorder(getDependenciesTitle(), false, false, true));\n    splitter.setSecondComponent(depsPanel);\n    \n    JPanel groupPanel = new JPanel(new BorderLayout());\n    groupPanel.add(createEntriesActionToolbar().getComponent(), BorderLayout.NORTH);\n    groupPanel.add(splitter, BorderLayout.CENTER);\n    groupPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n\n    final MultiLineLabel description = new MultiLineLabel(getStepDescriptionText());\n    add(description, BorderLayout.NORTH);\n    add(groupPanel, BorderLayout.CENTER);\n    \n    myEntriesChooser.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final List<T> entries = getSelectedEntries();\n        final Collection deps = getDependencies(entries);\n\n        final DefaultListModel depsModel = (DefaultListModel)myDependenciesList.getModel();\n        depsModel.clear();\n        for (Object dep : alphaSortList(new ArrayList(deps))) {\n          depsModel.addElement(dep);\n        }\n      }\n    });\n  }","commit_id":"a714d31f3e7fbcc0932a342a43b0205b871b414a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public KeyboardShortcutDialog(Component component, String actionId, final QuickList[] quickLists) {\n    super(component, true);\n    setTitle(KeyMapBundle.message(\"keyboard.shortcut.dialog.title\"));\n    myActionId = actionId;\n    final Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(component));\n    myMainGroup = ActionsTreeUtil.createMainGroup(project, myKeymap, quickLists, null, false, null); //without current filter\n    myEnableSecondKeystroke = new JCheckBox(KeyMapBundle.message(\"enable.second.keystroke.check.box\"));\n    myEnableSecondKeystroke.setFocusable(false);\n    myKeystrokePreview = new JLabel(\" \");\n    myConflictInfoArea = new JTextArea(\"\");\n    myConflictInfoArea.setFocusable(false);\n    init();\n  }","id":84923,"modified_method":"public KeyboardShortcutDialog(Component component, String actionId, final QuickList[] quickLists) {\n    super(component, true);\n    setTitle(KeyMapBundle.message(\"keyboard.shortcut.dialog.title\"));\n    myActionId = actionId;\n    final Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(component));\n    myMainGroup = ActionsTreeUtil.createMainGroup(project, myKeymap, quickLists, null, false, null); //without current filter\n    myEnableSecondKeystroke = new JCheckBox();\n    UIUtil.applyStyle(UIUtil.ComponentStyle.SMALL, myEnableSecondKeystroke);\n    myEnableSecondKeystroke.setBorder(new EmptyBorder(4, 0, 0, 2));\n    myEnableSecondKeystroke.setFocusable(false);\n    myKeystrokePreview = new JLabel(\" \");\n    myConflictInfoArea = new JTextArea(\"\");\n    myConflictInfoArea.setFocusable(false);\n    init();\n  }","commit_id":"d6a92e7e0b5efefcc97e94c8ff475b62fa9b79f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel(new GridBagLayout());\n\n    // First stroke\n\n    myFirstStrokePanel = new StrokePanel(KeyMapBundle.message(\"first.stroke.panel.title\"));\n    panel.add(\n      myFirstStrokePanel,\n      new GridBagConstraints(0,0,1,1,1,0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0)\n    );\n\n    // Second stroke panel\n\n    panel.add(\n      myEnableSecondKeystroke,\n      new GridBagConstraints(0,1,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0)\n    );\n\n    mySecondStrokePanel = new StrokePanel(KeyMapBundle.message(\"second.stroke.panel.title\"));\n    panel.add(\n      mySecondStrokePanel,\n      new GridBagConstraints(0,2,1,1,1,0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,30,0,0),0,0)\n    );\n\n    // Shortcut preview\n\n    JPanel previewPanel = new JPanel(new BorderLayout());\n    previewPanel.setBorder(\n      BorderFactory.createCompoundBorder(\n        IdeBorderFactory.createTitledBorder(KeyMapBundle.message(\"shortcut.preview.ide.border.factory.title\"), false, true, true),\n        BorderFactory.createEmptyBorder(5,5,5,5)\n      )\n    );\n    previewPanel.add(myKeystrokePreview);\n    panel.add(\n      previewPanel,\n      new GridBagConstraints(0,3,1,1,1,0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0)\n    );\n\n    // Conflicts\n\n    JPanel conflictsPanel = new JPanel(new BorderLayout());\n    conflictsPanel.setBorder(IdeBorderFactory.createTitledBorder(KeyMapBundle.message(\"conflicts.ide.border.factory.title\"),\n                                                                 false, true, true));\n    myConflictInfoArea.setEditable(false);\n    myConflictInfoArea.setBackground(panel.getBackground());\n    myConflictInfoArea.setLineWrap(true);\n    myConflictInfoArea.setWrapStyleWord(true);\n    final JScrollPane conflictInfoScroll = ScrollPaneFactory.createScrollPane(myConflictInfoArea);\n    conflictInfoScroll.setPreferredSize(new Dimension(260, 60));\n    conflictInfoScroll.setBorder(null);\n    conflictsPanel.add(conflictInfoScroll);\n    panel.add(\n      conflictsPanel,\n      new GridBagConstraints(0,4,1,1,1,1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0)\n    );\n\n    myEnableSecondKeystroke.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        handleSecondKey();\n        updateCurrentKeyStrokeInfo();\n\n        /** TODO[anton]????  */\n        if (myEnableSecondKeystroke.isSelected()) {\n          mySecondStrokePanel.getShortcutTextField().requestFocus();\n        }\n        else {\n          myFirstStrokePanel.getShortcutTextField().requestFocus();\n        }\n      }\n    });\n    return panel;\n  }","id":84924,"modified_method":"protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel(new GridBagLayout());\n\n    // First stroke\n\n    myFirstStrokePanel = new StrokePanel(KeyMapBundle.message(\"first.stroke.panel.title\"));\n    panel.add(\n      myFirstStrokePanel,\n      new GridBagConstraints(0,0,2,1,1,0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0)\n    );\n\n    // Second stroke panel\n\n    panel.add(\n      myEnableSecondKeystroke,\n      new GridBagConstraints(0,1,1,1,0,0,GridBagConstraints.NORTHWEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0)\n    );\n\n    mySecondStrokePanel = new StrokePanel(KeyMapBundle.message(\"second.stroke.panel.title\"));\n    panel.add(\n      mySecondStrokePanel,\n      new GridBagConstraints(1,1,1,1,1,0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0)\n    );\n\n    // Shortcut preview\n\n    JPanel previewPanel = new JPanel(new BorderLayout());\n    previewPanel.setBorder(IdeBorderFactory.createTitledBorder(KeyMapBundle.message(\"shortcut.preview.ide.border.factory.title\"), false, true, true));\n    previewPanel.add(myKeystrokePreview);\n    panel.add(\n      previewPanel,\n      new GridBagConstraints(0,2,2,1,1,0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0)\n    );\n\n    // Conflicts\n\n    JPanel conflictsPanel = new JPanel(new BorderLayout());\n    conflictsPanel.setBorder(IdeBorderFactory.createTitledBorder(KeyMapBundle.message(\"conflicts.ide.border.factory.title\"),\n                                                                 false, true, true));\n    myConflictInfoArea.setEditable(false);\n    myConflictInfoArea.setBackground(panel.getBackground());\n    myConflictInfoArea.setLineWrap(true);\n    myConflictInfoArea.setWrapStyleWord(true);\n    final JScrollPane conflictInfoScroll = ScrollPaneFactory.createScrollPane(myConflictInfoArea);\n    conflictInfoScroll.setPreferredSize(new Dimension(260, 60));\n    conflictInfoScroll.setBorder(null);\n    conflictsPanel.add(conflictInfoScroll);\n    panel.add(\n      conflictsPanel,\n      new GridBagConstraints(0,3,2,1,1,1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0)\n    );\n\n    myEnableSecondKeystroke.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        handleSecondKey();\n        updateCurrentKeyStrokeInfo();\n\n        /** TODO[anton]????  */\n        if (myEnableSecondKeystroke.isSelected()) {\n          mySecondStrokePanel.getShortcutTextField().requestFocus();\n        }\n        else {\n          myFirstStrokePanel.getShortcutTextField().requestFocus();\n        }\n      }\n    });\n    return panel;\n  }","commit_id":"d6a92e7e0b5efefcc97e94c8ff475b62fa9b79f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StrokePanel(String borderText) {\n      setLayout(new BorderLayout());\n      setBorder(\n        BorderFactory.createCompoundBorder(\n          IdeBorderFactory.createTitledBorder(borderText, false, true, true),\n          BorderFactory.createEmptyBorder(5,5,5,5)\n        )\n      );\n\n      myShortcutTextField = new ShortcutTextField(){\n        protected void updateCurrentKeyStrokeInfo() {\n          KeyboardShortcutDialog.this.updateCurrentKeyStrokeInfo();\n        }\n      };\n      add(myShortcutTextField);\n    }","id":84925,"modified_method":"public StrokePanel(String borderText) {\n      setLayout(new BorderLayout());\n      setBorder(IdeBorderFactory.createTitledBorder(borderText, false, false, true));\n\n      myShortcutTextField = new ShortcutTextField(){\n        protected void updateCurrentKeyStrokeInfo() {\n          KeyboardShortcutDialog.this.updateCurrentKeyStrokeInfo();\n        }\n      };\n      add(myShortcutTextField);\n    }","commit_id":"d6a92e7e0b5efefcc97e94c8ff475b62fa9b79f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Bulk-indexes/persists messages to ElasticSearch.\n     * http://www.elasticsearch.org/guide/reference/api/bulk.html\n     *\n     * @param message The message to index.\n     * @return\n     */\n    public static boolean bulkIndex(List<GELFMessage> messages) {\n        if (messages.isEmpty()) {\n            return true;\n        }\n        \n        StringBuilder batchFactory = new StringBuilder();\n\n        for (GELFMessage message : messages) {\n            batchFactory.append(\"{\\\"index\\\":{\\\"_index\\\":\\\"\");\n            batchFactory.append(INDEX);\n            batchFactory.append(\"\\\",\\\"_type\\\":\\\"\");\n            batchFactory.append(TYPE);\n            batchFactory.append(\"\\\"}}\\n\");\n            batchFactory.append(JSONValue.toJSONString(message.toElasticSearchObject()));\n            batchFactory.append(\"\\n\");\n        }\n\n        try {\n            URL url = new URL(buildElasticSearchURL() + \"_bulk\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(batchFactory.toString());\n            writer.close();\n            if (conn.getResponseCode() == 200) {\n                return true;\n            } else {\n                LOG.warn(\"Indexer response code was not 200, but \" + conn.getResponseCode());\n                return false; \n            }\n        } catch (IOException e) {\n            LOG.warn(\"IO error when trying to index messages: \" + e.getMessage(), e);\n        }\n\n        // Not reached.\n        return false;\n    }","id":84926,"modified_method":"/**\n     * Bulk-indexes/persists messages to ElasticSearch.\n     * <p/>\n     * See <a href=\"http://www.elasticsearch.org/guide/reference/api/bulk.html\">elasticsearch Bulk API<\/a> for details\n     *\n     * @param messages The messages to index\n     * @return {@literal true} if the messages were successfully indexed, {@literal false} otherwise\n     */\n    public static boolean bulkIndex(List<GELFMessage> messages) {\n\n        if (messages.isEmpty()) {\n            return true;\n        }\n\n        Writer writer = null;\n        int responseCode = 0;\n\n        try {\n            URL url = new URL(buildElasticSearchURL() + \"_bulk\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n\n            writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(getJSONfromGELFMessages(messages));\n            writer.flush();\n\n            responseCode = conn.getResponseCode();\n        } catch (IOException e) {\n            LOG.warn(\"IO error when trying to index messages\", e);\n        } finally {\n            if (null != writer) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    LOG.error(\"Couldn't close output stream\", e);\n                }\n            }\n        }\n\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        } else {\n            LOG.warn(\"Indexer response code was not 200, but \" + responseCode);\n            return false;\n        }\n    }","commit_id":"5c3ff53b4589881bc7361f5e74429f38d0b08531","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Checks if the index exists.\n     * \n     * http://www.elasticsearch.org/guide/reference/api/admin-indices-indices-exists.html\n     */\n    public static boolean indexExists() throws IOException {\n        URL url = new URL(Indexer.buildIndexURL());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"HEAD\");\n        if (conn.getResponseCode() == 200) {\n            return true;\n        } else {\n            if (conn.getResponseCode() != 404) {\n                LOG.warn(\"Indexer response code was not 200 or 404, but \" + conn.getResponseCode());\n            }\n\n            return false;\n        }\n    }","id":84927,"modified_method":"/**\n     * Checks if the index for Graylog2 exists\n     * <p/>\n     * See <a href=\"http://www.elasticsearch.org/guide/reference/api/admin-indices-indices-exists.html\">elasticsearch Indices Exists API<\/a> for details.\n     *\n     * @return {@literal true} if the index for Graylog2 exists, {@literal false} otherwise\n     * @throws IOException if elasticsearch server couldn't be reached\n     */\n    public static boolean indexExists() throws IOException {\n        URL url = new URL(Indexer.buildIndexURL());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"HEAD\");\n        if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            return true;\n        } else {\n            if (conn.getResponseCode() != HttpURLConnection.HTTP_NOT_FOUND) {\n                LOG.warn(\"Indexer response code was not 200 or 404, but \" + conn.getResponseCode());\n            }\n\n            return false;\n        }\n    }","commit_id":"5c3ff53b4589881bc7361f5e74429f38d0b08531","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Creates the index including the mapping.\n     *\n     * http://www.elasticsearch.org/guide/reference/api/admin-indices-create-index.html\n     * http://www.elasticsearch.org/guide/reference/mapping\n     */\n    public static boolean createIndex() throws IOException {\n        URL url = new URL(Indexer.buildIndexURL());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setRequestMethod(\"POST\");\n        OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n        // Write Mapping.\n        writer.write(JSONValue.toJSONString(Mapping.get()));\n        writer.close();\n        if (conn.getResponseCode() == 200) {\n            return true;\n        } else {\n            LOG.warn(\"Response code of create index operation was not 200, but \" + conn.getResponseCode());\n            return false;\n        }\n    }","id":84928,"modified_method":"/**\n     * Creates the index for Graylog2 including the mapping\n     * <p/>\n     * <a href=\"http://www.elasticsearch.org/guide/reference/api/admin-indices-create-index.html\">Create Index API<\/a> and\n     * <a href=\"http://www.elasticsearch.org/guide/reference/mapping\">elasticsearch Mapping<\/a>\n     *\n     * @return {@literal true} if the index for Graylog2 could be created, {@literal false} otherwise\n     * @throws IOException if elasticsearch server couldn't be reached\n     */\n    public static boolean createIndex() throws IOException {\n\n        Writer writer = null;\n        URL url = new URL(Indexer.buildIndexURL());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setRequestMethod(\"POST\");\n\n        try {\n            writer = new OutputStreamWriter(conn.getOutputStream());\n\n            // Write Mapping.\n            writer.write(JSONValue.toJSONString(Mapping.get()));\n\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                return true;\n            } else {\n                LOG.warn(\"Response code of create index operation was not 200, but \" + conn.getResponseCode());\n                return false;\n            }\n        } finally {\n            if (null != writer) {\n                writer.close();\n            }\n        }\n    }","commit_id":"5c3ff53b4589881bc7361f5e74429f38d0b08531","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n   * Helper method that extracts an authentication token received from a connection.\n   * <p/>\n   * This method is used by {@link Authenticator} implementations.\n   *\n   * @param conn connection to extract the authentication token from.\n   * @param token the authentication token.\n   *\n   * @throws IOException if an IO error occurred.\n   * @throws AuthenticationException if an authentication exception occurred.\n   */\n  public static void extractToken(HttpURLConnection conn, Token token) throws IOException, AuthenticationException {\n    if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      Map<String, List<String>> headers = conn.getHeaderFields();\n      List<String> cookies = headers.get(\"Set-Cookie\");\n      if (cookies != null) {\n        for (String cookie : cookies) {\n          if (cookie.startsWith(AUTH_COOKIE_EQ)) {\n            String value = cookie.substring(AUTH_COOKIE_EQ.length());\n            int separator = value.indexOf(\";\");\n            if (separator > -1) {\n              value = value.substring(0, separator);\n            }\n            if (value.length() > 0) {\n              token.set(value);\n            }\n          }\n        }\n      }\n    } else {\n      token.set(null);\n      throw new AuthenticationException(\"Authentication failed, status: \" + conn.getResponseCode() +\n                                        \", message: \" + conn.getResponseMessage());\n    }\n  }","id":84929,"modified_method":"/**\n   * Helper method that extracts an authentication token received from a connection.\n   * <p/>\n   * This method is used by {@link Authenticator} implementations.\n   *\n   * @param conn connection to extract the authentication token from.\n   * @param token the authentication token.\n   *\n   * @throws IOException if an IO error occurred.\n   * @throws AuthenticationException if an authentication exception occurred.\n   */\n  public static void extractToken(HttpURLConnection conn, Token token) throws IOException, AuthenticationException {\n    int respCode = conn.getResponseCode();\n    if (respCode == HttpURLConnection.HTTP_OK\n        || respCode == HttpURLConnection.HTTP_CREATED\n        || respCode == HttpURLConnection.HTTP_ACCEPTED) {\n      Map<String, List<String>> headers = conn.getHeaderFields();\n      List<String> cookies = headers.get(\"Set-Cookie\");\n      if (cookies != null) {\n        for (String cookie : cookies) {\n          if (cookie.startsWith(AUTH_COOKIE_EQ)) {\n            String value = cookie.substring(AUTH_COOKIE_EQ.length());\n            int separator = value.indexOf(\";\");\n            if (separator > -1) {\n              value = value.substring(0, separator);\n            }\n            if (value.length() > 0) {\n              token.set(value);\n            }\n          }\n        }\n      }\n    } else {\n      token.set(null);\n      throw new AuthenticationException(\"Authentication failed, status: \" + conn.getResponseCode() +\n                                        \", message: \" + conn.getResponseMessage());\n    }\n  }","commit_id":"2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e","url":"https://github.com/apache/hadoop"},{"original_method":"public KMSClientProvider(URI uri, Configuration conf) throws IOException {\n    super(conf);\n    Path path = ProviderUtils.unnestUri(uri);\n    URL url = path.toUri().toURL();\n    kmsUrl = createServiceURL(url);\n    if (\"https\".equalsIgnoreCase(url.getProtocol())) {\n      sslFactory = new SSLFactory(SSLFactory.Mode.CLIENT, conf);\n      try {\n        sslFactory.init();\n      } catch (GeneralSecurityException ex) {\n        throw new IOException(ex);\n      }\n    }\n    int timeout = conf.getInt(TIMEOUT_ATTR, DEFAULT_TIMEOUT);\n    configurator = new TimeoutConnConfigurator(timeout, sslFactory);\n    encKeyVersionQueue =\n        new ValueQueue<KeyProviderCryptoExtension.EncryptedKeyVersion>(\n            conf.getInt(\n                CommonConfigurationKeysPublic.KMS_CLIENT_ENC_KEY_CACHE_SIZE,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_SIZE_DEFAULT),\n            conf.getFloat(\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK_DEFAULT),\n            conf.getInt(\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_MS,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_DEFAULT),\n            conf.getInt(\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS_DEFAULT),\n            new EncryptedQueueRefiller());\n    authToken = new DelegationTokenAuthenticatedURL.Token();\n    loginUgi = UserGroupInformation.getCurrentUser();\n  }","id":84930,"modified_method":"public KMSClientProvider(URI uri, Configuration conf) throws IOException {\n    super(conf);\n    Path path = ProviderUtils.unnestUri(uri);\n    URL url = path.toUri().toURL();\n    kmsUrl = createServiceURL(url);\n    if (\"https\".equalsIgnoreCase(url.getProtocol())) {\n      sslFactory = new SSLFactory(SSLFactory.Mode.CLIENT, conf);\n      try {\n        sslFactory.init();\n      } catch (GeneralSecurityException ex) {\n        throw new IOException(ex);\n      }\n    }\n    int timeout = conf.getInt(TIMEOUT_ATTR, DEFAULT_TIMEOUT);\n    authRetry = conf.getInt(AUTH_RETRY, DEFAULT_AUTH_RETRY);\n    configurator = new TimeoutConnConfigurator(timeout, sslFactory);\n    encKeyVersionQueue =\n        new ValueQueue<KeyProviderCryptoExtension.EncryptedKeyVersion>(\n            conf.getInt(\n                CommonConfigurationKeysPublic.KMS_CLIENT_ENC_KEY_CACHE_SIZE,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_SIZE_DEFAULT),\n            conf.getFloat(\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK_DEFAULT),\n            conf.getInt(\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_MS,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_DEFAULT),\n            conf.getInt(\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS,\n                CommonConfigurationKeysPublic.\n                    KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS_DEFAULT),\n            new EncryptedQueueRefiller());\n    authToken = new DelegationTokenAuthenticatedURL.Token();\n    loginUgi = UserGroupInformation.getCurrentUser();\n  }","commit_id":"2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e","url":"https://github.com/apache/hadoop"},{"original_method":"private <T> T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class<T> klass)\n      throws IOException {\n    T ret = null;\n    try {\n      if (jsonOutput != null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if (conn.getResponseCode() == HttpURLConnection.HTTP_FORBIDDEN) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken =\n          new DelegationTokenAuthenticatedURL.Token();\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        && klass != null) {\n      ObjectMapper mapper = new ObjectMapper();\n      InputStream is = null;\n      try {\n        is = conn.getInputStream();\n        ret = mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is != null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is != null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }","id":84931,"modified_method":"private <T> T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class<T> klass) throws IOException {\n    return call(conn, jsonOutput, expectedResponse, klass, authRetry);\n  }","commit_id":"2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testKMSRestart() throws Exception {\n    Configuration conf = new Configuration();\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\n    UserGroupInformation.setConfiguration(conf);\n    final File testDir = getTestDir();\n    conf = createBaseKMSConf(testDir);\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\",\n        keytab.getAbsolutePath());\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\n\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\n      conf.set(type.getAclConfigKey(), type.toString());\n    }\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(),\n        KMSACLs.Type.CREATE.toString() + \",SET_KEY_MATERIAL\");\n\n    conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(),\n        KMSACLs.Type.ROLLOVER.toString() + \",SET_KEY_MATERIAL\");\n\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k0.ALL\", \"*\");\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k2.ALL\", \"*\");\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k3.ALL\", \"*\");\n\n    writeConf(testDir, conf);\n\n    KMSCallable<KeyProvider> c =\n        new KMSCallable<KeyProvider>() {\n      @Override\n      public KeyProvider call() throws Exception {\n        final Configuration conf = new Configuration();\n        conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\n        final URI uri = createKMSUri(getKMSUrl());\n\n        final KeyProvider kp =\n            doAs(\"SET_KEY_MATERIAL\",\n                new PrivilegedExceptionAction<KeyProvider>() {\n                  @Override\n                  public KeyProvider run() throws Exception {\n                    KMSClientProvider kp = new KMSClientProvider(uri, conf);\n                        kp.createKey(\"k1\", new byte[16],\n                            new KeyProvider.Options(conf));\n                    return kp;\n                  }\n                });\n        return kp;\n      }\n    };\n\n    final KeyProvider retKp =\n        runServer(null, null, testDir, c);\n\n    // Restart server (using the same port)\n    runServer(c.getKMSUrl().getPort(), null, null, testDir,\n        new KMSCallable<Void>() {\n          @Override\n          public Void call() throws Exception {\n            final Configuration conf = new Configuration();\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\n            doAs(\"SET_KEY_MATERIAL\",\n                new PrivilegedExceptionAction<Void>() {\n                  @Override\n                  public Void run() throws Exception {\n                    try {\n                      retKp.createKey(\"k2\", new byte[16],\n                          new KeyProvider.Options(conf));\n                      Assert.fail(\"Should fail first time !!\");\n                    } catch (IOException e) {\n                      String message = e.getMessage();\n                      Assert.assertTrue(\"Should be a 403 error : \" + message,\n                          message.contains(\"403\"));\n                    }\n                    retKp.createKey(\"k2\", new byte[16],\n                        new KeyProvider.Options(conf));\n                    retKp.createKey(\"k3\", new byte[16],\n                        new KeyProvider.Options(conf));\n                    return null;\n                  }\n                });\n            return null;\n          }\n        });\n  }","id":84932,"modified_method":"@Test\n  public void testKMSRestartKerberosAuth() throws Exception {\n    doKMSRestart(true);\n  }","commit_id":"2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e","url":"https://github.com/apache/hadoop"},{"original_method":"private static void defineBranchCoverageRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.INSUFFICIENT_BRANCH_COVERAGE);\n    rule.setName(\"Branches should have sufficient coverage by unit tests\")\n      .addTags(\"bad-practice\")\n      .setHtmlDescription(\"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.\"\n        + \"It gives the number of branches to be covered in order to reach the required threshold.\")\n      .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.UNIT_TESTABILITY)\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"5min\"))\n      .setEffortToFixDescription(\"number of uncovered conditions\")\n      .setSeverity(Severity.MAJOR);\n    rule.createParam(CommonRuleKeys.INSUFFICIENT_BRANCH_COVERAGE_PROPERTY)\n      .setName(\"The minimum required branch coverage ratio\")\n      .setDefaultValue(\"65\")\n      .setType(RuleParamType.FLOAT);\n  }","id":84933,"modified_method":"private static void defineBranchCoverageRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.INSUFFICIENT_BRANCH_COVERAGE);\n    rule.setName(\"Branches should have sufficient coverage by unit tests\")\n      .addTags(\"bad-practice\")\n      .setHtmlDescription(\"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.\"\n        + \"It gives the number of branches to be covered in order to reach the required threshold.\")\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"5min\"))\n      .setEffortToFixDescription(\"number of uncovered conditions\")\n      .setSeverity(Severity.MAJOR);\n    rule.createParam(CommonRuleKeys.INSUFFICIENT_BRANCH_COVERAGE_PROPERTY)\n      .setName(\"The minimum required branch coverage ratio\")\n      .setDefaultValue(\"65\")\n      .setType(RuleParamType.FLOAT);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void defineLineCoverageRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.INSUFFICIENT_LINE_COVERAGE);\n    rule.setName(\"Lines should have sufficient coverage by unit tests\")\n      .addTags(\"bad-practice\")\n      .setHtmlDescription(\"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. \" +\n        \"It gives the number of lines to be covered in order to reach the required threshold.\")\n      .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.UNIT_TESTABILITY)\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"2min\"))\n      .setEffortToFixDescription(\"number of lines under the coverage threshold\")\n      .setSeverity(Severity.MAJOR);\n    rule.createParam(CommonRuleKeys.INSUFFICIENT_LINE_COVERAGE_PROPERTY)\n      .setName(\"The minimum required line coverage ratio\")\n      .setDefaultValue(\"65\")\n      .setType(RuleParamType.FLOAT);\n  }","id":84934,"modified_method":"private static void defineLineCoverageRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.INSUFFICIENT_LINE_COVERAGE);\n    rule.setName(\"Lines should have sufficient coverage by unit tests\")\n      .addTags(\"bad-practice\")\n      .setHtmlDescription(\"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. \" +\n        \"It gives the number of lines to be covered in order to reach the required threshold.\")\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"2min\"))\n      .setEffortToFixDescription(\"number of lines under the coverage threshold\")\n      .setSeverity(Severity.MAJOR);\n    rule.createParam(CommonRuleKeys.INSUFFICIENT_LINE_COVERAGE_PROPERTY)\n      .setName(\"The minimum required line coverage ratio\")\n      .setDefaultValue(\"65\")\n      .setType(RuleParamType.FLOAT);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void defineCommentDensityRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.INSUFFICIENT_COMMENT_DENSITY);\n    rule.setName(\"Source files should have a sufficient density of comment lines\")\n      .addTags(\"convention\")\n      .setHtmlDescription(\"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. \" +\n        \"The number of comment lines to be written in order to reach the required threshold is provided by each issue message.\")\n      .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.UNDERSTANDABILITY)\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"2min\"))\n      .setEffortToFixDescription(\"number of lines required to meet minimum density\")\n      .setSeverity(Severity.MAJOR);\n    rule.createParam(CommonRuleKeys.INSUFFICIENT_COMMENT_DENSITY_PROPERTY)\n      .setName(\"The minimum required comment density\")\n      .setDefaultValue(\"25\")\n      .setType(RuleParamType.FLOAT);\n  }","id":84935,"modified_method":"private static void defineCommentDensityRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.INSUFFICIENT_COMMENT_DENSITY);\n    rule.setName(\"Source files should have a sufficient density of comment lines\")\n      .addTags(\"convention\")\n      .setHtmlDescription(\"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. \" +\n        \"The number of comment lines to be written in order to reach the required threshold is provided by each issue message.\")\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"2min\"))\n      .setEffortToFixDescription(\"number of lines required to meet minimum density\")\n      .setSeverity(Severity.MAJOR);\n    rule.createParam(CommonRuleKeys.INSUFFICIENT_COMMENT_DENSITY_PROPERTY)\n      .setName(\"The minimum required comment density\")\n      .setDefaultValue(\"25\")\n      .setType(RuleParamType.FLOAT);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void defineFailedUnitTestRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.FAILED_UNIT_TESTS);\n    rule\n      .setName(\"Failed unit tests should be fixed\")\n      .addTags(\"bug\")\n      .setHtmlDescription(\n        \"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions.\")\n      .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.UNIT_TESTABILITY)\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"10min\"))\n      .setEffortToFixDescription(\"number of failed tests\")\n      .setSeverity(Severity.MAJOR);\n  }","id":84936,"modified_method":"private static void defineFailedUnitTestRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.FAILED_UNIT_TESTS);\n    rule\n      .setName(\"Failed unit tests should be fixed\")\n      .addTags(\"bug\")\n      .setHtmlDescription(\n        \"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions.\")\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"10min\"))\n      .setEffortToFixDescription(\"number of failed tests\")\n      .setSeverity(Severity.MAJOR);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void defineDuplicatedBlocksRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.DUPLICATED_BLOCKS);\n    rule.setName(\"Source files should not have any duplicated blocks\")\n      .addTags(\"pitfall\")\n      .setHtmlDescription(\"An issue is created on a file as soon as there is at least one block of duplicated code on this file\")\n      .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.LOGIC_CHANGEABILITY)\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linearWithOffset(\"10min\", \"10min\"))\n      .setEffortToFixDescription(\"number of duplicate blocks\")\n      .setSeverity(Severity.MAJOR);\n  }","id":84937,"modified_method":"private static void defineDuplicatedBlocksRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.DUPLICATED_BLOCKS);\n    rule.setName(\"Source files should not have any duplicated blocks\")\n      .addTags(\"pitfall\")\n      .setHtmlDescription(\"An issue is created on a file as soon as there is at least one block of duplicated code on this file\")\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linearWithOffset(\"10min\", \"10min\"))\n      .setEffortToFixDescription(\"number of duplicate blocks\")\n      .setSeverity(Severity.MAJOR);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void defineSkippedUnitTestRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.SKIPPED_UNIT_TESTS);\n    rule.setName(\"Skipped unit tests should be either removed or fixed\")\n      .addTags(\"pitfall\")\n      .setHtmlDescription(\"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed.\")\n      .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.UNIT_TESTABILITY)\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"10min\"))\n      .setEffortToFixDescription(\"number of skipped tests\")\n      .setSeverity(Severity.MAJOR);\n  }","id":84938,"modified_method":"private static void defineSkippedUnitTestRule(RulesDefinition.NewRepository repo) {\n    RulesDefinition.NewRule rule = repo.createRule(CommonRuleKeys.SKIPPED_UNIT_TESTS);\n    rule.setName(\"Skipped unit tests should be either removed or fixed\")\n      .addTags(\"pitfall\")\n      .setHtmlDescription(\"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed.\")\n      .setDebtRemediationFunction(rule.debtRemediationFunctions().linear(\"10min\"))\n      .setEffortToFixDescription(\"number of skipped tests\")\n      .setSeverity(Severity.MAJOR);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_custom_rule_on_template_change() {\n    register(new Rules() {\n      @Override\n      public void init(RulesDefinition.NewRepository repository) {\n        repository.createRule(\"T1\")\n          .setName(\"template1 name\")\n          .setHtmlDescription(\"template1 desc\")\n          .setSeverity(Severity.MAJOR)\n          .setTemplate(true)\n          .createParam(\"format\")\n          .setDefaultValue(\"csv\")\n          .setType(RuleParamType.STRING)\n          .setDescription(\"format parameter\");\n      }\n    });\n    RuleDto template = ruleDao.selectOrFailByKey(dbSession, RuleKey.of(\"xoo\", \"T1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = TESTER.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", template.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n\n    // Update template and restart\n    register(new Rules() {\n      @Override\n      public void init(RulesDefinition.NewRepository repository) {\n        RulesDefinition.NewRule rule = repository.createRule(\"T1\")\n          .setName(\"template1 name\")\n          .setHtmlDescription(\"template1 desc\")\n          .setSeverity(Severity.BLOCKER)\n          .setStatus(RuleStatus.BETA)\n          .setTemplate(true)\n          .setInternalKey(\"new_internal\");\n        rule\n          .setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.INTEGRATION_TESTABILITY)\n          .setDebtRemediationFunction(rule.debtRemediationFunctions().linearWithOffset(\"1h\", \"30min\"))\n          .setEffortToFixDescription(\"Effort\");\n      }\n    });\n\n    // Verify custom rule has been restore from the template\n    RuleDto customRule = ruleDao.selectOrFailByKey(dbSession, customRuleKey);\n    assertThat(customRule.getLanguage()).isEqualTo(\"xoo\");\n    assertThat(customRule.getConfigKey()).isEqualTo(\"new_internal\");\n    assertThat(customRule.getSeverityString()).isEqualTo(Severity.BLOCKER);\n    assertThat(customRule.getStatus()).isEqualTo(RuleStatus.BETA);\n    assertThat(customRule.getDefaultRemediationFunction()).isEqualTo(DebtRemediationFunction.Type.LINEAR_OFFSET.name());\n    assertThat(customRule.getEffortToFixDescription()).isEqualTo(\"Effort\");\n\n    assertThat(ruleIndex.search(new RuleQuery().setKey(customRuleKey.toString()), new SearchOptions()).getTotal()).isEqualTo(1);\n  }","id":84939,"modified_method":"@Test\n  public void update_custom_rule_on_template_change() {\n    register(new Rules() {\n      @Override\n      public void init(RulesDefinition.NewRepository repository) {\n        repository.createRule(\"T1\")\n          .setName(\"template1 name\")\n          .setHtmlDescription(\"template1 desc\")\n          .setSeverity(Severity.MAJOR)\n          .setTemplate(true)\n          .createParam(\"format\")\n          .setDefaultValue(\"csv\")\n          .setType(RuleParamType.STRING)\n          .setDescription(\"format parameter\");\n      }\n    });\n    RuleDto template = ruleDao.selectOrFailByKey(dbSession, RuleKey.of(\"xoo\", \"T1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = TESTER.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", template.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n\n    // Update template and restart\n    register(new Rules() {\n      @Override\n      public void init(RulesDefinition.NewRepository repository) {\n        RulesDefinition.NewRule rule = repository.createRule(\"T1\")\n          .setName(\"template1 name\")\n          .setHtmlDescription(\"template1 desc\")\n          .setSeverity(Severity.BLOCKER)\n          .setStatus(RuleStatus.BETA)\n          .setTemplate(true)\n          .setInternalKey(\"new_internal\");\n        rule\n          .setDebtRemediationFunction(rule.debtRemediationFunctions().linearWithOffset(\"1h\", \"30min\"))\n          .setEffortToFixDescription(\"Effort\");\n      }\n    });\n\n    // Verify custom rule has been restore from the template\n    RuleDto customRule = ruleDao.selectOrFailByKey(dbSession, customRuleKey);\n    assertThat(customRule.getLanguage()).isEqualTo(\"xoo\");\n    assertThat(customRule.getConfigKey()).isEqualTo(\"new_internal\");\n    assertThat(customRule.getSeverityString()).isEqualTo(Severity.BLOCKER);\n    assertThat(customRule.getStatus()).isEqualTo(RuleStatus.BETA);\n    assertThat(customRule.getDefaultRemediationFunction()).isEqualTo(DebtRemediationFunction.Type.LINEAR_OFFSET.name());\n    assertThat(customRule.getEffortToFixDescription()).isEqualTo(\"Effort\");\n\n    assertThat(ruleIndex.search(new RuleQuery().setKey(customRuleKey.toString()), new SearchOptions()).getTotal()).isEqualTo(1);\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void define(Context context) {\n      NewRepository repo = context.createRepository(\"fake\", \"java\");\n\n      // almost all the attributes of rule1 are changed\n      NewRule rule1 = repo.createRule(\"rule1\")\n        .setName(\"One v2\")\n        .setHtmlDescription(\"Description of One v2\")\n        .setSeverity(INFO)\n        .setInternalKey(\"config1 v2\")\n        // tag2 and tag3 removed, tag4 added\n        .setTags(\"tag1\", \"tag4\")\n        .setStatus(RuleStatus.READY)\n        .setDebtSubCharacteristic(\"MEMORY_EFFICIENCY\")\n        .setEffortToFixDescription(\"squid.S115.effortToFix.v2\");\n      rule1.setDebtRemediationFunction(rule1.debtRemediationFunctions().linearWithOffset(\"6d\", \"2h\"));\n      rule1.createParam(\"param1\").setDescription(\"parameter one v2\").setDefaultValue(\"default1 v2\");\n      rule1.createParam(\"param2\").setDescription(\"parameter two v2\").setDefaultValue(\"default2 v2\");\n\n      // rule2 is dropped, rule3 is new\n      repo.createRule(\"rule3\")\n        .setName(\"Three\")\n        .setHtmlDescription(\"Rule Three\");\n      repo.done();\n    }","id":84940,"modified_method":"@Override\n    public void define(Context context) {\n      NewRepository repo = context.createRepository(\"fake\", \"java\");\n\n      // almost all the attributes of rule1 are changed\n      NewRule rule1 = repo.createRule(\"rule1\")\n        .setName(\"One v2\")\n        .setHtmlDescription(\"Description of One v2\")\n        .setSeverity(INFO)\n        .setInternalKey(\"config1 v2\")\n        // tag2 and tag3 removed, tag4 added\n        .setTags(\"tag1\", \"tag4\")\n        .setStatus(RuleStatus.READY)\n        .setEffortToFixDescription(\"squid.S115.effortToFix.v2\");\n      rule1.setDebtRemediationFunction(rule1.debtRemediationFunctions().linearWithOffset(\"6d\", \"2h\"));\n      rule1.createParam(\"param1\").setDescription(\"parameter one v2\").setDefaultValue(\"default1 v2\");\n      rule1.createParam(\"param2\").setDescription(\"parameter two v2\").setDefaultValue(\"default2 v2\");\n\n      // rule2 is dropped, rule3 is new\n      repo.createRule(\"rule3\")\n        .setName(\"Three\")\n        .setHtmlDescription(\"Rule Three\");\n      repo.done();\n    }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void define(Context context) {\n      NewRepository repo = context.createRepository(\"fake\", \"java\");\n      NewRule rule1 = repo.createRule(\"rule1\")\n        .setName(\"One\")\n        .setHtmlDescription(\"Description of One\")\n        .setSeverity(BLOCKER)\n        .setInternalKey(\"config1\")\n        .setTags(\"tag1\", \"tag2\", \"tag3\")\n        .setStatus(RuleStatus.BETA)\n        .setDebtSubCharacteristic(\"MEMORY_EFFICIENCY\")\n        .setEffortToFixDescription(\"squid.S115.effortToFix\");\n      rule1.setDebtRemediationFunction(rule1.debtRemediationFunctions().linearWithOffset(\"5d\", \"10h\"));\n\n      rule1.createParam(\"param1\").setDescription(\"parameter one\").setDefaultValue(\"default1\");\n      rule1.createParam(\"param2\").setDescription(\"parameter two\").setDefaultValue(\"default2\");\n\n      repo.createRule(\"rule2\")\n        .setName(\"Two\")\n        .setHtmlDescription(\"Minimal rule\");\n      repo.done();\n    }","id":84941,"modified_method":"@Override\n    public void define(Context context) {\n      NewRepository repo = context.createRepository(\"fake\", \"java\");\n      NewRule rule1 = repo.createRule(\"rule1\")\n        .setName(\"One\")\n        .setHtmlDescription(\"Description of One\")\n        .setSeverity(BLOCKER)\n        .setInternalKey(\"config1\")\n        .setTags(\"tag1\", \"tag2\", \"tag3\")\n        .setStatus(RuleStatus.BETA)\n        .setEffortToFixDescription(\"squid.S115.effortToFix\");\n      rule1.setDebtRemediationFunction(rule1.debtRemediationFunctions().linearWithOffset(\"5d\", \"10h\"));\n\n      rule1.createParam(\"param1\").setDescription(\"parameter one\").setDefaultValue(\"default1\");\n      rule1.createParam(\"param2\").setDescription(\"parameter two\").setDefaultValue(\"default2\");\n\n      repo.createRule(\"rule2\")\n        .setName(\"Two\")\n        .setHtmlDescription(\"Minimal rule\");\n      repo.done();\n    }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void defineRulesXoo2(Context context) {\n    NewRepository repo = context.createRepository(XOO2_REPOSITORY, Xoo2.KEY).setName(\"Xoo2\");\n\n    NewRule hasTag = repo.createRule(HasTagSensor.RULE_KEY).setName(\"Has Tag\")\n      .setHtmlDescription(\"Search for a given tag in Xoo files\");\n\n    NewRule oneIssuePerLine = repo.createRule(OneIssuePerLineSensor.RULE_KEY).setName(\"One Issue Per Line\")\n      .setHtmlDescription(\"Generate an issue on each line of a file. It requires the metric \\\"lines\\\".\");\n    oneIssuePerLine.setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.MEMORY_EFFICIENCY)\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"1min\"))\n      .setEffortToFixDescription(\"It takes about 1 minute to an experienced software craftsman to remove a line of code\");\n\n    repo.done();\n  }","id":84942,"modified_method":"private static void defineRulesXoo2(Context context) {\n    NewRepository repo = context.createRepository(XOO2_REPOSITORY, Xoo2.KEY).setName(\"Xoo2\");\n\n    NewRule hasTag = repo.createRule(HasTagSensor.RULE_KEY).setName(\"Has Tag\")\n      .setHtmlDescription(\"Search for a given tag in Xoo files\");\n\n    NewRule oneIssuePerLine = repo.createRule(OneIssuePerLineSensor.RULE_KEY).setName(\"One Issue Per Line\")\n      .setHtmlDescription(\"Generate an issue on each line of a file. It requires the metric \\\"lines\\\".\");\n    oneIssuePerLine\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"1min\"))\n      .setEffortToFixDescription(\"It takes about 1 minute to an experienced software craftsman to remove a line of code\");\n\n    repo.done();\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineRulesXoo(Context context) {\n    NewRepository repo = context.createRepository(XOO_REPOSITORY, Xoo.KEY).setName(\"Xoo\");\n\n    new RulesDefinitionAnnotationLoader().load(repo, Check.ALL);\n\n    NewRule hasTag = repo.createRule(HasTagSensor.RULE_KEY).setName(\"Has Tag\")\n      .setHtmlDescription(\"Search for a given tag in Xoo files\");\n    hasTag.setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.READABILITY)\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().constantPerIssue(\"2min\"));\n    hasTag.createParam(\"tag\")\n      .setDefaultValue(\"xoo\")\n      .setDescription(\"The tag to search for\");\n\n    NewRule ruleWithParameters = repo.createRule(\"RuleWithParameters\").setName(\"Rule with parameters\")\n      .setHtmlDescription(\"Rule containing parameter of different types : boolean, integer, etc. For information, no issue will be linked to this rule.\");\n    ruleWithParameters.createParam(\"string\").setType(RuleParamType.STRING);\n    ruleWithParameters.createParam(\"text\").setType(RuleParamType.TEXT);\n    ruleWithParameters.createParam(\"boolean\").setType(RuleParamType.BOOLEAN);\n    ruleWithParameters.createParam(\"integer\").setType(RuleParamType.INTEGER);\n    ruleWithParameters.createParam(\"float\").setType(RuleParamType.FLOAT);\n\n    NewRule oneIssuePerLine = repo.createRule(OneIssuePerLineSensor.RULE_KEY).setName(\"One Issue Per Line\")\n      .setHtmlDescription(\"Generate an issue on each line of a file. It requires the metric \\\"lines\\\".\");\n    oneIssuePerLine.setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.MEMORY_EFFICIENCY)\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"1min\"))\n      .setEffortToFixDescription(\"It takes about 1 minute to an experienced software craftsman to remove a line of code\");\n\n    repo.createRule(OneIssueOnDirPerFileSensor.RULE_KEY).setName(\"One Issue On Dir Per File\")\n      .setHtmlDescription(\"Generate issues on directories\");\n\n    NewRule oneIssuePerFile = repo.createRule(OneIssuePerFileSensor.RULE_KEY).setName(\"One Issue Per File\")\n      .setHtmlDescription(\"Generate an issue on each file\");\n    oneIssuePerFile.setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.ARCHITECTURE_CHANGEABILITY)\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"10min\"));\n\n    NewRule oneDayDebtPerFile = repo.createRule(OneDayDebtPerFileSensor.RULE_KEY).setName(\"One Day Debt Per File\")\n      .setHtmlDescription(\"Generate an issue on each file with a debt of one day\");\n    oneDayDebtPerFile.setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.ARCHITECTURE_RELIABILITY)\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"1d\"));\n\n    NewRule oneIssuePerModule = repo.createRule(OneIssuePerModuleSensor.RULE_KEY).setName(\"One Issue Per Module\")\n      .setHtmlDescription(\"Generate an issue on each module\");\n    oneIssuePerModule.setDebtSubCharacteristic(RulesDefinition.SubCharacteristics.API_ABUSE)\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linearWithOffset(\"25min\", \"1h\"))\n      .setEffortToFixDescription(\"A certified architect will need roughly half an hour to start working on removal of modules, \" +\n        \"then it's about one hour per module.\");\n\n    repo.createRule(OneBlockerIssuePerFileSensor.RULE_KEY).setName(\"One Blocker Issue Per File\")\n      .setHtmlDescription(\"Generate a blocker issue on each file, whatever the severity declared in the Quality profile\");\n\n    repo.createRule(CustomMessageSensor.RULE_KEY).setName(\"Issue With Custom Message\")\n      .setHtmlDescription(\"Generate an issue on each file with a custom message\");\n\n    repo.createRule(RandomAccessSensor.RULE_KEY).setName(\"One Issue Per File with Random Access\")\n      .setHtmlDescription(\"This issue is generated on each file\");\n\n    repo.createRule(DeprecatedResourceApiSensor.RULE_KEY).setName(\"Issue created using deprecated API\")\n      .setHtmlDescription(\"Issue created using deprecated API\");\n\n    repo.createRule(MultilineIssuesSensor.RULE_KEY).setName(\"Creates issues with ranges/multiple locations\")\n      .setHtmlDescription(\"Issue with range and multiple locations\");\n\n    repo.done();\n\n  }","id":84943,"modified_method":"private void defineRulesXoo(Context context) {\n    NewRepository repo = context.createRepository(XOO_REPOSITORY, Xoo.KEY).setName(\"Xoo\");\n\n    new RulesDefinitionAnnotationLoader().load(repo, Check.ALL);\n\n    NewRule hasTag = repo.createRule(HasTagSensor.RULE_KEY).setName(\"Has Tag\")\n      .setHtmlDescription(\"Search for a given tag in Xoo files\");\n    hasTag\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().constantPerIssue(\"2min\"));\n    hasTag.createParam(\"tag\")\n      .setDefaultValue(\"xoo\")\n      .setDescription(\"The tag to search for\");\n\n    NewRule ruleWithParameters = repo.createRule(\"RuleWithParameters\").setName(\"Rule with parameters\")\n      .setHtmlDescription(\"Rule containing parameter of different types : boolean, integer, etc. For information, no issue will be linked to this rule.\");\n    ruleWithParameters.createParam(\"string\").setType(RuleParamType.STRING);\n    ruleWithParameters.createParam(\"text\").setType(RuleParamType.TEXT);\n    ruleWithParameters.createParam(\"boolean\").setType(RuleParamType.BOOLEAN);\n    ruleWithParameters.createParam(\"integer\").setType(RuleParamType.INTEGER);\n    ruleWithParameters.createParam(\"float\").setType(RuleParamType.FLOAT);\n\n    NewRule oneIssuePerLine = repo.createRule(OneIssuePerLineSensor.RULE_KEY).setName(\"One Issue Per Line\")\n      .setHtmlDescription(\"Generate an issue on each line of a file. It requires the metric \\\"lines\\\".\");\n    oneIssuePerLine\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"1min\"))\n      .setEffortToFixDescription(\"It takes about 1 minute to an experienced software craftsman to remove a line of code\");\n\n    repo.createRule(OneIssueOnDirPerFileSensor.RULE_KEY).setName(\"One Issue On Dir Per File\")\n      .setHtmlDescription(\"Generate issues on directories\");\n\n    NewRule oneIssuePerFile = repo.createRule(OneIssuePerFileSensor.RULE_KEY).setName(\"One Issue Per File\")\n      .setHtmlDescription(\"Generate an issue on each file\");\n    oneIssuePerFile.setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"10min\"));\n\n    NewRule oneDayDebtPerFile = repo.createRule(OneDayDebtPerFileSensor.RULE_KEY).setName(\"One Day Debt Per File\")\n      .setHtmlDescription(\"Generate an issue on each file with a debt of one day\");\n    oneDayDebtPerFile.setDebtRemediationFunction(hasTag.debtRemediationFunctions().linear(\"1d\"));\n\n    NewRule oneIssuePerModule = repo.createRule(OneIssuePerModuleSensor.RULE_KEY).setName(\"One Issue Per Module\")\n      .setHtmlDescription(\"Generate an issue on each module\");\n    oneIssuePerModule\n      .setDebtRemediationFunction(hasTag.debtRemediationFunctions().linearWithOffset(\"25min\", \"1h\"))\n      .setEffortToFixDescription(\"A certified architect will need roughly half an hour to start working on removal of modules, \" +\n        \"then it's about one hour per module.\");\n\n    repo.createRule(OneBlockerIssuePerFileSensor.RULE_KEY).setName(\"One Blocker Issue Per File\")\n      .setHtmlDescription(\"Generate a blocker issue on each file, whatever the severity declared in the Quality profile\");\n\n    repo.createRule(CustomMessageSensor.RULE_KEY).setName(\"Issue With Custom Message\")\n      .setHtmlDescription(\"Generate an issue on each file with a custom message\");\n\n    repo.createRule(RandomAccessSensor.RULE_KEY).setName(\"One Issue Per File with Random Access\")\n      .setHtmlDescription(\"This issue is generated on each file\");\n\n    repo.createRule(DeprecatedResourceApiSensor.RULE_KEY).setName(\"Issue created using deprecated API\")\n      .setHtmlDescription(\"Issue created using deprecated API\");\n\n    repo.createRule(MultilineIssuesSensor.RULE_KEY).setName(\"Creates issues with ranges/multiple locations\")\n      .setHtmlDescription(\"Issue with range and multiple locations\");\n\n    repo.done();\n\n  }","commit_id":"3210d6092b56edf7f9e3b5b544a360f07bcf5a7a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void getAllMethodNames(@NotNull HashSet<String> set) {\n    set.addAll(JavaMethodNameIndex.getInstance().getAllKeys(myManager.getProject()));\n  }","id":84944,"modified_method":"@Override\n  public void getAllMethodNames(@NotNull HashSet<String> set) {\n    JavaMethodNameIndex.getInstance().processAllKeys(myManager.getProject(), new CommonProcessors.CollectProcessor<String>(set));\n  }","commit_id":"aac49995065d7aab5f48334d59a49c90a0bac073","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public String[] getAllClassNames() {\n    final Collection<String> names = JavaShortClassNameIndex.getInstance().getAllKeys(myManager.getProject());\n    return ArrayUtil.toStringArray(names);\n  }","id":84945,"modified_method":"@Override\n  @NotNull\n  public String[] getAllClassNames() {\n    return ArrayUtil.toStringArray(JavaShortClassNameIndex.getInstance().getAllKeys(myManager.getProject()));\n  }","commit_id":"aac49995065d7aab5f48334d59a49c90a0bac073","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public String[] getAllMethodNames() {\n    final Collection<String> names = JavaMethodNameIndex.getInstance().getAllKeys(myManager.getProject());\n    return ArrayUtil.toStringArray(names);\n  }","id":84946,"modified_method":"@Override\n  @NotNull\n  public String[] getAllMethodNames() {\n    return ArrayUtil.toStringArray(JavaMethodNameIndex.getInstance().getAllKeys(myManager.getProject()));\n  }","commit_id":"aac49995065d7aab5f48334d59a49c90a0bac073","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public String[] getAllFieldNames() {\n    final Collection<String> names = JavaFieldNameIndex.getInstance().getAllKeys(myManager.getProject());\n    return ArrayUtil.toStringArray(names);\n  }","id":84947,"modified_method":"@Override\n  @NotNull\n  public String[] getAllFieldNames() {\n    return ArrayUtil.toStringArray(JavaFieldNameIndex.getInstance().getAllKeys(myManager.getProject()));\n  }","commit_id":"aac49995065d7aab5f48334d59a49c90a0bac073","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getAllClassNames(@NotNull HashSet<String> set) {\n    set.addAll(JavaShortClassNameIndex.getInstance().getAllKeys(myManager.getProject()));\n  }","id":84948,"modified_method":"@Override\n  public void getAllClassNames(@NotNull HashSet<String> set) {\n    JavaShortClassNameIndex.getInstance().processAllKeys(myManager.getProject(), new CommonProcessors.CollectProcessor<String>(set));\n  }","commit_id":"aac49995065d7aab5f48334d59a49c90a0bac073","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getAllFieldNames(@NotNull HashSet<String> set) {\n    set.addAll(JavaFieldNameIndex.getInstance().getAllKeys(myManager.getProject()));\n  }","id":84949,"modified_method":"@Override\n  public void getAllFieldNames(@NotNull HashSet<String> set) {\n    JavaFieldNameIndex.getInstance().processAllKeys(myManager.getProject(), new CommonProcessors.CollectProcessor<String>(set));\n  }","commit_id":"aac49995065d7aab5f48334d59a49c90a0bac073","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        Message in = exchange.getIn();\n        if (in.getBody() == null) {\n            // only convert if the is a body\n            callback.done(true);\n            return true;\n        }\n\n        if (charset != null) {\n            // override existing charset with configured charset as that is what the user\n            // have explicit configured and expects to be used\n            exchange.setProperty(Exchange.CHARSET_NAME, charset);\n        }\n        // use mandatory conversion\n        Object value;\n        try {\n            value = in.getMandatoryBody(type);\n        } catch (Exception e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n\n        // create a new message container so we do not drag specialized message objects along\n        Message msg = new DefaultMessage();\n        msg.copyFrom(in);\n        msg.setBody(value);\n\n        if (exchange.getPattern().isOutCapable()) {\n            exchange.setOut(msg);\n        } else {\n            exchange.setIn(msg);\n        }\n\n        // remove charset when we are done as we should not propagate that,\n        // as that can lead to double converting later on\n        if (charset != null) {\n            exchange.removeProperty(Exchange.CHARSET_NAME);\n        }\n\n        callback.done(true);\n        return true;\n    }","id":84950,"modified_method":"@Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        boolean out = exchange.hasOut();\n        Message old = out ? exchange.getOut() : exchange.getIn();\n\n        if (old.getBody() == null) {\n            // only convert if the is a body\n            callback.done(true);\n            return true;\n        }\n\n        if (charset != null) {\n            // override existing charset with configured charset as that is what the user\n            // have explicit configured and expects to be used\n            exchange.setProperty(Exchange.CHARSET_NAME, charset);\n        }\n        // use mandatory conversion\n        Object value;\n        try {\n            value = old.getMandatoryBody(type);\n        } catch (Exception e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n\n        // create a new message container so we do not drag specialized message objects along\n        // but that is only needed if the old message is a specialized message\n        boolean copyNeeded = !(old.getClass().equals(DefaultMessage.class));\n\n        if (copyNeeded) {\n            Message msg = new DefaultMessage();\n            msg.copyFrom(old);\n            msg.setBody(value);\n\n            // replace message on exchange\n            ExchangeHelper.replaceMessage(exchange, msg, false);\n        } else {\n            // no copy needed so set replace value directly\n            old.setBody(value);\n        }\n\n        // remove charset when we are done as we should not propagate that,\n        // as that can lead to double converting later on\n        if (charset != null) {\n            exchange.removeProperty(Exchange.CHARSET_NAME);\n        }\n\n        callback.done(true);\n        return true;\n    }","commit_id":"7031ec87cef60db278af8afac62a55539dc7f575","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        try {\n            Object newBody = expression.evaluate(exchange, Object.class);\n\n            boolean out = exchange.hasOut();\n            Message old = out ? exchange.getOut() : exchange.getIn();\n\n            // create a new message container so we do not drag specialized message objects along\n            Message msg = new DefaultMessage();\n            msg.copyFrom(old);\n            msg.setBody(newBody);\n\n            if (out) {\n                exchange.setOut(msg);\n            } else {\n                exchange.setIn(msg);\n            }\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n        callback.done(true);\n        return true;\n    }","id":84951,"modified_method":"@Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        try {\n            Object newBody = expression.evaluate(exchange, Object.class);\n\n            boolean out = exchange.hasOut();\n            Message old = out ? exchange.getOut() : exchange.getIn();\n\n            // create a new message container so we do not drag specialized message objects along\n            // but that is only needed if the old message is a specialized message\n            boolean copyNeeded = !(old.getClass().equals(DefaultMessage.class));\n\n            if (copyNeeded) {\n                Message msg = new DefaultMessage();\n                msg.copyFrom(old);\n                msg.setBody(newBody);\n\n                // replace message on exchange\n                ExchangeHelper.replaceMessage(exchange, msg, false);\n            } else {\n                // no copy needed so set replace value directly\n                old.setBody(newBody);\n            }\n\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n        callback.done(true);\n        return true;\n    }","commit_id":"7031ec87cef60db278af8afac62a55539dc7f575","url":"https://github.com/apache/camel"},{"original_method":"public boolean process(Exchange exchange, AsyncCallback callback) {\n        try {\n            Object newBody = expression.evaluate(exchange, Object.class);\n\n            Message old = exchange.getIn();\n\n            // create a new message container so we do not drag specialized message objects along\n            Message msg = new DefaultMessage();\n            msg.copyFrom(old);\n            msg.setBody(newBody);\n            exchange.setOut(msg);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n        callback.done(true);\n        return true;\n    }","id":84952,"modified_method":"public boolean process(Exchange exchange, AsyncCallback callback) {\n        try {\n            Object newBody = expression.evaluate(exchange, Object.class);\n\n            boolean out = exchange.hasOut();\n            Message old = out ? exchange.getOut() : exchange.getIn();\n\n            // create a new message container so we do not drag specialized message objects along\n            // but that is only needed if the old message is a specialized message\n            boolean copyNeeded = !(old.getClass().equals(DefaultMessage.class));\n\n            if (copyNeeded) {\n                Message msg = new DefaultMessage();\n                msg.copyFrom(old);\n                msg.setBody(newBody);\n\n                // replace message on exchange (must set as OUT)\n                ExchangeHelper.replaceMessage(exchange, msg, true);\n            } else {\n                // no copy needed so set replace value directly\n                old.setBody(newBody);\n\n                // but the message must be on OUT\n                if (!exchange.hasOut()) {\n                    exchange.setOut(exchange.getIn());\n                }\n            }\n\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n        callback.done(true);\n        return true;\n    }","commit_id":"7031ec87cef60db278af8afac62a55539dc7f575","url":"https://github.com/apache/camel"},{"original_method":"public void copyFrom(org.apache.camel.Message that) {\n        super.copyFrom(that);\n        if (that instanceof MailMessage) {\n            MailMessage mailMessage = (MailMessage) that;\n            this.originalMailMessage = mailMessage.originalMailMessage;\n            this.mailMessage = mailMessage.mailMessage;\n            this.mapMailMessage = mailMessage.mapMailMessage;\n        }\n    }","id":84953,"modified_method":"public void copyFrom(org.apache.camel.Message that) {\n        // only do a deep copy if we need to (yes when that is not a mail message, or if the mapMailMessage is true)\n        boolean needCopy = !(that instanceof MailMessage) || (((MailMessage) that).mapMailMessage);\n        if (needCopy) {\n            super.copyFrom(that);\n        } else {\n            // no deep copy needed, but copy message id\n            setMessageId(that.getMessageId());\n            setFault(that.isFault());\n        }\n        if (that instanceof MailMessage) {\n            MailMessage mailMessage = (MailMessage) that;\n            this.originalMailMessage = mailMessage.originalMailMessage;\n            this.mailMessage = mailMessage.mailMessage;\n            this.mapMailMessage = mailMessage.mapMailMessage;\n        }\n    }","commit_id":"bb4d11db8a539bc302749cba068f1a0b18c32559","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public MailMessage newInstance() {\n        return new MailMessage();\n    }","id":84954,"modified_method":"@Override\n    public MailMessage newInstance() {\n        return new MailMessage(null, this.mapMailMessage);\n    }","commit_id":"bb4d11db8a539bc302749cba068f1a0b18c32559","url":"https://github.com/apache/camel"},{"original_method":"private void testRawMessageConsumer(String type) throws Exception {\n        Mailbox mailboxRaw = Mailbox.get(\"jonesRaw\" + type + \"@localhost\");\n        assertEquals(1, mailboxRaw.size());\n\n        MockEndpoint mock = getMockEndpoint(\"mock://rawMessage\" + type);\n        mock.expectedMessageCount(1);\n        mock.expectedBodyReceived().body().isNotNull();\n        assertMockEndpointsSatisfied();\n\n        Message mailMessage = mock.getExchanges().get(0).getIn().getBody(Message.class);\n        assertNotNull(\"mail subject should not be null\", mailMessage.getSubject());\n        assertEquals(\"mail subject should be hurz\", \"hurz\", mailMessage.getSubject());\n    }","id":84955,"modified_method":"private void testRawMessageConsumer(String type) throws Exception {\n        Mailbox mailboxRaw = Mailbox.get(\"jonesRaw\" + type + \"@localhost\");\n        assertEquals(1, mailboxRaw.size());\n\n        MockEndpoint mock = getMockEndpoint(\"mock://rawMessage\" + type);\n        mock.expectedMessageCount(1);\n        mock.expectedBodyReceived().body().isNotNull();\n        assertMockEndpointsSatisfied();\n\n        Message mailMessage = mock.getExchanges().get(0).getIn().getBody(Message.class);\n        assertNotNull(\"mail subject should not be null\", mailMessage.getSubject());\n        assertEquals(\"mail subject should be hurz\", \"hurz\", mailMessage.getSubject());\n\n        Map<String, Object> headers = mock.getExchanges().get(0).getIn().getHeaders();\n        assertNotNull(headers);\n        assertTrue(!headers.isEmpty());\n    }","commit_id":"bb4d11db8a539bc302749cba068f1a0b18c32559","url":"https://github.com/apache/camel"},{"original_method":"private void testNormalMessageConsumer(String type) throws Exception {\n        Mailbox mailbox = Mailbox.get(\"jones\" + type + \"@localhost\");\n        assertEquals(1, mailbox.size());\n\n        MockEndpoint mock = getMockEndpoint(\"mock://normalMessage\" + type);\n        mock.expectedMessageCount(1);\n        mock.expectedBodyReceived().body().isNotNull();\n        assertMockEndpointsSatisfied();\n\n        String body = mock.getExchanges().get(0).getIn().getBody(String.class);\n        MimeMessage mm = new MimeMessage(null, new ByteArrayInputStream(body.getBytes()));\n        String subject = mm.getSubject();\n        assertNull(\"mail subject should not be available\", subject);\n    }","id":84956,"modified_method":"private void testNormalMessageConsumer(String type) throws Exception {\n        Mailbox mailbox = Mailbox.get(\"jones\" + type + \"@localhost\");\n        assertEquals(1, mailbox.size());\n\n        MockEndpoint mock = getMockEndpoint(\"mock://normalMessage\" + type);\n        mock.expectedMessageCount(1);\n        mock.expectedBodyReceived().body().isNotNull();\n        assertMockEndpointsSatisfied();\n\n        String body = mock.getExchanges().get(0).getIn().getBody(String.class);\n        MimeMessage mm = new MimeMessage(null, new ByteArrayInputStream(body.getBytes()));\n        String subject = mm.getSubject();\n        assertNull(\"mail subject should not be available\", subject);\n\n        Map<String, Object> headers = mock.getExchanges().get(0).getIn().getHeaders();\n        assertNotNull(headers);\n        assertTrue(!headers.isEmpty());\n    }","commit_id":"bb4d11db8a539bc302749cba068f1a0b18c32559","url":"https://github.com/apache/camel"},{"original_method":"public void execute( Archiver archiver, AssemblerConfigurationSource configSource )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        // MASSEMBLY-282: We should support adding a project's standard output file as part of an assembly that replaces it.\n        if ( ( ( artifact.getFile() != null )  &&  ( archiver.getDestFile() != null ) )\n                        && artifact.getFile().equals( archiver.getDestFile() ) )\n        {\n            File tempRoot = configSource.getTemporaryRootDirectory();\n            File tempArtifactFile = new File( tempRoot, artifact.getFile().getName() );\n\n            logger.warn( \"Artifact: \"\n                         + artifact.getId()\n                         + \" references the same file as the assembly destination file. Moving it to a temporary location for inclusion.\" );\n            try\n            {\n                FileUtils.copyFile( artifact.getFile(), tempArtifactFile );\n            }\n            catch ( IOException e )\n            {\n                throw new ArchiveCreationException( \"Error moving artifact file: '\" + artifact.getFile() + \"' to temporary location: \" + tempArtifactFile + \". Reason: \"\n                                                    + e.getMessage(), e );\n            }\n\n            artifact.setFile( tempArtifactFile );\n        }\n\n        String destDirectory = outputDirectory;\n\n        destDirectory = AssemblyFormatUtils.getOutputDirectory( destDirectory, configSource.getProject(), moduleProject, project, configSource.getFinalName(), configSource );\n\n        if ( unpack )\n        {\n            String outputLocation = destDirectory;\n\n            if ( ( outputLocation.length() > 0 ) && !outputLocation.endsWith( \"/\" ) )\n            {\n                outputLocation += \"/\";\n            }\n\n            String[] includesArray = TypeConversionUtils.toStringArray( includes );\n            if ( includesArray == null )\n            {\n                includesArray = DEFAULT_INCLUDES_ARRAY;\n            }\n            String[] excludesArray = TypeConversionUtils.toStringArray( excludes );\n\n            int oldDirMode = archiver.getDefaultDirectoryMode();\n            int oldFileMode = archiver.getDefaultFileMode();\n\n            logger.debug( \"Unpacking artifact: \" + artifact.getId() + \" to assembly location: \" + outputLocation + \".\" );\n\n            try\n            {\n                if ( fileMode != null )\n                {\n                    archiver.setDefaultFileMode( TypeConversionUtils.modeToInt( fileMode, logger ) );\n                }\n\n                if ( directoryMode != null )\n                {\n                    archiver.setDefaultDirectoryMode( TypeConversionUtils.modeToInt( directoryMode, logger ) );\n                }\n\n                File artifactFile = artifact.getFile();\n                if ( artifactFile == null )\n                {\n                    logger.warn( \"Skipping artifact: \" + artifact.getId() + \"; it does not have an associated file or directory.\" );\n                }\n                else if ( artifactFile.isDirectory() )\n                {\n                    logger.debug( \"Adding artifact directory contents for: \" + artifact + \" to: \" + outputLocation );\n                    archiver.addDirectory( artifactFile, outputLocation, includesArray, excludesArray );\n                }\n                else\n                {\n                    logger.debug( \"Unpacking artifact contents for: \" + artifact + \" to: \" + outputLocation );\n                    logger.debug( \"includes:\\n\" + StringUtils.join( includesArray, \"\\n\" ) + \"\\n\" );\n                    logger.debug( \"excludes:\\n\" + (excludesArray == null ? \"none\" : StringUtils.join( excludesArray, \"\\n\" ) ) + \"\\n\" );\n                    archiver.addArchivedFileSet( artifactFile, outputLocation, includesArray, excludesArray );\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new ArchiveCreationException( \"Error adding file-set for '\" + artifact.getId() + \"' to archive: \"\n                    + e.getMessage(), e );\n            }\n            finally\n            {\n                archiver.setDefaultDirectoryMode( oldDirMode );\n                archiver.setDefaultFileMode( oldFileMode );\n            }\n        }\n        else\n        {\n            String fileNameMapping =\n                AssemblyFormatUtils.evaluateFileNameMapping( outputFileNameMapping, artifact,\n                                                             configSource.getProject(), moduleProject, moduleArtifact,\n                                                             project, configSource );\n\n            String outputLocation = destDirectory + fileNameMapping;\n\n            try\n            {\n                File artifactFile = artifact.getFile();\n\n                logger.debug( \"Adding artifact: \" + artifact.getId() + \" with file: \" + artifactFile + \" to assembly location: \" + outputLocation + \".\" );\n\n                if ( fileMode != null )\n                {\n                    int mode = TypeConversionUtils.modeToInt( fileMode, logger );\n\n                    archiver.addFile( artifactFile, outputLocation, mode );\n                }\n                else\n                {\n                    archiver.addFile( artifactFile, outputLocation );\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new ArchiveCreationException( \"Error adding file '\" + artifact.getId() + \"' to archive: \"\n                    + e.getMessage(), e );\n            }\n        }\n    }","id":84957,"modified_method":"public void execute( Archiver archiver, AssemblerConfigurationSource configSource )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        // MASSEMBLY-282: We should support adding a project's standard output file as part of an assembly that replaces it.\n        if ( ( ( artifact.getFile() != null )  &&  ( archiver.getDestFile() != null ) )\n                        && artifact.getFile().equals( archiver.getDestFile() ) )\n        {\n            File tempRoot = configSource.getTemporaryRootDirectory();\n            File tempArtifactFile = new File( tempRoot, artifact.getFile().getName() );\n\n            logger.warn( \"Artifact: \"\n                         + artifact.getId()\n                         + \" references the same file as the assembly destination file. Moving it to a temporary location for inclusion.\" );\n            try\n            {\n                FileUtils.copyFile( artifact.getFile(), tempArtifactFile );\n            }\n            catch ( IOException e )\n            {\n                throw new ArchiveCreationException( \"Error moving artifact file: '\" + artifact.getFile() + \"' to temporary location: \" + tempArtifactFile + \". Reason: \"\n                                                    + e.getMessage(), e );\n            }\n\n            artifact.setFile( tempArtifactFile );\n        }\n\n        String destDirectory = outputDirectory;\n\n        destDirectory = AssemblyFormatUtils.getOutputDirectory( destDirectory, configSource.getProject(), moduleProject, project, configSource.getFinalName(), configSource );\n\n        if ( unpack )\n        {\n            String outputLocation = destDirectory;\n\n            if ( ( outputLocation.length() > 0 ) && !outputLocation.endsWith( \"/\" ) )\n            {\n                outputLocation += \"/\";\n            }\n\n            String[] includesArray = TypeConversionUtils.toStringArray( includes );\n            if ( includesArray == null )\n            {\n                includesArray = DEFAULT_INCLUDES_ARRAY;\n            }\n            String[] excludesArray = TypeConversionUtils.toStringArray( excludes );\n\n            int oldDirMode = archiver.getDefaultDirectoryMode();\n            int oldFileMode = archiver.getDefaultFileMode();\n\n            logger.debug( \"Unpacking artifact: \" + artifact.getId() + \" to assembly location: \" + outputLocation + \".\" );\n\n            try\n            {\n                if ( fileMode != -1 )\n                {\n                    archiver.setDefaultFileMode( fileMode );\n                }\n\n                if ( directoryMode != -1 )\n                {\n                    archiver.setDefaultDirectoryMode( directoryMode );\n                }\n\n                File artifactFile = artifact.getFile();\n                if ( artifactFile == null )\n                {\n                    logger.warn( \"Skipping artifact: \" + artifact.getId() + \"; it does not have an associated file or directory.\" );\n                }\n                else if ( artifactFile.isDirectory() )\n                {\n                    logger.debug( \"Adding artifact directory contents for: \" + artifact + \" to: \" + outputLocation );\n                    archiver.addDirectory( artifactFile, outputLocation, includesArray, excludesArray );\n                }\n                else\n                {\n                    logger.debug( \"Unpacking artifact contents for: \" + artifact + \" to: \" + outputLocation );\n                    logger.debug( \"includes:\\n\" + StringUtils.join( includesArray, \"\\n\" ) + \"\\n\" );\n                    logger.debug( \"excludes:\\n\" + (excludesArray == null ? \"none\" : StringUtils.join( excludesArray, \"\\n\" ) ) + \"\\n\" );\n                    archiver.addArchivedFileSet( artifactFile, outputLocation, includesArray, excludesArray );\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new ArchiveCreationException( \"Error adding file-set for '\" + artifact.getId() + \"' to archive: \"\n                    + e.getMessage(), e );\n            }\n            finally\n            {\n                archiver.setDefaultDirectoryMode( oldDirMode );\n                archiver.setDefaultFileMode( oldFileMode );\n            }\n        }\n        else\n        {\n            String fileNameMapping =\n                AssemblyFormatUtils.evaluateFileNameMapping( outputFileNameMapping, artifact,\n                                                             configSource.getProject(), moduleProject, moduleArtifact,\n                                                             project, configSource );\n\n            String outputLocation = destDirectory + fileNameMapping;\n\n            try\n            {\n                File artifactFile = artifact.getFile();\n\n                logger.debug( \"Adding artifact: \" + artifact.getId() + \" with file: \" + artifactFile + \" to assembly location: \" + outputLocation + \".\" );\n\n                if ( fileMode != -1 )\n                {\n                    archiver.addFile( artifactFile, outputLocation, fileMode );\n                }\n                else\n                {\n                    archiver.addFile( artifactFile, outputLocation );\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new ArchiveCreationException( \"Error adding file '\" + artifact.getId() + \"' to archive: \"\n                    + e.getMessage(), e );\n            }\n        }\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setFileMode( String fileMode )\n    {\n        this.fileMode = fileMode;\n    }","id":84958,"modified_method":"public void setFileMode( int fileMode )\n    {\n        this.fileMode = fileMode;\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setDirectoryMode( String directoryMode )\n    {\n        this.directoryMode = directoryMode;\n    }","id":84959,"modified_method":"public void setDirectoryMode( int directoryMode )\n    {\n        this.directoryMode = directoryMode;\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldAddArchiveFileWithUnpackAndModes()\n        throws ArchiveCreationException, AssemblyFormattingException, IOException\n    {\n        int directoryMode = TypeConversionUtils.modeToInt( \"777\", new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" ) );\n        int fileMode = TypeConversionUtils.modeToInt( \"777\", new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" ) );\n\n        mac.expectModeChange( -1, -1, directoryMode, fileMode, 2 );\n//        mac.expectIsSnapshot( false );\n\n        String outputLocation = \"\";\n\n        ArtifactMock artifactMock = new ArtifactMock( mockManager, \"group\", \"artifact\", \"version\", \"jar\", false );\n        File artifactFile = artifactMock.setNewFile();\n\n        mac.expectGetDestFile( new File( \"junk\" ) );\n        try\n        {\n            mac.archiver.addArchivedFileSet( artifactFile, outputLocation, AddArtifactTask.DEFAULT_INCLUDES_ARRAY, null );\n        }\n        catch ( ArchiverException e )\n        {\n            fail( \"Should never happen.\" );\n        }\n\n        mockManager.replayAll();\n\n        AddArtifactTask task = createTask( artifactMock.getArtifact() );\n\n        task.setUnpack( true );\n        task.setDirectoryMode( \"777\" );\n        task.setFileMode( \"777\" );\n\n        task.execute( mac.archiver, mac.configSource );\n\n        mockManager.verifyAll();\n    }","id":84960,"modified_method":"public void testShouldAddArchiveFileWithUnpackAndModes()\n        throws ArchiveCreationException, AssemblyFormattingException, IOException\n    {\n        int directoryMode = TypeConversionUtils.modeToInt( \"777\", new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" ) );\n        int fileMode = TypeConversionUtils.modeToInt( \"777\", new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" ) );\n\n        mac.expectModeChange( -1, -1, directoryMode, fileMode, 2 );\n//        mac.expectIsSnapshot( false );\n\n        String outputLocation = \"\";\n\n        ArtifactMock artifactMock = new ArtifactMock( mockManager, \"group\", \"artifact\", \"version\", \"jar\", false );\n        File artifactFile = artifactMock.setNewFile();\n\n        mac.expectGetDestFile( new File( \"junk\" ) );\n        try\n        {\n            mac.archiver.addArchivedFileSet( artifactFile, outputLocation, AddArtifactTask.DEFAULT_INCLUDES_ARRAY, null );\n        }\n        catch ( ArchiverException e )\n        {\n            fail( \"Should never happen.\" );\n        }\n\n        mockManager.replayAll();\n\n        AddArtifactTask task = createTask( artifactMock.getArtifact() );\n\n        task.setUnpack( true );\n        \n        task.setDirectoryMode( directoryMode );\n        task.setFileMode( fileMode );\n\n        task.execute( mac.archiver, mac.configSource );\n\n        mockManager.verifyAll();\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void addDependencySet( DependencySet dependencySet, Archiver archiver,\n                                     AssemblerConfigurationSource configSource )\n        throws AssemblyFormattingException, ArchiveCreationException, InvalidAssemblerConfigurationException\n    {\n        logger.info( \"Processing DependencySet (output=\" + dependencySet.getOutputDirectory() + \")\" );\n\n        if ( !dependencySet.isUseTransitiveDependencies() && dependencySet.isUseTransitiveFiltering() )\n        {\n            logger.warn( \"DependencySet has nonsensical configuration: useTransitiveDependencies == false \"\n                         + \"AND useTransitiveFiltering == true. Transitive filtering flag will be ignored.\" );\n        }\n\n        Set dependencyArtifacts = resolveDependencyArtifacts( dependencySet, configSource );\n\n        logger.debug( \"Adding \" + dependencyArtifacts.size() + \" dependency artifacts.\" );\n\n        for ( Iterator j = dependencyArtifacts.iterator(); j.hasNext(); )\n        {\n            Artifact depArtifact = (Artifact) j.next();\n\n            MavenProject depProject;\n            try\n            {\n                depProject = projectBuilder.buildFromRepository( depArtifact, configSource.getRemoteRepositories(),\n                                                                 configSource.getLocalRepository() );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                logger.debug( \"Error retrieving POM of module-dependency: \" + depArtifact.getId()\n                    + \"; Reason: \" + e.getMessage() + \"\\n\\nBuilding stub project instance.\" );\n\n                depProject = buildProjectStub( depArtifact );\n            }\n\n            if ( NON_ARCHIVE_DEPENDENCY_TYPES.contains( depArtifact.getType() ) )\n            {\n                addNonArchiveDependency( depArtifact, depProject, dependencySet, archiver, configSource );\n            }\n            else\n            {\n                AddArtifactTask task = new AddArtifactTask( depArtifact, logger );\n\n                task.setProject( depProject );\n                task.setModuleProject( moduleProject );\n                task.setModuleArtifact( moduleArtifact );\n                task.setOutputDirectory( dependencySet.getOutputDirectory(), defaultOutputDirectory );\n                task.setFileNameMapping( dependencySet.getOutputFileNameMapping(), defaultOutputFileNameMapping );\n                task.setDirectoryMode( dependencySet.getDirectoryMode() );\n                task.setFileMode( dependencySet.getFileMode() );\n                task.setUnpack( dependencySet.isUnpack() );\n\n                UnpackOptions opts = dependencySet.getUnpackOptions();\n                if ( dependencySet.isUnpack() && ( opts != null ) )\n                {\n                    task.setIncludes( opts.getIncludes() );\n                    task.setExcludes( opts.getExcludes() );\n                }\n\n                task.execute( archiver, configSource );\n            }\n        }\n    }","id":84961,"modified_method":"protected void addDependencySet( DependencySet dependencySet, Archiver archiver,\n                                     AssemblerConfigurationSource configSource )\n        throws AssemblyFormattingException, ArchiveCreationException, InvalidAssemblerConfigurationException\n    {\n        logger.info( \"Processing DependencySet (output=\" + dependencySet.getOutputDirectory() + \")\" );\n\n        if ( !dependencySet.isUseTransitiveDependencies() && dependencySet.isUseTransitiveFiltering() )\n        {\n            logger.warn( \"DependencySet has nonsensical configuration: useTransitiveDependencies == false \"\n                         + \"AND useTransitiveFiltering == true. Transitive filtering flag will be ignored.\" );\n        }\n\n        Set dependencyArtifacts = resolveDependencyArtifacts( dependencySet, configSource );\n\n        logger.debug( \"Adding \" + dependencyArtifacts.size() + \" dependency artifacts.\" );\n\n        for ( Iterator j = dependencyArtifacts.iterator(); j.hasNext(); )\n        {\n            Artifact depArtifact = (Artifact) j.next();\n\n            MavenProject depProject;\n            try\n            {\n                depProject = projectBuilder.buildFromRepository( depArtifact, configSource.getRemoteRepositories(),\n                                                                 configSource.getLocalRepository() );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                logger.debug( \"Error retrieving POM of module-dependency: \" + depArtifact.getId()\n                    + \"; Reason: \" + e.getMessage() + \"\\n\\nBuilding stub project instance.\" );\n\n                depProject = buildProjectStub( depArtifact );\n            }\n\n            if ( NON_ARCHIVE_DEPENDENCY_TYPES.contains( depArtifact.getType() ) )\n            {\n                addNonArchiveDependency( depArtifact, depProject, dependencySet, archiver, configSource );\n            }\n            else\n            {\n                AddArtifactTask task = new AddArtifactTask( depArtifact, logger );\n\n                task.setProject( depProject );\n                task.setModuleProject( moduleProject );\n                task.setModuleArtifact( moduleArtifact );\n                task.setOutputDirectory( dependencySet.getOutputDirectory(), defaultOutputDirectory );\n                task.setFileNameMapping( dependencySet.getOutputFileNameMapping(), defaultOutputFileNameMapping );\n                \n                int dirMode = TypeConversionUtils.modeToInt( dependencySet.getDirectoryMode(), logger );\n                if ( dirMode != -1 )\n                {\n                    task.setDirectoryMode( dirMode );\n                }\n                \n                int fileMode = TypeConversionUtils.modeToInt( dependencySet.getFileMode(), logger );\n                if ( fileMode != -1 )\n                {\n                    task.setFileMode( fileMode );\n                }\n                \n                task.setUnpack( dependencySet.isUnpack() );\n\n                UnpackOptions opts = dependencySet.getUnpackOptions();\n                if ( dependencySet.isUnpack() && ( opts != null ) )\n                {\n                    task.setIncludes( opts.getIncludes() );\n                    task.setExcludes( opts.getExcludes() );\n                }\n\n                task.execute( archiver, configSource );\n            }\n        }\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( Archiver archiver, AssemblerConfigurationSource configSource )\n        throws ArchiveCreationException\n    {\n        if ( \".\".equals( outputDirectory ) )\n        {\n            outputDirectory = \"\";\n        }\n        else if ( \"..\".equals( outputDirectory ) )\n        {\n            throw new ArchiveCreationException( \"Cannot add source directory: \" + directory + \" to archive-path: \"\n                + outputDirectory + \". All paths must be within the archive root directory.\" );\n        }\n\n        int oldDirMode = archiver.getDefaultDirectoryMode();\n        int oldFileMode = archiver.getDefaultFileMode();\n\n        try\n        {\n            if ( directoryMode > -1 )\n            {\n                archiver.setDefaultDirectoryMode( directoryMode );\n            }\n\n            if ( fileMode > -1 )\n            {\n                archiver.setDefaultFileMode( fileMode );\n            }\n\n            if ( directory.exists() )\n            {\n                List directoryExcludes;\n                if ( excludes != null && !excludes.isEmpty() )\n                {\n                    directoryExcludes = new ArrayList( excludes );\n                }\n                else\n                {\n                    directoryExcludes = new ArrayList();\n                }\n\n                if ( useDefaultExcludes )\n                {\n                    directoryExcludes.addAll( FileUtils.getDefaultExcludesAsList() );\n                }\n\n                try\n                {\n                    String[] includesArray = null;\n                    if ( includes != null && !includes.isEmpty() )\n                    {\n                        includesArray = (String[]) includes.toArray( new String[0] );\n                    }\n\n                    // this one is guaranteed to be non-null by code above.\n                    String[] excludesArray = (String[]) directoryExcludes.toArray( new String[0] );\n\n                    archiver.addDirectory( directory, outputDirectory, includesArray, excludesArray );\n                }\n                catch ( ArchiverException e )\n                {\n                    throw new ArchiveCreationException( \"Error adding directory to archive: \" + e.getMessage(), e );\n                }\n            }\n        }\n        finally\n        {\n            archiver.setDefaultDirectoryMode( oldDirMode );\n            archiver.setDefaultFileMode( oldFileMode );\n        }\n    }","id":84962,"modified_method":"public void execute( Archiver archiver, AssemblerConfigurationSource configSource )\n        throws ArchiveCreationException\n    {\n        if ( \".\".equals( outputDirectory ) )\n        {\n            outputDirectory = \"\";\n        }\n        else if ( \"..\".equals( outputDirectory ) )\n        {\n            throw new ArchiveCreationException( \"Cannot add source directory: \" + directory + \" to archive-path: \"\n                + outputDirectory + \". All paths must be within the archive root directory.\" );\n        }\n\n        int oldDirMode = archiver.getDefaultDirectoryMode();\n        int oldFileMode = archiver.getDefaultFileMode();\n\n        try\n        {\n            if ( directoryMode != -1 )\n            {\n                archiver.setDefaultDirectoryMode( directoryMode );\n            }\n\n            if ( fileMode != -1 )\n            {\n                archiver.setDefaultFileMode( fileMode );\n            }\n\n            if ( directory.exists() )\n            {\n                List directoryExcludes;\n                if ( excludes != null && !excludes.isEmpty() )\n                {\n                    directoryExcludes = new ArrayList( excludes );\n                }\n                else\n                {\n                    directoryExcludes = new ArrayList();\n                }\n\n                if ( useDefaultExcludes )\n                {\n                    directoryExcludes.addAll( FileUtils.getDefaultExcludesAsList() );\n                }\n\n                try\n                {\n                    String[] includesArray = null;\n                    if ( includes != null && !includes.isEmpty() )\n                    {\n                        includesArray = (String[]) includes.toArray( new String[0] );\n                    }\n\n                    // this one is guaranteed to be non-null by code above.\n                    String[] excludesArray = (String[]) directoryExcludes.toArray( new String[0] );\n\n                    archiver.addDirectory( directory, outputDirectory, includesArray, excludesArray );\n                }\n                catch ( ArchiverException e )\n                {\n                    throw new ArchiveCreationException( \"Error adding directory to archive: \" + e.getMessage(), e );\n                }\n            }\n        }\n        finally\n        {\n            archiver.setDefaultDirectoryMode( oldDirMode );\n            archiver.setDefaultFileMode( oldFileMode );\n        }\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void addFileSet( FileSet fileSet, Archiver archiver, AssemblerConfigurationSource configSource,\n                               File archiveBaseDir )\n        throws AssemblyFormattingException, ArchiveCreationException\n    {\n        // throw this check in just in case someone extends this class...\n        checkLogger();\n\n        FileSetFormatter fileSetFormatter = new FileSetFormatter( configSource, logger );\n\n        if ( project == null )\n        {\n            project = configSource.getProject();\n        }\n\n        File basedir = project.getBasedir();\n\n        String destDirectory = fileSet.getOutputDirectory();\n\n        if ( destDirectory == null )\n        {\n            destDirectory = fileSet.getDirectory();\n        }\n\n        destDirectory =\n            AssemblyFormatUtils.getOutputDirectory( destDirectory, configSource.getProject(), moduleProject, project,\n                                                    configSource.getFinalName(), configSource );\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"FileSet[\" + destDirectory + \"]\" + \" dir perms: \"\n                + Integer.toString( archiver.getDefaultDirectoryMode(), 8 ) + \" file perms: \"\n                + Integer.toString( archiver.getDefaultFileMode(), 8 )\n                + ( fileSet.getLineEnding() == null ? \"\" : \" lineEndings: \" + fileSet.getLineEnding() ) );\n        }\n\n        logger.debug( \"The archive base directory is '\" + archiveBaseDir + \"'\" );\n\n        File fileSetDir = getFileSetDirectory( fileSet, basedir, archiveBaseDir );\n\n        if ( fileSetDir.exists() )\n        {\n            try\n            {\n                fileSetDir = fileSetFormatter.formatFileSetForAssembly( fileSetDir, fileSet );\n            }\n            catch ( IOException e )\n            {\n                throw new ArchiveCreationException( \"Error fixing file-set line endings for assembly: \"\n                    + e.getMessage(), e );\n            }\n\n            logger.debug( \"Adding file-set from directory: '\" + fileSetDir.getAbsolutePath() + \"'\\nassembly output directory is: \\'\" + destDirectory + \"\\'\" );\n\n            AddDirectoryTask task = new AddDirectoryTask( fileSetDir );\n\n            task.setDirectoryMode( TypeConversionUtils.modeToInt( fileSet.getDirectoryMode(), logger ) );\n            task.setFileMode( TypeConversionUtils.modeToInt( fileSet.getFileMode(), logger ) );\n            task.setUseDefaultExcludes( fileSet.isUseDefaultExcludes() );\n            List excludes = fileSet.getExcludes();\n            excludes.add( \"**/*.filtered\" );\n            task.setExcludes( excludes );\n            task.setIncludes( fileSet.getIncludes() );\n            task.setOutputDirectory( destDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","id":84963,"modified_method":"protected void addFileSet( FileSet fileSet, Archiver archiver, AssemblerConfigurationSource configSource,\n                               File archiveBaseDir )\n        throws AssemblyFormattingException, ArchiveCreationException\n    {\n        // throw this check in just in case someone extends this class...\n        checkLogger();\n\n        FileSetFormatter fileSetFormatter = new FileSetFormatter( configSource, logger );\n\n        if ( project == null )\n        {\n            project = configSource.getProject();\n        }\n\n        File basedir = project.getBasedir();\n\n        String destDirectory = fileSet.getOutputDirectory();\n\n        if ( destDirectory == null )\n        {\n            destDirectory = fileSet.getDirectory();\n        }\n\n        destDirectory =\n            AssemblyFormatUtils.getOutputDirectory( destDirectory, configSource.getProject(), moduleProject, project,\n                                                    configSource.getFinalName(), configSource );\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"FileSet[\" + destDirectory + \"]\" + \" dir perms: \"\n                + Integer.toString( archiver.getDefaultDirectoryMode(), 8 ) + \" file perms: \"\n                + Integer.toString( archiver.getDefaultFileMode(), 8 )\n                + ( fileSet.getLineEnding() == null ? \"\" : \" lineEndings: \" + fileSet.getLineEnding() ) );\n        }\n\n        logger.debug( \"The archive base directory is '\" + archiveBaseDir + \"'\" );\n\n        File fileSetDir = getFileSetDirectory( fileSet, basedir, archiveBaseDir );\n\n        if ( fileSetDir.exists() )\n        {\n            try\n            {\n                fileSetDir = fileSetFormatter.formatFileSetForAssembly( fileSetDir, fileSet );\n            }\n            catch ( IOException e )\n            {\n                throw new ArchiveCreationException( \"Error fixing file-set line endings for assembly: \"\n                    + e.getMessage(), e );\n            }\n\n            logger.debug( \"Adding file-set from directory: '\" + fileSetDir.getAbsolutePath() + \"'\\nassembly output directory is: \\'\" + destDirectory + \"\\'\" );\n\n            AddDirectoryTask task = new AddDirectoryTask( fileSetDir );\n\n            int dirMode = TypeConversionUtils.modeToInt( fileSet.getDirectoryMode(), logger );\n            if ( dirMode != -1 )\n            {\n                task.setDirectoryMode( dirMode );\n            }\n            \n            int fileMode = TypeConversionUtils.modeToInt( fileSet.getFileMode(), logger );\n            if ( fileMode != -1 )\n            {\n                task.setFileMode( fileMode );\n            }\n            \n            task.setUseDefaultExcludes( fileSet.isUseDefaultExcludes() );\n            \n            List excludes = fileSet.getExcludes();\n            excludes.add( \"**/*.filtered\" );\n            task.setExcludes( excludes );\n            \n            task.setIncludes( fileSet.getIncludes() );\n            task.setOutputDirectory( destDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void addModuleArtifact( Artifact artifact, MavenProject project, Archiver archiver,\n                                AssemblerConfigurationSource configSource, ModuleBinaries binaries )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        if ( artifact.getFile() == null )\n        {\n            throw new ArchiveCreationException( \"Artifact: \" + artifact.getId()\n                            + \" (included by module) does not have an artifact with a file. \"\n                            + \"Please ensure the package phase is run before the assembly is generated.\" );\n        }\n\n        AddArtifactTask task = new AddArtifactTask( artifact, getLogger() );\n\n        task.setFileNameMapping( binaries.getOutputFileNameMapping() );\n        task.setOutputDirectory( binaries.getOutputDirectory() );\n        task.setProject( project );\n        task.setModuleProject( project );\n        task.setModuleArtifact( artifact );\n        task.setDirectoryMode( binaries.getDirectoryMode() );\n        task.setFileMode( binaries.getFileMode() );\n        task.setUnpack( binaries.isUnpack() );\n        \n        if ( binaries.isUnpack() && binaries.getUnpackOptions() != null )\n        {\n            task.setIncludes( binaries.getUnpackOptions().getIncludes() );\n            task.setExcludes( binaries.getUnpackOptions().getExcludes() );\n        }\n\n        task.execute( archiver, configSource );\n    }","id":84964,"modified_method":"protected void addModuleArtifact( Artifact artifact, MavenProject project, Archiver archiver,\n                                AssemblerConfigurationSource configSource, ModuleBinaries binaries )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        if ( artifact.getFile() == null )\n        {\n            throw new ArchiveCreationException( \"Artifact: \" + artifact.getId()\n                            + \" (included by module) does not have an artifact with a file. \"\n                            + \"Please ensure the package phase is run before the assembly is generated.\" );\n        }\n\n        AddArtifactTask task = new AddArtifactTask( artifact, getLogger() );\n\n        task.setFileNameMapping( binaries.getOutputFileNameMapping() );\n        task.setOutputDirectory( binaries.getOutputDirectory() );\n        task.setProject( project );\n        task.setModuleProject( project );\n        task.setModuleArtifact( artifact );\n        \n        int dirMode = TypeConversionUtils.modeToInt( binaries.getDirectoryMode(), getLogger() );\n        if ( dirMode != -1 )\n        {\n            task.setDirectoryMode( dirMode );\n        }\n        \n        int fileMode = TypeConversionUtils.modeToInt( binaries.getFileMode(), getLogger() );\n        if ( fileMode != -1 )\n        {\n            task.setFileMode( fileMode );\n        }\n        \n        task.setUnpack( binaries.isUnpack() );\n        \n        if ( binaries.isUnpack() && binaries.getUnpackOptions() != null )\n        {\n            task.setIncludes( binaries.getUnpackOptions().getIncludes() );\n            task.setExcludes( binaries.getUnpackOptions().getExcludes() );\n        }\n\n        task.execute( archiver, configSource );\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute( Assembly assembly, Archiver archiver, AssemblerConfigurationSource configSource,\n                         AssemblyContext context )\n        throws ArchiveCreationException, AssemblyFormattingException, InvalidAssemblerConfigurationException\n    {\n        List repositoriesList = assembly.getRepositories();\n\n        File tempRoot = configSource.getTemporaryRootDirectory();\n\n        for ( Iterator i = repositoriesList.iterator(); i.hasNext(); )\n        {\n            Repository repository = (Repository) i.next();\n\n            resolveDependencies( repository, configSource, context );\n\n            String outputDirectory =\n                AssemblyFormatUtils.getOutputDirectory( repository.getOutputDirectory(), configSource.getProject(),\n                                                        null, configSource.getFinalName(),\n                                                        configSource );\n\n            File repositoryDirectory = new File( tempRoot, outputDirectory );\n\n            if ( !repositoryDirectory.exists() )\n            {\n                repositoryDirectory.mkdirs();\n            }\n\n            try\n            {\n                getLogger().debug( \"Assembling repository to: \" + repositoryDirectory );\n                repositoryAssembler.buildRemoteRepository( repositoryDirectory, wrap( repository ), wrap( configSource ) );\n                getLogger().debug( \"Finished assembling repository to: \" + repositoryDirectory );\n            }\n            catch ( RepositoryAssemblyException e )\n            {\n                throw new ArchiveCreationException( \"Failed to assemble repository: \" + e.getMessage(), e );\n            }\n\n            AddDirectoryTask task = new AddDirectoryTask( repositoryDirectory );\n\n            task.setDirectoryMode( TypeConversionUtils.modeToInt( repository.getDirectoryMode(), getLogger() ) );\n            task.setFileMode( TypeConversionUtils.modeToInt( repository.getFileMode(), getLogger() ) );\n            task.setUseDefaultExcludes( repository.isUseDefaultExcludes() );\n            task.setOutputDirectory( outputDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","id":84965,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute( Assembly assembly, Archiver archiver, AssemblerConfigurationSource configSource,\n                         AssemblyContext context )\n        throws ArchiveCreationException, AssemblyFormattingException, InvalidAssemblerConfigurationException\n    {\n        List repositoriesList = assembly.getRepositories();\n\n        File tempRoot = configSource.getTemporaryRootDirectory();\n\n        for ( Iterator i = repositoriesList.iterator(); i.hasNext(); )\n        {\n            Repository repository = (Repository) i.next();\n\n            resolveDependencies( repository, configSource, context );\n\n            String outputDirectory =\n                AssemblyFormatUtils.getOutputDirectory( repository.getOutputDirectory(), configSource.getProject(),\n                                                        null, configSource.getFinalName(),\n                                                        configSource );\n\n            File repositoryDirectory = new File( tempRoot, outputDirectory );\n\n            if ( !repositoryDirectory.exists() )\n            {\n                repositoryDirectory.mkdirs();\n            }\n\n            try\n            {\n                getLogger().debug( \"Assembling repository to: \" + repositoryDirectory );\n                repositoryAssembler.buildRemoteRepository( repositoryDirectory, wrap( repository ), wrap( configSource ) );\n                getLogger().debug( \"Finished assembling repository to: \" + repositoryDirectory );\n            }\n            catch ( RepositoryAssemblyException e )\n            {\n                throw new ArchiveCreationException( \"Failed to assemble repository: \" + e.getMessage(), e );\n            }\n\n            AddDirectoryTask task = new AddDirectoryTask( repositoryDirectory );\n\n            int dirMode = TypeConversionUtils.modeToInt( repository.getDirectoryMode(), getLogger() );\n            if ( dirMode != -1 )\n            {\n                task.setDirectoryMode( dirMode );\n            }\n            \n            int fileMode = TypeConversionUtils.modeToInt( repository.getFileMode(), getLogger() );\n            if ( fileMode != -1 )\n            {\n                task.setFileMode( fileMode );\n            }\n            \n            task.setUseDefaultExcludes( repository.isUseDefaultExcludes() );\n            task.setOutputDirectory( outputDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","commit_id":"a450a0f07adfaba97494c8e27edb721ce481d1e6","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        subsystem.registerSubsystemModel(new OSGiRootResource(registerRuntimeOnly));\n\n        subsystem.registerXMLElementWriter(OSGiSubsystemWriter.INSTANCE);\n    }","id":84966,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        subsystem.registerSubsystemModel(new OSGiRootResource(registerRuntimeOnly));\n\n        subsystem.registerXMLElementWriter(OSGiSubsystemWriter.INSTANCE);\n\n        registerTransformers1_0_0(subsystem);\n    }","commit_id":"e3e5612d9749ef414c6edaff2eb9710198bf10e0","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDescribeHandler() throws Exception {\n        KernelServices servicesA = installInController(AdditionalInitialization.MANAGEMENT, SUBSYSTEM_XML_1_2);\n        ModelNode modelA = servicesA.readWholeModel();\n        ModelNode describeOp = new ModelNode();\n        describeOp.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.DESCRIBE);\n        describeOp.get(ModelDescriptionConstants.OP_ADDR).set(\n                PathAddress.pathAddress(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME)).toModelNode());\n        List<ModelNode> operations = checkResultAndGetContents(servicesA.executeOperation(describeOp)).asList();\n\n        KernelServices servicesB = installInController(AdditionalInitialization.MANAGEMENT, operations);\n        ModelNode modelB = servicesB.readWholeModel();\n\n        compare(modelA, modelB);\n    }","id":84967,"modified_method":"@Test\n    public void testDescribeHandler() throws Exception {\n        KernelServices servicesA = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXml(SUBSYSTEM_XML_1_2)\n                .build();\n        ModelNode modelA = servicesA.readWholeModel();\n        ModelNode describeOp = new ModelNode();\n        describeOp.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.DESCRIBE);\n        describeOp.get(ModelDescriptionConstants.OP_ADDR).set(\n                PathAddress.pathAddress(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME)).toModelNode());\n        List<ModelNode> operations = checkResultAndGetContents(servicesA.executeOperation(describeOp)).asList();\n\n        KernelServices servicesB = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setBootOperations(operations)\n                .build();\n        ModelNode modelB = servicesB.readWholeModel();\n\n        compare(modelA, modelB);\n    }","commit_id":"e3e5612d9749ef414c6edaff2eb9710198bf10e0","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testReadWriteNamespace10() throws Exception {\n        KernelServices services = installInController(AdditionalInitialization.MANAGEMENT, SUBSYSTEM_XML_1_0);\n        ModelNode model = services.readWholeModel();\n\n        String marshalled = outputModel(model);\n        Assert.assertEquals(normalizeXML(SUBSYSTEM_XML_1_2), normalizeXML(marshalled));\n    }","id":84968,"modified_method":"@Test\n    public void testReadWriteNamespace10() throws Exception {\n        KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXml(SUBSYSTEM_XML_1_0)\n                .build();\n        ModelNode model = services.readWholeModel();\n\n        String marshalled = outputModel(model);\n        Assert.assertEquals(normalizeXML(SUBSYSTEM_XML_1_2), normalizeXML(marshalled));\n    }","commit_id":"e3e5612d9749ef414c6edaff2eb9710198bf10e0","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testReadWriteNamespace11() throws Exception {\n        KernelServices services = installInController(AdditionalInitialization.MANAGEMENT, SUBSYSTEM_XML_1_1);\n        ModelNode model = services.readWholeModel();\n\n        String marshalled = outputModel(model);\n        Assert.assertEquals(normalizeXML(SUBSYSTEM_XML_1_2), normalizeXML(marshalled));\n    }","id":84969,"modified_method":"@Test\n    public void testReadWriteNamespace11() throws Exception {\n        KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXml(SUBSYSTEM_XML_1_1)\n                .build();\n        ModelNode model = services.readWholeModel();\n\n        String marshalled = outputModel(model);\n        Assert.assertEquals(normalizeXML(SUBSYSTEM_XML_1_2), normalizeXML(marshalled));\n    }","commit_id":"e3e5612d9749ef414c6edaff2eb9710198bf10e0","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ChangeCollector(final Project project, final VcsDirtyScope dirtyScope, final VirtualFile vcsRoot) {\n    myDirtyScope = dirtyScope;\n    myVcsRoot = vcsRoot;\n    myProject = project;\n  }","id":84970,"modified_method":"/**\n   * A constructor\n   *\n   * @param project    a project\n   * @param dirtyScope the dirty scope to check\n   * @param vcsRoot    a vcs root\n   */\n  public ChangeCollector(final Project project, VcsDirtyScope dirtyScope, final VirtualFile vcsRoot) {\n    myDirtyScope = dirtyScope;\n    myVcsRoot = vcsRoot;\n    myProject = project;\n  }","commit_id":"852639fb077c06500c38c05df346b2ae08e9676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Collect changes if they weren't collected yet and return unversioned files.\n   * @return unversioned files\n   */\n  public Collection<VirtualFile> unversioned() throws VcsException {\n    ensureCollected();\n    return myUnversioned;\n  }","id":84971,"modified_method":"/**\n   * Get unversioned files\n   *\n   * @return an unversioned files\n   * @throws VcsException if there is a problem with executing Git\n   */\n  public Collection<VirtualFile> unversioned() throws VcsException {\n    ensureCollected();\n    return myUnversioned;\n  }","commit_id":"852639fb077c06500c38c05df346b2ae08e9676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Parses the output of the 'ls-files' command and fills myUnversioned and myChanges sets.\n   * Doesn't record files which are already in myChanges.\n   * Doesn't take care of unmerged files, because they are handled by collectIndexChanges.\n   */\n  private void parseLsFiles(String list) throws VcsException {\n    final Set<String> removed = new HashSet<String>();\n    final Set<String> changed = new HashSet<String>();\n    final Set<String> unmerged = new HashSet<String>();\n\n    // removed and unmerged files are also marked as changed in the 'ls-files' output\n    // (so they are represented twice or even more times there).\n    // we are going to collect them all and then exclude merged and removed files from the list of changed files.\n    // although we won't collect unmerged files as changed, we need to collect them here to exclude them from the list of changed files.\n    for (StringScanner sc = new StringScanner(list); sc.hasMoreData(); ) {\n      if (sc.isEol()) {\n        sc.nextLine();\n        continue;\n      }\n      final char status = sc.peek();\n      sc.skipChars(2);\n\n      // format for ? (unversioned) and other statuses different, so we have 2 if-branches here\n      if ('?' == status) {\n        // ? <filename>\n        VirtualFile file = myVcsRoot.findFileByRelativePath(GitUtil.unescapePath(sc.line()));\n        myUnversioned.add(file);\n      } else {\n        // <status> <mode> <object> <stage>\\t<filename>\n        // TODO: don't rely on this tab character\n        sc.boundedToken('\\t');\n        final String filePath = GitUtil.unescapePath(sc.line());\n        if ('R' == status) { // removed on disk but not from git\n          removed.add(filePath);\n        } else if ('C' == status) {    // modified, unmerged or removed\n          changed.add(filePath);\n        } else if ('M' == status) {\n          unmerged.add(filePath);\n        } else {\n          LOG.info(\"Unexpected type of the file status returned by git ls-file: [\" + status + \"]. Line: \" + sc.line());\n        }\n      }\n    }\n\n    // removed and unmerged files are also marked as changed (in ls-files output), so remove them from that list\n    changed.removeAll(removed);\n    changed.removeAll(unmerged);\n\n    // -- Precedence comparison between index and working tree changes --\n    // Deletion on disk take the most precedence: if the file is deleted, we show it as deleted even if it was somehow modified in the index\n    // Any other modifications in the working tree (actually it means editing the file since unversioned files are handled separately)\n    // are less important than changes in the index:\n    // if a file was modified in the index and in the working tree, we don't care: it's modified.\n    // if a file was added and modified, then it's important that it's added.\n    // if a file was renamed (in index) and then modified, its status is moved - it's more important.\n\n    // 1. we collect changed paths to use further when deciding whether to add a modified file to myChanges.\n    // 2. we also remove from myChanges any changes that happened with file which was then removed on disk.\n    // 3. and we also take care of situation when a file was added to git and then removed from disk -\n    //    although the file is new in index and deleted in the working tree, we don't show it as if there were no index at all.\n    //    TODO: this solution is far from the best: the file remains in the index, but we don't show it.\n\n    final Set<String> changedPaths = new HashSet<String>(myChanges.size());\n    for (Iterator<Change> it = myChanges.iterator(); it.hasNext(); ) {\n      boolean alreadyRemoved = false;\n      final Change c = it.next();\n      final ContentRevision before = c.getBeforeRevision();\n      final ContentRevision after = c.getAfterRevision();\n      if (after != null) {\n        String path = after.getFile().getPath();\n        if (path != null) {\n          path = GitUtil.relativePath(VfsUtil.virtualToIoFile(myVcsRoot), new File(path));\n          if (removed.contains(path)) {\n            it.remove();\n            alreadyRemoved = true;\n            // additional condition for newly created files: if a file was added to git and then removed from disk, don't show it\n            if (before == null) {\n              removed.remove(path);\n            }\n          } else {\n            changedPaths.add(path);\n          }\n        }\n      }\n      // if 'after' is null, the file was deleted by git rm command, so its status already is deleted and the file won't be shown in the\n      // output of ls-files command\n\n      if (before != null) {\n        String path = before.getFile().getPath();\n        if (path != null) {\n          path = GitUtil.relativePath(VfsUtil.virtualToIoFile(myVcsRoot), new File(path));\n          if (removed.contains(path)) {\n            if (!alreadyRemoved) { it.remove(); } // don't remove twice \n          } else {\n            changedPaths.add(path);\n          }\n        }\n      }\n    }\n\n    // these files are removed from disk but not from git.\n    for (String removedPath : removed) {\n      ContentRevision before = GitContentRevision.createRevision(myVcsRoot, removedPath, myHeadRevision, myProject, true, true);\n      myChanges.add(new Change(before, null, FileStatus.DELETED));\n    }\n\n    // these files are changed in working tree. Index change has precedence over working tree modification:\n    // so if the file was already handled by diff-index, we don't add it again from working tree status.\n    for (String changedPath : changed) {\n      if (changedPaths.contains(changedPath)) { continue; }\n      ContentRevision before = GitContentRevision.createRevision(myVcsRoot, changedPath, myHeadRevision, myProject, false, true);\n      ContentRevision after = GitContentRevision.createRevision(myVcsRoot, changedPath, null, myProject, false, false);\n      myChanges.add(new Change(before, after, FileStatus.MODIFIED));\n    }\n  }","id":84972,"modified_method":"private void parseFiles(String list) throws VcsException {\n    for (StringScanner sc = new StringScanner(list); sc.hasMoreData();) {\n      if (sc.isEol()) {\n        sc.nextLine();\n        continue;\n      }\n      char status = sc.peek();\n      sc.skipChars(2);\n      if ('?' == status) {\n        VirtualFile file = myVcsRoot.findFileByRelativePath(GitUtil.unescapePath(sc.line()));\n        if (GitUtil.gitRootOrNull(file) == myVcsRoot) {\n          myUnversioned.add(file);\n        }\n      }\n      else { //noinspection HardCodedStringLiteral\n        if ('M' == status) {\n          sc.boundedToken('\\t');\n          String file = GitUtil.unescapePath(sc.line());\n          VirtualFile vFile = myVcsRoot.findFileByRelativePath(file);\n          if (GitUtil.gitRootOrNull(vFile) != myVcsRoot) {\n            continue;\n          }\n          if (!myUnmergedNames.add(file)) {\n            continue;\n          }\n          // TODO handle conflict rename-modify\n          // TODO handle conflict copy-modify\n          // TODO handle conflict delete-modify\n          // TODO handle conflict rename-delete\n          // assume modify-modify conflict\n          ContentRevision before = GitContentRevision.createRevision(myVcsRoot, file, new GitRevisionNumber(\"orig_head\"), myProject, false, true);\n          ContentRevision after = GitContentRevision.createRevision(myVcsRoot, file, null, myProject, false, false);\n          myChanges.add(new Change(before, after, FileStatus.MERGED_WITH_CONFLICTS));\n        }\n        else {\n          throw new VcsException(\"Unsupported type of the merge conflict detected: \" + status);\n        }\n      }\n    }\n  }","commit_id":"852639fb077c06500c38c05df346b2ae08e9676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Collect changes if they weren't collected yet and return all changes but unversioned files.\n   * @return all changes except unversioned ones.\n   */\n  public Collection<Change> changes() throws VcsException {\n    ensureCollected();\n    return myChanges;\n  }","id":84973,"modified_method":"/**\n   * Get changes\n   *\n   * @return an unversioned files\n   * @throws VcsException if there is a problem with executing Git\n   */\n  public Collection<Change> changes() throws VcsException {\n    ensureCollected();\n    return myChanges;\n  }","commit_id":"852639fb077c06500c38c05df346b2ae08e9676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Collect changes if needed.\n   */\n  private void ensureCollected() throws VcsException {\n    if (myIsCollected) {\n      if (myIsFailed) {\n        throw new IllegalStateException(\"The method should not be called after after exception has been thrown.\");\n      }\n      else {\n        return;\n      }\n    }\n    myIsCollected = true;\n    updateIndex();\n    myHeadRevision = GitChangeUtils.loadRevision(myProject, myVcsRoot, \"HEAD\");\n    final Collection<FilePath> dirtyPaths = getDirtyPaths();\n    // ! order of collecting is important, because changes may intersect\n    collectIndexChanges(dirtyPaths);\n    collectWorkingTreeChanges(dirtyPaths);\n    myIsFailed = false;\n  }","id":84974,"modified_method":"/**\n   * Ensure that changes has been collected.\n   *\n   * @throws VcsException an exception\n   */\n  private void ensureCollected() throws VcsException {\n    if (myIsCollected) {\n      if (myIsFailed) {\n        throw new IllegalStateException(\"The method should not be called after after exception has been thrown.\");\n      }\n      else {\n        return;\n      }\n    }\n    myIsCollected = true;\n    updateIndex();\n    collectUnmergedAndUnversioned();\n    collectDiffChanges();\n    myIsFailed = false;\n  }","commit_id":"852639fb077c06500c38c05df346b2ae08e9676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * <p>Adds the given path to the collection of paths, but only in the way of collapsing common prefixes.\n   * That is: if any of the directories of the collection contains toAdd, nothing changes;\n   * if toAdd contains any of the directories of the collection, then toAdd is preferable than the latter.<\/p>\n   * <p>Also the situation when the whole repository is contained in toAdd is considered, and true is returned in that case.<\/p>\n   *\n   * @param root  repository root.\n   * @param paths existing paths.\n   * @param toAdd the path to add.\n   * @return true if all repository is dirty, false if not.\n   */\n  private static boolean addToPaths(FilePath root, Collection<FilePath> paths, FilePath toAdd) {\n    final VirtualFile gitRoot = GitUtil.getGitRootOrNull(toAdd);\n    // the check is needed for multi-repository configurations (otherwise will try to get status of directories outside the repository).\n    if (gitRoot == null || !gitRoot.getPath().equals(root.getPath())) {\n      return false;\n    }\n\n    if (root.isUnder(toAdd, true)) {\n      // the dirty directory which is being added contains the root => the whole repository is dirty\n      return true;\n    }\n    for (Iterator<FilePath> i = paths.iterator(); i.hasNext();) {\n      FilePath p = i.next();\n      if (p.isUnder(toAdd, true)) {\n        i.remove();\n      }\n      if (toAdd.isUnder(p, false)) {\n        return false;\n      }\n    }\n    paths.add(toAdd);\n    return false;\n  }","id":84975,"modified_method":"/**\n   * Add path to the collection of the paths to check for this vcs root\n   *\n   * @param root  the root path\n   * @param paths the existing paths\n   * @param toAdd the path to add\n   */\n  void addToPaths(FilePath root, Collection<FilePath> paths, FilePath toAdd) {\n    if (GitUtil.getGitRootOrNull(toAdd) != myVcsRoot) {\n      return;\n    }\n    if (root.isUnder(toAdd, true)) {\n      toAdd = root;\n    }\n    for (Iterator<FilePath> i = paths.iterator(); i.hasNext();) {\n      FilePath p = i.next();\n      if (p.isUnder(toAdd, true)) {\n        i.remove();\n      }\n      if (toAdd.isUnder(p, false)) {\n        return;\n      }\n    }\n    paths.add(toAdd);\n  }","commit_id":"852639fb077c06500c38c05df346b2ae08e9676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * A constructor\n   *\n   * @param project    a project\n   * @param dirtyScope the dirty scope to check\n   * @param vcsRoot    a vcs root\n   */\n  public ChangeCollector(final Project project, VcsDirtyScope dirtyScope, final VirtualFile vcsRoot) {\n    myDirtyScope = dirtyScope;\n    myVcsRoot = vcsRoot;\n    myProject = project;\n  }","id":84976,"modified_method":"public ChangeCollector(final Project project, final VcsDirtyScope dirtyScope, final VirtualFile vcsRoot) {\n    myDirtyScope = dirtyScope;\n    myVcsRoot = vcsRoot;\n    myProject = project;\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Add path to the collection of the paths to check for this vcs root\n   *\n   * @param root  the root path\n   * @param paths the existing paths\n   * @param toAdd the path to add\n   */\n  void addToPaths(FilePath root, Collection<FilePath> paths, FilePath toAdd) {\n    if (GitUtil.getGitRootOrNull(toAdd) != myVcsRoot) {\n      return;\n    }\n    if (root.isUnder(toAdd, true)) {\n      toAdd = root;\n    }\n    for (Iterator<FilePath> i = paths.iterator(); i.hasNext();) {\n      FilePath p = i.next();\n      if (p.isUnder(toAdd, true)) {\n        i.remove();\n      }\n      if (toAdd.isUnder(p, false)) {\n        return;\n      }\n    }\n    paths.add(toAdd);\n  }","id":84977,"modified_method":"/**\n   * <p>Adds the given path to the collection of paths, but only in the way of collapsing common prefixes.\n   * That is: if any of the directories of the collection contains toAdd, nothing changes;\n   * if toAdd contains any of the directories of the collection, then toAdd is preferable than the latter.<\/p>\n   * <p>Also the situation when the whole repository is contained in toAdd is considered, and true is returned in that case.<\/p>\n   *\n   * @param root  repository root.\n   * @param paths existing paths.\n   * @param toAdd the path to add.\n   * @return true if all repository is dirty, false if not.\n   */\n  private static boolean addToPaths(FilePath root, Collection<FilePath> paths, FilePath toAdd) {\n    final VirtualFile gitRoot = GitUtil.getGitRootOrNull(toAdd);\n    // the check is needed for multi-repository configurations (otherwise will try to get status of directories outside the repository).\n    if (gitRoot == null || !gitRoot.getPath().equals(root.getPath())) {\n      return false;\n    }\n\n    if (root.isUnder(toAdd, true)) {\n      // the dirty directory which is being added contains the root => the whole repository is dirty\n      return true;\n    }\n    for (Iterator<FilePath> i = paths.iterator(); i.hasNext();) {\n      FilePath p = i.next();\n      if (p.isUnder(toAdd, true)) {\n        i.remove();\n      }\n      if (toAdd.isUnder(p, false)) {\n        return false;\n      }\n    }\n    paths.add(toAdd);\n    return false;\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get changes\n   *\n   * @return an unversioned files\n   * @throws VcsException if there is a problem with executing Git\n   */\n  public Collection<Change> changes() throws VcsException {\n    ensureCollected();\n    return myChanges;\n  }","id":84978,"modified_method":"/**\n   * Collect changes if they weren't collected yet and return all changes but unversioned files.\n   * @return all changes except unversioned ones.\n   */\n  public Collection<Change> changes() throws VcsException {\n    ensureCollected();\n    return myChanges;\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Ensure that changes has been collected.\n   *\n   * @throws VcsException an exception\n   */\n  private void ensureCollected() throws VcsException {\n    if (myIsCollected) {\n      if (myIsFailed) {\n        throw new IllegalStateException(\"The method should not be called after after exception has been thrown.\");\n      }\n      else {\n        return;\n      }\n    }\n    myIsCollected = true;\n    updateIndex();\n    collectUnmergedAndUnversioned();\n    collectDiffChanges();\n    myIsFailed = false;\n  }","id":84979,"modified_method":"/**\n   * Collect changes if needed.\n   */\n  private void ensureCollected() throws VcsException {\n    if (myIsCollected) {\n      if (myIsFailed) {\n        throw new IllegalStateException(\"The method should not be called after after exception has been thrown.\");\n      }\n      else {\n        return;\n      }\n    }\n    myIsCollected = true;\n    updateIndex();\n    myHeadRevision = GitChangeUtils.loadRevision(myProject, myVcsRoot, \"HEAD\");\n    final Collection<FilePath> dirtyPaths = getDirtyPaths();\n    collectWorkingTreeChanges(dirtyPaths);\n    collectIndexChanges(dirtyPaths);\n    myIsFailed = false;\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get unversioned files\n   *\n   * @return an unversioned files\n   * @throws VcsException if there is a problem with executing Git\n   */\n  public Collection<VirtualFile> unversioned() throws VcsException {\n    ensureCollected();\n    return myUnversioned;\n  }","id":84980,"modified_method":"/**\n   * Collect changes if they weren't collected yet and return unversioned files.\n   * @return unversioned files\n   */\n  public Collection<VirtualFile> unversioned() throws VcsException {\n    ensureCollected();\n    return myUnversioned;\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseFiles(String list) throws VcsException {\n    for (StringScanner sc = new StringScanner(list); sc.hasMoreData();) {\n      if (sc.isEol()) {\n        sc.nextLine();\n        continue;\n      }\n      char status = sc.peek();\n      sc.skipChars(2);\n      if ('?' == status) {\n        VirtualFile file = myVcsRoot.findFileByRelativePath(GitUtil.unescapePath(sc.line()));\n        if (GitUtil.gitRootOrNull(file) == myVcsRoot) {\n          myUnversioned.add(file);\n        }\n      }\n      else { //noinspection HardCodedStringLiteral\n        if ('M' == status) {\n          sc.boundedToken('\\t');\n          String file = GitUtil.unescapePath(sc.line());\n          VirtualFile vFile = myVcsRoot.findFileByRelativePath(file);\n          if (GitUtil.gitRootOrNull(vFile) != myVcsRoot) {\n            continue;\n          }\n          if (!myUnmergedNames.add(file)) {\n            continue;\n          }\n          // TODO handle conflict rename-modify\n          // TODO handle conflict copy-modify\n          // TODO handle conflict delete-modify\n          // TODO handle conflict rename-delete\n          // assume modify-modify conflict\n          ContentRevision before = GitContentRevision.createRevision(myVcsRoot, file, new GitRevisionNumber(\"orig_head\"), myProject, false, true);\n          ContentRevision after = GitContentRevision.createRevision(myVcsRoot, file, null, myProject, false, false);\n          myChanges.add(new Change(before, after, FileStatus.MERGED_WITH_CONFLICTS));\n        }\n        else {\n          throw new VcsException(\"Unsupported type of the merge conflict detected: \" + status);\n        }\n      }\n    }\n  }","id":84981,"modified_method":"/**\n   * Parses the output of the 'ls-files' command and fills myUnversioned, myUnmergedNames and myChanges sets.\n   */\n  private void parseLsFiles(String list) throws VcsException {\n    final Set<String> removed = new HashSet<String>();\n    final Set<String> changed = new HashSet<String>();\n    final Set<String> unmerged = new HashSet<String>();\n\n    // removed and unmerged files are also marked as changed in the 'ls-files' output\n    // (so they are represented twice or even more times there).\n    // we are going to collect them all and then exclude merged and removed files from the list of changed files.\n    for (StringScanner sc = new StringScanner(list); sc.hasMoreData(); ) {\n      if (sc.isEol()) {\n        sc.nextLine();\n        continue;\n      }\n      final char status = sc.peek();\n      sc.skipChars(2);\n\n      // format for ? (unversioned) and other statuses different, so we have 2 if-branches here\n      if ('?' == status) {\n        // ? <filename>\n        VirtualFile file = myVcsRoot.findFileByRelativePath(GitUtil.unescapePath(sc.line()));\n        myUnversioned.add(file);\n      } else {\n        // <status> <mode> <object> <stage>\\t<filename>\n        // TODO: don't rely on this tab character\n        sc.boundedToken('\\t');\n        final String filePath = GitUtil.unescapePath(sc.line());\n        if ('R' == status) { // removed on disk but not from git\n          removed.add(filePath);\n        } else if ('C' == status) {    // modified, unmerged or removed\n          changed.add(filePath);\n        } else if ('M' == status) {\n          unmerged.add(filePath);\n        } else {\n          LOG.info(\"Unsupported type of the file status returned by git ls-file: [\" + status + \"]. Line: \" + sc.line());\n        }\n      }\n    }\n\n    // remove duplicates from changes, which are already handled by removed and unmerged.\n    // Then create Change objects and fill myChanges array.\n\n    for (String removedPath : removed) {\n      changed.remove(removedPath);\n      ContentRevision before = GitContentRevision.createRevision(myVcsRoot, removedPath, myHeadRevision, myProject, true, true);\n      myChanges.add(new Change(before, null, FileStatus.DELETED));\n    }\n\n    for (String unmergedPath : unmerged) {\n      changed.remove(unmergedPath);\n      myUnmergedNames.add(unmergedPath);\n      ContentRevision before = GitContentRevision.createRevision(myVcsRoot, unmergedPath, new GitRevisionNumber(\"orig_head\"), myProject, false, true);\n      ContentRevision after = GitContentRevision.createRevision(myVcsRoot, unmergedPath, null, myProject, false, false);\n      myChanges.add(new Change(before, after, FileStatus.MERGED_WITH_CONFLICTS));\n    }\n\n    for (String changedPath : changed) {\n      ContentRevision before = GitContentRevision.createRevision(myVcsRoot, changedPath, null, myProject, false, true);\n      ContentRevision after = GitContentRevision.createRevision(myVcsRoot, changedPath, myHeadRevision, myProject, false, false);\n      myChanges.add(new Change(before, after, FileStatus.MODIFIED));\n    }\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * A constructor\n   *\n   * @param project a project\n   */\n  public GitChangeProvider(@NotNull Project project) {\n    myProject = project;\n  }","id":84982,"modified_method":"public GitChangeProvider(@NotNull Project project) {\n    myProject = project;\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Parse changes from lines\n   *\n   * @param project        the context project\n   * @param vcsRoot        the git root\n   * @param thisRevision   the current revision\n   * @param parentRevision the parent revision for this change list\n   * @param s              the lines to parse\n   * @param changes        a list of changes to update\n   * @param ignoreNames    a set of names ignored during collection of the changes\n   * @throws VcsException if the input format does not matches expected format\n   */\n  public static void parseChanges(Project project,\n                                  VirtualFile vcsRoot,\n                                  GitRevisionNumber thisRevision,\n                                  GitRevisionNumber parentRevision,\n                                  StringScanner s,\n                                  List<Change> changes,\n                                  final Set<String> ignoreNames) throws VcsException {\n    while (s.hasMoreData()) {\n      FileStatus status = null;\n      if (s.isEol()) {\n        s.nextLine();\n        continue;\n      }\n      if (\"CADUMR\".indexOf(s.peek()) == -1) {\n        // exit if there is no next character\n        return;\n      }\n      String[] tokens = s.line().split(\"\\t\");\n      final ContentRevision before;\n      final ContentRevision after;\n      final String path = tokens[tokens.length - 1];\n      switch (tokens[0].charAt(0)) {\n        case 'C':\n        case 'A':\n          before = null;\n          status = FileStatus.ADDED;\n          after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false);\n          break;\n        case 'U':\n          status = FileStatus.MERGED_WITH_CONFLICTS;\n        case 'M':\n          if (status == null) {\n            status = FileStatus.MODIFIED;\n          }\n          before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true);\n          after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false);\n          break;\n        case 'D':\n          status = FileStatus.DELETED;\n          before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true);\n          after = null;\n          break;\n        case 'R':\n          status = FileStatus.MODIFIED;\n          before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true);\n          after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false);\n          break;\n        default:\n          throw new VcsException(\"Unknown file status: \" + Arrays.asList(tokens));\n      }\n      if (ignoreNames == null || !ignoreNames.contains(path)) {\n        changes.add(new Change(before, after, status));\n      }\n    }\n  }","id":84983,"modified_method":"/**\n   * Parse changes from lines\n   *\n   * @param project        the context project\n   * @param vcsRoot        the git root\n   * @param thisRevision   the current revision\n   * @param parentRevision the parent revision for this change list\n   * @param s              the lines to parse\n   * @param changes        a list of changes to update\n   * @param ignoreNames    a set of names ignored during collection of the changes\n   * @throws VcsException if the input format does not matches expected format\n   */\n  public static void parseChanges(Project project,\n                                  VirtualFile vcsRoot,\n                                  GitRevisionNumber thisRevision,\n                                  GitRevisionNumber parentRevision,\n                                  StringScanner s,\n                                  Collection<Change> changes,\n                                  final Set<String> ignoreNames) throws VcsException {\n    while (s.hasMoreData()) {\n      FileStatus status = null;\n      if (s.isEol()) {\n        s.nextLine();\n        continue;\n      }\n      if (\"CADUMR\".indexOf(s.peek()) == -1) {\n        // exit if there is no next character\n        return;\n      }\n      String[] tokens = s.line().split(\"\\t\");\n      final ContentRevision before;\n      final ContentRevision after;\n      final String path = tokens[tokens.length - 1];\n      switch (tokens[0].charAt(0)) {\n        case 'C':\n        case 'A':\n          before = null;\n          status = FileStatus.ADDED;\n          after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false);\n          break;\n        case 'U':\n          status = FileStatus.MERGED_WITH_CONFLICTS;\n        case 'M':\n          if (status == null) {\n            status = FileStatus.MODIFIED;\n          }\n          before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true);\n          after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false);\n          break;\n        case 'D':\n          status = FileStatus.DELETED;\n          before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true);\n          after = null;\n          break;\n        case 'R':\n          status = FileStatus.MODIFIED;\n          before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true);\n          after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false);\n          break;\n        default:\n          throw new VcsException(\"Unknown file status: \" + Arrays.asList(tokens));\n      }\n      if (ignoreNames == null || !ignoreNames.contains(path)) {\n        changes.add(new Change(before, after, status));\n      }\n    }\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Parse changes from lines\n   *\n   * @param project        the context project\n   * @param vcsRoot        the git root\n   * @param thisRevision   the current revision\n   * @param parentRevision the parent revision for this change list\n   * @param s              the lines to parse\n   * @param changes        a list of changes to update\n   * @param ignoreNames    a set of names ignored during collection of the changes\n   * @throws VcsException if the input format does not matches expected format\n   */\n  public static void parseChanges(Project project,\n                                  VirtualFile vcsRoot,\n                                  GitRevisionNumber thisRevision,\n                                  GitRevisionNumber parentRevision,\n                                  String s,\n                                  List<Change> changes,\n                                  final Set<String> ignoreNames) throws VcsException {\n    StringScanner sc = new StringScanner(s);\n    parseChanges(project, vcsRoot, thisRevision, parentRevision, sc, changes, ignoreNames);\n    if (sc.hasMoreData()) {\n      throw new IllegalStateException(\"Unknown file status: \" + sc.line());\n    }\n  }","id":84984,"modified_method":"/**\n   * Parse changes from lines\n   *\n   * @param project        the context project\n   * @param vcsRoot        the git root\n   * @param thisRevision   the current revision\n   * @param parentRevision the parent revision for this change list\n   * @param s              the lines to parse\n   * @param changes        a list of changes to update\n   * @param ignoreNames    a set of names ignored during collection of the changes\n   * @throws VcsException if the input format does not matches expected format\n   */\n  public static void parseChanges(Project project,\n                                  VirtualFile vcsRoot,\n                                  GitRevisionNumber thisRevision,\n                                  GitRevisionNumber parentRevision,\n                                  String s,\n                                  Collection<Change> changes,\n                                  final Set<String> ignoreNames) throws VcsException {\n    StringScanner sc = new StringScanner(s);\n    parseChanges(project, vcsRoot, thisRevision, parentRevision, sc, changes, ignoreNames);\n    if (sc.hasMoreData()) {\n      throw new IllegalStateException(\"Unknown file status: \" + sc.line());\n    }\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Load actual revision number with timestamp basing on revision number expression\n   *\n   * @param project        a project\n   * @param vcsRoot        a repository root\n   * @param revisionNumber a revision number expression\n   * @return a resolved revision\n   * @throws VcsException if there is a problem with running git\n   */\n  @SuppressWarnings({\"SameParameterValue\"})\n  public static GitRevisionNumber loadRevision(final Project project, final VirtualFile vcsRoot, @NonNls final String revisionNumber)\n    throws VcsException {\n    GitSimpleHandler handler = new GitSimpleHandler(project, vcsRoot, GitCommand.REV_LIST);\n    handler.addParameters(\"--timestamp\", \"--max-count=1\", revisionNumber);\n    handler.endOptions();\n    handler.setNoSSH(true);\n    handler.setSilent(true);\n    String output = handler.run();\n    StringTokenizer stk = new StringTokenizer(output, \"\\n\\r \\t\", false);\n    if (!stk.hasMoreTokens()) {\n      throw new VcsException(\"The string '\" + revisionNumber + \"' does not represents a revision number.\");\n    }\n    Date timestamp = GitUtil.parseTimestamp(stk.nextToken());\n    return new GitRevisionNumber(stk.nextToken(), timestamp);\n  }","id":84985,"modified_method":"/**\n   * Load actual revision number with timestamp basing on revision number expression\n   *\n   * @param project        a project\n   * @param vcsRoot        a repository root\n   * @param revisionNumber a revision number expression\n   * @return a resolved revision\n   * @throws VcsException if there is a problem with running git\n   */\n  @SuppressWarnings({\"SameParameterValue\"})\n  public static GitRevisionNumber loadRevision(final Project project, final VirtualFile vcsRoot, @NonNls final String revisionNumber)\n    throws VcsException {\n    GitSimpleHandler handler = new GitSimpleHandler(project, vcsRoot, GitCommand.REV_LIST);\n    handler.addParameters(\"--timestamp\", \"--max-count=1\", revisionNumber);\n    handler.endOptions();\n    handler.setNoSSH(true);\n    //handler.setSilent(true);\n    String output = handler.run();\n    StringTokenizer stk = new StringTokenizer(output, \"\\n\\r \\t\", false);\n    if (!stk.hasMoreTokens()) {\n      throw new VcsException(\"The string '\" + revisionNumber + \"' does not represents a revision number.\");\n    }\n    Date timestamp = GitUtil.parseTimestamp(stk.nextToken());\n    return new GitRevisionNumber(stk.nextToken(), timestamp);\n  }","commit_id":"70cb48019fdc279b57fa7bcccf94c17215cc7bb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Collect dirty file paths\n   *\n   * @param includeChanges if true, previous changes are included in collection\n   * @return the set of dirty paths to check, the paths are automatically collapsed if the summary length more than limit\n   */\n  private Collection<FilePath> dirtyPaths(boolean includeChanges) {\n    // TODO collapse paths with common prefix\n    ArrayList<FilePath> paths = new ArrayList<FilePath>();\n    FilePath rootPath = VcsUtil.getFilePath(myVcsRoot.getPath(), true);\n    for (FilePath p : myDirtyScope.getRecursivelyDirtyDirectories()) {\n      addToPaths(rootPath, paths, p);\n    }\n    ArrayList<FilePath> candidatePaths = new ArrayList<FilePath>();\n    candidatePaths.addAll(myDirtyScope.getDirtyFilesNoExpand());\n    if (includeChanges) {\n      try {\n        for (Change c : myChangeListManager.getChangesIn(myVcsRoot)) {\n          switch (c.getType()) {\n            case NEW:\n            case DELETED:\n            case MOVED:\n              if (c.getAfterRevision() != null) {\n                addToPaths(rootPath, paths, c.getAfterRevision().getFile());\n              }\n              if (c.getBeforeRevision() != null) {\n                addToPaths(rootPath, paths, c.getBeforeRevision().getFile());\n              }\n            case MODIFICATION:\n            default:\n              // do nothing\n          }\n        }\n      }\n      catch (Exception t) {\n        // ignore exceptions\n      }\n    }\n    for (FilePath p : candidatePaths) {\n      addToPaths(rootPath, paths, p);\n    }\n    return paths;\n  }","id":84986,"modified_method":"/**\n   * Collect dirty file paths\n   *\n   * @param includeChanges if true, previous changes are included in collection\n   * @return the set of dirty paths to check, the paths are automatically collapsed if the summary length more than limit\n   */\n  private Collection<FilePath> dirtyPaths(boolean includeChanges) {\n    final List<String> allPaths = new ArrayList<String>();\n\n    for (FilePath p : myDirtyScope.getRecursivelyDirtyDirectories()) {\n      addToPaths(p, allPaths);\n    }\n    for (FilePath p : myDirtyScope.getDirtyFilesNoExpand()) {\n      addToPaths(p, allPaths);\n    }\n\n    if (includeChanges) {\n      try {\n        for (Change c : myChangeListManager.getChangesIn(myVcsRoot)) {\n          switch (c.getType()) {\n            case NEW:\n            case DELETED:\n            case MOVED:\n              if (c.getAfterRevision() != null) {\n                addToPaths(c.getAfterRevision().getFile(), allPaths);\n              }\n              if (c.getBeforeRevision() != null) {\n                addToPaths(c.getBeforeRevision().getFile(), allPaths);\n              }\n            case MODIFICATION:\n            default:\n              // do nothing\n          }\n        }\n      }\n      catch (Exception t) {\n        // ignore exceptions\n      }\n    }\n\n    removeCommonParents(allPaths);\n\n    final List<FilePath> paths = new ArrayList<FilePath>(allPaths.size());\n    for (String p : allPaths) {\n      final File file = new File(p);\n      paths.add(new FilePathImpl(file, file.isDirectory()));\n    }\n    return paths;\n  }","commit_id":"f8c80c6bc09ddd05522f2a1eb17b3df83e5dfa17","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public int getTileXMax(int zoom) {\n        Projection proj = Main.getProjection();\n        double scale = getDegreesPerTile(zoom);\n        Bounds bounds = Main.getProjection().getWorldBoundsLatLon();\n        EastNorth min = proj.latlon2eastNorth(bounds.getMin());\n        EastNorth max = proj.latlon2eastNorth(bounds.getMax());\n        return (int) Math.ceil(Math.abs(max.getX() - min.getX()) / scale);\n    }","id":84987,"modified_method":"@Override\n    public int getTileXMax(int zoom) {\n        LatLon bottomRight = new LatLon(worldBounds.getMinLat(), worldBounds.getMaxLon());\n        return latLonToTileXY(bottomRight.toCoordinate(), zoom).getXIndex();\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"private double getDegreesPerTile(int zoom) {\n        return getDegreesPerTile(zoom, Main.getProjection());\n    }","id":84988,"modified_method":"private double getDegreesPerTile(int zoom) {\n        Projection proj = Main.getProjection();\n        EastNorth min = proj.latlon2eastNorth(worldBounds.getMin());\n        EastNorth max = proj.latlon2eastNorth(worldBounds.getMax());\n\n        int tilesPerZoom = (int) Math.pow(2, zoom - 1);\n        return Math.max(\n                Math.abs(max.getY() - min.getY()) / tilesPerZoom,\n                Math.abs(max.getX() - min.getX()) / tilesPerZoom\n                );\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public int getTileYMax(int zoom) {\n        Projection proj = Main.getProjection();\n        double scale = getDegreesPerTile(zoom);\n        Bounds bounds = Main.getProjection().getWorldBoundsLatLon();\n        EastNorth min = proj.latlon2eastNorth(bounds.getMin());\n        EastNorth max = proj.latlon2eastNorth(bounds.getMax());\n        return (int) Math.ceil(Math.abs(max.getY() - min.getY()) / scale);\n    }","id":84989,"modified_method":"@Override\n    public int getTileYMax(int zoom) {\n        LatLon bottomRight = new LatLon(worldBounds.getMinLat(), worldBounds.getMaxLon());\n        return latLonToTileXY(bottomRight.toCoordinate(), zoom).getYIndex();\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Initializes class with projection in JOSM. This call is needed every time projection changes.\n     * @param proj new projection that shall be used for computations\n     */\n    public void initProjection(Projection proj) {\n        Bounds bounds = proj.getWorldBoundsLatLon();\n        EastNorth min = proj.latlon2eastNorth(bounds.getMin());\n        EastNorth max = proj.latlon2eastNorth(bounds.getMax());\n        this.topLeftCorner = new EastNorth(min.east(), max.north());\n    }","id":84990,"modified_method":"/**\n     * Initializes class with projection in JOSM. This call is needed every time projection changes.\n     * @param proj new projection that shall be used for computations\n     */\n    public void initProjection(Projection proj) {\n        this.worldBounds = getWorldBounds();\n        EastNorth min = proj.latlon2eastNorth(worldBounds.getMin());\n        EastNorth max = proj.latlon2eastNorth(worldBounds.getMax());\n        this.topLeftCorner = new EastNorth(min.east(), max.north());\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void verifyLocation(TemplatedWMSTileSource source, LatLon location) {\n        for (int z = 1; z < 22; z++) {\n            TileXY tileIndex = source.latLonToTileXY(location.toCoordinate(), z);\n            BBox bbox = new BBox(\n                    getTileLatLon(source, tileIndex, z),\n                    getTileLatLon(source, tileIndex.getXIndex() + 1, tileIndex.getYIndex() + 1, z)\n                    );\n            assertTrue(location.toDisplayString() + \" not within \" + bbox.toString() +\n                    \" for tile \" + z + \"/\" + tileIndex.getXIndex() + \"/\" + tileIndex.getYIndex(),\n                    bbox.bounds(location));\n        }\n    }","id":84991,"modified_method":"private void verifyLocation(TemplatedWMSTileSource source, LatLon location) {\n        for (int z = 22; z > 1; z--) {\n            verifyLocation(source, location, z);\n        }\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void verifyMercatorTile(TemplatedWMSTileSource source, int x, int y, int z) {\n        TemplatedTMSTileSource verifier = new TemplatedTMSTileSource(testImageryTMS);\n        LatLon result = getTileLatLon(source, x, y, z);\n        LatLon expected = new LatLon(verifier.tileYToLat(y, z - 1), verifier.tileXToLon(x, z - 1)); //\n        System.out.println(z + \"/\" + x + \"/\" + y + \" - result: \" + result.toDisplayString() + \" osmMercator: \" +  expected.toDisplayString());\n        assertTrue(\"result: \" + result.toDisplayString() + \" osmMercator: \" +  expected.toDisplayString(), result.equalsEpsilon(expected));\n        LatLon tileCenter = new Bounds(result, getTileLatLon(source, x+1, y+1, z)).getCenter();\n        TileXY backwardsResult = source.latLonToTileXY(tileCenter.toCoordinate(), z);\n        assertEquals(x, backwardsResult.getXIndex());\n        assertEquals(y, backwardsResult.getYIndex());\n    }","id":84992,"modified_method":"private void verifyMercatorTile(TemplatedWMSTileSource source, int x, int y, int z) {\n        TemplatedTMSTileSource verifier = new TemplatedTMSTileSource(testImageryTMS);\n        LatLon result = getTileLatLon(source, x, y, z);\n        LatLon expected = new LatLon(verifier.tileYToLat(y, z - 1), verifier.tileXToLon(x, z - 1)); //\n        assertTrue(\"result: \" + result.toDisplayString() + \" osmMercator: \" +  expected.toDisplayString(), result.equalsEpsilon(expected));\n        LatLon tileCenter = new Bounds(result, getTileLatLon(source, x+1, y+1, z)).getCenter();\n        TileXY backwardsResult = source.latLonToTileXY(tileCenter.toCoordinate(), z);\n        assertEquals(x, backwardsResult.getXIndex());\n        assertEquals(y, backwardsResult.getYIndex());\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void verifyTileSquarness(TemplatedWMSTileSource source, int x, int y, int z) {\n        Projection proj = Main.getProjection();\n        /**\n         * t1 | t2\n         * -------\n         * t3 | t4\n         */\n        EastNorth t1 = proj.latlon2eastNorth(getTileLatLon(source, x, y, z));\n        EastNorth t2 = proj.latlon2eastNorth(getTileLatLon(source, x + 1, y, z));\n        EastNorth t3 = proj.latlon2eastNorth(getTileLatLon(source, x, y + 1, z));\n        EastNorth t4 = proj.latlon2eastNorth(getTileLatLon(source, x + 1, y + 1, z));\n        double y_size = Math.abs(t1.getY() - t4.getY());\n        double x_size = Math.abs(t1.getX() - t4.getX());\n\n        assertEquals(x_size, y_size, Math.max(x_size, y_size) * 1e-05);\n        assertEquals(y_size, Math.abs(t1.getY() - t3.getY()), y_size * 1e-05);\n        assertEquals(x_size, Math.abs(t1.getX() - t2.getX()), x_size * 1e-05);\n\n        t1 = source.getTileEastNorth(x, y, z);\n        t2 = source.getTileEastNorth(x + 1, y, z);\n        t3 = source.getTileEastNorth(x, y + 1, z);\n        t4 = source.getTileEastNorth(x + 1, y + 1, z);\n        y_size = Math.abs(t1.getY() - t4.getY());\n        x_size = Math.abs(t1.getX() - t4.getX());\n        assertEquals(x_size, y_size, Math.max(x_size, y_size) * 1e-05);\n        assertEquals(y_size, Math.abs(t1.getY() - t3.getY()), y_size * 1e-05);\n        assertEquals(x_size, Math.abs(t1.getX() - t2.getX()), x_size * 1e-05);\n    }","id":84993,"modified_method":"private void verifyTileSquarness(TemplatedWMSTileSource source, int x, int y, int z) {\n        Projection proj = Main.getProjection();\n        /**\n         * t1 | t2\n         * -------\n         * t3 | t4\n         */\n        EastNorth t1 = source.getTileEastNorth(x, y, z);\n        EastNorth t2 = source.getTileEastNorth(x + 1, y, z);\n        EastNorth t3 = source.getTileEastNorth(x, y + 1, z);\n        EastNorth t4 = source.getTileEastNorth(x + 1, y + 1, z);\n        double y_size = Math.abs(t1.getY() - t4.getY());\n        double x_size = Math.abs(t1.getX() - t4.getX());\n\n        assertEquals(x_size, y_size, Math.max(x_size, y_size) * 1e-06);\n        assertEquals(y_size, Math.abs(t1.getY() - t3.getY()), y_size * 1e-06);\n        assertEquals(x_size, Math.abs(t1.getX() - t2.getX()), x_size * 1e-06);\n\n        t1 = source.getTileEastNorth(x, y, z);\n        t2 = source.getTileEastNorth(x + 1, y, z);\n        t3 = source.getTileEastNorth(x, y + 1, z);\n        t4 = source.getTileEastNorth(x + 1, y + 1, z);\n        y_size = Math.abs(t1.getY() - t4.getY());\n        x_size = Math.abs(t1.getX() - t4.getX());\n        assertEquals(x_size, y_size, Math.max(x_size, y_size) * 1e-05);\n        assertEquals(y_size, Math.abs(t1.getY() - t3.getY()), y_size * 1e-05);\n        assertEquals(x_size, Math.abs(t1.getX() - t2.getX()), x_size * 1e-05);\n    }","commit_id":"8d03197b58204d76db534b418808e5507fef2d7d","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n   * Hashes a specified key into several integers.\n   * @param k The specified key.\n   * @return The array of hashed values.\n   */\n  public int[] hash(Key k){\n      byte[] b = k.getBytes();\n      if(b == null) {\n        throw new NullPointerException(\"buffer reference is null\");\n      }\n      if(b.length == 0) {\n        throw new IllegalArgumentException(\"key length must be > 0\");\n      }\n      int[] result = new int[nbHash];\n      for (int i = 0, initval = 0; i < nbHash; i++) {\n        initval = result[i] = Math.abs(hashFunction.hash(b, initval) % maxValue);\n      }\n      return result;\n  }","id":84994,"modified_method":"/**\n   * Hashes a specified key into several integers.\n   * @param k The specified key.\n   * @return The array of hashed values.\n   */\n  public int[] hash(Key k){\n      byte[] b = k.getBytes();\n      if(b == null) {\n        throw new NullPointerException(\"buffer reference is null\");\n      }\n      if(b.length == 0) {\n        throw new IllegalArgumentException(\"key length must be > 0\");\n      }\n      int[] result = new int[nbHash];\n      for (int i = 0, initval = 0; i < nbHash; i++) {\n\t  initval = hashFunction.hash(b, initval);\n\t  result[i] = Math.abs(initval) % maxValue;\n      }\n      return result;\n  }","commit_id":"7fccb0258ea1bc8fa952a5ebd629d1808ee4e6ee","url":"https://github.com/apache/hbase"},{"original_method":"/** Test a DynamicBloomFilter\n   * @throws UnsupportedEncodingException\n   */\n  public void testDynamicBloomFilter() throws UnsupportedEncodingException {\n    Filter bf = new DynamicBloomFilter(8, 2, Hash.JENKINS_HASH, 2);\n    Key key = new StringKey(\"toto\");\n    Key k2 = new StringKey(\"lulu\");\n    Key k3 = new StringKey(\"mama\");\n    bf.add(key);\n    bf.add(k2);\n    bf.add(k3);\n    assertTrue(bf.membershipTest(key));\n    assertTrue(bf.membershipTest(new StringKey(\"graknyl\")));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n  }","id":84995,"modified_method":"/** Test a DynamicBloomFilter\n   * @throws UnsupportedEncodingException\n   */\n  public void testDynamicBloomFilter() throws UnsupportedEncodingException {\n    Filter bf = new DynamicBloomFilter(128, 2, Hash.JENKINS_HASH, 2);\n    Key key = new StringKey(\"toto\");\n    Key k2 = new StringKey(\"lulu\");\n    Key k3 = new StringKey(\"mama\");\n    bf.add(key);\n    bf.add(k2);\n    bf.add(k3);\n    assertTrue(bf.membershipTest(key));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n  }","commit_id":"7fccb0258ea1bc8fa952a5ebd629d1808ee4e6ee","url":"https://github.com/apache/hbase"},{"original_method":"/** Test a CountingBloomFilter\n   * @throws UnsupportedEncodingException\n   */\n  public void testCountingBloomFilter() throws UnsupportedEncodingException {\n    Filter bf = new CountingBloomFilter(8, 2, Hash.JENKINS_HASH);\n    Key key = new StringKey(\"toto\");\n    Key k2 = new StringKey(\"lulu\");\n    Key k3 = new StringKey(\"mama\");\n    bf.add(key);\n    bf.add(k2);\n    bf.add(k3);\n    assertTrue(bf.membershipTest(key));\n    assertTrue(bf.membershipTest(new StringKey(\"graknyl\")));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n\n    // delete 'key', and check that it is no longer a member\n    ((CountingBloomFilter)bf).delete(key);\n    assertFalse(bf.membershipTest(key));\n    \n    // OR 'key' back into the filter\n    Filter bf2 = new CountingBloomFilter(8, 2, Hash.JENKINS_HASH);\n    bf2.add(key);\n    bf.or(bf2);\n    assertTrue(bf.membershipTest(key));\n    assertTrue(bf.membershipTest(new StringKey(\"graknyl\")));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n    \n    // to test for overflows, add 'key' enough times to overflow a 4bit bucket,\n    // while asserting that it stays a member\n    for(int i = 0; i < 16; i++){\n      bf.add(key);\n      assertTrue(bf.membershipTest(key));\n    }\n    // test approximateCount\n    CountingBloomFilter bf3 = new CountingBloomFilter(4, 2, Hash.JENKINS_HASH);\n    // test the exact range\n    for (int i = 0; i < 8; i++) {\n      bf3.add(key);\n      bf3.add(k2);\n      assertEquals(bf3.approximateCount(key), i + 1);\n      assertEquals(bf3.approximateCount(k2), i + 1);\n    }\n    // test gently degraded counting in high-fill, high error rate filter\n    for (int i = 8; i < 15; i++) {\n      bf3.add(key);\n      assertTrue(bf3.approximateCount(key) >= (i + 1));\n      assertEquals(bf3.approximateCount(k2), 8);\n      assertEquals(bf3.approximateCount(k3), 0);\n    }\n  }","id":84996,"modified_method":"/** Test a CountingBloomFilter\n   * @throws UnsupportedEncodingException\n   */\n  public void testCountingBloomFilter() throws UnsupportedEncodingException {\n    Filter bf = new CountingBloomFilter(128, 2, Hash.JENKINS_HASH);\n    Key key = new StringKey(\"toto\");\n    Key k2 = new StringKey(\"lulu\");\n    Key k3 = new StringKey(\"mama\");\n    bf.add(key);\n    bf.add(k2);\n    bf.add(k3);\n    assertTrue(bf.membershipTest(key));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n\n    // delete 'key', and check that it is no longer a member\n    ((CountingBloomFilter)bf).delete(key);\n    assertFalse(bf.membershipTest(key));\n    \n    // to test for overflows, add 'key' enough times to overflow a 4bit bucket,\n    // while asserting that it stays a member\n    for(int i = 0; i < 16; i++){\n      bf.add(key);\n      assertTrue(bf.membershipTest(key));\n    }\n    // test approximateCount\n    CountingBloomFilter bf3 = new CountingBloomFilter(4, 2, Hash.JENKINS_HASH);\n    // test the exact range\n    for (int i = 0; i < 8; i++) {\n      bf3.add(key);\n      bf3.add(k2);\n      assertEquals(bf3.approximateCount(key), i + 1);\n      assertEquals(bf3.approximateCount(k2), i + 1);\n    }\n    // test gently degraded counting in high-fill, high error rate filter\n    for (int i = 8; i < 15; i++) {\n      bf3.add(key);\n      assertTrue(bf3.approximateCount(key) >= (i + 1));\n      assertEquals(bf3.approximateCount(k2), 8);\n      assertEquals(bf3.approximateCount(k3), 0);\n    }\n  }","commit_id":"7fccb0258ea1bc8fa952a5ebd629d1808ee4e6ee","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Hashes a specified key into several integers.\n   * @param k The specified key.\n   * @return The array of hashed values.\n   */\n  public int[] hash(Key k){\n      byte[] b = k.getBytes();\n      if(b == null) {\n        throw new NullPointerException(\"buffer reference is null\");\n      }\n      if(b.length == 0) {\n        throw new IllegalArgumentException(\"key length must be > 0\");\n      }\n      int[] result = new int[nbHash];\n      for (int i = 0, initval = 0; i < nbHash; i++) {\n\t  initval = hashFunction.hash(b, initval);\n\t  result[i] = Math.abs(initval) % maxValue;\n      }\n      return result;\n  }","id":84997,"modified_method":"/**\n   * Hashes a specified key into several integers.\n   * @param k The specified key.\n   * @return The array of hashed values.\n   */\n  public int[] hash(Key k){\n      byte[] b = k.getBytes();\n      if(b == null) {\n        throw new NullPointerException(\"buffer reference is null\");\n      }\n      if(b.length == 0) {\n        throw new IllegalArgumentException(\"key length must be > 0\");\n      }\n      int[] result = new int[nbHash];\n      for (int i = 0, initval = 0; i < nbHash; i++) {\n        initval = result[i] = Math.abs(hashFunction.hash(b, initval) % maxValue);\n      }\n      return result;\n  }","commit_id":"ce2995c49d111b5749a88b4de2065a3a68551386","url":"https://github.com/apache/hbase"},{"original_method":"/** Test a CountingBloomFilter\n   * @throws UnsupportedEncodingException\n   */\n  public void testCountingBloomFilter() throws UnsupportedEncodingException {\n    Filter bf = new CountingBloomFilter(8, 2, Hash.JENKINS_HASH);\n    Key key = new StringKey(\"toto\");\n    Key k2 = new StringKey(\"lulu\");\n    Key k3 = new StringKey(\"mama\");\n    bf.add(key);\n    bf.add(k2);\n    bf.add(k3);\n    assertTrue(bf.membershipTest(key));\n    assertFalse(bf.membershipTest(k2));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n\n    // delete 'key', and check that it is no longer a member\n    ((CountingBloomFilter)bf).delete(key);\n    assertFalse(bf.membershipTest(key));\n    \n    // OR 'key' back into the filter\n    Filter bf2 = new CountingBloomFilter(8, 2, Hash.JENKINS_HASH);\n    bf2.add(key);\n    bf.or(bf2);\n    assertTrue(bf.membershipTest(key));\n    assertTrue(bf.membershipTest(k2));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n    \n    // to test for overflows, add 'key' enough times to overflow a 4bit bucket,\n    // while asserting that it stays a member\n    for(int i = 0; i < 16; i++){\n      bf.add(key);\n      assertTrue(bf.membershipTest(key));\n    }\n    // test approximateCount\n    CountingBloomFilter bf3 = new CountingBloomFilter(4, 2, Hash.JENKINS_HASH);\n    // test the exact range\n    for (int i = 0; i < 8; i++) {\n      bf3.add(key);\n      bf3.add(k2);\n      assertEquals(bf3.approximateCount(key), i + 1);\n      assertEquals(bf3.approximateCount(k2), i + 1);\n    }\n    // test gently degraded counting in high-fill, high error rate filter\n    for (int i = 8; i < 15; i++) {\n      bf3.add(key);\n      assertTrue(bf3.approximateCount(key) >= (i + 1));\n      assertEquals(bf3.approximateCount(k2), 8);\n      assertEquals(bf3.approximateCount(k3), 0);\n    }\n  }","id":84998,"modified_method":"/** Test a CountingBloomFilter\n   * @throws UnsupportedEncodingException\n   */\n  public void testCountingBloomFilter() throws UnsupportedEncodingException {\n    Filter bf = new CountingBloomFilter(8, 2, Hash.JENKINS_HASH);\n    Key key = new StringKey(\"toto\");\n    Key k2 = new StringKey(\"lulu\");\n    Key k3 = new StringKey(\"mama\");\n    bf.add(key);\n    bf.add(k2);\n    bf.add(k3);\n    assertTrue(bf.membershipTest(key));\n    assertTrue(bf.membershipTest(new StringKey(\"graknyl\")));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n\n    // delete 'key', and check that it is no longer a member\n    ((CountingBloomFilter)bf).delete(key);\n    assertFalse(bf.membershipTest(key));\n    \n    // OR 'key' back into the filter\n    Filter bf2 = new CountingBloomFilter(8, 2, Hash.JENKINS_HASH);\n    bf2.add(key);\n    bf.or(bf2);\n    assertTrue(bf.membershipTest(key));\n    assertTrue(bf.membershipTest(new StringKey(\"graknyl\")));\n    assertFalse(bf.membershipTest(new StringKey(\"xyzzy\")));\n    assertFalse(bf.membershipTest(new StringKey(\"abcd\")));\n    \n    // to test for overflows, add 'key' enough times to overflow a 4bit bucket,\n    // while asserting that it stays a member\n    for(int i = 0; i < 16; i++){\n      bf.add(key);\n      assertTrue(bf.membershipTest(key));\n    }\n    // test approximateCount\n    CountingBloomFilter bf3 = new CountingBloomFilter(4, 2, Hash.JENKINS_HASH);\n    // test the exact range\n    for (int i = 0; i < 8; i++) {\n      bf3.add(key);\n      bf3.add(k2);\n      assertEquals(bf3.approximateCount(key), i + 1);\n      assertEquals(bf3.approximateCount(k2), i + 1);\n    }\n    // test gently degraded counting in high-fill, high error rate filter\n    for (int i = 8; i < 15; i++) {\n      bf3.add(key);\n      assertTrue(bf3.approximateCount(key) >= (i + 1));\n      assertEquals(bf3.approximateCount(k2), 8);\n      assertEquals(bf3.approximateCount(k3), 0);\n    }\n  }","commit_id":"ce2995c49d111b5749a88b4de2065a3a68551386","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Hashes a specified key into several integers.\n   * @param k The specified key.\n   * @return The array of hashed values.\n   */\n  public int[] hash(Key k){\n      byte[] b = k.getBytes();\n      if(b == null) {\n        throw new NullPointerException(\"buffer reference is null\");\n      }\n      if(b.length == 0) {\n        throw new IllegalArgumentException(\"key length must be > 0\");\n      }\n      int[] result = new int[nbHash];\n      for (int i = 0, initval = 0; i < nbHash; i++) {\n        initval = result[i] = Math.abs(hashFunction.hash(b, initval) % maxValue);\n      }\n      return result;\n  }","id":84999,"modified_method":"/**\n   * Hashes a specified key into several integers.\n   * @param k The specified key.\n   * @return The array of hashed values.\n   */\n  public int[] hash(Key k){\n      byte[] b = k.getBytes();\n      if(b == null) {\n        throw new NullPointerException(\"buffer reference is null\");\n      }\n      if(b.length == 0) {\n        throw new IllegalArgumentException(\"key length must be > 0\");\n      }\n      int[] result = new int[nbHash];\n      for (int i = 0, initval = 0; i < nbHash; i++) {\n\t  initval = hashFunction.hash(b, initval);\n\t  result[i] = Math.abs(initval) % maxValue;\n      }\n      return result;\n  }","commit_id":"03adaea261bcbc46bef141cd110e92a1dca0ed87","url":"https://github.com/apache/hbase"}]