[{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    super.actionPerformed(e);\n\n    DataContext dataContext = e.getDataContext();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return;\n    final BookmarkInContextInfo info = new BookmarkInContextInfo(dataContext, project).invoke();\n    final Bookmark bookmark = info.getBookmarkAtPlace();\n    final BookmarkManager bookmarks = BookmarkManager.getInstance(project);\n    if (bookmark != null) {\n      final JBPopup[] popup = new JBPopup[1];\n      MnemonicChooser mc = new MnemonicChooser() {\n        @Override\n        protected void onMnemonicChosen(char c) {\n          popup[0].cancel();\n          bookmarks.setMnemonic(bookmark, c);\n        }\n\n        @Override\n        protected void onCancelled() {\n          popup[0].cancel();\n          bookmarks.removeBookmark(bookmark);\n        }\n\n        @Override\n        protected boolean isOccupied(char c) {\n          return bookmarks.findBookmarkForMnemonic(c) != null;\n        }\n      };\n\n      final ComponentPopupBuilder builder = JBPopupFactory.getInstance().createComponentPopupBuilder(mc, mc);\n      popup[0] = builder.\n        setTitle(\"Bookmark Mnemonic\").\n        setFocusable(true).\n        setRequestFocus(true).\n        setMovable(false).\n        setCancelKeyEnabled(false).\n        setAdText(bookmarks.hasBookmarksWithMnemonics() ? (UIUtil.isUnderDarcula() ? \"Brown\" : \"Yellow\") + \" cells are in use\" : null).\n        setResizable(false)\n          .createPopup();\n\n      popup[0].showInBestPositionFor(dataContext);\n    }\n  }","id":104000,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    super.actionPerformed(e);\n\n    final Project project = e.getProject();\n    if (project == null) return;\n\n    final BookmarkInContextInfo info = new BookmarkInContextInfo(e.getDataContext(), project).invoke();\n    final Bookmark bookmark = info.getBookmarkAtPlace();\n    final BookmarkManager bookmarks = BookmarkManager.getInstance(project);\n    if (bookmark != null) {\n      final JBPopup[] popup = new JBPopup[1];\n\n      MnemonicChooser mc = new MnemonicChooser() {\n        @Override\n        protected void onMnemonicChosen(char c) {\n          popup[0].cancel();\n          bookmarks.setMnemonic(bookmark, c);\n        }\n\n        @Override\n        protected void onCancelled() {\n          popup[0].cancel();\n          bookmarks.removeBookmark(bookmark);\n        }\n\n        @Override\n        protected boolean isOccupied(char c) {\n          return bookmarks.findBookmarkForMnemonic(c) != null;\n        }\n      };\n\n      popup[0] = JBPopupFactory.getInstance().createComponentPopupBuilder(mc, mc).\n        setTitle(\"Bookmark Mnemonic\").\n        setFocusable(true).\n        setRequestFocus(true).\n        setMovable(false).\n        setCancelKeyEnabled(false).\n        setAdText(bookmarks.hasBookmarksWithMnemonics() ? (UIUtil.isUnderDarcula() ? \"Brown\" : \"Yellow\") + \" cells are in use\" : null).\n        setResizable(false).\n        createPopup();\n\n      popup[0].showInBestPositionFor(e.getDataContext());\n    }\n  }","commit_id":"818a1aef4698658c128b0757a63e01743b39bc1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n\n    BookmarksAction.BookmarkInContextInfo info = new BookmarksAction.BookmarkInContextInfo(dataContext, project).invoke();\n    if (info.getFile() == null) return;\n\n    final Bookmark oldBookmark = info.getBookmarkAtPlace();\n\n    final BookmarkManager manager = BookmarkManager.getInstance(project);\n    if (oldBookmark != null) {\n      manager.removeBookmark(oldBookmark);\n    }\n\n    if (oldBookmark == null || oldBookmark.getMnemonic() != '0' + myNumber) {\n      final Bookmark bookmark = manager.addTextBookmark(info.getFile(), info.getLine(), \"\");\n      manager.setMnemonic(bookmark, (char)('0' + myNumber));\n    }\n  }","id":104001,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null) return;\n\n    BookmarksAction.BookmarkInContextInfo info = new BookmarksAction.BookmarkInContextInfo(e.getDataContext(), project).invoke();\n    if (info.getFile() == null) return;\n\n    Bookmark oldBookmark = info.getBookmarkAtPlace();\n    BookmarkManager manager = BookmarkManager.getInstance(project);\n\n    if (oldBookmark != null) {\n      manager.removeBookmark(oldBookmark);\n    }\n\n    char mnemonic = (char)('0' + myNumber);\n    if (oldBookmark == null || oldBookmark.getMnemonic() != mnemonic) {\n      Bookmark bookmark = manager.addTextBookmark(info.getFile(), info.getLine(), \"\");\n      manager.setMnemonic(bookmark, mnemonic);\n    }\n  }","commit_id":"818a1aef4698658c128b0757a63e01743b39bc1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    e.getPresentation().setEnabled(project != null);\n  }","id":104002,"modified_method":"@Override\n  public void update(@NotNull AnActionEvent e) {\n    e.getPresentation().setEnabled(e.getProject() != null);\n  }","commit_id":"818a1aef4698658c128b0757a63e01743b39bc1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent event) {\n    Presentation presentation = event.getPresentation();\n    final DataContext dataContext = event.getDataContext();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    final boolean dumbMode = project == null || DumbService.getInstance(project).isDumb();\n    presentation.setEnabled(!dumbMode && getInspectionScope(dataContext) != null);\n  }","id":104003,"modified_method":"@Override\n  public void update(AnActionEvent event) {\n    Presentation presentation = event.getPresentation();\n    final DataContext dataContext = event.getDataContext();\n    final Project project = event.getProject();\n    final boolean dumbMode = project == null || DumbService.getInstance(project).isDumb();\n    presentation.setEnabled(!dumbMode && getInspectionScope(dataContext) != null);\n  }","commit_id":"577cef9f1861d2e708ba1099a578895692f90983","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent event) {\n    Presentation presentation = event.getPresentation();\n    DataContext dataContext = event.getDataContext();\n\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    Editor editor = getEditor(dataContext, project);\n    if (editor == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    final PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n    presentation.setEnabled(file != null && isValidForFile(project, editor, file));\n  }","id":104004,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    Presentation presentation = e.getPresentation();\n\n    Project project = e.getProject();\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    Editor editor = getEditor(e.getDataContext(), project);\n    if (editor == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    final PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n    presentation.setEnabled(file != null && isValidForFile(project, editor, file));\n  }","commit_id":"577cef9f1861d2e708ba1099a578895692f90983","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      Editor editor = getEditor(dataContext, project);\n      actionPerformedImpl(project, editor);\n    }\n  }","id":104005,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project != null) {\n      Editor editor = getEditor(e.getDataContext(), project);\n      actionPerformedImpl(project, editor);\n    }\n  }","commit_id":"577cef9f1861d2e708ba1099a578895692f90983","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public final void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n\n    final IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n    if (view == null) {\n      return;\n    }\n\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n\n    final PsiDirectory dir = view.getOrChooseDirectory();\n    if (dir == null) return;\n    final PsiElement[] createdElements = invokeDialog(project, dir);\n\n    for (PsiElement createdElement : createdElements) {\n      view.selectElement(createdElement);\n    }\n  }","id":104006,"modified_method":"@Override\n  public final void actionPerformed(final AnActionEvent e) {\n    final IdeView view = e.getData(LangDataKeys.IDE_VIEW);\n    if (view == null) {\n      return;\n    }\n\n    final Project project = e.getProject();\n\n    final PsiDirectory dir = view.getOrChooseDirectory();\n    if (dir == null) return;\n    final PsiElement[] createdElements = invokeDialog(project, dir);\n\n    for (PsiElement createdElement : createdElements) {\n      view.selectElement(createdElement);\n    }\n  }","commit_id":"577cef9f1861d2e708ba1099a578895692f90983","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = CommonDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) {\n      return;\n    }\n    \n    final Editor editor = CommonDataKeys.EDITOR.getData(e.getDataContext());\n    if (editor == null) {\n      return;\n    }\n    \n    PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    Document document = editor.getDocument();\n    documentManager.commitDocument(document);\n    \n    final PsiFile file = documentManager.getPsiFile(document);\n    if (file == null) {\n      return;\n    }\n\n    final List<TextRange> ranges = new ArrayList<TextRange>();\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (selectionModel.hasSelection()) {\n      ranges.add(TextRange.create(selectionModel.getSelectionStart(), selectionModel.getSelectionEnd()));\n    }\n    else if (selectionModel.hasBlockSelection()) {\n      int[] starts = selectionModel.getBlockSelectionStarts();\n      int[] ends = selectionModel.getBlockSelectionEnds();\n      for (int i = 0; i < starts.length; i++) {\n        ranges.add(TextRange.create(starts[i], ends[i]));\n      }\n    }\n    else {\n      ranges.add(TextRange.create(0, document.getTextLength()));\n    }\n    \n    final ArrangementEngine engine = ServiceManager.getService(project, ArrangementEngine.class);\n    try {\n      CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n        @Override\n        public void run() {\n          engine.arrange(editor, file, ranges); \n        }\n      }, getTemplatePresentation().getText(), null);\n    }\n    finally {\n      documentManager.commitDocument(document);\n    }\n  }","id":104007,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getProject();\n    if (project == null) {\n      return;\n    }\n    \n    final Editor editor = e.getData(CommonDataKeys.EDITOR);\n    if (editor == null) {\n      return;\n    }\n    \n    PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    Document document = editor.getDocument();\n    documentManager.commitDocument(document);\n    \n    final PsiFile file = documentManager.getPsiFile(document);\n    if (file == null) {\n      return;\n    }\n\n    final List<TextRange> ranges = new ArrayList<TextRange>();\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (selectionModel.hasSelection()) {\n      ranges.add(TextRange.create(selectionModel.getSelectionStart(), selectionModel.getSelectionEnd()));\n    }\n    else if (selectionModel.hasBlockSelection()) {\n      int[] starts = selectionModel.getBlockSelectionStarts();\n      int[] ends = selectionModel.getBlockSelectionEnds();\n      for (int i = 0; i < starts.length; i++) {\n        ranges.add(TextRange.create(starts[i], ends[i]));\n      }\n    }\n    else {\n      ranges.add(TextRange.create(0, document.getTextLength()));\n    }\n    \n    final ArrangementEngine engine = ServiceManager.getService(project, ArrangementEngine.class);\n    try {\n      CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n        @Override\n        public void run() {\n          engine.arrange(editor, file, ranges); \n        }\n      }, getTemplatePresentation().getText(), null);\n    }\n    finally {\n      documentManager.commitDocument(document);\n    }\n  }","commit_id":"577cef9f1861d2e708ba1099a578895692f90983","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(@NotNull AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Presentation presentation = e.getPresentation();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      final VirtualFile[] files = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n      if (files != null && files.length > 0) {\n        for (VirtualFile file : files) {\n          final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n          if (!(psiFile instanceof XmlFile)) {\n            continue;\n          }\n          final XmlFile xmlFile = (XmlFile)psiFile;\n          final XmlDocument document = xmlFile.getDocument();\n          if (document == null) {\n            continue;\n          }\n          final XmlTag rootTag = document.getRootTag();\n          if (rootTag == null) {\n            continue;\n          }\n          if (!\"project\".equals(rootTag.getName())) {\n            continue;\n          }\n          if (AntConfigurationBase.getInstance(project).getAntBuildFile(psiFile) != null) {\n            continue;\n          }\n          // found at least one candidate file\n          enable(presentation);\n          return;\n        }\n      }\n    }\n\n    disable(presentation);\n  }","id":104008,"modified_method":"public void update(@NotNull AnActionEvent e) {\n    final Presentation presentation = e.getPresentation();\n    final Project project = e.getProject();\n    if (project != null) {\n      final VirtualFile[] files = e.getData(CommonDataKeys.VIRTUAL_FILE_ARRAY);\n      if (files != null && files.length > 0) {\n        for (VirtualFile file : files) {\n          final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n          if (!(psiFile instanceof XmlFile)) {\n            continue;\n          }\n          final XmlFile xmlFile = (XmlFile)psiFile;\n          final XmlDocument document = xmlFile.getDocument();\n          if (document == null) {\n            continue;\n          }\n          final XmlTag rootTag = document.getRootTag();\n          if (rootTag == null) {\n            continue;\n          }\n          if (!\"project\".equals(rootTag.getName())) {\n            continue;\n          }\n          if (AntConfigurationBase.getInstance(project).getAntBuildFile(psiFile) != null) {\n            continue;\n          }\n          // found at least one candidate file\n          enable(presentation);\n          return;\n        }\n      }\n    }\n\n    disable(presentation);\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(@NotNull AnActionEvent event) {\n    final DataContext dataContext = event.getDataContext();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      return;\n    }\n    final VirtualFile[] contextFiles = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n    if (contextFiles == null || contextFiles.length == 0) {\n      return;\n    }\n    final AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n\n    final Set<VirtualFile> files = new HashSet<VirtualFile>();\n    files.addAll(Arrays.asList(contextFiles));\n    for (AntBuildFile buildFile : antConfiguration.getBuildFiles()) {\n      files.remove(buildFile.getVirtualFile());\n    }\n    \n    int filesAdded = 0;\n    final StringBuilder errors = new StringBuilder();\n\n    for (VirtualFile file : files) {\n      try {\n        antConfiguration.addBuildFile(file);\n        filesAdded++;\n      }\n      catch (AntNoFileException e) {\n        String message = e.getMessage();\n        if (message == null || message.length() == 0) {\n          message = AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\", e.getFile().getPresentableUrl());\n        }\n        if (errors.length() > 0) {\n          errors.append(\"\\n\");\n        }\n        errors.append(message);\n      }\n    }\n\n    if (errors.length() > 0) {\n      Messages.showWarningDialog(project, errors.toString(), AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n    if (filesAdded > 0) {\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n  }","id":104009,"modified_method":"public void actionPerformed(@NotNull AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Project project = e.getProject();\n    if (project == null) {\n      return;\n    }\n    final VirtualFile[] contextFiles = e.getData(CommonDataKeys.VIRTUAL_FILE_ARRAY);\n    if (contextFiles == null || contextFiles.length == 0) {\n      return;\n    }\n    final AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n\n    final Set<VirtualFile> files = new HashSet<VirtualFile>();\n    files.addAll(Arrays.asList(contextFiles));\n    for (AntBuildFile buildFile : antConfiguration.getBuildFiles()) {\n      files.remove(buildFile.getVirtualFile());\n    }\n    \n    int filesAdded = 0;\n    final StringBuilder errors = new StringBuilder();\n\n    for (VirtualFile file : files) {\n      try {\n        antConfiguration.addBuildFile(file);\n        filesAdded++;\n      }\n      catch (AntNoFileException e) {\n        String message = e.getMessage();\n        if (message == null || message.length() == 0) {\n          message = AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\", e.getFile().getPresentableUrl());\n        }\n        if (errors.length() > 0) {\n          errors.append(\"\\n\");\n        }\n        errors.append(message);\n      }\n    }\n\n    if (errors.length() > 0) {\n      Messages.showWarningDialog(project, errors.toString(), AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n    if (filesAdded > 0) {\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AnAction[] getChildren(@Nullable AnActionEvent e) {\n    if (e == null) return AnAction.EMPTY_ARRAY;\n    Project project = CommonDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) return AnAction.EMPTY_ARRAY;\n\n    final List<AnAction> children = new ArrayList<AnAction>();\n    final AntConfigurationBase antConfiguration = AntConfigurationBase.getInstance(project);\n    for (final AntBuildFile buildFile : antConfiguration.getBuildFiles()) {\n      final String name = buildFile.getPresentableName();\n      DefaultActionGroup subgroup = new DefaultActionGroup();\n      subgroup.getTemplatePresentation().setText(name, false);\n      subgroup.setPopup(true);\n      fillGroup(buildFile, subgroup, antConfiguration);\n      if (subgroup.getChildrenCount() > 0) {\n        children.add(subgroup);\n      }\n    }\n\n    return children.toArray(new AnAction[children.size()]);\n  }","id":104010,"modified_method":"@NotNull\n  public AnAction[] getChildren(@Nullable AnActionEvent e) {\n    if (e == null) return AnAction.EMPTY_ARRAY;\n    Project project = e.getProject();\n    if (project == null) return AnAction.EMPTY_ARRAY;\n\n    final List<AnAction> children = new ArrayList<AnAction>();\n    final AntConfigurationBase antConfiguration = AntConfigurationBase.getInstance(project);\n    for (final AntBuildFile buildFile : antConfiguration.getBuildFiles()) {\n      final String name = buildFile.getPresentableName();\n      DefaultActionGroup subgroup = new DefaultActionGroup();\n      subgroup.getTemplatePresentation().setText(name, false);\n      subgroup.setPopup(true);\n      fillGroup(buildFile, subgroup, antConfiguration);\n      if (subgroup.getChildrenCount() > 0) {\n        children.add(subgroup);\n      }\n    }\n\n    return children.toArray(new AnAction[children.size()]);\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent event) {\n    Project project = CommonDataKeys.PROJECT.getData(event.getDataContext());\n    Presentation presentation = event.getPresentation();\n    presentation.setEnabled(project != null);\n    presentation.setVisible(project != null);\n  }","id":104011,"modified_method":"public void update(AnActionEvent e) {\n    Project project = e.getProject();\n    Presentation presentation = e.getPresentation();\n    presentation.setEnabled(project != null);\n    presentation.setVisible(project != null);\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean executeTargetSynchronously(final DataContext dataContext, final AntBuildTarget target, final List<BuildFileProperty> additionalProperties) {\n    final Semaphore targetDone = new Semaphore();\n    targetDone.down();\n    final Ref<Boolean> result = Ref.create(Boolean.FALSE);\n    //noinspection SSBasedInspection\n    SwingUtilities.invokeLater(() -> {\n      try {\n        final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n        if (project == null || project.isDisposed()) {\n          targetDone.up();\n        }\n        else {\n          target.run(dataContext, additionalProperties, new AntBuildListener() {\n            public void buildFinished(int state, int errorCount) {\n              result.set((state == AntBuildListener.FINISHED_SUCCESSFULLY) && (errorCount == 0));\n              targetDone.up();\n            }\n          });\n        }\n      }\n      catch (Throwable e) {\n        targetDone.up();\n        LOG.error(e);\n      }\n    });\n    targetDone.waitFor();\n    return result.get();\n  }","id":104012,"modified_method":"public static boolean executeTargetSynchronously(final DataContext dataContext, final AntBuildTarget target, final List<BuildFileProperty> additionalProperties) {\n    final Semaphore targetDone = new Semaphore();\n    targetDone.down();\n    final Ref<Boolean> result = Ref.create(Boolean.FALSE);\n    //noinspection SSBasedInspection\n    SwingUtilities.invokeLater(() -> {\n      try {\n        final Project project = dataContext.getData(CommonDataKeys.PROJECT);\n        if (project == null || project.isDisposed()) {\n          targetDone.up();\n        }\n        else {\n          target.run(dataContext, additionalProperties, new AntBuildListener() {\n            public void buildFinished(int state, int errorCount) {\n              result.set((state == AntBuildListener.FINISHED_SUCCESSFULLY) && (errorCount == 0));\n              targetDone.up();\n            }\n          });\n        }\n      }\n      catch (Throwable e) {\n        targetDone.up();\n        LOG.error(e);\n      }\n    });\n    targetDone.waitFor();\n    return result.get();\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Pair<AntBuildFileBase, AntDomTarget> findAntTarget(@NotNull AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n\n    final Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n\n    if (project == null || editor == null) {\n      return null;\n    }\n    final VirtualFile file = CommonDataKeys.VIRTUAL_FILE.getData(dataContext);\n    if (file == null) {\n      return null;\n    }\n\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    if (!(psiFile instanceof XmlFile)) {\n      return null;\n    }\n    final XmlFile xmlFile = (XmlFile)psiFile;\n\n    final AntBuildFileBase antFile = AntConfigurationBase.getInstance(project).getAntBuildFile(xmlFile);\n    if (antFile == null) {\n      return null;\n    }\n\n    final PsiElement element = xmlFile.findElementAt(editor.getCaretModel().getOffset());\n    if (element == null) {\n      return null;\n    }\n    final XmlTag xmlTag = PsiTreeUtil.getParentOfType(element, XmlTag.class);\n    if (xmlTag == null) {\n      return null;\n    }\n\n    DomElement dom = AntSupport.getAntDomElement(xmlTag);\n    while (dom != null && !(dom instanceof AntDomTarget)) {\n      dom = dom.getParent();\n    }\n\n    final AntDomTarget domTarget = (AntDomTarget)dom;\n    if (domTarget == null) {\n      return null;\n    }\n    return Pair.create(antFile, domTarget);\n  }","id":104013,"modified_method":"@Nullable\n  private static Pair<AntBuildFileBase, AntDomTarget> findAntTarget(@NotNull AnActionEvent e) {\n    final Editor editor = e.getData(CommonDataKeys.EDITOR);\n    final Project project = e.getProject();\n\n    if (project == null || editor == null) {\n      return null;\n    }\n    final VirtualFile file = e.getData(CommonDataKeys.VIRTUAL_FILE);\n    if (file == null) {\n      return null;\n    }\n\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    if (!(psiFile instanceof XmlFile)) {\n      return null;\n    }\n    final XmlFile xmlFile = (XmlFile)psiFile;\n\n    final AntBuildFileBase antFile = AntConfigurationBase.getInstance(project).getAntBuildFile(xmlFile);\n    if (antFile == null) {\n      return null;\n    }\n\n    final PsiElement element = xmlFile.findElementAt(editor.getCaretModel().getOffset());\n    if (element == null) {\n      return null;\n    }\n    final XmlTag xmlTag = PsiTreeUtil.getParentOfType(element, XmlTag.class);\n    if (xmlTag == null) {\n      return null;\n    }\n\n    DomElement dom = AntSupport.getAntDomElement(xmlTag);\n    while (dom != null && !(dom instanceof AntDomTarget)) {\n      dom = dom.getParent();\n    }\n\n    final AntDomTarget domTarget = (AntDomTarget)dom;\n    if (domTarget == null) {\n      return null;\n    }\n    return Pair.create(antFile, domTarget);\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return;\n\n    for (final AntBuildFile buildFile : AntConfiguration.getInstance(project).getBuildFiles()) {\n      final String name = buildFile.getPresentableName();\n      if (name != null && myBuildName.equals(name)) {\n        String[] targets = myTargets.length == 1 && DEFAULT_TARGET_NAME.equals(myTargets[0]) ? ArrayUtil.EMPTY_STRING_ARRAY : myTargets;\n        ExecutionHandler.runBuild((AntBuildFileBase)buildFile, targets, null, dataContext, Collections.<BuildFileProperty>emptyList(), AntBuildListener.NULL);\n        return;\n      }\n    }\n  }","id":104014,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null) return;\n\n    for (final AntBuildFile buildFile : AntConfiguration.getInstance(project).getBuildFiles()) {\n      final String name = buildFile.getPresentableName();\n      if (name != null && myBuildName.equals(name)) {\n        String[] targets = myTargets.length == 1 && DEFAULT_TARGET_NAME.equals(myTargets[0]) ? ArrayUtil.EMPTY_STRING_ARRAY : myTargets;\n        ExecutionHandler.runBuild((AntBuildFileBase)buildFile, targets, null, e.getDataContext(), Collections.<BuildFileProperty>emptyList(), AntBuildListener.NULL);\n        return;\n      }\n    }\n  }","commit_id":"f250b7ab90e3ea902541b5d4f86b958c39ceeb22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Parse the command line arguments\n   */\n  void parseArguments(String[] args) {\n    if (args.length == 0) usage(true);\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      help = true;\n      return;\n    } else {\n      command = args[0];\n    }\n    // go through all the arguments\n    for (int pos = 1; pos < args.length; pos++) {\n      String arg = args[pos];\n      if (\"--host\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        hostname = args[pos];\n      }\n      else if (\"--port\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        try {\n          port = Integer.parseInt(args[pos]);\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      }\n      else if (\"--apikey\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        apikey = args[pos];\n      }\n      else if (\"--table\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        table = args[pos];\n      }\n      else if (\"--row\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        row = args[pos];\n      }\n      else if (\"--start\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        startcol = args[pos];\n      }\n      else if (\"--stop\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        stopcol = args[pos];\n      }\n      else if (\"--limit\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        try {\n          limit = Integer.parseInt(args[pos]);\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      }\n      else if (\"--column\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        columns.add(args[pos]);\n      }\n      else if (\"--columns\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        for (String column : args[pos].split(\",\"))\n          columns.add(column);\n      }\n      else if (\"--value\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        values.add(args[pos]);\n      }\n      else if (\"--values\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        for (String value : args[pos].split(\",\"))\n          values.add(value);\n      }\n      else if (\"--encoding\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        encoding = args[pos];\n      }\n      else if (\"--hex\".equals(arg)) {\n        encoding = \"hex\";\n      }\n      else if (\"--base64\".equals(arg)) {\n        encoding = \"base64\";\n      }\n      else if (\"--verbose\".equals(arg)) {\n        verbose = true;\n      }\n      else if (\"--pretty\".equals(arg)) {\n        pretty = true;\n      }\n      else if (\"--json\".equals(arg)) {\n        pretty = false;\n      }\n      else if (\"--help\".equals(arg)) {\n        help = true;\n        usage(false);\n        return;\n      } else {  // unkown argument\n        usage(true);\n      }\n    }\n  }","id":104015,"modified_method":"/**\n   * Parse the command line arguments\n   */\n  void parseArguments(String[] args) {\n    if (args.length == 0) usage(true);\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      help = true;\n      return;\n    } else {\n      command = args[0];\n    }\n    // go through all the arguments\n    for (int pos = 1; pos < args.length; pos++) {\n      String arg = args[pos];\n      if (\"--host\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        hostname = args[pos];\n      }\n      else if (\"--port\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        try {\n          port = Integer.parseInt(args[pos]);\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      }\n      else if (\"--apikey\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        apikey = args[pos];\n      }\n      else if (\"--table\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        table = args[pos];\n      }\n      else if (\"--row\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        row = args[pos];\n      }\n      else if (\"--start\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        startcol = args[pos];\n      }\n      else if (\"--stop\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        stopcol = args[pos];\n      }\n      else if (\"--limit\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        try {\n          limit = Integer.parseInt(args[pos]);\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      }\n      else if (\"--column\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        columns.add(args[pos]);\n      }\n      else if (\"--columns\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        for (String column : args[pos].split(\",\"))\n          columns.add(column);\n      }\n      else if (\"--value\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        values.add(args[pos]);\n      }\n      else if (\"--values\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        for (String value : args[pos].split(\",\"))\n          values.add(value);\n      }\n      else if (\"--hex\".equals(arg)) {\n        encoding = \"hex\";\n      }\n      else if (\"--url\".equals(arg)) {\n        encoding = \"url\";\n      }\n      else if (\"--base64\".equals(arg)) {\n        encoding = \"base64\";\n      }\n      else if (\"--verbose\".equals(arg)) {\n        verbose = true;\n      }\n      else if (\"--pretty\".equals(arg)) {\n        pretty = true;\n      }\n      else if (\"--json\".equals(arg)) {\n        pretty = false;\n      }\n      else if (\"--help\".equals(arg)) {\n        help = true;\n        usage(false);\n        return;\n      } else {  // unkown argument\n        usage(true);\n      }\n    }\n  }","commit_id":"37972f7d5f6ba11ee3817067a34382d0d9f8ff3d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Print the usage statement and return null (or empty string if this is not\n   * an error case). See getValue() for an explanation of the return type.\n   *\n   * @param error indicates whether this was invoked as the result of an error\n   * @throws com.continuuity.common.utils.UsageException in case of error\n   */\n  void usage(boolean error) {\n    PrintStream out = (error ? System.err : System.out);\n    String name = \"data-client\";\n    if (System.getProperty(\"script\")!=null) name = System.getProperty(\"script\").replaceAll(\"[./]\", \"\");\n    Copyright.print(out);\n    out.println(\"Usage: \");\n    out.println(\"  \" + name + \" create --table name\");\n    out.println(\"  \" + name + \" read --table name --row <row key> ...\");\n    out.println(\"  \" + name + \" write --table name --row <row key> ...\");\n    out.println(\"  \" + name + \" increment --table name --row <row key> ...\");\n    out.println(\"  \" + name + \" delete --table name --row <row key> ...\");\n    out.println();\n    out.println(\"Additional options:\");\n    out.println(\"  --table <name>          To specify the table to operate on\");\n    out.println(\"  --row <row key>         To specify the row to operate on\");\n    out.println(\"  --column <key>          To specify a single columns to operate on\");\n    out.println(\"  --columns <key,...>     To specify a list of columns to operate on\");\n    out.println(\"  --value <value>         To specify a single value to write/increment\");\n    out.println(\"  --values <value,...>    To specify a list of values to operate on\");\n    out.println(\"  --start <key>           To specify the start of a column range\");\n    out.println(\"  --stop <key>            To specify the end of a column range\");\n    out.println(\"  --limit <number>        To specify a limit for a column range\");\n    out.println(\"  --encoding <number>     To specify an encoding for keys/values\");\n    out.println(\"  --hex                   To specify hex encoding for keys/values\");\n    out.println(\"  --base64                To specify base64 encoding for keys/values\");\n    out.println(\"  --host <name>           To specify the hostname to send to\");\n    out.println(\"  --port <number>         To specify the port to use\");\n    out.println(\"  --apikey <apikey>       To specify an API key for authentication\");\n    out.println(\"  --json                  To see the raw JSON output\");\n    out.println(\"  --pretty                To see pretty printed output\");\n    out.println(\"  --verbose               To see more verbose output\");\n    out.println(\"  --help                  To print this message\");\n    if (error) {\n      throw new UsageException();\n    }\n  }","id":104016,"modified_method":"/**\n   * Print the usage statement and return null (or empty string if this is not\n   * an error case). See getValue() for an explanation of the return type.\n   *\n   * @param error indicates whether this was invoked as the result of an error\n   * @throws com.continuuity.common.utils.UsageException in case of error\n   */\n  void usage(boolean error) {\n    PrintStream out = (error ? System.err : System.out);\n    String name = \"data-client\";\n    if (System.getProperty(\"script\")!=null) name = System.getProperty(\"script\").replaceAll(\"[./]\", \"\");\n    Copyright.print(out);\n    out.println(\"Usage: \");\n    out.println(\"  \" + name + \" create --table name\");\n    out.println(\"  \" + name + \" read --table name --row <row key> ...\");\n    out.println(\"  \" + name + \" write --table name --row <row key> ...\");\n    out.println(\"  \" + name + \" increment --table name --row <row key> ...\");\n    out.println(\"  \" + name + \" delete --table name --row <row key> ...\");\n    out.println();\n    out.println(\"Additional options:\");\n    out.println(\"  --table <name>          To specify the table to operate on\");\n    out.println(\"  --row <row key>         To specify the row to operate on\");\n    out.println(\"  --column <key>          To specify a single columns to operate on\");\n    out.println(\"  --columns <key,...>     To specify a list of columns to operate on\");\n    out.println(\"  --value <value>         To specify a single value to write/increment\");\n    out.println(\"  --values <value,...>    To specify a list of values to operate on\");\n    out.println(\"  --start <key>           To specify the start of a column range\");\n    out.println(\"  --stop <key>            To specify the end of a column range\");\n    out.println(\"  --limit <number>        To specify a limit for a column range\");\n    out.println(\"  --hex                   To specify hex encoding for keys/values\");\n    out.println(\"  --url                   To specify hex encoding for keys/values\");\n    out.println(\"  --base64                To specify base64 encoding for keys/values\");\n    out.println(\"  --host <name>           To specify the hostname to send to\");\n    out.println(\"  --port <number>         To specify the port to use\");\n    out.println(\"  --apikey <apikey>       To specify an API key for authentication\");\n    out.println(\"  --json                  To see the raw JSON output\");\n    out.println(\"  --pretty                To see pretty printed output\");\n    out.println(\"  --verbose               To see more verbose output\");\n    out.println(\"  --help                  To print this message\");\n    if (error) {\n      throw new UsageException();\n    }\n  }","commit_id":"37972f7d5f6ba11ee3817067a34382d0d9f8ff3d","url":"https://github.com/caskdata/cdap"},{"original_method":"private void handleTableOperation(MessageEvent message, HttpRequest request,\n                                    MetricsHelper helper, LinkedList<String> pathComponents,\n                                    Map<String, List<String>> parameters, OperationContext opContext) {\n    // all operations must have table name\n    if (pathComponents.isEmpty()) {\n      respondBadRequest(message, request, helper, \"table name missing\");\n      return;\n    }\n    String tableName = pathComponents.removeFirst();\n\n    // if there is another path component, it must be a row key\n    String row = pathComponents.isEmpty() ? null : pathComponents.removeFirst();\n\n    // no more components allowed on path\n    if (!pathComponents.isEmpty()) {\n      respondBadRequest(message, request, helper, \"extra components in path\");\n      return;\n    }\n\n    // is there an operation parameter? Can have only one value, and only list and increment are allowed\n    TableOp operation = null;\n    List<String> operations = parameters.get(\"op\");\n    if (operations != null) {\n      if (operations.size() > 1) {\n        respondBadRequest(message, request, helper, \"more than one 'op' parameter\");\n        return;\n      } else if (operations.size() == 1) {\n        String op = operations.get(0);\n        if (\"list\".equals(op)) {\n         operation = TableOp.List;\n        } else if (\"increment\".equals(op)) {\n          operation = TableOp.Increment;\n        } else {\n          respondBadRequest(message, request, helper, \"unsupported 'op' parameter\");\n          return;\n        }\n      }\n    }\n\n    // for read and delete operations, optional parameter is columns\n    List<String> columns = null;\n    List<String> columnParams = parameters.get(\"columns\");\n    if (columnParams != null && columnParams.size() > 0) {\n      columns = Lists.newLinkedList();\n      for (String param : columnParams) {\n        for (String column : param.split(\",\")) {\n          columns.add(column);\n        }\n      }\n    }\n\n    // optional parameters start\n    List<String> startParams = parameters.get(\"start\");\n    if (startParams != null && startParams.size() > 1) {\n      respondBadRequest(message, request, helper, \"more than one 'start' parameter\");\n      return;\n    }\n    String start = (startParams == null || startParams.isEmpty()) ? null : startParams.get(0);\n\n    // optional parameters stop\n    List<String> stopParams = parameters.get(\"stop\");\n    if (stopParams != null && stopParams.size() > 1) {\n      respondBadRequest(message, request, helper, \"more than one 'stop' parameter\");\n      return;\n    }\n    String stop = (stopParams == null || stopParams.isEmpty()) ? null : stopParams.get(0);\n\n    // optional parameters limit\n    List<String> limitParams = parameters.get(\"limit\");\n    if (limitParams != null && limitParams.size() > 1) {\n      respondBadRequest(message, request, helper, \"more than one 'limit' parameter\");\n      return;\n    }\n    Integer limit;\n    try {\n      limit = (limitParams == null || limitParams.isEmpty()) ? null : Integer.parseInt(limitParams.get(0));\n    } catch (NumberFormatException e) {\n      respondBadRequest(message, request, helper, \"'limit' parameter is not an integer\");\n      return;\n    }\n\n    // optional parameter encoding\n    String encoding = getEncodingParameter(message, request, helper, parameters);\n    if (encoding == null) { // error\n      return;\n    }\n\n    // make sure the operations and parameters are valid\n    HttpMethod method = request.getMethod();\n    if (HttpMethod.GET.equals(method)) {\n      // can be either a list or a read, list would have had ?op=list\n      if (operation == TableOp.List) {\n        if (row != null) {\n          respondBadRequest(message, request, helper, \"list operation cannot have row key\");\n          return;\n        } else {\n          respondBadRequest(message, request, helper,\n                            \"list operation not implemented\", HttpResponseStatus.NOT_IMPLEMENTED);\n          return;\n        }\n      }\n      // make sure no other operation was given with ?op=\n      if (operation != null) {\n        respondBadRequest(message, request, helper, \"invalid operation for method GET\");\n        return;\n      }\n      // must be a read, requires a row\n      if (row == null) {\n        respondBadRequest(message, request, helper, \"read must have a row key\");\n        return;\n      }\n      if (columns != null && !columns.isEmpty() && (start != null || stop != null)) {\n        respondBadRequest(message, request, helper, \"read can only specify columns or range\");\n        return;\n      }\n      operation = TableOp.Read;\n\n    } else if (HttpMethod.DELETE.equals(method)) {\n      // make sure no operation was given with ?op=\n      if (operation != null) {\n        respondBadRequest(message, request, helper, \"invalid operation for method GET\");\n        return;\n      }\n      // must be a delete, requires a row\n      if (row == null) {\n        respondBadRequest(message, request, helper, \"delete must have a row key\");\n        return;\n      }\n      if (columns == null || columns.isEmpty()) {\n        respondBadRequest(message, request, helper, \"delete must have columns\");\n        return;\n      }\n      operation = TableOp.Delete;\n\n    } else if (HttpMethod.PUT.equals(method)) {\n      // make sure no operation was given with ?op=\n      if (operation != null) {\n        respondBadRequest(message, request, helper, \"invalid operation for method PUT\");\n        return;\n      }\n      // must be a write, requires a row\n      if (row == null) {\n        operation = TableOp.Create;\n      } else {\n        operation = TableOp.Write;\n      }\n\n    } else if (HttpMethod.POST.equals(method)) {\n      // make sure no operation was given with ?op=\n      if (operation == null) {\n        respondBadRequest(message, request, helper, \"missing operation for method POST\");\n        return;\n      }\n      if (operation != TableOp.Increment) {\n        respondBadRequest(message, request, helper, \"invalid operation for method POST\");\n        return;\n      }\n      // must be increment, requires a row\n      if (row == null) {\n        respondBadRequest(message, request, helper, \"increment must have a row key\");\n        return;\n      }\n      operation = TableOp.Increment;\n    }\n\n    Type stringMapType = new TypeToken<Map<String, String>>() {}.getType();\n    // Type longMapType = new TypeToken<Map<String, Long>>() {}.getType();\n\n    // for operations write and increment, there must be a JSON string in the body\n    Map<String, String> valueMap = null;\n    // Map<String, Long> longMap = null;\n    try {\n      if (operation == TableOp.Increment || operation == TableOp.Write) {\n        InputStreamReader reader = new InputStreamReader(\n          new ChannelBufferInputStream(request.getContent()), Charsets.UTF_8);\n        if (operation == TableOp.Write) {\n          valueMap = new Gson().fromJson(reader, stringMapType);\n        } else {\n          // does not seem to work, Gson returns Map<String,String>\n          // longMap = new Gson().fromJson(reader, longMapType);\n          valueMap = new Gson().fromJson(reader, stringMapType);\n        }\n      }\n    } catch (Exception e) {\n      // failed to parse json, that is a bad request\n      respondBadRequest(message, request, helper, \"failed to read body as json: \" + e.getMessage());\n      return;\n    }\n\n    if (operation.equals(TableOp.Create)) {\n      DataSetSpecification spec = new Table(tableName).configure();\n      Dataset ds = new Dataset(spec.getName());\n      ds.setName(spec.getName());\n      ds.setType(spec.getType());\n      ds.setSpecification(new Gson().toJson(spec));\n      try {\n        this.accessor.getMetadataService().assertDataset(new Account(opContext.getAccount()), ds);\n      } catch (MetadataServiceException e) {\n        respondBadRequest(message, request, helper, \"table already exists\", HttpResponseStatus.CONFLICT);\n        return;\n      } catch (TException e) {\n        helper.finish(Error);\n        LOG.error(\"Thrift error creating table: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      respondSuccess(message.getChannel(), request);\n      helper.finish(Success);\n      return;\n    }\n\n    // make sure the table exists and instantiate dataset\n    Table table;\n    try {\n      table = this.accessor.getInstantiator().getDataSet(tableName, opContext);\n    } catch (Exception e) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Cannot instantiate requested table '\" + tableName + \"' (\" +\n                    e.getMessage() + \") for URI '\" + request.getUri() + \"'\");\n      }\n      helper.finish(BadRequest);\n      respondError(message.getChannel(), HttpResponseStatus.NOT_FOUND);\n      return;\n    }\n\n    // try to convert the row ket to bytes, using the given encoding\n    byte[] rowKey;\n    try {\n      rowKey = row == null ? null : Util.decodeBytes(row, encoding);\n    } catch (Exception e) {\n      respondBadRequest(message, request, helper, \"error decoding row key\", e);\n      return;\n    }\n\n    if (operation.equals(TableOp.List)) {\n      // TODO not implemented\n    } else if (operation.equals(TableOp.Read)) {\n      Read read;\n      try {\n        if (columns == null || columns.isEmpty()) {\n          // column range\n          byte[] startCol = Util.decodeBytes(start, encoding);\n          byte[] stopCol = Util.decodeBytes(stop, encoding);\n          read = new Read(rowKey, startCol, stopCol, limit == null ? -1 : limit);\n        } else {\n          byte[][] cols = new byte[columns.size()][];\n          int i = 0;\n          for (String column : columns) {\n            cols[i++] = Util.decodeBytes(column, encoding);\n          }\n          read = new Read(rowKey, cols);\n        }\n      } catch (UnsupportedEncodingException e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s)\", e);\n        return;\n      }\n      OperationResult<Map<byte[], byte[]>> result;\n      try {\n        result = table.read(read);\n      } catch (OperationException e) {\n        helper.finish(Error);\n        LOG.error(\"Error during Read: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      // read successful, now respond with result\n      if (result.isEmpty() || result.getValue().isEmpty()) {\n        helper.finish(NoData);\n        respondError(message.getChannel(), HttpResponseStatus.NOT_FOUND);\n      } else {\n        // result is not empty, now construct a json response\n        // first convert the bytes to strings\n        Map<String, String> map = Maps.newTreeMap();\n        try {\n          for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            map.put(Util.encodeBytes(entry.getKey(), encoding), Util.encodeBytes(entry.getValue(), encoding));\n          }\n        } catch (UnsupportedEncodingException e) {\n          respondBadRequest(message, request, helper, \"error encoding read result\", e);\n          return;\n        }\n        // now write a json string representing the map\n        byte[] response = new Gson().toJson(map).getBytes(Charsets.UTF_8);\n        System.err.println(new String(response, Charsets.UTF_8));\n        respondSuccess(message.getChannel(), request, response);\n        helper.finish(Success);\n      }\n    }\n    else if (operation.equals(TableOp.Delete)) {\n      Delete delete;\n      try {\n        byte[][] cols = new byte[columns.size()][];\n        int i = 0;\n        for (String column : columns) {\n          cols[i++] = Util.decodeBytes(column, encoding);\n        }\n        delete = new Delete(rowKey, cols);\n      } catch (UnsupportedEncodingException e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s)\", e);\n        return;\n      }\n      // now execute the delete operation\n      try {\n        table.write(delete);\n      } catch (OperationException e) {\n        helper.finish(Error);\n        LOG.error(\"Error during Delete: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      helper.finish(Success);\n      respondSuccess(message.getChannel(), request);\n    }\n\n    else if (operation.equals(TableOp.Write)) {\n      Write write;\n      // decode the columns and values into byte arrays\n      if (valueMap == null || valueMap.isEmpty()) {\n        // this happens when we have no content\n        respondBadRequest(message, request, helper, \"request body has no columns to write\");\n        return;\n      }\n      try {\n        byte[][] cols = new byte[valueMap.size()][];\n        byte[][] vals = new byte[valueMap.size()][];\n        int i = 0;\n        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\n          cols[i] = Util.decodeBytes(entry.getKey(), encoding);\n          vals[i] = Util.decodeBytes(entry.getValue(), encoding);\n          i++;\n        }\n        write = new Write(rowKey, cols, vals);\n      } catch (UnsupportedEncodingException e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s) and values\", e);\n        return;\n      }\n      // now execute the write\n      try {\n        table.write(write);\n      } catch (OperationException e) {\n        helper.finish(Error);\n        LOG.error(\"Error during Writte: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      helper.finish(Success);\n      respondSuccess(message.getChannel(), request);\n    }\n\n    else if (operation.equals(TableOp.Increment)) {\n      Increment increment;\n      if (valueMap == null || valueMap.isEmpty()) {\n        // this happens when we have no content\n        respondBadRequest(message, request, helper, \"request body has no columns to increment\");\n        return;\n      }\n      // decode the columns and values into byte arrays\n      try {\n        byte[][] cols = new byte[valueMap.size()][];\n        long[] vals = new long[valueMap.size()];\n        int i = 0;\n        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\n          cols[i] = Util.decodeBytes(entry.getKey(), encoding);\n          vals[i] = Long.parseLong(entry.getValue());\n          i++;\n        }\n        increment = new Increment(rowKey, cols, vals);\n      } catch (NumberFormatException e) {\n        respondBadRequest(message, request, helper, \"error converting values to long\", e);\n        return;\n      } catch (UnsupportedEncodingException e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s) and values\", e);\n        return;\n      }\n      // now execute the write\n      Map<byte[], Long> results;\n      try {\n        results = table.incrementAndGet(increment);\n      } catch (OperationException e) {\n        // if this was an illegal increment, then it was a bad request\n        if (StatusCode.ILLEGAL_INCREMENT == e.getStatus()) {\n          respondBadRequest(message, request, helper, \"attempt to increment a value that is not a long\");\n        } else {\n          // otherwise it is an internal error\n          helper.finish(Error);\n          LOG.error(\"Error during Write: \" + e.getMessage(), e);\n          respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        }\n        return;\n      }\n      // first convert the bytes to strings\n      Map<String, Long> map = Maps.newTreeMap();\n      try {\n        for (Map.Entry<byte[], Long> entry : results.entrySet()) {\n          map.put(Util.encodeBytes(entry.getKey(), encoding), entry.getValue());\n        }\n      } catch (UnsupportedEncodingException e) {\n        respondBadRequest(message, request, helper, \"error encoding read result\", e);\n        return;\n      }\n      // now write a json string representing the map\n      byte[] response = new Gson().toJson(map).getBytes(Charsets.UTF_8);\n      respondSuccess(message.getChannel(), request, response);\n      helper.finish(Success);\n    }\n  }","id":104017,"modified_method":"private void handleTableOperation(MessageEvent message, HttpRequest request,\n                                    MetricsHelper helper, LinkedList<String> pathComponents,\n                                    Map<String, List<String>> parameters, OperationContext opContext) {\n    // all operations must have table name\n    if (pathComponents.isEmpty()) {\n      respondBadRequest(message, request, helper, \"table name missing\");\n      return;\n    }\n    String tableName = pathComponents.removeFirst();\n\n    // if there is another path component, it must be a row key\n    String row = pathComponents.isEmpty() ? null : pathComponents.removeFirst();\n\n    // no more components allowed on path\n    if (!pathComponents.isEmpty()) {\n      respondBadRequest(message, request, helper, \"extra components in path\");\n      return;\n    }\n\n    // is there an operation parameter? Can have only one value, and only list and increment are allowed\n    TableOp operation = null;\n    List<String> operations = parameters.get(\"op\");\n    if (operations != null) {\n      if (operations.size() > 1) {\n        respondBadRequest(message, request, helper, \"more than one 'op' parameter\");\n        return;\n      } else if (operations.size() == 1) {\n        String op = operations.get(0);\n        if (\"list\".equals(op)) {\n         operation = TableOp.List;\n        } else if (\"increment\".equals(op)) {\n          operation = TableOp.Increment;\n        } else {\n          respondBadRequest(message, request, helper, \"unsupported 'op' parameter\");\n          return;\n        }\n      }\n    }\n\n    // for read and delete operations, optional parameter is columns\n    List<String> columns = null;\n    List<String> columnParams = parameters.get(\"columns\");\n    if (columnParams != null && columnParams.size() > 0) {\n      columns = Lists.newLinkedList();\n      for (String param : columnParams) {\n        for (String column : param.split(\",\")) {\n          columns.add(column);\n        }\n      }\n    }\n\n    // optional parameters start\n    List<String> startParams = parameters.get(\"start\");\n    if (startParams != null && startParams.size() > 1) {\n      respondBadRequest(message, request, helper, \"more than one 'start' parameter\");\n      return;\n    }\n    String start = (startParams == null || startParams.isEmpty()) ? null : startParams.get(0);\n\n    // optional parameters stop\n    List<String> stopParams = parameters.get(\"stop\");\n    if (stopParams != null && stopParams.size() > 1) {\n      respondBadRequest(message, request, helper, \"more than one 'stop' parameter\");\n      return;\n    }\n    String stop = (stopParams == null || stopParams.isEmpty()) ? null : stopParams.get(0);\n\n    // optional parameters limit\n    List<String> limitParams = parameters.get(\"limit\");\n    if (limitParams != null && limitParams.size() > 1) {\n      respondBadRequest(message, request, helper, \"more than one 'limit' parameter\");\n      return;\n    }\n    Integer limit;\n    try {\n      limit = (limitParams == null || limitParams.isEmpty()) ? null : Integer.parseInt(limitParams.get(0));\n    } catch (NumberFormatException e) {\n      respondBadRequest(message, request, helper, \"'limit' parameter is not an integer\");\n      return;\n    }\n\n    // optional parameter encoding\n    String encoding = null;\n    List<String> encodingParams = parameters.get(\"encoding\");\n    if (encodingParams != null) {\n      // make sure there is at most one\n      if (encodingParams.size() > 1) {\n        respondBadRequest(message, request, helper, \"more than one 'encoding' parameter\");\n        return;\n      }\n      // make sure that if there is one, it is supported\n      if (!encodingParams.isEmpty()) {\n        encoding = encodingParams.get(0);\n        if (!Util.supportedEncoding(encoding)) {\n          respondBadRequest(message, request, helper, \"unsupported 'encoding' parameter\");\n          return;\n        }\n      }\n    }\n\n    // make sure the operations and parameters are valid\n    HttpMethod method = request.getMethod();\n    if (HttpMethod.GET.equals(method)) {\n      // can be either a list or a read, list would have had ?op=list\n      if (operation == TableOp.List) {\n        if (row != null) {\n          respondBadRequest(message, request, helper, \"list operation cannot have row key\");\n          return;\n        } else {\n          respondBadRequest(message, request, helper,\n                            \"list operation not implemented\", HttpResponseStatus.NOT_IMPLEMENTED);\n          return;\n        }\n      }\n      // make sure no other operation was given with ?op=\n      if (operation != null) {\n        respondBadRequest(message, request, helper, \"invalid operation for method GET\");\n        return;\n      }\n      // must be a read, requires a row\n      if (row == null) {\n        respondBadRequest(message, request, helper, \"read must have a row key\");\n        return;\n      }\n      if (columns != null && !columns.isEmpty() && (start != null || stop != null)) {\n        respondBadRequest(message, request, helper, \"read can only specify columns or range\");\n        return;\n      }\n      operation = TableOp.Read;\n\n    } else if (HttpMethod.DELETE.equals(method)) {\n      // make sure no operation was given with ?op=\n      if (operation != null) {\n        respondBadRequest(message, request, helper, \"invalid operation for method GET\");\n        return;\n      }\n      // must be a delete, requires a row\n      if (row == null) {\n        respondBadRequest(message, request, helper, \"delete must have a row key\");\n        return;\n      }\n      if (columns == null || columns.isEmpty()) {\n        respondBadRequest(message, request, helper, \"delete must have columns\");\n        return;\n      }\n      operation = TableOp.Delete;\n\n    } else if (HttpMethod.PUT.equals(method)) {\n      // make sure no operation was given with ?op=\n      if (operation != null) {\n        respondBadRequest(message, request, helper, \"invalid operation for method PUT\");\n        return;\n      }\n      // must be a write, requires a row\n      if (row == null) {\n        operation = TableOp.Create;\n      } else {\n        operation = TableOp.Write;\n      }\n\n    } else if (HttpMethod.POST.equals(method)) {\n      // make sure no operation was given with ?op=\n      if (operation == null) {\n        respondBadRequest(message, request, helper, \"missing operation for method POST\");\n        return;\n      }\n      if (operation != TableOp.Increment) {\n        respondBadRequest(message, request, helper, \"invalid operation for method POST\");\n        return;\n      }\n      // must be increment, requires a row\n      if (row == null) {\n        respondBadRequest(message, request, helper, \"increment must have a row key\");\n        return;\n      }\n      operation = TableOp.Increment;\n    }\n\n    Type stringMapType = new TypeToken<Map<String, String>>() {}.getType();\n    // Type longMapType = new TypeToken<Map<String, Long>>() {}.getType();\n\n    // for operations write and increment, there must be a JSON string in the body\n    Map<String, String> valueMap = null;\n    // Map<String, Long> longMap = null;\n    try {\n      if (operation == TableOp.Increment || operation == TableOp.Write) {\n        InputStreamReader reader = new InputStreamReader(\n          new ChannelBufferInputStream(request.getContent()), Charsets.UTF_8);\n        if (operation == TableOp.Write) {\n          valueMap = new Gson().fromJson(reader, stringMapType);\n        } else {\n          // does not seem to work, Gson returns Map<String,String>\n          // longMap = new Gson().fromJson(reader, longMapType);\n          valueMap = new Gson().fromJson(reader, stringMapType);\n        }\n      }\n    } catch (Exception e) {\n      // failed to parse json, that is a bad request\n      respondBadRequest(message, request, helper, \"failed to read body as json: \" + e.getMessage());\n      return;\n    }\n\n    if (operation.equals(TableOp.Create)) {\n      DataSetSpecification spec = new Table(tableName).configure();\n      Dataset ds = new Dataset(spec.getName());\n      ds.setName(spec.getName());\n      ds.setType(spec.getType());\n      ds.setSpecification(new Gson().toJson(spec));\n      try {\n        this.accessor.getMetadataService().assertDataset(new Account(opContext.getAccount()), ds);\n      } catch (MetadataServiceException e) {\n        respondBadRequest(message, request, helper, \"table already exists\", HttpResponseStatus.CONFLICT);\n        return;\n      } catch (TException e) {\n        helper.finish(Error);\n        LOG.error(\"Thrift error creating table: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      respondSuccess(message.getChannel(), request);\n      helper.finish(Success);\n      return;\n    }\n\n    // make sure the table exists and instantiate dataset\n    Table table;\n    try {\n      table = this.accessor.getInstantiator().getDataSet(tableName, opContext);\n    } catch (Exception e) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Cannot instantiate requested table '\" + tableName + \"' (\" +\n                    e.getMessage() + \") for URI '\" + request.getUri() + \"'\");\n      }\n      helper.finish(BadRequest);\n      respondError(message.getChannel(), HttpResponseStatus.NOT_FOUND);\n      return;\n    }\n\n    // try to convert the row ket to bytes, using the given encoding\n    byte[] rowKey;\n    try {\n      rowKey = row == null ? null : Util.decodeBinary(row, encoding);\n    } catch (Exception e) {\n      respondBadRequest(message, request, helper, \"error decoding row key\", e);\n      return;\n    }\n\n    if (operation.equals(TableOp.List)) {\n      // TODO not implemented\n    } else if (operation.equals(TableOp.Read)) {\n      Read read;\n      try {\n        if (columns == null || columns.isEmpty()) {\n          // column range\n          byte[] startCol = start == null ? null : Util.decodeBinary(start, encoding);\n          byte[] stopCol = stop == null ? null : Util.decodeBinary(stop, encoding);\n          read = new Read(rowKey, startCol, stopCol, limit == null ? -1 : limit);\n        } else {\n          byte[][] cols = new byte[columns.size()][];\n          int i = 0;\n          for (String column : columns) {\n            cols[i++] = Util.decodeBinary(column, encoding);\n          }\n          read = new Read(rowKey, cols);\n        }\n      } catch (Exception e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s)\", e);\n        return;\n      }\n      OperationResult<Map<byte[], byte[]>> result;\n      try {\n        result = table.read(read);\n      } catch (OperationException e) {\n        helper.finish(Error);\n        LOG.error(\"Error during Read: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      // read successful, now respond with result\n      if (result.isEmpty() || result.getValue().isEmpty()) {\n        helper.finish(NoData);\n        respondError(message.getChannel(), HttpResponseStatus.NOT_FOUND);\n      } else {\n        // result is not empty, now construct a json response\n        // first convert the bytes to strings\n        Map<String, String> map = Maps.newTreeMap();\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n          map.put(Util.encodeBinary(entry.getKey(), encoding), Util.encodeBinary(entry.getValue(), encoding));\n        }\n        // now write a json string representing the map\n        byte[] response = new Gson().toJson(map).getBytes(Charsets.UTF_8);\n        respondSuccess(message.getChannel(), request, response);\n        helper.finish(Success);\n      }\n    }\n    else if (operation.equals(TableOp.Delete)) {\n      Delete delete;\n      try {\n        byte[][] cols = new byte[columns.size()][];\n        int i = 0;\n        for (String column : columns) {\n          cols[i++] = Util.decodeBinary(column, encoding);\n        }\n        delete = new Delete(rowKey, cols);\n      } catch (Exception e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s)\", e);\n        return;\n      }\n      // now execute the delete operation\n      try {\n        table.write(delete);\n      } catch (OperationException e) {\n        helper.finish(Error);\n        LOG.error(\"Error during Delete: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      helper.finish(Success);\n      respondSuccess(message.getChannel(), request);\n    }\n\n    else if (operation.equals(TableOp.Write)) {\n      Write write;\n      // decode the columns and values into byte arrays\n      if (valueMap == null || valueMap.isEmpty()) {\n        // this happens when we have no content\n        respondBadRequest(message, request, helper, \"request body has no columns to write\");\n        return;\n      }\n      try {\n        byte[][] cols = new byte[valueMap.size()][];\n        byte[][] vals = new byte[valueMap.size()][];\n        int i = 0;\n        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\n          cols[i] = Util.decodeBinary(entry.getKey(), encoding);\n          vals[i] = Util.decodeBinary(entry.getValue(), encoding);\n          i++;\n        }\n        write = new Write(rowKey, cols, vals);\n      } catch (Exception e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s) and values\", e);\n        return;\n      }\n      // now execute the write\n      try {\n        table.write(write);\n      } catch (OperationException e) {\n        helper.finish(Error);\n        LOG.error(\"Error during Writte: \" + e.getMessage(), e);\n        respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        return;\n      }\n      helper.finish(Success);\n      respondSuccess(message.getChannel(), request);\n    }\n\n    else if (operation.equals(TableOp.Increment)) {\n      Increment increment;\n      if (valueMap == null || valueMap.isEmpty()) {\n        // this happens when we have no content\n        respondBadRequest(message, request, helper, \"request body has no columns to increment\");\n        return;\n      }\n      // decode the columns and values into byte arrays\n      try {\n        byte[][] cols = new byte[valueMap.size()][];\n        long[] vals = new long[valueMap.size()];\n        int i = 0;\n        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\n          cols[i] = Util.decodeBinary(entry.getKey(), encoding);\n          vals[i] = Long.parseLong(entry.getValue());\n          i++;\n        }\n        increment = new Increment(rowKey, cols, vals);\n      } catch (Exception e) {\n        respondBadRequest(message, request, helper, \"error decoding column key(s) and values\", e);\n        return;\n      }\n      // now execute the write\n      Map<byte[], Long> results;\n      try {\n        results = table.incrementAndGet(increment);\n      } catch (OperationException e) {\n        // if this was an illegal increment, then it was a bad request\n        if (StatusCode.ILLEGAL_INCREMENT == e.getStatus()) {\n          respondBadRequest(message, request, helper, \"attempt to increment a value that is not a long\");\n        } else {\n          // otherwise it is an internal error\n          helper.finish(Error);\n          LOG.error(\"Error during Write: \" + e.getMessage(), e);\n          respondError(message.getChannel(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        }\n        return;\n      }\n      // first convert the bytes to strings\n      Map<String, Long> map = Maps.newTreeMap();\n      for (Map.Entry<byte[], Long> entry : results.entrySet()) {\n        map.put(Util.encodeBinary(entry.getKey(), encoding), entry.getValue());\n      }\n      // now write a json string representing the map\n      byte[] response = new Gson().toJson(map).getBytes(Charsets.UTF_8);\n      respondSuccess(message.getChannel(), request, response);\n      helper.finish(Success);\n    }\n  }","commit_id":"37972f7d5f6ba11ee3817067a34382d0d9f8ff3d","url":"https://github.com/caskdata/cdap"},{"original_method":"public static byte[] decodeBytes(String string, String encoding) throws UnsupportedEncodingException {\n    if (string == null) {\n      return null;\n    }\n    if (encoding == null || encoding.isEmpty()) {\n      return string.getBytes(Charsets.UTF_8);\n    }\n    if (\"url\".equals(encoding)) {\n      return urlDecode(string);\n    }\n    if (\"hex\".equals(encoding)) {\n      return hexValue(string);\n    }\n    if (\"base64\".equals(encoding)) {\n      return fromBase64(string);\n    }\n    return string.getBytes(encoding);\n  }","id":104018,"modified_method":"public static byte[] decodeBinary(String str, String encoding) throws NumberFormatException {\n\n    if (encoding == null) {\n      return str.getBytes(Charsets.US_ASCII);\n    }\n    if (\"hex\".equals(encoding)) {\n      return hexValue(str);\n    }\n    if (\"base64\".equals(encoding)) {\n      return Base64.decodeBase64(str);\n    }\n    if (\"url\".equals(encoding)) {\n      try {\n        // URLDecoder does not produce byte[], so we decode to a String using ISO-8859. Note that the URL\n        // decoder produces chars between 0-255, and thus each %-escaped byet in the URL results in\n        // exactly one char in the string. That can be safely converted 1:1 into byte[] using getBuytes().\n        return URLDecoder.decode(str, Charsets.ISO_8859_1.name()).getBytes(Charsets.ISO_8859_1);\n      } catch (UnsupportedEncodingException e) {\n        // can't happen\n        throw new RuntimeException(\"Charsets.ISO_8859_1 is unsupported? Something is wrong with the JVM\", e);\n      }\n    }\n    // this can never happen because we only call it with null, hex, base64, or url\n    throw new RuntimeException(\"Unexpected encoding: \" + encoding + \" Only hex, base64 and url are supported.\");\n  }","commit_id":"37972f7d5f6ba11ee3817067a34382d0d9f8ff3d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Convert a big-endian byte-array into a long. This is intended to be used\n   * with 8-byte arrays, but it does not check the length of the array. For\n   * arrays of less than 8 bytes, this will produce the same value as if the\n   * array was left-padded with zeros. For arrays longer than 8 bytes, only\n   * the last 8 bytes are used.\n   * @param bytes the byte array to convert\n   * @return the long value of the byte array\n   */\n  public static long bytesToLong(byte[] bytes) {\n    long value = 0;\n    for (int i = 0; i < bytes.length; i++) {\n      value = (value << 8) | (((long)bytes[i]) & 0xff);\n    }\n    return value;\n  }","id":104019,"modified_method":"/**\n   * Convert a big-endian byte-array into a long. This is intended to be used\n   * with 8-byte arrays, but it does not check the length of the array. For\n   * arrays of less than 8 bytes, this will produce the same value as if the\n   * array was left-padded with zeros. For arrays longer than 8 bytes, only\n   * the last 8 bytes are used.\n   * @param bytes the byte array to convert\n   * @return the long value of the byte array\n   */\n  public static long bytesToLong(byte[] bytes) {\n    long value = 0;\n    for (byte aByte : bytes) {\n      value = (value << 8) | (((long) aByte) & 0xff);\n    }\n    return value;\n  }","commit_id":"37972f7d5f6ba11ee3817067a34382d0d9f8ff3d","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String encodeBytes(byte[] bytes, String encoding) throws UnsupportedEncodingException {\n    if (bytes == null) {\n      return null;\n    }\n    if (encoding == null || encoding.isEmpty()) {\n      return new String(bytes, Charsets.UTF_8);\n    }\n    if (\"url\".equals(encoding)) {\n      return urlEncode(bytes);\n    }\n    if (\"hex\".equals(encoding)) {\n      return toHex(bytes);\n    }\n    if (\"base64\".equals(encoding)) {\n      return toBase64(bytes);\n    }\n    return new String(bytes, encoding);\n  }","id":104020,"modified_method":"public static String encodeBinary(byte[] binary, String encoding) {\n    if (encoding == null) {\n      return new String(binary, Charsets.US_ASCII);\n    }\n    if (\"hex\".equals(encoding)) {\n      return toHex(binary);\n    }\n    if (\"base64\".equals(encoding)) {\n      return Base64.encodeBase64URLSafeString(binary);\n    }\n    if (\"url\".equals(encoding)) {\n      try {\n        // URLEncoder does not take byte[], so we convert it into a String with the same code points using\n        // ISO-8859-1. This string only contains code points 0-255. Then we URL-encode that string using\n        // ISO-8859-1 again. This way, every byte ends up as the exact same, %-escaped byte, in the URL string\n        return URLEncoder.encode(new String(binary, Charsets.ISO_8859_1), Charsets.UTF_8.name());\n      } catch (UnsupportedEncodingException e) {\n        // can't happen\n        throw new RuntimeException(\"Charsets.ISO_8859_1 is unsupported? Something is wrong with the JVM\", e);\n      }\n    }\n    // this can never happen because we only call it with null, hex, base64, or url\n    throw new RuntimeException(\"Unexpected encoding: \" + encoding + \" Only hex, base64 and url are supported.\");\n  }","commit_id":"37972f7d5f6ba11ee3817067a34382d0d9f8ff3d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Extracts the body from the XMPP message\n     */\n    public Object extractBodyFromXmpp(XmppExchange exchange, Message message) {\n        return message.getBody();\n    }","id":104021,"modified_method":"/**\n     * Extracts the body from the XMPP message\n     */\n    public Object extractBodyFromXmpp(Exchange exchange, Message message) {\n        return message.getBody();\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"public void processMessage(Chat chat, Message message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recieved XMPP message: \" + message.getBody());\n        }\n\n        XmppExchange exchange = endpoint.createExchange(message);\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n    }","id":104022,"modified_method":"public void processMessage(Chat chat, Message message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recieved XMPP message: \" + message.getBody());\n        }\n\n        Exchange exchange = endpoint.createExchange(message);\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Exchange createExchange(ExchangePattern pattern) {\n        return new XmppExchange(this, pattern, getBinding());\n    }","id":104023,"modified_method":"@Override\n    public Exchange createExchange(ExchangePattern pattern) {\n        return createExchange(pattern, null);\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"public XmppExchange createExchange(Message message) {\n        return new XmppExchange(this, getExchangePattern(), getBinding(), message);\n    }","id":104024,"modified_method":"public Exchange createExchange(Message message) {\n        return createExchange(getExchangePattern(), message);\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Object createBody() {\n        if (xmppMessage != null) {\n            return getExchange().getBinding().extractBodyFromXmpp(getExchange(), xmppMessage);\n        }\n        return null;\n    }","id":104025,"modified_method":"@Override\n    protected Object createBody() {\n        if (xmppMessage != null) {\n            XmppBinding binding = (XmppBinding) getExchange().getProperty(Exchange.BINDING);\n            if (binding != null) {\n                binding.extractBodyFromXmpp(getExchange(), xmppMessage);\n            }\n        }\n        return null;\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        if (xmppMessage != null) {\n            map.putAll(getExchange().getBinding().extractHeadersFromXmpp(xmppMessage, getExchange()));\n        }\n    }","id":104026,"modified_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        if (xmppMessage != null) {\n            XmppBinding binding = (XmppBinding) getExchange().getProperty(Exchange.BINDING);\n            if (binding != null) {\n                map.putAll(binding.extractHeadersFromXmpp(xmppMessage, getExchange()));\n            }\n        }\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"protected Object assertReceivedValidExchange() throws Exception {\n        // lets wait on the message being received\n        boolean received = latch.await(5, TimeUnit.SECONDS);\n        assertTrue(\"Did not receive the message!\", received);\n\n        assertNotNull(receivedExchange);\n        XmppMessage receivedMessage = receivedExchange.getIn();\n\n        Assert.assertEquals(\"cheese header\", 123, receivedMessage.getHeader(\"cheese\"));\n        Object body = receivedMessage.getBody();\n        XmppRouteTest.LOG.debug(\"Received body: \" + body);\n        Message xmppMessage = receivedMessage.getXmppMessage();\n        assertNotNull(xmppMessage);\n\n        XmppRouteTest.LOG.debug(\"Received XMPP message: \" + xmppMessage.getBody());\n        return body;\n    }","id":104027,"modified_method":"protected Object assertReceivedValidExchange() throws Exception {\n        // lets wait on the message being received\n        boolean received = latch.await(5, TimeUnit.SECONDS);\n        assertTrue(\"Did not receive the message!\", received);\n\n        assertNotNull(receivedExchange);\n        XmppMessage receivedMessage = (XmppMessage)receivedExchange.getIn();\n\n        Assert.assertEquals(\"cheese header\", 123, receivedMessage.getHeader(\"cheese\"));\n        Object body = receivedMessage.getBody();\n        XmppRouteTest.LOG.debug(\"Received body: \" + body);\n        Message xmppMessage = receivedMessage.getXmppMessage();\n        assertNotNull(xmppMessage);\n\n        XmppRouteTest.LOG.debug(\"Received XMPP message: \" + xmppMessage.getBody());\n        return body;\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        if (isXmppServerPresent()) {\n            String uriPrefix = getUriPrefix();\n            final String uri1 = uriPrefix + \"&resource=camel-test-from&nickname=came-test-from\";\n            final String uri2 = uriPrefix + \"&resource=camel-test-to&nickname=came-test-to\";\n            final String uri3 = uriPrefix + \"&resource=camel-test-from-processor&nickname=came-test-from-processor\";\n            LOG.info(\"Using URI \" + uri1 + \" and \" + uri2);\n\n            endpoint = container.getEndpoint(uri1);\n            assertNotNull(\"No endpoint found!\", endpoint);\n\n            // lets add some routes\n            container.addRoutes(new RouteBuilder() {\n                public void configure() {\n                    from(uri1).to(uri2);\n                    from(uri3).process(new Processor() {\n                        public void process(Exchange e) {\n                            LOG.info(\"Received exchange: \" + e);\n                            receivedExchange = (XmppExchange) e;\n                            latch.countDown();\n                        }\n                    });\n                }\n            });\n        }\n\n        container.start();\n    }","id":104028,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        if (isXmppServerPresent()) {\n            String uriPrefix = getUriPrefix();\n            final String uri1 = uriPrefix + \"&resource=camel-test-from&nickname=came-test-from\";\n            final String uri2 = uriPrefix + \"&resource=camel-test-to&nickname=came-test-to\";\n            final String uri3 = uriPrefix + \"&resource=camel-test-from-processor&nickname=came-test-from-processor\";\n            LOG.info(\"Using URI \" + uri1 + \" and \" + uri2);\n\n            endpoint = container.getEndpoint(uri1);\n            assertNotNull(\"No endpoint found!\", endpoint);\n\n            // lets add some routes\n            container.addRoutes(new RouteBuilder() {\n                public void configure() {\n                    from(uri1).to(uri2);\n                    from(uri3).process(new Processor() {\n                        public void process(Exchange e) {\n                            LOG.info(\"Received exchange: \" + e);\n                            receivedExchange = e;\n                            latch.countDown();\n                        }\n                    });\n                }\n            });\n        }\n\n        container.start();\n    }","commit_id":"21936a5d94d3ea01ab478de1c81349d99cab97db","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Extracts the body from the Mail message\n     */\n    public Object extractBodyFromMail(MailExchange exchange, Message message) {\n        try {\n            return message.getContent();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Failed to extract body due to: \" + e.getMessage()\n                + \". Exchange: \" + exchange + \". Message: \" + message, e);\n        }\n    }","id":104029,"modified_method":"/**\n     * Extracts the body from the Mail message\n     */\n    public Object extractBodyFromMail(Exchange exchange, Message message) {\n        try {\n            return message.getContent();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Failed to extract body due to: \" + e.getMessage()\n                + \". Exchange: \" + exchange + \". Message: \" + message, e);\n        }\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy when processing the exchange failed.\n     */\n    protected void processRollback(MailExchange exchange) throws MessagingException {\n        LOG.warn(\"Exchange failed, so rolling back message status: \" + exchange);\n    }","id":104030,"modified_method":"/**\n     * Strategy when processing the exchange failed.\n     */\n    protected void processRollback(Exchange exchange) throws MessagingException {\n        LOG.warn(\"Exchange failed, so rolling back message status: \" + exchange);\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy to process the mail message.\n     */\n    protected void processExchange(MailExchange exchange) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing message: \" + MailUtils.dumpMessage(exchange.getIn().getMessage()));\n        }\n        getProcessor().process(exchange);\n    }","id":104031,"modified_method":"/**\n     * Strategy to process the mail message.\n     */\n    protected void processExchange(Exchange exchange) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            MailMessage msg = (MailMessage) exchange.getIn();\n            LOG.debug(\"Processing message: \" + MailUtils.dumpMessage(msg.getMessage()));\n        }\n        getProcessor().process(exchange);\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"public void processBatch(Queue exchanges) throws Exception {\n        int total = exchanges.size();\n\n        // limit if needed\n        if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {\n            LOG.debug(\"Limiting to maximum messages to poll \" + maxMessagesPerPoll + \" as there was \" + total + \" messages in this poll.\");\n            total = maxMessagesPerPoll;\n        }\n\n        for (int index = 0; index < total && isRunAllowed(); index++) {\n            // only loop if we are started (allowed to run)\n            MailExchange exchange = (MailExchange) exchanges.poll();\n            // add current index and total as properties\n            exchange.setProperty(Exchange.BATCH_INDEX, index);\n            exchange.setProperty(Exchange.BATCH_SIZE, total);\n            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n\n            // process the current exchange\n            processExchange(exchange);\n            if (!exchange.isFailed()) {\n                processCommit(exchange);\n            } else {\n                processRollback(exchange);\n            }\n        }\n    }","id":104032,"modified_method":"public void processBatch(Queue exchanges) throws Exception {\n        int total = exchanges.size();\n\n        // limit if needed\n        if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {\n            LOG.debug(\"Limiting to maximum messages to poll \" + maxMessagesPerPoll + \" as there was \" + total + \" messages in this poll.\");\n            total = maxMessagesPerPoll;\n        }\n\n        for (int index = 0; index < total && isRunAllowed(); index++) {\n            // only loop if we are started (allowed to run)\n            Exchange exchange = (Exchange)exchanges.poll();\n            // add current index and total as properties\n            exchange.setProperty(Exchange.BATCH_INDEX, index);\n            exchange.setProperty(Exchange.BATCH_SIZE, total);\n            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n\n            // process the current exchange\n            processExchange(exchange);\n            if (!exchange.isFailed()) {\n                processCommit(exchange);\n            } else {\n                processRollback(exchange);\n            }\n        }\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy to flag the message after being processed.\n     */\n    protected void processCommit(MailExchange exchange) throws MessagingException {\n        Message message = exchange.getIn().getMessage();\n\n        if (endpoint.getConfiguration().isDelete()) {\n            LOG.debug(\"Exchange processed, so flagging message as DELETED\");\n            message.setFlag(Flags.Flag.DELETED, true);\n        } else {\n            LOG.debug(\"Exchange processed, so flagging message as SEEN\");\n            message.setFlag(Flags.Flag.SEEN, true);\n        }\n    }","id":104033,"modified_method":"/**\n     * Strategy to flag the message after being processed.\n     */\n    protected void processCommit(Exchange exchange) throws MessagingException {\n        MailMessage msg = (MailMessage) exchange.getIn();\n        Message message = msg.getMessage();\n\n        if (endpoint.getConfiguration().isDelete()) {\n            LOG.debug(\"Exchange processed, so flagging message as DELETED\");\n            message.setFlag(Flags.Flag.DELETED, true);\n        } else {\n            LOG.debug(\"Exchange processed, so flagging message as SEEN\");\n            message.setFlag(Flags.Flag.SEEN, true);\n        }\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"protected Queue<Exchange> createExchanges(Message[] messages) throws MessagingException {\n        Queue<Exchange> answer = new LinkedList<Exchange>();\n\n        int fetchSize = endpoint.getConfiguration().getFetchSize();\n        int count = fetchSize == -1 ? messages.length : Math.min(fetchSize, messages.length);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Fetching \" + count + \" messages. Total \" + messages.length + \" messages.\");\n        }\n\n        for (int i = 0; i < count; i++) {\n            Message message = messages[i];\n            if (!message.getFlags().contains(Flags.Flag.DELETED)) {\n                MailExchange exchange = endpoint.createExchange(message);\n                answer.add(exchange);\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Skipping message as it was flagged as deleted: \" + MailUtils.dumpMessage(message));\n                }\n            }\n        }\n\n        return answer;\n    }","id":104034,"modified_method":"protected Queue<Exchange> createExchanges(Message[] messages) throws MessagingException {\n        Queue<Exchange> answer = new LinkedList<Exchange>();\n\n        int fetchSize = endpoint.getConfiguration().getFetchSize();\n        int count = fetchSize == -1 ? messages.length : Math.min(fetchSize, messages.length);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Fetching \" + count + \" messages. Total \" + messages.length + \" messages.\");\n        }\n\n        for (int i = 0; i < count; i++) {\n            Message message = messages[i];\n            if (!message.getFlags().contains(Flags.Flag.DELETED)) {\n                Exchange exchange = endpoint.createExchange(message);\n                answer.add(exchange);\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Skipping message as it was flagged as deleted: \" + MailUtils.dumpMessage(message));\n                }\n            }\n        }\n\n        return answer;\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"public MailExchange createExchange(Message message) {\n        return new MailExchange(this, getExchangePattern(), getBinding(), message);\n    }","id":104035,"modified_method":"public Exchange createExchange(Message message) {\n        return createExchange(getExchangePattern(), message);\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Exchange createExchange(ExchangePattern pattern) {\n        return new MailExchange(this, pattern, getBinding());\n    }","id":104036,"modified_method":"@Override\n    public Exchange createExchange(ExchangePattern pattern) {\n        return createExchange(pattern, null);\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        if (mailMessage != null) {\n            try {\n                map.putAll(getExchange().getBinding().extractHeadersFromMail(mailMessage, getExchange()));\n            } catch (MessagingException e) {\n                throw new RuntimeCamelException(\"Error accessing headers due to: \" + e.getMessage(), e);\n            }\n        }\n    }","id":104037,"modified_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        if (mailMessage != null) {\n            try {\n                MailBinding binding = (MailBinding) getExchange().getProperty(Exchange.BINDING);\n                if (binding != null) {\n                    map.putAll(binding.extractHeadersFromMail(mailMessage, getExchange()));\n                }\n            } catch (MessagingException e) {\n                throw new RuntimeCamelException(\"Error accessing headers due to: \" + e.getMessage(), e);\n            }\n        }\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Object createBody() {\n        if (mailMessage != null) {\n            return getExchange().getBinding().extractBodyFromMail(getExchange(), mailMessage);\n        }\n        return null;\n    }","id":104038,"modified_method":"@Override\n    protected Object createBody() {\n        if (mailMessage != null) {\n            MailBinding binding = (MailBinding) getExchange().getProperty(Exchange.BINDING);\n            return binding != null ? binding.extractBodyFromMail(getExchange(), mailMessage) : null;\n        }\n        return null;\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testMailMessageHandlesMultipleHeaders() throws Exception {\n        mimeMessage.setRecipients(Message.RecipientType.TO, new Address[] {new InternetAddress(\"foo@localhost\"), new InternetAddress(\"bar@localhost\")});\n\n        MailExchange exchange = endpoint.createExchange(mimeMessage);\n        MailMessage in = exchange.getIn();\n\n        assertEquals(\"mail body\", body, in.getBody());\n\n        // need to use iterator as some mail impl returns String[] and others a single String with comma as separator\n        // so we let Camel create an iterator so we can use the same code for the test\n        Object to = in.getHeader(\"TO\");\n        Iterator<String> it = ObjectHelper.createIterator(to);\n        int i = 0;\n        while (it.hasNext()) {\n            if (i == 0) {\n                assertEquals(\"foo@localhost\", it.next().trim());\n            } else {\n                assertEquals(\"bar@localhost\", it.next().trim());\n            }\n            i++;\n        }\n    }","id":104039,"modified_method":"@Test\n    public void testMailMessageHandlesMultipleHeaders() throws Exception {\n        mimeMessage.setRecipients(Message.RecipientType.TO, new Address[] {new InternetAddress(\"foo@localhost\"), new InternetAddress(\"bar@localhost\")});\n\n        Exchange exchange = endpoint.createExchange(mimeMessage);\n        MailMessage in = (MailMessage)exchange.getIn();\n        assertNotNull(in);\n        assertEquals(\"mail body\", body, in.getBody());\n\n        // need to use iterator as some mail impl returns String[] and others a single String with comma as separator\n        // so we let Camel create an iterator so we can use the same code for the test\n        Object to = in.getHeader(\"TO\");\n        Iterator<String> it = ObjectHelper.createIterator(to);\n        int i = 0;\n        while (it.hasNext()) {\n            if (i == 0) {\n                assertEquals(\"foo@localhost\", it.next().trim());\n            } else {\n                assertEquals(\"bar@localhost\", it.next().trim());\n            }\n            i++;\n        }\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testMailMessageHandlesSingleHeader() throws Exception {\n        mimeMessage.setRecipients(Message.RecipientType.TO, new Address[] {new InternetAddress(\"frank@localhost\")});\n\n        MailExchange exchange = endpoint.createExchange(mimeMessage);\n        MailMessage in = exchange.getIn();\n        Object header = in.getHeader(\"TO\");\n        String value = assertIsInstanceOf(String.class, header);\n        assertEquals(\"value\", \"frank@localhost\", value);\n\n        assertEquals(\"body\", body, in.getBody());\n    }","id":104040,"modified_method":"@Test\n    public void testMailMessageHandlesSingleHeader() throws Exception {\n        mimeMessage.setRecipients(Message.RecipientType.TO, new Address[] {new InternetAddress(\"frank@localhost\")});\n\n        Exchange exchange = endpoint.createExchange(mimeMessage);\n        MailMessage in = (MailMessage)exchange.getIn();\n        assertNotNull(in);\n        Object header = in.getHeader(\"TO\");\n        String value = assertIsInstanceOf(String.class, header);\n        assertEquals(\"value\", \"frank@localhost\", value);\n\n        assertEquals(\"body\", body, in.getBody());\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Gets a log dump of the given message that can be used for tracing etc.\n     *\n     * @param message the Mail message\n     * @return a log string with important fields dumped\n     */\n    public static String dumpMessage(Message message) {\n        try {\n            StringBuilder sb = new StringBuilder();\n\n            int number = message.getMessageNumber();\n            sb.append(\"messageNumber=[\").append(number).append(\"]\");\n\n            Address[] from = message.getFrom();\n            if (from != null) {\n                for (Address adr : from) {\n                    sb.append(\", from=[\").append(adr).append(\"]\");\n                }\n            }\n\n            Address[] to = message.getRecipients(Message.RecipientType.TO);\n            if (to != null) {\n                for (Address adr : to) {\n                    sb.append(\", to=[\").append(adr).append(\"]\");\n                }\n            }\n\n            String subject = message.getSubject();\n            if (subject != null) {\n                sb.append(\", subject=[\").append(subject).append(\"]\");\n            }\n\n            Date sentDate = message.getSentDate();\n            if (sentDate != null) {\n                sb.append(\", sentDate=[\").append(DateFormat.getDateTimeInstance().format(sentDate)).append(\"]\");\n            }\n\n            Date receivedDate = message.getReceivedDate();\n            if (receivedDate != null) {\n                sb.append(\", receivedDate=[\").append(DateFormat.getDateTimeInstance().format(receivedDate)).append(\"]\");\n            }\n\n            return sb.toString();\n        } catch (MessagingException e) {\n            // ignore the error and just return tostring \n            return message.toString();\n        }\n\n    }","id":104041,"modified_method":"/**\n     * Gets a log dump of the given message that can be used for tracing etc.\n     *\n     * @param message the Mail message\n     * @return a log string with important fields dumped\n     */\n    public static String dumpMessage(Message message) {\n        if (message == null) {\n            return \"null\";\n        }\n        \n        try {\n            StringBuilder sb = new StringBuilder();\n\n            int number = message.getMessageNumber();\n            sb.append(\"messageNumber=[\").append(number).append(\"]\");\n\n            Address[] from = message.getFrom();\n            if (from != null) {\n                for (Address adr : from) {\n                    sb.append(\", from=[\").append(adr).append(\"]\");\n                }\n            }\n\n            Address[] to = message.getRecipients(Message.RecipientType.TO);\n            if (to != null) {\n                for (Address adr : to) {\n                    sb.append(\", to=[\").append(adr).append(\"]\");\n                }\n            }\n\n            String subject = message.getSubject();\n            if (subject != null) {\n                sb.append(\", subject=[\").append(subject).append(\"]\");\n            }\n\n            Date sentDate = message.getSentDate();\n            if (sentDate != null) {\n                sb.append(\", sentDate=[\").append(DateFormat.getDateTimeInstance().format(sentDate)).append(\"]\");\n            }\n\n            Date receivedDate = message.getReceivedDate();\n            if (receivedDate != null) {\n                sb.append(\", receivedDate=[\").append(DateFormat.getDateTimeInstance().format(receivedDate)).append(\"]\");\n            }\n\n            return sb.toString();\n        } catch (MessagingException e) {\n            // ignore the error and just return tostring \n            return message.toString();\n        }\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testSendAndReceiveMails() throws Exception {\n        Mailbox.clearAll();\n\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedMinimumMessageCount(1);\n\n        MimeMessage message = new MimeMessage(mailSession);\n        message.setText(body);\n\n        message.setRecipients(Message.RecipientType.TO,\n                              new Address[] {new InternetAddress(\"james@localhost\"),\n                                             new InternetAddress(\"bar@localhost\")});\n\n        Transport.send(message);\n\n        // lets test the receive worked\n        resultEndpoint.assertIsSatisfied();\n\n        Exchange exchange = resultEndpoint.getReceivedExchanges().get(0);\n\n        org.apache.camel.Message in = exchange.getIn();\n        assertNotNull(\"Should have headers\", in.getHeaders());\n\n        MailExchange mailExchange = (MailExchange) exchange;\n        Message inMessage = mailExchange.getIn().getMessage();\n        assertNotNull(\"In message has no JavaMail message!\", inMessage);\n\n        String text = in.getBody(String.class);\n        assertEquals(\"mail body\", body, text);\n\n        // need to use iterator as some mail impl returns String[] and others a single String with comma as separator\n        // so we let Camel create an iterator so we can use the same code for the test\n        Object to = in.getHeader(\"TO\");\n        Iterator<String> it = ObjectHelper.createIterator(to);\n        int i = 0;\n        while (it.hasNext()) {\n            if (i == 0) {\n                assertEquals(\"james@localhost\", it.next().trim());\n            } else {\n                assertEquals(\"bar@localhost\", it.next().trim());\n            }\n            i++;\n        }\n\n        Enumeration iter = inMessage.getAllHeaders();\n        while (iter.hasMoreElements()) {\n            Header header = (Header) iter.nextElement();\n            String[] value = message.getHeader(header.getName());\n            log.debug(\"Header: \" + header.getName() + \" has value: \" + ObjectHelper.asString(value));\n        }\n\n    }","id":104042,"modified_method":"@Test\n    public void testSendAndReceiveMails() throws Exception {\n        Mailbox.clearAll();\n\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedMinimumMessageCount(1);\n\n        MimeMessage message = new MimeMessage(mailSession);\n        message.setText(body);\n\n        message.setRecipients(Message.RecipientType.TO,\n                              new Address[] {new InternetAddress(\"james@localhost\"),\n                                             new InternetAddress(\"bar@localhost\")});\n\n        Transport.send(message);\n\n        // lets test the receive worked\n        resultEndpoint.assertIsSatisfied(100000);\n\n        Exchange exchange = resultEndpoint.getReceivedExchanges().get(0);\n\n        org.apache.camel.Message in = exchange.getIn();\n        assertNotNull(\"Should have headers\", in.getHeaders());\n\n        MailMessage msg = (MailMessage) exchange.getIn();\n        Message inMessage = msg != null ? msg.getMessage() : null;\n        assertNotNull(\"In message has no JavaMail message!\", inMessage);\n\n        String text = in.getBody(String.class);\n        assertEquals(\"mail body\", body, text);\n\n        // need to use iterator as some mail impl returns String[] and others a single String with comma as separator\n        // so we let Camel create an iterator so we can use the same code for the test\n        Object to = in.getHeader(\"TO\");\n        Iterator<String> it = ObjectHelper.createIterator(to);\n        int i = 0;\n        while (it.hasNext()) {\n            if (i == 0) {\n                assertEquals(\"james@localhost\", it.next().trim());\n            } else {\n                assertEquals(\"bar@localhost\", it.next().trim());\n            }\n            i++;\n        }\n\n        Enumeration iter = inMessage.getAllHeaders();\n        while (iter.hasMoreElements()) {\n            Header header = (Header) iter.nextElement();\n            String[] value = message.getHeader(header.getName());\n            log.debug(\"Header: \" + header.getName() + \" has value: \" + ObjectHelper.asString(value));\n        }\n\n    }","commit_id":"b0adfdde3e2bde4921c680bfed839ac994d17300","url":"https://github.com/apache/camel"},{"original_method":"@NotNull\n  private Pair<Point, Short> guessPosition() {\n    JLayeredPane layeredPane = myParentEditor.getContentComponent().getRootPane().getLayeredPane();\n    LogicalPosition logicalPosition = myParentEditor.getCaretModel().getLogicalPosition();\n\n    LogicalPosition pos = new LogicalPosition(logicalPosition.line, logicalPosition.column);\n    Point p1 = HintManagerImpl.getHintPosition(this, myParentEditor, pos, HintManager.UNDER);\n    Point p2 = HintManagerImpl.getHintPosition(this, myParentEditor, pos, HintManager.ABOVE);\n\n    boolean p1Ok = p1.y + getComponent().getPreferredSize().height < layeredPane.getHeight();\n    boolean p2Ok = p2.y >= 0;\n\n    if (p1Ok) return new Pair<Point, Short>(p1, HintManager.UNDER);\n    if (p2Ok) return new Pair<Point, Short>(p2, HintManager.ABOVE);\n\n    int underSpace = layeredPane.getHeight() - p1.y;\n    int aboveSpace = p2.y;\n    return aboveSpace > underSpace\n           ? new Pair<Point, Short>(new Point(p2.x, 0), HintManager.UNDER)\n           : new Pair<Point, Short>(p1, HintManager.ABOVE);\n  }","id":104043,"modified_method":"@NotNull\n  private Pair<Point, Short> guessPosition() {\n    JRootPane rootPane = myParentEditor.getContentComponent().getRootPane();\n    JComponent layeredPane = rootPane != null ? rootPane.getLayeredPane() : myParentEditor.getComponent();\n    LogicalPosition logicalPosition = myParentEditor.getCaretModel().getLogicalPosition();\n\n    LogicalPosition pos = new LogicalPosition(logicalPosition.line, logicalPosition.column);\n    Point p1 = HintManagerImpl.getHintPosition(this, myParentEditor, pos, HintManager.UNDER);\n    Point p2 = HintManagerImpl.getHintPosition(this, myParentEditor, pos, HintManager.ABOVE);\n\n    boolean p1Ok = p1.y + getComponent().getPreferredSize().height < layeredPane.getHeight();\n    boolean p2Ok = p2.y >= 0;\n\n    if (p1Ok) return new Pair<Point, Short>(p1, HintManager.UNDER);\n    if (p2Ok) return new Pair<Point, Short>(p2, HintManager.ABOVE);\n\n    int underSpace = layeredPane.getHeight() - p1.y;\n    int aboveSpace = p2.y;\n    return aboveSpace > underSpace\n           ? new Pair<Point, Short>(new Point(p2.x, 0), HintManager.UNDER)\n           : new Pair<Point, Short>(p1, HintManager.ABOVE);\n  }","commit_id":"d13a4e18a7bb1b1098e07491f64fd0e9bedd795b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateText(@NotNull final Producer<String> contentProducer) {\n    myAlarm.cancelAllRequests();\n    myAlarm.addRequest(new Runnable() {\n      @Override\n      public void run() {\n        if (!isDisposed) {\n          final String newText = contentProducer.produce();\n          if (StringUtil.isEmpty(newText)) {\n            hide();\n          }\n          else if (!myEditor.getDocument().getText().equals(newText)) {\n            DocumentUtil.writeInRunUndoTransparentAction(new Runnable() {\n              @Override\n              public void run() {\n                myEditor.getDocument().setText(newText);\n              }\n            });\n            Pair<Point, Short> position = guessPosition();\n            HintManagerImpl.adjustEditorHintPosition(EmmetPreviewHint.this, myParentEditor, position.first, position.second);\n          }\n        }\n      }\n    }, 100);\n  }","id":104044,"modified_method":"public void updateText(@NotNull final Producer<String> contentProducer) {\n    myAlarm.cancelAllRequests();\n    myAlarm.addRequest(new Runnable() {\n      @Override\n      public void run() {\n        if (!isDisposed) {\n          final String newText = contentProducer.produce();\n          if (StringUtil.isEmpty(newText)) {\n            hide();\n          }\n          else if (!myEditor.getDocument().getText().equals(newText)) {\n            DocumentUtil.writeInRunUndoTransparentAction(new Runnable() {\n              @Override\n              public void run() {\n                myEditor.getDocument().setText(newText);\n              }\n            });\n          }\n        }\n      }\n    }, 100);\n  }","commit_id":"d13a4e18a7bb1b1098e07491f64fd0e9bedd795b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showHint() {\n    myParentEditor.putUserData(KEY, this);\n\n    Pair<Point, Short> position = guessPosition();\n    JLayeredPane layeredPane = myParentEditor.getComponent().getRootPane().getLayeredPane();\n    HintHint hintHint = new HintHint(layeredPane, position.first)\n        .setAwtTooltip(true)\n        .setContentActive(true)\n        .setExplicitClose(true)\n        .setShowImmediately(true)\n        .setPreferredPosition(position.second == HintManager.ABOVE ? Balloon.Position.above : Balloon.Position.below);\n\n    int hintFlags = HintManager.HIDE_BY_OTHER_HINT | HintManager.HIDE_BY_ESCAPE | HintManager.UPDATE_BY_SCROLLING;\n    HintManagerImpl.getInstanceImpl().showEditorHint(this, myParentEditor, position.first, hintFlags, 0, false, hintHint);\n  }","id":104045,"modified_method":"public void showHint() {\n    myParentEditor.putUserData(KEY, this);\n\n    Pair<Point, Short> position = guessPosition();\n    JRootPane pane = myParentEditor.getComponent().getRootPane();\n    JComponent layeredPane = pane != null ? pane.getLayeredPane() : myParentEditor.getComponent();\n    HintHint hintHint = new HintHint(layeredPane, position.first)\n        .setAwtTooltip(true)\n        .setContentActive(true)\n        .setExplicitClose(true)\n        .setShowImmediately(true)\n        .setPreferredPosition(position.second == HintManager.ABOVE ? Balloon.Position.above : Balloon.Position.below);\n\n    int hintFlags = HintManager.HIDE_BY_OTHER_HINT | HintManager.HIDE_BY_ESCAPE | HintManager.UPDATE_BY_SCROLLING;\n    HintManagerImpl.getInstanceImpl().showEditorHint(this, myParentEditor, position.first, hintFlags, 0, false, hintHint);\n  }","commit_id":"d13a4e18a7bb1b1098e07491f64fd0e9bedd795b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EmmetPreviewHint(@NotNull JBPanel panel, @NotNull Editor editor, @NotNull Editor parentEditor) {\n    super(panel);\n    myParentEditor = parentEditor;\n    myEditor = editor;\n\n    EditorFactory.getInstance().addEditorFactoryListener(new EditorFactoryAdapter() {\n      @Override\n      public void editorReleased(@NotNull EditorFactoryEvent event) {\n        if (event.getEditor() == myParentEditor || event.getEditor() == myEditor) {\n          hide();\n        }\n      }\n    }, this);\n  }","id":104046,"modified_method":"private EmmetPreviewHint(@NotNull JBPanel panel, @NotNull Editor editor, @NotNull Editor parentEditor) {\n    super(panel);\n    myParentEditor = parentEditor;\n    myEditor = editor;\n\n    EditorFactory.getInstance().addEditorFactoryListener(new EditorFactoryAdapter() {\n      @Override\n      public void editorReleased(@NotNull EditorFactoryEvent event) {\n        if (event.getEditor() == myParentEditor || event.getEditor() == myEditor) {\n          hide();\n        }\n      }\n    }, this);\n\n    myEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent event) {\n        if (!isDisposed && event.isWholeTextReplaced()) {\n          Pair<Point, Short> position = guessPosition();\n          HintManagerImpl.adjustEditorHintPosition(EmmetPreviewHint.this, myParentEditor, position.first, position.second);\n          myEditor.getScrollingModel().scrollVertically(0);\n        }\n      }\n    }, this);\n  }","commit_id":"d13a4e18a7bb1b1098e07491f64fd0e9bedd795b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String calculateTemplateText(@NotNull Editor editor, @NotNull PsiFile file, boolean expandPrimitiveAbbreviations) {\n    if (file instanceof XmlFile) {\n      final Ref<TemplateImpl> generatedTemplate = new Ref<TemplateImpl>();\n      CustomTemplateCallback callback = createCallback(editor, file, generatedTemplate);\n      PsiElement context = callback.getContext();\n      ZenCodingGenerator generator = ZenCodingTemplate.findApplicableDefaultGenerator(context, false);\n      if (generator != null) {\n        final String templatePrefix = new ZenCodingTemplate().computeTemplateKeyWithoutContextChecking(callback);\n        if (templatePrefix != null) {\n          ZenCodingTemplate.expand(templatePrefix, callback, null, generator, Collections.<ZenCodingFilter>emptyList(), expandPrimitiveAbbreviations, 0);\n          TemplateImpl template = generatedTemplate.get();\n          String templateText = template != null ? template.getTemplateText() : null;\n          if (!StringUtil.isEmpty(templateText)) {\n            return template.isToReformat() ? reformatTemplateText(file, templateText) : templateText;\n          }\n        }\n      }\n    }\n    return null;\n  }","id":104047,"modified_method":"@Nullable\n  public static String calculateTemplateText(@NotNull Editor editor, @NotNull PsiFile file, boolean expandPrimitiveAbbreviations) {\n    if (file instanceof XmlFile) {\n      final Ref<TemplateImpl> generatedTemplate = new Ref<TemplateImpl>();\n      CustomTemplateCallback callback = createCallback(editor, file, generatedTemplate);\n      PsiDocumentManager.getInstance(file.getProject()).commitDocument(editor.getDocument());\n      PsiElement context = callback.getContext();\n      ZenCodingGenerator generator = ZenCodingTemplate.findApplicableDefaultGenerator(context, false);\n      if (generator != null) {\n        final String templatePrefix = new ZenCodingTemplate().computeTemplateKeyWithoutContextChecking(callback);\n        if (templatePrefix != null) {\n          ZenCodingTemplate.expand(templatePrefix, callback, null, generator, Collections.<ZenCodingFilter>emptyList(), expandPrimitiveAbbreviations, 0);\n          TemplateImpl template = generatedTemplate.get();\n          String templateText = template != null ? template.getTemplateText() : null;\n          if (!StringUtil.isEmpty(templateText)) {\n            return template.isToReformat() ? reformatTemplateText(file, templateText) : templateText;\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"d13a4e18a7bb1b1098e07491f64fd0e9bedd795b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private <T> List<T> getListWithLimit(List<T> list) {\n    if (mySegmentLimit == 0) {\n      return Collections.emptyList();\n    }\n    if (mySegmentLimit > 0 && list.size() > mySegmentLimit) {\n      LOGGER.warn(\"Template with more than \" + mySegmentLimit + \" segments had been build (\" + list.size() + \"). Text: \" + myText);\n      return list.subList(0, Math.min(list.size(), mySegmentLimit));\n    }\n    return list;\n  }","id":104048,"modified_method":"private <T> List<T> getListWithLimit(List<T> list) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return list;\n    }\n    if (mySegmentLimit == 0) {\n      return Collections.emptyList();\n    }\n    if (mySegmentLimit > 0 && list.size() > mySegmentLimit) {\n      LOGGER.warn(\"Template with more than \" + mySegmentLimit + \" segments had been build (\" + list.size() + \"). Text: \" + myText);\n      return list.subList(0, Math.min(list.size(), mySegmentLimit));\n    }\n    return list;\n  }","commit_id":"d13a4e18a7bb1b1098e07491f64fd0e9bedd795b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public void show() {\n    LOG.assertTrue(myInplaceEditorComponent == null, \"editor is not released\");\n    final DebuggerTree tree = myNode.getTree();\n    final JLayeredPane layeredPane = tree.getRootPane().getLayeredPane();\n\n    Rectangle bounds = getEditorBounds();\n\n    Point layeredPanePoint = SwingUtilities.convertPoint(tree, bounds.x, bounds.y,layeredPane);\n\n    myInplaceEditorComponent = createInplaceEditorComponent();\n    LOG.assertTrue(myInplaceEditorComponent != null);\n    myInplaceEditorComponent.setBounds(\n      layeredPanePoint.x,\n      layeredPanePoint.y,\n      bounds.width,\n      Math.max(bounds.height, myInplaceEditorComponent.getPreferredSize().height)\n    );\n\n    layeredPane.add(myInplaceEditorComponent,new Integer(250));\n\n    myInplaceEditorComponent.validate();\n    myInplaceEditorComponent.paintImmediately(0,0,myInplaceEditorComponent.getWidth(),myInplaceEditorComponent.getHeight());\n    getPreferredFocusedComponent().requestFocus();\n\n    tree.getRootPane().addComponentListener(myComponentListener);\n    ExecutionManager.getInstance(getProject()).getContentManager().addRunContentListener(myRunContentListener);\n    final JComponent editorComponent = getEditorComponent();\n    editorComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"enterStroke\");\n    editorComponent.getActionMap().put(\"enterStroke\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        doOKAction();\n      }\n    });\n    editorComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"escapeStroke\");\n    editorComponent.getActionMap().put(\"escapeStroke\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        cancelEditing();\n      }\n    });\n    Toolkit.getDefaultToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n  }","id":104049,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public void show() {\n    LOG.assertTrue(myInplaceEditorComponent == null, \"editor is not released\");\n    final DebuggerTree tree = myNode.getTree();\n    final JRootPane rootPane = tree.getRootPane();\n    if (rootPane == null) {\n      return;\n    }\n    final JLayeredPane layeredPane = rootPane.getLayeredPane();\n\n    Rectangle bounds = getEditorBounds();\n\n    Point layeredPanePoint = SwingUtilities.convertPoint(tree, bounds.x, bounds.y,layeredPane);\n\n    final JComponent inplaceEditorComponent = createInplaceEditorComponent();\n    myInplaceEditorComponent = inplaceEditorComponent;\n    LOG.assertTrue(inplaceEditorComponent != null);\n    inplaceEditorComponent.setBounds(\n      layeredPanePoint.x,\n      layeredPanePoint.y,\n      bounds.width,\n      Math.max(bounds.height, inplaceEditorComponent.getPreferredSize().height)\n    );\n\n    layeredPane.add(inplaceEditorComponent, new Integer(250));\n\n    myRemoveActions.add(new Runnable() {\n      public void run() {\n        layeredPane.remove(inplaceEditorComponent);\n      }\n    });\n\n    inplaceEditorComponent.validate();\n    inplaceEditorComponent.paintImmediately(0,0,inplaceEditorComponent.getWidth(),inplaceEditorComponent.getHeight());\n    getPreferredFocusedComponent().requestFocus();\n\n    final ComponentAdapter componentListener = new ComponentAdapter() {\n      public void componentResized(ComponentEvent e) {\n        DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {\n          public void run() {\n            if (!isShown()) {\n              return;\n            }\n            JTree tree = myNode.getTree();\n            JLayeredPane layeredPane = tree.getRootPane().getLayeredPane();\n            Rectangle bounds = getEditorBounds();\n            Point layeredPanePoint = SwingUtilities.convertPoint(tree, bounds.x, bounds.y, layeredPane);\n            inplaceEditorComponent.setBounds(layeredPanePoint.x, layeredPanePoint.y, bounds.width, bounds.height);\n            inplaceEditorComponent.revalidate();\n          }\n        });\n      }\n\n      public void componentHidden(ComponentEvent e) {\n        cancelEditing();\n      }\n    };\n    rootPane.addComponentListener(componentListener);\n    myRemoveActions.add(new Runnable() {\n      public void run() {\n        rootPane.removeComponentListener(componentListener);\n      }\n    });\n\n    final RunContentManager contentManager = ExecutionManager.getInstance(getProject()).getContentManager();\n    final RunContentListener runContentListener = new RunContentListener() {\n      public void contentSelected(RunContentDescriptor descriptor) {\n        cancelEditing();\n      }\n\n      public void contentRemoved(RunContentDescriptor descriptor) {\n        cancelEditing();\n      }\n    };\n    contentManager.addRunContentListener(runContentListener);\n    myRemoveActions.add(new Runnable() {\n      public void run() {\n        contentManager.removeRunContentListener(runContentListener);\n      }\n    });\n\n    final JComponent editorComponent = getEditorComponent();\n    editorComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"enterStroke\");\n    editorComponent.getActionMap().put(\"enterStroke\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        doOKAction();\n      }\n    });\n    editorComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"escapeStroke\");\n    editorComponent.getActionMap().put(\"escapeStroke\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        cancelEditing();\n      }\n    });\n    final Toolkit defaultToolkit = Toolkit.getDefaultToolkit();\n    defaultToolkit.addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n    myRemoveActions.add(new Runnable() {\n      public void run() {\n        defaultToolkit.removeAWTEventListener(InplaceEditor.this);\n      }\n    });\n  }","commit_id":"ccd187f62bef43ac3cc8aa5641847149ce9534ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void remove() {\n    if (!isShown()) {\n      return;\n    }\n    //ListenerUtil.removeKeyListener(getPreferredFocusedComponent(), this);\n    //ListenerUtil.removeKeyListener(myInplaceEditorComponent, this);\n    Toolkit.getDefaultToolkit().removeAWTEventListener(this);\n    ExecutionManager.getInstance(getProject()).getContentManager().removeRunContentListener(myRunContentListener);\n\n    DebuggerTree tree = myNode.getTree();\n    JRootPane rootPane = tree.getRootPane();\n    if (rootPane != null) {\n      JLayeredPane layeredPane = rootPane.getLayeredPane();\n      if(layeredPane != null) {\n        layeredPane.remove(myInplaceEditorComponent);\n      }\n      rootPane.removeComponentListener(myComponentListener);\n    }\n    myInplaceEditorComponent = null;\n    tree.repaint();\n    tree.requestFocus();\n  }","id":104050,"modified_method":"private void remove() {\n    if (!isShown()) {\n      return;\n    }\n    for (Runnable action : myRemoveActions) {\n      action.run();\n    }\n    myRemoveActions.clear();\n\n    myInplaceEditorComponent = null;\n\n    final DebuggerTree tree = myNode.getTree();\n    tree.repaint();\n    tree.requestFocus();\n  }","commit_id":"ccd187f62bef43ac3cc8aa5641847149ce9534ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void eventDispatched(AWTEvent event) {\n    MouseEvent mouseEvent = (MouseEvent)event;\n    if (mouseEvent.getClickCount() == 0 || !isShown()) {\n      return;\n    }\n    final Component sourceComponent = mouseEvent.getComponent();\n    final Point originalPoint = mouseEvent.getPoint();\n\n    final Lookup activeLookup = LookupManager.getInstance(getEditor().getProject()).getActiveLookup();\n    if (activeLookup != null){\n      final DebuggerTree tree = myNode.getTree();\n      final JLayeredPane layeredPane = tree.getRootPane().getLayeredPane();\n      final Point layeredPoint = SwingUtilities.convertPoint(sourceComponent, originalPoint, layeredPane);\n      if (activeLookup.getBounds().contains(layeredPoint)){\n        return; //mouse click inside lookup\n      } else {\n        ((LookupImpl)activeLookup).hide(); //hide popup on mouse position changed\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(sourceComponent, originalPoint, myInplaceEditorComponent);\n    if (myInplaceEditorComponent.contains(point)) {\n      return;\n    }\n    final Component componentAtPoint = SwingUtilities.getDeepestComponentAt(sourceComponent, originalPoint.x, originalPoint.y);\n    for (Component comp = componentAtPoint; comp != null; comp = comp.getParent()) {\n      if (comp instanceof ComboPopup) {\n        return;\n      }\n    }\n    cancelEditing();\n  }","id":104051,"modified_method":"public void eventDispatched(AWTEvent event) {\n    if (!isShown()) {\n      return;\n    }\n    MouseEvent mouseEvent = (MouseEvent)event;\n    if (mouseEvent.getClickCount() == 0) {\n      return;\n    }\n    final Component sourceComponent = mouseEvent.getComponent();\n    final Point originalPoint = mouseEvent.getPoint();\n\n    final Lookup activeLookup = LookupManager.getInstance(getEditor().getProject()).getActiveLookup();\n    if (activeLookup != null){\n      final DebuggerTree tree = myNode.getTree();\n      final JLayeredPane layeredPane = tree.getRootPane().getLayeredPane();\n      final Point layeredPoint = SwingUtilities.convertPoint(sourceComponent, originalPoint, layeredPane);\n      if (activeLookup.getBounds().contains(layeredPoint)){\n        return; //mouse click inside lookup\n      } else {\n        ((LookupImpl)activeLookup).hide(); //hide popup on mouse position changed\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(sourceComponent, originalPoint, myInplaceEditorComponent);\n    if (myInplaceEditorComponent.contains(point)) {\n      return;\n    }\n    final Component componentAtPoint = SwingUtilities.getDeepestComponentAt(sourceComponent, originalPoint.x, originalPoint.y);\n    for (Component comp = componentAtPoint; comp != null; comp = comp.getParent()) {\n      if (comp instanceof ComboPopup) {\n        return;\n      }\n    }\n    cancelEditing();\n  }","commit_id":"ccd187f62bef43ac3cc8aa5641847149ce9534ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void cleanupUI() {\n    JLayeredPane layeredPane;\n    try {\n      // Return focus back to the previous focused component if we need to do it and\n      // previous focused componen is showing.\n      if (\n        myPreviouslyFocusedComponent instanceof JComponent &&\n        myPreviouslyFocusedComponent.isShowing()\n      ){\n        final JComponent _component = (JComponent)myPreviouslyFocusedComponent;\n        LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(_component);\n      }\n      if (myPreviouslyFocusedComponent != null) {\n        myPreviouslyFocusedComponent.requestFocus();\n      }\n\n      layeredPane = myTextFieldPanel.getRootPane().getLayeredPane();\n      layeredPane.remove(myListScrollPane);\n      layeredPane.remove(myTextFieldPanel);\n    }\n    finally {\n      LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(null);\n    }\n    layeredPane.validate();\n    layeredPane.repaint();\n  }","id":104052,"modified_method":"private void cleanupUI() {\n    JLayeredPane layeredPane = null;\n    try {\n      // Return focus back to the previous focused component if we need to do it and\n      // previous focused componen is showing.\n      if (\n        myPreviouslyFocusedComponent instanceof JComponent &&\n        myPreviouslyFocusedComponent.isShowing()\n      ){\n        final JComponent _component = (JComponent)myPreviouslyFocusedComponent;\n        LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(_component);\n      }\n      if (myPreviouslyFocusedComponent != null) {\n        myPreviouslyFocusedComponent.requestFocus();\n      }\n\n      final JRootPane rootPane = myTextFieldPanel.getRootPane();\n      if (rootPane != null) {\n        layeredPane = rootPane.getLayeredPane();\n        layeredPane.remove(myListScrollPane);\n        layeredPane.remove(myTextFieldPanel);\n      }\n    }\n    finally {\n      LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(null);\n    }\n    \n    if (layeredPane != null) {\n      layeredPane.validate();\n      layeredPane.repaint();\n    }\n  }","commit_id":"08c277cef1e05c8abfe8810b21b3d56ff910379b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showQuestionHint(@NotNull final Editor editor,\n                               @NotNull final Point p,\n                               final int offset1,\n                               final int offset2,\n                               @NotNull final LightweightHint hint,\n                               @NotNull final QuestionAction action,\n                               boolean showByBalloon,\n                               short constraint) {\n    TextAttributes attributes = new TextAttributes();\n    attributes.setEffectColor(HintUtil.QUESTION_UNDERSCORE_COLOR);\n    attributes.setEffectType(EffectType.LINE_UNDERSCORE);\n    final RangeHighlighter highlighter = editor.getMarkupModel()\n      .addRangeHighlighter(offset1, offset2, HighlighterLayer.ERROR + 1, attributes, HighlighterTargetArea.EXACT_RANGE);\n    if (myQuestionHint != null) {\n      myQuestionHint.hide();\n      myQuestionHint = null;\n      myQuestionAction = null;\n    }\n\n    hint.addHintListener(new HintListener() {\n      public void hintHidden(EventObject event) {\n        if (!editor.isDisposed()) {\n          editor.getMarkupModel().removeHighlighter(highlighter);\n        }\n\n        if (myQuestionHint == hint) {\n          myQuestionAction = null;\n          myQuestionHint = null;\n        }\n        hint.removeHintListener(this);\n      }\n    });\n\n    HintHint hintInfo = new HintHint(editor, p);\n    if (showByBalloon) {\n      JLayeredPane lp = editor.getComponent().getRootPane().getLayeredPane();\n      hintInfo = new HintHint(lp, p);\n      hintInfo.setAwtTooltip(true).setHighlighterType(true);\n    }\n    hintInfo.initStyleFrom(hint.getComponent());\n    hintInfo.setBorderColor(Color.gray);\n    hintInfo.setPreferredPosition(Balloon.Position.above);\n    if (constraint == UNDER || constraint == RIGHT_UNDER) {\n      hintInfo.setPreferredPosition(Balloon.Position.below);\n    } else if (constraint == RIGHT) {\n      hintInfo.setPreferredPosition(Balloon.Position.atRight);\n    } else if (constraint == LEFT) {\n      hintInfo.setPreferredPosition(Balloon.Position.atLeft);\n    }\n\n    showEditorHint(hint, editor, p, HIDE_BY_ANY_KEY | HIDE_BY_TEXT_CHANGE | UPDATE_BY_SCROLLING | HIDE_IF_OUT_OF_EDITOR, 0, false, hintInfo);\n    myQuestionAction = action;\n    myQuestionHint = hint;\n  }","id":104053,"modified_method":"public void showQuestionHint(@NotNull final Editor editor,\n                               @NotNull final Point p,\n                               final int offset1,\n                               final int offset2,\n                               @NotNull final LightweightHint hint,\n                               @NotNull final QuestionAction action,\n                               boolean showByBalloon,\n                               short constraint) {\n    TextAttributes attributes = new TextAttributes();\n    attributes.setEffectColor(HintUtil.QUESTION_UNDERSCORE_COLOR);\n    attributes.setEffectType(EffectType.LINE_UNDERSCORE);\n    final RangeHighlighter highlighter = editor.getMarkupModel()\n      .addRangeHighlighter(offset1, offset2, HighlighterLayer.ERROR + 1, attributes, HighlighterTargetArea.EXACT_RANGE);\n    if (myQuestionHint != null) {\n      myQuestionHint.hide();\n      myQuestionHint = null;\n      myQuestionAction = null;\n    }\n\n    hint.addHintListener(new HintListener() {\n      public void hintHidden(EventObject event) {\n        if (!editor.isDisposed()) {\n          editor.getMarkupModel().removeHighlighter(highlighter);\n        }\n\n        if (myQuestionHint == hint) {\n          myQuestionAction = null;\n          myQuestionHint = null;\n        }\n        hint.removeHintListener(this);\n      }\n    });\n\n    HintHint hintInfo = new HintHint(editor, p);\n    if (showByBalloon) {\n      JRootPane rootPane = editor.getComponent().getRootPane();\n      if (rootPane != null) {\n        JLayeredPane lp = rootPane.getLayeredPane();\n        hintInfo = new HintHint(lp, p);\n        hintInfo.setAwtTooltip(true).setHighlighterType(true);\n      }\n    }\n    hintInfo.initStyleFrom(hint.getComponent());\n    hintInfo.setBorderColor(Color.gray);\n    hintInfo.setPreferredPosition(Balloon.Position.above);\n    if (constraint == UNDER || constraint == RIGHT_UNDER) {\n      hintInfo.setPreferredPosition(Balloon.Position.below);\n    } else if (constraint == RIGHT) {\n      hintInfo.setPreferredPosition(Balloon.Position.atRight);\n    } else if (constraint == LEFT) {\n      hintInfo.setPreferredPosition(Balloon.Position.atLeft);\n    }\n\n    showEditorHint(hint, editor, p, HIDE_BY_ANY_KEY | HIDE_BY_TEXT_CHANGE | UPDATE_BY_SCROLLING | HIDE_IF_OUT_OF_EDITOR, 0, false, hintInfo);\n    myQuestionAction = action;\n    myQuestionHint = hint;\n  }","commit_id":"74348f6398a9cee8215b3b634e06769df99d40a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void hide() {\n    if (isVisible()) {\n      if (myIsRealPopup) {\n        myPopup.cancel();\n        myPopup = null;\n      }\n      else {\n        final Rectangle bounds = myComponent.getBounds();\n        final JLayeredPane layeredPane = myComponent.getRootPane().getLayeredPane();\n\n        try {\n          if(myFocusBackComponent != null){\n            LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(myFocusBackComponent);\n          }\n          layeredPane.remove(myComponent);\n        }\n        finally {\n          LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(null);\n        }\n        \n        layeredPane.repaint(bounds.x, bounds.y, bounds.width, bounds.height);\n      }\n    }\n    if (myEscListener != null) {\n      myComponent.unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0));\n    }\n    fireHintHidden();\n  }","id":104054,"modified_method":"public void hide() {\n    if (isVisible()) {\n      if (myIsRealPopup) {\n        myPopup.cancel();\n        myPopup = null;\n      }\n      else {\n        final JRootPane rootPane = myComponent.getRootPane();\n        if (rootPane != null) {\n          final Rectangle bounds = myComponent.getBounds();\n          final JLayeredPane layeredPane = rootPane.getLayeredPane();\n\n          try {\n            if(myFocusBackComponent != null){\n              LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(myFocusBackComponent);\n            }\n            layeredPane.remove(myComponent);\n          }\n          finally {\n            LayoutFocusTraversalPolicyExt.setOverridenDefaultComponent(null);\n          }\n\n          layeredPane.repaint(bounds.x, bounds.y, bounds.width, bounds.height);\n        }\n      }\n    }\n    if (myEscListener != null) {\n      myComponent.unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0));\n    }\n    fireHintHidden();\n  }","commit_id":"1fd8c67888278d347e4a222f89891b6a2cb3b60f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Refreshes the nodes in the tree to reflect updates in the database\n     * should be called in the gui thread\n     */\n    private void refreshTree(final BlackboardArtifact.ARTIFACT_TYPE... types) {\n\n        Node selected = getSelectedNode();\n        final String[] path = NodeOp.createPath(selected, em.getRootContext());\n\n        //TODO: instead, we should choose a specific key to refresh? Maybe?\n        //contentChildren.refreshKeys();\n\n        Children dirChilds = em.getRootContext().getChildren();\n\n        Node results = dirChilds.findChild(ResultsNode.NAME);\n\n        OriginalNode original = results.getLookup().lookup(OriginalNode.class);\n        ResultsNode resultsNode = (ResultsNode) original.getNode();\n        RootContentChildren resultsNodeChilds = (RootContentChildren) resultsNode.getChildren();\n        resultsNodeChilds.refreshKeys(types);\n\n        final TreeView tree = getTree();\n\n        tree.expandNode(results);\n\n        Children resultsChilds = results.getChildren();\n        tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n        tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n        SwingUtilities.invokeLater(new Runnable() {\n\n            @Override\n            public void run() {\n\n                if (path.length > 0 && path[0].equals(ResultsNode.NAME)) {\n                    try {\n                        Node newSelection = NodeOp.findPath(em.getRootContext(), path);\n                        resetHistoryListAndButtons();\n                        tree.expandNode(newSelection);\n                        em.setExploredContextAndSelection(newSelection, new Node[]{newSelection});\n                        // We need to set the selection, which will refresh dataresult and get rid of the oob exception\n                    } catch (NodeNotFoundException ex) {\n                        logger.log(Level.WARNING, \"Node not found\", ex);\n                    } catch (PropertyVetoException ex) {\n                        logger.log(Level.WARNING, \"Property Veto\", ex);\n                    }\n                }\n            }\n        });\n    }","id":104055,"modified_method":"/**\n     * Refreshes the nodes in the tree to reflect updates in the database\n     * should be called in the gui thread\n     */\n    private void refreshTree(final BlackboardArtifact.ARTIFACT_TYPE... types) {\n\n        Node selected = getSelectedNode();\n        final String[] path = NodeOp.createPath(selected, em.getRootContext());\n\n        //TODO: instead, we should choose a specific key to refresh? Maybe?\n        //contentChildren.refreshKeys();\n\n        Children dirChilds = em.getRootContext().getChildren();\n\n        Node results = dirChilds.findChild(ResultsNode.NAME);\n\n        OriginalNode original = results.getLookup().lookup(OriginalNode.class);\n        ResultsNode resultsNode = (ResultsNode) original.getNode();\n        RootContentChildren resultsNodeChilds = (RootContentChildren) resultsNode.getChildren();\n        resultsNodeChilds.refreshKeys(types);\n\n        final TreeView tree = getTree();\n\n        tree.expandNode(results);\n\n        Children resultsChilds = results.getChildren();\n        \n        if (resultsChilds == null)\n            //intermediate state check\n            return;\n        \n        Node childNode = resultsChilds.findChild(KeywordHits.NAME);\n        if (childNode == null)\n            //intermediate state check\n            return;\n        tree.expandNode(childNode);\n        \n        childNode = resultsChilds.findChild(ExtractedContentNode.NAME);\n        if (childNode == null)\n            //intermediate state check\n            return;\n        tree.expandNode(childNode);\n        \n        SwingUtilities.invokeLater(new Runnable() {\n\n            @Override\n            public void run() {\n\n                if (path.length > 0 && path[0].equals(ResultsNode.NAME)) {\n                    try {\n                        Node newSelection = NodeOp.findPath(em.getRootContext(), path);\n                        resetHistoryListAndButtons();\n                        if (newSelection != null) {\n                            tree.expandNode(newSelection);\n                            em.setExploredContextAndSelection(newSelection, new Node[]{newSelection});\n                        }\n                        // We need to set the selection, which will refresh dataresult and get rid of the oob exception\n                    } catch (NodeNotFoundException ex) {\n                        logger.log(Level.WARNING, \"Node not found\", ex);\n                    } catch (PropertyVetoException ex) {\n                        logger.log(Level.WARNING, \"Property Veto\", ex);\n                    }\n                }\n            }\n        });\n    }","commit_id":"27e9b7f8ee250006b5fe3579a08a58cd74bdd5d6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static ApplyPatchStatus applySinglePatch(final Project project, final FilePatch patch, final VirtualFile baseDirectory,\n                                                   final int stripLeadingDirectories) {\n    VirtualFile file = patch.findFileToPatch(baseDirectory, stripLeadingDirectories);\n    if (file == null) {\n      Messages.showErrorDialog(project, \"Cannot find file to patch: \" + patch.getBeforeName(), \"Apply Patch\");\n      return ApplyPatchStatus.FAILURE;\n    }\n\n    try {\n      return patch.apply(file);\n    }\n    catch(ApplyPatchException ex) {\n      if (!patch.isNewFile() && !patch.isDeletedFile()) {\n        PatchBaseVersionProvider provider = findBaseVersionProvider(project, patch, file);\n        if (provider != null) {\n          final StringBuilder newText = new StringBuilder();\n          final Ref<CharSequence> contentRef = new Ref<CharSequence>();\n          final Ref<ApplyPatchStatus> statusRef = new Ref<ApplyPatchStatus>();\n          provider.getBaseVersionContent(file, patch.getBeforeVersionId(), new Processor<CharSequence>() {\n            public boolean process(final CharSequence text) {\n              newText.setLength(0);\n              try {\n                statusRef.set(patch.applyModifications(text, newText));\n              }\n              catch(ApplyPatchException ex) {\n                return true;  // continue to older versions\n              }\n              contentRef.set(text);\n              return false;\n            }\n          });\n          ApplyPatchStatus status = statusRef.get();\n          if (status != null) {\n            if (status != ApplyPatchStatus.ALREADY_APPLIED) {\n              return showMergeDialog(project, file, contentRef.get(), newText.toString());\n            }\n            else {\n              return status;\n            }\n          }\n        }\n      }\n      Messages.showErrorDialog(project, VcsBundle.message(\"patch.apply.error\", patch.getBeforeName(), ex.getMessage()),\n                               VcsBundle.message(\"patch.apply.dialog.title\"));\n    }\n    catch (Exception ex) {\n      LOG.error(ex);\n    }\n    return ApplyPatchStatus.FAILURE;\n  }","id":104056,"modified_method":"private static ApplyPatchStatus applySinglePatch(final Project project, final FilePatch patch, final VirtualFile baseDirectory,\n                                                   final int stripLeadingDirectories, final boolean createDirectories) {\n    VirtualFile file = patch.findFileToPatch(baseDirectory, stripLeadingDirectories, createDirectories);\n    if (file == null) {\n      Messages.showErrorDialog(project, \"Cannot find file to patch: \" + patch.getBeforeName(), \"Apply Patch\");\n      return ApplyPatchStatus.FAILURE;\n    }\n\n    try {\n      return patch.apply(file);\n    }\n    catch(ApplyPatchException ex) {\n      if (!patch.isNewFile() && !patch.isDeletedFile()) {\n        PatchBaseVersionProvider provider = findBaseVersionProvider(project, patch, file);\n        if (provider != null) {\n          final StringBuilder newText = new StringBuilder();\n          final Ref<CharSequence> contentRef = new Ref<CharSequence>();\n          final Ref<ApplyPatchStatus> statusRef = new Ref<ApplyPatchStatus>();\n          provider.getBaseVersionContent(file, patch.getBeforeVersionId(), new Processor<CharSequence>() {\n            public boolean process(final CharSequence text) {\n              newText.setLength(0);\n              try {\n                statusRef.set(patch.applyModifications(text, newText));\n              }\n              catch(ApplyPatchException ex) {\n                return true;  // continue to older versions\n              }\n              contentRef.set(text);\n              return false;\n            }\n          });\n          ApplyPatchStatus status = statusRef.get();\n          if (status != null) {\n            if (status != ApplyPatchStatus.ALREADY_APPLIED) {\n              return showMergeDialog(project, file, contentRef.get(), newText.toString());\n            }\n            else {\n              return status;\n            }\n          }\n        }\n      }\n      Messages.showErrorDialog(project, VcsBundle.message(\"patch.apply.error\", patch.getBeforeName(), ex.getMessage()),\n                               VcsBundle.message(\"patch.apply.dialog.title\"));\n    }\n    catch (Exception ex) {\n      LOG.error(ex);\n    }\n    return ApplyPatchStatus.FAILURE;\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    final ApplyPatchDialog dialog = new ApplyPatchDialog(project);\n    dialog.show();    \n    if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    applyPatch(project, dialog.getPatches(), dialog.getBaseDirectory(), dialog.getStripLeadingDirectories());\n  }","id":104057,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    final ApplyPatchDialog dialog = new ApplyPatchDialog(project);\n    dialog.show();    \n    if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    applyPatch(project, dialog.getPatches(), dialog.getBaseDirectory(), dialog.getStripLeadingDirectories(), false);\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ApplyPatchStatus applyPatch(final Project project, final List<FilePatch> patches, final VirtualFile baseDirectory,\n                                            final int stripLeadingDirectories) {\n    List<VirtualFile> filesToMakeWritable = new ArrayList<VirtualFile>();\n    for(FilePatch patch: patches) {\n      VirtualFile fileToPatch = patch.findFileToPatch(baseDirectory, stripLeadingDirectories);\n      if (fileToPatch != null && !fileToPatch.isDirectory()) {\n        filesToMakeWritable.add(fileToPatch);\n        FileType fileType = fileToPatch.getFileType();\n        if (fileType == StdFileTypes.UNKNOWN) {\n          fileType = FileTypeChooser.associateFileType(fileToPatch.getPresentableName());\n          if (fileType == null) {\n            return ApplyPatchStatus.FAILURE;\n          }\n        }\n      }\n    }\n    final VirtualFile[] fileArray = filesToMakeWritable.toArray(new VirtualFile[filesToMakeWritable.size()]);\n    final ReadonlyStatusHandler.OperationStatus readonlyStatus = ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(fileArray);\n    if (readonlyStatus.hasReadonlyFiles()) {\n      return ApplyPatchStatus.FAILURE;\n    }\n    final Ref<ApplyPatchStatus> statusRef = new Ref<ApplyPatchStatus>();\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          public void run() {\n            ApplyPatchStatus status = null;\n            for(FilePatch patch: patches) {\n              final ApplyPatchStatus patchStatus = applySinglePatch(project, patch, baseDirectory, stripLeadingDirectories);\n              status = ApplyPatchStatus.and(status, patchStatus);\n            }\n            if (status == ApplyPatchStatus.ALREADY_APPLIED) {\n              Messages.showInfoMessage(project, VcsBundle.message(\"patch.apply.already.applied\"),\n                                       VcsBundle.message(\"patch.apply.dialog.title\"));\n            }\n            else if (status == ApplyPatchStatus.PARTIAL) {\n              Messages.showInfoMessage(project, VcsBundle.message(\"patch.apply.partially.applied\"),\n                                       VcsBundle.message(\"patch.apply.dialog.title\"));\n            }\n            statusRef.set(status);\n          }\n        }, VcsBundle.message(\"patch.apply.command\"), null);\n      }\n    });\n    return statusRef.get();\n  }","id":104058,"modified_method":"public static ApplyPatchStatus applyPatch(final Project project, final List<FilePatch> patches, final VirtualFile baseDirectory,\n                                            final int stripLeadingDirectories, final boolean createDirectories) {\n    List<VirtualFile> filesToMakeWritable = new ArrayList<VirtualFile>();\n    for(FilePatch patch: patches) {\n      VirtualFile fileToPatch = patch.findFileToPatch(baseDirectory, stripLeadingDirectories, false);\n      if (fileToPatch != null && !fileToPatch.isDirectory()) {\n        filesToMakeWritable.add(fileToPatch);\n        FileType fileType = fileToPatch.getFileType();\n        if (fileType == StdFileTypes.UNKNOWN) {\n          fileType = FileTypeChooser.associateFileType(fileToPatch.getPresentableName());\n          if (fileType == null) {\n            return ApplyPatchStatus.FAILURE;\n          }\n        }\n      }\n    }\n    final VirtualFile[] fileArray = filesToMakeWritable.toArray(new VirtualFile[filesToMakeWritable.size()]);\n    final ReadonlyStatusHandler.OperationStatus readonlyStatus = ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(fileArray);\n    if (readonlyStatus.hasReadonlyFiles()) {\n      return ApplyPatchStatus.FAILURE;\n    }\n    final Ref<ApplyPatchStatus> statusRef = new Ref<ApplyPatchStatus>();\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          public void run() {\n            ApplyPatchStatus status = null;\n            for(FilePatch patch: patches) {\n              final ApplyPatchStatus patchStatus = applySinglePatch(project, patch, baseDirectory, stripLeadingDirectories, createDirectories);\n              status = ApplyPatchStatus.and(status, patchStatus);\n            }\n            if (status == ApplyPatchStatus.ALREADY_APPLIED) {\n              Messages.showInfoMessage(project, VcsBundle.message(\"patch.apply.already.applied\"),\n                                       VcsBundle.message(\"patch.apply.dialog.title\"));\n            }\n            else if (status == ApplyPatchStatus.PARTIAL) {\n              Messages.showInfoMessage(project, VcsBundle.message(\"patch.apply.partially.applied\"),\n                                       VcsBundle.message(\"patch.apply.dialog.title\"));\n            }\n            statusRef.set(status);\n          }\n        }, VcsBundle.message(\"patch.apply.command\"), null);\n      }\n    });\n    return statusRef.get();\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void autoDetectBaseDirectory() {\n    for(FilePatch patch: myPatches) {\n      VirtualFile baseDir = myDetectedBaseDirectory == null\n                            ? getBaseDirectory()\n                            : LocalFileSystem.getInstance().findFileByPath(myDetectedBaseDirectory.replace(File.separatorChar, '/'));\n      int skipTopDirs = myDetectedStripLeadingDirs >= 0 ? myDetectedStripLeadingDirs : 0;\n      VirtualFile fileToPatch = patch.findFileToPatch(baseDir, skipTopDirs);\n      if (fileToPatch == null) {\n        String oldDetectedBaseDirectory = myDetectedBaseDirectory;\n        int oldDetectedStripLeadingDirs = myDetectedStripLeadingDirs;\n        boolean success = detectDirectoryByName(patch.getBeforeName());\n        if (!success) {\n          success = detectDirectoryByName(patch.getAfterName());\n        }\n        if (success) {\n          if ((oldDetectedBaseDirectory != null && !Comparing.equal(oldDetectedBaseDirectory, myDetectedBaseDirectory)) ||\n              (oldDetectedStripLeadingDirs >= 0 && oldDetectedStripLeadingDirs != myDetectedStripLeadingDirs)) {\n            myDetectedBaseDirectory = null;\n            myDetectedStripLeadingDirs = -1;\n            break;\n          }\n        }\n      }\n    }\n  }","id":104059,"modified_method":"private void autoDetectBaseDirectory() {\n    for(FilePatch patch: myPatches) {\n      VirtualFile baseDir = myDetectedBaseDirectory == null\n                            ? getBaseDirectory()\n                            : LocalFileSystem.getInstance().findFileByPath(myDetectedBaseDirectory.replace(File.separatorChar, '/'));\n      int skipTopDirs = myDetectedStripLeadingDirs >= 0 ? myDetectedStripLeadingDirs : 0;\n      VirtualFile fileToPatch = patch.findFileToPatch(baseDir, skipTopDirs, false);\n      if (fileToPatch == null) {\n        String oldDetectedBaseDirectory = myDetectedBaseDirectory;\n        int oldDetectedStripLeadingDirs = myDetectedStripLeadingDirs;\n        boolean success = detectDirectoryByName(patch.getBeforeName());\n        if (!success) {\n          success = detectDirectoryByName(patch.getAfterName());\n        }\n        if (success) {\n          if ((oldDetectedBaseDirectory != null && !Comparing.equal(oldDetectedBaseDirectory, myDetectedBaseDirectory)) ||\n              (oldDetectedStripLeadingDirs >= 0 && oldDetectedStripLeadingDirs != myDetectedStripLeadingDirs)) {\n            myDetectedBaseDirectory = null;\n            myDetectedStripLeadingDirs = -1;\n            break;\n          }\n        }\n      }\n    }\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ApplyPatchStatus apply(final VirtualFile patchedDir, final int skipTopDirs) throws ApplyPatchException, IOException {\n    VirtualFile fileToPatch = findFileToPatch(patchedDir, skipTopDirs);\n\n    if (fileToPatch == null) {\n      throw new ApplyPatchException(\"Cannot find file to patch: \" + myBeforeName);\n    }\n\n    return apply(fileToPatch);\n  }","id":104060,"modified_method":"public ApplyPatchStatus apply(final VirtualFile patchedDir, final int skipTopDirs) throws ApplyPatchException, IOException {\n    VirtualFile fileToPatch = findFileToPatch(patchedDir, skipTopDirs, false);\n\n    if (fileToPatch == null) {\n      throw new ApplyPatchException(\"Cannot find file to patch: \" + myBeforeName);\n    }\n\n    return apply(fileToPatch);\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile findFileToPatchByName(@NotNull final VirtualFile patchedDir, final int skipTopDirs, final String fileName) {\n    String[] pathNameComponents = fileName.split(\"/\");\n    VirtualFile fileToPatch = patchedDir;\n    int lastComponentToFind = isNewFile() ? pathNameComponents.length-1 : pathNameComponents.length;\n    for(int i=skipTopDirs; i<lastComponentToFind; i++) {\n      fileToPatch = fileToPatch.findChild(pathNameComponents [i]);\n      if (fileToPatch == null) {\n        break;\n      }\n    }\n    return fileToPatch;\n  }","id":104061,"modified_method":"@Nullable\n  private VirtualFile findFileToPatchByName(@NotNull final VirtualFile patchedDir, final int skipTopDirs, final String fileName,\n                                            final boolean createDirectories) {\n    String[] pathNameComponents = fileName.split(\"/\");\n    VirtualFile fileToPatch = patchedDir;\n    int lastComponentToFind = isNewFile() ? pathNameComponents.length-1 : pathNameComponents.length;\n    for(int i=skipTopDirs; i<lastComponentToFind; i++) {\n      VirtualFile nextChild = fileToPatch.findChild(pathNameComponents [i]);\n      if (nextChild == null) {\n        if (createDirectories) {\n          try {\n            nextChild = fileToPatch.createChildDirectory(this, pathNameComponents [i]);\n          }\n          catch (IOException e) {\n            return null;\n          }\n        }\n        else {\n          return null;\n        }\n      }\n      fileToPatch = nextChild;\n    }\n    return fileToPatch;\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ApplyPatchStatus apply(final VirtualFile fileToPatch) throws IOException, ApplyPatchException {\n    if (isNewFile()) {\n      if (fileToPatch.findChild(getBeforeFileName()) != null) {\n        throw new ApplyPatchException(\"File \" + getBeforeFileName() + \" already exists\");\n      }\n      VirtualFile newFile = fileToPatch.createChildData(this, getBeforeFileName());\n      final Document document = FileDocumentManager.getInstance().getDocument(newFile);\n      document.setText(myHunks.get(0).getText());\n      FileDocumentManager.getInstance().saveDocument(document);\n    }\n    else if (isDeletedFile()) {\n      fileToPatch.delete(this);\n    }\n    else {\n      byte[] fileContents = fileToPatch.contentsToByteArray();\n      CharSequence text = LoadTextUtil.getTextByBinaryPresentation(fileContents, fileToPatch);\n      StringBuilder newText = new StringBuilder();\n      ApplyPatchStatus status = applyModifications(text, newText);\n      if (status != ApplyPatchStatus.ALREADY_APPLIED) {\n        final Document document = FileDocumentManager.getInstance().getDocument(fileToPatch);\n        document.setText(newText.toString());\n        FileDocumentManager.getInstance().saveDocument(document);\n      }\n      return status;\n    }\n    return ApplyPatchStatus.SUCCESS;\n  }","id":104062,"modified_method":"public ApplyPatchStatus apply(final VirtualFile fileToPatch) throws IOException, ApplyPatchException {\n    if (isNewFile()) {\n      if (fileToPatch.findChild(getBeforeFileName()) != null) {\n        throw new ApplyPatchException(\"File \" + getBeforeFileName() + \" already exists\");\n      }\n      VirtualFile newFile = fileToPatch.createChildData(this, getBeforeFileName());\n      final Document document = FileDocumentManager.getInstance().getDocument(newFile);\n      document.setText(getNewFileText());\n      FileDocumentManager.getInstance().saveDocument(document);\n    }\n    else if (isDeletedFile()) {\n      fileToPatch.delete(this);\n    }\n    else {\n      byte[] fileContents = fileToPatch.contentsToByteArray();\n      CharSequence text = LoadTextUtil.getTextByBinaryPresentation(fileContents, fileToPatch);\n      StringBuilder newText = new StringBuilder();\n      ApplyPatchStatus status = applyModifications(text, newText);\n      if (status != ApplyPatchStatus.ALREADY_APPLIED) {\n        final Document document = FileDocumentManager.getInstance().getDocument(fileToPatch);\n        document.setText(newText.toString());\n        FileDocumentManager.getInstance().saveDocument(document);\n      }\n      return status;\n    }\n    return ApplyPatchStatus.SUCCESS;\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public VirtualFile findFileToPatch(@NotNull final VirtualFile patchedDir, final int skipTopDirs) {\n    VirtualFile file = findFileToPatchByName(patchedDir, skipTopDirs, myBeforeName);\n    if (file == null) {\n      file = findFileToPatchByName(patchedDir, skipTopDirs, myAfterName);\n    }\n    return file;\n  }","id":104063,"modified_method":"@Nullable\n  public VirtualFile findFileToPatch(@NotNull final VirtualFile patchedDir, final int skipTopDirs, final boolean createDirectories) {\n    VirtualFile file = findFileToPatchByName(patchedDir, skipTopDirs, myBeforeName, createDirectories);\n    if (file == null) {\n      file = findFileToPatchByName(patchedDir, skipTopDirs, myAfterName, createDirectories);\n    }\n    return file;\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      try {\n        ShelveChangesManager.getInstance(myProject).shelveChanges(changes, commitMessage);\n      }\n      catch (final IOException ex) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL);\n      }\n    }","id":104064,"modified_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      if (changes.size() > 0 && !ChangesUtil.hasFileChanges(changes)) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"shelve.changes.only.directories\"), VcsBundle.message(\"shelve.changes.action\"));\n          }\n        });\n        return;\n      }\n      try {\n        ShelveChangesManager.getInstance(myProject).shelveChanges(changes, commitMessage);\n      }\n      catch (final IOException ex) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL);\n      }\n    }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unshelveChangeList(final ShelvedChangeList change) {\n    try {\n      List<FilePatch> patches = loadPatches(change.PATH);\n      VirtualFile baseDir = myProject.getProjectFile().getParent();\n      if (ApplyPatchAction.applyPatch(myProject, patches, baseDir, 0) == ApplyPatchStatus.FAILURE) {\n        return;\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      return;\n    }\n    catch (PatchSyntaxException e) {\n      LOG.error(e);\n      return;\n    }\n    deleteChangeList(change);\n  }","id":104065,"modified_method":"public void unshelveChangeList(final ShelvedChangeList change) {\n    try {\n      List<FilePatch> patches = loadPatches(change.PATH);\n      VirtualFile baseDir = myProject.getProjectFile().getParent();\n      if (ApplyPatchAction.applyPatch(myProject, patches, baseDir, 0, true) == ApplyPatchStatus.FAILURE) {\n        return;\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      return;\n    }\n    catch (PatchSyntaxException e) {\n      LOG.error(e);\n      return;\n    }\n    deleteChangeList(change);\n  }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public String getContent() {\n      final Document doc = FileDocumentManager.getInstance().getDocument(myFilePath.getVirtualFile());\n      String baseContent = doc.getText();\n\n      try {\n        List<FilePatch> filePatches = ShelveChangesManager.loadPatches(myPatchPath);\n        for(FilePatch patch: filePatches) {\n          if (myPatchedFilePath.equals(patch.getBeforeName())) {\n            StringBuilder newText = new StringBuilder();\n            patch.applyModifications(baseContent, newText);\n            return newText.toString();\n          }\n        }\n      }\n      catch (Exception e) {\n        return null;\n      }\n\n      return null;\n    }","id":104066,"modified_method":"@Nullable\n    public String getContent() {\n      try {\n        List<FilePatch> filePatches = ShelveChangesManager.loadPatches(myPatchPath);\n        for(FilePatch patch: filePatches) {\n          if (myPatchedFilePath.equals(patch.getBeforeName())) {\n            if (patch.isNewFile()) {\n              return patch.getNewFileText();\n            }\n            if (patch.isDeletedFile()) {\n              return null;\n            }\n            StringBuilder newText = new StringBuilder();\n            patch.applyModifications(getBaseContent(), newText);\n            return newText.toString();\n          }\n        }\n      }\n      catch (Exception e) {\n        return null;\n      }\n\n      return null;\n    }","commit_id":"f2c28ff8b4fc125bc5eb12c7d384dee7ebb39797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"FieldDefinitionImpl{\");\n        sb.append(\"index=\").append(index);\n        sb.append(\", fieldName='\").append(fieldName).append('\\'');\n        sb.append(\", type=\").append(type);\n        sb.append(\", classId=\").append(classId);\n        sb.append(\", factoryId='\").append(factoryId).append('\\'');\n        sb.append('}');\n        return sb.toString();\n    }","id":104067,"modified_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"FieldDefinitionImpl{\");\n        sb.append(\"index=\").append(index);\n        sb.append(\", fieldName='\").append(fieldName).append('\\'');\n        sb.append(\", type=\").append(type);\n        sb.append(\", classId=\").append(classId);\n        sb.append(\", factoryId=\").append(factoryId);\n        sb.append('}');\n        return sb.toString();\n    }","commit_id":"93158415952eda37e0db8b42fd829d3c5d1f5705","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Portable read(ObjectDataInput in) throws IOException {\n        if (!(in instanceof BufferObjectDataInput)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of BufferObjectDataInput!\");\n        }\n        if (!(in instanceof PortableContextAwareInputStream)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of PortableContextAwareInputStream!\");\n        }\n        final PortableContextAwareInputStream ctxIn = (PortableContextAwareInputStream) in;\n        final int factoryId = ctxIn.getFactoryId();\n        final int dataClassId = ctxIn.getClassId();\n        final int dataVersion = ctxIn.getVersion();\n\n        final PortableFactory portableFactory = factories.get(factoryId);\n        if (portableFactory == null) {\n            throw new HazelcastSerializationException(\"Could not find PortableFactory for factory-id: \" + factoryId);\n        }\n        final Portable portable = portableFactory.create(dataClassId);\n        if (portable == null) {\n            throw new HazelcastSerializationException(\"Could not create Portable for class-id: \" + dataClassId);\n        }\n        final DefaultPortableReader reader;\n        final ClassDefinition cd;\n        final BufferObjectDataInput bufferedIn = (BufferObjectDataInput) in;\n        if (context.getVersion() == dataVersion) {\n            cd = context.lookup(factoryId, dataClassId); // using context.version\n            reader = new DefaultPortableReader(this, bufferedIn, cd);\n        } else {\n            cd = context.lookup(factoryId, dataClassId, dataVersion); // registered during read\n            reader = new MorphingPortableReader(this, bufferedIn, cd);\n        }\n        portable.readPortable(reader);\n        reader.end();\n        return portable;\n    }","id":104068,"modified_method":"public Portable read(ObjectDataInput in) throws IOException {\n        if (!(in instanceof BufferObjectDataInput)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of BufferObjectDataInput!\");\n        }\n        if (!(in instanceof PortableContextAwareInputStream)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of PortableContextAwareInputStream!\");\n        }\n        final PortableContextAwareInputStream ctxIn = (PortableContextAwareInputStream) in;\n        final int factoryId = ctxIn.getFactoryId();\n        final int dataClassId = ctxIn.getClassId();\n        final int dataVersion = ctxIn.getVersion();\n\n        final PortableFactory portableFactory = factories.get(factoryId);\n        if (portableFactory == null) {\n            throw new HazelcastSerializationException(\"Could not find PortableFactory for factory-id: \" + factoryId);\n        }\n        final Portable portable = portableFactory.create(dataClassId);\n        if (portable == null) {\n            throw new HazelcastSerializationException(\"Could not create Portable for class-id: \" + dataClassId);\n        }\n        final DefaultPortableReader reader;\n        final ClassDefinition cd;\n        final BufferObjectDataInput bufferedIn = (BufferObjectDataInput) in;\n        if (context.getVersion() == dataVersion) {\n            cd = context.lookup(factoryId, dataClassId); // using context.version\n            if (cd == null) {\n                throw new HazelcastSerializationException(\"Could not find class-definition for \" +\n                        \"factory-id: \" + factoryId + \", class-id: \" + dataClassId + \", version: \" + dataVersion);\n            }\n            reader = new DefaultPortableReader(this, bufferedIn, cd);\n        } else {\n            cd = context.lookup(factoryId, dataClassId, dataVersion); // registered during read\n            if (cd == null) {\n                throw new HazelcastSerializationException(\"Could not find class-definition for \" +\n                        \"factory-id: \" + factoryId + \", class-id: \" + dataClassId + \", version: \" + dataVersion);\n            }\n            reader = new MorphingPortableReader(this, bufferedIn, cd);\n        }\n        portable.readPortable(reader);\n        reader.end();\n        return portable;\n    }","commit_id":"93158415952eda37e0db8b42fd829d3c5d1f5705","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {\n            if (compressedBinary == null || compressedBinary.length == 0) {\n                throw new IOException(\"Illegal class-definition binary! \");\n            }\n            final BufferObjectDataOutput out = serializationService.pop();\n            final byte[] binary;\n            try {\n                decompress(compressedBinary, out);\n                binary = out.toByteArray();\n            } finally {\n                serializationService.push(out);\n            }\n            final ClassDefinitionImpl cd = new ClassDefinitionImpl();\n            cd.readData(serializationService.createObjectDataInput(binary));\n            cd.setBinary(compressedBinary);\n            final ClassDefinitionImpl currentCD = versionedDefinitions.putIfAbsent(combineToLong(cd.classId, getVersion()), cd);\n            if (currentCD == null) {\n                registerNestedDefinitions(cd);\n                return cd;\n            } else {\n                return currentCD;\n            }\n        }","id":104069,"modified_method":"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {\n            if (compressedBinary == null || compressedBinary.length == 0) {\n                throw new IOException(\"Illegal class-definition binary! \");\n            }\n            final BufferObjectDataOutput out = serializationService.pop();\n            final byte[] binary;\n            try {\n                decompress(compressedBinary, out);\n                binary = out.toByteArray();\n            } finally {\n                serializationService.push(out);\n            }\n            final ClassDefinitionImpl cd = new ClassDefinitionImpl();\n            cd.readData(serializationService.createObjectDataInput(binary));\n            cd.setBinary(compressedBinary);\n            registerNestedDefinitions(cd);\n            final ClassDefinitionImpl currentCd = versionedDefinitions.putIfAbsent(combineToLong(cd.classId, getVersion()), cd);\n            return currentCd == null ? cd : currentCd;\n        }","commit_id":"93158415952eda37e0db8b42fd829d3c5d1f5705","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ClassDefinition registerClassDefinition(ClassDefinition cd) {\n            if (cd == null) return null;\n            final ClassDefinitionImpl cdImpl = (ClassDefinitionImpl) cd;\n            if (cdImpl.getVersion() < 0) {\n                cdImpl.version = getVersion();\n            }\n            if (cdImpl.getBinary() == null) {\n                final BufferObjectDataOutput out = serializationService.pop();\n                try {\n                    cdImpl.writeData(out);\n                    final byte[] binary = out.toByteArray();\n                    out.clear();\n                    compress(binary, out);\n                    cdImpl.setBinary(out.toByteArray());\n                } catch (IOException e) {\n                    throw new HazelcastSerializationException(e);\n                } finally {\n                    serializationService.push(out);\n                }\n            }\n            final long versionedClassId = combineToLong(cdImpl.getClassId(), cdImpl.getVersion());\n            final ClassDefinitionImpl currentClassDef = versionedDefinitions.putIfAbsent(versionedClassId, cdImpl);\n            if (currentClassDef == null) {\n                registerNestedDefinitions(cdImpl);\n                return cd;\n            }\n            return currentClassDef;\n        }","id":104070,"modified_method":"ClassDefinition registerClassDefinition(ClassDefinition cd) {\n            if (cd == null) return null;\n            final ClassDefinitionImpl cdImpl = (ClassDefinitionImpl) cd;\n            if (cdImpl.getVersion() < 0) {\n                cdImpl.version = getVersion();\n            }\n            if (cdImpl.getBinary() == null) {\n                final BufferObjectDataOutput out = serializationService.pop();\n                try {\n                    cdImpl.writeData(out);\n                    final byte[] binary = out.toByteArray();\n                    out.clear();\n                    compress(binary, out);\n                    cdImpl.setBinary(out.toByteArray());\n                } catch (IOException e) {\n                    throw new HazelcastSerializationException(e);\n                } finally {\n                    serializationService.push(out);\n                }\n            }\n            final long versionedClassId = combineToLong(cdImpl.getClassId(), cdImpl.getVersion());\n            registerNestedDefinitions(cdImpl);\n            final ClassDefinitionImpl currentCd = versionedDefinitions.putIfAbsent(versionedClassId, cdImpl);\n            return currentCd == null ? cdImpl : currentCd;\n        }","commit_id":"93158415952eda37e0db8b42fd829d3c5d1f5705","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"FieldDefinitionImpl{\");\n        sb.append(\"index=\").append(index);\n        sb.append(\", fieldName='\").append(fieldName).append('\\'');\n        sb.append(\", type=\").append(type);\n        sb.append(\", classId=\").append(classId);\n        sb.append(\", factoryId='\").append(factoryId).append('\\'');\n        sb.append('}');\n        return sb.toString();\n    }","id":104071,"modified_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"FieldDefinitionImpl{\");\n        sb.append(\"index=\").append(index);\n        sb.append(\", fieldName='\").append(fieldName).append('\\'');\n        sb.append(\", type=\").append(type);\n        sb.append(\", classId=\").append(classId);\n        sb.append(\", factoryId=\").append(factoryId);\n        sb.append('}');\n        return sb.toString();\n    }","commit_id":"75bb19706f8e722db2bb868083bb62d51314e834","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Portable read(ObjectDataInput in) throws IOException {\n        if (!(in instanceof BufferObjectDataInput)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of BufferObjectDataInput!\");\n        }\n        if (!(in instanceof PortableContextAwareInputStream)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of PortableContextAwareInputStream!\");\n        }\n        final PortableContextAwareInputStream ctxIn = (PortableContextAwareInputStream) in;\n        final int factoryId = ctxIn.getFactoryId();\n        final int dataClassId = ctxIn.getClassId();\n        final int dataVersion = ctxIn.getVersion();\n\n        final PortableFactory portableFactory = factories.get(factoryId);\n        if (portableFactory == null) {\n            throw new HazelcastSerializationException(\"Could not find PortableFactory for factory-id: \" + factoryId);\n        }\n        final Portable portable = portableFactory.create(dataClassId);\n        if (portable == null) {\n            throw new HazelcastSerializationException(\"Could not create Portable for class-id: \" + dataClassId);\n        }\n        final DefaultPortableReader reader;\n        final ClassDefinition cd;\n        final BufferObjectDataInput bufferedIn = (BufferObjectDataInput) in;\n        if (context.getVersion() == dataVersion) {\n            cd = context.lookup(factoryId, dataClassId); // using context.version\n            reader = new DefaultPortableReader(this, bufferedIn, cd);\n        } else {\n            cd = context.lookup(factoryId, dataClassId, dataVersion); // registered during read\n            reader = new MorphingPortableReader(this, bufferedIn, cd);\n        }\n        portable.readPortable(reader);\n        reader.end();\n        return portable;\n    }","id":104072,"modified_method":"public Portable read(ObjectDataInput in) throws IOException {\n        if (!(in instanceof BufferObjectDataInput)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of BufferObjectDataInput!\");\n        }\n        if (!(in instanceof PortableContextAwareInputStream)) {\n            throw new IllegalArgumentException(\"ObjectDataInput must be instance of PortableContextAwareInputStream!\");\n        }\n        final PortableContextAwareInputStream ctxIn = (PortableContextAwareInputStream) in;\n        final int factoryId = ctxIn.getFactoryId();\n        final int dataClassId = ctxIn.getClassId();\n        final int dataVersion = ctxIn.getVersion();\n\n        final PortableFactory portableFactory = factories.get(factoryId);\n        if (portableFactory == null) {\n            throw new HazelcastSerializationException(\"Could not find PortableFactory for factory-id: \" + factoryId);\n        }\n        final Portable portable = portableFactory.create(dataClassId);\n        if (portable == null) {\n            throw new HazelcastSerializationException(\"Could not create Portable for class-id: \" + dataClassId);\n        }\n        final DefaultPortableReader reader;\n        final ClassDefinition cd;\n        final BufferObjectDataInput bufferedIn = (BufferObjectDataInput) in;\n        if (context.getVersion() == dataVersion) {\n            cd = context.lookup(factoryId, dataClassId); // using context.version\n            if (cd == null) {\n                throw new HazelcastSerializationException(\"Could not find class-definition for \" +\n                        \"factory-id: \" + factoryId + \", class-id: \" + dataClassId + \", version: \" + dataVersion);\n            }\n            reader = new DefaultPortableReader(this, bufferedIn, cd);\n        } else {\n            cd = context.lookup(factoryId, dataClassId, dataVersion); // registered during read\n            if (cd == null) {\n                throw new HazelcastSerializationException(\"Could not find class-definition for \" +\n                        \"factory-id: \" + factoryId + \", class-id: \" + dataClassId + \", version: \" + dataVersion);\n            }\n            reader = new MorphingPortableReader(this, bufferedIn, cd);\n        }\n        portable.readPortable(reader);\n        reader.end();\n        return portable;\n    }","commit_id":"75bb19706f8e722db2bb868083bb62d51314e834","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {\n            if (compressedBinary == null || compressedBinary.length == 0) {\n                throw new IOException(\"Illegal class-definition binary! \");\n            }\n            final BufferObjectDataOutput out = serializationService.pop();\n            final byte[] binary;\n            try {\n                decompress(compressedBinary, out);\n                binary = out.toByteArray();\n            } finally {\n                serializationService.push(out);\n            }\n            final ClassDefinitionImpl cd = new ClassDefinitionImpl();\n            cd.readData(serializationService.createObjectDataInput(binary));\n            cd.setBinary(compressedBinary);\n            final ClassDefinitionImpl currentCD = versionedDefinitions.putIfAbsent(combineToLong(cd.classId, getVersion()), cd);\n            if (currentCD == null) {\n                registerNestedDefinitions(cd);\n                return cd;\n            } else {\n                return currentCD;\n            }\n        }","id":104073,"modified_method":"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {\n            if (compressedBinary == null || compressedBinary.length == 0) {\n                throw new IOException(\"Illegal class-definition binary! \");\n            }\n            final BufferObjectDataOutput out = serializationService.pop();\n            final byte[] binary;\n            try {\n                decompress(compressedBinary, out);\n                binary = out.toByteArray();\n            } finally {\n                serializationService.push(out);\n            }\n            final ClassDefinitionImpl cd = new ClassDefinitionImpl();\n            cd.readData(serializationService.createObjectDataInput(binary));\n            cd.setBinary(compressedBinary);\n            registerNestedDefinitions(cd);\n            final ClassDefinitionImpl currentCd = versionedDefinitions.putIfAbsent(combineToLong(cd.classId, getVersion()), cd);\n            return currentCd == null ? cd : currentCd;\n        }","commit_id":"75bb19706f8e722db2bb868083bb62d51314e834","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ClassDefinition registerClassDefinition(ClassDefinition cd) {\n            if (cd == null) return null;\n            final ClassDefinitionImpl cdImpl = (ClassDefinitionImpl) cd;\n            if (cdImpl.getVersion() < 0) {\n                cdImpl.version = getVersion();\n            }\n            if (cdImpl.getBinary() == null) {\n                final BufferObjectDataOutput out = serializationService.pop();\n                try {\n                    cdImpl.writeData(out);\n                    final byte[] binary = out.toByteArray();\n                    out.clear();\n                    compress(binary, out);\n                    cdImpl.setBinary(out.toByteArray());\n                } catch (IOException e) {\n                    throw new HazelcastSerializationException(e);\n                } finally {\n                    serializationService.push(out);\n                }\n            }\n            final long versionedClassId = combineToLong(cdImpl.getClassId(), cdImpl.getVersion());\n            final ClassDefinitionImpl currentClassDef = versionedDefinitions.putIfAbsent(versionedClassId, cdImpl);\n            if (currentClassDef == null) {\n                registerNestedDefinitions(cdImpl);\n                return cd;\n            }\n            return currentClassDef;\n        }","id":104074,"modified_method":"ClassDefinition registerClassDefinition(ClassDefinition cd) {\n            if (cd == null) return null;\n            final ClassDefinitionImpl cdImpl = (ClassDefinitionImpl) cd;\n            if (cdImpl.getVersion() < 0) {\n                cdImpl.version = getVersion();\n            }\n            if (cdImpl.getBinary() == null) {\n                final BufferObjectDataOutput out = serializationService.pop();\n                try {\n                    cdImpl.writeData(out);\n                    final byte[] binary = out.toByteArray();\n                    out.clear();\n                    compress(binary, out);\n                    cdImpl.setBinary(out.toByteArray());\n                } catch (IOException e) {\n                    throw new HazelcastSerializationException(e);\n                } finally {\n                    serializationService.push(out);\n                }\n            }\n            final long versionedClassId = combineToLong(cdImpl.getClassId(), cdImpl.getVersion());\n            registerNestedDefinitions(cdImpl);\n            final ClassDefinitionImpl currentCd = versionedDefinitions.putIfAbsent(versionedClassId, cdImpl);\n            return currentCd == null ? cdImpl : currentCd;\n        }","commit_id":"75bb19706f8e722db2bb868083bb62d51314e834","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected AbstractModuleComponentResolveMetadata(MutableModuleComponentResolveMetadata metadata) {\n        this.descriptor = metadata.getDescriptor();\n        this.componentIdentifier = metadata.getComponentId();\n        this.moduleVersionIdentifier = metadata.getId();\n        changing = metadata.isChanging();\n        status = metadata.getStatus();\n        statusScheme = metadata.getStatusScheme();\n        moduleSource = metadata.getSource();\n        dependencies = metadata.getDependencies();\n        excludes = descriptor.getExcludes();\n        configurations = populateConfigurationsFromDescriptor(descriptor);\n        artifacts = metadata.getArtifacts();\n        if (artifacts != null) {\n            artifactsByConfig = populateArtifacts(artifacts);\n        } else {\n            artifactsByConfig = populateArtifactsFromDescriptor(componentIdentifier, descriptor);\n        }\n    }","id":104075,"modified_method":"protected AbstractModuleComponentResolveMetadata(MutableModuleComponentResolveMetadata metadata) {\n        this.descriptor = metadata.getDescriptor();\n        this.componentIdentifier = metadata.getComponentId();\n        this.moduleVersionIdentifier = metadata.getId();\n        changing = metadata.isChanging();\n        status = metadata.getStatus();\n        statusScheme = metadata.getStatusScheme();\n        moduleSource = metadata.getSource();\n        dependencies = metadata.getDependencies();\n        excludes = descriptor.getExcludes();\n        artifacts = metadata.getArtifacts();\n        configurations = populateConfigurationsFromDescriptor(descriptor);\n        if (artifacts != null) {\n            populateArtifacts(artifacts);\n        } else {\n            populateArtifactsFromDescriptor(componentIdentifier, descriptor);\n        }\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"private Multimap<String, ModuleComponentArtifactMetadata> populateArtifacts(Iterable<? extends ModuleComponentArtifactMetadata> artifacts) {\n        Multimap<String, ModuleComponentArtifactMetadata> artifactsByConfig = LinkedHashMultimap.create();\n        for (String config : getConfigurationNames()) {\n            artifactsByConfig.putAll(config, artifacts);\n        }\n        return artifactsByConfig;\n    }","id":104076,"modified_method":"private void populateArtifacts(List<ModuleComponentArtifactMetadata> artifacts) {\n        for (DefaultConfigurationMetadata configuration : configurations.values()) {\n            configuration.artifacts.addAll(artifacts);\n        }\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"private void populateExcludeRulesFromDescriptor() {\n            configExcludes = new LinkedHashSet<Exclude>();\n            Set<String> hierarchy = getHierarchy();\n            for (Exclude exclude : excludes) {\n                for (String config : exclude.getConfigurations()) {\n                    if (hierarchy.contains(config)) {\n                        configExcludes.add(exclude);\n                        break;\n                    }\n                }\n            }\n        }","id":104077,"modified_method":"private Set<Exclude> populateExcludeRulesFromDescriptor() {\n            Set<Exclude> configExcludes = new LinkedHashSet<Exclude>();\n            Set<String> hierarchy = getHierarchy();\n            for (Exclude exclude : excludes) {\n                for (String config : exclude.getConfigurations()) {\n                    if (hierarchy.contains(config)) {\n                        configExcludes.add(exclude);\n                        break;\n                    }\n                }\n            }\n            return configExcludes;\n        }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<ComponentArtifactMetadata> getArtifacts() {\n            if (artifacts == null) {\n                artifacts = getArtifactsForConfiguration(this, new LinkedHashSet<ComponentArtifactMetadata>(), new HashSet<String>());\n            }\n            return artifacts;\n        }","id":104078,"modified_method":"public Set<ComponentArtifactMetadata> getArtifacts() {\n            return artifacts;\n        }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"private static Multimap<String, ModuleComponentArtifactMetadata> populateArtifactsFromDescriptor(ModuleComponentIdentifier componentId, ModuleDescriptorState descriptor) {\n        Multimap<String, ModuleComponentArtifactMetadata> artifactsByConfig = LinkedHashMultimap.create();\n        for (Artifact artifact : descriptor.getArtifacts()) {\n            ModuleComponentArtifactMetadata artifactMetadata = new DefaultModuleComponentArtifactMetadata(componentId, artifact.getArtifactName());\n            for (String configuration : artifact.getConfigurations()) {\n                artifactsByConfig.put(configuration, artifactMetadata);\n            }\n        }\n        return artifactsByConfig;\n    }","id":104079,"modified_method":"private void populateArtifactsFromDescriptor(ModuleComponentIdentifier componentId, ModuleDescriptorState descriptor) {\n        for (Artifact artifact : descriptor.getArtifacts()) {\n            ModuleComponentArtifactMetadata artifactMetadata = new DefaultModuleComponentArtifactMetadata(componentId, artifact.getArtifactName());\n            for (String configuration : artifact.getConfigurations()) {\n                configurations.get(configuration).artifacts.add(artifactMetadata);\n            }\n        }\n        Set<ConfigurationMetadata> visited = new HashSet<ConfigurationMetadata>();\n        for (DefaultConfigurationMetadata configuration : configurations.values()) {\n            configuration.collectInheritedArtifacts(visited);\n        }\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"protected AbstractModuleComponentResolveMetadata(ModuleComponentIdentifier componentIdentifier, ModuleVersionIdentifier moduleVersionIdentifier, ModuleDescriptorState moduleDescriptor) {\n        this.descriptor = moduleDescriptor;\n        this.componentIdentifier = componentIdentifier;\n        this.moduleVersionIdentifier = moduleVersionIdentifier;\n        status = moduleDescriptor.getStatus();\n        configurations = populateConfigurationsFromDescriptor(moduleDescriptor);\n        artifacts = null;\n        artifactsByConfig = populateArtifactsFromDescriptor(componentIdentifier, moduleDescriptor);\n        dependencies = Collections.emptyList();\n        excludes = moduleDescriptor.getExcludes();\n    }","id":104080,"modified_method":"protected AbstractModuleComponentResolveMetadata(ModuleComponentIdentifier componentIdentifier, ModuleVersionIdentifier moduleVersionIdentifier, ModuleDescriptorState moduleDescriptor) {\n        this.descriptor = moduleDescriptor;\n        this.componentIdentifier = componentIdentifier;\n        this.moduleVersionIdentifier = moduleVersionIdentifier;\n        changing = false;\n        moduleSource = null;\n        status = moduleDescriptor.getStatus();\n        statusScheme = DEFAULT_STATUS_SCHEME;\n        dependencies = Collections.emptyList();\n        artifacts = null;\n        excludes = moduleDescriptor.getExcludes();\n        configurations = populateConfigurationsFromDescriptor(moduleDescriptor);\n        populateArtifactsFromDescriptor(componentIdentifier, moduleDescriptor);\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"public List<DependencyMetadata> getDependencies() {\n            if (configDependencies == null) {\n                configDependencies = new ArrayList<DependencyMetadata>();\n                for (DependencyMetadata dependency : dependencies) {\n                    if (include(dependency)) {\n                        configDependencies.add(dependency);\n                    }\n                }\n            }\n            return configDependencies;\n        }","id":104081,"modified_method":"public List<DependencyMetadata> getDependencies() {\n            return configDependencies;\n        }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<Exclude> getExcludes() {\n            if (configExcludes == null) {\n                populateExcludeRulesFromDescriptor();\n            }\n            return configExcludes;\n        }","id":104082,"modified_method":"public Set<Exclude> getExcludes() {\n            return configExcludes;\n        }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"private DefaultConfigurationMetadata(String name, boolean transitive, boolean visible, List<DefaultConfigurationMetadata> parents) {\n            this.name = name;\n            this.parents = parents;\n            this.transitive = transitive;\n            this.visible = visible;\n        }","id":104083,"modified_method":"private DefaultConfigurationMetadata(String name, boolean transitive, boolean visible, List<DefaultConfigurationMetadata> parents) {\n            this.name = name;\n            this.parents = parents;\n            this.transitive = transitive;\n            this.visible = visible;\n            this.configDependencies = calculateDependencies();\n            this.configExcludes = populateExcludeRulesFromDescriptor();\n            this.artifacts = new LinkedHashSet<ComponentArtifactMetadata>();\n        }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public DefaultIvyModuleResolveMetadata withSource(ModuleSource source) {\n        return (DefaultIvyModuleResolveMetadata) super.withSource(source);\n    }","id":104084,"modified_method":"@Override\n    public DefaultIvyModuleResolveMetadata withSource(ModuleSource source) {\n        return new DefaultIvyModuleResolveMetadata(this, source);\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public DefaultMavenModuleResolveMetadata withSource(ModuleSource source) {\n        return (DefaultMavenModuleResolveMetadata) super.withSource(source);\n    }","id":104085,"modified_method":"@Override\n    public DefaultMavenModuleResolveMetadata withSource(ModuleSource source) {\n        return new DefaultMavenModuleResolveMetadata(this, source);\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultMavenModuleResolveMetadata(ModuleComponentIdentifier componentId, ModuleDescriptorState descriptor, String packaging, boolean relocated) {\n        this(componentId, DefaultModuleVersionIdentifier.newId(componentId), descriptor, packaging, relocated);\n    }","id":104086,"modified_method":"public DefaultMavenModuleResolveMetadata(ModuleComponentIdentifier componentId, ModuleDescriptorState descriptor, String packaging, boolean relocated) {\n        super(componentId, DefaultModuleVersionIdentifier.newId(componentId), descriptor);\n        this.packaging = packaging;\n        this.relocated = relocated;\n        this.snapshotTimestamp = null;\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"DefaultMavenModuleResolveMetadata(MutableMavenModuleResolveMetadata metadata) {\n        super(metadata);\n        this.packaging = metadata.getPackaging();\n        this.relocated = metadata.isRelocated();\n        this.snapshotTimestamp = metadata.getSnapshotTimestamp();\n    }","id":104087,"modified_method":"DefaultMavenModuleResolveMetadata(MutableMavenModuleResolveMetadata metadata) {\n        super(metadata);\n        packaging = metadata.getPackaging();\n        relocated = metadata.isRelocated();\n        snapshotTimestamp = metadata.getSnapshotTimestamp();\n    }","commit_id":"9f49bd448394b91ed43b8d81f60472d0aa48d010","url":"https://github.com/gradle/gradle"},{"original_method":"public AbstractModuleComponentResolveMetaData(ModuleVersionIdentifier moduleVersionIdentifier, ModuleDescriptor moduleDescriptor, ModuleComponentIdentifier componentIdentifier) {\n        super(moduleVersionIdentifier, moduleDescriptor, componentIdentifier);\n    }","id":104088,"modified_method":"public AbstractModuleComponentResolveMetaData(ModuleComponentIdentifier componentIdentifier, ModuleVersionIdentifier moduleVersionIdentifier, ModuleDescriptor moduleDescriptor) {\n        super(componentIdentifier, moduleVersionIdentifier, moduleDescriptor);\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"public void setComponentId(ComponentIdentifier componentIdentifier) {\n        this.componentIdentifier = componentIdentifier;\n    }","id":104089,"modified_method":"public void setComponentId(ModuleComponentIdentifier componentIdentifier) {\n        this.componentIdentifier = componentIdentifier;\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"public AbstractModuleDescriptorBackedMetaData(ModuleVersionIdentifier moduleVersionIdentifier, ModuleDescriptor moduleDescriptor, ComponentIdentifier componentIdentifier) {\n        this.moduleVersionIdentifier = moduleVersionIdentifier;\n        this.moduleDescriptor = moduleDescriptor;\n        this.componentIdentifier = componentIdentifier;\n        status = moduleDescriptor.getStatus();\n    }","id":104090,"modified_method":"public AbstractModuleDescriptorBackedMetaData(ModuleComponentIdentifier componentIdentifier, ModuleVersionIdentifier moduleVersionIdentifier, ModuleDescriptor moduleDescriptor) {\n        this.componentIdentifier = componentIdentifier;\n        this.moduleVersionIdentifier = moduleVersionIdentifier;\n        this.moduleDescriptor = moduleDescriptor;\n        status = moduleDescriptor.getStatus();\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"public BuildableIvyModuleResolveMetaData(DefaultModuleDescriptor module) {\n        super(module);\n        this.module = module;\n    }","id":104091,"modified_method":"public BuildableIvyModuleResolveMetaData(DefaultModuleDescriptor module) {\n        super(DefaultModuleComponentIdentifier.newId(module.getModuleRevisionId()), module);\n        this.module = module;\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultIvyModuleResolveMetaData(ModuleComponentIdentifier componentIdentifier, ModuleDescriptor moduleDescriptor) {\n        super(DefaultModuleVersionIdentifier.newId(componentIdentifier), moduleDescriptor, componentIdentifier);\n        this.extraInfo = moduleDescriptor.getExtraInfo();\n    }","id":104092,"modified_method":"public DefaultIvyModuleResolveMetaData(ModuleComponentIdentifier componentIdentifier, ModuleDescriptor moduleDescriptor) {\n        this(componentIdentifier, DefaultModuleVersionIdentifier.newId(componentIdentifier), moduleDescriptor);\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public DefaultIvyModuleResolveMetaData copy() {\n        // TODO:ADAM - need to make a copy of the descriptor (it's effectively immutable at this point so it's not a problem yet)\n        DefaultIvyModuleResolveMetaData copy = new DefaultIvyModuleResolveMetaData(getId(), getDescriptor(), getComponentId());\n        copyTo(copy);\n        return copy;\n    }","id":104093,"modified_method":"@Override\n    public DefaultIvyModuleResolveMetaData copy() {\n        // TODO:ADAM - need to make a copy of the descriptor (it's effectively immutable at this point so it's not a problem yet)\n        DefaultIvyModuleResolveMetaData copy = new DefaultIvyModuleResolveMetaData(getComponentId(), getId(), getDescriptor());\n        copyTo(copy);\n        return copy;\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"private DefaultIvyModuleResolveMetaData(ModuleVersionIdentifier identifier, ModuleDescriptor moduleDescriptor, ModuleComponentIdentifier componentIdentifier) {\n        super(identifier, moduleDescriptor, componentIdentifier);\n        this.extraInfo = moduleDescriptor.getExtraInfo();\n    }","id":104094,"modified_method":"private DefaultIvyModuleResolveMetaData(ModuleComponentIdentifier componentIdentifier, ModuleVersionIdentifier identifier, ModuleDescriptor moduleDescriptor) {\n        super(componentIdentifier, identifier, moduleDescriptor);\n        this.extraInfo = moduleDescriptor.getExtraInfo();\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultMavenModuleResolveMetaData(ModuleComponentIdentifier componentId, ModuleDescriptor descriptor, String packaging, boolean relocated) {\n        super(DefaultModuleVersionIdentifier.newId(componentId), descriptor, componentId);\n        this.packaging = packaging;\n        this.relocated = relocated;\n    }","id":104095,"modified_method":"public DefaultMavenModuleResolveMetaData(ModuleComponentIdentifier componentId, ModuleDescriptor descriptor, String packaging, boolean relocated) {\n        this(componentId, DefaultModuleVersionIdentifier.newId(componentId), descriptor, packaging, relocated);\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultMavenModuleResolveMetaData(ModuleDescriptor moduleDescriptor, String packaging, boolean relocated) {\n        super(moduleDescriptor);\n        this.packaging = packaging;\n        this.relocated = relocated;\n    }","id":104096,"modified_method":"public DefaultMavenModuleResolveMetaData(ModuleDescriptor moduleDescriptor, String packaging, boolean relocated) {\n        this(DefaultModuleComponentIdentifier.newId(moduleDescriptor.getModuleRevisionId()), moduleDescriptor, packaging, relocated);\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public DefaultMavenModuleResolveMetaData copy() {\n        // TODO:ADAM - need to make a copy of the descriptor (it's effectively immutable at this point so it's not a problem yet)\n        DefaultMavenModuleResolveMetaData copy = new DefaultMavenModuleResolveMetaData(getId(), getDescriptor(), getComponentId(), packaging, relocated);\n        copyTo(copy);\n        copy.snapshotTimestamp = snapshotTimestamp;\n        return copy;\n    }","id":104097,"modified_method":"@Override\n    public DefaultMavenModuleResolveMetaData copy() {\n        // TODO:ADAM - need to make a copy of the descriptor (it's effectively immutable at this point so it's not a problem yet)\n        DefaultMavenModuleResolveMetaData copy = new DefaultMavenModuleResolveMetaData(getComponentId(), getId(), getDescriptor(), packaging, relocated);\n        copyTo(copy);\n        copy.snapshotTimestamp = snapshotTimestamp;\n        return copy;\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"private DefaultMavenModuleResolveMetaData(ModuleVersionIdentifier id, ModuleDescriptor descriptor, ModuleComponentIdentifier componentId, String packaging, boolean relocated) {\n        super(id, descriptor, componentId);\n        this.packaging = packaging;\n        this.relocated = relocated;\n    }","id":104098,"modified_method":"private DefaultMavenModuleResolveMetaData(ModuleComponentIdentifier componentId, ModuleVersionIdentifier id, ModuleDescriptor descriptor, String packaging, boolean relocated) {\n        super(componentId, id, descriptor);\n        this.packaging = packaging;\n        this.relocated = relocated;\n    }","commit_id":"1d82d1363c1b90a9e335fab0228ad936a93ddee5","url":"https://github.com/gradle/gradle"},{"original_method":"/**A method for handling a LWC event*/\n    public void LWCChanged(LWCEvent e)\n    {\n        String message = e.getWhat();\n        \n        //old events\n        //if (message == LWKey.ChildAdded)\n        //  addHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n        //else if (message == LWKey.ChildRemoved)\n        //deleteHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n\n        // TODO: also needs to generally handle HierachyChanging events, which\n        // is all we get on undo's\n\n        try\n        {\n            if (message == LWKey.LinkAdded)\n            {\n                addHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n            }\n            else if (message == LWKey.LinkRemoved)\n            {\n                deleteHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n            }\n            else if (message == LWKey.ChildrenAdded)\n            {\n                ArrayList childrenList = e.getComponents();\n                for (Iterator i = childrenList.iterator(); i.hasNext();)\n                  addHierarchyTreeNode((LWContainer)e.getSource(), (LWComponent)i.next());\n            }\n            else if (message == LWKey.ChildrenRemoved)\n            {\n                ArrayList childrenList = e.getComponents();\n                for (Iterator i = childrenList.iterator(); i.hasNext();)\n                  deleteHierarchyTreeNode((LWContainer)e.getSource(), (LWComponent)i.next());\n            }\n            else if (message == LWKey.HierarchyChanged)\n            {   \n                LWContainer container = (LWContainer)e.getSource();  \n                System.out.println(\"the container it needs to change is \" + container.toString());\n                \n                ArrayList nodes = new ArrayList();\n                HierarchyNode rootNode = getRootNode();\n                \n                if (container instanceof LWMap)\n                {    \n                    //rootNode.setLWComponent(container);\n                    nodes.add(rootNode);\n                }\n                \n                nodes.addAll(findHierarchyNodeByComponentID(rootNode, container.getID()));\n                \n                for (Iterator i = nodes.iterator(); i.hasNext();)\n                { \n                    HierarchyNode hierarchyNode = (HierarchyNode)i.next();\n                    \n                    for (osid.hierarchy.NodeIterator ni = hierarchyNode.getChildren(); ni.hasNext();)\n                      deleteHierarchyNode((HierarchyNode)ni.next()); \n                    \n                    for (Iterator ci = container.getChildIterator(); ci.hasNext();)\n                    {\n                        LWComponent component = (LWComponent)ci.next();\n                        addHierarchyTreeNode(container, component);\n                    }\n                }\n                \n                System.err.println(this + \" needs to rebuild child list from scratch for \" + e.getSource());\n            }\n        }\n        \n        catch(osid.hierarchy.HierarchyException he)\n        {\n            System.err.println(he.getMessage());\n            he.printStackTrace();\n        }\n    }","id":104099,"modified_method":"/**A method for handling a LWC event*/\n    public void LWCChanged(LWCEvent e)\n    {\n        String message = e.getWhat();\n        \n        //old events\n        //if (message == LWKey.ChildAdded)\n        //  addHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n        //else if (message == LWKey.ChildRemoved)\n        //deleteHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n\n        // TODO: also needs to generally handle HierachyChanging events, which\n        // is all we get on undo's\n\n        try\n        {\n            if (message == LWKey.LinkAdded)\n            {\n                addHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n            }\n            else if (message == LWKey.LinkRemoved)\n            {\n                deleteHierarchyTreeNode((LWContainer)e.getSource(), e.getComponent());\n            }\n            else if (message == LWKey.ChildrenAdded)\n            {\n                ArrayList childrenList = e.getComponents();\n                for (Iterator i = childrenList.iterator(); i.hasNext();)\n                  addHierarchyTreeNode((LWContainer)e.getSource(), (LWComponent)i.next());\n            }\n            else if (message == LWKey.ChildrenRemoved)\n            {\n                ArrayList childrenList = e.getComponents();\n                for (Iterator i = childrenList.iterator(); i.hasNext();)\n                  deleteHierarchyTreeNode((LWContainer)e.getSource(), (LWComponent)i.next());\n            }\n            else if (message == LWKey.HierarchyChanged)\n            {   \n                LWContainer container = (LWContainer)e.getSource();  \n                System.out.println(\"the container it needs to change is \" + container.toString());\n                \n                ArrayList nodes = new ArrayList();\n                HierarchyNode rootNode = getRootNode();\n                \n                if (container instanceof LWMap)\n                {    \n                    //rootNode.setLWComponent(container);\n                    nodes.add(rootNode);\n                }\n                \n                nodes.addAll(findHierarchyNodeByComponentID(rootNode, container.getID()));\n                \n                for (Iterator i = nodes.iterator(); i.hasNext();)\n                { \n                    HierarchyNode hierarchyNode = (HierarchyNode)i.next();\n                    \n                    for (osid.hierarchy.NodeIterator ni = hierarchyNode.getChildren(); ni.hasNext();)\n                      deleteHierarchyNode((HierarchyNode)ni.next()); \n                    \n                    for (Iterator li = container.getLinks().iterator(); li.hasNext();)\n                    {\n                        LWLink link = (LWLink)li.next();       \n                        addHierarchyTreeNode(container, link);\n                    }\n                    \n                    for (Iterator ci = container.getChildIterator(); ci.hasNext();)\n                    {\n                        LWComponent component = (LWComponent)ci.next();\n                        addHierarchyTreeNode(container, component);\n                    }\n                }\n                \n                System.err.println(this + \" needs to rebuild child list from scratch for \" + e.getSource());\n            }\n        }\n        \n        catch(osid.hierarchy.HierarchyException he)\n        {\n            System.err.println(he.getMessage());\n            he.printStackTrace();\n        }\n    }","commit_id":"fa76de1f533135806a1fed7699c1e3fd4593b85a","url":"https://github.com/VUE/VUE"},{"original_method":"/** Deletes a hierarchy node.  Note that deletedChild may or may NOT be a proper\n     LWMap container hierarchy child -- for our purposes here, any connected LWLink\n    is a \"child\" as it is displayed as such in the outline views, but it is not a real\n    child of the parent.\n    */\n    public void deleteHierarchyTreeNode(LWContainer parent, LWComponent deletedChild) throws osid.hierarchy.HierarchyException\n    {    \n        //if it is a LWNode\n        if (deletedChild instanceof LWNode)\n        {\n            HierarchyNode parentNode = null, deletedChildNode = null;\n            \n            //finds the parent hierarchy node\n            if (parent instanceof LWMap)\n              parentNode = getRootNode();\n            \n            else\n              parentNode = findHierarchyNode(getRootNode(), parent, true);\n                \n            if (parentNode == null) \n            {\n                System.err.println(\"*** NULL parentNode when deleting a hierarchy node in OutlineViewHierarchyModel\");\n                // don't know what right thing to do here, but this exception\n                // was driving me crazy -- SMF 2003-11-13 18:19.04\n                return;\n            }\n            \n            //finds the tree node representing the deleted child\n            deletedChildNode = findHierarchyNode(parentNode, deletedChild, false);  \n                \n            //removes from the hierarch model\n            deleteHierarchyNode(deletedChildNode);\n            reloadTreeModel(parentNode);\n        }\n         \n        //if it is a LWLink\n        else if (deletedChild instanceof LWLink)\n        {\n            HierarchyNode linkedNode1 = null, linkedNode2 = null;\n            LWLink link = (LWLink)deletedChild;\n            \n            //gets two components the link connects to\n            LWComponent component1 = link.getComponent1();\n            LWComponent component2 = link.getComponent2();\n       \n            linkedNode1 = findHierarchyNode(getRootNode(), component1, true);\n            linkedNode2 = findHierarchyNode(getRootNode(), component2, true);\n                \n            //finds the hierarchy nodes associated with the two components and deletes the tree node representing the link to\n            //the two tree nodes\n            //must check to see if the parent wasn't deleted in the process\n            if (linkedNode1 != null)\n            {\n                HierarchyNode linkNode1 = findHierarchyNode(linkedNode1, link, false);\n                deleteHierarchyNode(linkNode1);\n                reloadTreeModel(linkedNode1);\n            }\n              \n            if (linkedNode2 != null)\n            {\n                HierarchyNode linkNode2 = findHierarchyNode(linkedNode2, link, false); \n                deleteHierarchyNode(linkNode2);\n                reloadTreeModel(linkedNode2);\n            }\n        }\n        \n        //validateHierarchyNodeLinkLabels();\n    }","id":104100,"modified_method":"/** Deletes a hierarchy node.  Note that deletedChild may or may NOT be a proper\n     LWMap container hierarchy child -- for our purposes here, any connected LWLink\n    is a \"child\" as it is displayed as such in the outline views, but it is not a real\n    child of the parent.\n    */\n    public void deleteHierarchyTreeNode(LWContainer parent, LWComponent deletedChild) throws osid.hierarchy.HierarchyException\n    {    \n        //if it is a LWNode\n        if (deletedChild instanceof LWNode)\n        {\n            HierarchyNode parentNode = null, deletedChildNode = null;\n            \n            //finds the parent hierarchy node\n            if (parent instanceof LWMap)\n              parentNode = getRootNode();\n            \n            else\n              parentNode = findHierarchyNode(getRootNode(), parent, true);\n                \n            if (parentNode == null) \n            {\n                System.err.println(\"*** NULL parentNode when deleting a hierarchy node in OutlineViewHierarchyModel\");\n                // don't know what right thing to do here, but this exception\n                // was driving me crazy -- SMF 2003-11-13 18:19.04\n                return;\n            }\n            \n            //finds the tree node representing the deleted child\n            deletedChildNode = findHierarchyNode(parentNode, deletedChild, false);  \n                \n            //removes from the hierarch model\n            if (deletedChildNode != null)\n            {\n                deleteHierarchyNode(deletedChildNode);\n                reloadTreeModel(parentNode);\n            }\n        }\n         \n        //if it is a LWLink\n        else if (deletedChild instanceof LWLink)\n        {\n            HierarchyNode linkedNode1 = null, linkedNode2 = null;\n            LWLink link = (LWLink)deletedChild;\n            \n            //gets two components the link connects to\n            LWComponent component1 = link.getComponent1();\n            LWComponent component2 = link.getComponent2();\n       \n            linkedNode1 = findHierarchyNode(getRootNode(), component1, true);\n            linkedNode2 = findHierarchyNode(getRootNode(), component2, true);\n                \n            //finds the hierarchy nodes associated with the two components and deletes the tree node representing the link to\n            //the two tree nodes\n            //must check to see if the parent wasn't deleted in the process\n            if (linkedNode1 != null)\n            {\n                HierarchyNode linkNode1 = findHierarchyNode(linkedNode1, link, false);\n                \n                if (linkNode1 != null)\n                {\n                    deleteHierarchyNode(linkNode1);\n                    reloadTreeModel(linkedNode1);\n                }\n            }\n              \n            if (linkedNode2 != null)\n            {\n                HierarchyNode linkNode2 = findHierarchyNode(linkedNode2, link, false); \n                \n                if (linkNode2 != null)\n                {\n                    deleteHierarchyNode(linkNode2);\n                    reloadTreeModel(linkedNode2);\n                }\n            }\n        }\n        \n        //validateHierarchyNodeLinkLabels();\n    }","commit_id":"fa76de1f533135806a1fed7699c1e3fd4593b85a","url":"https://github.com/VUE/VUE"},{"original_method":"@Test\n    public void staticColumnsAreFiltered() throws IOException\n    {\n        DecoratedKey key = cfm.decorateKey(ByteBufferUtil.bytes(\"k\"));\n\n        UntypedResultSet rows;\n\n        QueryProcessor.executeInternal(\"INSERT INTO ks.tbl (k, s, i, v) VALUES ('k', 's', 0, 'v')\");\n        QueryProcessor.executeInternal(\"DELETE v FROM ks.tbl WHERE k='k' AND i=0\");\n        QueryProcessor.executeInternal(\"DELETE FROM ks.tbl WHERE k='k' AND i=0\");\n        rows = QueryProcessor.executeInternal(\"SELECT * FROM ks.tbl WHERE k='k' AND i=0\");\n\n        for (UntypedResultSet.Row row: rows)\n        {\n            logger.debug(\"Current: k={}, s={}, v={}\", (row.has(\"k\") ? row.getString(\"k\") : null), (row.has(\"s\") ? row.getString(\"s\") : null), (row.has(\"v\") ? row.getString(\"v\") : null));\n        }\n\n        assert rows.isEmpty();\n\n        ColumnFilter columnFilter = ColumnFilter.selection(PartitionColumns.of(v));\n        ByteBuffer zero = ByteBufferUtil.bytes(0);\n        Slices slices = Slices.with(cfm.comparator, Slice.make(Slice.Bound.inclusiveStartOf(zero), Slice.Bound.inclusiveEndOf(zero)));\n        ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(slices, false);\n        ReadCommand cmd = new SinglePartitionSliceCommand(false, MessagingService.VERSION_30, true, cfm,\n                                                          FBUtilities.nowInSeconds(),\n                                                          columnFilter,\n                                                          RowFilter.NONE,\n                                                          DataLimits.NONE,\n                                                          key,\n                                                          sliceFilter);\n\n        DataOutputBuffer out = new DataOutputBuffer((int) ReadCommand.legacyReadCommandSerializer.serializedSize(cmd, MessagingService.VERSION_21));\n        ReadCommand.legacyReadCommandSerializer.serialize(cmd, out, MessagingService.VERSION_21);\n        DataInputPlus in = new ByteBufferDataInput(out.buffer(), null, 0, 0);\n        cmd = ReadCommand.legacyReadCommandSerializer.deserialize(in, MessagingService.VERSION_21);\n\n        logger.debug(\"ReadCommand: {}\", cmd);\n        UnfilteredPartitionIterator partitionIterator = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        ReadResponse response = ReadResponse.createDataResponse(partitionIterator, cmd.columnFilter());\n\n        logger.debug(\"creating response: {}\", response);\n        partitionIterator = response.makeIterator(cfm, null);  // <- cmd is null\n        assert partitionIterator.hasNext();\n        UnfilteredRowIterator partition = partitionIterator.next();\n\n        LegacyLayout.LegacyUnfilteredPartition rowIter = LegacyLayout.fromUnfilteredRowIterator(partition);\n        Assert.assertEquals(Collections.emptyList(), rowIter.cells);\n    }","id":104101,"modified_method":"@Test\n    public void staticColumnsAreFiltered() throws IOException\n    {\n        DecoratedKey key = cfm.decorateKey(ByteBufferUtil.bytes(\"k\"));\n\n        UntypedResultSet rows;\n\n        QueryProcessor.executeInternal(\"INSERT INTO ks.tbl (k, s, i, v) VALUES ('k', 's', 0, 'v')\");\n        QueryProcessor.executeInternal(\"DELETE v FROM ks.tbl WHERE k='k' AND i=0\");\n        QueryProcessor.executeInternal(\"DELETE FROM ks.tbl WHERE k='k' AND i=0\");\n        rows = QueryProcessor.executeInternal(\"SELECT * FROM ks.tbl WHERE k='k' AND i=0\");\n\n        for (UntypedResultSet.Row row: rows)\n        {\n            logger.debug(\"Current: k={}, s={}, v={}\", (row.has(\"k\") ? row.getString(\"k\") : null), (row.has(\"s\") ? row.getString(\"s\") : null), (row.has(\"v\") ? row.getString(\"v\") : null));\n        }\n\n        assert rows.isEmpty();\n\n        ColumnFilter columnFilter = ColumnFilter.selection(PartitionColumns.of(v));\n        ByteBuffer zero = ByteBufferUtil.bytes(0);\n        Slices slices = Slices.with(cfm.comparator, Slice.make(Slice.Bound.inclusiveStartOf(zero), Slice.Bound.inclusiveEndOf(zero)));\n        ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(slices, false);\n        ReadCommand cmd = new SinglePartitionSliceCommand(false, MessagingService.VERSION_30, true, cfm,\n                                                          FBUtilities.nowInSeconds(),\n                                                          columnFilter,\n                                                          RowFilter.NONE,\n                                                          DataLimits.NONE,\n                                                          key,\n                                                          sliceFilter);\n\n        DataOutputBuffer out = new DataOutputBuffer((int) ReadCommand.legacyReadCommandSerializer.serializedSize(cmd, MessagingService.VERSION_21));\n        ReadCommand.legacyReadCommandSerializer.serialize(cmd, out, MessagingService.VERSION_21);\n        DataInputPlus in = new DataInputBuffer(out.buffer(), true);\n        cmd = ReadCommand.legacyReadCommandSerializer.deserialize(in, MessagingService.VERSION_21);\n\n        logger.debug(\"ReadCommand: {}\", cmd);\n        UnfilteredPartitionIterator partitionIterator = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        ReadResponse response = ReadResponse.createDataResponse(partitionIterator, cmd.columnFilter());\n\n        logger.debug(\"creating response: {}\", response);\n        partitionIterator = response.makeIterator(cfm, null);  // <- cmd is null\n        assert partitionIterator.hasNext();\n        UnfilteredRowIterator partition = partitionIterator.next();\n\n        LegacyLayout.LegacyUnfilteredPartition rowIter = LegacyLayout.fromUnfilteredRowIterator(partition);\n        Assert.assertEquals(Collections.emptyList(), rowIter.cells);\n    }","commit_id":"8f249a67d99b11367ff28be86443e20d61caba47","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void staticColumnsAreReturned() throws IOException\n    {\n        DecoratedKey key = cfm.decorateKey(ByteBufferUtil.bytes(\"k\"));\n\n        QueryProcessor.executeInternal(\"INSERT INTO ks.tbl (k, s) VALUES ('k', 's')\");\n        Assert.assertFalse(QueryProcessor.executeInternal(\"SELECT s FROM ks.tbl WHERE k='k'\").isEmpty());\n\n        ColumnFilter columnFilter = ColumnFilter.selection(PartitionColumns.of(s));\n        ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(Slices.NONE, false);\n        ReadCommand cmd = new SinglePartitionSliceCommand(false, MessagingService.VERSION_30, true, cfm,\n                                                          FBUtilities.nowInSeconds(),\n                                                          columnFilter,\n                                                          RowFilter.NONE,\n                                                          DataLimits.NONE,\n                                                          key,\n                                                          sliceFilter);\n\n        UnfilteredPartitionIterator pi;\n\n        // check raw iterator for static cell\n        pi = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        checkForS(pi);\n\n        ReadResponse response;\n        DataOutputBuffer out;\n        DataInputPlus in;\n        ReadResponse dst;\n\n        // check (de)serialized iterator for memtable static cell\n        pi = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        response = ReadResponse.createDataResponse(pi, cmd.columnFilter());\n        out = new DataOutputBuffer((int) ReadResponse.serializer.serializedSize(response, MessagingService.VERSION_30));\n        ReadResponse.serializer.serialize(response, out, MessagingService.VERSION_30);\n        in = new ByteBufferDataInput(out.buffer(), null, 0, 0);\n        dst = ReadResponse.serializer.deserialize(in, MessagingService.VERSION_30);\n        pi = dst.makeIterator(cfm, cmd);\n        checkForS(pi);\n\n        // check (de)serialized iterator for sstable static cell\n        Schema.instance.getColumnFamilyStoreInstance(cfm.cfId).forceBlockingFlush();\n        pi = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        response = ReadResponse.createDataResponse(pi, cmd.columnFilter());\n        out = new DataOutputBuffer((int) ReadResponse.serializer.serializedSize(response, MessagingService.VERSION_30));\n        ReadResponse.serializer.serialize(response, out, MessagingService.VERSION_30);\n        in = new ByteBufferDataInput(out.buffer(), null, 0, 0);\n        dst = ReadResponse.serializer.deserialize(in, MessagingService.VERSION_30);\n        pi = dst.makeIterator(cfm, cmd);\n        checkForS(pi);\n    }","id":104102,"modified_method":"@Test\n    public void staticColumnsAreReturned() throws IOException\n    {\n        DecoratedKey key = cfm.decorateKey(ByteBufferUtil.bytes(\"k\"));\n\n        QueryProcessor.executeInternal(\"INSERT INTO ks.tbl (k, s) VALUES ('k', 's')\");\n        Assert.assertFalse(QueryProcessor.executeInternal(\"SELECT s FROM ks.tbl WHERE k='k'\").isEmpty());\n\n        ColumnFilter columnFilter = ColumnFilter.selection(PartitionColumns.of(s));\n        ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(Slices.NONE, false);\n        ReadCommand cmd = new SinglePartitionSliceCommand(false, MessagingService.VERSION_30, true, cfm,\n                                                          FBUtilities.nowInSeconds(),\n                                                          columnFilter,\n                                                          RowFilter.NONE,\n                                                          DataLimits.NONE,\n                                                          key,\n                                                          sliceFilter);\n\n        UnfilteredPartitionIterator pi;\n\n        // check raw iterator for static cell\n        pi = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        checkForS(pi);\n\n        ReadResponse response;\n        DataOutputBuffer out;\n        DataInputPlus in;\n        ReadResponse dst;\n\n        // check (de)serialized iterator for memtable static cell\n        pi = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        response = ReadResponse.createDataResponse(pi, cmd.columnFilter());\n        out = new DataOutputBuffer((int) ReadResponse.serializer.serializedSize(response, MessagingService.VERSION_30));\n        ReadResponse.serializer.serialize(response, out, MessagingService.VERSION_30);\n        in = new DataInputBuffer(out.buffer(), true);\n        dst = ReadResponse.serializer.deserialize(in, MessagingService.VERSION_30);\n        pi = dst.makeIterator(cfm, cmd);\n        checkForS(pi);\n\n        // check (de)serialized iterator for sstable static cell\n        Schema.instance.getColumnFamilyStoreInstance(cfm.cfId).forceBlockingFlush();\n        pi = cmd.executeLocally(ReadOrderGroup.emptyGroup());\n        response = ReadResponse.createDataResponse(pi, cmd.columnFilter());\n        out = new DataOutputBuffer((int) ReadResponse.serializer.serializedSize(response, MessagingService.VERSION_30));\n        ReadResponse.serializer.serialize(response, out, MessagingService.VERSION_30);\n        in = new DataInputBuffer(out.buffer(), true);\n        dst = ReadResponse.serializer.deserialize(in, MessagingService.VERSION_30);\n        pi = dst.makeIterator(cfm, cmd);\n        checkForS(pi);\n    }","commit_id":"8f249a67d99b11367ff28be86443e20d61caba47","url":"https://github.com/apache/cassandra"},{"original_method":"protected DataQuery getQuery(){\n\t\t\n\t\tDataQuery query = null;\n\t\ttry {\n\t\t\tquery = new DataQuery(new URL(GaInputStepMeta.GA_DATA_URL));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tex.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tquery.setIds(meta.isUseCustomTableId()?environmentSubstitute(meta.getGaCustomTableId()):meta.getGaProfileTableId());\n\t\t\n\t\tquery.setStartDate(environmentSubstitute(meta.getStartDate()));\n\t\tquery.setEndDate(environmentSubstitute(meta.getEndDate()));\n\t\tquery.setDimensions(environmentSubstitute(meta.getDimensions()));\n\t\tquery.setMetrics(environmentSubstitute(meta.getMetrics()));\n\n\t\tif (meta.isUseCustomSegment()) {\n\t\t\tquery.setSegment(environmentSubstitute(meta.getCustomSegment()));\n\t\t} else {\n\t\t\tquery.setSegment(meta.getSegmentId());\n\t\t}\n\n\t\tif (!Const.isEmpty(meta.getFilters())) {\n\t\t\tquery.setFilters(environmentSubstitute(meta.getFilters()));\n\t\t}\n\t\tif (!Const.isEmpty(meta.getSort())) {\n\t\t\tquery.setSort(environmentSubstitute(meta.getSort()));\n\t\t}\n\t\t\n\t\tif (!Const.isEmpty(meta.getGaApiKey())){\n\t\t\t// allow to use optionally encrypted environment variables\n\t\t\tquery.setStringCustomParameter(\"key\", Encr.decryptPasswordOptionallyEncrypted(environmentSubstitute(meta.getGaApiKey())));\t\n\t\t}\n\n\t\treturn query;\n\t\t\n\t}","id":104103,"modified_method":"protected DataQuery getQuery(){\n\t\t\n\t\tDataQuery query = null;\n\t\ttry {\n\t\t\tquery = new DataQuery(new URL(GaInputStepMeta.GA_DATA_URL));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tex.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tquery.setIds(meta.isUseCustomTableId()?environmentSubstitute(meta.getGaCustomTableId()):meta.getGaProfileTableId());\n\t\t\n\t\tquery.setStartDate(environmentSubstitute(meta.getStartDate()));\n\t\tquery.setEndDate(environmentSubstitute(meta.getEndDate()));\n\t\tquery.setDimensions(environmentSubstitute(meta.getDimensions()));\n\t\tquery.setMetrics(environmentSubstitute(meta.getMetrics()));\n\n\t\tif (meta.isUseSegment()){\n\t\t\tif (meta.isUseCustomSegment()) {\n\t\t\t\tquery.setSegment(environmentSubstitute(meta.getCustomSegment()));\n\t\t\t} else {\n\t\t\t\tquery.setSegment(meta.getSegmentId());\n\t\t\t}\n\t\t}\n\n\t\tif (!Const.isEmpty(meta.getFilters())) {\n\t\t\tquery.setFilters(environmentSubstitute(meta.getFilters()));\n\t\t}\n\t\tif (!Const.isEmpty(meta.getSort())) {\n\t\t\tquery.setSort(environmentSubstitute(meta.getSort()));\n\t\t}\n\t\t\n\t\tif (!Const.isEmpty(meta.getGaApiKey())){\n\t\t\t// allow to use optionally encrypted environment variables\n\t\t\tquery.setStringCustomParameter(\"key\", Encr.decryptPasswordOptionallyEncrypted(environmentSubstitute(meta.getGaApiKey())));\t\n\t\t}\n\n\t\treturn query;\n\t\t\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open() {\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n\t\tprops.setLook(shell);\n\t\tsetShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() {\n\t\t\tpublic void modifyText(ModifyEvent e) {\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Shell.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t/*************************************************\n\t\t * // STEP NAME ENTRY\n\t\t *************************************************/\n\n\t\t// Stepname line\n\t\twlStepname = new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\n\t\tprops.setLook(wlStepname);\n\t\tfdlStepname = new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\n\t\tfdlStepname.top = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\n\t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n\t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname = new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top = new FormAttachment(0, margin);\n\t\tfdStepname.right = new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t/*************************************************\n\t\t * // GOOGLE ANALYTICS CONNECTION GROUP\n\t\t *************************************************/\n\n\t\tGroup gConnect = new Group(shell, SWT.SHADOW_ETCHED_IN);\n\t\tgConnect.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ConnectGroup.Label\"));\n\t\tFormLayout gConnectLayout = new FormLayout();\n\t\tgConnectLayout.marginWidth = 3;\n\t\tgConnectLayout.marginHeight = 3;\n\t\tgConnect.setLayout(gConnectLayout);\n\t\tprops.setLook(gConnect);\n\t\t\n\t\t// Google Analytics app name\n\t\twlGaAppName = new Label(gConnect, SWT.RIGHT);\n\t\twlGaAppName.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.AppName.Label\"));\n\t\tprops.setLook(wlGaAppName);\n\t\tFormData fdlGaAppName = new FormData();\n\t\tfdlGaAppName.top = new FormAttachment(0, margin);\n\t\tfdlGaAppName.left = new FormAttachment(0, 0);\n\t\tfdlGaAppName.right = new FormAttachment(middle, -margin);\n\t\twlGaAppName.setLayoutData(fdlGaAppName);\n\t\twGaAppName = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twGaAppName.addModifyListener(lsMod);\n\t\twGaAppName.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.AppName.Tooltip\"));\n\t\tprops.setLook(wGaAppName);\n\t\tFormData fdGaAppName = new FormData();\n\t\tfdGaAppName.top = new FormAttachment(0, margin);\n\t\tfdGaAppName.left = new FormAttachment(middle, 0);\n\t\tfdGaAppName.right = new FormAttachment(100, 0);\n\t\twGaAppName.setLayoutData(fdGaAppName);\t\t\n\n\t\t// Google Analytics Email\n\t\twlGaEmail = new Label(gConnect, SWT.RIGHT);\n\t\twlGaEmail.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Email.Label\"));\n\t\tprops.setLook(wlGaEmail);\n\t\tFormData fdlGaEmail = new FormData();\n\t\tfdlGaEmail.top = new FormAttachment(wGaAppName, margin);\n\t\tfdlGaEmail.left = new FormAttachment(0, 0);\n\t\tfdlGaEmail.right = new FormAttachment(middle, -margin);\n\t\twlGaEmail.setLayoutData(fdlGaEmail);\n\t\twGaEmail = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twGaEmail.addModifyListener(lsMod);\n\t\twGaEmail.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Email.Tooltip\"));\n\t\tprops.setLook(wGaEmail);\n\t\tFormData fdGaEmail = new FormData();\n\t\tfdGaEmail.top = new FormAttachment(wGaAppName, margin);\n\t\tfdGaEmail.left = new FormAttachment(middle, 0);\n\t\tfdGaEmail.right = new FormAttachment(100, 0);\n\t\twGaEmail.setLayoutData(fdGaEmail);\n\n\t\t// Google Analytics Password\n\t\twlGaPassword = new Label(gConnect, SWT.RIGHT);\n\t\twlGaPassword.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Password.Label\"));\n\t\tprops.setLook(wlGaPassword);\n\t\tFormData fdlGaPassword = new FormData();\n\t\tfdlGaPassword.top = new FormAttachment(wGaEmail, margin);\n\t\tfdlGaPassword.left = new FormAttachment(0, 0);\n\t\tfdlGaPassword.right = new FormAttachment(middle, -margin);\n\t\twlGaPassword.setLayoutData(fdlGaPassword);\n\t\twGaPassword = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.PASSWORD);\n\t\twGaPassword.addModifyListener(lsMod);\n\t\twGaPassword.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Password.Tooltip\"));\n\t\tprops.setLook(wGaPassword);\n\t\tFormData fdGaPassword = new FormData();\n\t\tfdGaPassword.top = new FormAttachment(wGaEmail, margin);\n\t\tfdGaPassword.left = new FormAttachment(middle, 0);\n\t\tfdGaPassword.right = new FormAttachment(100, 0);\n\t\twGaPassword.setLayoutData(fdGaPassword);\n\n\t\t// Google Analytics Password\n\t\tLabel wlGaApiKey = new Label(gConnect, SWT.RIGHT);\n\t\twlGaApiKey.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ApiKey.Label\"));\n\t\tprops.setLook(wlGaApiKey);\n\t\tFormData fdlGaApiKey = new FormData();\n\t\tfdlGaApiKey.top = new FormAttachment(wGaPassword, margin);\n\t\tfdlGaApiKey.left = new FormAttachment(0, 0);\n\t\tfdlGaApiKey.right = new FormAttachment(middle, -margin);\n\t\twlGaApiKey.setLayoutData(fdlGaApiKey);\n\t\twGaApiKey = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.PASSWORD);\n\t\twGaApiKey.addModifyListener(lsMod);\n\t\twGaApiKey.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ApiKey.Tooltip\"));\n\t\tprops.setLook(wGaApiKey);\n\t\tFormData fdGaApiKey = new FormData();\n\t\tfdGaApiKey.top = new FormAttachment(wGaPassword, margin);\n\t\tfdGaApiKey.left = new FormAttachment(middle, 0);\n\t\tfdGaApiKey.right = new FormAttachment(100, 0);\n\t\twGaApiKey.setLayoutData(fdGaApiKey);\t\t\n\t\t\n\t\t// custom profile definition\n\t\twlGaCustomProfile = new Label(gConnect, SWT.RIGHT);\n\t\twlGaCustomProfile.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.CustomProfileEnabled.Label\"));\n\t\tprops.setLook(wlGaCustomProfile);\n\t\tFormData fdlGaCustomProfile = new FormData();\n\t\tfdlGaCustomProfile.top = new FormAttachment(wGaApiKey, margin);\n\t\tfdlGaCustomProfile.left = new FormAttachment(0, 0);\n\t\tfdlGaCustomProfile.right = new FormAttachment(middle, -margin);\n\t\twlGaCustomProfile.setLayoutData(fdlGaCustomProfile);\n\n\t\twCustomProfileEnabled = new Button(gConnect, SWT.CHECK);\n\t\tprops.setLook(wCustomProfileEnabled);\n\t\twCustomProfileEnabled.pack(true);\n\n\t\tFormData fdCustomProfileEnabled = new FormData();\n\t\tfdCustomProfileEnabled.left = new FormAttachment(middle, 0);\n\t\tfdCustomProfileEnabled.top = new FormAttachment(wGaApiKey, margin);\n\t\twCustomProfileEnabled.setLayoutData(fdCustomProfileEnabled);\n\n\t\twCustomProfileEnabled.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tsetActive();\n\t\t\t\tif (wCustomProfileEnabled.getSelection()) {\n\t\t\t\t\twGaCustomProfile.setFocus();\n\t\t\t\t} else {\n\t\t\t\t\twGaProfile.setFocus();\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\twGaCustomProfile = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twGaCustomProfile.addModifyListener(lsMod);\n\t\twGaCustomProfile.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.CustomProfile.Tooltip\"));\n\t\tprops.setLook(wGaCustomProfile);\n\n\t\twGaCustomProfileReference = new Link(gConnect, SWT.SINGLE);\n\t\twGaCustomProfileReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wGaCustomProfileReference);\n\t\twGaCustomProfileReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_TABLE_ID_URI);\n\t\t\t}\n\t\t});\n\n\t\twGaCustomProfileReference.pack(true);\n\n\t\tFormData fdGaCustomProfile = new FormData();\n\t\tfdGaCustomProfile.top = new FormAttachment(wGaApiKey, margin);\n\t\tfdGaCustomProfile.left = new FormAttachment(wCustomProfileEnabled, margin);\n\t\tfdGaCustomProfile.right = new FormAttachment(100, -wGaCustomProfileReference.getBounds().width - margin);\n\t\twGaCustomProfile.setLayoutData(fdGaCustomProfile);\n\n\t\tFormData fdGaCustomProfileReference = new FormData();\n\t\tfdGaCustomProfileReference.top = new FormAttachment(wGaApiKey, margin);\n\t\tfdGaCustomProfileReference.left = new FormAttachment(wGaCustomProfile, 0);\n\t\tfdGaCustomProfileReference.right = new FormAttachment(100, 0);\n\t\twGaCustomProfileReference.setLayoutData(fdGaCustomProfileReference);\t\t\n\t\t\n\t\t\n\t\t// Google analytics profile\n\n\t\twlGaProfile = new Label(gConnect, SWT.RIGHT);\n\t\twlGaProfile.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.Label\"));\n\t\tprops.setLook(wlGaProfile);\n\n\t\tFormData fdlGaProfile = new FormData();\n\t\tfdlGaProfile.top = new FormAttachment(wGaCustomProfile, margin);\n\t\tfdlGaProfile.left = new FormAttachment(0, 0);\n\t\tfdlGaProfile.right = new FormAttachment(middle, -margin);\n\t\twlGaProfile.setLayoutData(fdlGaProfile);\n\n\t\twGaProfile = new CCombo(gConnect, SWT.LEFT | SWT.BORDER | SWT.SINGLE | SWT.READ_ONLY);\n\n\t\tprops.setLook(wGaProfile);\n\t\twGaProfile.addModifyListener(lsMod);\n\t\twGaProfile.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.Tooltip\"));\n\n\t\twGetProfiles = new Button(gConnect, SWT.PUSH);\n\t\twGetProfiles.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.GetProfilesButton.Label\"));\n\t\twGetProfiles.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.GetProfilesButton.Tooltip\"));\n\t\tprops.setLook(wGetProfiles);\n\t\twGetProfiles.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tshell.getDisplay().asyncExec(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\treadGaProfiles(wGaEmail.getText(), wGaPassword.getText(), wGaAppName.getText(), wGaApiKey.getText().trim());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\twGetProfiles.pack(true);\n\n\t\tFormData fdGaProfile = new FormData();\n\t\tfdGaProfile.left = new FormAttachment(middle, 0);\n\t\tfdGaProfile.top = new FormAttachment(wGaCustomProfile, margin);\n\t\tfdGaProfile.right = new FormAttachment(100, -wGetProfiles.getBounds().width - margin);\n\t\twGaProfile.setLayoutData(fdGaProfile);\n\n\t\tFormData fdGetProfiles = new FormData();\n\t\tfdGetProfiles.left = new FormAttachment(wGaProfile, 0);\n\t\tfdGetProfiles.top = new FormAttachment(wGaCustomProfile, margin);\n\t\tfdGetProfiles.right = new FormAttachment(100, 0);\n\t\twGetProfiles.setLayoutData(fdGetProfiles);\n\t\t\n\t\t\n\t\t\n\n\t\tFormData fdConnect = new FormData();\n\t\tfdConnect.left = new FormAttachment(0, 0);\n\t\tfdConnect.right = new FormAttachment(100, 0);\n\t\tfdConnect.top = new FormAttachment(wStepname, margin);\n\t\tgConnect.setLayoutData(fdConnect);\n\t\t\n\t\tgConnect.setTabList(new Control[] {wGaAppName, wGaEmail, wGaPassword, wCustomProfileEnabled, wGaCustomProfile, wGaProfile, wGetProfiles});\n\n\t\t/*************************************************\n\t\t * // GOOGLE ANALYTICS QUERY GROUP\n\t\t *************************************************/\n\n\t\tGroup gQuery = new Group(shell, SWT.SHADOW_ETCHED_IN);\n\t\tgQuery.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.QueryGroup.Label\"));\n\t\tFormLayout gQueryLayout = new FormLayout();\n\t\tgQueryLayout.marginWidth = 3;\n\t\tgQueryLayout.marginHeight = 3;\n\t\tgQuery.setLayout(gQueryLayout);\n\t\tprops.setLook(gQuery);\n\n\t\t// query start date\n\t\twlQuStartDate = new Label(gQuery, SWT.RIGHT);\n\t\twlQuStartDate.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.StartDate.Label\"));\n\t\tprops.setLook(wlQuStartDate);\n\t\tFormData fdlQuStartDate = new FormData();\n\t\tfdlQuStartDate.top = new FormAttachment(0, margin);\n\t\tfdlQuStartDate.left = new FormAttachment(0, 0);\n\t\tfdlQuStartDate.right = new FormAttachment(middle, -margin);\n\t\twlQuStartDate.setLayoutData(fdlQuStartDate);\n\t\twQuStartDate = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuStartDate.addModifyListener(lsMod);\n\t\twQuStartDate.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.StartDate.Tooltip\"));\n\t\tprops.setLook(wQuStartDate);\n\t\tFormData fdQuStartDate = new FormData();\n\t\tfdQuStartDate.top = new FormAttachment(0, margin);\n\t\tfdQuStartDate.left = new FormAttachment(middle, 0);\n\t\tfdQuStartDate.right = new FormAttachment(100, 0);\n\t\twQuStartDate.setLayoutData(fdQuStartDate);\n\n\t\t// query end date\n\t\twlQuEndDate = new Label(gQuery, SWT.RIGHT);\n\t\twlQuEndDate.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.EndDate.Label\"));\n\t\tprops.setLook(wlQuEndDate);\n\t\tFormData fdlQuEndDate = new FormData();\n\t\tfdlQuEndDate.top = new FormAttachment(wQuStartDate, margin);\n\t\tfdlQuEndDate.left = new FormAttachment(0, 0);\n\t\tfdlQuEndDate.right = new FormAttachment(middle, -margin);\n\t\twlQuEndDate.setLayoutData(fdlQuEndDate);\n\t\twQuEndDate = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuEndDate.addModifyListener(lsMod);\n\t\twQuEndDate.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.EndDate.Tooltip\"));\n\t\tprops.setLook(wQuEndDate);\n\t\tFormData fdQuEndDate = new FormData();\n\t\tfdQuEndDate.top = new FormAttachment(wQuStartDate, margin);\n\t\tfdQuEndDate.left = new FormAttachment(middle, 0);\n\t\tfdQuEndDate.right = new FormAttachment(100, 0);\n\t\twQuEndDate.setLayoutData(fdQuEndDate);\n\n\t\t// query dimensions\n\t\twlQuDimensions = new Label(gQuery, SWT.RIGHT);\n\t\twlQuDimensions.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Dimensions.Label\"));\n\t\tprops.setLook(wlQuDimensions);\n\t\tFormData fdlQuDimensions = new FormData();\n\t\tfdlQuDimensions.top = new FormAttachment(wQuEndDate, margin);\n\t\tfdlQuDimensions.left = new FormAttachment(0, 0);\n\t\tfdlQuDimensions.right = new FormAttachment(middle, -margin);\n\t\twlQuDimensions.setLayoutData(fdlQuDimensions);\n\t\twQuDimensions = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuDimensions.addModifyListener(lsMod);\n\t\twQuDimensions.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Dimensions.Tooltip\"));\n\t\tprops.setLook(wQuDimensions);\n\n\t\twQuDimensionsReference = new Link(gQuery, SWT.SINGLE);\n\n\t\twQuDimensionsReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuDimensionsReference);\n\t\twQuDimensionsReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_DIMENSIONS_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuDimensionsReference.pack(true);\n\n\t\tFormData fdQuDimensions = new FormData();\n\t\tfdQuDimensions.top = new FormAttachment(wQuEndDate, margin);\n\t\tfdQuDimensions.left = new FormAttachment(middle, 0);\n\t\tfdQuDimensions.right = new FormAttachment(100, -wQuDimensionsReference.getBounds().width - margin);\n\t\twQuDimensions.setLayoutData(fdQuDimensions);\n\n\t\tFormData fdQuDimensionsReference = new FormData();\n\t\tfdQuDimensionsReference.top = new FormAttachment(wQuEndDate, margin);\n\t\tfdQuDimensionsReference.left = new FormAttachment(wQuDimensions, 0);\n\t\tfdQuDimensionsReference.right = new FormAttachment(100, 0);\n\t\twQuDimensionsReference.setLayoutData(fdQuDimensionsReference);\n\n\t\t// query Metrics\n\t\twlQuMetrics = new Label(gQuery, SWT.RIGHT);\n\t\twlQuMetrics.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Metrics.Label\"));\n\t\tprops.setLook(wlQuMetrics);\n\t\tFormData fdlQuMetrics = new FormData();\n\t\tfdlQuMetrics.top = new FormAttachment(wQuDimensions, margin);\n\t\tfdlQuMetrics.left = new FormAttachment(0, 0);\n\t\tfdlQuMetrics.right = new FormAttachment(middle, -margin);\n\t\twlQuMetrics.setLayoutData(fdlQuMetrics);\n\t\twQuMetrics = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuMetrics.addModifyListener(lsMod);\n\t\twQuMetrics.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Metrics.Tooltip\"));\n\t\tprops.setLook(wQuMetrics);\n\n\t\twQuMetricsReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuMetricsReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuMetricsReference);\n\t\twQuMetricsReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_METRICS_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuMetricsReference.pack(true);\n\n\t\tFormData fdQuMetrics = new FormData();\n\t\tfdQuMetrics.top = new FormAttachment(wQuDimensions, margin);\n\t\tfdQuMetrics.left = new FormAttachment(middle, 0);\n\t\tfdQuMetrics.right = new FormAttachment(100, -wQuMetricsReference.getBounds().width - margin);\n\t\twQuMetrics.setLayoutData(fdQuMetrics);\n\n\t\tFormData fdQuMetricsReference = new FormData();\n\t\tfdQuMetricsReference.top = new FormAttachment(wQuDimensions, margin);\n\t\tfdQuMetricsReference.left = new FormAttachment(wQuMetrics, 0);\n\t\tfdQuMetricsReference.right = new FormAttachment(100, 0);\n\t\twQuMetricsReference.setLayoutData(fdQuMetricsReference);\n\n\t\t// query filters\n\t\twlQuFilters = new Label(gQuery, SWT.RIGHT);\n\t\twlQuFilters.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Filters.Label\"));\n\t\tprops.setLook(wlQuFilters);\n\t\tFormData fdlQuFilters = new FormData();\n\t\tfdlQuFilters.top = new FormAttachment(wQuMetrics, margin);\n\t\tfdlQuFilters.left = new FormAttachment(0, 0);\n\t\tfdlQuFilters.right = new FormAttachment(middle, -margin);\n\t\twlQuFilters.setLayoutData(fdlQuFilters);\n\t\twQuFilters = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuFilters.addModifyListener(lsMod);\n\t\twQuFilters.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Filters.Tooltip\"));\n\t\tprops.setLook(wQuFilters);\n\n\t\twQuFiltersReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuFiltersReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuFiltersReference);\n\t\twQuFiltersReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_FILTERS_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuFiltersReference.pack(true);\n\n\t\tFormData fdQuFilters = new FormData();\n\t\tfdQuFilters.top = new FormAttachment(wQuMetrics, margin);\n\t\tfdQuFilters.left = new FormAttachment(middle, 0);\n\t\tfdQuFilters.right = new FormAttachment(100, -wQuFiltersReference.getBounds().width - margin);\n\t\twQuFilters.setLayoutData(fdQuFilters);\n\n\t\tFormData fdQuFiltersReference = new FormData();\n\t\tfdQuFiltersReference.top = new FormAttachment(wQuMetrics, margin);\n\t\tfdQuFiltersReference.left = new FormAttachment(wQuFilters, 0);\n\t\tfdQuFiltersReference.right = new FormAttachment(100, 0);\n\t\twQuFiltersReference.setLayoutData(fdQuFiltersReference);\n\n\t\t// query Sort\n\t\twlQuSort = new Label(gQuery, SWT.RIGHT);\n\t\twlQuSort.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Sort.Label\"));\n\t\tprops.setLook(wlQuSort);\n\t\tFormData fdlQuSort = new FormData();\n\t\tfdlQuSort.top = new FormAttachment(wQuFilters, margin);\n\t\tfdlQuSort.left = new FormAttachment(0, 0);\n\t\tfdlQuSort.right = new FormAttachment(middle, -margin);\n\t\twlQuSort.setLayoutData(fdlQuSort);\n\t\twQuSort = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuSort.addModifyListener(lsMod);\n\t\twQuSort.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Sort.Tooltip\"));\n\t\tprops.setLook(wQuSort);\n\n\t\twQuSortReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuSortReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuSortReference);\n\t\twQuSortReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_SORT_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuSortReference.pack(true);\n\n\t\tFormData fdQuSort = new FormData();\n\t\tfdQuSort.top = new FormAttachment(wQuFilters, margin);\n\t\tfdQuSort.left = new FormAttachment(middle, 0);\n\t\tfdQuSort.right = new FormAttachment(100, -wQuSortReference.getBounds().width - margin);\n\t\twQuSort.setLayoutData(fdQuSort);\n\n\t\tFormData fdQuSortReference = new FormData();\n\t\tfdQuSortReference.top = new FormAttachment(wQuFilters, margin);\n\t\tfdQuSortReference.left = new FormAttachment(wQuSort, 0);\n\t\tfdQuSortReference.right = new FormAttachment(100, 0);\n\t\twQuSortReference.setLayoutData(fdQuSortReference);\n\n\t\t// custom segment definition\n\t\twlQuCustomSegment = new Label(gQuery, SWT.RIGHT);\n\t\twlQuCustomSegment.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.CustomSegment.Label\"));\n\t\tprops.setLook(wlQuCustomSegment);\n\t\tFormData fdlQuCustomSegment = new FormData();\n\t\tfdlQuCustomSegment.top = new FormAttachment(wQuSort, margin);\n\t\tfdlQuCustomSegment.left = new FormAttachment(0, 0);\n\t\tfdlQuCustomSegment.right = new FormAttachment(middle, -margin);\n\t\twlQuCustomSegment.setLayoutData(fdlQuCustomSegment);\n\n\t\twCustomSegmentEnabled = new Button(gQuery, SWT.CHECK);\n\t\tprops.setLook(wCustomSegmentEnabled);\n\t\twCustomSegmentEnabled.pack(true);\n\n\t\tFormData fdCustomSegmentEnabled = new FormData();\n\t\tfdCustomSegmentEnabled.left = new FormAttachment(middle, 0);\n\t\tfdCustomSegmentEnabled.top = new FormAttachment(wQuSort, margin);\n\t\twCustomSegmentEnabled.setLayoutData(fdCustomSegmentEnabled);\n\n\t\twCustomSegmentEnabled.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tsetActive();\n\t\t\t\tif (wCustomSegmentEnabled.getSelection()) {\n\t\t\t\t\twQuCustomSegment.setFocus();\n\t\t\t\t} else {\n\t\t\t\t\twQuSegment.setFocus();\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\twQuCustomSegment = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuCustomSegment.addModifyListener(lsMod);\n\t\twQuCustomSegment.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.CustomSegment.Tooltip\"));\n\t\tprops.setLook(wQuCustomSegment);\n\n\t\twQuCustomSegmentReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuCustomSegmentReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuCustomSegmentReference);\n\t\twQuCustomSegmentReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_SEGMENT_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuCustomSegmentReference.pack(true);\n\n\t\tFormData fdQuCustomSegment = new FormData();\n\t\tfdQuCustomSegment.top = new FormAttachment(wQuSort, margin);\n\t\tfdQuCustomSegment.left = new FormAttachment(wCustomSegmentEnabled, margin);\n\t\tfdQuCustomSegment.right = new FormAttachment(100, -wQuCustomSegmentReference.getBounds().width - margin);\n\t\twQuCustomSegment.setLayoutData(fdQuCustomSegment);\n\n\t\tFormData fdQuCustomSegmentReference = new FormData();\n\t\tfdQuCustomSegmentReference.top = new FormAttachment(wQuSort, margin);\n\t\tfdQuCustomSegmentReference.left = new FormAttachment(wQuCustomSegment, 0);\n\t\tfdQuCustomSegmentReference.right = new FormAttachment(100, 0);\n\t\twQuCustomSegmentReference.setLayoutData(fdQuCustomSegmentReference);\n\n\t\t// segment selection\n\n\t\twlQuSegment = new Label(gQuery, SWT.RIGHT);\n\t\twlQuSegment.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Segment.Label\"));\n\t\tprops.setLook(wlQuSegment);\n\n\t\tFormData fdlQuSegment = new FormData();\n\t\tfdlQuSegment.top = new FormAttachment(wQuCustomSegment, margin);\n\t\tfdlQuSegment.left = new FormAttachment(0, 0);\n\t\tfdlQuSegment.right = new FormAttachment(middle, -margin);\n\t\twlQuSegment.setLayoutData(fdlQuSegment);\n\n\t\twQuSegment = new CCombo(gQuery, SWT.LEFT | SWT.BORDER | SWT.SINGLE | SWT.READ_ONLY);\n\n\t\tprops.setLook(wQuSegment);\n\t\twQuSegment.addModifyListener(lsMod);\n\t\twQuSegment.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Segment.Tooltip\"));\n\n\t\twGetSegments = new Button(gQuery, SWT.PUSH);\n\t\twGetSegments.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.GetSegmentsButton.Label\"));\n\t\twGetSegments.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.GetSegmentsButton.Tooltip\"));\n\t\tprops.setLook(wGetSegments);\n\t\twGetSegments.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tshell.getDisplay().asyncExec(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\treadGaSegments(wGaEmail.getText(), wGaPassword.getText(), wGaAppName.getText(), wGaApiKey.getText().trim());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\twGetSegments.pack(true);\n\n\t\tFormData fdQuSegment = new FormData();\n\t\tfdQuSegment.left = new FormAttachment(middle, 0);\n\t\tfdQuSegment.top = new FormAttachment(wQuCustomSegment, margin);\n\t\tfdQuSegment.right = new FormAttachment(100, -wGetSegments.getBounds().width - margin);\n\t\twQuSegment.setLayoutData(fdQuSegment);\n\n\t\tFormData fdGetSegments = new FormData();\n\t\tfdGetSegments.left = new FormAttachment(wQuSegment, 0);\n\t\tfdGetSegments.top = new FormAttachment(wQuCustomSegment, margin);\n\t\tfdGetSegments.right = new FormAttachment(100, 0);\n\t\twGetSegments.setLayoutData(fdGetSegments);\n\n\t\tFormData fdQueryGroup = new FormData();\n\t\tfdQueryGroup.left = new FormAttachment(0, 0);\n\t\tfdQueryGroup.right = new FormAttachment(100, 0);\n\t\tfdQueryGroup.top = new FormAttachment(gConnect, margin);\n\t\tgQuery.setLayoutData(fdQueryGroup);\n\n\t\tgQuery.setTabList(new Control[] { wQuStartDate, wQuEndDate, wQuDimensions, wQuMetrics, wQuFilters, wQuSort, wCustomSegmentEnabled, wQuCustomSegment, wQuSegment, wGetSegments });\n\n\t\t// Limit input ...\n\t\twlLimit=new Label(shell, SWT.RIGHT);\n\t\twlLimit.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.LimitSize.Label\"));\n \t\tprops.setLook(wlLimit);\n\t\tFormData fdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\tfdlLimit.bottom = new FormAttachment(100, -50);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twLimit.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.LimitSize.Tooltip\"));\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tFormData fdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\tfdLimit.bottom = new FormAttachment(100, -50);\n\t\t\n\t\twLimit.setLayoutData(fdLimit);\t\t\n\t\t\n\t\t/*************************************************\n\t\t * // KEY / LOOKUP TABLE\n\t\t *************************************************/\n\n\t\twlFields = new Link(shell, SWT.NONE);\n\t\twlFields.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Return.Label\"));\n\t\tprops.setLook(wlFields);\n\t\twlFields.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_DIMENSION_AND_METRIC_URI);\n\t\t\t}\n\t\t});\n\t\t\n\t\tFormData fdlReturn = new FormData();\n\t\tfdlReturn.left = new FormAttachment(0, 0);\n\t\tfdlReturn.top = new FormAttachment(gQuery, margin);\n\t\twlFields.setLayoutData(fdlReturn);\n\n\t\tint fieldWidgetCols = 5;\n\t\tint fieldWidgetRows = (input.getFeedField() != null ? input.getFeedField().length : 1);\n\n\t\tColumnInfo[] ciKeys = new ColumnInfo[fieldWidgetCols];\n\t\tciKeys[0] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.FeedFieldType\"), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{GaInputStepMeta.FIELD_TYPE_DIMENSION, GaInputStepMeta.FIELD_TYPE_METRIC, GaInputStepMeta.FIELD_TYPE_CONFIDENCE_INTERVAL, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_PROPERTY, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_FIELD}, true);\n\t\tciKeys[1] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.FeedField\"), ColumnInfo.COLUMN_TYPE_TEXT, false, false);\n\t\tciKeys[1].setUsingVariables(true);\n\t\tciKeys[2] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.RenameTo\"), ColumnInfo.COLUMN_TYPE_TEXT, false, false);\n\t\tciKeys[3] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.Type\"), ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes());\n        ciKeys[4] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.Format\"), ColumnInfo.COLUMN_TYPE_FORMAT, 4);\n\n\t\twFields = new TableView(transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, ciKeys, fieldWidgetRows, lsMod, props);\n\n\t\tFormData fdReturn = new FormData();\n\t\tfdReturn.left = new FormAttachment(0, 0);\n\t\tfdReturn.top = new FormAttachment(wlFields, margin);\n\t\tfdReturn.right = new FormAttachment(100, 0);\n\t\tfdReturn.bottom = new FormAttachment(wLimit, -margin);\n\t\twFields.setLayoutData(fdReturn);\n\n\t\t/*************************************************\n\t\t * // OK AND CANCEL BUTTONS\n\t\t *************************************************/\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\n\t\t\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(BaseMessages.getString(PKG, \"System.Button.GetFields\"));\n\t\t\n\t\twGet.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event e) {\n\n\t\t\t\tDataQuery query = getPreviewQuery();\n\t\t\t\tquery.setMaxResults(1);\n\n\t\t\t\tString email = transMeta.environmentSubstitute(wGaEmail.getText());\n\t\t\t\tString pass = transMeta.environmentSubstitute(wGaPassword.getText());\n\t\t\t\t\n\n\t\t\t\tAnalyticsService analyticsService = new AnalyticsService(transMeta.environmentSubstitute(wGaAppName.getText()));\n\t\t\t\t\n\t\t\t\ttry{\n\t\t\t\t\n\t\t\t\t\tanalyticsService.setUserCredentials(email, pass);\n\t\t\t\t\tDataFeed dataFeed = analyticsService.getFeed(query.getUrl(), DataFeed.class);\n\t\t\t\t\t\n\t\t\t\t\tif (dataFeed.getEntries().size() < 1){\n\t\t\t\t\t\t\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\t\tmb.setText(\"Query yields empty feed\");\n\t\t\t\t\t\tmb.setMessage(\"The feed did not give any results. Please specify a query that returns data.\");\n\t\t\t\t\t\tmb.open();\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tDataEntry entry = dataFeed.getEntries().get(0);\n\t\t\t\t\t\n\t\t\t\t\tList<Dimension> dims = entry.getDimensions();\n\t\t\t\t\tList<Metric> metrics = entry.getMetrics();\n\t\t\t\t\tList<Property> dsprops = new ArrayList<Property>();\n\t\t\t\t\tint dataSourceFields = 0;\n\t\t\t\t\tif (dataFeed.getDataSources().size() > 0){\n\t\t\t\t\t\tdsprops = dataFeed.getDataSources().get(0).getProperties();\n\t\t\t\t\t\tdataSourceFields=2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twFields.table.setItemCount(dims.size()+metrics.size()*2+dsprops.size()+dataSourceFields);\n\t\t\t\t\t\n\t\t\t\t\tint i = 0;\n\t\t\t\t\t\n\t\t\t\t\t// Fill Dimension Fields\n\t\t\t\t\tfor (Dimension d : dims){\n\t\t\t\t\t\t\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DIMENSION);\n\t\t\t\t\t\titem.setText(2, d.getName());\n\t\t\t\t\t\titem.setText(3, d.getName());\n\n\t\t\t\t\t\t// recognize date dimension\n\t\t\t\t\t\tif (d.getName().equalsIgnoreCase(\"ga:date\")){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_DATE));\n\t\t\t\t\t\t\titem.setText(5, \"yyyyMMdd\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (d.getName().equalsIgnoreCase(\"ga:daysSinceLastVisit\") || d.getName().equalsIgnoreCase(\"ga:visitLength\") || d.getName().equalsIgnoreCase(\"ga:visitCount\")){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_INTEGER));\n\t\t\t\t\t\t\titem.setText(5, \"#;-#\");\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\telse if (d.getName().equalsIgnoreCase(\"ga:latitude\") || d.getName().equalsIgnoreCase(\"ga:longitude\")){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER));\n\t\t\t\t\t\t\titem.setText(5, \"#.#;-#.#\");\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Fill Metric fields\n\t\t\t\t\tfor (Metric m: metrics){\n\t\t\t\t\t\t\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_METRIC);\n\t\t\t\t\t\titem.setText(2, m.getName());\n\t\t\t\t\t\titem.setText(3, m.getName());\n\n\t\t\t\t\t\t// depending on type\n\t\t\t\t\t\tif (m.getType().compareToIgnoreCase(\"currency\") == 0 || m.getType().compareToIgnoreCase(\"float\") == 0 || m.getType().compareToIgnoreCase(\"percent\") == 0 || m.getType().compareToIgnoreCase(\"us_currency\") == 0){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER));\n\t\t\t\t\t\t\titem.setText(5, \"#.#;-#.#\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(m.getType().compareToIgnoreCase(\"time\") == 0 || m.getType().compareToIgnoreCase(\"integer\") == 0){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_INTEGER));\n\t\t\t\t\t\t\titem.setText(5, \"#;-#\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\titem = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_CONFIDENCE_INTERVAL);\n\t\t\t\t\t\titem.setText(2, m.getName());\n\t\t\t\t\t\titem.setText(3, m.getName()+\"#confidenceInterval\");\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER));\t\n\t\t\t\t\t\titem.setText(5, \"#.#;-#.#\");\n\t\t\t\t\t\t\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Fill ds property fields\n\t\t\t\t\tfor (Property prop:dsprops){\n\t\t\t\t\t\t\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_PROPERTY);\n\t\t\t\t\t\titem.setText(2, prop.getName());\n\t\t\t\t\t\titem.setText(3, prop.getName());\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t// Fill ds field fields\n\t\t\t\t\tif (dataFeed.getDataSources().size() > 0){\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_FIELD);\n\t\t\t\t\t\titem.setText(2, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_ID);\n\t\t\t\t\t\titem.setText(3, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_ID);\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\ti++;\n\n\t\t\t\t\t\titem = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_FIELD);\n\t\t\t\t\t\titem.setText(2, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_NAME);\n\t\t\t\t\t\titem.setText(3, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_NAME);\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t            wFields.removeEmptyRows();\n\t\t            wFields.setRowNums();\n\t\t            wFields.optWidth(true);\n\t\t            input.setChanged();\n\n\t\t\t\t} catch (AuthenticationException e1) {\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\tmb.setText(\"Authentication Error\");\n\t\t\t\t\tmb.setMessage(\"Could not authenticate. Please check the credentials and ensure that there's no network connectivity problem.\\n\\n\"+e1.getMessage());\n\t\t\t\t\tmb.open();\n\t\t\t\t\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\treturn;\n\n\t\t\t\t} catch (IOException e2) {\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\tmb.setText(\"IO Error\");\n\t\t\t\t\tmb.setMessage(\"Could not contact Google Analytics service. Please make sure that there's no network connectivity problem.\");\n\t\t\t\t\tmb.open();\n\t\t\t\t\te2.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t} catch (ServiceException e3) {\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\tmb.setText(\"Service Error\");\n\t\t\t\t\tmb.setMessage(\"Google Service Error\\n\\n\"+e3.getMessage());\n\t\t\t\t\tmb.open();\n\t\t\t\t\te3.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t});\t\t\n\n\t\twPreview = new Button(shell, SWT.PUSH);\n\t\twPreview.setText(BaseMessages.getString(PKG, \"System.Button.Preview\"));\t\t\n\t\twPreview.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tpreview();\n\t\t\t}\n\t\t});\n\t\t\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wGet, wPreview, wCancel }, margin, wLimit);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n\n\t\t/*************************************************\n\t\t * // DEFAULT ACTION LISTENERS\n\t\t *************************************************/\n\n\t\tlsDef = new SelectionAdapter() {\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twStepname.addSelectionListener(lsDef);\n\t\twGaEmail.addSelectionListener(lsDef);\n\t\twGaPassword.addSelectionListener(lsDef);\n\t\twGaCustomProfile.addSelectionListener(lsDef);\n\t\twQuStartDate.addSelectionListener(lsDef);\n\t\twQuEndDate.addSelectionListener(lsDef);\n\t\twQuDimensions.addSelectionListener(lsDef);\n\t\twQuMetrics.addSelectionListener(lsDef);\n\t\twQuFilters.addSelectionListener(lsDef);\n\t\twQuSort.addSelectionListener(lsDef);\n\t\twQuCustomSegment.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter() {\n\t\t\tpublic void shellClosed(ShellEvent e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\n\t\t/*************************************************\n\t\t * // POPULATE AND OPEN DIALOG\n\t\t *************************************************/\n\n\t\tgetData();\n\n\t\tinput.setChanged(backupChanged);\n\t\twStepname.setFocus();\n\n\t\tshell.setTabList(new Control[]{wStepname, gConnect, gQuery, wFields});\n\t\tshell.open();\n\n\t\twhile (!shell.isDisposed()) {\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":104104,"modified_method":"public String open() {\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n\t\tprops.setLook(shell);\n\t\tsetShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() {\n\t\t\tpublic void modifyText(ModifyEvent e) {\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Shell.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t/*************************************************\n\t\t * // STEP NAME ENTRY\n\t\t *************************************************/\n\n\t\t// Stepname line\n\t\twlStepname = new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\n\t\tprops.setLook(wlStepname);\n\t\tfdlStepname = new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\n\t\tfdlStepname.top = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\n\t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n\t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname = new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top = new FormAttachment(0, margin);\n\t\tfdStepname.right = new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t/*************************************************\n\t\t * // GOOGLE ANALYTICS CONNECTION GROUP\n\t\t *************************************************/\n\n\t\tGroup gConnect = new Group(shell, SWT.SHADOW_ETCHED_IN);\n\t\tgConnect.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ConnectGroup.Label\"));\n\t\tFormLayout gConnectLayout = new FormLayout();\n\t\tgConnectLayout.marginWidth = 3;\n\t\tgConnectLayout.marginHeight = 3;\n\t\tgConnect.setLayout(gConnectLayout);\n\t\tprops.setLook(gConnect);\n\t\t\n\t\t// Google Analytics app name\n\t\twlGaAppName = new Label(gConnect, SWT.RIGHT);\n\t\twlGaAppName.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.AppName.Label\"));\n\t\tprops.setLook(wlGaAppName);\n\t\tFormData fdlGaAppName = new FormData();\n\t\tfdlGaAppName.top = new FormAttachment(0, margin);\n\t\tfdlGaAppName.left = new FormAttachment(0, 0);\n\t\tfdlGaAppName.right = new FormAttachment(middle, -margin);\n\t\twlGaAppName.setLayoutData(fdlGaAppName);\n\t\twGaAppName = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twGaAppName.addModifyListener(lsMod);\n\t\twGaAppName.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.AppName.Tooltip\"));\n\t\tprops.setLook(wGaAppName);\n\t\tFormData fdGaAppName = new FormData();\n\t\tfdGaAppName.top = new FormAttachment(0, margin);\n\t\tfdGaAppName.left = new FormAttachment(middle, 0);\n\t\tfdGaAppName.right = new FormAttachment(100, 0);\n\t\twGaAppName.setLayoutData(fdGaAppName);\t\t\n\n\t\t// Google Analytics Email\n\t\twlGaEmail = new Label(gConnect, SWT.RIGHT);\n\t\twlGaEmail.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Email.Label\"));\n\t\tprops.setLook(wlGaEmail);\n\t\tFormData fdlGaEmail = new FormData();\n\t\tfdlGaEmail.top = new FormAttachment(wGaAppName, margin);\n\t\tfdlGaEmail.left = new FormAttachment(0, 0);\n\t\tfdlGaEmail.right = new FormAttachment(middle, -margin);\n\t\twlGaEmail.setLayoutData(fdlGaEmail);\n\t\twGaEmail = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twGaEmail.addModifyListener(lsMod);\n\t\twGaEmail.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Email.Tooltip\"));\n\t\tprops.setLook(wGaEmail);\n\t\tFormData fdGaEmail = new FormData();\n\t\tfdGaEmail.top = new FormAttachment(wGaAppName, margin);\n\t\tfdGaEmail.left = new FormAttachment(middle, 0);\n\t\tfdGaEmail.right = new FormAttachment(100, 0);\n\t\twGaEmail.setLayoutData(fdGaEmail);\n\n\t\t// Google Analytics Password\n\t\twlGaPassword = new Label(gConnect, SWT.RIGHT);\n\t\twlGaPassword.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Password.Label\"));\n\t\tprops.setLook(wlGaPassword);\n\t\tFormData fdlGaPassword = new FormData();\n\t\tfdlGaPassword.top = new FormAttachment(wGaEmail, margin);\n\t\tfdlGaPassword.left = new FormAttachment(0, 0);\n\t\tfdlGaPassword.right = new FormAttachment(middle, -margin);\n\t\twlGaPassword.setLayoutData(fdlGaPassword);\n\t\twGaPassword = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.PASSWORD);\n\t\twGaPassword.addModifyListener(lsMod);\n\t\twGaPassword.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Password.Tooltip\"));\n\t\tprops.setLook(wGaPassword);\n\t\tFormData fdGaPassword = new FormData();\n\t\tfdGaPassword.top = new FormAttachment(wGaEmail, margin);\n\t\tfdGaPassword.left = new FormAttachment(middle, 0);\n\t\tfdGaPassword.right = new FormAttachment(100, 0);\n\t\twGaPassword.setLayoutData(fdGaPassword);\n\n\t\t// Google Analytics Api Key\n\t\tLabel wlGaApiKey = new Label(gConnect, SWT.RIGHT);\n\t\twlGaApiKey.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ApiKey.Label\"));\n\t\tprops.setLook(wlGaApiKey);\n\t\tFormData fdlGaApiKey = new FormData();\n\t\tfdlGaApiKey.top = new FormAttachment(wGaPassword, margin);\n\t\tfdlGaApiKey.left = new FormAttachment(0, 0);\n\t\tfdlGaApiKey.right = new FormAttachment(middle, -margin);\n\t\twlGaApiKey.setLayoutData(fdlGaApiKey);\n\t\twGaApiKey = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.PASSWORD);\n\t\twGaApiKey.addModifyListener(lsMod);\n\t\twGaApiKey.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ApiKey.Tooltip\"));\n\t\tprops.setLook(wGaApiKey);\n\t\tFormData fdGaApiKey = new FormData();\n\t\tfdGaApiKey.top = new FormAttachment(wGaPassword, margin);\n\t\tfdGaApiKey.left = new FormAttachment(middle, 0);\n\t\tfdGaApiKey.right = new FormAttachment(100, 0);\n\t\twGaApiKey.setLayoutData(fdGaApiKey);\t\t\n\t\t\n\t\t// custom profile definition\n\t\twlGaCustomProfile = new Label(gConnect, SWT.RIGHT);\n\t\twlGaCustomProfile.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.CustomProfileEnabled.Label\"));\n\t\tprops.setLook(wlGaCustomProfile);\n\t\tFormData fdlGaCustomProfile = new FormData();\n\t\tfdlGaCustomProfile.top = new FormAttachment(wGaApiKey, margin);\n\t\tfdlGaCustomProfile.left = new FormAttachment(0, 0);\n\t\tfdlGaCustomProfile.right = new FormAttachment(middle, -margin);\n\t\twlGaCustomProfile.setLayoutData(fdlGaCustomProfile);\n\n\t\twCustomProfileEnabled = new Button(gConnect, SWT.CHECK);\n\t\tprops.setLook(wCustomProfileEnabled);\n\t\twCustomProfileEnabled.pack(true);\n\n\t\tFormData fdCustomProfileEnabled = new FormData();\n\t\tfdCustomProfileEnabled.left = new FormAttachment(middle, 0);\n\t\tfdCustomProfileEnabled.top = new FormAttachment(wGaApiKey, margin);\n\t\twCustomProfileEnabled.setLayoutData(fdCustomProfileEnabled);\n\n\t\twCustomProfileEnabled.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tinput.setChanged();\n\t\t\t\tsetActive();\n\t\t\t\tif (wCustomProfileEnabled.getSelection()) {\n\t\t\t\t\twGaCustomProfile.setFocus();\n\t\t\t\t} else {\n\t\t\t\t\twGaProfile.setFocus();\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\twGaCustomProfile = new TextVar(transMeta, gConnect, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twGaCustomProfile.addModifyListener(lsMod);\n\t\twGaCustomProfile.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.CustomProfile.Tooltip\"));\n\t\tprops.setLook(wGaCustomProfile);\n\n\t\twGaCustomProfileReference = new Link(gConnect, SWT.SINGLE);\n\t\twGaCustomProfileReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wGaCustomProfileReference);\n\t\twGaCustomProfileReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_TABLE_ID_URI);\n\t\t\t}\n\t\t});\n\n\t\twGaCustomProfileReference.pack(true);\n\n\t\tFormData fdGaCustomProfile = new FormData();\n\t\tfdGaCustomProfile.top = new FormAttachment(wGaApiKey, margin);\n\t\tfdGaCustomProfile.left = new FormAttachment(wCustomProfileEnabled, margin);\n\t\tfdGaCustomProfile.right = new FormAttachment(100, -wGaCustomProfileReference.getBounds().width - margin);\n\t\twGaCustomProfile.setLayoutData(fdGaCustomProfile);\n\n\t\tFormData fdGaCustomProfileReference = new FormData();\n\t\tfdGaCustomProfileReference.top = new FormAttachment(wGaApiKey, margin);\n\t\tfdGaCustomProfileReference.left = new FormAttachment(wGaCustomProfile, 0);\n\t\tfdGaCustomProfileReference.right = new FormAttachment(100, 0);\n\t\twGaCustomProfileReference.setLayoutData(fdGaCustomProfileReference);\t\t\n\t\t\n\t\t\n\t\t// Google analytics profile\n\n\t\twlGaProfile = new Label(gConnect, SWT.RIGHT);\n\t\twlGaProfile.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.Label\"));\n\t\tprops.setLook(wlGaProfile);\n\n\t\tFormData fdlGaProfile = new FormData();\n\t\tfdlGaProfile.top = new FormAttachment(wGaCustomProfile, margin);\n\t\tfdlGaProfile.left = new FormAttachment(0, 0);\n\t\tfdlGaProfile.right = new FormAttachment(middle, -margin);\n\t\twlGaProfile.setLayoutData(fdlGaProfile);\n\n\t\twGaProfile = new CCombo(gConnect, SWT.LEFT | SWT.BORDER | SWT.SINGLE | SWT.READ_ONLY);\n\n\t\tprops.setLook(wGaProfile);\n\t\twGaProfile.addModifyListener(lsMod);\n\t\twGaProfile.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.Tooltip\"));\n\n\t\twGetProfiles = new Button(gConnect, SWT.PUSH);\n\t\twGetProfiles.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.GetProfilesButton.Label\"));\n\t\twGetProfiles.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Profile.GetProfilesButton.Tooltip\"));\n\t\tprops.setLook(wGetProfiles);\n\t\twGetProfiles.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tshell.getDisplay().asyncExec(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\treadGaProfiles(wGaEmail.getText(), wGaPassword.getText(), wGaAppName.getText(), wGaApiKey.getText().trim());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\twGetProfiles.pack(true);\n\n\t\tFormData fdGaProfile = new FormData();\n\t\tfdGaProfile.left = new FormAttachment(middle, 0);\n\t\tfdGaProfile.top = new FormAttachment(wGaCustomProfile, margin);\n\t\tfdGaProfile.right = new FormAttachment(100, -wGetProfiles.getBounds().width - margin);\n\t\twGaProfile.setLayoutData(fdGaProfile);\n\n\t\tFormData fdGetProfiles = new FormData();\n\t\tfdGetProfiles.left = new FormAttachment(wGaProfile, 0);\n\t\tfdGetProfiles.top = new FormAttachment(wGaCustomProfile, margin);\n\t\tfdGetProfiles.right = new FormAttachment(100, 0);\n\t\twGetProfiles.setLayoutData(fdGetProfiles);\n\t\t\n\t\t\n\t\t\n\n\t\tFormData fdConnect = new FormData();\n\t\tfdConnect.left = new FormAttachment(0, 0);\n\t\tfdConnect.right = new FormAttachment(100, 0);\n\t\tfdConnect.top = new FormAttachment(wStepname, margin);\n\t\tgConnect.setLayoutData(fdConnect);\n\t\t\n\t\tgConnect.setTabList(new Control[] {wGaAppName, wGaEmail, wGaPassword, wGaApiKey, wCustomProfileEnabled, wGaCustomProfile, wGaProfile, wGetProfiles});\n\n\t\t/*************************************************\n\t\t * // GOOGLE ANALYTICS QUERY GROUP\n\t\t *************************************************/\n\n\t\tGroup gQuery = new Group(shell, SWT.SHADOW_ETCHED_IN);\n\t\tgQuery.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.QueryGroup.Label\"));\n\t\tFormLayout gQueryLayout = new FormLayout();\n\t\tgQueryLayout.marginWidth = 3;\n\t\tgQueryLayout.marginHeight = 3;\n\t\tgQuery.setLayout(gQueryLayout);\n\t\tprops.setLook(gQuery);\n\n\t\t// query start date\n\t\twlQuStartDate = new Label(gQuery, SWT.RIGHT);\n\t\twlQuStartDate.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.StartDate.Label\"));\n\t\tprops.setLook(wlQuStartDate);\n\t\tFormData fdlQuStartDate = new FormData();\n\t\tfdlQuStartDate.top = new FormAttachment(0, margin);\n\t\tfdlQuStartDate.left = new FormAttachment(0, 0);\n\t\tfdlQuStartDate.right = new FormAttachment(middle, -margin);\n\t\twlQuStartDate.setLayoutData(fdlQuStartDate);\n\t\twQuStartDate = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuStartDate.addModifyListener(lsMod);\n\t\twQuStartDate.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.StartDate.Tooltip\"));\n\t\tprops.setLook(wQuStartDate);\n\t\tFormData fdQuStartDate = new FormData();\n\t\tfdQuStartDate.top = new FormAttachment(0, margin);\n\t\tfdQuStartDate.left = new FormAttachment(middle, 0);\n\t\tfdQuStartDate.right = new FormAttachment(100, 0);\n\t\twQuStartDate.setLayoutData(fdQuStartDate);\n\n\t\t// query end date\n\t\twlQuEndDate = new Label(gQuery, SWT.RIGHT);\n\t\twlQuEndDate.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.EndDate.Label\"));\n\t\tprops.setLook(wlQuEndDate);\n\t\tFormData fdlQuEndDate = new FormData();\n\t\tfdlQuEndDate.top = new FormAttachment(wQuStartDate, margin);\n\t\tfdlQuEndDate.left = new FormAttachment(0, 0);\n\t\tfdlQuEndDate.right = new FormAttachment(middle, -margin);\n\t\twlQuEndDate.setLayoutData(fdlQuEndDate);\n\t\twQuEndDate = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuEndDate.addModifyListener(lsMod);\n\t\twQuEndDate.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.EndDate.Tooltip\"));\n\t\tprops.setLook(wQuEndDate);\n\t\tFormData fdQuEndDate = new FormData();\n\t\tfdQuEndDate.top = new FormAttachment(wQuStartDate, margin);\n\t\tfdQuEndDate.left = new FormAttachment(middle, 0);\n\t\tfdQuEndDate.right = new FormAttachment(100, 0);\n\t\twQuEndDate.setLayoutData(fdQuEndDate);\n\n\t\t// query dimensions\n\t\twlQuDimensions = new Label(gQuery, SWT.RIGHT);\n\t\twlQuDimensions.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Dimensions.Label\"));\n\t\tprops.setLook(wlQuDimensions);\n\t\tFormData fdlQuDimensions = new FormData();\n\t\tfdlQuDimensions.top = new FormAttachment(wQuEndDate, margin);\n\t\tfdlQuDimensions.left = new FormAttachment(0, 0);\n\t\tfdlQuDimensions.right = new FormAttachment(middle, -margin);\n\t\twlQuDimensions.setLayoutData(fdlQuDimensions);\n\t\twQuDimensions = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuDimensions.addModifyListener(lsMod);\n\t\twQuDimensions.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Dimensions.Tooltip\"));\n\t\tprops.setLook(wQuDimensions);\n\n\t\twQuDimensionsReference = new Link(gQuery, SWT.SINGLE);\n\n\t\twQuDimensionsReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuDimensionsReference);\n\t\twQuDimensionsReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_DIMENSIONS_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuDimensionsReference.pack(true);\n\n\t\tFormData fdQuDimensions = new FormData();\n\t\tfdQuDimensions.top = new FormAttachment(wQuEndDate, margin);\n\t\tfdQuDimensions.left = new FormAttachment(middle, 0);\n\t\tfdQuDimensions.right = new FormAttachment(100, -wQuDimensionsReference.getBounds().width - margin);\n\t\twQuDimensions.setLayoutData(fdQuDimensions);\n\n\t\tFormData fdQuDimensionsReference = new FormData();\n\t\tfdQuDimensionsReference.top = new FormAttachment(wQuEndDate, margin);\n\t\tfdQuDimensionsReference.left = new FormAttachment(wQuDimensions, 0);\n\t\tfdQuDimensionsReference.right = new FormAttachment(100, 0);\n\t\twQuDimensionsReference.setLayoutData(fdQuDimensionsReference);\n\n\t\t// query Metrics\n\t\twlQuMetrics = new Label(gQuery, SWT.RIGHT);\n\t\twlQuMetrics.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Metrics.Label\"));\n\t\tprops.setLook(wlQuMetrics);\n\t\tFormData fdlQuMetrics = new FormData();\n\t\tfdlQuMetrics.top = new FormAttachment(wQuDimensions, margin);\n\t\tfdlQuMetrics.left = new FormAttachment(0, 0);\n\t\tfdlQuMetrics.right = new FormAttachment(middle, -margin);\n\t\twlQuMetrics.setLayoutData(fdlQuMetrics);\n\t\twQuMetrics = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuMetrics.addModifyListener(lsMod);\n\t\twQuMetrics.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Metrics.Tooltip\"));\n\t\tprops.setLook(wQuMetrics);\n\n\t\twQuMetricsReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuMetricsReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuMetricsReference);\n\t\twQuMetricsReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_METRICS_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuMetricsReference.pack(true);\n\n\t\tFormData fdQuMetrics = new FormData();\n\t\tfdQuMetrics.top = new FormAttachment(wQuDimensions, margin);\n\t\tfdQuMetrics.left = new FormAttachment(middle, 0);\n\t\tfdQuMetrics.right = new FormAttachment(100, -wQuMetricsReference.getBounds().width - margin);\n\t\twQuMetrics.setLayoutData(fdQuMetrics);\n\n\t\tFormData fdQuMetricsReference = new FormData();\n\t\tfdQuMetricsReference.top = new FormAttachment(wQuDimensions, margin);\n\t\tfdQuMetricsReference.left = new FormAttachment(wQuMetrics, 0);\n\t\tfdQuMetricsReference.right = new FormAttachment(100, 0);\n\t\twQuMetricsReference.setLayoutData(fdQuMetricsReference);\n\n\t\t// query filters\n\t\twlQuFilters = new Label(gQuery, SWT.RIGHT);\n\t\twlQuFilters.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Filters.Label\"));\n\t\tprops.setLook(wlQuFilters);\n\t\tFormData fdlQuFilters = new FormData();\n\t\tfdlQuFilters.top = new FormAttachment(wQuMetrics, margin);\n\t\tfdlQuFilters.left = new FormAttachment(0, 0);\n\t\tfdlQuFilters.right = new FormAttachment(middle, -margin);\n\t\twlQuFilters.setLayoutData(fdlQuFilters);\n\t\twQuFilters = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuFilters.addModifyListener(lsMod);\n\t\twQuFilters.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Filters.Tooltip\"));\n\t\tprops.setLook(wQuFilters);\n\n\t\twQuFiltersReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuFiltersReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuFiltersReference);\n\t\twQuFiltersReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_FILTERS_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuFiltersReference.pack(true);\n\n\t\tFormData fdQuFilters = new FormData();\n\t\tfdQuFilters.top = new FormAttachment(wQuMetrics, margin);\n\t\tfdQuFilters.left = new FormAttachment(middle, 0);\n\t\tfdQuFilters.right = new FormAttachment(100, -wQuFiltersReference.getBounds().width - margin);\n\t\twQuFilters.setLayoutData(fdQuFilters);\n\n\t\tFormData fdQuFiltersReference = new FormData();\n\t\tfdQuFiltersReference.top = new FormAttachment(wQuMetrics, margin);\n\t\tfdQuFiltersReference.left = new FormAttachment(wQuFilters, 0);\n\t\tfdQuFiltersReference.right = new FormAttachment(100, 0);\n\t\twQuFiltersReference.setLayoutData(fdQuFiltersReference);\n\n\t\t// query Sort\n\t\twlQuSort = new Label(gQuery, SWT.RIGHT);\n\t\twlQuSort.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Sort.Label\"));\n\t\tprops.setLook(wlQuSort);\n\t\tFormData fdlQuSort = new FormData();\n\t\tfdlQuSort.top = new FormAttachment(wQuFilters, margin);\n\t\tfdlQuSort.left = new FormAttachment(0, 0);\n\t\tfdlQuSort.right = new FormAttachment(middle, -margin);\n\t\twlQuSort.setLayoutData(fdlQuSort);\n\t\twQuSort = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuSort.addModifyListener(lsMod);\n\t\twQuSort.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Sort.Tooltip\"));\n\t\tprops.setLook(wQuSort);\n\n\t\twQuSortReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuSortReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuSortReference);\n\t\twQuSortReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_SORT_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuSortReference.pack(true);\n\n\t\tFormData fdQuSort = new FormData();\n\t\tfdQuSort.top = new FormAttachment(wQuFilters, margin);\n\t\tfdQuSort.left = new FormAttachment(middle, 0);\n\t\tfdQuSort.right = new FormAttachment(100, -wQuSortReference.getBounds().width - margin);\n\t\twQuSort.setLayoutData(fdQuSort);\n\n\t\tFormData fdQuSortReference = new FormData();\n\t\tfdQuSortReference.top = new FormAttachment(wQuFilters, margin);\n\t\tfdQuSortReference.left = new FormAttachment(wQuSort, 0);\n\t\tfdQuSortReference.right = new FormAttachment(100, 0);\n\t\twQuSortReference.setLayoutData(fdQuSortReference);\n\n\t\t// custom segment definition\n\t\twlQuUseSegment = new Label(gQuery, SWT.RIGHT);\n\t\twlQuUseSegment.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.UseSegment.Label\"));\n\t\tprops.setLook(wlQuUseSegment);\n\t\tFormData fdlQuUseSegment = new FormData();\n\t\tfdlQuUseSegment.top = new FormAttachment(wQuSort, margin);\n\t\tfdlQuUseSegment.left = new FormAttachment(0, 0);\n\t\tfdlQuUseSegment.right = new FormAttachment(middle, -margin);\n\t\twlQuUseSegment.setLayoutData(fdlQuUseSegment);\n\n\t\twUseSegmentEnabled = new Button(gQuery, SWT.CHECK);\n\t\tprops.setLook(wUseSegmentEnabled);\n\t\twUseSegmentEnabled.pack(true);\n\n\t\tFormData fdUseSegmentEnabled = new FormData();\n\t\tfdUseSegmentEnabled.left = new FormAttachment(middle, 0);\n\t\tfdUseSegmentEnabled.top = new FormAttachment(wQuSort, margin);\n\t\twUseSegmentEnabled.setLayoutData(fdUseSegmentEnabled);\n\n\t\twUseSegmentEnabled.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tinput.setChanged();\n\t\t\t\tsetActive();\n\t\t\t\tif (wUseSegmentEnabled.getSelection()){\n\t\t\t\t\tif (wCustomSegmentEnabled.getSelection()) {\n\t\t\t\t\t\twQuCustomSegment.setFocus();\n\t\t\t\t\t} else {\n\t\t\t\t\t\twQuSegment.setFocus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\t\t\n\t\t\n\t\t// custom segment definition\n\t\twlQuCustomSegment = new Label(gQuery, SWT.RIGHT);\n\t\twlQuCustomSegment.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.CustomSegment.Label\"));\n\t\tprops.setLook(wlQuCustomSegment);\n\t\tFormData fdlQuCustomSegment = new FormData();\n\t\tfdlQuCustomSegment.top = new FormAttachment(wUseSegmentEnabled, margin);\n\t\tfdlQuCustomSegment.left = new FormAttachment(0, 0);\n\t\tfdlQuCustomSegment.right = new FormAttachment(middle, -margin);\n\t\twlQuCustomSegment.setLayoutData(fdlQuCustomSegment);\n\n\t\twCustomSegmentEnabled = new Button(gQuery, SWT.CHECK);\n\t\tprops.setLook(wCustomSegmentEnabled);\n\t\twCustomSegmentEnabled.pack(true);\n\n\t\tFormData fdCustomSegmentEnabled = new FormData();\n\t\tfdCustomSegmentEnabled.left = new FormAttachment(middle, 0);\n\t\tfdCustomSegmentEnabled.top = new FormAttachment(wUseSegmentEnabled, margin);\n\t\twCustomSegmentEnabled.setLayoutData(fdCustomSegmentEnabled);\n\n\t\twCustomSegmentEnabled.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tinput.setChanged();\n\t\t\t\tsetActive();\n\t\t\t\tif (wCustomSegmentEnabled.getSelection()) {\n\t\t\t\t\twQuCustomSegment.setFocus();\n\t\t\t\t} else {\n\t\t\t\t\twQuSegment.setFocus();\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\twQuCustomSegment = new TextVar(transMeta, gQuery, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twQuCustomSegment.addModifyListener(lsMod);\n\t\twQuCustomSegment.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.CustomSegment.Tooltip\"));\n\t\tprops.setLook(wQuCustomSegment);\n\n\t\twQuCustomSegmentReference = new Link(gQuery, SWT.SINGLE);\n\t\twQuCustomSegmentReference.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Reference.Label\"));\n\t\tprops.setLook(wQuCustomSegmentReference);\n\t\twQuCustomSegmentReference.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_SEGMENT_URI);\n\t\t\t}\n\t\t});\n\n\t\twQuCustomSegmentReference.pack(true);\n\n\t\tFormData fdQuCustomSegment = new FormData();\n\t\tfdQuCustomSegment.top = new FormAttachment(wUseSegmentEnabled, margin);\n\t\tfdQuCustomSegment.left = new FormAttachment(wCustomSegmentEnabled, margin);\n\t\tfdQuCustomSegment.right = new FormAttachment(100, -wQuCustomSegmentReference.getBounds().width - margin);\n\t\twQuCustomSegment.setLayoutData(fdQuCustomSegment);\n\n\t\tFormData fdQuCustomSegmentReference = new FormData();\n\t\tfdQuCustomSegmentReference.top = new FormAttachment(wUseSegmentEnabled, margin);\n\t\tfdQuCustomSegmentReference.left = new FormAttachment(wQuCustomSegment, 0);\n\t\tfdQuCustomSegmentReference.right = new FormAttachment(100, 0);\n\t\twQuCustomSegmentReference.setLayoutData(fdQuCustomSegmentReference);\n\n\t\t// segment selection\n\n\t\twlQuSegment = new Label(gQuery, SWT.RIGHT);\n\t\twlQuSegment.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Segment.Label\"));\n\t\tprops.setLook(wlQuSegment);\n\n\t\tFormData fdlQuSegment = new FormData();\n\t\tfdlQuSegment.top = new FormAttachment(wQuCustomSegment, margin);\n\t\tfdlQuSegment.left = new FormAttachment(0, 0);\n\t\tfdlQuSegment.right = new FormAttachment(middle, -margin);\n\t\twlQuSegment.setLayoutData(fdlQuSegment);\n\n\t\twQuSegment = new CCombo(gQuery, SWT.LEFT | SWT.BORDER | SWT.SINGLE | SWT.READ_ONLY);\n\n\t\tprops.setLook(wQuSegment);\n\t\twQuSegment.addModifyListener(lsMod);\n\t\twQuSegment.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.Segment.Tooltip\"));\n\n\t\twGetSegments = new Button(gQuery, SWT.PUSH);\n\t\twGetSegments.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.GetSegmentsButton.Label\"));\n\t\twGetSegments.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Query.GetSegmentsButton.Tooltip\"));\n\t\tprops.setLook(wGetSegments);\n\t\twGetSegments.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tshell.getDisplay().asyncExec(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\treadGaSegments(wGaEmail.getText(), wGaPassword.getText(), wGaAppName.getText(), wGaApiKey.getText().trim());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\twGetSegments.pack(true);\n\n\t\tFormData fdQuSegment = new FormData();\n\t\tfdQuSegment.left = new FormAttachment(middle, 0);\n\t\tfdQuSegment.top = new FormAttachment(wQuCustomSegment, margin);\n\t\tfdQuSegment.right = new FormAttachment(100, -wGetSegments.getBounds().width - margin);\n\t\twQuSegment.setLayoutData(fdQuSegment);\n\n\t\tFormData fdGetSegments = new FormData();\n\t\tfdGetSegments.left = new FormAttachment(wQuSegment, 0);\n\t\tfdGetSegments.top = new FormAttachment(wQuCustomSegment, margin);\n\t\tfdGetSegments.right = new FormAttachment(100, 0);\n\t\twGetSegments.setLayoutData(fdGetSegments);\n\n\t\tFormData fdQueryGroup = new FormData();\n\t\tfdQueryGroup.left = new FormAttachment(0, 0);\n\t\tfdQueryGroup.right = new FormAttachment(100, 0);\n\t\tfdQueryGroup.top = new FormAttachment(gConnect, margin);\n\t\tgQuery.setLayoutData(fdQueryGroup);\n\n\t\tgQuery.setTabList(new Control[] { wQuStartDate, wQuEndDate, wQuDimensions, wQuMetrics, wQuFilters, wQuSort, wUseSegmentEnabled, wCustomSegmentEnabled, wQuCustomSegment, wQuSegment, wGetSegments });\n\n\t\t// Limit input ...\n\t\twlLimit=new Label(shell, SWT.RIGHT);\n\t\twlLimit.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.LimitSize.Label\"));\n \t\tprops.setLook(wlLimit);\n\t\tFormData fdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\tfdlLimit.bottom = new FormAttachment(100, -50);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twLimit.setToolTipText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.LimitSize.Tooltip\"));\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tFormData fdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\tfdLimit.bottom = new FormAttachment(100, -50);\n\t\t\n\t\twLimit.setLayoutData(fdLimit);\t\t\n\t\t\n\t\t/*************************************************\n\t\t * // KEY / LOOKUP TABLE\n\t\t *************************************************/\n\n\t\twlFields = new Link(shell, SWT.NONE);\n\t\twlFields.setText(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.Return.Label\"));\n\t\tprops.setLook(wlFields);\n\t\twlFields.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tBareBonesBrowserLaunch.openURL(REFERENCE_DIMENSION_AND_METRIC_URI);\n\t\t\t}\n\t\t});\n\t\t\n\t\tFormData fdlReturn = new FormData();\n\t\tfdlReturn.left = new FormAttachment(0, 0);\n\t\tfdlReturn.top = new FormAttachment(gQuery, margin);\n\t\twlFields.setLayoutData(fdlReturn);\n\n\t\tint fieldWidgetCols = 5;\n\t\tint fieldWidgetRows = (input.getFeedField() != null ? input.getFeedField().length : 1);\n\n\t\tColumnInfo[] ciKeys = new ColumnInfo[fieldWidgetCols];\n\t\tciKeys[0] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.FeedFieldType\"), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{GaInputStepMeta.FIELD_TYPE_DIMENSION, GaInputStepMeta.FIELD_TYPE_METRIC, GaInputStepMeta.FIELD_TYPE_CONFIDENCE_INTERVAL, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_PROPERTY, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_FIELD}, true);\n\t\tciKeys[1] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.FeedField\"), ColumnInfo.COLUMN_TYPE_TEXT, false, false);\n\t\tciKeys[1].setUsingVariables(true);\n\t\tciKeys[2] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.RenameTo\"), ColumnInfo.COLUMN_TYPE_TEXT, false, false);\n\t\tciKeys[3] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.Type\"), ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes());\n        ciKeys[4] = new ColumnInfo(BaseMessages.getString(PKG, \"GoogleAnalyticsDialog.ColumnInfo.Format\"), ColumnInfo.COLUMN_TYPE_FORMAT, 4);\n\n\t\twFields = new TableView(transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, ciKeys, fieldWidgetRows, lsMod, props);\n\n\t\tFormData fdReturn = new FormData();\n\t\tfdReturn.left = new FormAttachment(0, 0);\n\t\tfdReturn.top = new FormAttachment(wlFields, margin);\n\t\tfdReturn.right = new FormAttachment(100, 0);\n\t\tfdReturn.bottom = new FormAttachment(wLimit, -margin);\n\t\twFields.setLayoutData(fdReturn);\n\n\t\t/*************************************************\n\t\t * // OK AND CANCEL BUTTONS\n\t\t *************************************************/\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\n\t\t\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(BaseMessages.getString(PKG, \"System.Button.GetFields\"));\n\t\t\n\t\twGet.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event e) {\n\n\t\t\t\tDataQuery query = getPreviewQuery();\n\t\t\t\tquery.setMaxResults(1);\n\n\t\t\t\tString email = transMeta.environmentSubstitute(wGaEmail.getText());\n\t\t\t\tString pass = transMeta.environmentSubstitute(wGaPassword.getText());\n\t\t\t\t\n\n\t\t\t\tAnalyticsService analyticsService = new AnalyticsService(transMeta.environmentSubstitute(wGaAppName.getText()));\n\t\t\t\t\n\t\t\t\ttry{\n\t\t\t\t\n\t\t\t\t\tanalyticsService.setUserCredentials(email, pass);\n\t\t\t\t\tDataFeed dataFeed = analyticsService.getFeed(query.getUrl(), DataFeed.class);\n\t\t\t\t\t\n\t\t\t\t\tif (dataFeed.getEntries().size() < 1){\n\t\t\t\t\t\t\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\t\tmb.setText(\"Query yields empty feed\");\n\t\t\t\t\t\tmb.setMessage(\"The feed did not give any results. Please specify a query that returns data.\");\n\t\t\t\t\t\tmb.open();\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tDataEntry entry = dataFeed.getEntries().get(0);\n\t\t\t\t\t\n\t\t\t\t\tList<Dimension> dims = entry.getDimensions();\n\t\t\t\t\tList<Metric> metrics = entry.getMetrics();\n\t\t\t\t\tList<Property> dsprops = new ArrayList<Property>();\n\t\t\t\t\tint dataSourceFields = 0;\n\t\t\t\t\tif (dataFeed.getDataSources().size() > 0){\n\t\t\t\t\t\tdsprops = dataFeed.getDataSources().get(0).getProperties();\n\t\t\t\t\t\tdataSourceFields=2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twFields.table.setItemCount(dims.size()+metrics.size()*2+dsprops.size()+dataSourceFields);\n\t\t\t\t\t\n\t\t\t\t\tint i = 0;\n\t\t\t\t\t\n\t\t\t\t\t// Fill Dimension Fields\n\t\t\t\t\tfor (Dimension d : dims){\n\t\t\t\t\t\t\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DIMENSION);\n\t\t\t\t\t\titem.setText(2, d.getName());\n\t\t\t\t\t\titem.setText(3, d.getName());\n\n\t\t\t\t\t\t// recognize date dimension\n\t\t\t\t\t\tif (d.getName().equalsIgnoreCase(\"ga:date\")){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_DATE));\n\t\t\t\t\t\t\titem.setText(5, \"yyyyMMdd\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (d.getName().equalsIgnoreCase(\"ga:daysSinceLastVisit\") || d.getName().equalsIgnoreCase(\"ga:visitLength\") || d.getName().equalsIgnoreCase(\"ga:visitCount\")){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_INTEGER));\n\t\t\t\t\t\t\titem.setText(5, \"#;-#\");\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\telse if (d.getName().equalsIgnoreCase(\"ga:latitude\") || d.getName().equalsIgnoreCase(\"ga:longitude\")){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER));\n\t\t\t\t\t\t\titem.setText(5, \"#.#;-#.#\");\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Fill Metric fields\n\t\t\t\t\tfor (Metric m: metrics){\n\t\t\t\t\t\t\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_METRIC);\n\t\t\t\t\t\titem.setText(2, m.getName());\n\t\t\t\t\t\titem.setText(3, m.getName());\n\n\t\t\t\t\t\t// depending on type\n\t\t\t\t\t\tif (m.getType().compareToIgnoreCase(\"currency\") == 0 || m.getType().compareToIgnoreCase(\"float\") == 0 || m.getType().compareToIgnoreCase(\"percent\") == 0 || m.getType().compareToIgnoreCase(\"us_currency\") == 0){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER));\n\t\t\t\t\t\t\titem.setText(5, \"#.#;-#.#\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(m.getType().compareToIgnoreCase(\"time\") == 0 || m.getType().compareToIgnoreCase(\"integer\") == 0){\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_INTEGER));\n\t\t\t\t\t\t\titem.setText(5, \"#;-#\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\titem = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_CONFIDENCE_INTERVAL);\n\t\t\t\t\t\titem.setText(2, m.getName());\n\t\t\t\t\t\titem.setText(3, m.getName()+\"#confidenceInterval\");\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER));\t\n\t\t\t\t\t\titem.setText(5, \"#.#;-#.#\");\n\t\t\t\t\t\t\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Fill ds property fields\n\t\t\t\t\tfor (Property prop:dsprops){\n\t\t\t\t\t\t\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_PROPERTY);\n\t\t\t\t\t\titem.setText(2, prop.getName());\n\t\t\t\t\t\titem.setText(3, prop.getName());\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t// Fill ds field fields\n\t\t\t\t\tif (dataFeed.getDataSources().size() > 0){\n\t\t\t\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_FIELD);\n\t\t\t\t\t\titem.setText(2, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_ID);\n\t\t\t\t\t\titem.setText(3, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_ID);\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\ti++;\n\n\t\t\t\t\t\titem = wFields.table.getItem(i);\n\t\t\t\t\t\titem.setText(1, GaInputStepMeta.FIELD_TYPE_DATA_SOURCE_FIELD);\n\t\t\t\t\t\titem.setText(2, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_NAME);\n\t\t\t\t\t\titem.setText(3, GaInputStepMeta.FIELD_DATA_SOURCE_TABLE_NAME);\n\t\t\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));\n\t\t\t\t\t\titem.setText(5, \"\");\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t            wFields.removeEmptyRows();\n\t\t            wFields.setRowNums();\n\t\t            wFields.optWidth(true);\n\t\t            input.setChanged();\n\n\t\t\t\t} catch (AuthenticationException e1) {\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\tmb.setText(\"Authentication Error\");\n\t\t\t\t\tmb.setMessage(\"Could not authenticate. Please check the credentials and ensure that there's no network connectivity problem.\\n\\n\"+e1.getMessage());\n\t\t\t\t\tmb.open();\n\t\t\t\t\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\treturn;\n\n\t\t\t\t} catch (IOException e2) {\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\tmb.setText(\"IO Error\");\n\t\t\t\t\tmb.setMessage(\"Could not contact Google Analytics service. Please make sure that there's no network connectivity problem.\");\n\t\t\t\t\tmb.open();\n\t\t\t\t\te2.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t} catch (ServiceException e3) {\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR);\n\t\t\t\t\tmb.setText(\"Service Error\");\n\t\t\t\t\tmb.setMessage(\"Google Service Error\\n\\n\"+e3.getMessage());\n\t\t\t\t\tmb.open();\n\t\t\t\t\te3.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t});\t\t\n\n\t\twPreview = new Button(shell, SWT.PUSH);\n\t\twPreview.setText(BaseMessages.getString(PKG, \"System.Button.Preview\"));\t\t\n\t\twPreview.addListener(SWT.Selection, new Listener() {\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event ev) {\n\t\t\t\tpreview();\n\t\t\t}\n\t\t});\n\t\t\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wGet, wPreview, wCancel }, margin, wLimit);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n\n\t\t/*************************************************\n\t\t * // DEFAULT ACTION LISTENERS\n\t\t *************************************************/\n\n\t\tlsDef = new SelectionAdapter() {\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twStepname.addSelectionListener(lsDef);\n\t\twGaEmail.addSelectionListener(lsDef);\n\t\twGaPassword.addSelectionListener(lsDef);\n\t\twGaApiKey.addSelectionListener(lsDef);\n\t\twGaCustomProfile.addSelectionListener(lsDef);\n\t\twQuStartDate.addSelectionListener(lsDef);\n\t\twQuEndDate.addSelectionListener(lsDef);\n\t\twQuDimensions.addSelectionListener(lsDef);\n\t\twQuMetrics.addSelectionListener(lsDef);\n\t\twQuFilters.addSelectionListener(lsDef);\n\t\twQuSort.addSelectionListener(lsDef);\n\t\twQuCustomSegment.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter() {\n\t\t\tpublic void shellClosed(ShellEvent e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\n\t\t/*************************************************\n\t\t * // POPULATE AND OPEN DIALOG\n\t\t *************************************************/\n\n\t\tgetData();\n\n\t\tinput.setChanged(backupChanged);\n\t\twStepname.setFocus();\n\n\t\tshell.setTabList(new Control[]{wStepname, gConnect, gQuery, wFields});\n\t\tshell.open();\n\n\t\twhile (!shell.isDisposed()) {\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getData() {\n\n\t\twStepname.selectAll();\n\n\t\tif (input.getGaAppName() != null){\n\t\t\twGaAppName.setText(input.getGaAppName());\n\t\t}\n\t\t\n\t\tif (input.getGaEmail() != null) {\n\t\t\twGaEmail.setText(input.getGaEmail());\n\t\t}\n\n\t\tif (input.getGaPassword() != null) {\n\t\t\twGaPassword.setText(input.getGaPassword());\n\t\t}\n\t\t\n\t\tif (input.getGaApiKey() != null){\n\t\t\twGaApiKey.setText(input.getGaApiKey());\n\t\t}\n\n\t\tif (input.getGaProfileName() != null) {\n\t\t\twGaProfile.setText(input.getGaProfileName());\n\t\t\tprofileTableIds.clear();\n\t\t\tprofileTableIds.put(input.getGaProfileName(), input.getGaProfileTableId());\n\t\t}\n\n\t\tif (input.isUseCustomTableId()){\n\t\t\twCustomProfileEnabled.setSelection(true);\n\t\t}\n\t\telse{\n\t\t\twCustomProfileEnabled.setSelection(false);\n\t\t}\n\t\t\n\t\tif (input.getGaCustomTableId() != null){\n\t\t\twGaCustomProfile.setText(input.getGaCustomTableId());\n\t\t}\n\t\t\n\t\tif (input.getStartDate() != null) {\n\t\t\twQuStartDate.setText(input.getStartDate());\n\t\t}\n\n\t\tif (input.getEndDate() != null) {\n\t\t\twQuEndDate.setText(input.getEndDate());\n\t\t}\n\n\t\tif (input.getDimensions() != null) {\n\t\t\twQuDimensions.setText(input.getDimensions());\n\t\t}\n\n\t\tif (input.getMetrics() != null) {\n\t\t\twQuMetrics.setText(input.getMetrics());\n\t\t}\n\n\t\tif (input.getFilters() != null) {\n\t\t\twQuFilters.setText(input.getFilters());\n\t\t}\n\n\t\tif (input.getSort() != null) {\n\t\t\twQuSort.setText(input.getSort());\n\t\t}\n\n\t\tif (input.isUseCustomSegment()) {\n\t\t\twCustomSegmentEnabled.setSelection(true);\n\t\t} else {\n\t\t\twCustomSegmentEnabled.setSelection(false);\n\t\t}\n\n\t\tif (input.getCustomSegment() != null) {\n\t\t\twQuCustomSegment.setText(input.getCustomSegment());\n\t\t}\n\n\t\tif (input.getSegmentName() != null) {\n\t\t\twQuSegment.setText(input.getSegmentName());\n\t\t\tsegmentIds.clear();\n\t\t\tsegmentIds.put(input.getSegmentName(), input.getSegmentId());\n\t\t}\n\n\t\tif (input.getFeedField() != null) {\n\n\t\t\tfor (int i = 0; i < input.getFeedField().length; i++) {\n\n\t\t\t\tTableItem item = wFields.table.getItem(i);\n\n\t\t\t\tif (input.getFeedFieldType()[i] != null) {\n\t\t\t\t\titem.setText(1, input.getFeedFieldType()[i]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (input.getFeedField()[i] != null) {\n\t\t\t\t\titem.setText(2, input.getFeedField()[i]);\n\t\t\t\t}\n\n\t\t\t\tif (input.getOutputField()[i] != null) {\n\t\t\t\t\titem.setText(3, input.getOutputField()[i]);\n\t\t\t\t}\n\n\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(input.getOutputType()[i]));\n\t\t\t\t\n\t\t\t\tif (input.getConversionMask()[i] != null) {\n\t\t\t\t\titem.setText(5, input.getConversionMask()[i]);\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t}\n\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\n\t\twLimit.setText(input.getRowLimit()+\"\");\n\n\t\tsetActive();\n\t}","id":104105,"modified_method":"public void getData() {\n\n\t\twStepname.selectAll();\n\n\t\tif (input.getGaAppName() != null){\n\t\t\twGaAppName.setText(input.getGaAppName());\n\t\t}\n\t\t\n\t\tif (input.getGaEmail() != null) {\n\t\t\twGaEmail.setText(input.getGaEmail());\n\t\t}\n\n\t\tif (input.getGaPassword() != null) {\n\t\t\twGaPassword.setText(input.getGaPassword());\n\t\t}\n\t\t\n\t\tif (input.getGaApiKey() != null){\n\t\t\twGaApiKey.setText(input.getGaApiKey());\n\t\t}\n\n\t\tif (input.getGaProfileName() != null) {\n\t\t\twGaProfile.setText(input.getGaProfileName());\n\t\t\tprofileTableIds.clear();\n\t\t\tprofileTableIds.put(input.getGaProfileName(), input.getGaProfileTableId());\n\t\t}\n\n\t\tif (input.isUseCustomTableId()){\n\t\t\twCustomProfileEnabled.setSelection(true);\n\t\t}\n\t\telse{\n\t\t\twCustomProfileEnabled.setSelection(false);\n\t\t}\n\t\t\n\t\tif (input.getGaCustomTableId() != null){\n\t\t\twGaCustomProfile.setText(input.getGaCustomTableId());\n\t\t}\n\t\t\n\t\tif (input.getStartDate() != null) {\n\t\t\twQuStartDate.setText(input.getStartDate());\n\t\t}\n\n\t\tif (input.getEndDate() != null) {\n\t\t\twQuEndDate.setText(input.getEndDate());\n\t\t}\n\n\t\tif (input.getDimensions() != null) {\n\t\t\twQuDimensions.setText(input.getDimensions());\n\t\t}\n\n\t\tif (input.getMetrics() != null) {\n\t\t\twQuMetrics.setText(input.getMetrics());\n\t\t}\n\n\t\tif (input.getFilters() != null) {\n\t\t\twQuFilters.setText(input.getFilters());\n\t\t}\n\n\t\tif (input.getSort() != null) {\n\t\t\twQuSort.setText(input.getSort());\n\t\t}\n\n\t\tif (input.isUseSegment()){\n\t\t\twUseSegmentEnabled.setSelection(true);\n\t\t}\n\t\telse{\n\t\t\twUseSegmentEnabled.setSelection(false);\n\t\t}\n\t\t\n\t\tif (input.isUseCustomSegment()) {\n\t\t\twCustomSegmentEnabled.setSelection(true);\n\t\t} else {\n\t\t\twCustomSegmentEnabled.setSelection(false);\n\t\t}\n\n\t\tif (input.getCustomSegment() != null) {\n\t\t\twQuCustomSegment.setText(input.getCustomSegment());\n\t\t}\n\n\t\tif (input.getSegmentName() != null) {\n\t\t\twQuSegment.setText(input.getSegmentName());\n\t\t\tsegmentIds.clear();\n\t\t\tsegmentIds.put(input.getSegmentName(), input.getSegmentId());\n\t\t}\n\n\t\tif (input.getFeedField() != null) {\n\n\t\t\tfor (int i = 0; i < input.getFeedField().length; i++) {\n\n\t\t\t\tTableItem item = wFields.table.getItem(i);\n\n\t\t\t\tif (input.getFeedFieldType()[i] != null) {\n\t\t\t\t\titem.setText(1, input.getFeedFieldType()[i]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (input.getFeedField()[i] != null) {\n\t\t\t\t\titem.setText(2, input.getFeedField()[i]);\n\t\t\t\t}\n\n\t\t\t\tif (input.getOutputField()[i] != null) {\n\t\t\t\t\titem.setText(3, input.getOutputField()[i]);\n\t\t\t\t}\n\n\t\t\t\titem.setText(4, ValueMeta.getTypeDesc(input.getOutputType()[i]));\n\t\t\t\t\n\t\t\t\tif (input.getConversionMask()[i] != null) {\n\t\t\t\t\titem.setText(5, input.getConversionMask()[i]);\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t}\n\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\n\t\twLimit.setText(input.getRowLimit()+\"\");\n\n\t\tsetActive();\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void setActive() {\n\t\tboolean custom = wCustomSegmentEnabled.getSelection();\n\n\t\twQuCustomSegment.setEnabled(custom);\n\t\twQuCustomSegmentReference.setEnabled(custom);\n\t\twQuSegment.setEnabled(!custom);\n\t\twGetSegments.setEnabled(!custom);\n\t\t\n\t\tboolean directTableId = wCustomProfileEnabled.getSelection();\n\t\t\n\t\twGaProfile.setEnabled(!directTableId);\n\t\twGetProfiles.setEnabled(!directTableId);\n\t\twGaCustomProfile.setEnabled(directTableId);\n\t\twGaCustomProfileReference.setEnabled(directTableId);\n\n\t}","id":104106,"modified_method":"protected void setActive() {\n\t\t\n\t\tboolean segment = wUseSegmentEnabled.getSelection();\n\t\twCustomSegmentEnabled.setEnabled(segment);\n\n\t\tif (!segment){\n\t\t\twQuCustomSegment.setEnabled(false);\n\t\t\twQuCustomSegmentReference.setEnabled(false);\n\t\t\twQuSegment.setEnabled(false);\n\t\t\twGetSegments.setEnabled(false);\n\t\t}\n\t\telse{\n\n\t\t\tboolean custom = wCustomSegmentEnabled.getSelection();\n\n\t\t\twQuCustomSegment.setEnabled(custom);\n\t\t\twQuCustomSegmentReference.setEnabled(custom);\n\t\t\twQuSegment.setEnabled(!custom);\n\t\t\twGetSegments.setEnabled(!custom);\n\t\t}\n\t\t\n\t\tboolean directTableId = wCustomProfileEnabled.getSelection();\n\t\t\n\t\twGaProfile.setEnabled(!directTableId);\n\t\twGetProfiles.setEnabled(!directTableId);\n\t\twGaCustomProfile.setEnabled(directTableId);\n\t\twGaCustomProfileReference.setEnabled(directTableId);\n\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected DataQuery getPreviewQuery(){\n\t\t\n\t\tDataQuery query = null;\n\t\ttry {\n\t\t\tquery = new DataQuery(new URL(GaInputStepMeta.GA_DATA_URL));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tex.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tquery.setIds(wCustomProfileEnabled.getSelection()? transMeta.environmentSubstitute(wGaCustomProfile.getText()): profileTableIds.get(wGaProfile.getText()));\n\t\tquery.setStartDate(transMeta.environmentSubstitute(wQuStartDate.getText()));\n\t\tquery.setEndDate(transMeta.environmentSubstitute(wQuEndDate.getText()));\n\t\tquery.setDimensions(transMeta.environmentSubstitute(wQuDimensions.getText()));\n\t\tquery.setMetrics(transMeta.environmentSubstitute(wQuMetrics.getText()));\n\t\t\n\t\tif (wGaApiKey.getText().trim().length() > 0){\n\t\t\tquery.setStringCustomParameter(\"key\", wGaApiKey.getText().trim());\t\n\t\t}\n\n\t\tif (wCustomSegmentEnabled.getSelection()) {\n\t\t\tquery.setSegment(transMeta.environmentSubstitute(wQuCustomSegment.getText()));\n\t\t} else {\n\t\t\tquery.setSegment(segmentIds.get(wQuSegment.getText()));\n\t\t}\n\n\t\tif (!Const.isEmpty(wQuFilters.getText())) {\n\t\t\tquery.setFilters(transMeta.environmentSubstitute(wQuFilters.getText()));\n\t\t}\n\t\tif (!Const.isEmpty(wQuSort.getText())) {\n\t\t\tquery.setSort(transMeta.environmentSubstitute(wQuSort.getText()));\n\t\t}\n\n\t\treturn query;\n\t\t\n\t}","id":104107,"modified_method":"protected DataQuery getPreviewQuery(){\n\t\t\n\t\tDataQuery query = null;\n\t\ttry {\n\t\t\tquery = new DataQuery(new URL(GaInputStepMeta.GA_DATA_URL));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tex.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tquery.setIds(wCustomProfileEnabled.getSelection()? transMeta.environmentSubstitute(wGaCustomProfile.getText()): profileTableIds.get(wGaProfile.getText()));\n\t\tquery.setStartDate(transMeta.environmentSubstitute(wQuStartDate.getText()));\n\t\tquery.setEndDate(transMeta.environmentSubstitute(wQuEndDate.getText()));\n\t\tquery.setDimensions(transMeta.environmentSubstitute(wQuDimensions.getText()));\n\t\tquery.setMetrics(transMeta.environmentSubstitute(wQuMetrics.getText()));\n\t\t\n\t\tif (wGaApiKey.getText().trim().length() > 0){\n\t\t\tquery.setStringCustomParameter(\"key\", wGaApiKey.getText().trim());\t\n\t\t}\n\n\t\tif (wUseSegmentEnabled.getSelection()){\n\t\t\tif (wCustomSegmentEnabled.getSelection()) {\n\t\t\t\tquery.setSegment(transMeta.environmentSubstitute(wQuCustomSegment.getText()));\n\t\t\t} else {\n\t\t\t\tquery.setSegment(segmentIds.get(wQuSegment.getText()));\n\t\t\t}\n\t\t}\n\n\t\tif (!Const.isEmpty(wQuFilters.getText())) {\n\t\t\tquery.setFilters(transMeta.environmentSubstitute(wQuFilters.getText()));\n\t\t}\n\t\tif (!Const.isEmpty(wQuSort.getText())) {\n\t\t\tquery.setSort(transMeta.environmentSubstitute(wQuSort.getText()));\n\t\t}\n\n\t\treturn query;\n\t\t\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(GaInputStepMeta meta){\n\t\t\n\t\tstepname = wStepname.getText(); // return value\n\n\t\tmeta.setGaEmail(wGaEmail.getText());\n\t\tmeta.setGaPassword(wGaPassword.getText());\n\t\tmeta.setGaProfileName(wGaProfile.getText());\n\t\tmeta.setGaAppName(wGaAppName.getText());\n\t\tmeta.setGaApiKey(wGaApiKey.getText().trim());\n\t\t\n\t\tif (!Const.isEmpty(wGaProfile.getText())) {\n\t\t\tmeta.setGaProfileTableId(profileTableIds.get(wGaProfile.getText()));\n\t\t} else {\n\t\t\tmeta.setGaProfileTableId(null);\n\t\t}\n\t\t\n\t\tmeta.setUseCustomTableId(wCustomProfileEnabled.getSelection());\n\t\tmeta.setGaCustomTableId(wGaCustomProfile.getText());\n\n\t\tmeta.setSegmentName(Const.isEmpty(wQuSegment.getText())?\"All Visits\":wQuSegment.getText());\n\t\tif (!Const.isEmpty(wQuSegment.getText())) {\n\t\t\tmeta.setSegmentId(segmentIds.get(wQuSegment.getText()));\n\t\t}\n\t\telse{\n\t\t\t// all visits is default\n\t\t\tmeta.setSegmentId(\"gaid::-1\");\n\t\t}\n\n\t\tmeta.setStartDate(wQuStartDate.getText());\n\t\tmeta.setEndDate(wQuEndDate.getText());\n\n\t\tmeta.setDimensions(wQuDimensions.getText());\n\t\tmeta.setMetrics(wQuMetrics.getText());\n\t\tmeta.setFilters(wQuFilters.getText());\n\t\tmeta.setSort(wQuSort.getText());\n\n\t\tmeta.setUseCustomSegment(wCustomSegmentEnabled.getSelection());\n\t\tmeta.setCustomSegment(wQuCustomSegment.getText());\n\n\t\tint nrFields = wFields.nrNonEmpty();\n\n\t\tmeta.allocate(nrFields);\n\n\t\tfor (int i = 0; i < nrFields; i++) {\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tmeta.getFeedFieldType()[i] = item.getText(1);\n\t\t\tmeta.getFeedField()[i] = item.getText(2);\n\t\t\tmeta.getOutputField()[i] = item.getText(3);\n\n\t\t\tmeta.getOutputType()[i] = ValueMeta.getType(item.getText(4));\n\t\t\tmeta.getConversionMask()[i] = item.getText(5);\n\n\t\t\t// fix unknowns\n\t\t\tif (meta.getOutputType()[i] < 0) {\n\t\t\t\tmeta.getOutputType()[i] = ValueMetaInterface.TYPE_STRING;\n\t\t\t}\n\n\t\t}\t\t\n\t\t\n\t\tmeta.setRowLimit(Const.toInt(wLimit.getText(), 0));\n\t\t\n\t}","id":104108,"modified_method":"private void getInfo(GaInputStepMeta meta){\n\t\t\n\t\tstepname = wStepname.getText(); // return value\n\n\t\tmeta.setGaEmail(wGaEmail.getText());\n\t\tmeta.setGaPassword(wGaPassword.getText());\n\t\tmeta.setGaProfileName(wGaProfile.getText());\n\t\tmeta.setGaAppName(wGaAppName.getText());\n\t\tmeta.setGaApiKey(wGaApiKey.getText().trim());\n\t\t\n\t\tif (!Const.isEmpty(wGaProfile.getText())) {\n\t\t\tmeta.setGaProfileTableId(profileTableIds.get(wGaProfile.getText()));\n\t\t} else {\n\t\t\tmeta.setGaProfileTableId(null);\n\t\t}\n\t\t\n\t\tmeta.setUseCustomTableId(wCustomProfileEnabled.getSelection());\n\t\tmeta.setGaCustomTableId(wGaCustomProfile.getText());\n\n\t\tmeta.setSegmentName(Const.isEmpty(wQuSegment.getText())?\"All Visits\":wQuSegment.getText());\n\t\tif (!Const.isEmpty(wQuSegment.getText())) {\n\t\t\tmeta.setSegmentId(segmentIds.get(wQuSegment.getText()));\n\t\t}\n\t\telse{\n\t\t\t// all visits is default\n\t\t\tmeta.setSegmentId(\"gaid::-1\");\n\t\t}\n\n\t\tmeta.setStartDate(wQuStartDate.getText());\n\t\tmeta.setEndDate(wQuEndDate.getText());\n\n\t\tmeta.setDimensions(wQuDimensions.getText());\n\t\tmeta.setMetrics(wQuMetrics.getText());\n\t\tmeta.setFilters(wQuFilters.getText());\n\t\tmeta.setSort(wQuSort.getText());\n\n\t\tmeta.setUseSegment(wUseSegmentEnabled.getSelection());\n\t\tmeta.setUseCustomSegment(wCustomSegmentEnabled.getSelection());\n\t\tmeta.setCustomSegment(wQuCustomSegment.getText());\n\n\t\tint nrFields = wFields.nrNonEmpty();\n\n\t\tmeta.allocate(nrFields);\n\n\t\tfor (int i = 0; i < nrFields; i++) {\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tmeta.getFeedFieldType()[i] = item.getText(1);\n\t\t\tmeta.getFeedField()[i] = item.getText(2);\n\t\t\tmeta.getOutputField()[i] = item.getText(3);\n\n\t\t\tmeta.getOutputType()[i] = ValueMeta.getType(item.getText(4));\n\t\t\tmeta.getConversionMask()[i] = item.getText(5);\n\n\t\t\t// fix unknowns\n\t\t\tif (meta.getOutputType()[i] < 0) {\n\t\t\t\tmeta.getOutputType()[i] = ValueMetaInterface.TYPE_STRING;\n\t\t\t}\n\n\t\t}\t\t\n\t\t\n\t\tmeta.setRowLimit(Const.toInt(wLimit.getText(), 0));\n\t\t\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step) throws KettleException {\n\t\ttry {\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"user\", gaEmail);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"pass\", \"Encrypted \" + Encr.encryptPassword(gaPassword));\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"apiKey\", \"Encrypted \" + Encr.encryptPassword(gaApiKey));\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"appName\", gaAppName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"profileName\", gaProfileName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"profileTableId\", gaProfileTableId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"customTableId\", gaCustomTableId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"useCustomTableId\", useCustomTableId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"startDate\", startDate);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"endDate\", endDate);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"dimensions\", dimensions);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"metrics\", metrics);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filters\", filters);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"sort\", sort);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"useCustomSegment\", useCustomSegment);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"customSegment\", customSegment);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"segmentId\", segmentId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"segmentName\", segmentName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rowLimit\", rowLimit);\n\t\t\t\n\t\t\tfor (int i = 0; i < feedField.length; i++) {\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"feedFieldType\", feedFieldType[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"feedField\", feedField[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"outField\", outputField[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"conversionMask\", conversionMask[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"type\", ValueMeta.getTypeDesc(outputType[i]));\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"GoogleAnalytics.Error.UnableToSaveToRep\") + id_step, e);\n\t\t}\n\t}","id":104109,"modified_method":"public void saveRep(Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step) throws KettleException {\n\t\ttry {\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"user\", gaEmail);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"pass\", \"Encrypted \" + Encr.encryptPassword(gaPassword));\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"apiKey\", \"Encrypted \" + Encr.encryptPassword(gaApiKey));\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"appName\", gaAppName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"profileName\", gaProfileName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"profileTableId\", gaProfileTableId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"customTableId\", gaCustomTableId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"useCustomTableId\", useCustomTableId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"startDate\", startDate);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"endDate\", endDate);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"dimensions\", dimensions);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"metrics\", metrics);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filters\", filters);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"sort\", sort);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"useSegment\", useSegment);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"useCustomSegment\", useCustomSegment);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"customSegment\", customSegment);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"segmentId\", segmentId);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"segmentName\", segmentName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rowLimit\", rowLimit);\n\t\t\t\n\t\t\tfor (int i = 0; i < feedField.length; i++) {\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"feedFieldType\", feedFieldType[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"feedField\", feedField[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"outField\", outputField[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"conversionMask\", conversionMask[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"type\", ValueMeta.getTypeDesc(outputType[i]));\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"GoogleAnalytics.Error.UnableToSaveToRep\") + id_step, e);\n\t\t}\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault() {\n\t\tgaEmail = \"your.account@googlemail.com\";\n\t\tsegmentId = \"gaid::-1\";\n\t\tsegmentName = \"All Visits\";\n\t\tdimensions = \"ga:browser\";\n\t\tmetrics = \"ga:visits\";\n\t\tstartDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n\t\tendDate = new String(startDate);\n\t\tsort = \"-ga:visits\";\n\t\tgaAppName = DEFAULT_GA_APPLICATION_NAME;\n\t\trowLimit = 0;\n\t\tgaApiKey = \"\";\n\t\t// default is to have no key lookup settings\n\t\tallocate(0);\n\n\t}","id":104110,"modified_method":"public void setDefault() {\n\t\tgaEmail = \"your.account@googlemail.com\";\n\t\tuseSegment = true;\n\t\tsegmentId = \"gaid::-1\";\n\t\tsegmentName = \"All Visits\";\n\t\tdimensions = \"ga:browser\";\n\t\tmetrics = \"ga:visits\";\n\t\tstartDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n\t\tendDate = new String(startDate);\n\t\tsort = \"-ga:visits\";\n\t\tgaAppName = DEFAULT_GA_APPLICATION_NAME;\n\t\trowLimit = 0;\n\t\tgaApiKey = \"\";\n\t\t// default is to have no key lookup settings\n\t\tallocate(0);\n\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases) throws KettleException {\n\t\ttry {\n\t\t\t\n\t\t\t\n\t\t\tgaEmail = rep.getStepAttributeString(id_step, \"user\");\n\t\t\tgaPassword = Encr.decryptPasswordOptionallyEncrypted(rep.getStepAttributeString(id_step, \"pass\"));\n\t\t\tgaApiKey = Encr.decryptPasswordOptionallyEncrypted(rep.getStepAttributeString(id_step, \"apiKey\"));\n\t\t\tgaProfileName = rep.getStepAttributeString(id_step,  \"profileName\");\n\t\t\tgaAppName = rep.getStepAttributeString(id_step,  \"appName\");\n\t\t\tgaProfileTableId = rep.getStepAttributeString(id_step,  \"profileTableId\");\n\t\t\tgaCustomTableId = rep.getStepAttributeString(id_step,  \"customTableId\");\n\t\t\tuseCustomTableId = rep.getStepAttributeBoolean(id_step, \"useCustomTableId\");\n\t\t\tstartDate = rep.getStepAttributeString(id_step,  \"startDate\");\n\t\t\tendDate = rep.getStepAttributeString(id_step,  \"endDate\");\n\t\t\tdimensions = rep.getStepAttributeString(id_step,  \"dimensions\");\n\t\t\tmetrics = rep.getStepAttributeString(id_step, \"metrics\");\n\t\t\tfilters = rep.getStepAttributeString(id_step,  \"filters\");\n\t\t\tsort = rep.getStepAttributeString(id_step, \"sort\");\n\t\t\tuseCustomSegment = rep.getStepAttributeBoolean(id_step, \"useCustomSegment\");\n\t\t\tcustomSegment = rep.getStepAttributeString(id_step,  \"customSegment\");\n\t\t\tsegmentId = rep.getStepAttributeString(id_step,  \"segmentId\");\n\t\t\tsegmentName = rep.getStepAttributeString(id_step,  \"segmentName\");\n\t\t\trowLimit = (int)rep.getStepAttributeInteger(id_step, \"rowLimit\");\n\t\t\t\n\t\t\tint nrFields = rep.countNrStepAttributes(id_step, \"feedField\");\n\t\t\tallocate(nrFields);\n\t\t\t\n\t\t\tfor (int i = 0; i < nrFields; i++) {\n\t\t\t\t\n\t\t\t\tfeedFieldType[i] = rep.getStepAttributeString(id_step, i, \"feedFieldType\");\n\t\t\t\tfeedField[i] = rep.getStepAttributeString(id_step, i, \"feedField\");\n\t\t\t\toutputField[i] = rep.getStepAttributeString(id_step, i, \"outField\");\n\t\t\t\toutputType[i] = ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"type\"));\n\t\t\t\tconversionMask[i] = rep.getStepAttributeString(id_step, i, \"conversionMask\");\n\n\t\t\t\tif (outputType[i] < 0) {\n\t\t\t\t\toutputType[i] = ValueMetaInterface.TYPE_STRING;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"GoogleAnalytics.Error.UnableToReadFromRep\"), e);\n\t\t}\n\t}","id":104111,"modified_method":"public void readRep(Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases) throws KettleException {\n\t\ttry {\n\t\t\t\n\t\t\t\n\t\t\tgaEmail = rep.getStepAttributeString(id_step, \"user\");\n\t\t\tgaPassword = Encr.decryptPasswordOptionallyEncrypted(rep.getStepAttributeString(id_step, \"pass\"));\n\t\t\tgaApiKey = Encr.decryptPasswordOptionallyEncrypted(rep.getStepAttributeString(id_step, \"apiKey\"));\n\t\t\tgaProfileName = rep.getStepAttributeString(id_step,  \"profileName\");\n\t\t\tgaAppName = rep.getStepAttributeString(id_step,  \"appName\");\n\t\t\tgaProfileTableId = rep.getStepAttributeString(id_step,  \"profileTableId\");\n\t\t\tgaCustomTableId = rep.getStepAttributeString(id_step,  \"customTableId\");\n\t\t\tuseCustomTableId = rep.getStepAttributeBoolean(id_step, \"useCustomTableId\");\n\t\t\tstartDate = rep.getStepAttributeString(id_step,  \"startDate\");\n\t\t\tendDate = rep.getStepAttributeString(id_step,  \"endDate\");\n\t\t\tdimensions = rep.getStepAttributeString(id_step,  \"dimensions\");\n\t\t\tmetrics = rep.getStepAttributeString(id_step, \"metrics\");\n\t\t\tfilters = rep.getStepAttributeString(id_step,  \"filters\");\n\t\t\tsort = rep.getStepAttributeString(id_step, \"sort\");\n\t\t\tuseSegment = rep.getStepAttributeBoolean(id_step, 0, \"useSegment\", true); // assume default true, if not present\n\t\t\tuseCustomSegment = rep.getStepAttributeBoolean(id_step, \"useCustomSegment\");\n\t\t\tcustomSegment = rep.getStepAttributeString(id_step,  \"customSegment\");\n\t\t\tsegmentId = rep.getStepAttributeString(id_step,  \"segmentId\");\n\t\t\tsegmentName = rep.getStepAttributeString(id_step,  \"segmentName\");\n\t\t\trowLimit = (int)rep.getStepAttributeInteger(id_step, \"rowLimit\");\n\t\t\t\n\t\t\tint nrFields = rep.countNrStepAttributes(id_step, \"feedField\");\n\t\t\tallocate(nrFields);\n\t\t\t\n\t\t\tfor (int i = 0; i < nrFields; i++) {\n\t\t\t\t\n\t\t\t\tfeedFieldType[i] = rep.getStepAttributeString(id_step, i, \"feedFieldType\");\n\t\t\t\tfeedField[i] = rep.getStepAttributeString(id_step, i, \"feedField\");\n\t\t\t\toutputField[i] = rep.getStepAttributeString(id_step, i, \"outField\");\n\t\t\t\toutputType[i] = ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"type\"));\n\t\t\t\tconversionMask[i] = rep.getStepAttributeString(id_step, i, \"conversionMask\");\n\n\t\t\t\tif (outputType[i] < 0) {\n\t\t\t\t\toutputType[i] = ValueMetaInterface.TYPE_STRING;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"GoogleAnalytics.Error.UnableToReadFromRep\"), e);\n\t\t}\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadXML(Node stepnode, List<DatabaseMeta> databases, IMetaStore metaStore) throws KettleXMLException {\n\n\t\ttry {\n\n\t\t\tgaEmail = XMLHandler.getTagValue(stepnode, \"user\");\n\t\t\tgaPassword = Encr.decryptPasswordOptionallyEncrypted(XMLHandler.getTagValue(stepnode, \"pass\"));\n\t\t\tgaAppName = XMLHandler.getTagValue(stepnode, \"appName\");\n\t\t\tgaApiKey = Encr.decryptPasswordOptionallyEncrypted(XMLHandler.getTagValue(stepnode, \"apiKey\"));\n\t\t\tgaProfileName = XMLHandler.getTagValue(stepnode, \"profileName\");\n\t\t\tgaProfileTableId = XMLHandler.getTagValue(stepnode, \"profileTableId\");\n\t\t\tgaCustomTableId = XMLHandler.getTagValue(stepnode, \"customTableId\");\n\t\t\tuseCustomTableId = getBooleanAttributeFromNode(stepnode, \"useCustomTableId\");\n\t\t\tstartDate = XMLHandler.getTagValue(stepnode, \"startDate\");\n\t\t\tendDate = XMLHandler.getTagValue(stepnode, \"endDate\");\n\t\t\tdimensions = XMLHandler.getTagValue(stepnode, \"dimensions\");\n\t\t\tmetrics = XMLHandler.getTagValue(stepnode, \"metrics\");\n\t\t\tfilters = XMLHandler.getTagValue(stepnode, \"filters\");\n\t\t\tsort = XMLHandler.getTagValue(stepnode, \"sort\");\n\t\t\tuseCustomSegment = getBooleanAttributeFromNode(stepnode, \"useCustomSegment\");\n\t\t\tcustomSegment = XMLHandler.getTagValue(stepnode, \"customSegment\");\n\t\t\tsegmentId = XMLHandler.getTagValue(stepnode, \"segmentId\");\n\t\t\tsegmentName = XMLHandler.getTagValue(stepnode, \"segmentName\");\n\t\t\trowLimit = Const.toInt(XMLHandler.getTagValue(stepnode, \"rowLimit\"), 0);\t\t\t\n\n\t\t\tallocate(0);\n\t\t\t\n\t\t\tint nrFields = XMLHandler.countNodes(stepnode, \"feedField\");\n\t\t\tallocate(nrFields);\n\n\t\t\tfor (int i = 0; i < nrFields; i++) {\n\t\t\t\tNode knode = XMLHandler.getSubNodeByNr(stepnode, \"feedField\", i);\n\n\t\t\t\tfeedFieldType[i] = XMLHandler.getTagValue(knode, \"feedFieldType\");\n\t\t\t\tfeedField[i] = XMLHandler.getTagValue(knode, \"feedField\");\n\t\t\t\toutputField[i] = XMLHandler.getTagValue(knode, \"outField\");\n\t\t\t\toutputType[i] = ValueMeta.getType(XMLHandler.getTagValue(knode, \"type\"));\n\t\t\t\tconversionMask[i] = XMLHandler.getTagValue(knode, \"conversionMask\");\n\n\t\t\t\tif (outputType[i] < 0) {\n\t\t\t\t\toutputType[i] = ValueMetaInterface.TYPE_STRING;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleXMLException(BaseMessages.getString(PKG, \"GoogleAnalytics.Error.UnableToReadFromXML\"), e);\n\t\t}\n\n\t}","id":104112,"modified_method":"public void loadXML(Node stepnode, List<DatabaseMeta> databases, IMetaStore metaStore) throws KettleXMLException {\n\n\t\ttry {\n\n\t\t\tgaEmail = XMLHandler.getTagValue(stepnode, \"user\");\n\t\t\tgaPassword = Encr.decryptPasswordOptionallyEncrypted(XMLHandler.getTagValue(stepnode, \"pass\"));\n\t\t\tgaAppName = XMLHandler.getTagValue(stepnode, \"appName\");\n\t\t\tgaApiKey = Encr.decryptPasswordOptionallyEncrypted(XMLHandler.getTagValue(stepnode, \"apiKey\"));\n\t\t\tgaProfileName = XMLHandler.getTagValue(stepnode, \"profileName\");\n\t\t\tgaProfileTableId = XMLHandler.getTagValue(stepnode, \"profileTableId\");\n\t\t\tgaCustomTableId = XMLHandler.getTagValue(stepnode, \"customTableId\");\n\t\t\tuseCustomTableId = getBooleanAttributeFromNode(stepnode, \"useCustomTableId\");\n\t\t\tstartDate = XMLHandler.getTagValue(stepnode, \"startDate\");\n\t\t\tendDate = XMLHandler.getTagValue(stepnode, \"endDate\");\n\t\t\tdimensions = XMLHandler.getTagValue(stepnode, \"dimensions\");\n\t\t\tmetrics = XMLHandler.getTagValue(stepnode, \"metrics\");\n\t\t\tfilters = XMLHandler.getTagValue(stepnode, \"filters\");\n\t\t\tsort = XMLHandler.getTagValue(stepnode, \"sort\");\n\t\t\tuseSegment = XMLHandler.getTagValue(stepnode, \"useSegment\") == null ? true : getBooleanAttributeFromNode(stepnode, \"useSegment\"); // assume true for non-present\n\t\t\tuseCustomSegment = getBooleanAttributeFromNode(stepnode, \"useCustomSegment\");\n\t\t\tcustomSegment = XMLHandler.getTagValue(stepnode, \"customSegment\");\n\t\t\tsegmentId = XMLHandler.getTagValue(stepnode, \"segmentId\");\n\t\t\tsegmentName = XMLHandler.getTagValue(stepnode, \"segmentName\");\n\t\t\trowLimit = Const.toInt(XMLHandler.getTagValue(stepnode, \"rowLimit\"), 0);\t\t\t\n\n\t\t\tallocate(0);\n\t\t\t\n\t\t\tint nrFields = XMLHandler.countNodes(stepnode, \"feedField\");\n\t\t\tallocate(nrFields);\n\n\t\t\tfor (int i = 0; i < nrFields; i++) {\n\t\t\t\tNode knode = XMLHandler.getSubNodeByNr(stepnode, \"feedField\", i);\n\n\t\t\t\tfeedFieldType[i] = XMLHandler.getTagValue(knode, \"feedFieldType\");\n\t\t\t\tfeedField[i] = XMLHandler.getTagValue(knode, \"feedField\");\n\t\t\t\toutputField[i] = XMLHandler.getTagValue(knode, \"outField\");\n\t\t\t\toutputType[i] = ValueMeta.getType(XMLHandler.getTagValue(knode, \"type\"));\n\t\t\t\tconversionMask[i] = XMLHandler.getTagValue(knode, \"conversionMask\");\n\n\t\t\t\tif (outputType[i] < 0) {\n\t\t\t\t\toutputType[i] = ValueMetaInterface.TYPE_STRING;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleXMLException(BaseMessages.getString(PKG, \"GoogleAnalytics.Error.UnableToReadFromXML\"), e);\n\t\t}\n\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() throws KettleValueException {\n\n\t\tStringBuffer retval = new StringBuffer(800);\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"user\", gaEmail));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"pass\", \"Encrypted \" + Encr.encryptPassword(gaPassword)));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"appName\", gaAppName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"apiKey\", \"Encrypted \" + Encr.encryptPassword(gaApiKey)));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"profileName\", gaProfileName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"profileTableId\", gaProfileTableId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"customTableId\", gaCustomTableId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"useCustomTableId\", useCustomTableId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"startDate\", startDate));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"endDate\", endDate));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"dimensions\", dimensions));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"metrics\", metrics));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filters\", filters));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"sort\", sort));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"useCustomSegment\", useCustomSegment));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"customSegment\", customSegment));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"segmentId\", segmentId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"segmentName\", segmentName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"rowLimit\", rowLimit));\t\t\n\n\t\tfor (int i = 0; i < feedField.length; i++) {\n\t\t\tretval.append(\"      <feedField>\").append(Const.CR);\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"feedFieldType\", feedFieldType[i]));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"feedField\", feedField[i]));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"outField\", outputField[i]));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(outputType[i])));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"conversionMask\", conversionMask[i]));\n\t\t\tretval.append(\"      <\/feedField>\").append(Const.CR);\n\t\t}\n\n\t\treturn retval.toString();\n\t}","id":104113,"modified_method":"public String getXML() throws KettleValueException {\n\n\t\tStringBuffer retval = new StringBuffer(800);\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"user\", gaEmail));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"pass\", \"Encrypted \" + Encr.encryptPassword(gaPassword)));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"appName\", gaAppName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"apiKey\", \"Encrypted \" + Encr.encryptPassword(gaApiKey)));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"profileName\", gaProfileName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"profileTableId\", gaProfileTableId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"customTableId\", gaCustomTableId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"useCustomTableId\", useCustomTableId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"startDate\", startDate));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"endDate\", endDate));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"dimensions\", dimensions));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"metrics\", metrics));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filters\", filters));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"sort\", sort));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"useSegment\", useSegment));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"useCustomSegment\", useCustomSegment));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"customSegment\", customSegment));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"segmentId\", segmentId));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"segmentName\", segmentName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"rowLimit\", rowLimit));\t\t\n\n\t\tfor (int i = 0; i < feedField.length; i++) {\n\t\t\tretval.append(\"      <feedField>\").append(Const.CR);\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"feedFieldType\", feedFieldType[i]));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"feedField\", feedField[i]));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"outField\", outputField[i]));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(outputType[i])));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"conversionMask\", conversionMask[i]));\n\t\t\tretval.append(\"      <\/feedField>\").append(Const.CR);\n\t\t}\n\n\t\treturn retval.toString();\n\t}","commit_id":"ecd8dd74acce6b9a86957fc2ab99fd6f8d5966b1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setDatabase(jobMeta.findDatabase(wConnection.getText()));\n\t\tjobEntry.setSchemaname(wSchemaname.getText());\n\t\tjobEntry.setTablename(wTablename.getText());\n\t\tjobEntry.setFilename(wFilename.getText());\n\t\tjobEntry.setSeparator(wSeparator.getText());\n\t\tjobEntry.setEnclosed(wEnclosed.getText());\n\t\tjobEntry.setLineterminated(wLineterminated.getText());\n\t\t\n\t\tjobEntry.setLimitlines(wLimitlines.getText());\n\t\tjobEntry.setListColumn(wListColumn.getText());\n\n\t\tjobEntry.outdumpvalue = wOutDumpValue.getSelectionIndex();\n\n\t\tjobEntry.setHighPriority(wHighPriority.getSelection());\n\t\tjobEntry.iffileexists = wIfFileExists.getSelectionIndex();\n\n\t\tdispose();\n\t}","id":104114,"modified_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setDatabase(jobMeta.findDatabase(wConnection.getText()));\n\t\tjobEntry.setSchemaname(wSchemaname.getText());\n\t\tjobEntry.setTablename(wTablename.getText());\n\t\tjobEntry.setFilename(wFilename.getText());\n\t\tjobEntry.setSeparator(wSeparator.getText());\n\t\tjobEntry.setEnclosed(wEnclosed.getText());\n\t\tjobEntry.setOptionEnclosed(wOptionEnclosed.getSelection());\n\t\tjobEntry.setLineterminated(wLineterminated.getText());\n\t\t\n\t\tjobEntry.setLimitlines(wLimitlines.getText());\n\t\tjobEntry.setListColumn(wListColumn.getText());\n\n\t\tjobEntry.outdumpvalue = wOutDumpValue.getSelectionIndex();\n\n\t\tjobEntry.setHighPriority(wHighPriority.getSelection());\n\t\tjobEntry.iffileexists = wIfFileExists.getSelectionIndex();\n\n\t\tdispose();\n\t}","commit_id":"d0144a7acd20554ca6e0aaa8d391ec95b00aa9d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\t// System.out.println(\"evaluates: \"+jobentry.evaluates());\n\n\t\tif (jobEntry.getName() != null)\n\t\t\twName.setText(jobEntry.getName());\n\t\tif (jobEntry.getSchemaname() != null)\n\t\t\twTablename.setText(jobEntry.getSchemaname());\n\t\tif (jobEntry.getTablename() != null)\n\t\t\twTablename.setText(jobEntry.getTablename());\n\t\tif (jobEntry.getFilename() != null)\n\t\t\twFilename.setText(jobEntry.getFilename());\n\t\tif (jobEntry.getSeparator() != null)\n\t\t\twSeparator.setText(jobEntry.getSeparator());\n\n\t\tif (jobEntry.getEnclosed() != null)\n\t\t\twEnclosed.setText(jobEntry.getEnclosed());\n\t\n\t\tif (jobEntry.getLineterminated() != null)\n\t\t\twLineterminated.setText(jobEntry.getLineterminated());\n\t\t\n\t\t\t\n\t\twHighPriority.setSelection(jobEntry.isHighPriority());\n\t\t\n\n\t\tif (jobEntry.getLimitlines() != null)\n\t\t\twLimitlines.setText(jobEntry.getLimitlines());\n\t\telse\n\t\t\twLimitlines.setText(\"0\");\n\t\t\n\t\tif (jobEntry.getListColumn() != null)\n\t\t\twListColumn.setText(jobEntry.getListColumn());\n\t\t\n     \n\t\tif (jobEntry.outdumpvalue>=0) \n        {\n            wOutDumpValue.select(jobEntry.outdumpvalue );\n        }\n        else\n        {\n            wOutDumpValue.select(0); // NORMAL priority\n        }\n\n\t\n\t\tif (jobEntry.iffileexists>=0) \n\t\t{\n\t\t\twIfFileExists.select(jobEntry.iffileexists );\n\t\t}\n\t\telse\n\t\t{\n\t\t\twIfFileExists.select(2); // FAIL\n\t\t}\n\t\t\n\t\tif (jobEntry.getDatabase() != null)\n\t\t{\n\t\t\twConnection.setText(jobEntry.getDatabase().getName());\n\t\t}\n\t\twName.selectAll();\n\t}","id":104115,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\t// System.out.println(\"evaluates: \"+jobentry.evaluates());\n\n\t\tif (jobEntry.getName() != null)\n\t\t\twName.setText(jobEntry.getName());\n\t\tif (jobEntry.getSchemaname() != null)\n\t\t\twTablename.setText(jobEntry.getSchemaname());\n\t\tif (jobEntry.getTablename() != null)\n\t\t\twTablename.setText(jobEntry.getTablename());\n\t\tif (jobEntry.getFilename() != null)\n\t\t\twFilename.setText(jobEntry.getFilename());\n\t\tif (jobEntry.getSeparator() != null)\n\t\t\twSeparator.setText(jobEntry.getSeparator());\n\n\t\tif (jobEntry.getEnclosed() != null)\n\t\t\twEnclosed.setText(jobEntry.getEnclosed());\n\t\twOptionEnclosed.setSelection(jobEntry.isOptionEnclosed());\n\t\n\t\tif (jobEntry.getLineterminated() != null)\n\t\t\twLineterminated.setText(jobEntry.getLineterminated());\n\t\t\n\t\t\t\n\t\twHighPriority.setSelection(jobEntry.isHighPriority());\n\t\twOptionEnclosed.setSelection(jobEntry.isOptionEnclosed());\n\n\t\tif (jobEntry.getLimitlines() != null)\n\t\t\twLimitlines.setText(jobEntry.getLimitlines());\n\t\telse\n\t\t\twLimitlines.setText(\"0\");\n\t\t\n\t\tif (jobEntry.getListColumn() != null)\n\t\t\twListColumn.setText(jobEntry.getListColumn());\n\t\t\n     \n\t\tif (jobEntry.outdumpvalue>=0) \n        {\n            wOutDumpValue.select(jobEntry.outdumpvalue );\n        }\n        else\n        {\n            wOutDumpValue.select(0); // NORMAL priority\n        }\n\n\t\n\t\tif (jobEntry.iffileexists>=0) \n\t\t{\n\t\t\twIfFileExists.select(jobEntry.iffileexists );\n\t\t}\n\t\telse\n\t\t{\n\t\t\twIfFileExists.select(2); // FAIL\n\t\t}\n\t\t\n\t\tif (jobEntry.getDatabase() != null)\n\t\t{\n\t\t\twConnection.setText(jobEntry.getDatabase().getName());\n\t\t}\n\t\twName.selectAll();\n\t}","commit_id":"d0144a7acd20554ca6e0aaa8d391ec95b00aa9d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, props.getJobsDialogStyle());\n\t\tprops.setLook(shell);\n\t\tJobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobMysqlBulkFile.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName = new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobMysqlBulkFile.Name.Label\"));\n\t\tprops.setLook(wlName);\n\t\tfdlName = new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right = new FormAttachment(middle, 0);\n\t\tfdlName.top = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName = new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top = new FormAttachment(0, margin);\n\t\tfdName.right = new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Connection line\n\t\twlConnection = new Label(shell, SWT.RIGHT);\n\t\twlConnection.setText(Messages.getString(\"JobMysqlBulkFile.Connection.Label\"));\n\t\tprops.setLook(wlConnection);\n\t\tfdlConnection = new FormData();\n\t\tfdlConnection.left = new FormAttachment(0, 0);\n\t\tfdlConnection.top = new FormAttachment(wName, margin);\n\t\tfdlConnection.right = new FormAttachment(middle, -margin);\n\t\twlConnection.setLayoutData(fdlConnection);\n\n\t\twbConnection = new Button(shell, SWT.PUSH);\n\t\twbConnection.setText(Messages.getString(\"System.Button.New\") + \"...\");\n\t\twbConnection.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tDatabaseMeta databaseMeta = new DatabaseMeta();\n\t\t\t\tDatabaseDialog cid = new DatabaseDialog(shell, databaseMeta);\n\t\t\t\tif (cid.open() != null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta.addDatabase(databaseMeta);\n\n\t\t\t\t\t// SB: Maybe do the same her as in BaseStepDialog: remove\n\t\t\t\t\t// all db connections and add them again.\n\t\t\t\t\twConnection.add(databaseMeta.getName());\n\t\t\t\t\twConnection.select(wConnection.getItemCount() - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfdbConnection = new FormData();\n\t\tfdbConnection.right = new FormAttachment(100, 0);\n\t\tfdbConnection.top = new FormAttachment(wName, margin);\n\t\tfdbConnection.height = 20;\n\t\twbConnection.setLayoutData(fdbConnection);\n\n\t\twConnection = new CCombo(shell, SWT.BORDER | SWT.READ_ONLY);\n\t\tprops.setLook(wConnection);\n\t\tfor (int i = 0; i < jobMeta.nrDatabases(); i++)\n\t\t{\n\t\t\tDatabaseMeta ci = jobMeta.getDatabase(i);\n\t\t\twConnection.add(ci.getName());\n\t\t}\n\t\twConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\tfdConnection = new FormData();\n\t\tfdConnection.left = new FormAttachment(middle, 0);\n\t\tfdConnection.top = new FormAttachment(wName, margin);\n\t\tfdConnection.right = new FormAttachment(wbConnection, -margin);\n\t\twConnection.setLayoutData(fdConnection);\n\n\t\t\n\t\t// Schema name line\n\t\twlSchemaname = new Label(shell, SWT.RIGHT);\n\t\twlSchemaname.setText(Messages.getString(\"JobMysqlBulkFile.Schemaname.Label\"));\n\t\tprops.setLook(wlSchemaname);\n\t\tfdlSchemaname = new FormData();\n\t\tfdlSchemaname.left = new FormAttachment(0, 0);\n\t\tfdlSchemaname.right = new FormAttachment(middle, 0);\n\t\tfdlSchemaname.top = new FormAttachment(wConnection, margin);\n\t\twlSchemaname.setLayoutData(fdlSchemaname);\n\n\t\twSchemaname = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wSchemaname);\n\t\twSchemaname.setToolTipText(Messages.getString(\"JobMysqlBulkFile.Schemaname.Tooltip\"));\n\t\twSchemaname.addModifyListener(lsMod);\n\t\tfdSchemaname = new FormData();\n\t\tfdSchemaname.left = new FormAttachment(middle, 0);\n\t\tfdSchemaname.top = new FormAttachment(wConnection, margin);\n\t\tfdSchemaname.right = new FormAttachment(100, 0);\n\t\twSchemaname.setLayoutData(fdSchemaname);\n\t\t\n\t\t// Table name line\n\t\twlTablename = new Label(shell, SWT.RIGHT);\n\t\twlTablename.setText(Messages.getString(\"JobMysqlBulkFile.Tablename.Label\"));\n\t\tprops.setLook(wlTablename);\n\t\tfdlTablename = new FormData();\n\t\tfdlTablename.left = new FormAttachment(0, 0);\n\t\tfdlTablename.right = new FormAttachment(middle, 0);\n\t\tfdlTablename.top = new FormAttachment(wSchemaname, margin);\n\t\twlTablename.setLayoutData(fdlTablename);\n\n        wbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbTable);\n        wbTable.setText(Messages.getString(\"System.Button.Browse\"));\n        FormData fdbTable = new FormData();\n        fdbTable.right= new FormAttachment(100, 0);\n        fdbTable.top  = new FormAttachment(wSchemaname, margin/2);\n        wbTable.setLayoutData(fdbTable);\n        wbTable.addSelectionListener( new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { getTableName(); } } );\n\n\t\twTablename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wTablename);\n\t\twTablename.setToolTipText(Messages.getString(\"JobMysqlBulkFile.Tablename.Tooltip\"));\n\t\twTablename.addModifyListener(lsMod);\n\t\tfdTablename = new FormData();\n\t\tfdTablename.left = new FormAttachment(middle, 0);\n\t\tfdTablename.top = new FormAttachment(wSchemaname, margin);\n\t\tfdTablename.right = new FormAttachment(wbTable, -margin);\n\t\twTablename.setLayoutData(fdTablename);\n\n\n\t\t// Filename line\n\t\twlFilename = new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"JobMysqlBulkFile.Filename.Label\"));\n\t\tprops.setLook(wlFilename);\n\t\tfdlFilename = new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdlFilename.right = new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbFilename = new Button(shell, SWT.PUSH | SWT.CENTER);\n\t\tprops.setLook(wbFilename);\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename = new FormData();\n\t\tfdbFilename.right = new FormAttachment(100, 0);\n\t\tfdbFilename.top = new FormAttachment(wTablename, 0);\n\t\t// fdbFilename.height = 22;\n\t\twbFilename.setLayoutData(fdbFilename);\n\n\t\twFilename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename = new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdFilename.right = new FormAttachment(wbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twFilename.setToolTipText(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t}\n\t\t});\n\n\t\twbFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\tdialog.setFilterExtensions(new String[] { \"*.txt\", \"*.csv\", \"*\" });\n\t\t\t\tif (wFilename.getText() != null)\n\t\t\t\t{\n\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t\t}\n\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\tif (dialog.open() != null)\n\t\t\t\t{\n\t\t\t\t\twFilename.setText(dialog.getFilterPath() + Const.FILE_SEPARATOR\n\t\t\t\t\t\t+ dialog.getFileName());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t//High Priority ?\n\t\twlHighPriority = new Label(shell, SWT.RIGHT);\n\t\twlHighPriority.setText(Messages.getString(\"JobMysqlBulkFile.HighPriority.Label\"));\n\t\tprops.setLook(wlHighPriority);\n\t\tfdlHighPriority = new FormData();\n\t\tfdlHighPriority.left = new FormAttachment(0, 0);\n\t\tfdlHighPriority.top = new FormAttachment(wFilename, margin);\n\t\tfdlHighPriority.right = new FormAttachment(middle, -margin);\n\t\twlHighPriority.setLayoutData(fdlHighPriority);\n\t\twHighPriority = new Button(shell, SWT.CHECK);\n\t\tprops.setLook(wHighPriority);\n\t\twHighPriority.setToolTipText(Messages.getString(\"JobMysqlBulkFile.HighPriority.Tooltip\"));\n\t\tfdHighPriority = new FormData();\n\t\tfdHighPriority.left = new FormAttachment(middle, 0);\n\t\tfdHighPriority.top = new FormAttachment(wFilename, margin);\n\t\tfdHighPriority.right = new FormAttachment(100, 0);\n\t\twHighPriority.setLayoutData(fdHighPriority);\n\t\twHighPriority.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\n\n\n\t\t// Out Dump\n\t\twlOutDumpValue = new Label(shell, SWT.RIGHT);\n\t\twlOutDumpValue.setText(Messages.getString(\"JobMysqlBulkFile.OutDumpValue.Label\"));\n\t\tprops.setLook(wlOutDumpValue);\n\t\tfdlOutDumpValue = new FormData();\n\t\tfdlOutDumpValue.left = new FormAttachment(0, 0);\n\t\tfdlOutDumpValue.right = new FormAttachment(middle, 0);\n\t\tfdlOutDumpValue.top = new FormAttachment(wHighPriority, margin);\n\t\twlOutDumpValue.setLayoutData(fdlOutDumpValue);\n\t\twOutDumpValue = new CCombo(shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\n\t\t\t\t\twOutDumpValue.add(Messages.getString(\"JobMysqlBulkFile.OutFileValue.Label\"));\n\t\t\t\t\twOutDumpValue.add(Messages.getString(\"JobMysqlBulkFile.DumpFileValue.Label\"));\n\t\t\t\t\twOutDumpValue.select(0); // +1: starts at -1\n\n\t\tprops.setLook(wOutDumpValue);\n\t\tfdOutDumpValue= new FormData();\n\t\tfdOutDumpValue.left = new FormAttachment(middle, 0);\n\t\tfdOutDumpValue.top = new FormAttachment(wHighPriority, margin);\n\t\tfdOutDumpValue.right = new FormAttachment(100, 0);\n\t\twOutDumpValue.setLayoutData(fdOutDumpValue);\n\n\t\tfdOutDumpValue = new FormData();\n\t\tfdOutDumpValue.left = new FormAttachment(middle, 0);\n\t\tfdOutDumpValue.top = new FormAttachment(wHighPriority, margin);\n\t\tfdOutDumpValue.right = new FormAttachment(100, 0);\n\t\twOutDumpValue.setLayoutData(fdOutDumpValue);\n\n\n\t\twOutDumpValue.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tDumpFile();\n\t\t\t}\n\t\t});\n\n\n\n\t\t// Separator\n\t\twlSeparator = new Label(shell, SWT.RIGHT);\n\t\twlSeparator.setText(Messages.getString(\"JobMysqlBulkFile.Separator.Label\"));\n\t\tprops.setLook(wlSeparator);\n\t\tfdlSeparator = new FormData();\n\t\tfdlSeparator.left = new FormAttachment(0, 0);\n\t\tfdlSeparator.right = new FormAttachment(middle, 0);\n\t\tfdlSeparator.top = new FormAttachment(wOutDumpValue, margin);\n\t\twlSeparator.setLayoutData(fdlSeparator);\n\n\t\twbSeparator=new Button(shell, SWT.PUSH| SWT.CENTER);\r\n\t\tprops.setLook(wbSeparator);\r\n\t\twbSeparator.setText(Messages.getString(\"JobMysqlBulkFile.Separator.Button\"));\r\n\t\tfdbSeparator=new FormData();\r\n\t\tfdbSeparator.right= new FormAttachment(100, 0);\r\n\t\tfdbSeparator.top  = new FormAttachment(wOutDumpValue, 0);\r\n\t\twbSeparator.setLayoutData(fdbSeparator);\n\n\t\twSeparator = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wSeparator);\n\t\twSeparator.addModifyListener(lsMod);\n\t\tfdSeparator = new FormData();\n\t\tfdSeparator.left = new FormAttachment(middle, 0);\n\t\tfdSeparator.top = new FormAttachment(wOutDumpValue, margin);\n\t\tfdSeparator.right = new FormAttachment(100, 0);\n\t\twSeparator.setLayoutData(fdSeparator);\n\n\t\t// enclosed\n\t\twlEnclosed = new Label(shell, SWT.RIGHT);\n\t\twlEnclosed.setText(Messages.getString(\"JobMysqlBulkFile.Enclosed.Label\"));\n\t\tprops.setLook(wlEnclosed);\n\t\tfdlEnclosed = new FormData();\n\t\tfdlEnclosed.left = new FormAttachment(0, 0);\n\t\tfdlEnclosed.right = new FormAttachment(middle, 0);\n\t\tfdlEnclosed.top = new FormAttachment(wSeparator, margin);\n\t\twlEnclosed.setLayoutData(fdlEnclosed);\n\n\t\twEnclosed = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wEnclosed);\n\t\twEnclosed.addModifyListener(lsMod);\n\t\tfdEnclosed = new FormData();\n\t\tfdEnclosed.left = new FormAttachment(middle, 0);\n\t\tfdEnclosed.top = new FormAttachment(wSeparator, margin);\n\t\tfdEnclosed.right = new FormAttachment(100, 0);\n\t\twEnclosed.setLayoutData(fdEnclosed);\n\n\t\t// Line terminated\n\t\twlLineterminated = new Label(shell, SWT.RIGHT);\n\t\twlLineterminated.setText(Messages.getString(\"JobMysqlBulkFile.Lineterminated.Label\"));\n\t\tprops.setLook(wlLineterminated);\n\t\tfdlLineterminated = new FormData();\n\t\tfdlLineterminated.left = new FormAttachment(0, 0);\n\t\tfdlLineterminated.right = new FormAttachment(middle, 0);\n\t\tfdlLineterminated.top = new FormAttachment(wEnclosed, margin);\n\t\twlLineterminated.setLayoutData(fdlLineterminated);\n\n\t\twLineterminated = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wLineterminated);\n\t\twLineterminated.addModifyListener(lsMod);\n\t\tfdLineterminated = new FormData();\n\t\tfdLineterminated.left = new FormAttachment(middle, 0);\n\t\tfdLineterminated.top = new FormAttachment(wEnclosed, margin);\n\t\tfdLineterminated.right = new FormAttachment(100, 0);\n\t\twLineterminated.setLayoutData(fdLineterminated);\n\n\n\n\n\t\t// List of columns to set for\n\t\twlListColumn = new Label(shell, SWT.RIGHT);\n\t\twlListColumn.setText(Messages.getString(\"JobMysqlBulkFile.ListColumn.Label\"));\n\t\tprops.setLook(wlListColumn);\n\t\tfdlListColumn = new FormData();\n\t\tfdlListColumn.left = new FormAttachment(0, 0);\n\t\tfdlListColumn.right = new FormAttachment(middle, 0);\n\t\tfdlListColumn.top = new FormAttachment(wLineterminated, margin);\n\t\twlListColumn.setLayoutData(fdlListColumn);\n\n        wbListColumns=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbListColumns);\n        wbListColumns.setText(Messages.getString(\"System.Button.Edit\"));\n        FormData fdbListColumns = new FormData();\n        fdbListColumns.right= new FormAttachment(100, 0);\n        fdbListColumns.top  = new FormAttachment(wLineterminated, margin);\n        wbListColumns.setLayoutData(fdbListColumns);\n        wbListColumns.addSelectionListener( new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { getListColumns(); } } );\n\n\t\twListColumn = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wListColumn);\n\t\twListColumn.setToolTipText(Messages.getString(\"JobMysqlBulkFile.ListColumn.Tooltip\"));\n\t\twListColumn.addModifyListener(lsMod);\n\t\tfdListColumn = new FormData();\n\t\tfdListColumn.left = new FormAttachment(middle, 0);\n\t\tfdListColumn.top = new FormAttachment(wLineterminated, margin);\n\t\tfdListColumn.right = new FormAttachment(wbListColumns, -margin);\n\t\twListColumn.setLayoutData(fdListColumn);\n\n\n\n\n\t\t// Nbr of lines to Limit\n\t\twlLimitlines = new Label(shell, SWT.RIGHT);\n\t\twlLimitlines.setText(Messages.getString(\"JobMysqlBulkFile.Limitlines.Label\"));\n\t\tprops.setLook(wlLimitlines);\n\t\tfdlLimitlines = new FormData();\n\t\tfdlLimitlines.left = new FormAttachment(0, 0);\n\t\tfdlLimitlines.right = new FormAttachment(middle, 0);\n\t\tfdlLimitlines.top = new FormAttachment(wListColumn, margin);\n\t\twlLimitlines.setLayoutData(fdlLimitlines);\n\n\t\twLimitlines = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wLimitlines);\n\t\twLimitlines.setToolTipText(Messages.getString(\"JobMysqlBulkFile.Limitlines.Tooltip\"));\n\t\twLimitlines.addModifyListener(lsMod);\n\t\tfdLimitlines = new FormData();\n\t\tfdLimitlines.left = new FormAttachment(middle, 0);\n\t\tfdLimitlines.top = new FormAttachment(wListColumn, margin);\n\t\tfdLimitlines.right = new FormAttachment(100, 0);\n\t\twLimitlines.setLayoutData(fdLimitlines);\n\n\n\t\t//IF File Exists\n\t\twlIfFileExists = new Label(shell, SWT.RIGHT);\n\t\twlIfFileExists.setText(Messages.getString(\"JobMysqlBulkFile.IfFileExists.Label\"));\n\t\tprops.setLook(wlIfFileExists);\n\t\tfdlIfFileExists = new FormData();\n\t\tfdlIfFileExists.left = new FormAttachment(0, 0);\n\t\tfdlIfFileExists.right = new FormAttachment(middle, 0);\n\t\tfdlIfFileExists.top = new FormAttachment(wLimitlines, margin);\n\t\twlIfFileExists.setLayoutData(fdlIfFileExists);\n\t\twIfFileExists = new CCombo(shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\n\t\twIfFileExists.add(Messages.getString(\"JobMysqlBulkFile.Create_NewFile_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobMysqlBulkFile.Do_Nothing_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobMysqlBulkFile.Fail_IfFileExists.Label\"));\n\t\twIfFileExists.select(2); // +1: starts at -1\n\n\t\tprops.setLook(wIfFileExists);\n\t\tfdIfFileExists= new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wLimitlines, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\t\tfdIfFileExists = new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wLimitlines, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\tFormData fd = new FormData();\n\t\tfd.right = new FormAttachment(50, -10);\n\t\tfd.bottom = new FormAttachment(100, 0);\n\t\tfd.width = 100;\n\t\twOK.setLayoutData(fd);\n\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(50, 10);\n\t\tfd.bottom = new FormAttachment(100, 0);\n\t\tfd.width = 100;\n\t\twCancel.setLayoutData(fd);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n\n\t\tlsDef = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twName.addSelectionListener(lsDef);\n\t\twTablename.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter()\n\t\t{\n\t\t\tpublic void shellClosed(ShellEvent e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\n\t\t// Allow the insertion of tabs as separator...\r\n\t\twbSeparator.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t{\r\n\t\t\t\twSeparator.setText(wSeparator.getText()+\"\\t\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t);\n\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\tprops.setDialogSize(shell, \"JobMysqlBulkFileDialogSize\");\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","id":104116,"modified_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, props.getJobsDialogStyle());\n\t\tprops.setLook(shell);\n\t\tJobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobMysqlBulkFile.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName = new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobMysqlBulkFile.Name.Label\"));\n\t\tprops.setLook(wlName);\n\t\tfdlName = new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right = new FormAttachment(middle, 0);\n\t\tfdlName.top = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName = new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top = new FormAttachment(0, margin);\n\t\tfdName.right = new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Connection line\n\t\twlConnection = new Label(shell, SWT.RIGHT);\n\t\twlConnection.setText(Messages.getString(\"JobMysqlBulkFile.Connection.Label\"));\n\t\tprops.setLook(wlConnection);\n\t\tfdlConnection = new FormData();\n\t\tfdlConnection.left = new FormAttachment(0, 0);\n\t\tfdlConnection.top = new FormAttachment(wName, margin);\n\t\tfdlConnection.right = new FormAttachment(middle, -margin);\n\t\twlConnection.setLayoutData(fdlConnection);\n\n\t\twbConnection = new Button(shell, SWT.PUSH);\n\t\twbConnection.setText(Messages.getString(\"System.Button.New\") + \"...\");\n\t\twbConnection.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tDatabaseMeta databaseMeta = new DatabaseMeta();\n\t\t\t\tDatabaseDialog cid = new DatabaseDialog(shell, databaseMeta);\n\t\t\t\tif (cid.open() != null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta.addDatabase(databaseMeta);\n\n\t\t\t\t\t// SB: Maybe do the same her as in BaseStepDialog: remove\n\t\t\t\t\t// all db connections and add them again.\n\t\t\t\t\twConnection.add(databaseMeta.getName());\n\t\t\t\t\twConnection.select(wConnection.getItemCount() - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfdbConnection = new FormData();\n\t\tfdbConnection.right = new FormAttachment(100, 0);\n\t\tfdbConnection.top = new FormAttachment(wName, margin);\n\t\tfdbConnection.height = 20;\n\t\twbConnection.setLayoutData(fdbConnection);\n\n\t\twConnection = new CCombo(shell, SWT.BORDER | SWT.READ_ONLY);\n\t\tprops.setLook(wConnection);\n\t\tfor (int i = 0; i < jobMeta.nrDatabases(); i++)\n\t\t{\n\t\t\tDatabaseMeta ci = jobMeta.getDatabase(i);\n\t\t\twConnection.add(ci.getName());\n\t\t}\n\t\twConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\tfdConnection = new FormData();\n\t\tfdConnection.left = new FormAttachment(middle, 0);\n\t\tfdConnection.top = new FormAttachment(wName, margin);\n\t\tfdConnection.right = new FormAttachment(wbConnection, -margin);\n\t\twConnection.setLayoutData(fdConnection);\n\n\t\t\n\t\t// Schema name line\n\t\twlSchemaname = new Label(shell, SWT.RIGHT);\n\t\twlSchemaname.setText(Messages.getString(\"JobMysqlBulkFile.Schemaname.Label\"));\n\t\tprops.setLook(wlSchemaname);\n\t\tfdlSchemaname = new FormData();\n\t\tfdlSchemaname.left = new FormAttachment(0, 0);\n\t\tfdlSchemaname.right = new FormAttachment(middle, 0);\n\t\tfdlSchemaname.top = new FormAttachment(wConnection, margin);\n\t\twlSchemaname.setLayoutData(fdlSchemaname);\n\n\t\twSchemaname = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wSchemaname);\n\t\twSchemaname.setToolTipText(Messages.getString(\"JobMysqlBulkFile.Schemaname.Tooltip\"));\n\t\twSchemaname.addModifyListener(lsMod);\n\t\tfdSchemaname = new FormData();\n\t\tfdSchemaname.left = new FormAttachment(middle, 0);\n\t\tfdSchemaname.top = new FormAttachment(wConnection, margin);\n\t\tfdSchemaname.right = new FormAttachment(100, 0);\n\t\twSchemaname.setLayoutData(fdSchemaname);\n\t\t\n\t\t// Table name line\n\t\twlTablename = new Label(shell, SWT.RIGHT);\n\t\twlTablename.setText(Messages.getString(\"JobMysqlBulkFile.Tablename.Label\"));\n\t\tprops.setLook(wlTablename);\n\t\tfdlTablename = new FormData();\n\t\tfdlTablename.left = new FormAttachment(0, 0);\n\t\tfdlTablename.right = new FormAttachment(middle, 0);\n\t\tfdlTablename.top = new FormAttachment(wSchemaname, margin);\n\t\twlTablename.setLayoutData(fdlTablename);\n\n        wbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbTable);\n        wbTable.setText(Messages.getString(\"System.Button.Browse\"));\n        FormData fdbTable = new FormData();\n        fdbTable.right= new FormAttachment(100, 0);\n        fdbTable.top  = new FormAttachment(wSchemaname, margin/2);\n        wbTable.setLayoutData(fdbTable);\n        wbTable.addSelectionListener( new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { getTableName(); } } );\n\n\t\twTablename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wTablename);\n\t\twTablename.setToolTipText(Messages.getString(\"JobMysqlBulkFile.Tablename.Tooltip\"));\n\t\twTablename.addModifyListener(lsMod);\n\t\tfdTablename = new FormData();\n\t\tfdTablename.left = new FormAttachment(middle, 0);\n\t\tfdTablename.top = new FormAttachment(wSchemaname, margin);\n\t\tfdTablename.right = new FormAttachment(wbTable, -margin);\n\t\twTablename.setLayoutData(fdTablename);\n\n\n\t\t// Filename line\n\t\twlFilename = new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"JobMysqlBulkFile.Filename.Label\"));\n\t\tprops.setLook(wlFilename);\n\t\tfdlFilename = new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdlFilename.right = new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbFilename = new Button(shell, SWT.PUSH | SWT.CENTER);\n\t\tprops.setLook(wbFilename);\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename = new FormData();\n\t\tfdbFilename.right = new FormAttachment(100, 0);\n\t\tfdbFilename.top = new FormAttachment(wTablename, 0);\n\t\t// fdbFilename.height = 22;\n\t\twbFilename.setLayoutData(fdbFilename);\n\n\t\twFilename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename = new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdFilename.right = new FormAttachment(wbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twFilename.setToolTipText(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t}\n\t\t});\n\n\t\twbFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\tdialog.setFilterExtensions(new String[] { \"*.txt\", \"*.csv\", \"*\" });\n\t\t\t\tif (wFilename.getText() != null)\n\t\t\t\t{\n\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t\t}\n\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\tif (dialog.open() != null)\n\t\t\t\t{\n\t\t\t\t\twFilename.setText(dialog.getFilterPath() + Const.FILE_SEPARATOR\n\t\t\t\t\t\t+ dialog.getFileName());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t//High Priority ?\n\t\twlHighPriority = new Label(shell, SWT.RIGHT);\n\t\twlHighPriority.setText(Messages.getString(\"JobMysqlBulkFile.HighPriority.Label\"));\n\t\tprops.setLook(wlHighPriority);\n\t\tfdlHighPriority = new FormData();\n\t\tfdlHighPriority.left = new FormAttachment(0, 0);\n\t\tfdlHighPriority.top = new FormAttachment(wFilename, margin);\n\t\tfdlHighPriority.right = new FormAttachment(middle, -margin);\n\t\twlHighPriority.setLayoutData(fdlHighPriority);\n\t\twHighPriority = new Button(shell, SWT.CHECK);\n\t\tprops.setLook(wHighPriority);\n\t\twHighPriority.setToolTipText(Messages.getString(\"JobMysqlBulkFile.HighPriority.Tooltip\"));\n\t\tfdHighPriority = new FormData();\n\t\tfdHighPriority.left = new FormAttachment(middle, 0);\n\t\tfdHighPriority.top = new FormAttachment(wFilename, margin);\n\t\tfdHighPriority.right = new FormAttachment(100, 0);\n\t\twHighPriority.setLayoutData(fdHighPriority);\n\t\twHighPriority.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\n\n\n\t\t// Out Dump\n\t\twlOutDumpValue = new Label(shell, SWT.RIGHT);\n\t\twlOutDumpValue.setText(Messages.getString(\"JobMysqlBulkFile.OutDumpValue.Label\"));\n\t\tprops.setLook(wlOutDumpValue);\n\t\tfdlOutDumpValue = new FormData();\n\t\tfdlOutDumpValue.left = new FormAttachment(0, 0);\n\t\tfdlOutDumpValue.right = new FormAttachment(middle, 0);\n\t\tfdlOutDumpValue.top = new FormAttachment(wHighPriority, margin);\n\t\twlOutDumpValue.setLayoutData(fdlOutDumpValue);\n\t\twOutDumpValue = new CCombo(shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\n\t\t\t\t\twOutDumpValue.add(Messages.getString(\"JobMysqlBulkFile.OutFileValue.Label\"));\n\t\t\t\t\twOutDumpValue.add(Messages.getString(\"JobMysqlBulkFile.DumpFileValue.Label\"));\n\t\t\t\t\twOutDumpValue.select(0); // +1: starts at -1\n\n\t\tprops.setLook(wOutDumpValue);\n\t\tfdOutDumpValue= new FormData();\n\t\tfdOutDumpValue.left = new FormAttachment(middle, 0);\n\t\tfdOutDumpValue.top = new FormAttachment(wHighPriority, margin);\n\t\tfdOutDumpValue.right = new FormAttachment(100, 0);\n\t\twOutDumpValue.setLayoutData(fdOutDumpValue);\n\n\t\tfdOutDumpValue = new FormData();\n\t\tfdOutDumpValue.left = new FormAttachment(middle, 0);\n\t\tfdOutDumpValue.top = new FormAttachment(wHighPriority, margin);\n\t\tfdOutDumpValue.right = new FormAttachment(100, 0);\n\t\twOutDumpValue.setLayoutData(fdOutDumpValue);\n\n\n\t\twOutDumpValue.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tDumpFile();\n\t\t\t}\n\t\t});\n\n\n\n\t\t// Separator\n\t\twlSeparator = new Label(shell, SWT.RIGHT);\n\t\twlSeparator.setText(Messages.getString(\"JobMysqlBulkFile.Separator.Label\"));\n\t\tprops.setLook(wlSeparator);\n\t\tfdlSeparator = new FormData();\n\t\tfdlSeparator.left = new FormAttachment(0, 0);\n\t\tfdlSeparator.right = new FormAttachment(middle, 0);\n\t\tfdlSeparator.top = new FormAttachment(wOutDumpValue, margin);\n\t\twlSeparator.setLayoutData(fdlSeparator);\n\n\t\twSeparator = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wSeparator);\n\t\twSeparator.addModifyListener(lsMod);\n\t\tfdSeparator = new FormData();\n\t\tfdSeparator.left = new FormAttachment(middle, 0);\n\t\tfdSeparator.top = new FormAttachment(wOutDumpValue, margin);\n\t\tfdSeparator.right = new FormAttachment(100, 0);\n\t\twSeparator.setLayoutData(fdSeparator);\n\n\t\t// enclosed\n\t\twlEnclosed = new Label(shell, SWT.RIGHT);\n\t\twlEnclosed.setText(Messages.getString(\"JobMysqlBulkFile.Enclosed.Label\"));\n\t\tprops.setLook(wlEnclosed);\n\t\tfdlEnclosed = new FormData();\n\t\tfdlEnclosed.left = new FormAttachment(0, 0);\n\t\tfdlEnclosed.right = new FormAttachment(middle, 0);\n\t\tfdlEnclosed.top = new FormAttachment(wSeparator, margin);\n\t\twlEnclosed.setLayoutData(fdlEnclosed);\n\n\t\twEnclosed = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wEnclosed);\n\t\twEnclosed.addModifyListener(lsMod);\n\t\tfdEnclosed = new FormData();\n\t\tfdEnclosed.left = new FormAttachment(middle, 0);\n\t\tfdEnclosed.top = new FormAttachment(wSeparator, margin);\n\t\tfdEnclosed.right = new FormAttachment(100, 0);\n\t\twEnclosed.setLayoutData(fdEnclosed);\n\n\t\t//Optionnally enclosed ?\n\t\twlOptionEnclosed = new Label(shell, SWT.RIGHT);\n\t\twlOptionEnclosed.setText(Messages.getString(\"JobMysqlBulkFile.OptionEnclosed.Label\"));\n\t\tprops.setLook(wlOptionEnclosed);\n\t\tfdlOptionEnclosed = new FormData();\n\t\tfdlOptionEnclosed.left = new FormAttachment(0, 0);\n\t\tfdlOptionEnclosed.top = new FormAttachment(wEnclosed, margin);\n\t\tfdlOptionEnclosed.right = new FormAttachment(middle, -margin);\n\t\twlOptionEnclosed.setLayoutData(fdlOptionEnclosed);\n\t\twOptionEnclosed = new Button(shell, SWT.CHECK);\n\t\tprops.setLook(wOptionEnclosed);\n\t\twOptionEnclosed.setToolTipText(Messages.getString(\"JobMysqlBulkFile.OptionEnclosed.Tooltip\"));\n\t\tfdOptionEnclosed = new FormData();\n\t\tfdOptionEnclosed.left = new FormAttachment(middle, 0);\n\t\tfdOptionEnclosed.top = new FormAttachment(wEnclosed, margin);\n\t\tfdOptionEnclosed.right = new FormAttachment(100, 0);\n\t\twOptionEnclosed.setLayoutData(fdOptionEnclosed);\n\t\twOptionEnclosed.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\n\n\t\t// Line terminated\n\t\twlLineterminated = new Label(shell, SWT.RIGHT);\n\t\twlLineterminated.setText(Messages.getString(\"JobMysqlBulkFile.Lineterminated.Label\"));\n\t\tprops.setLook(wlLineterminated);\n\t\tfdlLineterminated = new FormData();\n\t\tfdlLineterminated.left = new FormAttachment(0, 0);\n\t\tfdlLineterminated.right = new FormAttachment(middle, 0);\n\t\tfdlLineterminated.top = new FormAttachment(wOptionEnclosed, margin);\n\t\twlLineterminated.setLayoutData(fdlLineterminated);\n\n\t\twLineterminated = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wLineterminated);\n\t\twLineterminated.addModifyListener(lsMod);\n\t\tfdLineterminated = new FormData();\n\t\tfdLineterminated.left = new FormAttachment(middle, 0);\n\t\tfdLineterminated.top = new FormAttachment(wOptionEnclosed, margin);\n\t\tfdLineterminated.right = new FormAttachment(100, 0);\n\t\twLineterminated.setLayoutData(fdLineterminated);\n\n\n\n\n\t\t// List of columns to set for\n\t\twlListColumn = new Label(shell, SWT.RIGHT);\n\t\twlListColumn.setText(Messages.getString(\"JobMysqlBulkFile.ListColumn.Label\"));\n\t\tprops.setLook(wlListColumn);\n\t\tfdlListColumn = new FormData();\n\t\tfdlListColumn.left = new FormAttachment(0, 0);\n\t\tfdlListColumn.right = new FormAttachment(middle, 0);\n\t\tfdlListColumn.top = new FormAttachment(wLineterminated, margin);\n\t\twlListColumn.setLayoutData(fdlListColumn);\n\n        wbListColumns=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbListColumns);\n        wbListColumns.setText(Messages.getString(\"System.Button.Edit\"));\n        FormData fdbListColumns = new FormData();\n        fdbListColumns.right= new FormAttachment(100, 0);\n        fdbListColumns.top  = new FormAttachment(wLineterminated, margin);\n        wbListColumns.setLayoutData(fdbListColumns);\n        wbListColumns.addSelectionListener( new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { getListColumns(); } } );\n\n\t\twListColumn = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wListColumn);\n\t\twListColumn.setToolTipText(Messages.getString(\"JobMysqlBulkFile.ListColumn.Tooltip\"));\n\t\twListColumn.addModifyListener(lsMod);\n\t\tfdListColumn = new FormData();\n\t\tfdListColumn.left = new FormAttachment(middle, 0);\n\t\tfdListColumn.top = new FormAttachment(wLineterminated, margin);\n\t\tfdListColumn.right = new FormAttachment(wbListColumns, -margin);\n\t\twListColumn.setLayoutData(fdListColumn);\n\n\n\n\n\t\t// Nbr of lines to Limit\n\t\twlLimitlines = new Label(shell, SWT.RIGHT);\n\t\twlLimitlines.setText(Messages.getString(\"JobMysqlBulkFile.Limitlines.Label\"));\n\t\tprops.setLook(wlLimitlines);\n\t\tfdlLimitlines = new FormData();\n\t\tfdlLimitlines.left = new FormAttachment(0, 0);\n\t\tfdlLimitlines.right = new FormAttachment(middle, 0);\n\t\tfdlLimitlines.top = new FormAttachment(wListColumn, margin);\n\t\twlLimitlines.setLayoutData(fdlLimitlines);\n\n\t\twLimitlines = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wLimitlines);\n\t\twLimitlines.setToolTipText(Messages.getString(\"JobMysqlBulkFile.Limitlines.Tooltip\"));\n\t\twLimitlines.addModifyListener(lsMod);\n\t\tfdLimitlines = new FormData();\n\t\tfdLimitlines.left = new FormAttachment(middle, 0);\n\t\tfdLimitlines.top = new FormAttachment(wListColumn, margin);\n\t\tfdLimitlines.right = new FormAttachment(100, 0);\n\t\twLimitlines.setLayoutData(fdLimitlines);\n\n\n\t\t//IF File Exists\n\t\twlIfFileExists = new Label(shell, SWT.RIGHT);\n\t\twlIfFileExists.setText(Messages.getString(\"JobMysqlBulkFile.IfFileExists.Label\"));\n\t\tprops.setLook(wlIfFileExists);\n\t\tfdlIfFileExists = new FormData();\n\t\tfdlIfFileExists.left = new FormAttachment(0, 0);\n\t\tfdlIfFileExists.right = new FormAttachment(middle, 0);\n\t\tfdlIfFileExists.top = new FormAttachment(wLimitlines, margin);\n\t\twlIfFileExists.setLayoutData(fdlIfFileExists);\n\t\twIfFileExists = new CCombo(shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\n\t\twIfFileExists.add(Messages.getString(\"JobMysqlBulkFile.Create_NewFile_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobMysqlBulkFile.Do_Nothing_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobMysqlBulkFile.Fail_IfFileExists.Label\"));\n\t\twIfFileExists.select(2); // +1: starts at -1\n\n\t\tprops.setLook(wIfFileExists);\n\t\tfdIfFileExists= new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wLimitlines, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\t\tfdIfFileExists = new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wLimitlines, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\tFormData fd = new FormData();\n\t\tfd.right = new FormAttachment(50, -10);\n\t\tfd.bottom = new FormAttachment(100, 0);\n\t\tfd.width = 100;\n\t\twOK.setLayoutData(fd);\n\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(50, 10);\n\t\tfd.bottom = new FormAttachment(100, 0);\n\t\tfd.width = 100;\n\t\twCancel.setLayoutData(fd);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n\n\t\tlsDef = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twName.addSelectionListener(lsDef);\n\t\twTablename.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter()\n\t\t{\n\t\t\tpublic void shellClosed(ShellEvent e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\n\t\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\tprops.setDialogSize(shell, \"JobMysqlBulkFileDialogSize\");\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","commit_id":"d0144a7acd20554ca6e0aaa8d391ec95b00aa9d7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private Object[] getRowFromCache(RowMetaInterface lookupMeta, Object[] lookupRow) throws KettleException {\r\n        TimedRow timedRow = (TimedRow) data.look.get(new RowMetaAndData(data.lookupMeta, lookupRow));\r\n        if (timedRow!=null)\r\n        {\r\n            return timedRow.getRow();\r\n        }\r\n        else\r\n        {\r\n        \tif (meta.isLoadingAllDataInCache())\r\n        \t{\r\n        \t\t// OK, all data is loaded in memory and we still don't have a cache hit.\r\n        \t\t// \r\n        \t\tif (!data.allEquals)\r\n        \t\t{\r\n        \t\t\t// TODO: find an alternative way to look up the data based on the condition.\r\n        \t\t\t// Not all conditions are \"=\" so we are going to have to evaluate row by row\r\n        \t\t\t// A sorted list or index might be a good solution here...\r\n        \t\t\t// \r\n        \t\t\tEnumeration<RowMetaAndData> keys = data.look.keys();\r\n        \t\t\twhile (keys.hasMoreElements()) {\r\n        \t\t\t\tRowMetaAndData key = keys.nextElement();\r\n        \t\t\t\t// Now verify that the key is matching our conditions...\r\n        \t\t\t\t//\r\n        \t\t\t\tboolean match = true;\r\n    \t\t\t\t\tfor (int i=0;i<data.conditions.length && match;i++) {\r\n        \t\t\t\t\tValueMetaInterface cmpMeta = lookupMeta.getValueMeta(i);\r\n        \t\t\t\t\tObject cmpData = lookupRow[i];\r\n        \t\t\t\t\tValueMetaInterface keyMeta = key.getValueMeta(i);\r\n        \t\t\t\t\tObject keyData = key.getData()[i];\r\n        \t\t\t\t\t\r\n        \t\t\t\t\tswitch(data.conditions[i]) {\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_EQ : match = (cmpMeta.compare(cmpData, keyMeta, keyData)==0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_NE : match = (cmpMeta.compare(cmpData, keyMeta, keyData)!=0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_LT : match = (cmpMeta.compare(cmpData, keyMeta, keyData)>0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_LE : match = (cmpMeta.compare(cmpData, keyMeta, keyData)>=0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_GT : match = (cmpMeta.compare(cmpData, keyMeta, keyData)<0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_GE : match = (cmpMeta.compare(cmpData, keyMeta, keyData)<=0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_IS_NULL: match = keyMeta.isNull(keyData); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_IS_NOT_NULL: match = !keyMeta.isNull(keyData); break;\r\n        \t\t\t\t\tdefault: match=false; break; \r\n        \t\t\t\t\t// TODO: add LIKE, BETWEEN operators\r\n        \t\t\t\t\t}\r\n        \t\t\t\t}\r\n    \t\t\t\t\tif (match) {\r\n    \t\t\t\t\t\ttimedRow = data.look.get(key);\r\n    \t\t\t\t        if (timedRow!=null)\r\n    \t\t\t\t        {\r\n    \t\t\t\t            return timedRow.getRow();\r\n    \t\t\t\t        }\r\n    \t\t\t\t        else\r\n    \t\t\t\t        {\r\n    \t\t\t\t        \t// This should never occur\r\n    \t\t\t\t        }\r\n    \t\t\t\t\t}\r\n        \t\t\t}\r\n        \t\t}\r\n        \t\telse\r\n        \t\t{\r\n        \t\t\t// TODO: this is some program error, we should have gotten a hit here!\r\n        \t\t\t// throw new KettleException(\"Unexpected cache miss while loading all data\");\r\n        \t\t}\r\n        \t}\r\n        }\r\n        return null;\r\n\t}","id":104117,"modified_method":"private Object[] getRowFromCache(RowMetaInterface lookupMeta, Object[] lookupRow) throws KettleException {\r\n        TimedRow timedRow = (TimedRow) data.look.get(new RowMetaAndData(data.lookupMeta, lookupRow));\r\n        if (timedRow!=null)\r\n        {\r\n            return timedRow.getRow();\r\n        }\r\n        else\r\n        {\r\n        \tif (meta.isLoadingAllDataInCache())\r\n        \t{\r\n        \t\t// OK, all data is loaded in memory and we still don't have a cache hit.\r\n        \t\t// \r\n        \t\tif (!data.allEquals)\r\n        \t\t{\r\n        \t\t\t// TODO: find an alternative way to look up the data based on the condition.\r\n        \t\t\t// Not all conditions are \"=\" so we are going to have to evaluate row by row\r\n        \t\t\t// A sorted list or index might be a good solution here...\r\n        \t\t\t// \r\n        \t\t\tEnumeration<RowMetaAndData> keys = data.look.keys();\r\n        \t\t\twhile (keys.hasMoreElements()) {\r\n        \t\t\t\tRowMetaAndData key = keys.nextElement();\r\n        \t\t\t\t// Now verify that the key is matching our conditions...\r\n        \t\t\t\t//\r\n        \t\t\t\tboolean match = true;\r\n    \t\t\t\t\tfor (int i=0;i<data.conditions.length && match;i++) {\r\n        \t\t\t\t\tValueMetaInterface cmpMeta = lookupMeta.getValueMeta(i);\r\n        \t\t\t\t\tObject cmpData = lookupRow[i];\r\n        \t\t\t\t\tValueMetaInterface keyMeta = key.getValueMeta(i);\r\n        \t\t\t\t\tObject keyData = key.getData()[i];\r\n        \t\t\t\t\t\r\n        \t\t\t\t\tswitch(data.conditions[i]) {\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_EQ : match = (cmpMeta.compare(cmpData, keyMeta, keyData)==0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_NE : match = (cmpMeta.compare(cmpData, keyMeta, keyData)!=0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_LT : match = (cmpMeta.compare(cmpData, keyMeta, keyData)>0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_LE : match = (cmpMeta.compare(cmpData, keyMeta, keyData)>=0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_GT : match = (cmpMeta.compare(cmpData, keyMeta, keyData)<0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_GE : match = (cmpMeta.compare(cmpData, keyMeta, keyData)<=0); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_IS_NULL: match = keyMeta.isNull(keyData); break;\r\n        \t\t\t\t\tcase DatabaseLookupMeta.CONDITION_IS_NOT_NULL: match = !keyMeta.isNull(keyData); break;\r\n        \t\t\t\t\tdefault: match=false; break; \r\n        \t\t\t\t\t// TODO: add LIKE, BETWEEN operators\r\n        \t\t\t\t\t}\r\n        \t\t\t\t}\r\n    \t\t\t\t\tif (match) {\r\n    \t\t\t\t\t\ttimedRow = data.look.get(key);\r\n    \t\t\t\t        if (timedRow!=null)\r\n    \t\t\t\t        {\r\n    \t\t\t\t            return timedRow.getRow();\r\n    \t\t\t\t        }\r\n    \t\t\t\t        else\r\n    \t\t\t\t        {\r\n    \t\t\t\t        \t// This should never occur\r\n    \t\t\t\t        }\r\n    \t\t\t\t\t}\r\n        \t\t\t}\r\n        \t\t}\r\n        \t}\r\n        }\r\n        return null;\r\n\t}","commit_id":"d190e2c32206da4d6825624ebc81ef2c3fa91847","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Performs the lookup based on the meta-data and the input row.\n\t * @param row The row to use as lookup data and the row to add the returned lookup fields to\n\t * @return the resulting row after the lookup values where added\n\t * @throws KettleException In case something goes wrong.\n\t */\n\tprivate synchronized Object[] lookupValues(RowMetaInterface inputRowMeta, Object[] row) throws KettleException\n\t{\n\t\tObject[] outputRow = RowDataUtil.resizeArray(row, data.outputRowMeta.size());\n                \n        Object[] lookupRow = new Object[data.lookupMeta.size()];\n        int lookupIndex=0;\n        \n        for (int i=0;i<meta.getStreamKeyField1().length;i++)\n\t\t{\n\t\t\tif (data.keynrs[i]>=0)\n\t\t\t{\n                ValueMetaInterface input = inputRowMeta.getValueMeta(data.keynrs[i]);\n\t\t\t\tValueMetaInterface value = data.lookupMeta.getValueMeta(lookupIndex);\n                lookupRow[lookupIndex] = row[data.keynrs[i]];\n                \n\t\t\t\t// Try to convert type if needed\n\t\t\t\tif (input.getType()!=value.getType())\n                {\n                    lookupRow[lookupIndex] = value.convertData(input, lookupRow[lookupIndex]);\n                }\n                lookupIndex++;\n\t\t\t}\n\t\t\tif (data.keynrs2[i]>=0)\n\t\t\t{\n                ValueMetaInterface input = inputRowMeta.getValueMeta(data.keynrs2[i]);\n                ValueMetaInterface value = data.lookupMeta.getValueMeta(lookupIndex);\n                lookupRow[lookupIndex] = row[data.keynrs2[i]];\n                \n                // Try to convert type if needed\n                if (input.getType()!=value.getType())\n                {\n                    lookupRow[lookupIndex] = value.convertData(input, lookupRow[lookupIndex]);\n                }\n                lookupIndex++;\n\t\t\t}\n\t\t}\n\n        Object[] add = null;\n        boolean cache_now=false;\r\n        boolean cacheHit = false;\n\n\t\t// First, check if we looked up before\n\t\tif (meta.isCached())\n        {\r\n\t\t\tadd = getRowFromCache(data.lookupMeta, lookupRow);\r\n\t\t\tif (add!=null) \r\n\t\t\t{\r\n\t\t\t\tcacheHit=true;\r\n\t\t\t}\n        }\n\t\telse add=null; \n\n\t\tif (add==null)\n\t\t{\n\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.AddedValuesToLookupRow1\")+meta.getStreamKeyField1().length+Messages.getString(\"DatabaseLookup.Log.AddedValuesToLookupRow2\")+data.lookupMeta.getString(lookupRow)); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\tdata.db.setValuesLookup(data.lookupMeta, lookupRow);\n\t\t\tadd = data.db.getLookup(meta.isFailingOnMultipleResults());\n\t\t\tcache_now=true;\n\t\t}\n\n\t\tif (add==null) // nothing was found, unknown code: add default values\n\t\t{\n\t\t\tif (meta.isEatingRowOnLookupFailure())\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (getStepMeta().isDoingErrorHandling())\n\t\t\t{\n                putError(getInputRowMeta(), row, 1L, \"No lookup found\", null, \"DBL001\");\n\n                // return false else we would still be processed.\n                return null;\n\t\t\t}\n\t\t\t\n\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.NoResultsFoundAfterLookup\")); //$NON-NLS-1$\n            \n\t\t\tadd=new Object[data.returnMeta.size()];\n\t\t\tfor (int i=0;i<meta.getReturnValueField().length;i++)\n\t\t\t{\n\t\t\t\tif (data.nullif[i]!=null)\n\t\t\t\t{\n\t\t\t\t\tadd[i] = data.nullif[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd[i] = null;\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        else\n        {\n        \tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.FoundResultsAfterLookup\")+add); //$NON-NLS-1$\n\r\n        \t// Only verify the data types if the data comes from the DB, NOT when we have a cache hit\r\n        \t// In that case, we already know the data type is OK.\r\n        \tif (!cacheHit)\r\n        \t{\n\t        \tint types[] = meta.getReturnValueDefaultType();\n\t\n\t        \t// The assumption here is that the types are in the same order\n\t        \t// as the returned lookup row, but since we make the lookup row\n\t        \t// that should not be a problem.\n\t            //\n\t            for (int i=0;i<types.length;i++)\n\t        \t{  \n\t        \t\tValueMetaInterface returned = data.db.getReturnRowMeta().getValueMeta(i);\n\t                ValueMetaInterface expected = data.returnMeta.getValueMeta(i);\n\t                \n\t                if ( returned != null && types[i] > 0 && types[i] !=  returned.getType() )\n\t        \t\t{\n\t        \t\t\t// Set the type to the default return type\n\t        \t\t    add[i] = expected.convertData(returned, add[i]);\n\t        \t\t}\n\t        \t}\r\n        \t}\n        } \n\n\t\t// Store in cache if we need to!\r\n\t\t// If we already loaded all data into the cache, storing more makes no sense.\r\n\t\t//\r\n\t\tif (meta.isCached() && cache_now && !meta.isLoadingAllDataInCache())\r\n\t\t{\r\n\t\t\tstoreRowInCache(data.lookupMeta, lookupRow, add);\n\t\t}\n\n\t\tfor (int i=0;i<data.returnMeta.size();i++)\n\t\t{\n\t\t\toutputRow[inputRowMeta.size()+i] = add[i];\n\t\t}\n\n\t\treturn outputRow;\n\t}","id":104118,"modified_method":"/**\n\t * Performs the lookup based on the meta-data and the input row.\n\t * @param row The row to use as lookup data and the row to add the returned lookup fields to\n\t * @return the resulting row after the lookup values where added\n\t * @throws KettleException In case something goes wrong.\n\t */\n\tprivate synchronized Object[] lookupValues(RowMetaInterface inputRowMeta, Object[] row) throws KettleException\n\t{\n\t\tObject[] outputRow = RowDataUtil.resizeArray(row, data.outputRowMeta.size());\n                \n        Object[] lookupRow = new Object[data.lookupMeta.size()];\n        int lookupIndex=0;\n        \n        for (int i=0;i<meta.getStreamKeyField1().length;i++)\n\t\t{\n\t\t\tif (data.keynrs[i]>=0)\n\t\t\t{\n                ValueMetaInterface input = inputRowMeta.getValueMeta(data.keynrs[i]);\n\t\t\t\tValueMetaInterface value = data.lookupMeta.getValueMeta(lookupIndex);\n                lookupRow[lookupIndex] = row[data.keynrs[i]];\n                \n\t\t\t\t// Try to convert type if needed\n\t\t\t\tif (input.getType()!=value.getType())\n                {\n                    lookupRow[lookupIndex] = value.convertData(input, lookupRow[lookupIndex]);\n                }\n                lookupIndex++;\n\t\t\t}\n\t\t\tif (data.keynrs2[i]>=0)\n\t\t\t{\n                ValueMetaInterface input = inputRowMeta.getValueMeta(data.keynrs2[i]);\n                ValueMetaInterface value = data.lookupMeta.getValueMeta(lookupIndex);\n                lookupRow[lookupIndex] = row[data.keynrs2[i]];\n                \n                // Try to convert type if needed\n                if (input.getType()!=value.getType())\n                {\n                    lookupRow[lookupIndex] = value.convertData(input, lookupRow[lookupIndex]);\n                }\n                lookupIndex++;\n\t\t\t}\n\t\t}\n\n        Object[] add = null;\n        boolean cache_now=false;\r\n        boolean cacheHit = false;\n\n\t\t// First, check if we looked up before\n\t\tif (meta.isCached())\n        {\r\n\t\t\tadd = getRowFromCache(data.lookupMeta, lookupRow);\r\n\t\t\tif (add!=null) \r\n\t\t\t{\r\n\t\t\t\tcacheHit=true;\r\n\t\t\t}\n        }\n\t\telse add=null; \n\n\t\tif (add==null)\n\t\t{\n\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.AddedValuesToLookupRow1\")+meta.getStreamKeyField1().length+Messages.getString(\"DatabaseLookup.Log.AddedValuesToLookupRow2\")+data.lookupMeta.getString(lookupRow)); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\tdata.db.setValuesLookup(data.lookupMeta, lookupRow);\n\t\t\tadd = data.db.getLookup(meta.isFailingOnMultipleResults());\n\t\t\tcache_now=true;\n\t\t}\n\n\t\tif (add==null) // nothing was found, unknown code: add default values\n\t\t{\n\t\t\tif (meta.isEatingRowOnLookupFailure())\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (getStepMeta().isDoingErrorHandling())\n\t\t\t{\n                putError(getInputRowMeta(), row, 1L, \"No lookup found\", null, \"DBL001\");\n\n                // return false else we would still be processed.\n                return null;\n\t\t\t}\n\t\t\t\n\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.NoResultsFoundAfterLookup\")); //$NON-NLS-1$\n            \n\t\t\tadd=new Object[data.returnMeta.size()];\n\t\t\tfor (int i=0;i<meta.getReturnValueField().length;i++)\n\t\t\t{\n\t\t\t\tif (data.nullif[i]!=null)\n\t\t\t\t{\n\t\t\t\t\tadd[i] = data.nullif[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd[i] = null;\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        else\n        {\n        \tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.FoundResultsAfterLookup\")+add); //$NON-NLS-1$\n\r\n        \t// Only verify the data types if the data comes from the DB, NOT when we have a cache hit\r\n        \t// In that case, we already know the data type is OK.\r\n        \tif (!cacheHit)\r\n        \t{\n\t        \tint types[] = meta.getReturnValueDefaultType();\n\t\n\t        \t// The assumption here is that the types are in the same order\n\t        \t// as the returned lookup row, but since we make the lookup row\n\t        \t// that should not be a problem.\n\t            //\n\t            for (int i=0;i<types.length;i++)\n\t        \t{  \n\t        \t\tValueMetaInterface returned = data.db.getReturnRowMeta().getValueMeta(i);\n\t                ValueMetaInterface expected = data.returnMeta.getValueMeta(i);\n\t                \n\t                if ( returned != null && types[i] > 0 && types[i] !=  returned.getType() )\n\t        \t\t{\n\t        \t\t\t// Set the type to the default return type\n\t        \t\t    add[i] = expected.convertData(returned, add[i]);\n\t        \t\t}\n\t        \t}\r\n        \t}\n        } \n\n\t\t// Store in cache if we need to!\r\n\t\t// If we already loaded all data into the cache, storing more makes no sense.\r\n\t\t//\r\n\t\tif (meta.isCached() && cache_now && !meta.isLoadingAllDataInCache() && data.allEquals)\r\n\t\t{\r\n\t\t\tstoreRowInCache(data.lookupMeta, lookupRow, add);\n\t\t}\n\n\t\tfor (int i=0;i<data.returnMeta.size();i++)\n\t\t{\n\t\t\toutputRow[inputRowMeta.size()+i] = add[i];\n\t\t}\n\n\t\treturn outputRow;\n\t}","commit_id":"d190e2c32206da4d6825624ebc81ef2c3fa91847","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\t\n\t\tFocusListener lsFocusLost = new FocusAdapter() {\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t\tsetTableFieldCombo();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DatabaseLookupDialog.shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DatabaseLookupDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"DatabaseLookupDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        wSchema.addFocusListener(lsFocusLost);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"DatabaseLookupDialog.Lookuptable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin*2);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"DatabaseLookupDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\twTable.addFocusListener(lsFocusLost);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin*2);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Cache?\n\t\twlCache=new Label(shell, SWT.RIGHT);\n\t\twlCache.setText(Messages.getString(\"DatabaseLookupDialog.Cache.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCache);\n\t\tfdlCache=new FormData();\n\t\tfdlCache.left = new FormAttachment(0, 0);\n\t\tfdlCache.right= new FormAttachment(middle, -margin);\n\t\tfdlCache.top  = new FormAttachment(wbTable, margin);\n\t\twlCache.setLayoutData(fdlCache);\n\t\twCache=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wCache);\n\t\tfdCache=new FormData();\n\t\tfdCache.left = new FormAttachment(middle, 0);\n\t\tfdCache.top  = new FormAttachment(wbTable, margin);\n\t\twCache.setLayoutData(fdCache);\n\t\twCache.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tinput.setChanged();\n\t\t\t\t\t\n\t\t\t\t\twCachesize.setEnabled(wCache.getSelection());\n\t\t\t\t\twlCachesize.setEnabled(wCache.getSelection());\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Cache size line\n\t\twlCachesize=new Label(shell, SWT.RIGHT);\n\t\twlCachesize.setText(Messages.getString(\"DatabaseLookupDialog.Cachesize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCachesize);\n\t\twlCachesize.setEnabled(input.isCached());\n\t\tfdlCachesize=new FormData();\n\t\tfdlCachesize.left   = new FormAttachment(0, 0);\n\t\tfdlCachesize.right  = new FormAttachment(middle, -margin);\n\t\tfdlCachesize.top    = new FormAttachment(wlCache, margin);\n\t\twlCachesize.setLayoutData(fdlCachesize);\n\t\twCachesize=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCachesize);\n\t\twCachesize.setEnabled(input.isCached());\n\t\twCachesize.addModifyListener(lsMod);\n\t\tfdCachesize=new FormData();\n\t\tfdCachesize.left   = new FormAttachment(middle, 0);\n\t\tfdCachesize.right  = new FormAttachment(100, 0);\n\t\tfdCachesize.top    = new FormAttachment(wlCache, margin);\n\t\twCachesize.setLayoutData(fdCachesize);\n\n\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"DatabaseLookupDialog.Keys.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCachesize, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getStreamKeyField1()!=null?input.getStreamKeyField1().length:1);\n\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Tablefield\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},  false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Comparator\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field1\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field2\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\ttableFieldColumns.add(ciKey[0]);\n\t\tfieldColumns.add(ciKey[2]);\n\t\tfieldColumns.add(ciKey[3]);\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdKey=new FormData();\n\t\tfdKey.left  = new FormAttachment(0, 0);\n\t\tfdKey.top   = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(100, 0);\n\t\tfdKey.bottom= new FormAttachment(wlKey, 150);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DatabaseLookupDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twGetLU=new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"DatabaseLookupDialog.GetLookupFields.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel , wGet, wGetLU}, margin, null);\n\n\t\t// OderBy line\n\t\twlOrderBy=new Label(shell, SWT.RIGHT);\n\t\twlOrderBy.setText(Messages.getString(\"DatabaseLookupDialog.Orderby.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlOrderBy);\n\t\tfdlOrderBy=new FormData();\n\t\tfdlOrderBy.left   = new FormAttachment(0, 0);\n\t\tfdlOrderBy.right  = new FormAttachment(middle, -margin);\n\t\tfdlOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\twlOrderBy.setLayoutData(fdlOrderBy);\n\t\twOrderBy=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wOrderBy);\n\t\tfdOrderBy=new FormData();\n\t\tfdOrderBy.left   = new FormAttachment(middle, 0);\n\t\tfdOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\tfdOrderBy.right  = new FormAttachment(100, 0);\n\t\twOrderBy.setLayoutData(fdOrderBy);\n\n        // FailMultiple?\n        wlFailMultiple=new Label(shell, SWT.RIGHT);\n        wlFailMultiple.setText(Messages.getString(\"DatabaseLookupDialog.FailMultiple.Label\")); //$NON-NLS-1$\n        props.setLook(wlFailMultiple);\n        fdlFailMultiple=new FormData();\n        fdlFailMultiple.left   = new FormAttachment(0, 0);\n        fdlFailMultiple.right  = new FormAttachment(middle, -margin);\n        fdlFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wlFailMultiple.setLayoutData(fdlFailMultiple);\n        wFailMultiple=new Button(shell, SWT.CHECK);\n        props.setLook(wFailMultiple);\n        fdFailMultiple=new FormData();\n        fdFailMultiple.left   = new FormAttachment(middle, 0);\n        fdFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wFailMultiple.setLayoutData(fdFailMultiple);\n        wFailMultiple.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    setFlags();\n                }\n            }\n        );\n\n        // EatRows?\n        wlEatRows=new Label(shell, SWT.RIGHT);\n        wlEatRows.setText(Messages.getString(\"DatabaseLookupDialog.EatRows.Label\")); //$NON-NLS-1$\n        props.setLook(wlEatRows);\n        fdlEatRows=new FormData();\n        fdlEatRows.left   = new FormAttachment(0, 0);\n        fdlEatRows.right  = new FormAttachment(middle, -margin);\n        fdlEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wlEatRows.setLayoutData(fdlEatRows);\n        wEatRows=new Button(shell, SWT.CHECK);\n        props.setLook(wEatRows);\n        fdEatRows=new FormData();\n        fdEatRows.left   = new FormAttachment(middle, 0);\n        fdEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wEatRows.setLayoutData(fdEatRows);\n        wEatRows.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    setFlags();\n                }\n            }\n        );\n\n        \n        // THE UPDATE/INSERT TABLE\n        wlReturn=new Label(shell, SWT.NONE);\n        wlReturn.setText(Messages.getString(\"DatabaseLookupDialog.Return.Label\")); //$NON-NLS-1$\n        props.setLook(wlReturn);\n        fdlReturn=new FormData();\n        fdlReturn.left  = new FormAttachment(0, 0);\n        fdlReturn.top   = new FormAttachment(wKey, margin);\n        wlReturn.setLayoutData(fdlReturn);\n        \n        int UpInsCols=4;\n        int UpInsRows= (input.getReturnValueField()!=null?input.getReturnValueField().length:1);\n        \n        ColumnInfo[] ciReturn=new ColumnInfo[UpInsCols];\n        ciReturn[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field\"),    ColumnInfo.COLUMN_TYPE_CCOMBO,new String[]{},  false); //$NON-NLS-1$\n        ciReturn[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Newname\"), ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Default\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Type\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes()); //$NON-NLS-1$\n        tableFieldColumns.add(ciReturn[0]);\n        \n        wReturn=new TableView(transMeta, shell, \n                              SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n                              ciReturn, \n                              UpInsRows,  \n                              lsMod,\n                              props\n                              );\n\n        fdReturn=new FormData();\n        fdReturn.left  = new FormAttachment(0, 0);\n        fdReturn.top   = new FormAttachment(wlReturn, margin);\n        fdReturn.right = new FormAttachment(100, 0);\n        fdReturn.bottom= new FormAttachment(wEatRows, -margin);\n        wReturn.setLayoutData(fdReturn);\n\n\n        \n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsGetLU    = new Listener() { public void handleEvent(Event e) { getlookup(); } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twGetLU.addListener (SWT.Selection, lsGetLU );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twTable.addSelectionListener( lsDef );\n\t\twOrderBy.addSelectionListener( lsDef );\n\t\twCachesize.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\t\t\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\n\t\tsetComboValues();\n\t\tsetTableFieldCombo();\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":104119,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\t\n\t\tFocusListener lsFocusLost = new FocusAdapter() {\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t\tsetTableFieldCombo();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DatabaseLookupDialog.shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DatabaseLookupDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"DatabaseLookupDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        wSchema.addFocusListener(lsFocusLost);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"DatabaseLookupDialog.Lookuptable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin*2);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"DatabaseLookupDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\twTable.addFocusListener(lsFocusLost);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin*2);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Cache?\n\t\twlCache=new Label(shell, SWT.RIGHT);\n\t\twlCache.setText(Messages.getString(\"DatabaseLookupDialog.Cache.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCache);\n\t\tfdlCache=new FormData();\n\t\tfdlCache.left = new FormAttachment(0, 0);\n\t\tfdlCache.right= new FormAttachment(middle, -margin);\n\t\tfdlCache.top  = new FormAttachment(wTable, margin);\n\t\twlCache.setLayoutData(fdlCache);\n\t\twCache=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wCache);\n\t\tfdCache=new FormData();\n\t\tfdCache.left = new FormAttachment(middle, 0);\n\t\tfdCache.top  = new FormAttachment(wTable, margin);\n\t\twCache.setLayoutData(fdCache);\n\t\twCache.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tinput.setChanged();\n\t\t\t\t\tenableFields();\r\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\r\n\t\t// Cache size line\n\t\twlCachesize=new Label(shell, SWT.RIGHT);\n\t\twlCachesize.setText(Messages.getString(\"DatabaseLookupDialog.Cachesize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCachesize);\n\t\twlCachesize.setEnabled(input.isCached());\n\t\tfdlCachesize=new FormData();\n\t\tfdlCachesize.left   = new FormAttachment(0, 0);\n\t\tfdlCachesize.right  = new FormAttachment(middle, -margin);\n\t\tfdlCachesize.top    = new FormAttachment(wCache, margin);\n\t\twlCachesize.setLayoutData(fdlCachesize);\n\t\twCachesize=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCachesize);\n\t\twCachesize.setEnabled(input.isCached());\n\t\twCachesize.addModifyListener(lsMod);\n\t\tfdCachesize=new FormData();\n\t\tfdCachesize.left   = new FormAttachment(middle, 0);\n\t\tfdCachesize.right  = new FormAttachment(100, 0);\n\t\tfdCachesize.top    = new FormAttachment(wCache, margin);\n\t\twCachesize.setLayoutData(fdCachesize);\n\n\t\t// Cache : Load all?\r\n\t\twlCacheLoadAll=new Label(shell, SWT.RIGHT);\r\n\t\twlCacheLoadAll.setText(Messages.getString(\"DatabaseLookupDialog.CacheLoadAll.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlCacheLoadAll);\r\n\t\tfdlCacheLoadAll=new FormData();\r\n\t\tfdlCacheLoadAll.left = new FormAttachment(0, 0);\r\n\t\tfdlCacheLoadAll.right= new FormAttachment(middle, -margin);\r\n\t\tfdlCacheLoadAll.top  = new FormAttachment(wCachesize, margin);\r\n\t\twlCacheLoadAll.setLayoutData(fdlCacheLoadAll);\r\n\t\twCacheLoadAll=new Button(shell, SWT.CHECK);\r\n \t\tprops.setLook(wCacheLoadAll);\r\n\t\tfdCacheLoadAll=new FormData();\r\n\t\tfdCacheLoadAll.left = new FormAttachment(middle, 0);\r\n\t\tfdCacheLoadAll.top  = new FormAttachment(wCachesize, margin);\r\n\t\twCacheLoadAll.setLayoutData(fdCacheLoadAll);\r\n\t\twCacheLoadAll.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\tenableFields();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"DatabaseLookupDialog.Keys.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCacheLoadAll, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getStreamKeyField1()!=null?input.getStreamKeyField1().length:1);\n\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Tablefield\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},  false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Comparator\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, DatabaseLookupMeta.conditionStrings);\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field1\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field2\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\ttableFieldColumns.add(ciKey[0]);\n\t\tfieldColumns.add(ciKey[2]);\n\t\tfieldColumns.add(ciKey[3]);\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdKey=new FormData();\n\t\tfdKey.left  = new FormAttachment(0, 0);\n\t\tfdKey.top   = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(100, 0);\n\t\tfdKey.bottom= new FormAttachment(wlKey, 250);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DatabaseLookupDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twGetLU=new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"DatabaseLookupDialog.GetLookupFields.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel , wGet, wGetLU}, margin, null);\n\n\t\t// OderBy line\n\t\twlOrderBy=new Label(shell, SWT.RIGHT);\n\t\twlOrderBy.setText(Messages.getString(\"DatabaseLookupDialog.Orderby.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlOrderBy);\n\t\tfdlOrderBy=new FormData();\n\t\tfdlOrderBy.left   = new FormAttachment(0, 0);\n\t\tfdlOrderBy.right  = new FormAttachment(middle, -margin);\n\t\tfdlOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\twlOrderBy.setLayoutData(fdlOrderBy);\n\t\twOrderBy=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wOrderBy);\n\t\tfdOrderBy=new FormData();\n\t\tfdOrderBy.left   = new FormAttachment(middle, 0);\n\t\tfdOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\tfdOrderBy.right  = new FormAttachment(100, 0);\n\t\twOrderBy.setLayoutData(fdOrderBy);\n\n        // FailMultiple?\n        wlFailMultiple=new Label(shell, SWT.RIGHT);\n        wlFailMultiple.setText(Messages.getString(\"DatabaseLookupDialog.FailMultiple.Label\")); //$NON-NLS-1$\n        props.setLook(wlFailMultiple);\n        fdlFailMultiple=new FormData();\n        fdlFailMultiple.left   = new FormAttachment(0, 0);\n        fdlFailMultiple.right  = new FormAttachment(middle, -margin);\n        fdlFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wlFailMultiple.setLayoutData(fdlFailMultiple);\n        wFailMultiple=new Button(shell, SWT.CHECK);\n        props.setLook(wFailMultiple);\n        fdFailMultiple=new FormData();\n        fdFailMultiple.left   = new FormAttachment(middle, 0);\n        fdFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wFailMultiple.setLayoutData(fdFailMultiple);\n        wFailMultiple.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    enableFields();\n                }\n            }\n        );\n\n        // EatRows?\n        wlEatRows=new Label(shell, SWT.RIGHT);\n        wlEatRows.setText(Messages.getString(\"DatabaseLookupDialog.EatRows.Label\")); //$NON-NLS-1$\n        props.setLook(wlEatRows);\n        fdlEatRows=new FormData();\n        fdlEatRows.left   = new FormAttachment(0, 0);\n        fdlEatRows.right  = new FormAttachment(middle, -margin);\n        fdlEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wlEatRows.setLayoutData(fdlEatRows);\n        wEatRows=new Button(shell, SWT.CHECK);\n        props.setLook(wEatRows);\n        fdEatRows=new FormData();\n        fdEatRows.left   = new FormAttachment(middle, 0);\n        fdEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wEatRows.setLayoutData(fdEatRows);\n        wEatRows.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    enableFields();\n                }\n            }\n        );\n\n        \n        // THE UPDATE/INSERT TABLE\n        wlReturn=new Label(shell, SWT.NONE);\n        wlReturn.setText(Messages.getString(\"DatabaseLookupDialog.Return.Label\")); //$NON-NLS-1$\n        props.setLook(wlReturn);\n        fdlReturn=new FormData();\n        fdlReturn.left  = new FormAttachment(0, 0);\n        fdlReturn.top   = new FormAttachment(wKey, margin);\n        wlReturn.setLayoutData(fdlReturn);\n        \n        int UpInsCols=4;\n        int UpInsRows= (input.getReturnValueField()!=null?input.getReturnValueField().length:1);\n        \n        ColumnInfo[] ciReturn=new ColumnInfo[UpInsCols];\n        ciReturn[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field\"),    ColumnInfo.COLUMN_TYPE_CCOMBO,new String[]{},  false); //$NON-NLS-1$\n        ciReturn[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Newname\"), ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Default\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Type\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes()); //$NON-NLS-1$\n        tableFieldColumns.add(ciReturn[0]);\n        \n        wReturn=new TableView(transMeta, shell, \n                              SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n                              ciReturn, \n                              UpInsRows,  \n                              lsMod,\n                              props\n                              );\n\n        fdReturn=new FormData();\n        fdReturn.left  = new FormAttachment(0, 0);\n        fdReturn.top   = new FormAttachment(wlReturn, margin);\n        fdReturn.right = new FormAttachment(100, 0);\n        fdReturn.bottom= new FormAttachment(wEatRows, -margin);\n        wReturn.setLayoutData(fdReturn);\n\n\n        \n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsGetLU    = new Listener() { public void handleEvent(Event e) { getlookup(); } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twGetLU.addListener (SWT.Selection, lsGetLU );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twTable.addSelectionListener( lsDef );\n\t\twOrderBy.addSelectionListener( lsDef );\n\t\twCachesize.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\t\t\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\n\t\tsetComboValues();\n\t\tsetTableFieldCombo();\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"d190e2c32206da4d6825624ebc81ef2c3fa91847","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\t\n\t\tif (Const.isEmpty(wStepname.getText())) return;\n\n\t\tint nrkeys = wKey.nrNonEmpty();\n\t\tint nrfields = wReturn.nrNonEmpty();\n\t\t\n\t\tinput.allocate(nrkeys, nrfields);\n\t\t\n\t\tinput.setCached( wCache.getSelection() );\n\t\tinput.setCacheSize( Const.toInt(wCachesize.getText(), 0) );\n\t\t\n\t\tlog.logDebug(toString(), Messages.getString(\"DatabaseLookupDialog.Log.FoundKeys\",String.valueOf(nrkeys))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (int i=0;i<nrkeys;i++)\n\t\t{\n\t\t\tTableItem item = wKey.getNonEmpty(i);\n\t\t\tinput.getTableKeyField()[i]    = item.getText(1);\n\t\t\tinput.getKeyCondition()[i]     = item.getText(2);\n\t\t\tinput.getStreamKeyField1()[i]  = item.getText(3);\n\t\t\tinput.getStreamKeyField2()[i]  = item.getText(4);\n\t\t}\n\n\t\tlog.logDebug(toString(), Messages.getString(\"DatabaseLookupDialog.Log.FoundFields\",String.valueOf(nrfields))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tTableItem item        = wReturn.getNonEmpty(i);\n\t\t\tinput.getReturnValueField()[i]        = item.getText(1);\n\t\t\tinput.getReturnValueNewName()[i]    = item.getText(2);\n\t\t\tif (input.getReturnValueNewName()[i]==null || input.getReturnValueNewName()[i].length()==0)\n\t\t\t\tinput.getReturnValueNewName()[i] = input.getReturnValueField()[i];\n\t\t\t\n\t\t\tinput.getReturnValueDefault()[i]     = item.getText(3);\n\t\t\tinput.getReturnValueDefaultType()[i] = ValueMeta.getType(item.getText(4));\n\t\t\t\n\t\t\tif (input.getReturnValueDefaultType()[i]<0)\n\t\t\t{\n\t\t\t\tinput.getReturnValueDefaultType()[i]=ValueMetaInterface.TYPE_STRING;\n\t\t\t}\n\t\t}\n\t\t\n        input.setSchemaName( wSchema.getText() ); \n\t\tinput.setTablename( wTable.getText() ); \n\t\tinput.setDatabaseMeta( transMeta.findDatabase(wConnection.getText()) );\n\t\tinput.setOrderByClause( wOrderBy.getText() );\n\t\tinput.setFailingOnMultipleResults( wFailMultiple.getSelection() );\n\t\tinput.setEatingRowOnLookupFailure( wEatRows.getSelection() );\n        \n\t\tstepname = wStepname.getText(); // return value\n\n\t\tif (transMeta.findDatabase(wConnection.getText())==null)\n\t\t{\n\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\tmb.setMessage(Messages.getString(\"DatabaseLookupDialog.InvalidConnection.DialogMessage\")); //$NON-NLS-1$\n\t\t\tmb.setText(Messages.getString(\"DatabaseLookupDialog.InvalidConnection.DialogTitle\")); //$NON-NLS-1$\n\t\t\tmb.open();\n\t\t}\n\t\t\n\t\tdispose();\n\t}","id":104120,"modified_method":"private void ok()\n\t{\t\n\t\tif (Const.isEmpty(wStepname.getText())) return;\n\n\t\tint nrkeys = wKey.nrNonEmpty();\n\t\tint nrfields = wReturn.nrNonEmpty();\n\t\t\n\t\tinput.allocate(nrkeys, nrfields);\n\t\t\n\t\tinput.setCached( wCache.getSelection() );\n\t\tinput.setCacheSize( Const.toInt(wCachesize.getText(), 0) );\n\t\tinput.setLoadingAllDataInCache( wCacheLoadAll.getSelection() );\r\n\t\t\n\t\tlog.logDebug(toString(), Messages.getString(\"DatabaseLookupDialog.Log.FoundKeys\",String.valueOf(nrkeys))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (int i=0;i<nrkeys;i++)\n\t\t{\n\t\t\tTableItem item = wKey.getNonEmpty(i);\n\t\t\tinput.getTableKeyField()[i]    = item.getText(1);\n\t\t\tinput.getKeyCondition()[i]     = item.getText(2);\n\t\t\tinput.getStreamKeyField1()[i]  = item.getText(3);\n\t\t\tinput.getStreamKeyField2()[i]  = item.getText(4);\n\t\t}\n\n\t\tlog.logDebug(toString(), Messages.getString(\"DatabaseLookupDialog.Log.FoundFields\",String.valueOf(nrfields))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tTableItem item        = wReturn.getNonEmpty(i);\n\t\t\tinput.getReturnValueField()[i]        = item.getText(1);\n\t\t\tinput.getReturnValueNewName()[i]    = item.getText(2);\n\t\t\tif (input.getReturnValueNewName()[i]==null || input.getReturnValueNewName()[i].length()==0)\n\t\t\t\tinput.getReturnValueNewName()[i] = input.getReturnValueField()[i];\n\t\t\t\n\t\t\tinput.getReturnValueDefault()[i]     = item.getText(3);\n\t\t\tinput.getReturnValueDefaultType()[i] = ValueMeta.getType(item.getText(4));\n\t\t\t\n\t\t\tif (input.getReturnValueDefaultType()[i]<0)\n\t\t\t{\n\t\t\t\tinput.getReturnValueDefaultType()[i]=ValueMetaInterface.TYPE_STRING;\n\t\t\t}\n\t\t}\n\t\t\n        input.setSchemaName( wSchema.getText() ); \n\t\tinput.setTablename( wTable.getText() ); \n\t\tinput.setDatabaseMeta( transMeta.findDatabase(wConnection.getText()) );\n\t\tinput.setOrderByClause( wOrderBy.getText() );\n\t\tinput.setFailingOnMultipleResults( wFailMultiple.getSelection() );\n\t\tinput.setEatingRowOnLookupFailure( wEatRows.getSelection() );\n        \n\t\tstepname = wStepname.getText(); // return value\n\n\t\tif (transMeta.findDatabase(wConnection.getText())==null)\n\t\t{\n\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\tmb.setMessage(Messages.getString(\"DatabaseLookupDialog.InvalidConnection.DialogMessage\")); //$NON-NLS-1$\n\t\t\tmb.setText(Messages.getString(\"DatabaseLookupDialog.InvalidConnection.DialogTitle\")); //$NON-NLS-1$\n\t\t\tmb.open();\n\t\t}\n\t\t\n\t\tdispose();\n\t}","commit_id":"d190e2c32206da4d6825624ebc81ef2c3fa91847","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), Messages.getString(\"DatabaseLookupDialog.Log.GettingKeyInfo\")); //$NON-NLS-1$\n\t\t\n\t\twCache.setSelection(input.isCached());\n\t\twCachesize.setText(\"\"+input.getCacheSize()); //$NON-NLS-1$\n\t\t\n\t\tif (input.getStreamKeyField1()!=null)\n\t\tfor (i=0;i<input.getStreamKeyField1().length;i++)\n\t\t{\n\t\t\tTableItem item = wKey.table.getItem(i);\n\t\t\tif (input.getTableKeyField()[i]   !=null) item.setText(1, input.getTableKeyField()[i]);\n\t\t\tif (input.getKeyCondition()[i]!=null) item.setText(2, input.getKeyCondition()[i]);\n\t\t\tif (input.getStreamKeyField1()[i]         !=null) item.setText(3, input.getStreamKeyField1()[i]);\n\t\t\tif (input.getStreamKeyField2()[i]        !=null) item.setText(4, input.getStreamKeyField2()[i]);\n\t\t}\n\t\t\n\t\tif (input.getReturnValueField()!=null)\n\t\tfor (i=0;i<input.getReturnValueField().length;i++)\n\t\t{\n\t\t\tTableItem item = wReturn.table.getItem(i);\n\t\t\tif (input.getReturnValueField()[i]!=null     ) item.setText(1, input.getReturnValueField()[i]);\n\t\t\tif (input.getReturnValueNewName()[i]!=null && !input.getReturnValueNewName()[i].equals(input.getReturnValueField()[i]))\n\t\t\t\titem.setText(2, input.getReturnValueNewName()[i]);\n\t\t\t\n\t\t\tif (input.getReturnValueDefault()[i]!=null  ) item.setText(3, input.getReturnValueDefault()[i]);\n\t\t\titem.setText(4, ValueMeta.getTypeDesc(input.getReturnValueDefaultType()[i]));\n\t\t}\n\t\t\n        if (input.getSchemaName()!=null) wSchema.setText( input.getSchemaName() );\n\t\tif (input.getTablename()!=null) wTable.setText( input.getTablename() );\n\t\tif (input.getDatabaseMeta()!=null)   wConnection.setText(input.getDatabaseMeta().getName());\n\t\telse if (transMeta.nrDatabases()==1)\n\t\t{\n\t\t\twConnection.setText( transMeta.getDatabase(0).getName() );\n\t\t}\n\t\tif (input.getOrderByClause()!=null)      wOrderBy.setText(input.getOrderByClause());\n\t\twFailMultiple.setSelection(input.isFailingOnMultipleResults());\n\t\twEatRows.setSelection(input.isEatingRowOnLookupFailure());\n        \n\t\twStepname.selectAll();\n\t\twKey.setRowNums();\n\t\twKey.optWidth(true);\n\t\twReturn.setRowNums();\n\t\twReturn.optWidth(true);\n        \n        setFlags();\n\t}","id":104121,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), Messages.getString(\"DatabaseLookupDialog.Log.GettingKeyInfo\")); //$NON-NLS-1$\n\t\t\n\t\twCache.setSelection(input.isCached());\n\t\twCachesize.setText(\"\"+input.getCacheSize()); //$NON-NLS-1$\r\n\t\twCacheLoadAll.setSelection(input.isLoadingAllDataInCache());\n\t\t\n\t\tif (input.getStreamKeyField1()!=null)\n\t\tfor (i=0;i<input.getStreamKeyField1().length;i++)\n\t\t{\n\t\t\tTableItem item = wKey.table.getItem(i);\n\t\t\tif (input.getTableKeyField()[i]   !=null) item.setText(1, input.getTableKeyField()[i]);\n\t\t\tif (input.getKeyCondition()[i]!=null) item.setText(2, input.getKeyCondition()[i]);\n\t\t\tif (input.getStreamKeyField1()[i]         !=null) item.setText(3, input.getStreamKeyField1()[i]);\n\t\t\tif (input.getStreamKeyField2()[i]        !=null) item.setText(4, input.getStreamKeyField2()[i]);\n\t\t}\n\t\t\n\t\tif (input.getReturnValueField()!=null)\n\t\tfor (i=0;i<input.getReturnValueField().length;i++)\n\t\t{\n\t\t\tTableItem item = wReturn.table.getItem(i);\n\t\t\tif (input.getReturnValueField()[i]!=null     ) item.setText(1, input.getReturnValueField()[i]);\n\t\t\tif (input.getReturnValueNewName()[i]!=null && !input.getReturnValueNewName()[i].equals(input.getReturnValueField()[i]))\n\t\t\t\titem.setText(2, input.getReturnValueNewName()[i]);\n\t\t\t\n\t\t\tif (input.getReturnValueDefault()[i]!=null  ) item.setText(3, input.getReturnValueDefault()[i]);\n\t\t\titem.setText(4, ValueMeta.getTypeDesc(input.getReturnValueDefaultType()[i]));\n\t\t}\n\t\t\n        if (input.getSchemaName()!=null) wSchema.setText( input.getSchemaName() );\n\t\tif (input.getTablename()!=null) wTable.setText( input.getTablename() );\n\t\tif (input.getDatabaseMeta()!=null)   wConnection.setText(input.getDatabaseMeta().getName());\n\t\telse if (transMeta.nrDatabases()==1)\n\t\t{\n\t\t\twConnection.setText( transMeta.getDatabase(0).getName() );\n\t\t}\n\t\tif (input.getOrderByClause()!=null)      wOrderBy.setText(input.getOrderByClause());\n\t\twFailMultiple.setSelection(input.isFailingOnMultipleResults());\n\t\twEatRows.setSelection(input.isEatingRowOnLookupFailure());\n        \n\t\twStepname.selectAll();\n\t\twKey.setRowNums();\n\t\twKey.optWidth(true);\n\t\twReturn.setRowNums();\n\t\twReturn.optWidth(true);\n        \n        enableFields();\n\t}","commit_id":"d190e2c32206da4d6825624ebc81ef2c3fa91847","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected final void doInsert() {\n        if (this.rowData.size() == 0) {\n            this.logger.warn(\"Found a row with no data for table \" + this.currentTable + \", the row will be ignored\");\n            return;\n        }\n        \n        final StringBuilder columns = new StringBuilder();\n        final StringBuilder parameters = new StringBuilder();\n        final List<Object> values = new ArrayList<Object>(this.rowData.size());\n        \n        for (final Iterator<Entry<String, String>> rowIterator = this.rowData.entrySet().iterator(); rowIterator.hasNext(); ) {\n            final Entry<String, String> row = rowIterator.next();\n            columns.append(row.getKey());\n            parameters.append(\"?\");\n            values.add(row.getValue());\n            \n            if (rowIterator.hasNext()) {\n                columns.append(\", \");\n                parameters.append(\", \");\n            }\n        }\n        \n        final String sql = \"INSERT INTO \" + this.currentTable + \" (\" + columns + \") VALUES (\" + parameters + \")\";\n        this.logger.info(sql + \"\\t\" + values);\n\n        this.transactionTemplate.execute(new TransactionCallback() {\n\n            /* (non-Javadoc)\n             * @see org.springframework.transaction.support.TransactionCallback#doInTransaction(org.springframework.transaction.TransactionStatus)\n             */\n            public Object doInTransaction(TransactionStatus status) {\n                return jdbcTemplate.update(sql, values.toArray());\n            }\n        });\n    }","id":104122,"modified_method":"protected final void doInsert() {\n        if (this.rowData.size() == 0) {\n            this.logger.warn(\"Found a row with no data for table \" + this.currentTable + \", the row will be ignored\");\n            return;\n        }\n        \n        final Map<String, Integer> columnInfo = this.getTableColumnTypes(this.currentTable);\n        \n        final StringBuilder columns = new StringBuilder();\n        final StringBuilder parameters = new StringBuilder();\n        final Object[] values = new Object[this.rowData.size()];\n        final int[] types = new int[this.rowData.size()];\n        \n        int index = 0;\n        for (final Iterator<Entry<String, String>> rowIterator = this.rowData.entrySet().iterator(); rowIterator.hasNext(); ) {\n            final Entry<String, String> row = rowIterator.next();\n            final String columnName = row.getKey();\n            columns.append(columnName);\n            parameters.append(\"?\");\n            \n            values[index] = row.getValue();\n            types[index] = columnInfo.get(columnName);\n            \n            if (rowIterator.hasNext()) {\n                columns.append(\", \");\n                parameters.append(\", \");\n            }\n            \n            index++;\n        }\n        \n        final String sql = \"INSERT INTO \" + this.currentTable + \" (\" + columns + \") VALUES (\" + parameters + \")\";\n        if (this.logger.isInfoEnabled()) {\n            this.logger.info(sql + \"\\t\" + Arrays.asList(values) + \"\\t\" + Arrays.asList(ArrayUtils.toObject(types)));\n        }\n\n        this.transactionTemplate.execute(new TransactionCallback() {\n\n            /* (non-Javadoc)\n             * @see org.springframework.transaction.support.TransactionCallback#doInTransaction(org.springframework.transaction.TransactionStatus)\n             */\n            public Object doInTransaction(TransactionStatus status) {\n                return jdbcTemplate.update(sql, values, types);\n            }\n        });\n    }","commit_id":"32261089cdf0eb9440a9dd12af5a5f9ed823cf62","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Method for writing the output file of the active profiles information.\n     *\n     * @param message   the output to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeFile( StringBuffer message ) \n        throws MojoExecutionException\n    {\n        Writer writer = null;\n        try\n        {\n            File dir = output.getParentFile();\n            \n            if ( !dir.exists() )\n            {\n                dir.mkdirs();\n            }\n            \n            writer = new FileWriter( output );\n            \n            writer.write( \"Created by: \" + getClass().getName() + \"\\n\" );\n            writer.write( \"Created on: \" + new Date() + \"\\n\\n\" );\n            writer.write( message.toString() );\n            writer.flush();\n            \n            getLog().info( \"Active profile report written to: \" + output );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot write output to file: \" + output, e );\n        }\n        finally\n        {\n            if ( writer != null )\n            {\n                try\n                {\n                    writer.close();\n                }\n                catch ( IOException e )\n                {\n                    getLog().debug( \"Failed to close output file writer.\", e );\n                }\n            }\n        }\n    }","id":104123,"modified_method":"/**\n     * Method for writing the output file of the active profiles information.\n     *\n     * @param message   the output to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeFile( StringBuffer message )\n        throws MojoExecutionException\n    {\n        Writer writer = null;\n        try\n        {\n            File dir = output.getParentFile();\n\n            if ( !dir.exists() )\n            {\n                dir.mkdirs();\n            }\n\n            writer = WriterFactory.newPlatformWriter( output );\n\n            writer.write( \"Created by: \" + getClass().getName() + \"\\n\" );\n            writer.write( \"Created on: \" + new Date() + \"\\n\\n\" );\n            writer.write( message.toString() );\n            writer.flush();\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Active profile report written to: \" + output );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot write output to file: \" + output, e );\n        }\n        finally\n        {\n            if ( writer != null )\n            {\n                try\n                {\n                    writer.close();\n                }\n                catch ( IOException e )\n                {\n                    if ( getLog().isDebugEnabled() )\n                    {\n                        getLog().debug( \"Failed to close output file writer.\", e );\n                    }\n                }\n            }\n        }\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.AbstractMojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n        \n        for ( Iterator it = projects.iterator(); it.hasNext(); )\n        {\n            MavenProject project = (MavenProject) it.next();\n            \n            getActiveProfileStatement( project, message );\n            \n            message.append( \"\\n\\n\" );\n        }\n        \n        if ( output != null )\n        {\n            writeFile( message );\n        }\n        else\n        {\n            Log log = getLog();\n            log.info( message );\n        }\n    }","id":104124,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        for ( Iterator it = projects.iterator(); it.hasNext(); )\n        {\n            MavenProject project = (MavenProject) it.next();\n\n            getActiveProfileStatement( project, message );\n\n            message.append( \"\\n\\n\" );\n        }\n\n        if ( output != null )\n        {\n            writeFile( message );\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method to write the mojo description into the output file\n     *\n     * @param descriptionBuffer contains the description to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeDescription( StringBuffer descriptionBuffer )\n        throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n\n                out = new FileWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Error closing file output.\", e );\n                    }\n                }\n            }\n\n            getLog().info( \"Wrote descriptions to: \" + output );\n        }\n        else\n        {\n            getLog().info( descriptionBuffer.toString() );\n        }\n    }","id":104125,"modified_method":"/**\n     * Method to write the mojo description into the output file\n     *\n     * @param descriptionBuffer contains the description to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeDescription( StringBuffer descriptionBuffer )\n        throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n\n                out = WriterFactory.newPlatformWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n\n                out.flush();\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        if ( getLog().isDebugEnabled() )\n                        {\n                            getLog().debug( \"Error closing file output.\", e );\n                        }\n                    }\n                }\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Wrote descriptions to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( descriptionBuffer.toString() );\n            }\n        }\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.AbstractMojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( project == null )\n        {\n            try\n            {\n                project = projectBuilder.buildStandaloneSuperProject( localRepository );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new MojoExecutionException( \"Error while retrieving the super-project.\", e );\n            }\n        }\n\n        PluginInfo pi = new PluginInfo();\n\n        parsePluginLookupInfo( pi );\n\n        PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        if ( mojo != null && mojo.length() > 0 )\n        {\n            describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n        }\n        else\n        {\n            describePlugin( descriptor, descriptionBuffer );\n        }\n\n        writeDescription( descriptionBuffer );\n    }","id":104126,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( project == null )\n        {\n            try\n            {\n                project = projectBuilder.buildStandaloneSuperProject( localRepository );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new MojoExecutionException( \"Error while retrieving the super-project.\", e );\n            }\n        }\n\n        PluginInfo pi = new PluginInfo();\n\n        parsePluginLookupInfo( pi );\n\n        PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        if ( mojo != null && mojo.length() > 0 )\n        {\n            describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n        }\n        else\n        {\n            describePlugin( descriptor, descriptionBuffer );\n        }\n\n        writeDescription( descriptionBuffer );\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method for retrieving the description of the plugin\n     *\n     * @param pi    holds information of the plugin whose description is to be retrieved\n     * @return  a PluginDescriptor where the plugin description is to be retrieved\n     * @throws MojoExecutionException\n     * @throws MojoFailureException\n     */\n    private PluginDescriptor lookupPluginDescriptor( PluginInfo pi )\n        throws MojoExecutionException, MojoFailureException\n    {\n        PluginDescriptor descriptor = null;\n\n        Plugin forLookup = null;\n\n        if ( pi.prefix != null )\n        {\n            descriptor = pluginManager.getPluginDescriptorForPrefix( pi.prefix );\n\n            if ( descriptor == null )\n            {\n                forLookup = pluginManager.getPluginDefinitionForPrefix( pi.prefix, session, project );\n            }\n        }\n        else if ( pi.groupId != null && pi.artifactId != null )\n        {\n            forLookup = new Plugin();\n\n            forLookup.setGroupId( pi.groupId );\n            forLookup.setArtifactId( pi.artifactId );\n\n            if ( pi.version != null )\n            {\n                forLookup.setVersion( pi.version );\n            }\n        }\n        else\n        {\n            throw new MojoFailureException(\n                \"You must either specify \\'groupId\\' and \\'artifactId\\', or a valid \\'plugin\\' parameter.\" );\n        }\n\n        if ( descriptor == null && forLookup != null )\n        {\n            try\n            {\n                descriptor = pluginManager.verifyPlugin( forLookup, project, settings, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                throw new MojoExecutionException( \"Plugin dependency does not exist: \" + e.getMessage(), e );\n            }\n            catch ( InvalidVersionSpecificationException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( InvalidPluginException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginNotFoundException e )\n            {\n                getLog().debug( \"Unable to find plugin\", e );\n                throw new MojoFailureException( \"Plugin does not exist: \" + e.getMessage() );\n            }\n            catch ( PluginVersionNotFoundException e )\n            {\n                getLog().debug( \"Unable to find plugin version\", e );\n                throw new MojoFailureException( e.getMessage() );\n            }\n        }\n\n        if ( descriptor == null )\n        {\n            throw new MojoFailureException( \"Plugin could not be found. If you believe it is correct,\"\n                + \" check your pluginGroups setting, and run with -U to update the remote configuration\" );\n        }\n\n        return descriptor;\n    }","id":104127,"modified_method":"/**\n     * Method for retrieving the description of the plugin\n     *\n     * @param pi    holds information of the plugin whose description is to be retrieved\n     * @return  a PluginDescriptor where the plugin description is to be retrieved\n     * @throws MojoExecutionException\n     * @throws MojoFailureException\n     */\n    private PluginDescriptor lookupPluginDescriptor( PluginInfo pi )\n        throws MojoExecutionException, MojoFailureException\n    {\n        PluginDescriptor descriptor = null;\n\n        Plugin forLookup = null;\n\n        if ( pi.prefix != null )\n        {\n            descriptor = pluginManager.getPluginDescriptorForPrefix( pi.prefix );\n\n            if ( descriptor == null )\n            {\n                forLookup = pluginManager.getPluginDefinitionForPrefix( pi.prefix, session, project );\n            }\n        }\n        else if ( pi.groupId != null && pi.artifactId != null )\n        {\n            forLookup = new Plugin();\n\n            forLookup.setGroupId( pi.groupId );\n            forLookup.setArtifactId( pi.artifactId );\n\n            if ( pi.version != null )\n            {\n                forLookup.setVersion( pi.version );\n            }\n        }\n        else\n        {\n            throw new MojoFailureException(\n                \"You must either specify \\'groupId\\' and \\'artifactId\\', or a valid \\'plugin\\' parameter.\" );\n        }\n\n        if ( descriptor == null && forLookup != null )\n        {\n            try\n            {\n                descriptor = pluginManager.verifyPlugin( forLookup, project, settings, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                throw new MojoExecutionException( \"Plugin dependency does not exist: \" + e.getMessage(), e );\n            }\n            catch ( InvalidVersionSpecificationException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( InvalidPluginException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\" + groupId\n                    + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginNotFoundException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Unable to find plugin\", e );\n                }\n                throw new MojoFailureException( \"Plugin does not exist: \" + e.getMessage() );\n            }\n            catch ( PluginVersionNotFoundException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Unable to find plugin version\", e );\n                }\n                throw new MojoFailureException( e.getMessage() );\n            }\n        }\n\n        if ( descriptor == null )\n        {\n            throw new MojoFailureException( \"Plugin could not be found. If you believe it is correct,\"\n                + \" check your pluginGroups setting, and run with -U to update the remote configuration\" );\n        }\n\n        return descriptor;\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.AbstractMojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        if ( projects.get( 0 ).equals( project ) )\n        {\n            // this is normal in aggregation mode.\n\n            for ( Iterator it = projects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n                \n                getEffectivePom( project, message );\n                \n                message.append( \"\\n\\n\" );\n            }\n        }\n        else\n        {\n            getEffectivePom( project, message );\n            message.append( \"\\n\\n\" );\n        }\n        \n        if ( output != null )\n        {\n            FileWriter fWriter = null;\n            try\n            {\n                File dir = output.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n\n                getLog().info( \"Writing effective-POM to: \" + output );\n\n                fWriter = new FileWriter( output );\n\n                fWriter.write( \"Created by: \" + getClass().getName() + \"\\n\" );\n                fWriter.write( \"Created on: \" + new Date() + \"\\n\\n\" );\n                \n                fWriter.write( message.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-POM to output: \" + output, e );\n            }\n            finally\n            {\n                if ( fWriter != null )\n                {\n                    try\n                    {\n                        fWriter.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Cannot close FileWriter to output location: \" + output, e );\n                    }\n                }\n            }\n        }\n        else\n        {\n            StringBuffer formatted = new StringBuffer();\n\n            formatted.append( \"\\nEffective POMs, after inheritance, interpolation, and profiles are applied:\\n\\n\" );\n            formatted.append( message.toString() );\n            formatted.append( \"\\n\" );\n\n            getLog().info( message );\n        }\n    }","id":104128,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        if ( projects.get( 0 ).equals( project ) )\n        {\n            // this is normal in aggregation mode.\n\n            for ( Iterator it = projects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                getEffectivePom( project, message );\n\n                message.append( \"\\n\\n\" );\n            }\n        }\n        else\n        {\n            getEffectivePom( project, message );\n            message.append( \"\\n\\n\" );\n        }\n\n        if ( output != null )\n        {\n            Writer fWriter = null;\n            try\n            {\n                File dir = output.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n\n                fWriter = WriterFactory.newPlatformWriter( output );\n\n                fWriter.write( \"Created by: \" + getClass().getName() + \"\\n\" );\n                fWriter.write( \"Created on: \" + new Date() + \"\\n\\n\" );\n                fWriter.write( message.toString() );\n\n                fWriter.flush();\n\n                if ( getLog().isInfoEnabled() )\n                {\n                    getLog().info( \"Effective-POM written to: \" + output );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-POM to output: \" + output, e );\n            }\n            finally\n            {\n                if ( fWriter != null )\n                {\n                    try\n                    {\n                        fWriter.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        if ( getLog().isDebugEnabled() )\n                        {\n                            getLog().debug( \"Cannot close FileWriter to output location: \" + output, e );\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            StringBuffer formatted = new StringBuffer();\n\n            formatted.append( \"\\nEffective POMs, after inheritance, interpolation, and profiles are applied:\\n\\n\" );\n            formatted.append( message.toString() );\n            formatted.append( \"\\n\" );\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.AbstractMojo#execute() \n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringWriter sWriter = new StringWriter();\n\n        SettingsXpp3Writer settingsWriter = new SettingsXpp3Writer();\n\n        try\n        {\n            settingsWriter.write( sWriter, settings );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot serialize Settings to XML.\", e );\n        }\n\n        if ( output != null && output.trim().length() > 0 )\n        {\n            FileWriter fWriter = null;\n            try\n            {\n                File outFile = new File( output ).getAbsoluteFile();\n\n                File dir = outFile.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n\n                getLog().info( \"Writing effective-settings to: \" + outFile );\n\n                fWriter = new FileWriter( outFile );\n\n                fWriter.write( sWriter.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-settings to output: \" + output, e );\n            }\n            finally\n            {\n                if ( fWriter != null )\n                {\n                    try\n                    {\n                        fWriter.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Cannot close FileWriter to output location: \" + output, e );\n                    }\n                }\n            }\n        }\n        else\n        {\n            StringBuffer message = new StringBuffer();\n\n            message.append( \"\\nEffective settings:\\n\\n\" );\n            message.append( sWriter.toString() );\n            message.append( \"\\n\\n\" );\n\n            getLog().info( message );\n        }\n    }","id":104129,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringWriter sWriter = new StringWriter();\n\n        SettingsXpp3Writer settingsWriter = new SettingsXpp3Writer();\n\n        try\n        {\n            settingsWriter.write( sWriter, settings );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot serialize Settings to XML.\", e );\n        }\n\n        if ( output != null && output.trim().length() > 0 )\n        {\n            Writer fWriter = null;\n            try\n            {\n                File outFile = new File( output ).getAbsoluteFile();\n\n                File dir = outFile.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n\n                fWriter = WriterFactory.newPlatformWriter( outFile );\n                fWriter.write( sWriter.toString() );\n\n                fWriter.flush();\n\n                if ( getLog().isInfoEnabled() )\n                {\n                    getLog().info( \"Effective-settings written to: \" + output );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-settings to output: \" + output, e );\n            }\n            finally\n            {\n                if ( fWriter != null )\n                {\n                    try\n                    {\n                        fWriter.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        if ( getLog().isDebugEnabled() )\n                        {\n                            getLog().debug( \"Cannot close FileWriter to output location: \" + output, e );\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            StringBuffer message = new StringBuffer();\n\n            message.append( \"\\nEffective settings:\\n\\n\" );\n            message.append( sWriter.toString() );\n            message.append( \"\\n\\n\" );\n\n            getLog().info( message );\n        }\n    }","commit_id":"094acbcce36a9850fb2ce3b9f3f2789c1a6a50e9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( \"fo\".equalsIgnoreCase( implementation ) )\n        {\n            this.docRenderer = foRenderer;\n        }\n        else if ( \"itext\".equalsIgnoreCase( implementation ) )\n        {\n            this.docRenderer = itextRenderer;\n        }\n        else\n        {\n            throw new MojoFailureException( \"Not a valid implementation: '\" + implementation\n                + \"'. Should be 'fo' or 'itext'.\" );\n        }\n\n        try\n        {\n            generatedPdf();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage(), e );\n        }\n\n        try\n        {\n            if ( !outputDirectory.getCanonicalPath().equals( workingDirectory.getCanonicalPath() ) )\n            {\n                String outputName = getDocumentModel( getDefaultLocale() ).getOutputName();\n                final String extension = FileUtils.getExtension( outputName );\n                if ( StringUtils.isNotEmpty( extension ) )\n                {\n                    outputName = outputName.substring( 0, outputName.indexOf( extension ) - 1 );\n                }\n                final List pdfs = FileUtils.getFiles( workingDirectory, \"**/\" + outputName + \".pdf\", null );\n\n                for ( final Iterator it = pdfs.iterator(); it.hasNext(); )\n                {\n                    final File pdf = (File) it.next();\n\n                    FileUtils.copyFile( pdf, new File( outputDirectory, pdf.getName() ) );\n                    pdf.delete();\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error copying generated PDF: \" + e.getMessage(), e );\n        }\n    }","id":104130,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( \"fo\".equalsIgnoreCase( implementation ) )\n        {\n            this.docRenderer = foRenderer;\n        }\n        else if ( \"itext\".equalsIgnoreCase( implementation ) )\n        {\n            this.docRenderer = itextRenderer;\n        }\n        else\n        {\n            throw new MojoFailureException( \"Not a valid implementation: '\" + implementation\n                + \"'. Should be 'fo' or 'itext'.\" );\n        }\n\n        try\n        {\n            generatedPdf();\n        }\n        catch ( IOException e )\n        {\n            debugLogGeneratedModel( getDocumentModel( Locale.ENGLISH ) );\n\n            throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage(), e );\n        }\n\n        try\n        {\n            if ( !outputDirectory.getCanonicalPath().equals( workingDirectory.getCanonicalPath() ) )\n            {\n                String outputName = getDocumentModel( getDefaultLocale() ).getOutputName();\n                final String extension = FileUtils.getExtension( outputName );\n                if ( StringUtils.isNotEmpty( extension ) )\n                {\n                    outputName = outputName.substring( 0, outputName.indexOf( extension ) - 1 );\n                }\n                final List pdfs = FileUtils.getFiles( workingDirectory, \"**/\" + outputName + \".pdf\", null );\n\n                for ( final Iterator it = pdfs.iterator(); it.hasNext(); )\n                {\n                    final File pdf = (File) it.next();\n\n                    FileUtils.copyFile( pdf, new File( outputDirectory, pdf.getName() ) );\n                    pdf.delete();\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error copying generated PDF: \" + e.getMessage(), e );\n        }\n    }","commit_id":"e12994008f0ee0003c2f2d695a2b5dfba2d79a0c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate the given Maven report only if it is not an external report and the report could be generated.\n     *\n     * @param mojoDescriptor not null, to catch linkage error\n     * @param report could be null\n     * @param locale not null\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     * @see #isValidGeneratedReport(MojoDescriptor, File, String)\n     * @since 1.1\n     */\n    private void generateMavenReport( MojoDescriptor mojoDescriptor, MavenReport report, Locale locale )\n        throws IOException, MojoExecutionException\n    {\n        if ( report == null )\n        {\n            return;\n        }\n\n        String localReportName = report.getName( locale );\n        if ( !report.canGenerateReport() )\n        {\n            getLog().info(\n                          \"Skipped \\\"\" + localReportName + \"\\\" report, canGenerateReport() was false.\" );\n            return;\n        }\n        if ( report.isExternalReport() )\n        {\n            getLog().info(\n                          \"Skipped external report, \\\"\" + localReportName + \"\\\" report.\" );\n            return;\n        }\n\n        for ( final Iterator it = getGeneratedMavenReports().iterator(); it.hasNext(); )\n        {\n            MavenReport generatedReport = (MavenReport) it.next();\n            if ( report.getName( locale ).equals( generatedReport.getName( locale ) ) )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( report.getName( locale ) + \" was already generated.\" );\n                }\n                return;\n            }\n        }\n\n        File outDir = new File( getGeneratedSiteDirectoryTmp(), \"xdoc\" );\n        if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n        {\n            outDir = new File( new File( getGeneratedSiteDirectoryTmp(), locale.getLanguage() ), \"xdoc\" );\n        }\n        outDir.mkdirs();\n\n        File generatedReport = new File( outDir, report.getOutputName() + \".xml\" );\n\n        String excludes = getDefaultExcludesWithLocales( getAvailableLocales(), getDefaultLocale() );\n        List files = FileUtils.getFileNames( siteDirectory, \"*/\" + report.getOutputName() + \".*\", excludes, false );\n        if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n        {\n            files =\n                FileUtils.getFileNames( new File( siteDirectory, locale.getLanguage() ), \"*/\"\n                    + report.getOutputName() + \".*\", excludes, false );\n        }\n\n        if ( files.size() != 0 )\n        {\n            String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n\n            getLog().info(\n                           \"Skipped \\\"\" + report.getName( locale ) + \"\\\" report, file \\\"\" + report.getOutputName()\n                               + \"\\\" already exists for the \" + displayLanguage + \" version.\" );\n            return;\n        }\n\n        getLog().info( \"Generating \\\"\" + localReportName + \"\\\" report.\" );\n\n        StringWriter sw = new StringWriter();\n\n        PdfSink sink = new PdfSink( sw );\n        try\n        {\n            report.generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"MavenReportException: \" + e.getMessage(), e );\n        }\n        catch ( LinkageError e )\n        {\n            if ( getLog().isErrorEnabled() )\n            {\n                getLog().error(\n                                report.getClass().getName() + \"#generate(...) caused a linkage error (\"\n                                    + e.getClass().getName() + \") and may be out-of-date. Check the realms:\" );\n\n                ClassRealm reportPluginRealm = mojoDescriptor.getPluginDescriptor().getClassRealm();\n                StringBuilder sb = new StringBuilder();\n                sb.append( \"Maven Report Plugin realm = \" + reportPluginRealm.getId() ).append( '\\n' );\n                for ( int i = 0; i < reportPluginRealm.getConstituents().length; i++ )\n                {\n                    sb.append( \"urls[\" + i + \"] = \" + reportPluginRealm.getConstituents()[i] );\n                    if ( i != ( reportPluginRealm.getConstituents().length - 1 ) )\n                    {\n                        sb.append( '\\n' );\n                    }\n                }\n                getLog().error( sb.toString() );\n            }\n\n            throw e;\n        }\n        finally\n        {\n            sink.close();\n        }\n\n        writeGeneratedReport( sw.toString(), generatedReport );\n\n        if ( isValidGeneratedReport( mojoDescriptor, generatedReport, localReportName ) )\n        {\n            getGeneratedMavenReports().add( report );\n        }\n    }","id":104131,"modified_method":"/**\n     * Generate the given Maven report only if it is not an external report and the report could be generated.\n     *\n     * @param mojoDescriptor not null, to catch linkage error\n     * @param report could be null\n     * @param locale not null\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     * @see #isValidGeneratedReport(MojoDescriptor, File, String)\n     * @since 1.1\n     */\n    private void generateMavenReport( MojoDescriptor mojoDescriptor, MavenReport report, Locale locale )\n        throws IOException, MojoExecutionException\n    {\n        if ( report == null )\n        {\n            return;\n        }\n\n        String localReportName = report.getName( locale );\n        if ( !report.canGenerateReport() )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Skipped \\\"\" + localReportName + \"\\\" report.\" );\n            }\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().debug( \"canGenerateReport() was false.\" );\n            }\n\n            return;\n        }\n\n        if ( report.isExternalReport() )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Skipped external report, \\\"\" + localReportName + \"\\\" report.\" );\n            }\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().debug( \"isExternalReport() was false.\" );\n            }\n\n            return;\n        }\n\n        for ( final Iterator it = getGeneratedMavenReports().iterator(); it.hasNext(); )\n        {\n            MavenReport generatedReport = (MavenReport) it.next();\n            if ( report.getName( locale ).equals( generatedReport.getName( locale ) ) )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( report.getName( locale ) + \" was already generated.\" );\n                }\n                return;\n            }\n        }\n\n        File outDir = new File( getGeneratedSiteDirectoryTmp(), \"xdoc\" );\n        if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n        {\n            outDir = new File( new File( getGeneratedSiteDirectoryTmp(), locale.getLanguage() ), \"xdoc\" );\n        }\n        outDir.mkdirs();\n\n        File generatedReport = new File( outDir, report.getOutputName() + \".xml\" );\n\n        String excludes = getDefaultExcludesWithLocales( getAvailableLocales(), getDefaultLocale() );\n        List files = FileUtils.getFileNames( siteDirectory, \"*/\" + report.getOutputName() + \".*\", excludes, false );\n        if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n        {\n            files =\n                FileUtils.getFileNames( new File( siteDirectory, locale.getLanguage() ), \"*/\"\n                    + report.getOutputName() + \".*\", excludes, false );\n        }\n\n        if ( files.size() != 0 )\n        {\n            String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info(\n                               \"Skipped \\\"\" + report.getName( locale ) + \"\\\" report, file \\\"\"\n                                   + report.getOutputName() + \"\\\" already exists for the \" + displayLanguage\n                                   + \" version.\" );\n            }\n\n            return;\n        }\n\n        if ( getLog().isInfoEnabled() )\n        {\n            getLog().info( \"Generating \\\"\" + localReportName + \"\\\" report.\" );\n        }\n\n        StringWriter sw = new StringWriter();\n\n        PdfSink sink = new PdfSink( sw );\n        try\n        {\n            report.generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"MavenReportException: \" + e.getMessage(), e );\n        }\n        catch ( LinkageError e )\n        {\n            if ( getLog().isErrorEnabled() )\n            {\n                ClassRealm reportPluginRealm = mojoDescriptor.getPluginDescriptor().getClassRealm();\n                StringBuilder sb = new StringBuilder();\n                sb.append( report.getClass().getName() ).append( \"#generate(...) caused a linkage error (\" );\n                sb.append( e.getClass().getName() ).append( \") and may be out-of-date. Check the realms:\\n\" );\n                sb.append( \"Maven Report Plugin realm = \" + reportPluginRealm.getId() ).append( '\\n' );\n                for ( int i = 0; i < reportPluginRealm.getConstituents().length; i++ )\n                {\n                    sb.append( \"urls[\" + i + \"] = \" + reportPluginRealm.getConstituents()[i] );\n                    if ( i != ( reportPluginRealm.getConstituents().length - 1 ) )\n                    {\n                        sb.append( '\\n' );\n                    }\n                }\n\n                getLog().error( sb.toString() );\n            }\n\n            throw e;\n        }\n        finally\n        {\n            sink.close();\n        }\n\n        writeGeneratedReport( sw.toString(), generatedReport );\n\n        if ( isValidGeneratedReport( mojoDescriptor, generatedReport, localReportName ) )\n        {\n            getGeneratedMavenReports().add( report );\n        }\n    }","commit_id":"e12994008f0ee0003c2f2d695a2b5dfba2d79a0c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate all Maven reports defined in <code>${project.reporting}<\/code> part only if <code>generateReports<\/code> is\n     * enabled.\n     *\n     * @param locale not null\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void generateMavenReports( Locale locale )\n        throws MojoExecutionException, IOException\n    {\n        if ( !includeReports )\n        {\n            getLog().info( \"Skipped report generation.\" );\n            return;\n        }\n\n        if ( project.getReporting() == null )\n        {\n            getLog().info( \"No report was specified.\" );\n            return;\n        }\n\n        for ( final Iterator it = project.getReporting().getPlugins().iterator(); it.hasNext(); )\n        {\n            final ReportPlugin reportPlugin = (ReportPlugin) it.next();\n\n            final PluginDescriptor pluginDescriptor = getPluginDescriptor( reportPlugin );\n\n            List goals = new ArrayList();\n            for ( final Iterator it2 = reportPlugin.getReportSets().iterator(); it2.hasNext(); )\n            {\n                final ReportSet reportSet = (ReportSet) it2.next();\n\n                for ( final Iterator it3 = reportSet.getReports().iterator(); it3.hasNext(); )\n                {\n                    goals.add( it3.next().toString() );\n                }\n            }\n\n            List mojoDescriptors = pluginDescriptor.getMojos();\n            for ( final Iterator it2 = mojoDescriptors.iterator(); it2.hasNext(); )\n            {\n                final MojoDescriptor mojoDescriptor = (MojoDescriptor) it2.next();\n\n                if ( goals.isEmpty() || ( !goals.isEmpty() && goals.contains( mojoDescriptor.getGoal() ) ) )\n                {\n                    MavenReport report = getMavenReport( mojoDescriptor );\n\n                    generateMavenReport( mojoDescriptor, report, locale );\n                }\n            }\n        }\n\n        // generate project-info report\n        if ( !getGeneratedMavenReports().isEmpty() )\n        {\n            File outDir = new File( getGeneratedSiteDirectoryTmp(), \"xdoc\" );\n            if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n            {\n                outDir = new File( new File( getGeneratedSiteDirectoryTmp(), locale.getLanguage() ), \"xdoc\" );\n            }\n            outDir.mkdirs();\n\n            File piReport = new File( outDir, \"project-info.xml\" );\n\n            StringWriter sw = new StringWriter();\n\n            PdfSink sink = new PdfSink( sw );\n            ProjectInfoRenderer r = new ProjectInfoRenderer( sink, getGeneratedMavenReports(), i18n, locale );\n            r.render();\n\n            writeGeneratedReport( sw.toString(), piReport );\n        }\n\n        // copy generated site\n        copySiteDir( getGeneratedSiteDirectoryTmp(), getSiteDirectoryTmp() );\n        copySiteDir( generatedSiteDirectory, getSiteDirectoryTmp() );\n    }","id":104132,"modified_method":"/**\n     * Generate all Maven reports defined in <code>${project.reporting}<\/code> part only if <code>generateReports<\/code> is\n     * enabled.\n     *\n     * @param locale not null\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void generateMavenReports( Locale locale )\n        throws MojoExecutionException, IOException\n    {\n        if ( !includeReports )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Skipped report generation.\" );\n            }\n\n            return;\n        }\n\n        if ( project.getReporting() == null )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"No report was specified.\" );\n            }\n            return;\n        }\n\n        for ( final Iterator it = project.getReporting().getPlugins().iterator(); it.hasNext(); )\n        {\n            final ReportPlugin reportPlugin = (ReportPlugin) it.next();\n\n            final PluginDescriptor pluginDescriptor = getPluginDescriptor( reportPlugin );\n\n            List goals = new ArrayList();\n            for ( final Iterator it2 = reportPlugin.getReportSets().iterator(); it2.hasNext(); )\n            {\n                final ReportSet reportSet = (ReportSet) it2.next();\n\n                for ( final Iterator it3 = reportSet.getReports().iterator(); it3.hasNext(); )\n                {\n                    goals.add( it3.next().toString() );\n                }\n            }\n\n            List mojoDescriptors = pluginDescriptor.getMojos();\n            for ( final Iterator it2 = mojoDescriptors.iterator(); it2.hasNext(); )\n            {\n                final MojoDescriptor mojoDescriptor = (MojoDescriptor) it2.next();\n\n                if ( goals.isEmpty() || ( !goals.isEmpty() && goals.contains( mojoDescriptor.getGoal() ) ) )\n                {\n                    MavenReport report = getMavenReport( mojoDescriptor );\n\n                    generateMavenReport( mojoDescriptor, report, locale );\n                }\n            }\n        }\n\n        // generate project-info report\n        if ( !getGeneratedMavenReports().isEmpty() )\n        {\n            File outDir = new File( getGeneratedSiteDirectoryTmp(), \"xdoc\" );\n            if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n            {\n                outDir = new File( new File( getGeneratedSiteDirectoryTmp(), locale.getLanguage() ), \"xdoc\" );\n            }\n            outDir.mkdirs();\n\n            File piReport = new File( outDir, \"project-info.xml\" );\n\n            StringWriter sw = new StringWriter();\n\n            PdfSink sink = new PdfSink( sw );\n            ProjectInfoRenderer r = new ProjectInfoRenderer( sink, getGeneratedMavenReports(), i18n, locale );\n            r.render();\n\n            writeGeneratedReport( sw.toString(), piReport );\n        }\n\n        // copy generated site\n        copySiteDir( getGeneratedSiteDirectoryTmp(), getSiteDirectoryTmp() );\n        copySiteDir( generatedSiteDirectory, getSiteDirectoryTmp() );\n    }","commit_id":"e12994008f0ee0003c2f2d695a2b5dfba2d79a0c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write the auto-generated model to disc.\n     *\n     * @param docModel the model to write.\n     */\n    private void debugLogGeneratedModel( final DocumentModel docModel )\n    {\n        if ( getLog().isDebugEnabled() && project != null )\n        {\n            final File outputDir = new File( project.getBuild().getDirectory(), \"pdf\" );\n\n            if ( !outputDir.exists() )\n            {\n                outputDir.mkdirs();\n            }\n\n            final File doc = FileUtils.createTempFile( \"pdf\", \".xml\", outputDir );\n            final DocumentXpp3Writer xpp3 = new DocumentXpp3Writer();\n\n            Writer w = null;\n            try\n            {\n                w = WriterFactory.newXmlWriter( doc );\n                xpp3.write( w, docModel );\n                getLog().debug( \"Generated a default document model: \" + doc.getAbsolutePath() );\n            }\n            catch ( IOException io )\n            {\n                getLog().debug( \"Failed to write document model: \" + doc.getAbsolutePath(), io );\n            }\n            finally\n            {\n                IOUtil.close( w );\n            }\n        }\n    }","id":104133,"modified_method":"/**\n     * Write the auto-generated model to disc.\n     *\n     * @param docModel the model to write.\n     */\n    private void debugLogGeneratedModel( final DocumentModel docModel )\n    {\n        if ( getLog().isDebugEnabled() && project != null )\n        {\n            final File outputDir = new File( project.getBuild().getDirectory(), \"pdf\" );\n\n            if ( !outputDir.exists() )\n            {\n                outputDir.mkdirs();\n            }\n\n            final File doc = FileUtils.createTempFile( \"pdf\", \".xml\", outputDir );\n            final DocumentXpp3Writer xpp3 = new DocumentXpp3Writer();\n\n            Writer w = null;\n            try\n            {\n                w = WriterFactory.newXmlWriter( doc );\n                xpp3.write( w, docModel );\n\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Generated a default document model: \" + doc.getAbsolutePath() );\n                }\n            }\n            catch ( IOException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().error( \"Failed to write document model: \" + e.getMessage(), e );\n                }\n                else\n                {\n                    getLog().error( \"Failed to write document model: \" + e.getMessage() );\n                }\n            }\n            finally\n            {\n                IOUtil.close( w );\n            }\n        }\n    }","commit_id":"e12994008f0ee0003c2f2d695a2b5dfba2d79a0c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate the PDF.\n     *\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void generatedPdf()\n        throws MojoExecutionException, IOException\n    {\n        Locale.setDefault( getDefaultLocale() );\n\n        for ( final Iterator iterator = getAvailableLocales().iterator(); iterator.hasNext(); )\n        {\n            final Locale locale = (Locale) iterator.next();\n\n            final File workingDir = getWorkingDirectory( locale );\n\n            File siteDirectoryFile = getSiteDirectoryTmp();\n            if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) )\n            {\n                siteDirectoryFile = new File( getSiteDirectoryTmp(), locale.getLanguage() );\n            }\n\n            // Copy extra-resources\n            copyResources( locale );\n\n            // generate reports\n            generateMavenReports( locale );\n\n            DocumentRendererContext context = new DocumentRendererContext();\n            context.put( \"project\", project );\n            context.put( \"settings\", settings );\n            context.put( \"PathTool\", new PathTool() );\n            context.put( \"FileUtils\", new FileUtils() );\n            context.put( \"StringUtils\", new StringUtils() );\n            context.put( \"i18n\", i18n );\n\n            try\n            {\n                // TODO use interface see DOXIASITETOOLS-30\n                if ( aggregate )\n                {\n                    ( (AbstractDocumentRenderer) docRenderer ).render( siteDirectoryFile, workingDir,\n                                                                       getDocumentModel( locale ), context );\n                }\n                else\n                {\n                    ( (AbstractDocumentRenderer) docRenderer ).render( siteDirectoryFile, workingDir, null,\n                                                                       context );\n                }\n            }\n            catch ( DocumentRendererException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage(), e );\n                }\n\n                throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage() );\n            }\n        }\n    }","id":104134,"modified_method":"/**\n     * Generate the PDF.\n     *\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void generatedPdf()\n        throws MojoExecutionException, IOException\n    {\n        try\n        {\n            FileUtils.deleteDirectory( workingDirectory );\n        }\n        catch ( IOException e )\n        {\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().error( \"IOException: \" + e.getMessage(), e );\n            }\n            else\n            {\n                getLog().error( \"IOException: \" + e.getMessage() );\n            }\n        }\n\n        Locale.setDefault( getDefaultLocale() );\n\n        for ( final Iterator iterator = getAvailableLocales().iterator(); iterator.hasNext(); )\n        {\n            final Locale locale = (Locale) iterator.next();\n\n            final File workingDir = getWorkingDirectory( locale );\n\n            File siteDirectoryFile = getSiteDirectoryTmp();\n            if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) )\n            {\n                siteDirectoryFile = new File( getSiteDirectoryTmp(), locale.getLanguage() );\n            }\n\n            // Copy extra-resources\n            copyResources( locale );\n\n            // generate reports\n            generateMavenReports( locale );\n\n            DocumentRendererContext context = new DocumentRendererContext();\n            context.put( \"project\", project );\n            context.put( \"settings\", settings );\n            context.put( \"PathTool\", new PathTool() );\n            context.put( \"FileUtils\", new FileUtils() );\n            context.put( \"StringUtils\", new StringUtils() );\n            context.put( \"i18n\", i18n );\n\n            try\n            {\n                // TODO use interface see DOXIASITETOOLS-30\n                if ( aggregate )\n                {\n                    ( (AbstractDocumentRenderer) docRenderer ).render( siteDirectoryFile, workingDir,\n                                                                       getDocumentModel( locale ), context );\n                }\n                else\n                {\n                    ( (AbstractDocumentRenderer) docRenderer ).render( siteDirectoryFile, workingDir, null,\n                                                                       context );\n                }\n            }\n            catch ( DocumentRendererException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage(), e );\n                }\n\n                throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage() );\n            }\n        }\n    }","commit_id":"e12994008f0ee0003c2f2d695a2b5dfba2d79a0c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param pluginDescriptor not null\n     * @return the MavenProject for the current plugin descriptor or null if an error occurred.\n     * @since 1.1\n     */\n    private MavenProject getReportPluginProject( PluginDescriptor pluginDescriptor )\n    {\n        Artifact artifact =\n            artifactFactory.createProjectArtifact( pluginDescriptor.getGroupId(),\n                                                   pluginDescriptor.getArtifactId(),\n                                                   pluginDescriptor.getVersion(), Artifact.SCOPE_COMPILE );\n        try\n        {\n            return mavenProjectBuilder.buildFromRepository( artifact, remoteRepositories, localRepository );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            getLog().debug( e.getMessage(), e );\n        }\n\n        return null;\n    }","id":104135,"modified_method":"/**\n     * @param pluginDescriptor not null\n     * @return the MavenProject for the current plugin descriptor or null if an error occurred.\n     * @since 1.1\n     */\n    private MavenProject getReportPluginProject( PluginDescriptor pluginDescriptor )\n    {\n        Artifact artifact =\n            artifactFactory.createProjectArtifact( pluginDescriptor.getGroupId(),\n                                                   pluginDescriptor.getArtifactId(),\n                                                   pluginDescriptor.getVersion(), Artifact.SCOPE_COMPILE );\n        try\n        {\n            return mavenProjectBuilder.buildFromRepository( artifact, remoteRepositories, localRepository );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().error( \"ProjectBuildingException: \" + e.getMessage(), e );\n            }\n            else\n            {\n                getLog().error( \"ProjectBuildingException: \" + e.getMessage() );\n            }\n        }\n\n        return null;\n    }","commit_id":"e12994008f0ee0003c2f2d695a2b5dfba2d79a0c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n   * Returns a list of all attributes of the specified element in a map.\n   * @param ctx database context\n   * @param env root element\n   * @param elem element to be parsed\n   * @return map list\n   */\n  static ArrayList<HashMap<String, String>> list(final Context ctx, final XdmValue env,\n      final String elem) {\n\n    final ArrayList<HashMap<String, String>> list =\n        new ArrayList<HashMap<String, String>>();\n    final XQuery query = new XQuery(\"*:\" + elem, ctx).context(env);\n    for(final XdmItem it : query) list.add(map(ctx, it));\n    query.close();\n    return list;\n  }","id":104136,"modified_method":"/**\n   * Returns a list of all attributes of the specified element in a map.\n   * @param ctx database context\n   * @param env root element\n   * @param elem element to be parsed\n   * @return map list\n   */\n  static ArrayList<HashMap<String, String>> list(final Context ctx, final XdmValue env,\n      final String elem) {\n\n    final ArrayList<HashMap<String, String>> list =\n        new ArrayList<HashMap<String, String>>();\n    for(final XdmItem it : new XQuery(\"*:\" + elem, ctx).context(env)) {\n      list.add(map(ctx, it));\n    }\n    return list;\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns all attributes of the specified element in a map.\n   * @param ctx database context\n   * @param env root element\n   * @return map\n   */\n  static HashMap<String, String> map(final Context ctx, final XdmValue env) {\n    final HashMap<String, String> map = new HashMap<String, String>();\n    final XQuery query = new XQuery(\"@*\", ctx).context(env);\n    for(final XdmItem it : query) map.put(it.getName().getLocalPart(), it.getString());\n    query.close();\n    return map;\n  }","id":104137,"modified_method":"/**\n   * Returns all attributes of the specified element in a map.\n   * @param ctx database context\n   * @param env root element\n   * @return map\n   */\n  static HashMap<String, String> map(final Context ctx, final XdmValue env) {\n    final HashMap<String, String> map = new HashMap<String, String>();\n    for(final XdmItem it : new XQuery(\"@*\", ctx).context(env))\n      map.put(it.getName().getLocalPart(), it.getString());\n    return map;\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a single attribute string.\n   * @param elm name of element\n   * @param ctx database context\n   * @param env root element\n   * @return map\n   */\n  static String string(final String elm, final Context ctx, final XdmValue env) {\n    String value = null;\n    final XQuery query = new XQuery(\"*:\" + elm, ctx).context(env);\n    final XdmItem it = query.next();\n    if(it != null) {\n      final XQuery qattr = new XQuery(\"string(@*)\", ctx).context(it);\n      value = qattr.next().getString();\n      qattr.close();\n    }\n    query.close();\n    return value;\n  }","id":104138,"modified_method":"/**\n   * Returns a single attribute string.\n   * @param elm name of element\n   * @param ctx database context\n   * @param env root element\n   * @return map\n   */\n  static String string(final String elm, final Context ctx, final XdmValue env) {\n    final XdmItem it = new XQuery(\"*:\" + elm, ctx).context(env).next();\n    return it == null ? null :\n      new XQuery(\"string(@*)\", ctx).context(it).next().getString();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param ctx database context\n   * @param env environment item\n   */\n  QT3Env(final Context ctx, final XdmValue env) {\n    name = XQuery.string('@' + NNAME, env, ctx);\n    sources = list(ctx, env, SOURCE);\n    resources = list(ctx, env, RESOURCE);\n    params = list(ctx, env, PARAM);\n    namespaces = list(ctx, env, NAMESPACE);\n    ArrayList<HashMap<String, String>> al = list(ctx, env, SCHEMA);\n    schemas = al.isEmpty() ? null : al.get(0);\n    al = list(ctx, env, COLLATION);\n    collations = al.isEmpty() ? null : al.get(0);\n    final String uri = string(STATIC_BASE_URI, ctx, env);\n    baseURI = \"#UNDEFINED\".equals(uri) ? \"\" : uri;\n\n    // collections\n    collURI = XQuery.string(\"*:collection/@uri\", env, ctx);\n\n    XQuery xq = new XQuery(\"*:collection/*:source/@role = '.'\", ctx).context(env);\n    collContext = xq.next().getBoolean();\n    xq.close();\n\n    collSources = new StringList();\n    xq = new XQuery(\"*:collection/*:source/@file\", ctx).context(env);\n    for(final XdmItem iatt : xq) collSources.add(iatt.getString());\n    xq.close();\n\n    decFormats = new HashMap<QName, HashMap<String, String>>();\n    xq = new XQuery(\"*:decimal-format\", ctx).context(env);\n    for(final XdmItem it : xq) {\n      final XdmItem xq2 = new XQuery(\n        \"for $n in @name \" +\n        \"let $b := substring-before($n, ':') \" +\n        \"return QName(if($b) then namespace-uri-for-prefix($b, .) else '', $n)\",\n        ctx).context(it).next();\n      final HashMap<String, String> hm = new HashMap<String, String>();\n      final QNm qnm = xq2 != null ? (QNm) xq2.internal() : new QNm(Token.EMPTY);\n      decFormats.put(qnm.toJava(), hm);\n      for(final XdmItem it2 : new XQuery(\"@*[name() != 'name']\", ctx).context(it)) {\n        hm.put(it2.getName().getLocalPart(), it2.getString());\n      }\n    }\n    xq.close();\n  }","id":104139,"modified_method":"/**\n   * Constructor.\n   * @param ctx database context\n   * @param env environment item\n   */\n  QT3Env(final Context ctx, final XdmValue env) {\n    name = XQuery.string('@' + NNAME, env, ctx);\n    sources = list(ctx, env, SOURCE);\n    resources = list(ctx, env, RESOURCE);\n    params = list(ctx, env, PARAM);\n    namespaces = list(ctx, env, NAMESPACE);\n    ArrayList<HashMap<String, String>> al = list(ctx, env, SCHEMA);\n    schemas = al.isEmpty() ? null : al.get(0);\n    al = list(ctx, env, COLLATION);\n    collations = al.isEmpty() ? null : al.get(0);\n    final String uri = string(STATIC_BASE_URI, ctx, env);\n    baseURI = \"#UNDEFINED\".equals(uri) ? \"\" : uri;\n\n    // collections\n    collURI = XQuery.string(\"*:collection/@uri\", env, ctx);\n\n    collContext = new XQuery(\"*:collection/*:source/@role = '.'\", ctx).\n        context(env).value().getBoolean();\n\n    collSources = new StringList();\n    for(final XdmItem iatt : new XQuery(\"*:collection/*:source/@file\", ctx).context(env))\n      collSources.add(iatt.getString());\n\n    decFormats = new HashMap<QName, HashMap<String, String>>();\n    for(final XdmItem it : new XQuery(\"*:decimal-format\", ctx).context(env)) {\n      final XdmValue it1 = new XQuery(\n        \"for $n in @name \" +\n        \"let $b := substring-before($n, ':') \" +\n        \"return QName(if($b) then namespace-uri-for-prefix($b, .) else '', $n)\",\n        ctx).context(it).value();\n      final HashMap<String, String> hm = new HashMap<String, String>();\n      final QNm qnm = it1.size() != 0 ? (QNm) it1.internal() : new QNm(Token.EMPTY);\n      decFormats.put(qnm.toJava(), hm);\n      for(final XdmItem it2 : new XQuery(\"@*[name() != 'name']\", ctx).context(it)) {\n        hm.put(it2.getName().getLocalPart(), it2.getString());\n      }\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests permutation.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertPermutation(final XdmValue value, final XdmValue expect) {\n    final XQuery query = new XQuery(expect.getString(), ctx);\n    try {\n      // cache expected results\n      final HashSet<String> exp = new HashSet<String>();\n      for(final XdmItem it : query) exp.add(it.getString());\n      // cache actual results\n      final HashSet<String> res = new HashSet<String>();\n      for(final XdmItem it : value) res.add(it.getString());\n\n      if(exp.size() != res.size())\n        return Util.info(\"% results (found: %)\", exp.size(), res.size());\n\n      for(final String s : exp.toArray(new String[exp.size()])) {\n        if(!res.contains(s)) return Util.info(\"% (missing)\", s);\n      }\n      for(final String s : res.toArray(new String[exp.size()])) {\n        if(!exp.contains(s))\n          return Util.info(\"% (missing in expected result)\", s);\n      }\n      return null;\n    } finally {\n      query.close();\n    }\n  }","id":104140,"modified_method":"/**\n   * Tests permutation.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertPermutation(final XdmValue value, final XdmValue expect) {\n    // cache expected results\n    final HashSet<String> exp = new HashSet<String>();\n    for(final XdmItem it : new XQuery(expect.getString(), ctx))\n      exp.add(it.getString());\n    // cache actual results\n    final HashSet<String> res = new HashSet<String>();\n    for(final XdmItem it : value) res.add(it.getString());\n\n    if(exp.size() != res.size())\n      return Util.info(\"% results (found: %)\", exp.size(), res.size());\n\n    for(final String s : exp.toArray(new String[exp.size()])) {\n      if(!res.contains(s)) return Util.info(\"% (missing)\", s);\n    }\n    for(final String s : res.toArray(new String[exp.size()])) {\n      if(!exp.contains(s))\n        return Util.info(\"% (missing in expected result)\", s);\n    }\n    return null;\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests any-of.\n   * @param res resulting value\n   * @param exp expected result\n   * @return optional expected test suite result\n   */\n  private String anyOf(final QT3Result res, final XdmValue exp) {\n    final XQuery query = new XQuery(\"*\", ctx).context(exp);\n    final TokenBuilder tb = new TokenBuilder();\n    try {\n      for(final XdmItem it : query) {\n        final String msg = test(res, it);\n        if(msg == null) return null;\n        tb.add(tb.isEmpty() ? \"\" : \", \").add(msg);\n      }\n      return \"any of { \" + tb + \" }\";\n    } finally {\n      query.close();\n    }\n  }","id":104141,"modified_method":"/**\n   * Tests any-of.\n   * @param res resulting value\n   * @param exp expected result\n   * @return optional expected test suite result\n   */\n  private String anyOf(final QT3Result res, final XdmValue exp) {\n    final TokenBuilder tb = new TokenBuilder();\n    for(final XdmItem it : new XQuery(\"*\", ctx).context(exp)) {\n      final String msg = test(res, it);\n      if(msg == null) return null;\n      tb.add(tb.isEmpty() ? \"\" : \", \").add(msg);\n    }\n    return \"any of { \" + tb + \" }\";\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Runs all tests.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  private void run(final String[] args) throws Exception {\n    ctx.mprop.set(MainProp.DBPATH, sandbox().path() + \"/data\");\n    parseArguments(args);\n    init();\n\n    final Performance perf = new Performance();\n    ctx.prop.set(Prop.CHOP, false);\n    ctx.prop.set(Prop.INTPARSE, false);\n    ctx.prop.set(Prop.SERIALIZER, \"omit-xml-declaration=no,indent=no\");\n\n    final XQuery qdoc = new XQuery(\"doc('\" + file(false, CATALOG) + \"')\", ctx);\n    final XdmValue doc = qdoc.value();\n    final String version = asString(\"*:catalog/@version\", doc);\n    Util.outln(NL + \"QT3 Test Suite \" + version);\n    Util.outln(\"Test directory: \" + new File(\".\").getCanonicalPath());\n    Util.out(\"Parsing queries\");\n\n    final XQuery qenv = new XQuery(\"*:catalog/*:environment\", ctx).context(doc);\n    for(final XdmItem ienv : qenv) genvs.add(new QT3Env(ctx, ienv));\n    qenv.close();\n\n    final XQuery qset = new XQuery(\n        \"for $f in //*:test-set/@file return string($f)\", ctx).context(doc);\n    for(final XdmItem it : qset) testSet(it.getString());\n    qset.close();\n    qdoc.close();\n\n    final StringBuilder result = new StringBuilder();\n    result.append(\" Rate    : \").append(pc(correct, tested)).append(NL);\n    result.append(\" Total   : \").append(total).append(NL);\n    result.append(\" Tested  : \").append(tested).append(NL);\n    result.append(\" Wrong   : \").append(tested - correct).append(NL);\n    result.append(\" Ignored : \").append(ignored).append(NL);\n\n    // save log data\n    Util.outln(NL + \"Writing log file '\" + testid + \".log'...\");\n    final PrintOutput po = new PrintOutput(testid + \".log\");\n    po.println(\"QT3TS RESULTS __________________________\" + NL);\n    po.println(result.toString());\n    po.println(\"WRONG __________________________________\" + NL);\n    po.print(wrong.finish());\n    if(all || !single.isEmpty()) {\n      po.println(\"CORRECT ________________________________\" + NL);\n      po.print(right.finish());\n    }\n    if(ignoring) {\n      po.println(\"IGNORED ________________________________\" + NL);\n      po.print(ignore.finish());\n    }\n    po.close();\n\n    // save report\n    if(report != null) {\n      final String file = \"ReportingResults/results_\" +\n          Prop.NAME + \"_\" + Prop.VERSION + IO.XMLSUFFIX;\n      new IOFile(file).write(report.create(ctx).toArray());\n      Util.outln(\"Creating report '\" + file + \"'...\");\n    }\n\n    Util.out(NL + result);\n    Util.outln(\" Time    : \" + perf);\n\n    if(slow != null && !slow.isEmpty()) {\n      Util.outln(NL + \"Slow queries:\");\n      for(final Map.Entry<Long, String> l : slow.entrySet()) {\n        Util.outln(\"- \" + -(l.getKey() / 1000000) + \" ms: \" + l.getValue());\n      }\n    }\n\n    ctx.close();\n    sandbox().delete();\n  }","id":104142,"modified_method":"/**\n   * Runs all tests.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  private void run(final String[] args) throws Exception {\n    ctx.mprop.set(MainProp.DBPATH, sandbox().path() + \"/data\");\n    parseArguments(args);\n    init();\n\n    final Performance perf = new Performance();\n    ctx.prop.set(Prop.CHOP, false);\n    ctx.prop.set(Prop.INTPARSE, false);\n    ctx.prop.set(Prop.SERIALIZER, \"omit-xml-declaration=no,indent=no\");\n\n    final XdmValue doc = new XQuery(\"doc('\" + file(false, CATALOG) + \"')\", ctx).value();\n    final String version = asString(\"*:catalog/@version\", doc);\n    Util.outln(NL + \"QT3 Test Suite \" + version);\n    Util.outln(\"Test directory: \" + new File(\".\").getCanonicalPath());\n    Util.out(\"Parsing queries\");\n\n    for(final XdmItem ienv : new XQuery(\"*:catalog/*:environment\", ctx).context(doc))\n      genvs.add(new QT3Env(ctx, ienv));\n\n    for(final XdmItem it : new XQuery(\"for $f in //*:test-set/@file return string($f)\",\n        ctx).context(doc)) testSet(it.getString());\n\n    final StringBuilder result = new StringBuilder();\n    result.append(\" Rate    : \").append(pc(correct, tested)).append(NL);\n    result.append(\" Total   : \").append(total).append(NL);\n    result.append(\" Tested  : \").append(tested).append(NL);\n    result.append(\" Wrong   : \").append(tested - correct).append(NL);\n    result.append(\" Ignored : \").append(ignored).append(NL);\n\n    // save log data\n    Util.outln(NL + \"Writing log file '\" + testid + \".log'...\");\n    final PrintOutput po = new PrintOutput(testid + \".log\");\n    po.println(\"QT3TS RESULTS __________________________\" + NL);\n    po.println(result.toString());\n    po.println(\"WRONG __________________________________\" + NL);\n    po.print(wrong.finish());\n    if(all || !single.isEmpty()) {\n      po.println(\"CORRECT ________________________________\" + NL);\n      po.print(right.finish());\n    }\n    if(ignoring) {\n      po.println(\"IGNORED ________________________________\" + NL);\n      po.print(ignore.finish());\n    }\n    po.close();\n\n    // save report\n    if(report != null) {\n      final String file = \"ReportingResults/results_\" +\n          Prop.NAME + \"_\" + Prop.VERSION + IO.XMLSUFFIX;\n      new IOFile(file).write(report.create(ctx).toArray());\n      Util.outln(\"Creating report '\" + file + \"'...\");\n    }\n\n    Util.out(NL + result);\n    Util.outln(\" Time    : \" + perf);\n\n    if(slow != null && !slow.isEmpty()) {\n      Util.outln(NL + \"Slow queries:\");\n      for(final Map.Entry<Long, String> l : slow.entrySet()) {\n        Util.outln(\"- \" + -(l.getKey() / 1000000) + \" ms: \" + l.getValue());\n      }\n    }\n\n    ctx.close();\n    sandbox().delete();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests all-of.\n   * @param res resulting value\n   * @param exp expected result\n   * @return optional expected test suite result\n   */\n  private String allOf(final QT3Result res, final XdmValue exp) {\n    final XQuery query = new XQuery(\"*\", ctx).context(exp);\n    try {\n      final TokenBuilder tb = new TokenBuilder();\n      for(final XdmItem it : query) {\n        final String msg = test(res, it);\n        if(msg != null) tb.add(tb.isEmpty() ? \"\" : \", \").add(msg);\n      }\n      return tb.isEmpty() ? null : tb.toString();\n    } finally {\n      query.close();\n    }\n  }","id":104143,"modified_method":"/**\n   * Tests all-of.\n   * @param res resulting value\n   * @param exp expected result\n   * @return optional expected test suite result\n   */\n  private String allOf(final QT3Result res, final XdmValue exp) {\n    final TokenBuilder tb = new TokenBuilder();\n    for(final XdmItem it : new XQuery(\"*\", ctx).context(exp)) {\n      final String msg = test(res, it);\n      if(msg != null) tb.add(tb.isEmpty() ? \"\" : \", \").add(msg);\n    }\n    return tb.isEmpty() ? null : tb.toString();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Runs a single test case.\n   * @param test node\n   * @param envs environments\n   * @throws Exception exception\n   */\n  private void testCase(final XdmItem test, final ArrayList<QT3Env> envs)\n      throws Exception {\n\n    if(total++ % 500 == 0) Util.out(\".\");\n\n    if(!supported(test)) {\n      if(ignoring) ignore.add(asString(\"@name\", test)).add(NL);\n      ignored++;\n      return;\n    }\n\n    // skip queries that do not match filter\n    final String name = asString(\"@name\", test);\n    if(!name.startsWith(single)) {\n      if(ignoring) ignore.add(name).add(NL);\n      ignored++;\n      return;\n    }\n\n    tested++;\n\n    // expected result\n    final XQuery qexp = new XQuery(\"*:result/*[1]\", ctx).context(test);\n    final XdmValue expected = qexp.value();\n\n    // use XQuery 1.0 if XQ10 or XP20 is specified\n    final XQuery q = new XQuery(\"*:dependency[@type='spec']\" +\n        \"[matches(@value,'(XQ10)([^+]|$)')]\", ctx);\n    if(q.context(test).next() != null) ctx.prop.set(Prop.XQUERY3, false);\n    q.close();\n\n    // check if environment is defined in test-case\n    QT3Env e = null;\n    final XQuery qenv = new XQuery(\"*:environment[*]\", ctx).context(test);\n    final XdmValue ienv = qenv.next();\n    if(ienv != null) e = new QT3Env(ctx, ienv);\n    qenv.close();\n\n    // parse local environment\n    boolean base = true;\n    if(e == null) {\n      final String env = asString(\"*:environment/@ref\", test);\n      if(!env.isEmpty()) {\n        // check if environment is defined in test-set\n        e = envs(envs, env);\n        // check if environment is defined in catalog\n        if(e == null) {\n          e = envs(genvs, env);\n          base = false;\n        }\n        if(e == null) Util.errln(\"%: environment '%' not found.\", name, env);\n      }\n    }\n\n    // retrieve query to be run\n    final Performance perf = new Performance();\n    final String qfile = asString(\"*:test/@file\", test);\n    String string;\n    if(qfile.isEmpty()) {\n      // get query string\n      string = asString(\"*:test\", test);\n    } else {\n      // get query from file\n      string = string(new IOFile(baseDir, qfile).read());\n    }\n\n    if(verbose) Util.outln(name);\n    final XQuery query = new XQuery(string, ctx);\n    if(base) query.baseURI(baseURI);\n\n    // add modules\n    final String qm = \"for $m in *:module return ($m/@uri, $m/@file)\";\n    final XQuery qmod = new XQuery(qm, ctx).context(test);\n    while(true) {\n      final XdmItem uri = qmod.next();\n      if(uri == null) break;\n      final XdmItem file = qmod.next();\n      if(file == null) break;\n      query.addModule(uri.getString(), baseDir + file.getString());\n    }\n\n    final QT3Result result = new QT3Result();\n    try {\n      if(e != null) {\n        // bind namespaces\n        for(final HashMap<String, String> ns : e.namespaces) {\n          query.namespace(ns.get(PREFIX), ns.get(URI));\n        }\n        // bind variables\n        for(final HashMap<String, String> par : e.params) {\n          query.bind(par.get(NNAME), new XQuery(par.get(SELECT), ctx).value());\n        }\n        // bind documents\n        for(final HashMap<String, String> src : e.sources) {\n          // add document reference\n          final String file = file(base, src.get(FILE));\n          query.addDocument(src.get(URI), file);\n          final String role = src.get(ROLE);\n          if(role == null) continue;\n          final Object call = Function.DOC.get(Str.get(file));\n          if(role.equals(\".\")) query.context(call);\n          else query.bind(role, call);\n        }\n        // bind resources\n        for(final HashMap<String, String> src : e.resources) {\n          query.addResource(src.get(URI), file(base, src.get(FILE)), src.get(ENCODING));\n        }\n        // bind collections\n        query.addCollection(e.collURI, e.collSources.toArray());\n        if(e.collContext) {\n          query.context(Function.COLLECTION.get(Str.get(e.collURI)));\n        }\n        // set base uri\n        if(e.baseURI != null) query.baseURI(e.baseURI);\n        // bind decimal formats\n        for(final Map.Entry<QName, HashMap<String, String>> df :\n          e.decFormats.entrySet()) {\n          query.decimalFormat(df.getKey(), df.getValue());\n        }\n      }\n\n      // run query\n      result.value = query.value();\n      result.sprop = query.serializer();\n    } catch(final XQueryException ex) {\n      result.err = ex;\n      result.value = null;\n    } catch(final Throwable ex) {\n      // unexpected error (potential bug)\n      result.error = ex;\n      Util.errln(\"Query: \" + name);\n      ex.printStackTrace();\n    }\n\n    if(slow != null) {\n      final long l = perf.time();\n      if(l > 100000000) slow.put(-l, name);\n    }\n\n    // revert to XQuery as default\n    ctx.prop.set(Prop.XQUERY3, true);\n\n    final String exp = test(result, expected);\n    final TokenBuilder tmp = new TokenBuilder();\n    tmp.add(name).add(NL);\n    tmp.add(noComments(string)).add(NL);\n\n    boolean err = result.value == null;\n    String res;\n    try {\n      if(result.error != null) {\n        res = result.error.toString();\n      } else if(result.err != null) {\n        res = result.err.getCode() + \": \" + result.err.getLocalizedMessage();\n      } else {\n        result.sprop.set(SerializerProp.S_OMIT_XML_DECLARATION, \"yes\");\n        res = serialize(result.value, result.sprop);\n      }\n    } catch(final XQueryException ex) {\n      res = ex.getCode() + \": \" + ex.getLocalizedMessage();\n      err = true;\n    } catch(final Throwable ex) {\n      res = \"Unexpected: \" + ex.toString();\n      err = true;\n    }\n\n    tmp.add(err ? \"Error : \" : \"Result: \").add(noComments(res)).add(NL);\n    if(exp == null) {\n      tmp.add(NL);\n      right.add(tmp.finish());\n      correct++;\n    } else {\n      tmp.add(\"Expect: \" + noComments(exp)).add(NL).add(NL);\n      wrong.add(tmp.finish());\n    }\n    if(report != null) report.addTest(name, exp == null);\n\n    query.close();\n    qexp.close();\n  }","id":104144,"modified_method":"/**\n   * Runs a single test case.\n   * @param test node\n   * @param envs environments\n   * @throws Exception exception\n   */\n  private void testCase(final XdmItem test, final ArrayList<QT3Env> envs)\n      throws Exception {\n\n    if(total++ % 500 == 0) Util.out(\".\");\n\n    if(!supported(test)) {\n      if(ignoring) ignore.add(asString(\"@name\", test)).add(NL);\n      ignored++;\n      return;\n    }\n\n    // skip queries that do not match filter\n    final String name = asString(\"@name\", test);\n    if(!name.startsWith(single)) {\n      if(ignoring) ignore.add(name).add(NL);\n      ignored++;\n      return;\n    }\n\n    tested++;\n\n    // expected result\n    final XdmValue expected = new XQuery(\"*:result/*[1]\", ctx).context(test).value();\n\n    // use XQuery 1.0 if XQ10 or XP20 is specified\n    if(new XQuery(\"*:dependency[@type='spec'][matches(@value,'(XQ10)([^+]|$)')]\", ctx).\n        context(test).next() != null) ctx.prop.set(Prop.XQUERY3, false);\n\n    // check if environment is defined in test-case\n    QT3Env e = null;\n    final XdmValue ienv = new XQuery(\"*:environment[*]\", ctx).context(test).value();\n    if(ienv.size() != 0) e = new QT3Env(ctx, ienv);\n\n    // parse local environment\n    boolean base = true;\n    if(e == null) {\n      final String env = asString(\"*:environment/@ref\", test);\n      if(!env.isEmpty()) {\n        // check if environment is defined in test-set\n        e = envs(envs, env);\n        // check if environment is defined in catalog\n        if(e == null) {\n          e = envs(genvs, env);\n          base = false;\n        }\n        if(e == null) Util.errln(\"%: environment '%' not found.\", name, env);\n      }\n    }\n\n    // retrieve query to be run\n    final Performance perf = new Performance();\n    final String qfile = asString(\"*:test/@file\", test);\n    String string;\n    if(qfile.isEmpty()) {\n      // get query string\n      string = asString(\"*:test\", test);\n    } else {\n      // get query from file\n      string = string(new IOFile(baseDir, qfile).read());\n    }\n\n    if(verbose) Util.outln(name);\n    final XQuery query = new XQuery(string, ctx);\n    if(base) query.baseURI(baseURI);\n\n    // add modules\n    final String qm = \"for $m in *:module return ($m/@uri, $m/@file)\";\n    final XQuery qmod = new XQuery(qm, ctx).context(test);\n    while(true) {\n      final XdmItem uri = qmod.next();\n      if(uri == null) break;\n      final XdmItem file = qmod.next();\n      if(file == null) break;\n      query.addModule(uri.getString(), baseDir + file.getString());\n    }\n\n    final QT3Result result = new QT3Result();\n    try {\n      if(e != null) {\n        // bind namespaces\n        for(final HashMap<String, String> ns : e.namespaces) {\n          query.namespace(ns.get(PREFIX), ns.get(URI));\n        }\n        // bind variables\n        for(final HashMap<String, String> par : e.params) {\n          query.bind(par.get(NNAME), new XQuery(par.get(SELECT), ctx).value());\n        }\n        // bind documents\n        for(final HashMap<String, String> src : e.sources) {\n          // add document reference\n          final String file = file(base, src.get(FILE));\n          query.addDocument(src.get(URI), file);\n          final String role = src.get(ROLE);\n          if(role == null) continue;\n          final Object call = Function.DOC.get(Str.get(file));\n          if(role.equals(\".\")) query.context(call);\n          else query.bind(role, call);\n        }\n        // bind resources\n        for(final HashMap<String, String> src : e.resources) {\n          query.addResource(src.get(URI), file(base, src.get(FILE)), src.get(ENCODING));\n        }\n        // bind collections\n        query.addCollection(e.collURI, e.collSources.toArray());\n        if(e.collContext) {\n          query.context(Function.COLLECTION.get(Str.get(e.collURI)));\n        }\n        // set base uri\n        if(e.baseURI != null) query.baseURI(e.baseURI);\n        // bind decimal formats\n        for(final Map.Entry<QName, HashMap<String, String>> df :\n          e.decFormats.entrySet()) {\n          query.decimalFormat(df.getKey(), df.getValue());\n        }\n      }\n\n      // run query\n      result.value = query.value();\n      result.sprop = query.serializer();\n    } catch(final XQueryException ex) {\n      result.err = ex;\n      result.value = null;\n    } catch(final Throwable ex) {\n      // unexpected error (potential bug)\n      result.error = ex;\n      Util.errln(\"Query: \" + name);\n      ex.printStackTrace();\n    }\n\n    if(slow != null) {\n      final long l = perf.time();\n      if(l > 100000000) slow.put(-l, name);\n    }\n\n    // revert to XQuery as default\n    ctx.prop.set(Prop.XQUERY3, true);\n\n    final String exp = test(result, expected);\n    final TokenBuilder tmp = new TokenBuilder();\n    tmp.add(name).add(NL);\n    tmp.add(noComments(string)).add(NL);\n\n    boolean err = result.value == null;\n    String res;\n    try {\n      if(result.error != null) {\n        res = result.error.toString();\n      } else if(result.err != null) {\n        res = result.err.getCode() + \": \" + result.err.getLocalizedMessage();\n      } else {\n        result.sprop.set(SerializerProp.S_OMIT_XML_DECLARATION, \"yes\");\n        res = serialize(result.value, result.sprop);\n      }\n    } catch(final XQueryException ex) {\n      res = ex.getCode() + \": \" + ex.getLocalizedMessage();\n      err = true;\n    } catch(final Throwable ex) {\n      res = \"Unexpected: \" + ex.toString();\n      err = true;\n    }\n\n    tmp.add(err ? \"Error : \" : \"Result: \").add(noComments(res)).add(NL);\n    if(exp == null) {\n      tmp.add(NL);\n      right.add(tmp.finish());\n      correct++;\n    } else {\n      tmp.add(\"Expect: \" + noComments(exp)).add(NL).add(NL);\n      wrong.add(tmp.finish());\n    }\n    if(report != null) report.addTest(name, exp == null);\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests equality.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertEq(final XdmValue value, final XdmValue expect) {\n    final XQuery query = new XQuery(expect.getString(), ctx);\n    try {\n      final XdmItem exp = query.next();\n      final XdmItem res = value instanceof XdmItem ? (XdmItem) value : null;\n      return exp.equal(res) ? null : exp.toString();\n    } catch(final XQueryException err) {\n      // try simple string comparison\n      return expect.getString().equals(value.getString()) ? null :\n        err.getException().getMessage();\n    } finally {\n      query.close();\n    }\n  }","id":104145,"modified_method":"/**\n   * Tests equality.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertEq(final XdmValue value, final XdmValue expect) {\n    try {\n      final XdmItem exp = new XQuery(expect.getString(), ctx).next();\n      final XdmItem res = value instanceof XdmItem ? (XdmItem) value : null;\n      return exp.equal(res) ? null : exp.toString();\n    } catch(final XQueryException err) {\n      // try simple string comparison\n      return expect.getString().equals(value.getString()) ? null :\n        err.getException().getMessage();\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks if the current test case is supported.\n   * @param test test case\n   * @return result of check\n   */\n  private boolean supported(final XdmValue test) {\n    // the following query generates a result if the specified test is not supported\n    final XQuery q = new XQuery(\n      \"*:environment/*:collation |\" + // skip collation tests\n      \"*:dependency[\" +\n      // skip schema imports, schema validation, namespace axis, static typing\n      \"@type = 'feature' and (\" +\n      \" @value = \" + NOSUPPORT + \" and (@satisfied = 'true' or empty(@satisfied)) or\" +\n      \" @value != \" + NOSUPPORT + \"and @satisfied = 'false') or \" +\n      // skip fully-normalized unicode tests\n      \"@type = 'unicode-normalization-form' and @value = 'FULLY-NORMALIZED' or \" +\n      // skip xml/xsd 1.1 tests\n      \"@type = ('xml-version', 'xsd-version') and @value = ('1.1', '1.0:4-') or \" +\n      // skip non-XQuery tests\n      \"@type = 'spec' and not(contains(@value, 'XQ'))\" +\n      \"]\", ctx).context(test);\n\n    try {\n      return q.next() == null;\n    } finally {\n      q.close();\n    }\n  }","id":104146,"modified_method":"/**\n   * Checks if the current test case is supported.\n   * @param test test case\n   * @return result of check\n   */\n  private boolean supported(final XdmValue test) {\n    // the following query generates a result if the specified test is not supported\n    return new XQuery(\n      \"*:environment/*:collation |\" + // skip collation tests\n      \"*:dependency[\" +\n      // skip schema imports, schema validation, namespace axis, static typing\n      \"@type = 'feature' and (\" +\n      \" @value = \" + NOSUPPORT + \" and (@satisfied = 'true' or empty(@satisfied)) or\" +\n      \" @value != \" + NOSUPPORT + \"and @satisfied = 'false') or \" +\n      // skip fully-normalized unicode tests\n      \"@type = 'unicode-normalization-form' and @value = 'FULLY-NORMALIZED' or \" +\n      // skip xml/xsd 1.1 tests\n      \"@type = ('xml-version', 'xsd-version') and @value = ('1.1', '1.0:4-') or \" +\n      // skip non-XQuery tests\n      \"@type = 'spec' and not(contains(@value, 'XQ'))\" +\n      \"]\", ctx).context(test).value().size() == 0;\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Runs a single test set.\n   * @param name name of test set\n   * @throws Exception exception\n   */\n  private void testSet(final String name) throws Exception {\n    final XQuery qdoc = new XQuery(\"doc(' \" + file(false, name) + \"')\", ctx);\n    final XdmValue doc = qdoc.value();\n    final XQuery qset = new XQuery(\"*:test-set\", ctx).context(doc);\n    final XdmValue set = qset.value();\n    final IO base = IO.get(doc.getBaseURI());\n    baseURI = base.path();\n    baseDir = base.dirPath();\n    qdoc.close();\n\n    if(supported(set)) {\n      // parse environment of test-set\n      final XQuery qenv = new XQuery(\"*:environment\", ctx).context(set);\n      final ArrayList<QT3Env> envs = new ArrayList<QT3Env>();\n      for(final XdmItem ienv : qenv) envs.add(new QT3Env(ctx, ienv));\n      qenv.close();\n\n      if(report != null) report.addSet(asString(\"@name\", set));\n\n      // run all test cases\n      final XQuery qts = new XQuery(\"*:test-case\", ctx).context(set);\n      for(final XdmItem its : qts) {\n        try {\n          testCase(its, envs);\n        } catch(final IOException ex) {\n          Util.debug(ex);\n        }\n      }\n      qts.close();\n    }\n    qset.close();\n  }","id":104147,"modified_method":"/**\n   * Runs a single test set.\n   * @param name name of test set\n   * @throws Exception exception\n   */\n  private void testSet(final String name) throws Exception {\n    final XdmValue doc = new XQuery(\"doc(' \" + file(false, name) + \"')\", ctx).value();\n    final XdmValue set = new XQuery(\"*:test-set\", ctx).context(doc).value();\n    final IO base = IO.get(doc.getBaseURI());\n    baseURI = base.path();\n    baseDir = base.dirPath();\n\n    if(supported(set)) {\n      // parse environment of test-set\n      final ArrayList<QT3Env> envs = new ArrayList<QT3Env>();\n      for(final XdmItem ienv : new XQuery(\"*:environment\", ctx).context(set))\n        envs.add(new QT3Env(ctx, ienv));\n\n      if(report != null) report.addSet(asString(\"@name\", set));\n\n      // run all test cases\n      for(final XdmItem its : new XQuery(\"*:test-case\", ctx).context(set)) {\n        try {\n          testCase(its, envs);\n        } catch(final IOException ex) {\n          Util.debug(ex);\n        }\n      }\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests deep equals.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertDeepEq(final XdmValue value, final XdmValue expect) {\n    final XQuery query = new XQuery(expect.getString(), ctx);\n    try {\n      final XdmValue exp = query.value();\n      return exp.deepEqual(value) ? null : exp.toString();\n    } finally {\n      query.close();\n    }\n  }","id":104148,"modified_method":"/**\n   * Tests deep equals.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertDeepEq(final XdmValue value, final XdmValue expect) {\n    final XdmValue exp = new XQuery(expect.getString(), ctx).value();\n    return exp.deepEqual(value) ? null : exp.toString();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests assertion.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertQuery(final XdmValue value, final XdmValue expect) {\n    final String exp = expect.getString();\n    final XQuery query = new XQuery(exp, ctx);\n    try {\n      return query.bind(\"result\", value).value().getBoolean() ? null : exp;\n    } catch(final XQueryException ex) {\n      // should not occur\n      return ex.getException().getMessage();\n    } finally {\n      query.close();\n    }\n  }","id":104149,"modified_method":"/**\n   * Tests assertion.\n   * @param value resulting value\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  private String assertQuery(final XdmValue value, final XdmValue expect) {\n    final String exp = expect.getString();\n    try {\n      return new XQuery(exp, ctx).bind(\"result\", value).value().getBoolean() ? null : exp;\n    } catch(final XQueryException ex) {\n      // should not occur\n      return ex.getException().getMessage();\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the boolean representation of a query result.\n   * @param query query string\n   * @param value optional context value\n   * @return optional expected test suite result\n   */\n  boolean asBoolean(final String query, final XdmValue value) {\n    final XQuery qp = new XQuery(query, ctx).context(value);\n    try {\n      final XdmItem it = qp.next();\n      return it != null && it.getBoolean();\n    } finally {\n      qp.close();\n    }\n  }","id":104150,"modified_method":"/**\n   * Returns the boolean representation of a query result.\n   * @param query query string\n   * @param value optional context value\n   * @return optional expected test suite result\n   */\n  boolean asBoolean(final String query, final XdmValue value) {\n    final XdmValue val = new XQuery(query, ctx).context(value).value();\n    return val.size() != 0 && val.getBoolean();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests permutation.\n   * [LW] wrong\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertPermutation(final String expect) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(Util.info(\"Permutation of: '%'\", expect));\n    final XQuery query = new XQuery(expect, ctx);\n    try {\n      // cache expected results\n      final HashSet<String> exp = new HashSet<String>();\n      for(final XdmItem it : query) exp.add(it.getString());\n      // cache actual results\n      final HashSet<String> res = new HashSet<String>();\n      for(final XdmItem it : value) res.add(it.getString());\n\n      if(exp.size() != res.size())\n        return fail(Util.info(\"% results (found: %)\", exp.size(), res.size()));\n\n      for(final String s : exp.toArray(new String[exp.size()])) {\n        if(!res.contains(s)) return fail(Util.info(\"% (missing)\", s));\n      }\n      for(final String s : res.toArray(new String[exp.size()])) {\n        if(!exp.contains(s))\n          return fail(Util.info(\"% (missing in expected result)\", s));\n      }\n      return true;\n    } finally {\n      query.close();\n    }\n  }","id":104151,"modified_method":"/**\n   * Tests permutation.\n   * [LW] wrong\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertPermutation(final String expect) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(Util.info(\"Permutation of: '%'\", expect));\n    // cache expected results\n    final HashSet<String> exp = new HashSet<String>();\n    for(final XdmItem it : new XQuery(expect, ctx)) exp.add(it.getString());\n    // cache actual results\n    final HashSet<String> res = new HashSet<String>();\n    for(final XdmItem it : value) res.add(it.getString());\n\n    if(exp.size() != res.size())\n      return fail(Util.info(\"% results (found: %)\", exp.size(), res.size()));\n\n    for(final String s : exp.toArray(new String[exp.size()])) {\n      if(!res.contains(s)) return fail(Util.info(\"% (missing)\", s));\n    }\n    for(final String s : res.toArray(new String[exp.size()])) {\n      if(!exp.contains(s))\n        return fail(Util.info(\"% (missing in expected result)\", s));\n    }\n    return true;\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests assertion.\n   * @param exp expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertQuery(final String exp) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(exp);\n\n    final XQuery query = new XQuery(exp, ctx);\n    try {\n      return result(query.bind(\"result\", value).value().getBoolean(), exp);\n    } catch(final XQueryException ex) {\n      // should not occur\n      return fail(ex.getException().getMessage());\n    } finally {\n      query.close();\n    }\n  }","id":104152,"modified_method":"/**\n   * Tests assertion.\n   * @param exp expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertQuery(final String exp) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(exp);\n    try {\n      return result(new XQuery(exp, ctx).bind(\"result\", value).value().getBoolean(), exp);\n    } catch(final XQueryException ex) {\n      // should not occur\n      return fail(ex.getException().getMessage());\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests equality.\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertEq(final String expect) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(Util.info(\"Equal to: '%'\", expect));\n\n    final XQuery query = new XQuery(expect, ctx);\n    try {\n      final XdmItem exp = query.next();\n      final XdmItem res = value instanceof XdmItem ? (XdmItem) value : null;\n      return result(exp.equal(res), exp.toString());\n    } catch(final XQueryException err) {\n      return result(expect.equals(value.getString()), err.getException().getMessage());\n    } finally {\n      query.close();\n    }\n  }","id":104153,"modified_method":"/**\n   * Tests equality.\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertEq(final String expect) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(Util.info(\"Equal to: '%'\", expect));\n\n    try {\n      final XdmItem exp = new XQuery(expect, ctx).next();\n      final XdmItem res = value instanceof XdmItem ? (XdmItem) value : null;\n      return result(exp.equal(res), exp.toString());\n    } catch(final XQueryException err) {\n      return result(expect.equals(value.getString()), err.getException().getMessage());\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the boolean representation of a query result.\n   * @param query query string\n   * @param value optional context value\n   * @return optional expected test suite result\n   */\n  private boolean asBoolean(final String query, final XdmValue value) {\n    final XQuery qp = new XQuery(query, ctx).context(value);\n    try {\n      final XdmItem it = qp.next();\n      return it != null && it.getBoolean();\n    } finally {\n      qp.close();\n    }\n  }","id":104154,"modified_method":"/**\n   * Returns the boolean representation of a query result.\n   * @param query query string\n   * @param value optional context value\n   * @return optional expected test suite result\n   */\n  private boolean asBoolean(final String query, final XdmValue value) {\n    final XdmValue xv = new XQuery(query, ctx).context(value).value();\n    return xv.size() != 0 && xv.getBoolean();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a document node from the given file path.\n   * @param file file path\n   * @return document node\n   */\n  protected XdmItem node(final String file) {\n    if(file == null) return null;\n    final XQuery xq = new XQuery(\"doc('\" + file + \"')\", ctx);\n    try {\n      return xq.next();\n    } finally {\n      xq.close();\n    }\n  }","id":104155,"modified_method":"/**\n   * Creates a document node from the given file path.\n   * @param file file path\n   * @return document node\n   */\n  protected XdmItem node(final String file) {\n    return file == null ? null : new XQuery(\"doc('\" + file + \"')\", ctx).next();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests deep equals.\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertDeepEq(final String expect) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(Util.info(\"Deep-equal to: '%'\", expect));\n    final XQuery query = new XQuery(expect, ctx);\n    try {\n      final XdmValue exp = query.value();\n      return result(exp.deepEqual(value), exp.toString());\n    } finally {\n      query.close();\n    }\n  }","id":104156,"modified_method":"/**\n   * Tests deep equals.\n   * @param expect expected result\n   * @return optional expected test suite result\n   */\n  protected boolean assertDeepEq(final String expect) {\n    final XdmValue value = result.value;\n    if(value == null) return fail(Util.info(\"Deep-equal to: '%'\", expect));\n    final XdmValue exp = new XQuery(expect, ctx).value();\n    return result(exp.deepEqual(value), exp.toString());\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the result value.\n   * @return result value\n   * @throws XQueryException exception\n   */\n  public XdmValue value() {\n    try {\n      return XdmValue.get(qp.value());\n    } catch(final QueryException ex) {\n      Util.debug(ex);\n      throw new XQueryException(ex);\n    }\n  }","id":104157,"modified_method":"/**\n   * Returns the result value.\n   * @return result value\n   * @throws XQueryException exception\n   */\n  public XdmValue value() {\n    try {\n      return XdmValue.get(qp.value());\n    } catch(final QueryException ex) {\n      Util.debug(ex);\n      throw new XQueryException(ex);\n    } finally {\n      qp.close();\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the string representation of a query result.\n   * @param query query string\n   * @param val optional context\n   * @param ctx database context\n   * @return optional expected test suite result\n   */\n  public static String string(final String query, final XdmValue val, final Context ctx) {\n    final XQuery qp = new XQuery(query, ctx).context(val);\n    try {\n      final XdmItem it = qp.next();\n      return it == null ? \"\" : it.getString();\n    } finally {\n      qp.close();\n    }\n  }","id":104158,"modified_method":"/**\n   * Returns the string representation of a query result.\n   * @param query query string\n   * @param val optional context\n   * @param ctx database context\n   * @return optional expected test suite result\n   */\n  public static String string(final String query, final XdmValue val, final Context ctx) {\n    final XdmValue xv = new XQuery(query, ctx).context(val).value();\n    return xv.size() == 0 ? \"\" : xv.getString();\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Declares a decimal format.\n   * @param name qname\n   * @param map format\n   * @return self reference\n   */\n  public XQuery decimalFormat(final QName name, final HashMap<String, String> map) {\n    try {\n      qp.ctx.sc.decFormats.add(new QNm(name).id(), new DecFormatter(null, map));\n      return this;\n    } catch(final QueryException ex) {\n      Util.debug(ex);\n      throw new XQueryException(ex);\n    }\n  }","id":104159,"modified_method":"/**\n   * Declares a decimal format.\n   * @param name qname\n   * @param map format\n   * @return self reference\n   */\n  public XQuery decimalFormat(final QName name, final HashMap<String, String> map) {\n    try {\n      final TokenMap tm = new TokenMap();\n      for(final Map.Entry<String, String> e : map.entrySet()) {\n        tm.add(Token.token(e.getKey()), Token.token(e.getValue()));\n      }\n      qp.ctx.sc.decFormats.add(new QNm(name).id(), new DecFormatter(null, tm));\n      return this;\n    } catch(final QueryException ex) {\n      Util.debug(ex);\n      throw new XQueryException(ex);\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the next item, or {@code null} if all items have been returned.\n   * @return next result item\n   * @throws XQueryException exception\n   */\n  public XdmItem next() {\n    try {\n      if(ir == null) ir = qp.iter();\n      return XdmItem.get(ir.next());\n    } catch(final QueryException ex) {\n      Util.debug(ex);\n      throw new XQueryException(ex);\n    }\n  }","id":104160,"modified_method":"/**\n   * Returns the next item, or {@code null} if all items have been returned.\n   * @return next result item\n   * @throws XQueryException exception\n   */\n  public XdmItem next() {\n    Item it = null;\n    try {\n      if(ir == null) ir = qp.iter();\n      it = ir.next();\n      return it != null ? XdmItem.get(it) : null;\n    } catch(final QueryException ex) {\n      Util.debug(ex);\n      throw new XQueryException(ex);\n    } finally {\n      if(it == null) qp.close();\n    }\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a new XQuery value.\n   * @param val value\n   * @return result\n   */\n  public static XdmItem get(final Item val) {\n    return val == null ? null : val instanceof ANode ?\n        new XdmNode((ANode) val) : new XdmAtomic(val);\n  }","id":104161,"modified_method":"/**\n   * Returns a new XQuery value.\n   * @param val value\n   * @return result\n   */\n  public static XdmItem get(final Item val) {\n    return val instanceof ANode ? new XdmNode((ANode) val) : new XdmAtomic(val);\n  }","commit_id":"66b5157ded9a60bef03c396e42aca6d84dbceaf0","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public void visit(ExpressionComprehensionClause that) {\n        Term t = that.getExpression().getTerm();\n        if (t instanceof QualifiedMemberExpression) {\n            /*if (((QualifiedMemberExpression) t).getDeclaration() instanceof TypedDeclaration) {\n                ((TypedDeclaration)((QualifiedMemberExpression) t).getDeclaration()).setUnboxed(false);\n            }*/\n            Tree.Primary p = ((QualifiedMemberExpression) t).getPrimary();\n            if (p instanceof BaseMemberExpression) {\n                if (((BaseMemberExpression) p).getDeclaration() instanceof TypedDeclaration) {\n                    ((TypedDeclaration)((BaseMemberExpression) p).getDeclaration()).setUnboxed(false);\n                }\n            }\n        }\n        super.visit(that);\n    }","id":104162,"modified_method":"@Override\n    public void visit(ExpressionComprehensionClause that) {\n        super.visit(that);\n    }","commit_id":"b886595cdb7af83c590be2a02442d24e61b4b33a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override public void visit(IfComprehensionClause that) {\n        if (that.getCondition() instanceof IsCondition) {\n            ((IsCondition)that.getCondition()).getVariable().getDeclarationModel().setUnboxed(false);\n        } else if (that.getCondition() instanceof ExistsOrNonemptyCondition) {\n            ((ExistsOrNonemptyCondition)that.getCondition()).getVariable().getDeclarationModel().setUnboxed(false);\n        }\n        super.visit(that);\n    }","id":104163,"modified_method":"@Override public void visit(IfComprehensionClause that) {\n        Variable var = null;\n        if (that.getCondition() instanceof IsCondition) {\n            var = ((IsCondition)that.getCondition()).getVariable();\n        } else if (that.getCondition() instanceof ExistsOrNonemptyCondition) {\n            var = ((ExistsOrNonemptyCondition)that.getCondition()).getVariable();\n        }\n        if (var != null) {\n            var.getDeclarationModel().setUnboxed(false);\n        }\n        super.visit(that);\n    }","commit_id":"b886595cdb7af83c590be2a02442d24e61b4b33a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void testWorkItem() {\r\n    \tKnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        Reader source = new StringReader(\r\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\r\n            \"<process xmlns=\\\"http://drools.org/drools-5.0/process\\\"\\n\" +\r\n            \"         xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\" +\r\n            \"         xs:schemaLocation=\\\"http://drools.org/drools-5.0/process drools-processes-5.0.xsd\\\"\\n\" +\r\n            \"         type=\\\"RuleFlow\\\" name=\\\"flow\\\" id=\\\"org.drools.actions\\\" package-name=\\\"org.drools\\\" version=\\\"1\\\" >\\n\" +\r\n            \"\\n\" +\r\n            \"  <header>\\n\" +\r\n    \t\t\"    <variables>\\n\" +\r\n    \t\t\"      <variable name=\\\"UserName\\\" >\\n\" +\r\n    \t\t\"        <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n    \t\t\"        <value>John Doe<\/value>\\n\" +\r\n    \t\t\"      <\/variable>\\n\" +\r\n    \t\t\"      <variable name=\\\"MyObject\\\" >\\n\" +\r\n    \t\t\"        <type name=\\\"org.drools.process.core.datatype.impl.type.ObjectDataType\\\" className=\\\"java.lang.Object\\\" />\\n\" +\r\n    \t\t\"      <\/variable>\\n\" +\r\n    \t\t\"    <\/variables>\\n\" +\r\n            \"  <\/header>\\n\" +\r\n            \"\\n\" +\r\n            \"  <nodes>\\n\" +\r\n            \"    <start id=\\\"1\\\" name=\\\"Start\\\" />\\n\" +\r\n            \"    <workItem id=\\\"2\\\" name=\\\"HumanTask\\\" >\\n\" +\r\n            \"      <work name=\\\"Human Task\\\" >\\n\" +\r\n            \"        <parameter name=\\\"ActorId\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"          <value>#{UserName}<\/value>\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"TaskName\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"          <value>Do something<\/value>\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Priority\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Comment\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Attachment\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.ObjectDataType\\\" className=\\\"java.lang.Object\\\" />\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"      <\/work>\\n\" +\r\n            \"      <mapping type=\\\"in\\\" from=\\\"MyObject\\\" to=\\\"Attachment\\\" />\" +\r\n            \"      <mapping type=\\\"out\\\" from=\\\"Result\\\" to=\\\"MyObject\\\" />\" +\r\n            \"    <\/workItem>\\n\" +\r\n            \"    <end id=\\\"3\\\" name=\\\"End\\\" />\\n\" +\r\n            \"  <\/nodes>\\n\" +\r\n            \"\\n\" +\r\n            \"  <connections>\\n\" +\r\n            \"    <connection from=\\\"1\\\" to=\\\"2\\\" />\\n\" +\r\n            \"    <connection from=\\\"2\\\" to=\\\"3\\\" />\\n\" +\r\n            \"  <\/connections>\\n\" +\r\n            \"\\n\" +\r\n            \"<\/process>\");\r\n        kbuilder.add( ResourceFactory.newReaderResource( source ), ResourceType.DRF );\r\n        \r\n        Collection<KnowledgePackage> kpkgs = kbuilder.getKnowledgePackages();\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( kpkgs );        \r\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();\r\n    \t\r\n        TestWorkItemHandler handler = new TestWorkItemHandler();\r\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", handler);\r\n        ProcessInstance processInstance = ksession.startProcess(\"org.drools.actions\");\r\n        assertEquals(ProcessInstance.STATE_ACTIVE, processInstance.getState());\r\n        WorkItem workItem = handler.getWorkItem();\r\n        assertNotNull(workItem);\r\n        assertEquals(\"John Doe\", workItem.getParameter(\"ActorId\"));\r\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\r\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\r\n        \r\n        Map<String, Object> parameters = new HashMap<String, Object>();\r\n        parameters.put(\"UserName\", \"Jane Doe\");\r\n        parameters.put(\"MyObject\", \"SomeString\");\r\n        processInstance = ksession.startProcess(\"org.drools.actions\", parameters);\r\n        assertEquals(ProcessInstance.STATE_ACTIVE, processInstance.getState());\r\n        workItem = handler.getWorkItem();\r\n        assertNotNull(workItem);\r\n        assertEquals(\"Jane Doe\", workItem.getParameter(\"ActorId\"));\r\n        assertEquals(\"SomeString\", workItem.getParameter(\"Attachment\"));\r\n        Map<String, Object> results = new HashMap<String, Object>();\r\n        results.put(\"Result\", \"SomeOtherString\");\r\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), results);\r\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\r\n        VariableScopeInstance variableScope = (VariableScopeInstance)\r\n        \t((org.drools.process.instance.ProcessInstance) processInstance)\r\n        \t\t.getContextInstance(VariableScope.VARIABLE_SCOPE);\r\n        assertEquals(\"SomeOtherString\", variableScope.getVariable(\"MyObject\"));\r\n    }","id":104164,"modified_method":"public void testWorkItem() {\r\n    \tKnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        Reader source = new StringReader(\r\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\r\n            \"<process xmlns=\\\"http://drools.org/drools-5.0/process\\\"\\n\" +\r\n            \"         xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\" +\r\n            \"         xs:schemaLocation=\\\"http://drools.org/drools-5.0/process drools-processes-5.0.xsd\\\"\\n\" +\r\n            \"         type=\\\"RuleFlow\\\" name=\\\"flow\\\" id=\\\"org.drools.actions\\\" package-name=\\\"org.drools\\\" version=\\\"1\\\" >\\n\" +\r\n            \"\\n\" +\r\n            \"  <header>\\n\" +\r\n    \t\t\"    <variables>\\n\" +\r\n    \t\t\"      <variable name=\\\"UserName\\\" >\\n\" +\r\n    \t\t\"        <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n    \t\t\"        <value>John Doe<\/value>\\n\" +\r\n    \t\t\"      <\/variable>\\n\" +\r\n     \t\t\"      <variable name=\\\"Person\\\" >\\n\" +\r\n    \t\t\"        <type name=\\\"org.drools.process.core.datatype.impl.type.ObjectDataType\\\" className=\\\"org.drools.Person\\\" />\\n\" +\r\n    \t\t\"      <\/variable>\\n\" +\r\n    \t\t\"      <variable name=\\\"MyObject\\\" >\\n\" +\r\n    \t\t\"        <type name=\\\"org.drools.process.core.datatype.impl.type.ObjectDataType\\\" className=\\\"java.lang.Object\\\" />\\n\" +\r\n    \t\t\"      <\/variable>\\n\" +\r\n    \t\t\"      <variable name=\\\"Number\\\" >\\n\" +\r\n    \t\t\"        <type name=\\\"org.drools.process.core.datatype.impl.type.IntegerDataType\\\" />\\n\" +\r\n    \t\t\"      <\/variable>\\n\" +\r\n    \t\t\"    <\/variables>\\n\" +\r\n            \"  <\/header>\\n\" +\r\n            \"\\n\" +\r\n            \"  <nodes>\\n\" +\r\n            \"    <start id=\\\"1\\\" name=\\\"Start\\\" />\\n\" +\r\n            \"    <workItem id=\\\"2\\\" name=\\\"HumanTask\\\" >\\n\" +\r\n            \"      <work name=\\\"Human Task\\\" >\\n\" +\r\n            \"        <parameter name=\\\"ActorId\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"          <value>#{UserName}<\/value>\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Content\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"          <value>#{Person.name}<\/value>\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"TaskName\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"          <value>Do something<\/value>\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Priority\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Comment\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.StringDataType\\\" />\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"        <parameter name=\\\"Attachment\\\" >\\n\" +\r\n            \"          <type name=\\\"org.drools.process.core.datatype.impl.type.ObjectDataType\\\" className=\\\"java.lang.Object\\\" />\\n\" +\r\n            \"        <\/parameter>\\n\" +\r\n            \"      <\/work>\\n\" +\r\n            \"      <mapping type=\\\"in\\\" from=\\\"MyObject\\\" to=\\\"Attachment\\\" />\" +\r\n            \"      <mapping type=\\\"in\\\" from=\\\"Person.name\\\" to=\\\"Comment\\\" />\" +\r\n            \"      <mapping type=\\\"out\\\" from=\\\"Result\\\" to=\\\"MyObject\\\" />\" +\r\n            \"      <mapping type=\\\"out\\\" from=\\\"Result.length()\\\" to=\\\"Number\\\" />\" +\r\n            \"    <\/workItem>\\n\" +\r\n            \"    <end id=\\\"3\\\" name=\\\"End\\\" />\\n\" +\r\n            \"  <\/nodes>\\n\" +\r\n            \"\\n\" +\r\n            \"  <connections>\\n\" +\r\n            \"    <connection from=\\\"1\\\" to=\\\"2\\\" />\\n\" +\r\n            \"    <connection from=\\\"2\\\" to=\\\"3\\\" />\\n\" +\r\n            \"  <\/connections>\\n\" +\r\n            \"\\n\" +\r\n            \"<\/process>\");\r\n        kbuilder.add( ResourceFactory.newReaderResource( source ), ResourceType.DRF );\r\n        \r\n        Collection<KnowledgePackage> kpkgs = kbuilder.getKnowledgePackages();\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( kpkgs );        \r\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();\r\n    \t\r\n        TestWorkItemHandler handler = new TestWorkItemHandler();\r\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", handler);\r\n        ProcessInstance processInstance = ksession.startProcess(\"org.drools.actions\");\r\n        assertEquals(ProcessInstance.STATE_ACTIVE, processInstance.getState());\r\n        WorkItem workItem = handler.getWorkItem();\r\n        assertNotNull(workItem);\r\n        assertEquals(\"John Doe\", workItem.getParameter(\"ActorId\"));\r\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\r\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\r\n        \r\n        Map<String, Object> parameters = new HashMap<String, Object>();\r\n        parameters.put(\"UserName\", \"Jane Doe\");\r\n        parameters.put(\"MyObject\", \"SomeString\");\r\n        Person person = new Person();\r\n        person.setName(\"Jane Doe\");\r\n        parameters.put(\"Person\", person);\r\n        processInstance = ksession.startProcess(\"org.drools.actions\", parameters);\r\n        assertEquals(ProcessInstance.STATE_ACTIVE, processInstance.getState());\r\n        workItem = handler.getWorkItem();\r\n        assertNotNull(workItem);\r\n        assertEquals(\"Jane Doe\", workItem.getParameter(\"ActorId\"));\r\n        assertEquals(\"SomeString\", workItem.getParameter(\"Attachment\"));\r\n        assertEquals(\"Jane Doe\", workItem.getParameter(\"Content\"));\r\n        assertEquals(\"Jane Doe\", workItem.getParameter(\"Comment\"));\r\n        Map<String, Object> results = new HashMap<String, Object>();\r\n        results.put(\"Result\", \"SomeOtherString\");\r\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), results);\r\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\r\n        VariableScopeInstance variableScope = (VariableScopeInstance)\r\n        \t((org.drools.process.instance.ProcessInstance) processInstance)\r\n        \t\t.getContextInstance(VariableScope.VARIABLE_SCOPE);\r\n        assertEquals(\"SomeOtherString\", variableScope.getVariable(\"MyObject\"));\r\n        assertEquals(15, variableScope.getVariable(\"Number\"));\r\n    }","commit_id":"ad76f5e90c5891bf42a038e6b41d356e83a3d22f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void internalTrigger(final NodeInstance from, String type) {\r\n    \tsuper.internalTrigger(from, type);\r\n        if (!org.drools.workflow.core.Node.CONNECTION_DEFAULT_TYPE.equals(type)) {\r\n            throw new IllegalArgumentException(\r\n                \"A SubProcess node only accepts default incoming connections!\");\r\n        }\r\n        Map<String, Object> parameters = new HashMap<String, Object>();\r\n        for (Map.Entry<String, String> mapping: getSubProcessNode().getInMappings().entrySet()) {\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n                parameters.put(mapping.getKey(), variableScopeInstance.getVariable(mapping.getValue()));\r\n            } else {\r\n                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                System.err.println(\"when trying to execute SubProcess node \" + getSubProcessNode().getName());\r\n                System.err.println(\"Continuing without setting parameter.\");\r\n            }\r\n        }\r\n        String processId = getSubProcessNode().getProcessId();\r\n        Process process = ((InternalRuleBase) ((ProcessInstance) getProcessInstance())\r\n    \t\t.getWorkingMemory().getRuleBase()).getProcess(processId);\r\n        if (process == null) {\r\n        \tSystem.err.println(\"Could not find process \" + processId);\r\n        \tSystem.err.println(\"Aborting process\");\r\n        \t((ProcessInstance) getProcessInstance()).setState(ProcessInstance.STATE_ABORTED);\r\n        } else {\r\n\t    \tProcessInstance processInstance = ( ProcessInstance )\r\n\t    \t\t((ProcessInstance) getProcessInstance()).getWorkingMemory()\r\n\t    \t\t\t.startProcess(processId, parameters);\r\n\t    \tif (!getSubProcessNode().isWaitForCompletion()\r\n\t    \t        || processInstance.getState() == ProcessInstance.STATE_COMPLETED) {\r\n\t    \t\ttriggerCompleted();\r\n\t    \t} else {\r\n\t    \t\tthis.processInstanceId = processInstance.getId();\r\n\t    \t    addProcessListener();\r\n\t    \t}\r\n        }\r\n    }","id":104165,"modified_method":"public void internalTrigger(final NodeInstance from, String type) {\r\n    \tsuper.internalTrigger(from, type);\r\n        if (!org.drools.workflow.core.Node.CONNECTION_DEFAULT_TYPE.equals(type)) {\r\n            throw new IllegalArgumentException(\r\n                \"A SubProcess node only accepts default incoming connections!\");\r\n        }\r\n        Map<String, Object> parameters = new HashMap<String, Object>();\r\n        for (Map.Entry<String, String> mapping: getSubProcessNode().getInMappings().entrySet()) {\r\n        \tObject parameterValue = null;\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n                parameterValue = variableScopeInstance.getVariable(mapping.getValue());\r\n            } else {\r\n            \ttry {\r\n            \t\tparameterValue = MVEL.eval(mapping.getValue(), new NodeInstanceResolverFactory(this));\r\n            \t} catch (Throwable t) {\r\n            \t\tSystem.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                    System.err.println(\"when trying to execute SubProcess node \" + getSubProcessNode().getName());\r\n                    System.err.println(\"Continuing without setting parameter.\");\r\n            \t}\r\n            }\r\n            if (parameterValue != null) {\r\n            \tparameters.put(mapping.getKey(),parameterValue); \r\n            }\r\n        }\r\n        String processId = getSubProcessNode().getProcessId();\r\n        Process process = ((InternalRuleBase) ((ProcessInstance) getProcessInstance())\r\n    \t\t.getWorkingMemory().getRuleBase()).getProcess(processId);\r\n        if (process == null) {\r\n        \tSystem.err.println(\"Could not find process \" + processId);\r\n        \tSystem.err.println(\"Aborting process\");\r\n        \t((ProcessInstance) getProcessInstance()).setState(ProcessInstance.STATE_ABORTED);\r\n        } else {\r\n\t    \tProcessInstance processInstance = ( ProcessInstance )\r\n\t    \t\t((ProcessInstance) getProcessInstance()).getWorkingMemory()\r\n\t    \t\t\t.startProcess(processId, parameters);\r\n\t    \tif (!getSubProcessNode().isWaitForCompletion()\r\n\t    \t        || processInstance.getState() == ProcessInstance.STATE_COMPLETED) {\r\n\t    \t\ttriggerCompleted();\r\n\t    \t} else {\r\n\t    \t\tthis.processInstanceId = processInstance.getId();\r\n\t    \t    addProcessListener();\r\n\t    \t}\r\n        }\r\n    }","commit_id":"ad76f5e90c5891bf42a038e6b41d356e83a3d22f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void processInstanceCompleted(ProcessInstance processInstance) {\r\n        removeEventListeners();\r\n        VariableScopeInstance subProcessVariableScopeInstance = (VariableScopeInstance)\r\n            processInstance.getContextInstance(VariableScope.VARIABLE_SCOPE);\r\n        for (Map.Entry<String, String> mapping: getSubProcessNode().getOutMappings().entrySet()) {\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n                variableScopeInstance.setVariable(mapping.getValue(), subProcessVariableScopeInstance.getVariable(mapping.getKey()));\r\n            } else {\r\n                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                System.err.println(\"when trying to complete SubProcess node \" + getSubProcessNode().getName());\r\n                System.err.println(\"Continuing without setting variable.\");\r\n            }\r\n        }\r\n        triggerCompleted();\r\n    }","id":104166,"modified_method":"public void processInstanceCompleted(ProcessInstance processInstance) {\r\n        removeEventListeners();\r\n        VariableScopeInstance subProcessVariableScopeInstance = (VariableScopeInstance)\r\n            processInstance.getContextInstance(VariableScope.VARIABLE_SCOPE);\r\n        for (Map.Entry<String, String> mapping: getSubProcessNode().getOutMappings().entrySet()) {\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n            \tObject value = subProcessVariableScopeInstance.getVariable(mapping.getKey());\r\n            \tif (value == null) {\r\n            \t\ttry {\r\n                \t\tvalue = MVEL.eval(mapping.getKey(), new VariableScopeResolverFactory(subProcessVariableScopeInstance));\r\n                \t} catch (Throwable t) {\r\n                \t\t// do nothing\r\n                \t}\r\n            \t}\r\n                variableScopeInstance.setVariable(mapping.getValue(), value);\r\n            } else {\r\n                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                System.err.println(\"when trying to complete SubProcess node \" + getSubProcessNode().getName());\r\n                System.err.println(\"Continuing without setting variable.\");\r\n            }\r\n        }\r\n        triggerCompleted();\r\n    }","commit_id":"ad76f5e90c5891bf42a038e6b41d356e83a3d22f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void triggerCompleted(WorkItem workItem) {\r\n        for (Iterator<Map.Entry<String, String>> iterator = getWorkItemNode().getOutMappings().entrySet().iterator(); iterator.hasNext(); ) {\r\n            Map.Entry<String, String> mapping = iterator.next();\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n                variableScopeInstance.setVariable(mapping.getValue(), workItem.getResult(mapping.getKey()));\r\n            } else {\r\n                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                System.err.println(\"when trying to complete Work Item \" + workItem.getName());\r\n                System.err.println(\"Continuing without setting variable.\");\r\n            }\r\n        }\r\n        if (isInversionOfControl()) {\r\n            WorkingMemory workingMemory = ((ProcessInstance) getProcessInstance()).getWorkingMemory();\r\n            workingMemory.update(workingMemory.getFactHandle(this), this);\r\n        } else {\r\n            triggerCompleted();\r\n        }\r\n    }","id":104167,"modified_method":"public void triggerCompleted(WorkItem workItem) {\r\n        for (Iterator<Map.Entry<String, String>> iterator = getWorkItemNode().getOutMappings().entrySet().iterator(); iterator.hasNext(); ) {\r\n            Map.Entry<String, String> mapping = iterator.next();\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n            \tObject value = workItem.getResult(mapping.getKey());\r\n            \tif (value == null) {\r\n            \t\ttry {\r\n                \t\tvalue = MVEL.eval(mapping.getKey(), new WorkItemResolverFactory(workItem));\r\n                \t} catch (Throwable t) {\r\n                \t\t// do nothing\r\n                \t}\r\n            \t}\r\n                variableScopeInstance.setVariable(mapping.getValue(), value);\r\n            } else {\r\n                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                System.err.println(\"when trying to complete Work Item \" + workItem.getName());\r\n                System.err.println(\"Continuing without setting variable.\");\r\n            }\r\n        }\r\n        if (isInversionOfControl()) {\r\n            WorkingMemory workingMemory = ((ProcessInstance) getProcessInstance()).getWorkingMemory();\r\n            workingMemory.update(workingMemory.getFactHandle(this), this);\r\n        } else {\r\n            triggerCompleted();\r\n        }\r\n    }","commit_id":"ad76f5e90c5891bf42a038e6b41d356e83a3d22f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected WorkItem createWorkItem(WorkItemNode workItemNode) {\r\n        Work work = workItemNode.getWork();\r\n        workItem = new WorkItemImpl();\r\n        ((WorkItem) workItem).setName(work.getName());\r\n        ((WorkItem) workItem).setProcessInstanceId(getProcessInstance().getId());\r\n        ((WorkItem) workItem).setParameters(new HashMap<String, Object>(work.getParameters()));\r\n        for (Iterator<Map.Entry<String, String>> iterator = workItemNode.getInMappings().entrySet().iterator(); iterator.hasNext(); ) {\r\n            Map.Entry<String, String> mapping = iterator.next();\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n            \t((WorkItem) workItem).setParameter(mapping.getKey(), variableScopeInstance.getVariable(mapping.getValue()));\r\n            } else {\r\n                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n                System.err.println(\"when trying to execute Work Item \" + work.getName());\r\n                System.err.println(\"Continuing without setting parameter.\");\r\n            }\r\n        }\r\n        for (Map.Entry<String, Object> entry: workItem.getParameters().entrySet()) {\r\n        \tif (entry.getValue() instanceof String) {\r\n        \t\tString s = (String) entry.getValue();\r\n        \t\tMap<String, String> replacements = new HashMap<String, String>();\r\n        \t\tMatcher matcher = PARAMETER_MATCHER.matcher(s);\r\n                while (matcher.find()) {\r\n                \tString paramName = matcher.group(1);\r\n                \tif (replacements.get(paramName) == null) {\r\n\t\t            \tVariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n\t\t                \tresolveContextInstance(VariableScope.VARIABLE_SCOPE, paramName);\r\n\t\t                if (variableScopeInstance != null) {\r\n\t\t                    Object variableValue = variableScopeInstance.getVariable(paramName);\r\n\t\t                \tString variableValueString = variableValue == null ? \"\" : variableValue.toString(); \r\n\t\t\t                replacements.put(paramName, variableValueString);\r\n\t\t                } else {\r\n\t\t                    System.err.println(\"Could not find variable scope for variable \" + paramName);\r\n\t\t                    System.err.println(\"when trying to replace variable in string for Work Item \" + work.getName());\r\n\t\t                    System.err.println(\"Continuing without setting parameter.\");\r\n\t\t                }\r\n                \t}\r\n                }\r\n                for (Map.Entry<String, String> replacement: replacements.entrySet()) {\r\n                \ts = s.replace(\"#{\" + replacement.getKey() + \"}\", replacement.getValue());\r\n                }\r\n                ((WorkItem) workItem).setParameter(entry.getKey(), s);\r\n        \t}\r\n        }\r\n        return workItem;\r\n    }","id":104168,"modified_method":"protected WorkItem createWorkItem(WorkItemNode workItemNode) {\r\n        Work work = workItemNode.getWork();\r\n        workItem = new WorkItemImpl();\r\n        ((WorkItem) workItem).setName(work.getName());\r\n        ((WorkItem) workItem).setProcessInstanceId(getProcessInstance().getId());\r\n        ((WorkItem) workItem).setParameters(new HashMap<String, Object>(work.getParameters()));\r\n        for (Iterator<Map.Entry<String, String>> iterator = workItemNode.getInMappings().entrySet().iterator(); iterator.hasNext(); ) {\r\n            Map.Entry<String, String> mapping = iterator.next();\r\n            Object parameterValue = null;\r\n            VariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n                resolveContextInstance(VariableScope.VARIABLE_SCOPE, mapping.getValue());\r\n            if (variableScopeInstance != null) {\r\n            \tparameterValue = variableScopeInstance.getVariable(mapping.getValue());\r\n            } else {\r\n            \ttry {\r\n            \t\tparameterValue = MVEL.eval(mapping.getValue(), new NodeInstanceResolverFactory(this));\r\n            \t} catch (Throwable t) {\r\n\t                System.err.println(\"Could not find variable scope for variable \" + mapping.getValue());\r\n\t                System.err.println(\"when trying to execute Work Item \" + work.getName());\r\n\t                System.err.println(\"Continuing without setting parameter.\");\r\n            \t}\r\n            }\r\n            if (parameterValue != null) {\r\n            \t((WorkItem) workItem).setParameter(mapping.getKey(), parameterValue);\r\n            }\r\n        }\r\n        for (Map.Entry<String, Object> entry: workItem.getParameters().entrySet()) {\r\n        \tif (entry.getValue() instanceof String) {\r\n        \t\tString s = (String) entry.getValue();\r\n        \t\tMap<String, String> replacements = new HashMap<String, String>();\r\n        \t\tMatcher matcher = PARAMETER_MATCHER.matcher(s);\r\n                while (matcher.find()) {\r\n                \tString paramName = matcher.group(1);\r\n                \tif (replacements.get(paramName) == null) {\r\n\t\t            \tVariableScopeInstance variableScopeInstance = (VariableScopeInstance)\r\n\t\t                \tresolveContextInstance(VariableScope.VARIABLE_SCOPE, paramName);\r\n\t\t                if (variableScopeInstance != null) {\r\n\t\t                    Object variableValue = variableScopeInstance.getVariable(paramName);\r\n\t\t                \tString variableValueString = variableValue == null ? \"\" : variableValue.toString(); \r\n\t\t\t                replacements.put(paramName, variableValueString);\r\n\t\t                } else {\r\n\t\t                \ttry {\r\n\t\t                \t\tObject variableValue = MVEL.eval(paramName, new NodeInstanceResolverFactory(this));\r\n\t\t\t                \tString variableValueString = variableValue == null ? \"\" : variableValue.toString();\r\n\t\t\t                \treplacements.put(paramName, variableValueString);\r\n\t\t                \t} catch (Throwable t) {\r\n\t\t\t                    System.err.println(\"Could not find variable scope for variable \" + paramName);\r\n\t\t\t                    System.err.println(\"when trying to replace variable in string for Work Item \" + work.getName());\r\n\t\t\t                    System.err.println(\"Continuing without setting parameter.\");\r\n\t\t                \t}\r\n\t\t                }\r\n                \t}\r\n                }\r\n                for (Map.Entry<String, String> replacement: replacements.entrySet()) {\r\n                \ts = s.replace(\"#{\" + replacement.getKey() + \"}\", replacement.getValue());\r\n                }\r\n                ((WorkItem) workItem).setParameter(entry.getKey(), s);\r\n        \t}\r\n        }\r\n        return workItem;\r\n    }","commit_id":"ad76f5e90c5891bf42a038e6b41d356e83a3d22f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static SNode clone (SNode node, SModel targetModel, IScope scope) {\n    SNode result = ModelPersistence.createNodeInstance(node.getClass().getName(), targetModel);\n    assert result != null;\n    result.setId(node.getId());\n    targetModel.addLanguage(node.getLanguage(scope));\n    for (String property : node.getProperties().keySet()) {\n      result.setProperty(property, node.getProperty(property), false);\n    }\n    for (SReference reference : node.getReferences()) {\n      if(reference.isExternal()) {\n        result.addReferent(reference.getRole(), reference.getTargetNode());\n      }\n      else {\n        SReference sReference = SReference.newInstance(reference.getRole(), result, reference.getTargetNodeId(), reference.getExtResolveInfo(), targetModel.getUID(), reference.getResolveInfo());\n        result.addSReference(sReference);\n      }\n    }\n    for (SNode child : node.getChildren()) {\n      result.addChild(node.getRoleOf(child), clone(child, targetModel, scope));\n    }\n    return result;\n  }","id":104169,"modified_method":"private static SNode clone (SNode node, SModel targetModel, IScope scope) {\n    SNode result = ModelPersistence.createNodeInstance(node.getClass().getName(), targetModel);\n    assert result != null;\n    result.setId(node.getId());\n    targetModel.addLanguage(node.getLanguage(scope));\n    for (String property : node.getProperties().keySet()) {\n      result.setProperty(property, node.getProperty(property), false);\n    }\n    for (SReference reference : node.getReferences()) {\n/*\n      if(reference.isExternal()) {\n        try {\n          result.addReferent(reference.getRole(), reference.getTargetNode());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n      else {\n*/\n        SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : targetModel.getUID();\n        SReference sReference = SReference.newInstance(reference.getRole(), result, reference.getTargetNodeId(), reference.getExtResolveInfo(), targetModelUID, reference.getResolveInfo());\n        result.addSReference(sReference);\n//      }\n    }\n    for (SNode child : node.getChildren()) {\n      result.addChild(node.getRoleOf(child), clone(child, targetModel, scope));\n    }\n    return result;\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ITemplateGenerator getGenerator() {\n    return myGenerator;\n  }","id":104170,"modified_method":"public TemplateModelGenerator_New getGenerator() {\n    return myGenerator;\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void createRootNodeFromTemplate(TemplateModelGenerator_New generator, String ruleName, SModel outputModel, SNode templateNode, SNode inputNode) {\n    SNode outputNode = createNodeFromTemplate(generator, ruleName, outputModel, templateNode, inputNode, null, 0);\n    generator.addNewRootNode(outputNode);\n    if(inputNode != null && inputNode.isRoot()) generator.addRootToDelete(inputNode);\n  }","id":104171,"modified_method":"private void createRootNodeFromTemplate(String ruleName, SNode templateNode, SNode inputNode) {\n    List<SNode> outputNodes = createNodeFromTemplate(ruleName, templateNode, inputNode, null, 0);\n    if (outputNodes != null) {\n      for (SNode outputNode : outputNodes) {\n        myGenerator.addNewRootNode(outputNode);\n      }\n    }\n    if(inputNode != null && inputNode.isRoot()) myGenerator.addRootToDelete(inputNode);\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean checkConditionForCreateRootRule(ITemplateGenerator generator, CreateRootRule createRootRule) {\n    CreateRootRule_Condition conditionFunction = createRootRule.getConditionFunction();\n    if (conditionFunction == null) {\n      return true;\n    }\n    String methodName = TemplateFunctionMethodName.createRootRule_Condition(conditionFunction.getNode());\n    Object[] args = new Object[]{\n            generator.getSourceModel(),\n            generator,\n            generator.getScope(),\n            generator.getGeneratorSessionContext()};\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(methodName, args, createRootRule.getModel());\n    } catch (Exception e) {\n      generator.showErrorMessage(null, null, BaseAdapter.fromAdapter(createRootRule), \"couldn't evaluate rule condition\");\n      LOG.error(e);\n      return false;\n    }\n  }","id":104172,"modified_method":"public boolean checkConditionForCreateRootRule(CreateRootRule createRootRule) {\n    CreateRootRule_Condition conditionFunction = createRootRule.getConditionFunction();\n    if (conditionFunction == null) {\n      return true;\n    }\n    String methodName = TemplateFunctionMethodName.createRootRule_Condition(conditionFunction.getNode());\n    Object[] args = new Object[]{\n            myGenerator.getSourceModel(),\n            myGenerator,\n            myGenerator.getScope(),\n            myGenerator.getGeneratorSessionContext()};\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(methodName, args, createRootRule.getModel());\n    } catch (Exception e) {\n      myGenerator.showErrorMessage(null, null, BaseAdapter.fromAdapter(createRootRule), \"couldn't evaluate rule condition\");\n      LOG.error(e);\n      return false;\n    }\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<SNode> createSourceNodeListForWeavingRule(WeavingRule weavingRule, ITemplateGenerator generator) {\n    String sourceQueryAspectId = weavingRule.getSourceQueryAspectId();\n    String methodName = \"templateWeavingRule_SourceQuery_\" + sourceQueryAspectId;\n    Object[] args = new Object[]{generator};\n    List<SNode> sourceNodes = (List<SNode>) QueryMethod.invoke(methodName, args, weavingRule.getModel());\n    return sourceNodes;\n  }","id":104173,"modified_method":"private List<SNode> createSourceNodeListForWeavingRule(WeavingRule weavingRule) {\n    String sourceQueryAspectId = weavingRule.getSourceQueryAspectId();\n    String methodName = \"templateWeavingRule_SourceQuery_\" + sourceQueryAspectId;\n    Object[] args = new Object[]{myGenerator};\n    List<SNode> sourceNodes = (List<SNode>) QueryMethod.invoke(methodName, args, weavingRule.getModel());\n    return sourceNodes;\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void weaveTemplateDeclaration(TemplateModelGenerator_New generator, SModel outputModel, SNode sourceNode, TemplateDeclaration template, SNode contextNode, SNode ruleNode) {\n    if (template == null) {\n      generator.showErrorMessage(sourceNode, BaseAdapter.fromAdapter(template), ruleNode, \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n\n    List<TemplateFragment> templateFragments = getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      generator.showErrorMessage(sourceNode, template.getNode(), ruleNode, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    boolean allFragmentsWhichUseDefaultContextHaveSameParent = true;\n    SNode defaultContext = null;\n    for (TemplateFragment templateFragment : templateFragments) {\n      if (templateFragment.getContextProviderAspectId() == null) { // uses <default context>\n        SNode fragmentContextNode = BaseAdapter.fromAdapter(templateFragment.getParent().getParent());\n        if (defaultContext == null) {\n          defaultContext = fragmentContextNode;\n        } else if (defaultContext != fragmentContextNode) {\n          allFragmentsWhichUseDefaultContextHaveSameParent = false;\n          break;\n        }\n      }\n    }\n    if (!allFragmentsWhichUseDefaultContextHaveSameParent) {\n      for (TemplateFragment templateFragment : templateFragments) {\n        if (templateFragment.getContextProviderAspectId() == null) { // uses <default context>\n          generator.showErrorMessage(null, templateFragment.getNode(), null, \"template fragment uses <default context>: conflicts with other fragments which use <default context>\");\n        }\n      }\n    }\n\n    String ruleMappingName = ruleNode.getName();\n    // for each template fragment create node builder\n    for (TemplateFragment templateFragment : templateFragments) {\n      SNode templateFragmentNode = BaseAdapter.fromAdapter(templateFragment.getParent());\n      String mappingName = templateFragment.getName();\n      if (mappingName == null) {\n        mappingName = ruleMappingName;\n      }\n//      List<INodeBuilder> fragmentNodeBuilders = createNodeBuildersForTemplateNode(sourceNode, templateFragmentNode, mappingName, 0, generator);\n      List<SNode> weavingSourceNodes = TemplateGenUtil.createSourceNodeListForTemplateNode_ForNewGenerator(sourceNode, templateFragmentNode, 0, generator);\n      for (SNode weavingSourceNode : weavingSourceNodes) {\n//        INodeBuilder nodeBuilder = createNodeBuilder(sourceNode, templateNode, mappingName, currentMacroIndex, generator);\n        SNode contextParentNode = getContextNodeForTemplateFragment(templateFragmentNode, contextNode, generator);\n        if(contextParentNode != null) {\n          SNode outputNodeToWeave = createNodeFromTemplate(generator, mappingName, outputModel, templateFragmentNode, weavingSourceNode, contextParentNode, 0);\n          if(outputNodeToWeave != null) {\n            SNode templateParentNode = templateFragmentNode.getParent();\n            contextParentNode.addChild(templateParentNode.getRoleOf(templateFragmentNode), outputNodeToWeave);\n          }\n        }\n        else {\n          generator.showErrorMessage(sourceNode, templateFragment.getNode(), ruleNode, \"couldn't define 'context' for template fragment\");\n        }\n      }\n    }\n  }","id":104174,"modified_method":"private void weaveTemplateDeclaration(SNode sourceNode, TemplateDeclaration template, SNode contextNode, SNode ruleNode) {\n    if (template == null) {\n      myGenerator.showErrorMessage(sourceNode, BaseAdapter.fromAdapter(template), ruleNode, \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n\n    List<TemplateFragment> templateFragments = getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      myGenerator.showErrorMessage(sourceNode, template.getNode(), ruleNode, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    boolean allFragmentsWhichUseDefaultContextHaveSameParent = true;\n    SNode defaultContext = null;\n    for (TemplateFragment templateFragment : templateFragments) {\n      if (templateFragment.getContextProviderAspectId() == null) { // uses <default context>\n        SNode fragmentContextNode = BaseAdapter.fromAdapter(templateFragment.getParent().getParent());\n        if (defaultContext == null) {\n          defaultContext = fragmentContextNode;\n        } else if (defaultContext != fragmentContextNode) {\n          allFragmentsWhichUseDefaultContextHaveSameParent = false;\n          break;\n        }\n      }\n    }\n    if (!allFragmentsWhichUseDefaultContextHaveSameParent) {\n      for (TemplateFragment templateFragment : templateFragments) {\n        if (templateFragment.getContextProviderAspectId() == null) { // uses <default context>\n          myGenerator.showErrorMessage(null, templateFragment.getNode(), null, \"template fragment uses <default context>: conflicts with other fragments which use <default context>\");\n        }\n      }\n    }\n\n    String ruleMappingName = ruleNode.getName();\n    // for each template fragment create node builder\n    for (TemplateFragment templateFragment : templateFragments) {\n      SNode templateFragmentNode = BaseAdapter.fromAdapter(templateFragment.getParent());\n      String mappingName = templateFragment.getName();\n      if (mappingName == null) {\n        mappingName = ruleMappingName;\n      }\n//      List<INodeBuilder> fragmentNodeBuilders = createNodeBuildersForTemplateNode(sourceNode, templateFragmentNode, mappingName, 0, myGenerator);\n      List<SNode> weavingSourceNodes = TemplateGenUtil.createSourceNodeListForTemplateNode_ForNewGenerator(sourceNode, templateFragmentNode, 0, myGenerator);\n      for (SNode weavingSourceNode : weavingSourceNodes) {\n//        INodeBuilder nodeBuilder = createNodeBuilder(sourceNode, templateNode, mappingName, currentMacroIndex, myGenerator);\n        SNode contextParentNode = getContextNodeForTemplateFragment(templateFragmentNode, contextNode);\n        if(contextParentNode != null) {\n          List<SNode> outputNodesToWeave = createNodeFromTemplate(mappingName, templateFragmentNode, weavingSourceNode, contextParentNode, 0);\n          if (outputNodesToWeave != null) {\n            SNode templateParentNode = templateFragmentNode.getParent();\n            for (SNode outputNodeToWeave : outputNodesToWeave) {\n              contextParentNode.addChild(templateParentNode.getRoleOf(templateFragmentNode), outputNodeToWeave);\n            }\n          }\n        }\n        else {\n          myGenerator.showErrorMessage(sourceNode, templateFragment.getNode(), ruleNode, \"couldn't define 'context' for template fragment\");\n        }\n      }\n    }\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void applyRootRule(TemplateModelGenerator_New generator, SModel outputModel, CreateRootRule createRootRule) {\n    if (RuleUtil.checkConditionForCreateRootRule(generator, createRootRule)) {\n      BaseConcept templateNode = createRootRule.getTemplateNode();\n      if (templateNode == null) {\n        generator.showErrorMessage(null, null, BaseAdapter.fromAdapter(createRootRule), \"'create root' rule has no template\");\n      } else {\n        createRootNodeFromTemplate(generator, createRootRule.getName(), outputModel, BaseAdapter.fromAdapter(templateNode), null);\n      }\n    }\n  }","id":104175,"modified_method":"public RuleUtil(RuleManager ruleManager) {\n    myRuleManager = ruleManager;\n    myGenerator = ruleManager.getGenerator();\n    myOutputModel = myGenerator.getSourceModel();\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean checkConditionForBaseMappingRule(ITemplateGenerator generator, SNode inputNode, BaseMappingRule mappingRule) {\n    BaseMappingRule_Condition conditionFunction = mappingRule.getConditionFunction();\n    if (conditionFunction == null) {\n      return true;\n    }\n    String methodName = TemplateFunctionMethodName.baseMappingRule_Condition(conditionFunction.getNode());\n    Object[] args = new Object[]{\n            inputNode,\n            generator.getSourceModel(),\n            generator,\n            generator.getScope(),\n            generator.getGeneratorSessionContext()};\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(methodName, args, mappingRule.getModel());\n    } catch (Exception e) {\n      generator.showErrorMessage(inputNode, null, BaseAdapter.fromAdapter(mappingRule), \"couldn't evaluate rule condition\");\n      LOG.error(e);\n      return false;\n    }\n  }","id":104176,"modified_method":"private boolean checkConditionForBaseMappingRule(SNode inputNode, BaseMappingRule mappingRule) {\n    BaseMappingRule_Condition conditionFunction = mappingRule.getConditionFunction();\n    if (conditionFunction == null) {\n      return true;\n    }\n    String methodName = TemplateFunctionMethodName.baseMappingRule_Condition(conditionFunction.getNode());\n    Object[] args = new Object[]{\n            inputNode,\n            myGenerator.getSourceModel(),\n            myGenerator,\n            myGenerator.getScope(),\n            myGenerator.getGeneratorSessionContext()};\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(methodName, args, mappingRule.getModel());\n    } catch (Exception e) {\n      myGenerator.showErrorMessage(inputNode, null, BaseAdapter.fromAdapter(mappingRule), \"couldn't evaluate rule condition\");\n      LOG.error(e);\n      return false;\n    }\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode getContextNodeForTemplateFragment(SNode templateFragmentNode, SNode ruleContextNode, ITemplateGenerator generator) {\n    TemplateFragment fragment = TemplateFragment_AnnotationLink.getTemplateFragment((BaseConcept) templateFragmentNode.getAdapter());\n    // has custom context builder provider?\n    String aspectId = fragment.getContextProviderAspectId();\n    if (aspectId != null) {\n      String methodName = \"templateFragment_Context_\" + aspectId;\n      Object[] args = new Object[]{templateFragmentNode, new SimpleNodeBuilder(ruleContextNode), generator};\n      INodeBuilder nodeBuilder = (INodeBuilder) QueryMethod.invoke(methodName, args, fragment.getModel());\n      if(nodeBuilder == null) return null;\n      return nodeBuilder.getTargetNode();\n    }\n    // ok, rule context builder by default\n    return ruleContextNode;\n  }","id":104177,"modified_method":"private SNode getContextNodeForTemplateFragment(SNode templateFragmentNode, SNode ruleContextNode) {\n    TemplateFragment fragment = TemplateFragment_AnnotationLink.getTemplateFragment((BaseConcept) templateFragmentNode.getAdapter());\n    // has custom context builder provider?\n    String aspectId = fragment.getContextProviderAspectId();\n    if (aspectId != null) {\n      String methodName = \"templateFragment_Context_\" + aspectId;\n      Object[] args = new Object[]{templateFragmentNode, new SimpleNodeBuilder(ruleContextNode), myGenerator};\n      INodeBuilder nodeBuilder = (INodeBuilder) QueryMethod.invoke(methodName, args, fragment.getModel());\n      if(nodeBuilder == null) return null;\n      return nodeBuilder.getTargetNode();\n    }\n    // ok, rule context builder by default\n    return ruleContextNode;\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected static SNode createNodeFromTemplate(TemplateModelGenerator_New generator, String ruleName, SModel outputModel,\n                                              SNode templateNode, SNode inputNode, SNode outputParentNode,\n                                              int nodeMacrosToSkip) {\n    int i = 0;\n    for (BaseAdapter templateChildNode : templateNode.getAdapter().getChildren()) {\n      if(!(templateChildNode instanceof NodeMacro)) continue;\n      i++;\n      if(i <= nodeMacrosToSkip)continue;\n      if(templateChildNode instanceof LoopMacro) {\n        List<SNode> newInputNodes = TemplateGenUtil.createSourceNodeListForTemplateNode_ForNewGenerator(inputNode, templateNode, nodeMacrosToSkip, generator);\n        for (SNode newInputNode : newInputNodes) {\n          SNode outputChildNode = createNodeFromTemplate(generator, ((LoopMacro)templateChildNode).getMappingId(), outputModel, templateNode, newInputNode, outputParentNode, nodeMacrosToSkip+1);\n          if(outputParentNode != null) {\n            SNode templateParentNode = templateNode.getParent();\n            if(templateParentNode != null) {\n              //todo it seems that we shouldn't delay this change, though...\n              generator.getDelayedChanges().addAddChildChange(outputParentNode, outputChildNode, templateParentNode.getRoleOf(templateNode));\n            }\n          }\n        }\n        return null;\n      }\n    }\n\n    SNode outputNode = ModelPersistence.createNodeInstance(templateNode.getClass().getName(), outputModel);\n    if(outputNode == null) {\n      generator.showErrorMessage(null, templateNode, \"'createNodeFromTemplate' cannot create root node\");\n      return null;\n    }\n    generator.addOutputNodeByTemplateNodeAndInputNode(templateNode, inputNode, outputNode);\n    generator.addOutputNodeByRuleNameAndInputNode(ruleName, inputNode, outputNode);\n    outputModel.addLanguage(templateNode.getLanguage(generator.getScope()));\n    for (String property : templateNode.getProperties().keySet()) {\n      outputNode.setProperty(property, templateNode.getProperty(property), false);\n    }\n\n    SModel templateModel = templateNode.getModel();\n    for (SReference reference : templateNode.getReferences()) {\n      SNode templateReferentNode = reference.getTargetNode();\n      if(templateReferentNode == null) {\n        generator.showErrorMessage(null, templateNode, \"'createNodeFromTemplate' referent node is null in template model\");\n        continue;\n      }\n      if(templateReferentNode.getModel().equals(templateModel)) {\n        generator.addReferenceInfo(new ReferenceInfo_Default(outputNode, reference.getRole(), templateNode, templateReferentNode, inputNode));\n      }\n      else {\n        outputNode.addReferent(reference.getRole(), templateReferentNode);\n      }\n    }\n\n    for (BaseAdapter templateChildNode : templateNode.getAdapter().getChildren()) {\n      if(templateChildNode instanceof NodeMacro) continue;\n      if (templateChildNode instanceof PropertyMacro) {\n        MacroUtil.expandPropertyMacro(generator, (PropertyMacro)templateChildNode, inputNode, templateNode, outputNode);\n      }\n      else if(templateChildNode instanceof ReferenceMacro) {\n        generator.addReferenceInfo(new ReferenceInfo_Macro((ReferenceMacro)templateChildNode, inputNode, templateNode, outputNode));\n      }\n      else {\n        SNode outputChildNode = createNodeFromTemplate(generator, ruleName, outputModel, templateChildNode.getNode(), inputNode, outputNode, 0);\n        if(outputChildNode != null) {\n          outputNode.addChild(templateNode.getRoleOf(templateChildNode.getNode()), outputChildNode);\n        }\n      }\n    }\n    return outputNode;\n  }","id":104178,"modified_method":"protected List<SNode> createNodeFromTemplate(String ruleName,SNode templateNode,\n                                               SNode inputNode, SNode outputParentNode,\n                                               int nodeMacrosToSkip) {\n    int i = 0;\n    List<SNode> outputNodes = new LinkedList<SNode>();\n    for (BaseAdapter templateChildNode : templateNode.getAdapter().getChildren()) {\n      if(!(templateChildNode instanceof NodeMacro)) continue;\n      i++;\n      if(i <= nodeMacrosToSkip)continue;\n      if(templateChildNode instanceof LoopMacro) {\n        List<SNode> newInputNodes = TemplateGenUtil.createSourceNodeListForTemplateNode_ForNewGenerator(inputNode, templateNode, nodeMacrosToSkip, myGenerator);\n        for (SNode newInputNode : newInputNodes) {\n          List<SNode> outputChildNodes = createNodeFromTemplate(((LoopMacro)templateChildNode).getMappingId(), templateNode, newInputNode, outputParentNode, nodeMacrosToSkip+1);\n          if (outputChildNodes != null) {\n            outputNodes.addAll(outputChildNodes);\n          }\n/*\n          if(outputParentNode != null) {\n            SNode templateParentNode = templateNode.getParent();\n            if(templateParentNode != null) {\n              outputParentNode.addChild(templateParentNode.getRoleOf(templateNode), outputChildNode);\n            }\n          }\n*/\n        }\n        return outputNodes;\n      }\n      else if(templateChildNode instanceof CopySrcNodeMacro) {\n        List<SNode> newInputNodes = TemplateGenUtil.createSourceNodeListForTemplateNode_ForNewGenerator(inputNode, templateNode, nodeMacrosToSkip, myGenerator);\n        for (SNode newInputNode : newInputNodes) {\n          String mappingId = ((CopySrcNodeMacro) templateChildNode).getMappingId();\n          List<SNode> newOutputNodes = copyNodeFromInputNode(mappingId, newInputNode, newInputNode);\n          outputNodes.addAll(newOutputNodes);\n        }\n        return outputNodes;\n      }\n\n    }\n\n    SNode outputNode = ModelPersistence.createNodeInstance(templateNode.getClass().getName(), myOutputModel);\n    if(outputNode == null) {\n      myGenerator.showErrorMessage(null, templateNode, \"'createNodeFromTemplate' cannot create output node\");\n      return null;\n    }\n    outputNodes.add(outputNode);\n    myGenerator.addOutputNodeByTemplateNodeAndInputNode(templateNode, inputNode, outputNode);\n    myGenerator.addOutputNodeByRuleNameAndInputNode(ruleName, inputNode, outputNode);\n    myOutputModel.addLanguage(templateNode.getLanguage(myGenerator.getScope()));\n    for (String property : templateNode.getProperties().keySet()) {\n      outputNode.setProperty(property, templateNode.getProperty(property), false);\n    }\n\n    SModel templateModel = templateNode.getModel();\n    for (SReference reference : templateNode.getReferences()) {\n      SNode templateReferentNode = reference.getTargetNode();\n      if(templateReferentNode == null) {\n        myGenerator.showErrorMessage(null, templateNode, \"'createNodeFromTemplate' referent node is null in template model\");\n        continue;\n      }\n      if(templateReferentNode.getModel().equals(templateModel)) {\n        myGenerator.addReferenceInfo(new ReferenceInfo_Default(outputNode, reference.getRole(), templateNode, templateReferentNode, inputNode));\n      }\n      else {\n        outputNode.addReferent(reference.getRole(), templateReferentNode);\n      }\n    }\n\n    for (BaseAdapter templateChildNode : templateNode.getAdapter().getChildren()) {\n      if(templateChildNode instanceof NodeMacro) continue;\n      if (templateChildNode instanceof PropertyMacro) {\n        MacroUtil.expandPropertyMacro(myGenerator, (PropertyMacro)templateChildNode, inputNode, templateNode, outputNode);\n      }\n      else if(templateChildNode instanceof ReferenceMacro) {\n        myGenerator.addReferenceInfo(new ReferenceInfo_Macro((ReferenceMacro)templateChildNode, inputNode, templateNode, outputNode));\n      }\n      else {\n        List<SNode> outputChildNodes = createNodeFromTemplate(ruleName, templateChildNode.getNode(), inputNode, outputNode, 0);\n        if(outputChildNodes != null) {\n          String childRole = templateNode.getRoleOf(templateChildNode.getNode());\n          for (SNode outputChildNode : outputChildNodes) {\n            outputNode.addChild(childRole, outputChildNode);\n          }\n        }\n      }\n    }\n    return outputNodes;\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected static List<SNode> evaluateSourceNodesQuery(SNode sourceNode, SourceSubstituteMacro_SourceNodesQuery query, SNode queryOwner, ITemplateGenerator generator) {\n    String methodName = TemplateFunctionMethodName.sourceSubstituteMacro_SourceNodesQuery(query.getNode());\n    Object[] args = new Object[]{\n            sourceNode,\n            generator.getSourceModel(),\n            generator,\n            generator.getScope(),\n            generator.getGeneratorSessionContext()};\n    try {\n      List<SNode> sourceNodes = (List<SNode>) QueryMethodGenerated.invoke(methodName, args, queryOwner.getModel());\n      return sourceNodes;\n    } catch (Exception e) {\n      generator.showErrorMessage(sourceNode, queryOwner, \"couldn't evaluate query\");\n      LOG.error(e);\n      return new LinkedList<SNode>();\n    }\n  }","id":104179,"modified_method":"protected List<SNode> evaluateSourceNodesQuery(SNode sourceNode, SourceSubstituteMacro_SourceNodesQuery query, SNode queryOwner) {\n    String methodName = TemplateFunctionMethodName.sourceSubstituteMacro_SourceNodesQuery(query.getNode());\n    Object[] args = new Object[]{\n            sourceNode,\n            myGenerator.getSourceModel(),\n            myGenerator,\n            myGenerator.getScope(),\n            myGenerator.getGeneratorSessionContext()};\n    try {\n      List<SNode> sourceNodes = (List<SNode>) QueryMethodGenerated.invoke(methodName, args, queryOwner.getModel());\n      return sourceNodes;\n    } catch (Exception e) {\n      myGenerator.showErrorMessage(sourceNode, queryOwner, \"couldn't evaluate query\");\n      LOG.error(e);\n      return new LinkedList<SNode>();\n    }\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<SNode> createInputNodeListForMappingRule(ITemplateGenerator generator, MappingRule mappingRule) {\n    String sourceQueryAspectId = mappingRule.getSourceQueryAspectId();\n    String methodName = \"templateMappingRule_SourceQuery_\" + sourceQueryAspectId;\n    Object[] args = new Object[]{generator};\n    List<SNode> inputNodes = (List<SNode>) QueryMethod.invoke(methodName, args, mappingRule.getModel());\n    return inputNodes;\n  }","id":104180,"modified_method":"private List<SNode> createInputNodeListForMappingRule(MappingRule mappingRule) {\n    String sourceQueryAspectId = mappingRule.getSourceQueryAspectId();\n    String methodName = \"templateMappingRule_SourceQuery_\" + sourceQueryAspectId;\n    Object[] args = new Object[]{myGenerator};\n    List<SNode> inputNodes = (List<SNode>) QueryMethod.invoke(methodName, args, mappingRule.getModel());\n    return inputNodes;\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode getContextNodeForWeavingingRule(SNode sourceNode, SNode ruleNode, String aspectId, ITemplateGenerator generator) {\n    try {\n      String methodName = \"templateWeavingRule_Context_\" + aspectId;\n      Object[] args = new Object[]{sourceNode, generator};\n      INodeBuilder nodeBuilder = (INodeBuilder) QueryMethod.invoke(methodName, args, ruleNode.getModel());\n      if(nodeBuilder == null) {\n        generator.showErrorMessage(sourceNode, null, ruleNode, \"Query Method returned null\");\n        return null;\n      }\n      return nodeBuilder.getTargetNode();\n    } catch (Throwable t) {\n      generator.showErrorMessage(sourceNode, null, ruleNode, t.getClass().getName());\n      throw new RuntimeException(t);\n    }\n  }","id":104181,"modified_method":"private SNode getContextNodeForWeavingingRule(SNode sourceNode, SNode ruleNode, String aspectId) {\n    try {\n      String methodName = \"templateWeavingRule_Context_\" + aspectId;\n      Object[] args = new Object[]{sourceNode, myGenerator};\n      INodeBuilder nodeBuilder = (INodeBuilder) QueryMethod.invoke(methodName, args, ruleNode.getModel());\n      if(nodeBuilder == null) {\n        myGenerator.showErrorMessage(sourceNode, null, ruleNode, \"Query Method returned null\");\n        return null;\n      }\n      return nodeBuilder.getTargetNode();\n    } catch (Throwable t) {\n      myGenerator.showErrorMessage(sourceNode, null, ruleNode, t.getClass().getName());\n      throw new RuntimeException(t);\n    }\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doPrimaryMapping() {\n    RuleManager ruleManager = new RuleManager(this);\n    for (CreateRootRule createRootRule : ruleManager.getCreateRootRules()) {\n      RuleUtil.applyRootRule(this, myModel, createRootRule);\n    }\n    for (MappingRule mappingRule : ruleManager.getMappingRules()) {\n      RuleUtil.applyMappingRule(this, myModel, mappingRule);\n    }\n    for (Root_MappingRule rootMappingRule : ruleManager.getRoot_MappingRules()) {\n      RuleUtil.applyRoot_MappingRule(this, myModel, rootMappingRule);\n    }\n\n    for (WeavingRule weavingRule : ruleManager.getWeavingRules()) {\n      RuleUtil.applyWeavingRule(this, myModel, weavingRule);\n    }\n    for (Weaving_MappingRule weavingMappingRule : ruleManager.getWeaving_MappingRules()) {\n      RuleUtil.applyWeavingMappingRule(this, myModel, weavingMappingRule);\n    }\n\n   for (SNode rootNode : myRootsToDelete) {\n      myModel.removeRoot(rootNode);\n    }\n    for (SNode rootNode : myModel.getRoots()) {\n      List<ConceptDeclaration> abandonedRootConcepts = ruleManager.getAbandonedRootConcepts();\n      for (ConceptDeclaration abandonedRootConcept : abandonedRootConcepts) {\n        if(rootNode.isInstanceOfConcept(abandonedRootConcept, getScope())){\n          myModel.removeRoot(rootNode);\n        }\n      }\n    }\n\n    for (SNode sourceRootNode : myModel.getRoots()) {\n      ruleManager.getReductionRuleManager().applyReductionRules(sourceRootNode);\n    }\n\n    for (SNode rootNode : myNewRootNodes) {\n      myModel.addRoot(rootNode);\n    }\n\n    myDelayedChanges.doAllChanges();\n\n    for (ReferenceInfo referenceInfo : myReferenceInfos) {\n      referenceInfo.execute(this);\n    }\n  }","id":104182,"modified_method":"public void doPrimaryMapping() {\n    RuleManager ruleManager = new RuleManager(this);\n    RuleUtil ruleUtil = new RuleUtil(ruleManager);\n    ruleManager.getReductionRuleManager().setRuleUtil(ruleUtil);\n    for (CreateRootRule createRootRule : ruleManager.getCreateRootRules()) {\n      ruleUtil.applyRootRule(createRootRule);\n    }\n    for (MappingRule mappingRule : ruleManager.getMappingRules()) {\n      ruleUtil.applyMappingRule(mappingRule);\n    }\n    for (Root_MappingRule rootMappingRule : ruleManager.getRoot_MappingRules()) {\n      ruleUtil.applyRoot_MappingRule(rootMappingRule);\n    }\n\n    for (WeavingRule weavingRule : ruleManager.getWeavingRules()) {\n      ruleUtil.applyWeavingRule(weavingRule);\n    }\n    for (Weaving_MappingRule weavingMappingRule : ruleManager.getWeaving_MappingRules()) {\n      ruleUtil.applyWeavingMappingRule(weavingMappingRule);\n    }\n\n   for (SNode rootNode : myRootsToDelete) {\n      myModel.removeRoot(rootNode);\n    }\n    for (SNode rootNode : myModel.getRoots()) {\n      List<ConceptDeclaration> abandonedRootConcepts = ruleManager.getAbandonedRootConcepts();\n      for (ConceptDeclaration abandonedRootConcept : abandonedRootConcepts) {\n        if(rootNode.isInstanceOfConcept(abandonedRootConcept, getScope())){\n          myModel.removeRoot(rootNode);\n        }\n      }\n    }\n\n    for (SNode sourceRootNode : myModel.getRoots()) {\n      ruleManager.getReductionRuleManager().applyReductionRules(sourceRootNode);\n    }\n\n    for (SNode rootNode : myNewRootNodes) {\n      myModel.addRoot(rootNode);\n    }\n\n    myDelayedChanges.doAllChanges();\n\n    for (ReferenceInfo referenceInfo : myReferenceInfos) {\n      referenceInfo.execute(this);\n    }\n  }","commit_id":"dadc1e92c8abf38d033301979d60c0b5e45c3733","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode cloneInt(SNode node, SModel outputModel, IScope scope, boolean keepOldId) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    if (keepOldId) {\n      result.setId(node.getSNodeId());\n    }\n    result.putProperties(node);\n    for (SReference reference : node.getReferences()) {\n      SReference referenceClone = reference.clone();\n      if(!reference.isExternal()) {\n        referenceClone.setTargetModelUID(outputModel.getUID());\n      }\n      result.addReference(referenceClone);\n\n//      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n//      if (targetModelUID == null) {\n//        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n//      } else {\n//        result.addReference(SReference.create(reference.getRole(),\n//                result,\n//                targetModelUID,\n//                reference.getTargetNodeId(),\n//                reference.getResolveInfo()));\n//      }\n    }\n    for (SNode child : node.getChildren()) {\n      String role = child.getRole_();\n      assert role != null;\n      result.addChild(role, clone(child, outputModel, scope));\n    }\n    return result;\n  }","id":104183,"modified_method":"private static SNode cloneInt(SNode node, SModel outputModel, IScope scope, boolean keepOldId) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    if (keepOldId) {\n      result.setId(node.getSNodeId());\n    }\n    result.putProperties(node);\n    for (SReference reference : node.getReferences()) {\n//      SReference referenceClone = reference.clone();\n//      if(!reference.isExternal()) {\n//        referenceClone.setTargetModelUID(outputModel.getUID());\n//      }\n//      result.addReference(referenceClone);\n\n      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n      if (targetModelUID == null) {\n        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n      } else {\n        result.addReference(SReference.create(reference.getRole(),\n                result,\n                targetModelUID,\n                reference.getTargetNodeId(),\n                reference.getResolveInfo()));\n      }\n    }\n    for (SNode child : node.getChildren()) {\n      String role = child.getRole_();\n      assert role != null;\n      result.addChild(role, clone(child, outputModel, scope));\n    }\n    return result;\n  }","commit_id":"5bad969ccc4087cc8738c258755ed954458b72ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode cloneInt(SNode node, SModel outputModel, IScope scope, boolean keepOldId) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    if (keepOldId) {\n      result.setId(node.getSNodeId());\n    }\n    result.putProperties(node);\n    for (SReference reference : node.getReferences()) {\n      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n      if (targetModelUID == null) {\n        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n      } else {\n        result.addReference(SReference.create(reference.getRole(),\n                result,\n                targetModelUID,\n                reference.getTargetNodeId(),\n                reference.getResolveInfo()));\n      }\n    }\n    for (SNode child : node.getChildren()) {\n      String role = child.getRole_();\n      assert role != null;\n      result.addChild(role, clone(child, outputModel, scope));\n    }\n    return result;\n  }","id":104184,"modified_method":"private static SNode cloneInt(SNode node, SModel outputModel, IScope scope, boolean keepOldId) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    if (keepOldId) {\n      result.setId(node.getSNodeId());\n    }\n    result.putProperties(node);\n    for (SReference reference : node.getReferences()) {\n      SReference referenceClone = reference.clone();\n      if(!reference.isExternal()) {\n        referenceClone.setTargetModelUID(outputModel.getUID());\n      }\n      result.addReference(referenceClone);\n\n//      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n//      if (targetModelUID == null) {\n//        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n//      } else {\n//        result.addReference(SReference.create(reference.getRole(),\n//                result,\n//                targetModelUID,\n//                reference.getTargetNodeId(),\n//                reference.getResolveInfo()));\n//      }\n    }\n    for (SNode child : node.getChildren()) {\n      String role = child.getRole_();\n      assert role != null;\n      result.addChild(role, clone(child, outputModel, scope));\n    }\n    return result;\n  }","commit_id":"9009d458c02c69bb2ab4f6123577966844eeaa2c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void clientConnectionRun(Socket s) {\n        OutputStream out = null;\n\n        /**\n         * The URL after fixup, always starting with http:// or https://\n         */\n        String targetRequest = null;\n\n        // in-net outproxy\n        boolean usingWWWProxy = false;\n        // local outproxy plugin\n        boolean usingInternalOutproxy = false;\n        Outproxy outproxy = null;\n        boolean usingInternalServer = false;\n        String internalPath = null;\n        String internalRawQuery = null;\n        String currentProxy = null;\n        long requestId = __requestId.incrementAndGet();\n        boolean shout = false;\n\n        try {\n            out = s.getOutputStream();\n            InputReader reader = new InputReader(s.getInputStream());\n            String line, method = null, protocol = null, host = null, destination = null;\n            StringBuilder newRequest = new StringBuilder();\n            boolean ahelperPresent = false;\n            boolean ahelperNew = false;\n            String ahelperKey = null;\n            String userAgent = null;\n            String authorization = null;\n            int remotePort = 0;\n            String referer = null;\n            while((line = reader.readLine(method)) != null) {\n                line = line.trim();\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(getPrefix(requestId) + \"Line=[\" + line + \"]\");\n                }\n\n                String lowercaseLine = line.toLowerCase(Locale.US);\n                if(lowercaseLine.startsWith(\"connection: \") ||\n                        lowercaseLine.startsWith(\"keep-alive: \") ||\n                        lowercaseLine.startsWith(\"proxy-connection: \")) {\n                    continue;\n                }\n\n                if(method == null) { // first line (GET /base64/realaddr)\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"First line [\" + line + \"]\");\n                    }\n\n                    String[] params = line.split(\" \", 3);\n                    if(params.length != 3) {\n                        break;\n                    }\n                    String request = params[1];\n\n                    // various obscure fixups\n                    if(request.startsWith(\"/\") && getTunnel().getClientOptions().getProperty(\"i2ptunnel.noproxy\") != null) {\n                        // what is this for ???\n                        request = \"http://i2p\" + request;\n                    } else if(request.startsWith(\"/eepproxy/\")) {\n                        // Deprecated\n                        // /eepproxy/foo.i2p/bar/baz.html\n                        String subRequest = request.substring(\"/eepproxy/\".length());\n                        if(subRequest.indexOf(\"/\") == -1) {\n                            subRequest += \"/\";\n                        }\n                        request = \"http://\" + subRequest;\n                    /****\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://i2p/\")) {\n                    // http://i2p/b64key/bar/baz.html\n                    // we can't do this now by setting the URI host to the b64key, as\n                    // it probably contains '=' and '~' which are illegal,\n                    // and a host may not include escaped octets\n                    // This will get undone below.\n                    String subRequest = request.substring(\"http://i2p/\".length());\n                    if (subRequest.indexOf(\"/\") == -1)\n                    subRequest += \"/\";\n                    \"http://\" + \"b64key/bar/baz.html\"\n                    request = \"http://\" + subRequest;\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://\")) {\n                    // Unsupported\n                    // http://$b64key/...\n                    // This probably used to work, rewrite it so that\n                    // we can create a URI without illegal characters\n                    // This will get undone below.\n                    String  oldPath = request.substring(7);\n                    int slash = oldPath.indexOf(\"/\");\n                    if (slash < 0)\n                    slash = oldPath.length();\n                    if (slash >= 516 && !oldPath.substring(0, slash).contains(\".\"))\n                    request = \"http://i2p/\" + oldPath;\n                     ****/\n                    }\n\n                    method = params[0];\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // this makes things easier later, by spoofing a\n                        // protocol so the URI parser find the host and port\n                        // For in-net outproxy, will be fixed up below\n                        request = \"https://\" + request + '/';\n                    }\n\n                    // Now use the Java URI parser\n                    // This will be the incoming URI but will then get modified\n                    // to be the outgoing URI (with http:// if going to outproxy, otherwise without)\n                    URI requestURI;\n                    try {\n                        requestURI = new URI(request);\n                        if(requestURI.getRawUserInfo() != null || requestURI.getRawFragment() != null) {\n                            // these should never be sent to the proxy in the request line\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing userinfo or fragment [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, null);\n                        }\n                        if(requestURI.getPath() == null || requestURI.getPath().length() <= 0) {\n                            // Add a path\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Adding / path to [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, \"/\");\n                        }\n                    } catch(URISyntaxException use) {\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(getPrefix(requestId) + \"Bad request [\" + request + \"]\", use);\n                        }\n                        if(out != null) {\n                            out.write(getErrorPage(\"baduri\", ERR_BAD_URI));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    }\n\n                    String protocolVersion = params[2];\n\n                    protocol = requestURI.getScheme();\n                    host = requestURI.getHost();\n                    if(protocol == null || host == null) {\n                        _log.warn(\"Null protocol or host: \" + request + ' ' + protocol + ' ' + host);\n                        method = null;\n                        break;\n                    }\n\n                    int port = requestURI.getPort();\n\n                    // Go through the various types of host names, set\n                    // the host and destination variables accordingly,\n                    // and transform the first line.\n                    // For all i2p network hosts, ensure that the host is a\n                    // Base 32 hostname so that we do not reveal our name for it\n                    // in our addressbook (all naming is local),\n                    // and it is removed from the request line.\n\n                    String hostLowerCase = host.toLowerCase(Locale.US);\n                    if(hostLowerCase.equals(LOCAL_SERVER)) {\n                        // so we don't do any naming service lookups\n                        destination = host;\n                        usingInternalServer = true;\n                        internalPath = requestURI.getPath();\n                        internalRawQuery = requestURI.getRawQuery();\n                    } else if(hostLowerCase.equals(\"i2p\")) {\n                        // pull the b64 _dest out of the first path element\n                        String oldPath = requestURI.getPath().substring(1);\n                        int slash = oldPath.indexOf(\"/\");\n                        if(slash < 0) {\n                            slash = oldPath.length();\n                            oldPath += \"/\";\n                        }\n                        String _dest = oldPath.substring(0, slash);\n                        if(slash >= 516 && !_dest.contains(\".\")) {\n                            // possible alternative:\n                            // redirect to b32\n                            destination = _dest;\n                            host = getHostName(destination);\n                            targetRequest = requestURI.toASCIIString();\n                            String newURI = oldPath.substring(slash);\n                            String query = requestURI.getRawQuery();\n                            if(query != null) {\n                                newURI += '?' + query;\n                            }\n                            try {\n                                requestURI = new URI(newURI);\n                            } catch(URISyntaxException use) {\n                                // shouldnt happen\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                        } else {\n                            _log.warn(\"Bad http://i2p/b64dest \" + request);\n                            host = null;\n                            break;\n                        }\n                    } else if(hostLowerCase.endsWith(\".i2p\")) {\n                        // Destination gets the host name\n                        destination = host;\n                        // Host becomes the destination's \"{b32}.b32.i2p\" string, or \"i2p\" on lookup failure\n                        host = getHostName(destination);\n\n                        int rPort = requestURI.getPort();\n                        if (rPort > 0) {\n                            // Save it to put in the I2PSocketOptions,\n                            remotePort = rPort;\n                         /********\n                            // but strip it from the URL\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing port from [\" + request + \"]\");\n                            }\n                            try {\n                                requestURI = changeURI(requestURI, null, -1, null);\n                            } catch(URISyntaxException use) {\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                          ******/\n                        } else if (\"https\".equals(protocol) ||\n                                   method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                            remotePort = 443;\n                        } else {\n                            remotePort = 80;\n                        }\n\n                        String query = requestURI.getRawQuery();\n                        if(query != null) {\n                            boolean ahelperConflict = false;\n\n                            // Try to find an address helper in the query\n                            String[] helperStrings = removeHelper(query);\n                            if(helperStrings != null &&\n                                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                                query = helperStrings[0];\n                                if(query.equals(\"\")) {\n                                    query = null;\n                                }\n                                try {\n                                    requestURI = replaceQuery(requestURI, query);\n                                } catch(URISyntaxException use) {\n                                    // shouldn't happen\n                                    _log.warn(request, use);\n                                    method = null;\n                                    break;\n                                }\n                                ahelperKey = helperStrings[1];\n                                // Key contains data, lets not ignore it\n                                if(ahelperKey.length() > 0) {\n                                    if(ahelperKey.endsWith(\".i2p\")) {\n                                        // allow i2paddresshelper=<b32>.b32.i2p syntax.\n                                        /*\n                                        also i2paddresshelper=name.i2p for aliases\n                                        i.e. on your eepsite put\n                                        <a href=\"?i2paddresshelper=name.i2p\">This is the name I want to be called.<\/a>\n                                         */\n                                        Destination _dest = _context.namingService().lookup(ahelperKey);\n                                        if(_dest == null) {\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Could not find destination for \" + ahelperKey);\n                                            }\n                                            byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                                            out.write(header);\n                                            out.write((\"<p>\" + _(\"This seems to be a bad destination:\") + \" \" + ahelperKey + \" \" + _(\"i2paddresshelper cannot help you with a destination like that!\") + \"<\/p>\").getBytes(\"UTF-8\"));\n                                            writeFooter(out);\n                                            // XXX: should closeSocket(s) be in a finally block?\n                                            closeSocket(s);\n                                            return;\n                                        }\n                                        ahelperKey = _dest.toBase64();\n                                    }\n\n                                    ahelperPresent = true;\n                                    // ahelperKey will be validated later\n                                    if(host == null || \"i2p\".equals(host)) {\n                                        // Host lookup failed - resolvable only with addresshelper\n                                        // Store in local HashMap unless there is conflict\n                                        String old = addressHelpers.putIfAbsent(destination.toLowerCase(Locale.US), ahelperKey);\n                                        ahelperNew = old == null;\n                                        if((!ahelperNew) && !old.equals(ahelperKey)) {\n                                            // Conflict: handle when URL reconstruction done\n                                            ahelperConflict = true;\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                        \"], trusted key [\" + old + \"], specified key [\" + ahelperKey + \"].\");\n                                            }\n                                        }\n                                    } else {\n                                        // If the host is resolvable from database, verify addresshelper key\n                                        // Silently bypass correct keys, otherwise alert\n                                        Destination hostDest = _context.namingService().lookup(destination);\n                                        if(hostDest != null) {\n                                            String destB64 = hostDest.toBase64();\n                                            if(destB64 != null && !destB64.equals(ahelperKey)) {\n                                                // Conflict: handle when URL reconstruction done\n                                                ahelperConflict = true;\n                                                if(_log.shouldLog(Log.WARN)) {\n                                                    _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                            \"], trusted key [\" + destB64 + \"], specified key [\" + ahelperKey + \"].\");\n                                                }\n\n                                            }\n                                        }\n                                    }\n                                } // ahelperKey\n                            } // helperstrings\n\n                            // Did addresshelper key conflict?\n                            if(ahelperConflict) {\n                                if(out != null) {\n                                    // convert ahelperKey to b32\n                                    String alias = getHostName(ahelperKey);\n                                    if(alias.equals(\"i2p\")) {\n                                        // bad ahelperKey\n                                        byte[] header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                                        writeErrorMessage(header, out, targetRequest, false, destination, null);\n                                    } else {\n                                        String trustedURL = requestURI.toASCIIString();\n                                        URI conflictURI;\n                                        try {\n                                            conflictURI = changeURI(requestURI, alias, 0, null);\n                                        } catch(URISyntaxException use) {\n                                            // shouldn't happen\n                                            _log.warn(request, use);\n                                            method = null;\n                                            break;\n                                        }\n                                        String conflictURL = conflictURI.toASCIIString();\n                                        byte[] header = getErrorPage(\"ahelper-conflict\", ERR_AHELPER_CONFLICT);\n                                        out.write(header);\n                                        out.write(_(\"To visit the destination in your host database, click <a href=\\\"{0}\\\">here<\/a>. To visit the conflicting addresshelper destination, click <a href=\\\"{1}\\\">here<\/a>.\", trustedURL, conflictURL).getBytes(\"UTF-8\"));\n                                        out.write((\"<\/p><\/div>\").getBytes());\n                                        writeFooter(out);\n                                    }\n                                }\n                                s.close();\n                                return;\n                            }\n                        }  // end query processing\n\n                        String addressHelper = addressHelpers.get(destination);\n                        if(addressHelper != null) {\n                            host = getHostName(addressHelper);\n                        }\n\n                        // now strip everything but path and query from URI\n                        targetRequest = requestURI.toASCIIString();\n                        String newURI = requestURI.getRawPath();\n                        if(query != null) {\n                            newURI += '?' + query;\n                        }\n                        try {\n                            requestURI = new URI(newURI);\n                        } catch(URISyntaxException use) {\n                            // shouldnt happen\n                            _log.warn(request, use);\n                            method = null;\n                            break;\n                        }\n\n                    // end of (host endsWith(\".i2p\"))\n\n                    } else if(hostLowerCase.equals(\"localhost\") || host.equals(\"127.0.0.1\") ||\n                            host.startsWith(\"192.168.\") || host.equals(\"[::1]\")) {\n                        // if somebody is trying to get to 192.168.example.com, oh well\n                        if(out != null) {\n                            out.write(getErrorPage(\"localhost\", ERR_LOCALHOST));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    } else if(host.contains(\".\") || host.startsWith(\"[\")) {\n                        if (Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USE_OUTPROXY_PLUGIN, \"true\"))) {\n                            ClientAppManager mgr = _context.clientAppManager();\n                            if (mgr != null) {\n                                ClientApp op = mgr.getRegisteredApp(Outproxy.NAME);\n                                if (op != null) {\n                                    outproxy = (Outproxy) op;\n                                    int rPort = requestURI.getPort();\n                                    if (rPort > 0)\n                                        remotePort = rPort;\n                                    else if (\"https\".equals(protocol) ||\n                                             method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                        remotePort = 443;\n                                    else\n                                        remotePort = 80;\n                                    usingInternalOutproxy = true;\n                                    targetRequest = requestURI.toASCIIString();\n                                    if(_log.shouldLog(Log.DEBUG))\n                                        _log.debug(getPrefix(requestId) + \" [\" + host + \"]: outproxy!\");\n                                }\n                            }\n                        }\n                        if (!usingInternalOutproxy) {\n                            if(port >= 0) {\n                                host = host + ':' + port;\n                            }\n                            // The request must be forwarded to a WWW proxy\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"Before selecting outproxy for \" + host);\n                            }\n                            if (\"https\".equals(protocol) ||\n                                method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                currentProxy = selectSSLProxy();\n                            else\n                                currentProxy = selectProxy();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"After selecting outproxy for \" + host + \": \" + currentProxy);\n                            }\n                            if(currentProxy == null) {\n                                if(_log.shouldLog(Log.WARN)) {\n                                    _log.warn(getPrefix(requestId) + \"Host wants to be outproxied, but we dont have any!\");\n                                }\n                                l.log(\"No outproxy found for the request.\");\n                                if(out != null) {\n                                    out.write(getErrorPage(\"noproxy\", _ERR_NO_OUTPROXY));\n                                    writeFooter(out);\n                                }\n                                s.close();\n                                return;\n                            }\n                            destination = currentProxy;\n                            usingWWWProxy = true;\n                            targetRequest = requestURI.toASCIIString();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(getPrefix(requestId) + \" [\" + host + \"]: wwwProxy!\");\n                            }\n                        }\n                    } else {\n                        // what is left for here? a hostname with no dots, and != \"i2p\"\n                        // and not a destination ???\n                        // Perhaps something in privatehosts.txt ...\n                        // Rather than look it up, just bail out.\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(\"NODOTS, NOI2P: \" + request);\n                        }\n                        if(out != null) {\n                            out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                            writeFooter(out);\n                        }\n                        s.close();\n                        return;\n                    }   // end host name processing\n\n                    boolean isValid = usingInternalOutproxy || usingWWWProxy ||\n                                      usingInternalServer || isSupportedAddress(host, protocol);\n                    if(!isValid) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"notValid(\" + host + \")\");\n                        }\n                        method = null;\n                        destination = null;\n                        break;\n                    }\n\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // fix up the change to requestURI above to get back to the original host:port\n                        line = method + ' ' + requestURI.getHost() + ':' + requestURI.getPort() + ' ' + protocolVersion;\n                    } else {\n                        line = method + ' ' + requestURI.toASCIIString() + ' ' + protocolVersion;\n                    }\n\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"NEWREQ: \\\"\" + line + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"HOST  : \\\"\" + host + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"DEST  : \\\"\" + destination + \"\\\"\");\n                    }\n\n                // end first line processing\n\n                } else {\n                    if(lowercaseLine.startsWith(\"host: \") && !usingWWWProxy && !usingInternalOutproxy) {\n                        // Note that we only pass the original Host: line through to the outproxy\n                        // But we don't create a Host: line if it wasn't sent to us\n                        line = \"Host: \" + host;\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"Setting host = \" + host);\n                        }\n                    } else if(lowercaseLine.startsWith(\"user-agent: \")) {\n                        // save for deciding whether to offer address book form\n                        userAgent = lowercaseLine.substring(12);\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            line = null;\n                            continue;\n                        }\n                    } else if(lowercaseLine.startsWith(\"accept\")) {\n                        // strip the accept-blah headers, as they vary dramatically from\n                        // browser to browser\n                        line = null;\n                        continue;\n                    } else if (lowercaseLine.startsWith(\"referer: \")) {\n                        // save for address helper form below\n                        referer = line.substring(9);\n                        if (!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_REFERER))) {\n                            // Shouldn't we be more specific, like accepting in-site referers ?\n                            //line = \"Referer: i2p\";\n                            line = null;\n                            continue; // completely strip the line\n                        }\n                    } else if(lowercaseLine.startsWith(\"via: \") &&\n                            !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_VIA))) {\n                        //line = \"Via: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"from: \")) {\n                        //line = \"From: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"authorization: ntlm \")) {\n                        // Block Windows NTLM after 401\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"proxy-authorization: \")) {\n                        // This should be for us. It is a\n                        // hop-by-hop header, and we definitely want to block Windows NTLM after a far-end 407.\n                        // Response to far-end shouldn't happen, as we\n                        // strip Proxy-Authenticate from the response in HTTPResponseOutputStream\n                        authorization = line.substring(21);  // \"proxy-authorization: \".length()\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"icy\")) {\n                        // icecast/shoutcast, We need to leave the user-agent alone.\n                        shout = true;\n                    }\n                }\n\n                if(line.length() == 0) {\n                    // No more headers, add our own and break out of the loop\n                    String ok = getTunnel().getClientOptions().getProperty(\"i2ptunnel.gzip\");\n                    boolean gzip = DEFAULT_GZIP;\n                    if(ok != null) {\n                        gzip = Boolean.parseBoolean(ok);\n                    }\n                    if(gzip && !usingInternalServer &&\n                       !method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // according to rfc2616 s14.3, this *should* force identity, even if\n                        // an explicit q=0 for gzip doesn't.  tested against orion.i2p, and it\n                        // seems to work.\n                        newRequest.append(\"Accept-Encoding: \\r\\n\");\n                        if (!usingInternalOutproxy)\n                            newRequest.append(\"X-Accept-Encoding: x-i2p-gzip;q=1.0, identity;q=0.5, deflate;q=0, gzip;q=0, *;q=0\\r\\n\");\n                    }\n                    if(!shout && !method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            // let's not advertise to external sites that we are from I2P\n                            if(usingWWWProxy || usingInternalOutproxy) {\n                                newRequest.append(\"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6\\r\\n\");\n                            } else {\n                                newRequest.append(\"User-Agent: MYOB/6.66 (AN/ON)\\r\\n\");\n                            }\n                        }\n                    }\n                    // Add Proxy-Authentication header for next hop (outproxy)\n                    if(usingWWWProxy && Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_AUTH))) {\n                        // specific for this proxy\n                        String user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER_PREFIX + currentProxy);\n                        String pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW_PREFIX + currentProxy);\n                        if(user == null || pw == null) {\n                            // if not, look at default user and pw\n                            user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER);\n                            pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW);\n                        }\n                        if(user != null && pw != null) {\n                            newRequest.append(\"Proxy-Authorization: Basic \").append(Base64.encode((user + ':' + pw).getBytes(), true)) // true = use standard alphabet\n                                    .append(\"\\r\\n\");\n                        }\n                    }\n                    newRequest.append(\"Connection: close\\r\\n\\r\\n\");\n                    break;\n                } else {\n                    newRequest.append(line).append(\"\\r\\n\"); // HTTP spec\n                }\n            } // end header processing\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"NewRequest header: [\" + newRequest.toString() + \"]\");\n            }\n\n            if(method == null || (destination == null && !usingInternalOutproxy)) {\n                //l.log(\"No HTTP method found in the request.\");\n                if(out != null) {\n                    if(protocol != null && \"http\".equals(protocol.toLowerCase(Locale.US))) {\n                        out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                    } else {\n                        out.write(getErrorPage(\"protocol\", ERR_BAD_PROTOCOL));\n                    }\n                    writeFooter(out);\n                }\n                s.close();\n                return;\n            }\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"Destination: \" + destination);\n            }\n\n            // Authorization\n            AuthResult result = authorize(s, requestId, method, authorization);\n            if (result != AuthResult.AUTH_GOOD) {\n                if(_log.shouldLog(Log.WARN)) {\n                    if(authorization != null) {\n                        _log.warn(getPrefix(requestId) + \"Auth failed, sending 407 again\");\n                    } else {\n                        _log.warn(getPrefix(requestId) + \"Auth required, sending 407\");\n                    }\n                }\n                out.write(getAuthError(result == AuthResult.AUTH_STALE).getBytes());\n                writeFooter(out);\n                s.close();\n                return;\n            }\n\n            // Serve local proxy files (images, css linked from error pages)\n            // Ignore all the headers\n            if(usingInternalServer) {\n                // disable the add form if address helper is disabled\n                if(internalPath.equals(\"/add\") &&\n                        Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                    out.write(ERR_HELPER_DISABLED);\n                } else {\n                    LocalHTTPServer.serveLocalFile(out, method, internalPath, internalRawQuery, _proxyNonce);\n                }\n                s.close();\n                return;\n            }\n\n            // no destination, going to outproxy plugin\n            if (usingInternalOutproxy) {\n                Socket outSocket = outproxy.connect(host, remotePort);\n                Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n                byte[] data;\n                byte[] response;\n                if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                } else {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                }\n                new I2PTunnelOutproxyRunner(s, outSocket, sockLock, data, response, onTimeout);\n                return;\n            }\n\n            // LOOKUP\n            // If the host is \"i2p\", the getHostName() lookup failed, don't try to\n            // look it up again as the naming service does not do negative caching\n            // so it will be slow.\n            Destination clientDest = null;\n            String addressHelper = addressHelpers.get(destination.toLowerCase(Locale.US));\n            if(addressHelper != null) {\n                clientDest = _context.namingService().lookup(addressHelper);\n                if(clientDest == null) {\n                    // remove bad entries\n                    addressHelpers.remove(destination.toLowerCase(Locale.US));\n                    if(_log.shouldLog(Log.WARN)) {\n                        _log.warn(getPrefix(requestId) + \"Could not find destination for \" + addressHelper);\n                    }\n                    byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                    writeErrorMessage(header, out, targetRequest, false, destination, null);\n                    s.close();\n                    return;\n                }\n            } else if(\"i2p\".equals(host)) {\n                clientDest = null;\n            } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                // use existing session to look up for efficiency\n                verifySocketManager();\n                I2PSession sess = sockMgr.getSession();\n                if(!sess.isClosed()) {\n                    byte[] hData = Base32.decode(destination.substring(0, 52));\n                    if(hData != null) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(\"lookup in-session \" + destination);\n                        }\n                        Hash hash = Hash.create(hData);\n                        clientDest = sess.lookupDest(hash, 20 * 1000);\n                    }\n                } else {\n                    clientDest = _context.namingService().lookup(destination);\n                }\n            } else {\n                clientDest = _context.namingService().lookup(destination);\n            }\n\n            if(clientDest == null) {\n                //l.log(\"Could not resolve \" + destination + \".\");\n                if(_log.shouldLog(Log.WARN)) {\n                    _log.warn(\"Unable to resolve \" + destination + \" (proxy? \" + usingWWWProxy + \", request: \" + targetRequest);\n                }\n                byte[] header;\n                String jumpServers = null;\n                if(usingWWWProxy) {\n                    header = getErrorPage(\"dnfp\", ERR_DESTINATION_UNKNOWN);\n                } else if(ahelperPresent) {\n                    header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                    header = getErrorPage(\"dnf\", ERR_DESTINATION_UNKNOWN);\n                } else {\n                    header = getErrorPage(\"dnfh\", ERR_DESTINATION_UNKNOWN);\n                    jumpServers = getTunnel().getClientOptions().getProperty(PROP_JUMP_SERVERS);\n                    if(jumpServers == null) {\n                        jumpServers = DEFAULT_JUMP_SERVERS;\n                    }\n                }\n                writeErrorMessage(header, out, targetRequest, usingWWWProxy, destination, jumpServers);\n                s.close();\n                return;\n            }\n\n            // Address helper response form\n            // This will only load once - the second time it won't be \"new\"\n            // Don't do this for eepget, which uses a user-agent of \"Wget\"\n            if(ahelperNew && \"GET\".equals(method) &&\n                    (userAgent == null || !userAgent.startsWith(\"Wget\")) &&\n                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                writeHelperSaveForm(out, destination, ahelperKey, targetRequest, referer);\n                s.close();\n                return;\n            }\n\n            // Redirect to non-addresshelper URL to not clog the browser address bar\n            // and not pass the parameter to the eepsite.\n            // This also prevents the not-found error page from looking bad\n            // Syndie can't handle a redirect of a POST\n            if(ahelperPresent && !\"POST\".equals(method)) {\n                String uri = targetRequest;\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(\"Auto redirecting to \" + uri);\n                }\n                out.write((\"HTTP/1.1 301 Address Helper Accepted\\r\\n\" +\n                        \"Location: \" + uri + \"\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                s.close();\n                return;\n            }\n\n            Properties opts = new Properties();\n            //opts.setProperty(\"i2p.streaming.inactivityTimeout\", \"\"+120*1000);\n            // 1 == disconnect.  see ConnectionOptions in the new streaming lib, which i\n            // dont want to hard link to here\n            //opts.setProperty(\"i2p.streaming.inactivityTimeoutAction\", \"\"+1);\n            I2PSocketOptions sktOpts = getDefaultOptions(opts);\n            if (remotePort > 0)\n                sktOpts.setPort(remotePort);\n            I2PSocket i2ps = createI2PSocket(clientDest, sktOpts);\n            Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n            if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                byte[] data;\n                byte[] response;\n                if (usingWWWProxy) {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                } else {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                }\n                new I2PTunnelRunner(s, i2ps, sockLock, data, response, mySockets, onTimeout);\n            } else {\n                byte[] data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                new I2PTunnelHTTPClientRunner(s, i2ps, sockLock, data, mySockets, onTimeout);\n            }\n        } catch (SocketException ex) {\n            if (_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(IOException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(I2PException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(\"getPrefix(requestId) + Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(OutOfMemoryError oom) {\n            IOException ex = new IOException(\"OOM\");\n            _log.error(\"getPrefix(requestId) + Error trying to connect\", oom);\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        }\n    }","id":104185,"modified_method":"protected void clientConnectionRun(Socket s) {\n        OutputStream out = null;\n\n        /**\n         * The URL after fixup, always starting with http:// or https://\n         */\n        String targetRequest = null;\n\n        // in-net outproxy\n        boolean usingWWWProxy = false;\n        // local outproxy plugin\n        boolean usingInternalOutproxy = false;\n        Outproxy outproxy = null;\n        boolean usingInternalServer = false;\n        String internalPath = null;\n        String internalRawQuery = null;\n        String currentProxy = null;\n        long requestId = __requestId.incrementAndGet();\n        boolean shout = false;\n\n        try {\n            out = s.getOutputStream();\n            InputReader reader = new InputReader(s.getInputStream());\n            String line, method = null, protocol = null, host = null, destination = null;\n            StringBuilder newRequest = new StringBuilder();\n            boolean ahelperPresent = false;\n            boolean ahelperNew = false;\n            String ahelperKey = null;\n            String userAgent = null;\n            String authorization = null;\n            int remotePort = 0;\n            String referer = null;\n            while((line = reader.readLine(method)) != null) {\n                line = line.trim();\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(getPrefix(requestId) + \"Line=[\" + line + \"]\");\n                }\n\n                String lowercaseLine = line.toLowerCase(Locale.US);\n                if(lowercaseLine.startsWith(\"connection: \") ||\n                        lowercaseLine.startsWith(\"keep-alive: \") ||\n                        lowercaseLine.startsWith(\"proxy-connection: \")) {\n                    continue;\n                }\n\n                if(method == null) { // first line (GET /base64/realaddr)\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"First line [\" + line + \"]\");\n                    }\n\n                    String[] params = line.split(\" \", 3);\n                    if(params.length != 3) {\n                        break;\n                    }\n                    String request = params[1];\n\n                    // various obscure fixups\n                    if(request.startsWith(\"/\") && getTunnel().getClientOptions().getProperty(\"i2ptunnel.noproxy\") != null) {\n                        // what is this for ???\n                        request = \"http://i2p\" + request;\n                    } else if(request.startsWith(\"/eepproxy/\")) {\n                        // Deprecated\n                        // /eepproxy/foo.i2p/bar/baz.html\n                        String subRequest = request.substring(\"/eepproxy/\".length());\n                        if(subRequest.indexOf(\"/\") == -1) {\n                            subRequest += \"/\";\n                        }\n                        request = \"http://\" + subRequest;\n                    /****\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://i2p/\")) {\n                    // http://i2p/b64key/bar/baz.html\n                    // we can't do this now by setting the URI host to the b64key, as\n                    // it probably contains '=' and '~' which are illegal,\n                    // and a host may not include escaped octets\n                    // This will get undone below.\n                    String subRequest = request.substring(\"http://i2p/\".length());\n                    if (subRequest.indexOf(\"/\") == -1)\n                    subRequest += \"/\";\n                    \"http://\" + \"b64key/bar/baz.html\"\n                    request = \"http://\" + subRequest;\n                    } else if (request.toLowerCase(Locale.US).startsWith(\"http://\")) {\n                    // Unsupported\n                    // http://$b64key/...\n                    // This probably used to work, rewrite it so that\n                    // we can create a URI without illegal characters\n                    // This will get undone below.\n                    String  oldPath = request.substring(7);\n                    int slash = oldPath.indexOf(\"/\");\n                    if (slash < 0)\n                    slash = oldPath.length();\n                    if (slash >= 516 && !oldPath.substring(0, slash).contains(\".\"))\n                    request = \"http://i2p/\" + oldPath;\n                     ****/\n                    }\n\n                    method = params[0];\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // this makes things easier later, by spoofing a\n                        // protocol so the URI parser find the host and port\n                        // For in-net outproxy, will be fixed up below\n                        request = \"https://\" + request + '/';\n                    }\n\n                    // Now use the Java URI parser\n                    // This will be the incoming URI but will then get modified\n                    // to be the outgoing URI (with http:// if going to outproxy, otherwise without)\n                    URI requestURI;\n                    try {\n                        requestURI = new URI(request);\n                        if(requestURI.getRawUserInfo() != null || requestURI.getRawFragment() != null) {\n                            // these should never be sent to the proxy in the request line\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing userinfo or fragment [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, null);\n                        }\n                        if(requestURI.getPath() == null || requestURI.getPath().length() <= 0) {\n                            // Add a path\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Adding / path to [\" + request + \"]\");\n                            }\n                            requestURI = changeURI(requestURI, null, 0, \"/\");\n                        }\n                    } catch(URISyntaxException use) {\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(getPrefix(requestId) + \"Bad request [\" + request + \"]\", use);\n                        }\n                        out.write(getErrorPage(\"baduri\", ERR_BAD_URI));\n                        writeFooter(out);\n                        reader.drain();\n                        s.close();\n                        return;\n                    }\n\n                    String protocolVersion = params[2];\n\n                    protocol = requestURI.getScheme();\n                    host = requestURI.getHost();\n                    if(protocol == null || host == null) {\n                        _log.warn(\"Null protocol or host: \" + request + ' ' + protocol + ' ' + host);\n                        method = null;\n                        break;\n                    }\n\n                    int port = requestURI.getPort();\n\n                    // Go through the various types of host names, set\n                    // the host and destination variables accordingly,\n                    // and transform the first line.\n                    // For all i2p network hosts, ensure that the host is a\n                    // Base 32 hostname so that we do not reveal our name for it\n                    // in our addressbook (all naming is local),\n                    // and it is removed from the request line.\n\n                    String hostLowerCase = host.toLowerCase(Locale.US);\n                    if(hostLowerCase.equals(LOCAL_SERVER)) {\n                        // so we don't do any naming service lookups\n                        destination = host;\n                        usingInternalServer = true;\n                        internalPath = requestURI.getPath();\n                        internalRawQuery = requestURI.getRawQuery();\n                    } else if(hostLowerCase.equals(\"i2p\")) {\n                        // pull the b64 _dest out of the first path element\n                        String oldPath = requestURI.getPath().substring(1);\n                        int slash = oldPath.indexOf(\"/\");\n                        if(slash < 0) {\n                            slash = oldPath.length();\n                            oldPath += \"/\";\n                        }\n                        String _dest = oldPath.substring(0, slash);\n                        if(slash >= 516 && !_dest.contains(\".\")) {\n                            // possible alternative:\n                            // redirect to b32\n                            destination = _dest;\n                            host = getHostName(destination);\n                            targetRequest = requestURI.toASCIIString();\n                            String newURI = oldPath.substring(slash);\n                            String query = requestURI.getRawQuery();\n                            if(query != null) {\n                                newURI += '?' + query;\n                            }\n                            try {\n                                requestURI = new URI(newURI);\n                            } catch(URISyntaxException use) {\n                                // shouldnt happen\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                        } else {\n                            _log.warn(\"Bad http://i2p/b64dest \" + request);\n                            host = null;\n                            break;\n                        }\n                    } else if(hostLowerCase.endsWith(\".i2p\")) {\n                        // Destination gets the host name\n                        destination = host;\n                        // Host becomes the destination's \"{b32}.b32.i2p\" string, or \"i2p\" on lookup failure\n                        host = getHostName(destination);\n\n                        int rPort = requestURI.getPort();\n                        if (rPort > 0) {\n                            // Save it to put in the I2PSocketOptions,\n                            remotePort = rPort;\n                         /********\n                            // but strip it from the URL\n                            if(_log.shouldLog(Log.WARN)) {\n                                _log.warn(getPrefix(requestId) + \"Removing port from [\" + request + \"]\");\n                            }\n                            try {\n                                requestURI = changeURI(requestURI, null, -1, null);\n                            } catch(URISyntaxException use) {\n                                _log.warn(request, use);\n                                method = null;\n                                break;\n                            }\n                          ******/\n                        } else if (\"https\".equals(protocol) ||\n                                   method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                            remotePort = 443;\n                        } else {\n                            remotePort = 80;\n                        }\n\n                        String query = requestURI.getRawQuery();\n                        if(query != null) {\n                            boolean ahelperConflict = false;\n\n                            // Try to find an address helper in the query\n                            String[] helperStrings = removeHelper(query);\n                            if(helperStrings != null &&\n                                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                                query = helperStrings[0];\n                                if(query.equals(\"\")) {\n                                    query = null;\n                                }\n                                try {\n                                    requestURI = replaceQuery(requestURI, query);\n                                } catch(URISyntaxException use) {\n                                    // shouldn't happen\n                                    _log.warn(request, use);\n                                    method = null;\n                                    break;\n                                }\n                                ahelperKey = helperStrings[1];\n                                // Key contains data, lets not ignore it\n                                if(ahelperKey.length() > 0) {\n                                    if(ahelperKey.endsWith(\".i2p\")) {\n                                        // allow i2paddresshelper=<b32>.b32.i2p syntax.\n                                        /*\n                                        also i2paddresshelper=name.i2p for aliases\n                                        i.e. on your eepsite put\n                                        <a href=\"?i2paddresshelper=name.i2p\">This is the name I want to be called.<\/a>\n                                         */\n                                        Destination _dest = _context.namingService().lookup(ahelperKey);\n                                        if(_dest == null) {\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Could not find destination for \" + ahelperKey);\n                                            }\n                                            byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                                            out.write(header);\n                                            out.write((\"<p>\" + _(\"This seems to be a bad destination:\") + \" \" + ahelperKey + \" \" + _(\"i2paddresshelper cannot help you with a destination like that!\") + \"<\/p>\").getBytes(\"UTF-8\"));\n                                            writeFooter(out);\n                                            // XXX: should closeSocket(s) be in a finally block?\n                                            closeSocket(s);\n                                            return;\n                                        }\n                                        ahelperKey = _dest.toBase64();\n                                    }\n\n                                    ahelperPresent = true;\n                                    // ahelperKey will be validated later\n                                    if(host == null || \"i2p\".equals(host)) {\n                                        // Host lookup failed - resolvable only with addresshelper\n                                        // Store in local HashMap unless there is conflict\n                                        String old = addressHelpers.putIfAbsent(destination.toLowerCase(Locale.US), ahelperKey);\n                                        ahelperNew = old == null;\n                                        if((!ahelperNew) && !old.equals(ahelperKey)) {\n                                            // Conflict: handle when URL reconstruction done\n                                            ahelperConflict = true;\n                                            if(_log.shouldLog(Log.WARN)) {\n                                                _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                        \"], trusted key [\" + old + \"], specified key [\" + ahelperKey + \"].\");\n                                            }\n                                        }\n                                    } else {\n                                        // If the host is resolvable from database, verify addresshelper key\n                                        // Silently bypass correct keys, otherwise alert\n                                        Destination hostDest = _context.namingService().lookup(destination);\n                                        if(hostDest != null) {\n                                            String destB64 = hostDest.toBase64();\n                                            if(destB64 != null && !destB64.equals(ahelperKey)) {\n                                                // Conflict: handle when URL reconstruction done\n                                                ahelperConflict = true;\n                                                if(_log.shouldLog(Log.WARN)) {\n                                                    _log.warn(getPrefix(requestId) + \"Addresshelper key conflict for site [\" + destination +\n                                                            \"], trusted key [\" + destB64 + \"], specified key [\" + ahelperKey + \"].\");\n                                                }\n\n                                            }\n                                        }\n                                    }\n                                } // ahelperKey\n                            } // helperstrings\n\n                            // Did addresshelper key conflict?\n                            if(ahelperConflict) {\n                                    // convert ahelperKey to b32\n                                    String alias = getHostName(ahelperKey);\n                                    if(alias.equals(\"i2p\")) {\n                                        // bad ahelperKey\n                                        byte[] header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                                        writeErrorMessage(header, out, targetRequest, false, destination, null);\n                                    } else {\n                                        String trustedURL = requestURI.toASCIIString();\n                                        URI conflictURI;\n                                        try {\n                                            conflictURI = changeURI(requestURI, alias, 0, null);\n                                        } catch(URISyntaxException use) {\n                                            // shouldn't happen\n                                            _log.warn(request, use);\n                                            method = null;\n                                            break;\n                                        }\n                                        String conflictURL = conflictURI.toASCIIString();\n                                        byte[] header = getErrorPage(\"ahelper-conflict\", ERR_AHELPER_CONFLICT);\n                                        out.write(header);\n                                        out.write(_(\"To visit the destination in your host database, click <a href=\\\"{0}\\\">here<\/a>. To visit the conflicting addresshelper destination, click <a href=\\\"{1}\\\">here<\/a>.\", trustedURL, conflictURL).getBytes(\"UTF-8\"));\n                                        out.write((\"<\/p><\/div>\").getBytes());\n                                        writeFooter(out);\n                                }\n                                reader.drain();\n                                s.close();\n                                return;\n                            }\n                        }  // end query processing\n\n                        String addressHelper = addressHelpers.get(destination);\n                        if(addressHelper != null) {\n                            host = getHostName(addressHelper);\n                        }\n\n                        // now strip everything but path and query from URI\n                        targetRequest = requestURI.toASCIIString();\n                        String newURI = requestURI.getRawPath();\n                        if(query != null) {\n                            newURI += '?' + query;\n                        }\n                        try {\n                            requestURI = new URI(newURI);\n                        } catch(URISyntaxException use) {\n                            // shouldnt happen\n                            _log.warn(request, use);\n                            method = null;\n                            break;\n                        }\n\n                    // end of (host endsWith(\".i2p\"))\n\n                    } else if(hostLowerCase.equals(\"localhost\") || host.equals(\"127.0.0.1\") ||\n                            host.startsWith(\"192.168.\") || host.equals(\"[::1]\")) {\n                        // if somebody is trying to get to 192.168.example.com, oh well\n                        out.write(getErrorPage(\"localhost\", ERR_LOCALHOST));\n                        writeFooter(out);\n                        reader.drain();\n                        s.close();\n                        return;\n                    } else if(host.contains(\".\") || host.startsWith(\"[\")) {\n                        if (Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USE_OUTPROXY_PLUGIN, \"true\"))) {\n                            ClientAppManager mgr = _context.clientAppManager();\n                            if (mgr != null) {\n                                ClientApp op = mgr.getRegisteredApp(Outproxy.NAME);\n                                if (op != null) {\n                                    outproxy = (Outproxy) op;\n                                    int rPort = requestURI.getPort();\n                                    if (rPort > 0)\n                                        remotePort = rPort;\n                                    else if (\"https\".equals(protocol) ||\n                                             method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                        remotePort = 443;\n                                    else\n                                        remotePort = 80;\n                                    usingInternalOutproxy = true;\n                                    targetRequest = requestURI.toASCIIString();\n                                    if(_log.shouldLog(Log.DEBUG))\n                                        _log.debug(getPrefix(requestId) + \" [\" + host + \"]: outproxy!\");\n                                }\n                            }\n                        }\n                        if (!usingInternalOutproxy) {\n                            if(port >= 0) {\n                                host = host + ':' + port;\n                            }\n                            // The request must be forwarded to a WWW proxy\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"Before selecting outproxy for \" + host);\n                            }\n                            if (\"https\".equals(protocol) ||\n                                method.toUpperCase(Locale.US).equals(\"CONNECT\"))\n                                currentProxy = selectSSLProxy();\n                            else\n                                currentProxy = selectProxy();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(\"After selecting outproxy for \" + host + \": \" + currentProxy);\n                            }\n                            if(currentProxy == null) {\n                                if(_log.shouldLog(Log.WARN)) {\n                                    _log.warn(getPrefix(requestId) + \"Host wants to be outproxied, but we dont have any!\");\n                                }\n                                l.log(\"No outproxy found for the request.\");\n                                out.write(getErrorPage(\"noproxy\", _ERR_NO_OUTPROXY));\n                                writeFooter(out);\n                                reader.drain();\n                                s.close();\n                                return;\n                            }\n                            destination = currentProxy;\n                            usingWWWProxy = true;\n                            targetRequest = requestURI.toASCIIString();\n                            if(_log.shouldLog(Log.DEBUG)) {\n                                _log.debug(getPrefix(requestId) + \" [\" + host + \"]: wwwProxy!\");\n                            }\n                        }\n                    } else {\n                        // what is left for here? a hostname with no dots, and != \"i2p\"\n                        // and not a destination ???\n                        // Perhaps something in privatehosts.txt ...\n                        // Rather than look it up, just bail out.\n                        if(_log.shouldLog(Log.WARN)) {\n                            _log.warn(\"NODOTS, NOI2P: \" + request);\n                        }\n                        out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                        writeFooter(out);\n                        reader.drain();\n                        s.close();\n                        return;\n                    }   // end host name processing\n\n                    boolean isValid = usingInternalOutproxy || usingWWWProxy ||\n                                      usingInternalServer || isSupportedAddress(host, protocol);\n                    if(!isValid) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"notValid(\" + host + \")\");\n                        }\n                        method = null;\n                        destination = null;\n                        break;\n                    }\n\n                    if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // fix up the change to requestURI above to get back to the original host:port\n                        line = method + ' ' + requestURI.getHost() + ':' + requestURI.getPort() + ' ' + protocolVersion;\n                    } else {\n                        line = method + ' ' + requestURI.toASCIIString() + ' ' + protocolVersion;\n                    }\n\n                    if(_log.shouldLog(Log.DEBUG)) {\n                        _log.debug(getPrefix(requestId) + \"NEWREQ: \\\"\" + line + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"HOST  : \\\"\" + host + \"\\\"\");\n                        _log.debug(getPrefix(requestId) + \"DEST  : \\\"\" + destination + \"\\\"\");\n                    }\n\n                // end first line processing\n\n                } else {\n                    if(lowercaseLine.startsWith(\"host: \") && !usingWWWProxy && !usingInternalOutproxy) {\n                        // Note that we only pass the original Host: line through to the outproxy\n                        // But we don't create a Host: line if it wasn't sent to us\n                        line = \"Host: \" + host;\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(getPrefix(requestId) + \"Setting host = \" + host);\n                        }\n                    } else if(lowercaseLine.startsWith(\"user-agent: \")) {\n                        // save for deciding whether to offer address book form\n                        userAgent = lowercaseLine.substring(12);\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            line = null;\n                            continue;\n                        }\n                    } else if(lowercaseLine.startsWith(\"accept\")) {\n                        // strip the accept-blah headers, as they vary dramatically from\n                        // browser to browser\n                        line = null;\n                        continue;\n                    } else if (lowercaseLine.startsWith(\"referer: \")) {\n                        // save for address helper form below\n                        referer = line.substring(9);\n                        if (!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_REFERER))) {\n                            // Shouldn't we be more specific, like accepting in-site referers ?\n                            //line = \"Referer: i2p\";\n                            line = null;\n                            continue; // completely strip the line\n                        }\n                    } else if(lowercaseLine.startsWith(\"via: \") &&\n                            !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_VIA))) {\n                        //line = \"Via: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"from: \")) {\n                        //line = \"From: i2p\";\n                        line = null;\n                        continue; // completely strip the line\n                    } else if(lowercaseLine.startsWith(\"authorization: ntlm \")) {\n                        // Block Windows NTLM after 401\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"proxy-authorization: \")) {\n                        // This should be for us. It is a\n                        // hop-by-hop header, and we definitely want to block Windows NTLM after a far-end 407.\n                        // Response to far-end shouldn't happen, as we\n                        // strip Proxy-Authenticate from the response in HTTPResponseOutputStream\n                        authorization = line.substring(21);  // \"proxy-authorization: \".length()\n                        line = null;\n                        continue;\n                    } else if(lowercaseLine.startsWith(\"icy\")) {\n                        // icecast/shoutcast, We need to leave the user-agent alone.\n                        shout = true;\n                    }\n                }\n\n                if(line.length() == 0) {\n                    // No more headers, add our own and break out of the loop\n                    String ok = getTunnel().getClientOptions().getProperty(\"i2ptunnel.gzip\");\n                    boolean gzip = DEFAULT_GZIP;\n                    if(ok != null) {\n                        gzip = Boolean.parseBoolean(ok);\n                    }\n                    if(gzip && !usingInternalServer &&\n                       !method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        // according to rfc2616 s14.3, this *should* force identity, even if\n                        // an explicit q=0 for gzip doesn't.  tested against orion.i2p, and it\n                        // seems to work.\n                        newRequest.append(\"Accept-Encoding: \\r\\n\");\n                        if (!usingInternalOutproxy)\n                            newRequest.append(\"X-Accept-Encoding: x-i2p-gzip;q=1.0, identity;q=0.5, deflate;q=0, gzip;q=0, *;q=0\\r\\n\");\n                    }\n                    if(!shout && !method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                        if(!Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_USER_AGENT))) {\n                            // let's not advertise to external sites that we are from I2P\n                            if(usingWWWProxy || usingInternalOutproxy) {\n                                newRequest.append(\"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6\\r\\n\");\n                            } else {\n                                newRequest.append(\"User-Agent: MYOB/6.66 (AN/ON)\\r\\n\");\n                            }\n                        }\n                    }\n                    // Add Proxy-Authentication header for next hop (outproxy)\n                    if(usingWWWProxy && Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_AUTH))) {\n                        // specific for this proxy\n                        String user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER_PREFIX + currentProxy);\n                        String pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW_PREFIX + currentProxy);\n                        if(user == null || pw == null) {\n                            // if not, look at default user and pw\n                            user = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_USER);\n                            pw = getTunnel().getClientOptions().getProperty(PROP_OUTPROXY_PW);\n                        }\n                        if(user != null && pw != null) {\n                            newRequest.append(\"Proxy-Authorization: Basic \").append(Base64.encode((user + ':' + pw).getBytes(), true)) // true = use standard alphabet\n                                    .append(\"\\r\\n\");\n                        }\n                    }\n                    newRequest.append(\"Connection: close\\r\\n\\r\\n\");\n                    break;\n                } else {\n                    newRequest.append(line).append(\"\\r\\n\"); // HTTP spec\n                }\n            } // end header processing\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"NewRequest header: [\" + newRequest.toString() + \"]\");\n            }\n\n            if(method == null || (destination == null && !usingInternalOutproxy)) {\n                //l.log(\"No HTTP method found in the request.\");\n                if (protocol != null && \"http\".equals(protocol.toLowerCase(Locale.US))) {\n                    out.write(getErrorPage(\"denied\", ERR_REQUEST_DENIED));\n                } else {\n                    out.write(getErrorPage(\"protocol\", ERR_BAD_PROTOCOL));\n                }\n                writeFooter(out);\n                s.close();\n                return;\n            }\n\n            if(_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getPrefix(requestId) + \"Destination: \" + destination);\n            }\n\n            // Authorization\n            AuthResult result = authorize(s, requestId, method, authorization);\n            if (result != AuthResult.AUTH_GOOD) {\n                if(_log.shouldLog(Log.WARN)) {\n                    if(authorization != null) {\n                        _log.warn(getPrefix(requestId) + \"Auth failed, sending 407 again\");\n                    } else {\n                        _log.warn(getPrefix(requestId) + \"Auth required, sending 407\");\n                    }\n                }\n                out.write(getAuthError(result == AuthResult.AUTH_STALE).getBytes());\n                writeFooter(out);\n                s.close();\n                return;\n            }\n\n            // Serve local proxy files (images, css linked from error pages)\n            // Ignore all the headers\n            if(usingInternalServer) {\n                // disable the add form if address helper is disabled\n                if(internalPath.equals(\"/add\") &&\n                        Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                    out.write(ERR_HELPER_DISABLED);\n                } else {\n                    LocalHTTPServer.serveLocalFile(out, method, internalPath, internalRawQuery, _proxyNonce);\n                }\n                s.close();\n                return;\n            }\n\n            // no destination, going to outproxy plugin\n            if (usingInternalOutproxy) {\n                Socket outSocket = outproxy.connect(host, remotePort);\n                Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n                byte[] data;\n                byte[] response;\n                if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                } else {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                }\n                new I2PTunnelOutproxyRunner(s, outSocket, sockLock, data, response, onTimeout);\n                return;\n            }\n\n            // LOOKUP\n            // If the host is \"i2p\", the getHostName() lookup failed, don't try to\n            // look it up again as the naming service does not do negative caching\n            // so it will be slow.\n            Destination clientDest = null;\n            String addressHelper = addressHelpers.get(destination.toLowerCase(Locale.US));\n            if(addressHelper != null) {\n                clientDest = _context.namingService().lookup(addressHelper);\n                if(clientDest == null) {\n                    // remove bad entries\n                    addressHelpers.remove(destination.toLowerCase(Locale.US));\n                    if(_log.shouldLog(Log.WARN)) {\n                        _log.warn(getPrefix(requestId) + \"Could not find destination for \" + addressHelper);\n                    }\n                    byte[] header = getErrorPage(\"ahelper-notfound\", ERR_AHELPER_NOTFOUND);\n                    writeErrorMessage(header, out, targetRequest, false, destination, null);\n                    s.close();\n                    return;\n                }\n            } else if(\"i2p\".equals(host)) {\n                clientDest = null;\n            } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                // use existing session to look up for efficiency\n                verifySocketManager();\n                I2PSession sess = sockMgr.getSession();\n                if(!sess.isClosed()) {\n                    byte[] hData = Base32.decode(destination.substring(0, 52));\n                    if(hData != null) {\n                        if(_log.shouldLog(Log.INFO)) {\n                            _log.info(\"lookup in-session \" + destination);\n                        }\n                        Hash hash = Hash.create(hData);\n                        clientDest = sess.lookupDest(hash, 20 * 1000);\n                    }\n                } else {\n                    clientDest = _context.namingService().lookup(destination);\n                }\n            } else {\n                clientDest = _context.namingService().lookup(destination);\n            }\n\n            if(clientDest == null) {\n                //l.log(\"Could not resolve \" + destination + \".\");\n                if(_log.shouldLog(Log.WARN)) {\n                    _log.warn(\"Unable to resolve \" + destination + \" (proxy? \" + usingWWWProxy + \", request: \" + targetRequest);\n                }\n                byte[] header;\n                String jumpServers = null;\n                if(usingWWWProxy) {\n                    header = getErrorPage(\"dnfp\", ERR_DESTINATION_UNKNOWN);\n                } else if(ahelperPresent) {\n                    header = getErrorPage(\"dnfb\", ERR_DESTINATION_UNKNOWN);\n                } else if(destination.length() == 60 && destination.toLowerCase(Locale.US).endsWith(\".b32.i2p\")) {\n                    header = getErrorPage(\"dnf\", ERR_DESTINATION_UNKNOWN);\n                } else {\n                    header = getErrorPage(\"dnfh\", ERR_DESTINATION_UNKNOWN);\n                    jumpServers = getTunnel().getClientOptions().getProperty(PROP_JUMP_SERVERS);\n                    if(jumpServers == null) {\n                        jumpServers = DEFAULT_JUMP_SERVERS;\n                    }\n                }\n                writeErrorMessage(header, out, targetRequest, usingWWWProxy, destination, jumpServers);\n                s.close();\n                return;\n            }\n\n            // Address helper response form\n            // This will only load once - the second time it won't be \"new\"\n            // Don't do this for eepget, which uses a user-agent of \"Wget\"\n            if(ahelperNew && \"GET\".equals(method) &&\n                    (userAgent == null || !userAgent.startsWith(\"Wget\")) &&\n                    !Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {\n                writeHelperSaveForm(out, destination, ahelperKey, targetRequest, referer);\n                s.close();\n                return;\n            }\n\n            // Redirect to non-addresshelper URL to not clog the browser address bar\n            // and not pass the parameter to the eepsite.\n            // This also prevents the not-found error page from looking bad\n            // Syndie can't handle a redirect of a POST\n            if(ahelperPresent && !\"POST\".equals(method)) {\n                String uri = targetRequest;\n                if(_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(\"Auto redirecting to \" + uri);\n                }\n                out.write((\"HTTP/1.1 301 Address Helper Accepted\\r\\n\" +\n                        \"Location: \" + uri + \"\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                s.close();\n                return;\n            }\n\n            Properties opts = new Properties();\n            //opts.setProperty(\"i2p.streaming.inactivityTimeout\", \"\"+120*1000);\n            // 1 == disconnect.  see ConnectionOptions in the new streaming lib, which i\n            // dont want to hard link to here\n            //opts.setProperty(\"i2p.streaming.inactivityTimeoutAction\", \"\"+1);\n            I2PSocketOptions sktOpts = getDefaultOptions(opts);\n            if (remotePort > 0)\n                sktOpts.setPort(remotePort);\n            I2PSocket i2ps = createI2PSocket(clientDest, sktOpts);\n            Runnable onTimeout = new OnTimeout(s, s.getOutputStream(), targetRequest, usingWWWProxy, currentProxy, requestId);\n            if (method.toUpperCase(Locale.US).equals(\"CONNECT\")) {\n                byte[] data;\n                byte[] response;\n                if (usingWWWProxy) {\n                    data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                    response = null;\n                } else {\n                    data = null;\n                    response = I2PTunnelConnectClient.SUCCESS_RESPONSE;\n                }\n                new I2PTunnelRunner(s, i2ps, sockLock, data, response, mySockets, onTimeout);\n            } else {\n                byte[] data = newRequest.toString().getBytes(\"ISO-8859-1\");\n                new I2PTunnelHTTPClientRunner(s, i2ps, sockLock, data, mySockets, onTimeout);\n            }\n        } catch(IOException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(getPrefix(requestId) + \"Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(I2PException ex) {\n            if(_log.shouldLog(Log.INFO)) {\n                _log.info(\"getPrefix(requestId) + Error trying to connect\", ex);\n            }\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        } catch(OutOfMemoryError oom) {\n            IOException ex = new IOException(\"OOM\");\n            _log.error(\"getPrefix(requestId) + Error trying to connect\", oom);\n            //l.log(\"Error connecting: \" + ex.getMessage());\n            handleHTTPClientException(ex, out, targetRequest, usingWWWProxy, currentProxy, requestId);\n            closeSocket(s);\n        }\n    }","commit_id":"1acd5caaa8f9176c577f34000058771be6540fd3","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"boolean hasInterfaceOids() throws CollectionError {\n\t\t\n\t\tMap ifMap = getIfMap();\n\t\tif (ifMap == null) return false;\n\t\t\n\t\tIterator iter = ifMap.values().iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tIfInfo ifInfo = (IfInfo) iter.next();\n\t\t\tif (ifInfo.getType() < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ifInfo.getOidList().isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":104186,"modified_method":"boolean hasInterfaceOids() {\n\t\treturn m_collectionSet.hasInterfaceOids();\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"Map getIfMap() throws CollectionError {\n\t\treturn m_collectionSet.getIfMap();\n\t}","id":104187,"modified_method":"Map getIfMap() {\n\t\treturn getCollectionSet().getIfMap();\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public CollectionSet(CollectionInterface collectionInterface, String collectionName) {\n\t\tm_collectionInterface = collectionInterface;\n\t\tm_collectionName = collectionName;\n\t}","id":104188,"modified_method":"public CollectionSet(CollectionInterface collectionInterface, String collectionName) {\n\t\tm_collectionInterface = collectionInterface;\n\t\tm_collectionName = collectionName;\n\t\taddSnmpInterfacesToCollectionSet();\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setOidList(List oidList) {\n        m_oidList = oidList;\n    }","id":104189,"modified_method":"public void setOidList(List list) {\n\t\tm_oidList = list;\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setDsList(List dsList) {\n        m_dsList = dsList;\n    }","id":104190,"modified_method":"public IfInfo(CollectionInterface collectionInterface, String collectionName, OnmsSnmpInterface snmpIface) {\n    \tm_collectionInterface = collectionInterface;\n    \tm_collectionName = collectionName;\n    \tm_snmpIface = snmpIface;\n    \t\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List getDsList() {\n        return m_dsList;\n    }","id":104191,"modified_method":"public List getDsList() {\n        List dsList = DataCollectionConfigFactory.buildDataSourceList(getCollectionName(), getOidList());\n\t\treturn dsList;\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List getOidList() {\n        return m_oidList;\n    }","id":104192,"modified_method":"public List getOidList() {\n        return (m_oidList == null ? computeOidList() : m_oidList);\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void execute(SnmpCollector collector, CollectionInterface iface, Map parameters) {\n\t\t\n\t\tinitialize(collector, iface, parameters);\n\n\n\t\tlogCollectionParms();\n\t\t\n\t\tvalidateNodeID();\n\t\tvalidatePrimaryIfIndex();\n\t\tvalidateIsSnmpPrimary();\n\t\tvalidateSysObjId();\n\n\t\tm_collectionSet = new CollectionSet(m_iface, m_collectionName);\n\t\t\n\t\tcomputeSnmpInfoForInterfaces();\n\t\t\n\t\tverifyCollectionIsNecessary();\n\t\t\t\n\t\tm_iface.setCollectionSet(m_collectionSet);\n\t\n\t\tlogCompletion();\n\t}","id":104193,"modified_method":"void execute(SnmpCollector collector, CollectionInterface iface, Map parameters) {\n\t\t\n\t\tm_collector = collector;\n\t\tm_iface = iface;\n\t\tm_collectionName = m_collector.getCollectionName(parameters);\n\t\t\n\t\t// Add the SNMP storage value as an attribute of the interface\n\t\tm_iface.setStorageFlag(m_collector.getStorageFlag(m_collectionName));\n\t\tm_iface.setMaxVarsPerPdu(m_collector.getMaxVarsPerPdu(m_collectionName));\n\n\t\tlogCollectionParms();\n\t\t\n\t\tvalidateIsSnmpPrimary();\n\t\tvalidateSysObjId();\n\n\t\tm_collectionSet = new CollectionSet(m_iface, m_collectionName);\n\t\tm_iface.setCollectionSet(m_collectionSet);\n\t\t\n\t\tverifyCollectionIsNecessary();\n\t\n\t\tlogCompletion();\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n\t\treturn ThreadCategory.getInstance(getClass());\n\t}","id":104194,"modified_method":"Category log() {\n\t\treturn ThreadCategory.getInstance(getClass());\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void verifyCollectionIsNecessary() {\n\t\t/*\n\t\t * Verify that there is something to collect from this primary SMP\n\t\t * interface. If no node objects and no interface objects then throw\n\t\t * exception\n\t\t */\n\t\tif (m_collectionSet.getNodeInfo().getOidList().isEmpty()) {\n\t\t\tboolean hasInterfaceOids = false;\n\t\t\tIterator iter = m_collectionSet.getIfMap().values().iterator();\n\t\t\twhile (iter.hasNext() && !hasInterfaceOids) {\n\t\t\t\tIfInfo ifInfo = (IfInfo) iter.next();\n\t\t\t\tif (!ifInfo.getOidList().isEmpty()) {\n\t\t\t\t\thasInterfaceOids = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!hasInterfaceOids) {\n\t\t\t\tthrow new RuntimeException(\"collection '\" + m_collectionName\n\t\t\t\t\t\t+ \"' defines nothing to collect for \"\n\t\t\t\t\t\t+ m_iface.getHostAddress());\n\t\t\t}\n\t\t}\n\t}","id":104195,"modified_method":"private void verifyCollectionIsNecessary() {\n\n\t\t/*\n\t\t * Verify that there is something to collect from this primary SMP\n\t\t * interface. If no node objects and no interface objects then throw\n\t\t * exception\n\t\t */\n\t\tif (!m_collectionSet.hasDataToCollect()) {\n\t\t\tthrow new RuntimeException(\"collection '\" + m_collectionName\n\t\t\t\t\t+ \"' defines nothing to collect for \"\n\t\t\t\t\t+ m_iface.getHostAddress());\n\t\t}\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * This method is responsible for building an RRDTool style 'update' command\n\t * which is issued via the RRD JNI interface in order to push the latest\n\t * SNMP-collected values into the interface's RRD database.\n\t * \n\t * @param collectionName\n\t *            SNMP data Collection name from 'datacollection-config.xml'\n\t * @param iface\n\t *            CollectionInterface object of the interface currently being\n\t *            polled\n\t * @param nodeCollector\n\t *            Node level MIB data collected via SNMP for the polled\n\t *            interface\n\t * @param ifCollector\n\t *            Interface level MIB data collected via SNMP for the polled\n\t *            interface\n\t * @throws CollectionError\n\t * @exception RuntimeException\n\t *                Thrown if the data source list for the interface is null.\n\t */\n\tprivate boolean updateRRDs(String collectionName, CollectionInterface iface,\n\t\t\tSnmpNodeCollector nodeCollector, SnmpIfCollector ifCollector,\n\t\t\tMap parms, EventProxy eproxy) throws CollectionError {\n\t\t// Log4j category\n\t\tInetAddress ipaddr = iface.getInetAddress();\n\n\t\t// Retrieve SNMP storage attribute\n\t\tString snmpStorage = iface.getSnmpStorage();\n\n\t\t// Get primary interface index from NodeInfo object\n\t\tNodeInfo nodeInfo = getNodeInfo(iface);\n\t\tint nodeId = nodeInfo.getNodeId();\n\t\tint primaryIfIndex = nodeInfo.getPrimarySnmpIfIndex();\n\n\t\t// Retrieve interface map attribute\n\t\tMap ifMap = getIfMap(iface);\n\n\t\t/*\n\t\t * Write relevant collected SNMP statistics to RRD database First the\n\t\t * node level RRD info will be updated. Secondly the interface level RRD\n\t\t * info will be updated.\n\t\t */\n\t\tboolean rrdError = false;\n\n\t\t// Node data\n\t\tif (nodeCollector != null) {\n\t\t\tlog().debug(\"updateRRDs: processing node-level collection...\");\n\n\t\t\t/*\n\t\t\t * Build path to node RRD repository. createRRD() will make the\n\t\t\t * appropriate directories if they do not already exist.\n\t\t\t */\n\t\t\tString nodeRepository = m_rrdPath + File.separator\n\t\t\t\t\t+ String.valueOf(nodeId);\n\n\t\t\tSNMPCollectorEntry nodeEntry = nodeCollector.getEntry();\n\n\t\t\t/*\n\t\t\t * Iterate over the node datasource list and issue RRD update\n\t\t\t * commands to update each datasource which has a corresponding\n\t\t\t * value in the collected SNMP data.\n\t\t\t */\n\t\t\tIterator iter = nodeInfo.getDsList().iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tDataSource ds = (DataSource) iter.next();\n\n\t\t\t\ttry {\n\t\t\t\t\tString dsVal = getRRDValue(ds, nodeEntry);\n\t\t\t\t\tif (dsVal == null) {\n\t\t\t\t\t\t// Do nothing, no update is necessary\n\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\t\t\"updateRRDs: Skipping update, no \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"data retrieved for nodeId: \"\n\t\t\t\t\t\t\t\t\t\t\t+ nodeId + \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// createRRD(collectionName, ipaddr, nodeRepository,\n\t\t\t\t\t\t// ds);\n\t\t\t\t\t\tif (ds.performUpdate(collectionName, ipaddr\n\t\t\t\t\t\t\t\t.getHostAddress(), nodeRepository,\n\t\t\t\t\t\t\t\tds.getName(), dsVal)) {\n\t\t\t\t\t\t\tlog().warn(\n\t\t\t\t\t\t\t\t\t\"updateRRDs: ds.performUpdate() \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"failed for node: \" + nodeId\n\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \" + ds.getName());\n\t\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tlog().warn(\"getRRDValue: \" + e.getMessage());\n\n\t\t\t\t\t// Set rrdError flag\n\t\t\t\t\trrdError = true;\n\t\t\t\t\tlog().warn(\n\t\t\t\t\t\t\t\"updateRRDs: call to getRRDValue() failed \"\n\t\t\t\t\t\t\t\t\t+ \"for node: \" + nodeId + \" datasource: \"\n\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t}\n\n\t\t\t} // end while(more datasources)\n\t\t} // end if(nodeCollector != null)\n\n\t\t// Interface-specific data\n\t\tboolean forceRescan = false;\n\t\tboolean rescanPending = false;\n\t\tMap SnmpIfAliasMap = new HashMap();\n\n\t\tif (ifCollector != null) {\n\t\t\tString domain = ParameterMap.getKeyedString(parms, \"domain\",\n\t\t\t\t\t\"default\");\n\t\t\tString storeByNodeID = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"storeByNodeID\", \"normal\");\n\t\t\tString storeByIfAlias = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"storeByIfAlias\", \"false\");\n\t\t\tString storFlagOverride = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"storFlagOverride\", \"false\");\n\t\t\tString ifAliasComment = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"ifAliasComment\", null);\n\n\t\t\tif (log().isDebugEnabled() && storeByIfAlias.equals(\"true\")) {\n\t\t\t\tlog()\n\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\"domain:storeByNodeID:storeByIfAlias:\"\n\t\t\t\t\t\t\t\t\t\t+ \"storFlagOverride:ifAliasComment = \"\n\t\t\t\t\t\t\t\t\t\t+ domain + \":\" + storeByNodeID + \":\"\n\t\t\t\t\t\t\t\t\t\t+ storeByIfAlias + \":\"\n\t\t\t\t\t\t\t\t\t\t+ storFlagOverride + \":\"\n\t\t\t\t\t\t\t\t\t\t+ ifAliasComment);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Retrieve list of SNMP collector entries generated for the remote\n\t\t\t * node's interfaces.\n\t\t\t */\n\t\t\tList snmpCollectorEntries = ifCollector.getEntries();\n\t\t\tif (snmpCollectorEntries == null\n\t\t\t\t\t|| snmpCollectorEntries.size() == 0) {\n\t\t\t\tlog().warn(\n\t\t\t\t\t\t\"updateRRDs: No data retrieved for the interface \"\n\t\t\t\t\t\t\t\t+ ipaddr.getHostAddress());\n\t\t\t}\n\n\t\t\t// get the snmpIfAliases\n\t\t\tif (isForceRescanInProgress(nodeId, ipaddr.getHostAddress())) {\n\t\t\t\trescanPending = true;\n\t\t\t} else {\n\t\t\t\tSnmpIfAliasMap = getIfAliasesFromDb(nodeId);\n\t\t\t}\n\n\t\t\t// Iterate over the SNMP collector entries\n\t\t\tIterator iter = snmpCollectorEntries.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tSNMPCollectorEntry ifEntry = (SNMPCollectorEntry) iter.next();\n\n\t\t\t\tint ifIndex = ifEntry.getIfIndex().intValue();\n\t\t\t\tString ifIdx = Integer.toString(ifIndex);\n\n\t\t\t\t// get the ifAlias if one exists\n\t\t\t\tString aliasVal = getRRDIfAlias(ifIdx, ifEntry);\n\t\t\t\tif (aliasVal != null && !aliasVal.equals(\"\")) {\n\t\t\t\t\taliasVal = aliasVal.trim();\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check DB to see if ifAlias is current and flag a forced\n\t\t\t\t\t * rescan if not.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rescanPending) {\n\t\t\t\t\t\tif (SnmpIfAliasMap.get(ifIdx) == null\n\t\t\t\t\t\t\t\t|| !SnmpIfAliasMap.get(ifIdx).equals(aliasVal)) {\n\t\t\t\t\t\t\trescanPending = true;\n\t\t\t\t\t\t\tforceRescan = true;\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\t\t\t\"Forcing rescan.  IfAlias \" + aliasVal\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" for index \" + ifIdx\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" does not match DB value: \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ SnmpIfAliasMap.get(ifIdx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ifAliasComment != null) {\n\t\t\t\t\t\tint si = aliasVal.indexOf(ifAliasComment);\n\t\t\t\t\t\tif (si > -1) {\n\t\t\t\t\t\t\taliasVal = aliasVal.substring(0, si).trim();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aliasVal != null && !aliasVal.equals(\"\")) {\n\t\t\t\t\t\taliasVal = AlphaNumeric.parseAndReplaceExcept(aliasVal,\n\t\t\t\t\t\t\t\tnonAnRepl, AnReplEx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean override = true;\n\t\t\t\tif (storFlagOverride.equals(\"false\") || (aliasVal == null)\n\t\t\t\t\t\t|| aliasVal.equals(\"\")) {\n\t\t\t\t\toverride = false;\n\t\t\t\t}\n\t\t\t\tString byNode = storeByNodeID;\n\n\t\t\t\t/*\n\t\t\t\t * Are we storing SNMP data for all interfaces or primary\n\t\t\t\t * interface only? If only storing for primary interface only\n\t\t\t\t * proceed if current ifIndex is equal to the ifIndex of the\n\t\t\t\t * primary SNMP interface.\n\t\t\t\t */\n\t\t\t\tif (snmpStorage.equals(SNMP_STORAGE_PRIMARY)) {\n\t\t\t\t\tif (ifIndex != primaryIfIndex) {\n\t\t\t\t\t\tif (override) {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: storFlagOverride \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"= true. Storing SNMP data for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"non-primary interface \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIdx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: only storing \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"SNMP data for primary interface (\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ primaryIfIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"), skipping ifIndex: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIdx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (byNode.equals(\"normal\")) {\n\t\t\t\t\t\t\tbyNode = \"false\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Use ifIndex to lookup the IfInfo object from the interface\n\t\t\t\t * map.\n\t\t\t\t */\n\t\t\t\tIfInfo ifInfo = (IfInfo) ifMap.get(new Integer(ifIndex));\n\t\t\t\tif (ifInfo == null) {\n\t\t\t\t\t// no data needed for this interface\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (snmpStorage.equals(SNMP_STORAGE_SELECT)) {\n\t\t\t\t\tif (ifInfo.getCollType().equals(CollectionType.NO_COLLECT)) {\n\t\t\t\t\t\tif (override) {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: storFlagOverride \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"= true. Storing SNMP data for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"interface \" + ifIdx\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" with CollType = \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifInfo.getCollType());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: selectively storing \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"SNMP data for primary interface (\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ primaryIfIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"), skipping ifIndex: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIdx\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" because collType = \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifInfo.getCollType());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (byNode.equals(\"normal\")) {\n\t\t\t\t\t\t\tbyNode = \"false\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (byNode.equals(\"normal\")) {\n\t\t\t\t\tbyNode = \"true\";\n\t\t\t\t}\n\n\t\t\t\tif (ifInfo.getDsList() == null) {\n\t\t\t\t\tthrow new RuntimeException(\"Data Source list not \"\n\t\t\t\t\t\t\t+ \"available for primary IP addr \"\n\t\t\t\t\t\t\t+ ipaddr.getHostAddress() + \" and ifIndex \"\n\t\t\t\t\t\t\t+ ifInfo.getIndex());\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Iterate over the interface datasource list and issue RRD\n\t\t\t\t * update commands to update each datasource which has a\n\t\t\t\t * corresponding value in the collected SNMP data.\n\t\t\t\t */\n\t\t\t\tIterator i = ifInfo.getDsList().iterator();\n\t\t\t\twhile (i.hasNext()) {\n\t\t\t\t\tDataSource ds = (DataSource) i.next();\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Build path to interface RRD repository. createRRD() will\n\t\t\t\t\t * make the appropriate directories if they do not already\n\t\t\t\t\t * exist.\n\t\t\t\t\t */\n\t\t\t\t\tString ifRepository = m_rrdPath + File.separator\n\t\t\t\t\t\t\t+ String.valueOf(nodeId) + File.separator\n\t\t\t\t\t\t\t+ ifInfo.getLabel();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString dsVal = getRRDValue(ds, ifEntry);\n\n\t\t\t\t\t\t// Build RRD update command\n\t\t\t\t\t\tif (dsVal == null) {\n\t\t\t\t\t\t\t// Do nothing, no update is necessary\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\t\t\t\"updateRRDs: Skipping update, \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"no data retrieved for \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"node/ifindex: \" + nodeId\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\" + ifIndex\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Call createRRD() to create RRD if it doesn't\n\t\t\t\t\t\t\t * already exist.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t// createRRD(collectionName, ipaddr, ifRepository,\n\t\t\t\t\t\t\t// ds);\n\t\t\t\t\t\t\tif (byNode.equals(\"true\")) {\n\t\t\t\t\t\t\t\tif (ds.performUpdate(collectionName, ipaddr\n\t\t\t\t\t\t\t\t\t\t.getHostAddress(), ifRepository, ds\n\t\t\t\t\t\t\t\t\t\t.getName(), dsVal)) {\n\t\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t\t.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"ds.performUpdate() failed for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"node/ifindex: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ nodeId + \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (storeByIfAlias.equals(\"true\")) {\n\t\t\t\t\t\t\t\tif ((aliasVal != null) && !aliasVal.equals(\"\")) {\n\t\t\t\t\t\t\t\t\tifRepository = m_rrdPath + File.separator\n\t\t\t\t\t\t\t\t\t\t\t+ domain + File.separator\n\t\t\t\t\t\t\t\t\t\t\t+ aliasVal;\n\t\t\t\t\t\t\t\t\tif (ds.performUpdate(collectionName, ipaddr\n\t\t\t\t\t\t\t\t\t\t\t.getHostAddress(), ifRepository, ds\n\t\t\t\t\t\t\t\t\t\t\t.getName(), dsVal)) {\n\t\t\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t\t\t.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"ds.performUpdate() failed for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"node/ifindex/domain/alias: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ nodeId\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ domain\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ aliasVal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\tlog().warn(\"buildRRDUpdateCmd: \" + e.getMessage());\n\n\t\t\t\t\t\t// Set rrdError flag\n\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\tlog().warn(\n\t\t\t\t\t\t\t\t\"updateRRDs: call to buildRRDUpdateCmd() \"\n\t\t\t\t\t\t\t\t\t\t+ \"failed for node/ifindex: \" + nodeId\n\t\t\t\t\t\t\t\t\t\t+ \"/\" + ifIndex + \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t}\n\n\t\t\t\t} // end while(more datasources)\n\t\t\t} // end while(more SNMP collector entries)\n\t\t} // end if(ifCollector != null)\n\n\t\tif (forceRescan) {\n\t\t\tgenerateForceRescanEvent(ipaddr.getHostAddress(), nodeInfo\n\t\t\t\t\t.getNodeId(), eproxy);\n\t\t}\n\t\treturn rrdError;\n\t}","id":104196,"modified_method":"/**\n\t * This method is responsible for building an RRDTool style 'update' command\n\t * which is issued via the RRD JNI interface in order to push the latest\n\t * SNMP-collected values into the interface's RRD database.\n\t * \n\t * @param collectionName\n\t *            SNMP data Collection name from 'datacollection-config.xml'\n\t * @param iface\n\t *            CollectionInterface object of the interface currently being\n\t *            polled\n\t * @param nodeCollector\n\t *            Node level MIB data collected via SNMP for the polled\n\t *            interface\n\t * @param ifCollector\n\t *            Interface level MIB data collected via SNMP for the polled\n\t *            interface\n\t * @throws CollectionError\n\t * @exception RuntimeException\n\t *                Thrown if the data source list for the interface is null.\n\t */\n\tprivate boolean updateRRDs(String collectionName, CollectionInterface iface,\n\t\t\tSnmpNodeCollector nodeCollector, SnmpIfCollector ifCollector,\n\t\t\tMap parms, EventProxy eproxy) throws CollectionError {\n\t\t// Log4j category\n\t\tInetAddress ipaddr = iface.getInetAddress();\n\n\t\t// Retrieve SNMP storage attribute\n\t\tString snmpStorage = iface.getSnmpStorage();\n\n\t\t// Get primary interface index from NodeInfo object\n\t\tint nodeId = iface.getNodeId();\n\t\tint primaryIfIndex = iface.getIfIndex();\n\n\t\t// Retrieve interface map attribute\n\t\tMap ifMap = iface.getIfMap();\n\t\tverifyIfMap(iface, ifMap);\n\n\t\t/*\n\t\t * Write relevant collected SNMP statistics to RRD database First the\n\t\t * node level RRD info will be updated. Secondly the interface level RRD\n\t\t * info will be updated.\n\t\t */\n\t\tboolean rrdError = false;\n\n\t\t// Node data\n\t\tif (nodeCollector != null) {\n\t\t\tlog().debug(\"updateRRDs: processing node-level collection...\");\n\n\t\t\t/*\n\t\t\t * Build path to node RRD repository. createRRD() will make the\n\t\t\t * appropriate directories if they do not already exist.\n\t\t\t */\n\t\t\tString nodeRepository = m_rrdPath + File.separator\n\t\t\t\t\t+ String.valueOf(nodeId);\n\n\t\t\tSNMPCollectorEntry nodeEntry = nodeCollector.getEntry();\n\n\t\t\t/*\n\t\t\t * Iterate over the node datasource list and issue RRD update\n\t\t\t * commands to update each datasource which has a corresponding\n\t\t\t * value in the collected SNMP data.\n\t\t\t */\n\t\t\tIterator iter = iface.getNodeDsList().iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tDataSource ds = (DataSource) iter.next();\n\n\t\t\t\ttry {\n\t\t\t\t\tString dsVal = getRRDValue(ds, nodeEntry);\n\t\t\t\t\tif (dsVal == null) {\n\t\t\t\t\t\t// Do nothing, no update is necessary\n\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\t\t\"updateRRDs: Skipping update, no \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"data retrieved for nodeId: \"\n\t\t\t\t\t\t\t\t\t\t\t+ nodeId + \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// createRRD(collectionName, ipaddr, nodeRepository,\n\t\t\t\t\t\t// ds);\n\t\t\t\t\t\tif (ds.performUpdate(collectionName, ipaddr\n\t\t\t\t\t\t\t\t.getHostAddress(), nodeRepository,\n\t\t\t\t\t\t\t\tds.getName(), dsVal)) {\n\t\t\t\t\t\t\tlog().warn(\n\t\t\t\t\t\t\t\t\t\"updateRRDs: ds.performUpdate() \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"failed for node: \" + nodeId\n\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \" + ds.getName());\n\t\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tlog().warn(\"getRRDValue: \" + e.getMessage());\n\n\t\t\t\t\t// Set rrdError flag\n\t\t\t\t\trrdError = true;\n\t\t\t\t\tlog().warn(\n\t\t\t\t\t\t\t\"updateRRDs: call to getRRDValue() failed \"\n\t\t\t\t\t\t\t\t\t+ \"for node: \" + nodeId + \" datasource: \"\n\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t}\n\n\t\t\t} // end while(more datasources)\n\t\t} // end if(nodeCollector != null)\n\n\t\t// Interface-specific data\n\t\tboolean forceRescan = false;\n\t\tboolean rescanPending = false;\n\t\tMap SnmpIfAliasMap = new HashMap();\n\n\t\tif (ifCollector != null) {\n\t\t\tString domain = ParameterMap.getKeyedString(parms, \"domain\",\n\t\t\t\t\t\"default\");\n\t\t\tString storeByNodeID = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"storeByNodeID\", \"normal\");\n\t\t\tString storeByIfAlias = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"storeByIfAlias\", \"false\");\n\t\t\tString storFlagOverride = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"storFlagOverride\", \"false\");\n\t\t\tString ifAliasComment = ParameterMap.getKeyedString(parms,\n\t\t\t\t\t\"ifAliasComment\", null);\n\n\t\t\tif (log().isDebugEnabled() && storeByIfAlias.equals(\"true\")) {\n\t\t\t\tlog()\n\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\"domain:storeByNodeID:storeByIfAlias:\"\n\t\t\t\t\t\t\t\t\t\t+ \"storFlagOverride:ifAliasComment = \"\n\t\t\t\t\t\t\t\t\t\t+ domain + \":\" + storeByNodeID + \":\"\n\t\t\t\t\t\t\t\t\t\t+ storeByIfAlias + \":\"\n\t\t\t\t\t\t\t\t\t\t+ storFlagOverride + \":\"\n\t\t\t\t\t\t\t\t\t\t+ ifAliasComment);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Retrieve list of SNMP collector entries generated for the remote\n\t\t\t * node's interfaces.\n\t\t\t */\n\t\t\tList snmpCollectorEntries = ifCollector.getEntries();\n\t\t\tif (snmpCollectorEntries == null\n\t\t\t\t\t|| snmpCollectorEntries.size() == 0) {\n\t\t\t\tlog().warn(\n\t\t\t\t\t\t\"updateRRDs: No data retrieved for the interface \"\n\t\t\t\t\t\t\t\t+ ipaddr.getHostAddress());\n\t\t\t}\n\n\t\t\t// get the snmpIfAliases\n\t\t\tif (isForceRescanInProgress(nodeId, ipaddr.getHostAddress())) {\n\t\t\t\trescanPending = true;\n\t\t\t} else {\n\t\t\t\tSnmpIfAliasMap = getIfAliasesFromDb(nodeId);\n\t\t\t}\n\n\t\t\t// Iterate over the SNMP collector entries\n\t\t\tIterator iter = snmpCollectorEntries.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tSNMPCollectorEntry ifEntry = (SNMPCollectorEntry) iter.next();\n\n\t\t\t\tint ifIndex = ifEntry.getIfIndex().intValue();\n\t\t\t\tString ifIdx = Integer.toString(ifIndex);\n\n\t\t\t\t// get the ifAlias if one exists\n\t\t\t\tString aliasVal = getRRDIfAlias(ifIdx, ifEntry);\n\t\t\t\tif (aliasVal != null && !aliasVal.equals(\"\")) {\n\t\t\t\t\taliasVal = aliasVal.trim();\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check DB to see if ifAlias is current and flag a forced\n\t\t\t\t\t * rescan if not.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rescanPending) {\n\t\t\t\t\t\tif (SnmpIfAliasMap.get(ifIdx) == null\n\t\t\t\t\t\t\t\t|| !SnmpIfAliasMap.get(ifIdx).equals(aliasVal)) {\n\t\t\t\t\t\t\trescanPending = true;\n\t\t\t\t\t\t\tforceRescan = true;\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\t\t\t\"Forcing rescan.  IfAlias \" + aliasVal\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" for index \" + ifIdx\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" does not match DB value: \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ SnmpIfAliasMap.get(ifIdx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ifAliasComment != null) {\n\t\t\t\t\t\tint si = aliasVal.indexOf(ifAliasComment);\n\t\t\t\t\t\tif (si > -1) {\n\t\t\t\t\t\t\taliasVal = aliasVal.substring(0, si).trim();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aliasVal != null && !aliasVal.equals(\"\")) {\n\t\t\t\t\t\taliasVal = AlphaNumeric.parseAndReplaceExcept(aliasVal,\n\t\t\t\t\t\t\t\tnonAnRepl, AnReplEx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean override = true;\n\t\t\t\tif (storFlagOverride.equals(\"false\") || (aliasVal == null)\n\t\t\t\t\t\t|| aliasVal.equals(\"\")) {\n\t\t\t\t\toverride = false;\n\t\t\t\t}\n\t\t\t\tString byNode = storeByNodeID;\n\n\t\t\t\t/*\n\t\t\t\t * Are we storing SNMP data for all interfaces or primary\n\t\t\t\t * interface only? If only storing for primary interface only\n\t\t\t\t * proceed if current ifIndex is equal to the ifIndex of the\n\t\t\t\t * primary SNMP interface.\n\t\t\t\t */\n\t\t\t\tif (snmpStorage.equals(SNMP_STORAGE_PRIMARY)) {\n\t\t\t\t\tif (ifIndex != primaryIfIndex) {\n\t\t\t\t\t\tif (override) {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: storFlagOverride \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"= true. Storing SNMP data for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"non-primary interface \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIdx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: only storing \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"SNMP data for primary interface (\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ primaryIfIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"), skipping ifIndex: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIdx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (byNode.equals(\"normal\")) {\n\t\t\t\t\t\t\tbyNode = \"false\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Use ifIndex to lookup the IfInfo object from the interface\n\t\t\t\t * map.\n\t\t\t\t */\n\t\t\t\tIfInfo ifInfo = (IfInfo) ifMap.get(new Integer(ifIndex));\n\t\t\t\tif (ifInfo == null) {\n\t\t\t\t\t// no data needed for this interface\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (snmpStorage.equals(SNMP_STORAGE_SELECT)) {\n\t\t\t\t\tif (ifInfo.getCollType().equals(CollectionType.NO_COLLECT)) {\n\t\t\t\t\t\tif (override) {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: storFlagOverride \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"= true. Storing SNMP data for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"interface \" + ifIdx\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" with CollType = \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifInfo.getCollType());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: selectively storing \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"SNMP data for primary interface (\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ primaryIfIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"), skipping ifIndex: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIdx\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" because collType = \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifInfo.getCollType());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (byNode.equals(\"normal\")) {\n\t\t\t\t\t\t\tbyNode = \"false\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (byNode.equals(\"normal\")) {\n\t\t\t\t\tbyNode = \"true\";\n\t\t\t\t}\n\n\t\t\t\tif (ifInfo.getDsList() == null) {\n\t\t\t\t\tthrow new RuntimeException(\"Data Source list not \"\n\t\t\t\t\t\t\t+ \"available for primary IP addr \"\n\t\t\t\t\t\t\t+ ipaddr.getHostAddress() + \" and ifIndex \"\n\t\t\t\t\t\t\t+ ifInfo.getIndex());\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Iterate over the interface datasource list and issue RRD\n\t\t\t\t * update commands to update each datasource which has a\n\t\t\t\t * corresponding value in the collected SNMP data.\n\t\t\t\t */\n\t\t\t\tIterator i = ifInfo.getDsList().iterator();\n\t\t\t\twhile (i.hasNext()) {\n\t\t\t\t\tDataSource ds = (DataSource) i.next();\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Build path to interface RRD repository. createRRD() will\n\t\t\t\t\t * make the appropriate directories if they do not already\n\t\t\t\t\t * exist.\n\t\t\t\t\t */\n\t\t\t\t\tString ifRepository = m_rrdPath + File.separator\n\t\t\t\t\t\t\t+ String.valueOf(nodeId) + File.separator\n\t\t\t\t\t\t\t+ ifInfo.getLabel();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString dsVal = getRRDValue(ds, ifEntry);\n\n\t\t\t\t\t\t// Build RRD update command\n\t\t\t\t\t\tif (dsVal == null) {\n\t\t\t\t\t\t\t// Do nothing, no update is necessary\n\t\t\t\t\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\t\t\t\"updateRRDs: Skipping update, \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"no data retrieved for \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"node/ifindex: \" + nodeId\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\" + ifIndex\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Call createRRD() to create RRD if it doesn't\n\t\t\t\t\t\t\t * already exist.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t// createRRD(collectionName, ipaddr, ifRepository,\n\t\t\t\t\t\t\t// ds);\n\t\t\t\t\t\t\tif (byNode.equals(\"true\")) {\n\t\t\t\t\t\t\t\tif (ds.performUpdate(collectionName, ipaddr\n\t\t\t\t\t\t\t\t\t\t.getHostAddress(), ifRepository, ds\n\t\t\t\t\t\t\t\t\t\t.getName(), dsVal)) {\n\t\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t\t.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"ds.performUpdate() failed for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"node/ifindex: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ nodeId + \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (storeByIfAlias.equals(\"true\")) {\n\t\t\t\t\t\t\t\tif ((aliasVal != null) && !aliasVal.equals(\"\")) {\n\t\t\t\t\t\t\t\t\tifRepository = m_rrdPath + File.separator\n\t\t\t\t\t\t\t\t\t\t\t+ domain + File.separator\n\t\t\t\t\t\t\t\t\t\t\t+ aliasVal;\n\t\t\t\t\t\t\t\t\tif (ds.performUpdate(collectionName, ipaddr\n\t\t\t\t\t\t\t\t\t\t\t.getHostAddress(), ifRepository, ds\n\t\t\t\t\t\t\t\t\t\t\t.getName(), dsVal)) {\n\t\t\t\t\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t\t\t\t\t.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"updateRRDs: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"ds.performUpdate() failed for \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"node/ifindex/domain/alias: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ nodeId\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ifIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ domain\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ aliasVal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\tlog().warn(\"buildRRDUpdateCmd: \" + e.getMessage());\n\n\t\t\t\t\t\t// Set rrdError flag\n\t\t\t\t\t\trrdError = true;\n\t\t\t\t\t\tlog().warn(\n\t\t\t\t\t\t\t\t\"updateRRDs: call to buildRRDUpdateCmd() \"\n\t\t\t\t\t\t\t\t\t\t+ \"failed for node/ifindex: \" + nodeId\n\t\t\t\t\t\t\t\t\t\t+ \"/\" + ifIndex + \" datasource: \"\n\t\t\t\t\t\t\t\t\t\t+ ds.getName());\n\t\t\t\t\t}\n\n\t\t\t\t} // end while(more datasources)\n\t\t\t} // end while(more SNMP collector entries)\n\t\t} // end if(ifCollector != null)\n\n\t\tif (forceRescan) {\n\t\t\tgenerateForceRescanEvent(ipaddr.getHostAddress(), iface.getNodeId(), eproxy);\n\t\t}\n\t\treturn rrdError;\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map getIfMap(CollectionInterface iface) throws CollectionError {\n\t\tMap ifMap = iface.getIfMap();\n\t\tif (ifMap == null) {\n\t\t\tthrow new CollectionError(\"Interface map not available for \"\n\t\t\t\t\t+ \"interface \" + iface.getHostAddress());\n\t\t}\n\t\treturn ifMap;\n\t}","id":104197,"modified_method":"private void verifyIfMap(CollectionInterface iface, Map ifMap) throws CollectionError {\n\t\tif (ifMap == null) {\n\t\t\tthrow new CollectionError(\"Interface map not available for \"\n\t\t\t\t\t+ \"interface \" + iface.getHostAddress());\n\t\t}\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private NodeInfo getNodeInfo(CollectionInterface iface) throws CollectionError {\n\t\tNodeInfo nodeInfo = iface.getNodeInfo();\n\t\tif (nodeInfo == null) {\n\t\t\tthrow new CollectionError(\"Node info not available for interface \"\n\t\t\t\t\t+ iface.getHostAddress());\n\t\t}\n\t\treturn nodeInfo;\n\t}","id":104198,"modified_method":"private int unexpected(CollectionInterface iface, Throwable t) {\n\t\tlog().error(\n\t\t\t\t\"Unexpected error during node SNMP collection for \"\n\t\t\t\t\t\t+ iface.getHostAddress(), t);\n\t\treturn COLLECTION_FAILED;\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Perform data collection.\n\t * \n\t * @param iface\n\t *            Network interface to be data collected.\n\t * @param eproxy\n\t *            Eventy proxy for sending events.\n\t * @param parameters\n\t *            Key/value pairs from the package to which the interface\n\t *            belongs.\n\t */\n\tpublic int collect(CollectionInterface iface, EventProxy eproxy, Map parameters) {\n\t\ttry {\n\t\t\t// Collect node and interface MIB data from the remote agent\n\n\t\t\tSnmpNodeCollector nodeCollector = null;\n\t\t\t// construct the nodeCollector\n\t\t\tif (!getNodeInfo(iface).getOidList().isEmpty()) {\n\t\t\t\tnodeCollector = new SnmpNodeCollector(iface.getInetAddress(),\n\t\t\t\t\t\tgetNodeInfo(iface).getOidList());\n\t\t\t}\n\n\t\t\tIfNumberTracker ifNumber = null;\n\t\t\tSnmpIfCollector ifCollector = null;\n\t\t\t// construct the ifCollector\n\t\t\tif (iface.hasInterfaceOids()) {\n\t\t\t\tifCollector = new SnmpIfCollector(iface.getInetAddress(),\n\t\t\t\t\t\tgetIfMap(iface));\n\t\t\t\tifNumber = new IfNumberTracker();\n\t\t\t}\n\n\t\t\tcollectData(iface, ifNumber, nodeCollector, ifCollector);\n\n\t\t\tif (iface.hasInterfaceOids()) {\n\t\t\t\tint savedIfCount = iface.getSavedIfCount();\n\n\t\t\t\tint ifCount = ifNumber.getIfNumber();\n\n\t\t\t\tiface.saveIfCount(ifCount);\n\n\t\t\t\tlog().debug(\n\t\t\t\t\t\t\"collect: nodeId: \" + getNodeInfo(iface).getNodeId()\n\t\t\t\t\t\t\t\t+ \" interface: \" + iface.getHostAddress()\n\t\t\t\t\t\t\t\t+ \" ifCount: \" + ifCount + \" savedIfCount: \"\n\t\t\t\t\t\t\t\t+ savedIfCount);\n\n\t\t\t\t/*\n\t\t\t\t * If saved interface count differs from the newly retreived\n\t\t\t\t * interface count the following must occur: 1. generate\n\t\t\t\t * forceRescan event so Capsd will rescan the node, update the\n\t\t\t\t * database, and generate the appropriate events back to the\n\t\t\t\t * poller.\n\t\t\t\t */\n\t\t\t\tif ((savedIfCount != -1) && (ifCount != savedIfCount)) {\n\t\t\t\t\tif (!isForceRescanInProgress(\n\t\t\t\t\t\t\tgetNodeInfo(iface).getNodeId(),\n\t\t\t\t\t\t\tiface.getHostAddress())) {\n\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t.info(\n\t\t\t\t\t\t\t\t\t\t\"Number of interfaces on primary SNMP \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"interface \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ iface.getHostAddress()\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" has changed, generating 'ForceRescan' event.\");\n\t\t\t\t\t\tgenerateForceRescanEvent(iface.getHostAddress(),\n\t\t\t\t\t\t\t\tgetNodeInfo(iface).getNodeId(), eproxy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update RRD with values retrieved in SNMP collection\n\t\t\tboolean rrdError = updateRRDs(getCollectionName(parameters), iface,\n\t\t\t\t\tnodeCollector, ifCollector, parameters, eproxy);\n\n\t\t\tif (rrdError) {\n\t\t\t\tlog().warn(\n\t\t\t\t\t\t\"collect: RRD error during update for \"\n\t\t\t\t\t\t\t\t+ iface.getHostAddress());\n\t\t\t}\n\n\t\t\t// return the status of the collection\n\t\t\treturn COLLECTION_SUCCEEDED;\n\t\t} catch (CollectionError e) {\n\t\t\tif (e.getCause() == null) {\n\t\t\t\tlog().error(e.getMessage());\n\t\t\t} else {\n\t\t\t\tlog().error(e.getMessage(), e.getCause());\n\t\t\t}\n\t\t\treturn COLLECTION_FAILED;\n\t\t} catch (CollectionWarning e) {\n\t\t\tif (e.getCause() == null) {\n\t\t\t\tlog().warn(e.getMessage());\n\t\t\t} else {\n\t\t\t\tlog().warn(e.getMessage(), e.getCause());\n\t\t\t}\n\t\t\treturn COLLECTION_FAILED;\n\t\t} catch (Throwable t) {\n\t\t\tlog().error(\n\t\t\t\t\t\"Unexpected error during node SNMP collection for \"\n\t\t\t\t\t\t\t+ iface.getHostAddress(), t);\n\t\t\treturn COLLECTION_FAILED;\n\t\t}\n\t}","id":104199,"modified_method":"/**\n\t * Perform data collection.\n\t * \n\t * @param iface\n\t *            Network interface to be data collected.\n\t * @param eproxy\n\t *            Eventy proxy for sending events.\n\t * @param parameters\n\t *            Key/value pairs from the package to which the interface\n\t *            belongs.\n\t */\n\tpublic int collect(CollectionInterface iface, EventProxy eproxy, Map parameters) {\n\t\ttry {\n\t\t\t// Collect node and interface MIB data from the remote agent\n\n\t\t\tSnmpNodeCollector nodeCollector = null;\n\t\t\t// construct the nodeCollector\n\t\t\tif (!iface.getNodeOidList().isEmpty()) {\n\t\t\t\tnodeCollector = new SnmpNodeCollector(iface.getInetAddress(), iface.getNodeOidList());\n\t\t\t}\n\n\t\t\tIfNumberTracker ifNumber = null;\n\t\t\tSnmpIfCollector ifCollector = null;\n\t\t\t// construct the ifCollector\n\t\t\tif (iface.hasInterfaceOids()) {\n\t\t\t\tifCollector = new SnmpIfCollector(iface.getInetAddress(), iface.getCombinedInterfaceOids());\n\t\t\t\tifNumber = new IfNumberTracker();\n\t\t\t}\n\n\t\t\tcollectData(iface, ifNumber, nodeCollector, ifCollector);\n\n\t\t\tif (iface.hasInterfaceOids()) {\n\t\t\t\tint savedIfCount = iface.getSavedIfCount();\n\n\t\t\t\tint ifCount = ifNumber.getIfNumber();\n\n\t\t\t\tiface.saveIfCount(ifCount);\n\n\t\t\t\tlog().debug(\n\t\t\t\t\t\t\"collect: nodeId: \" + iface.getNodeId()\n\t\t\t\t\t\t\t\t+ \" interface: \" + iface.getHostAddress()\n\t\t\t\t\t\t\t\t+ \" ifCount: \" + ifCount + \" savedIfCount: \"\n\t\t\t\t\t\t\t\t+ savedIfCount);\n\n\t\t\t\t/*\n\t\t\t\t * If saved interface count differs from the newly retreived\n\t\t\t\t * interface count the following must occur: 1. generate\n\t\t\t\t * forceRescan event so Capsd will rescan the node, update the\n\t\t\t\t * database, and generate the appropriate events back to the\n\t\t\t\t * poller.\n\t\t\t\t */\n\t\t\t\tif ((savedIfCount != -1) && (ifCount != savedIfCount)) {\n\t\t\t\t\tif (!isForceRescanInProgress(\n\t\t\t\t\t\t\tiface.getNodeId(),\n\t\t\t\t\t\t\tiface.getHostAddress())) {\n\t\t\t\t\t\tlog()\n\t\t\t\t\t\t\t\t.info(\n\t\t\t\t\t\t\t\t\t\t\"Number of interfaces on primary SNMP \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"interface \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ iface.getHostAddress()\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" has changed, generating 'ForceRescan' event.\");\n\t\t\t\t\t\tgenerateForceRescanEvent(iface.getHostAddress(),\n\t\t\t\t\t\t\t\tiface.getNodeId(), eproxy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update RRD with values retrieved in SNMP collection\n\t\t\tboolean rrdError = updateRRDs(getCollectionName(parameters), iface,\n\t\t\t\t\tnodeCollector, ifCollector, parameters, eproxy);\n\n\t\t\tif (rrdError) {\n\t\t\t\tlog().warn(\n\t\t\t\t\t\t\"collect: RRD error during update for \"\n\t\t\t\t\t\t\t\t+ iface.getHostAddress());\n\t\t\t}\n\n\t\t\t// return the status of the collection\n\t\t\treturn COLLECTION_SUCCEEDED;\n\t\t} catch (CollectionError e) {\n\t\t\treturn collectionError(e);\n\t\t} catch (CollectionWarning e) {\n\t\t\treturn collectionWarning(e);\n\t\t} catch (Throwable t) {\n\t\t\treturn unexpected(iface, t);\n\t\t}\n\t}","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The class constructor is used to initialize the collector and send out\n     * the initial SNMP packet requesting data. The data is then received and\n     * store by the object. When all the data has been collected the passed\n     * signaler object is <EM>notified<\/EM> using the notifyAll() method.\n     * @param address \n     * @param ifMap\n     *            Map of org.opennms.netmgt.poller.collectd.IfInfo objects.\n     */\n    public SnmpIfCollector(InetAddress address, Map ifMap) {\n        super(MibObject.getCollectionTrackers(SnmpIfCollector.buildV2CombinedOidList(ifMap)));\n\n        // Process parameters\n        //\n        m_primaryIf = address.getHostAddress();\n        m_objList = SnmpIfCollector.buildV2CombinedOidList(ifMap);\n\n\n    }","id":104200,"modified_method":"/**\n     * The class constructor is used to initialize the collector and send out\n     * the initial SNMP packet requesting data. The data is then received and\n     * store by the object. When all the data has been collected the passed\n     * signaler object is <EM>notified<\/EM> using the notifyAll() method.\n     * @param address \n\t * @param objList TODO\n\t * @param ifMap\n     *            Map of org.opennms.netmgt.poller.collectd.IfInfo objects.\n     */\n    public SnmpIfCollector(InetAddress address, List objList) {\n        super(MibObject.getCollectionTrackers(appendIfAlias(objList)));\n\n        // Process parameters\n        //\n        m_primaryIf = address.getHostAddress();\n        m_objList = appendIfAlias(objList);\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testZeroVars() throws Exception {\n        IfInfo ifInfo = createIfInfo(1, 24, \"lo\", CollectionType.PRIMARY);\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = createSnmpIfCollector();\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","id":104201,"modified_method":"public void testZeroVars() throws Exception {\n        addIfInfo(createIfInfo(1, 24, \"lo\", CollectionType.PRIMARY));\n        \n        SnmpIfCollector collector = createSnmpIfCollector();\n        waitForSignal();\n        \n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private IfInfo createIfInfo(int ifIndex, int ifType, String ifName, CollectionType ifCollType) {\n    \tOnmsNode node = new OnmsNode();\n\n    \tOnmsIpInterface iface = new OnmsIpInterface();\n    \tiface.setIfIndex(new Integer(ifIndex));\n    \tiface.setIsSnmpPrimary(ifCollType);\n    \tnode.addIpInterface(iface);\n\n    \tOnmsSnmpInterface snmpIface = new OnmsSnmpInterface();\n    \tsnmpIface.setIfIndex(new Integer(ifIndex));\n    \tsnmpIface.setIfType(new Integer(ifType));\n    \tsnmpIface.setIfName(ifName);\n    \tnode.addSnmpInterface(snmpIface);\n\n    \tIfInfo ifInfo = new IfInfo(snmpIface);\n        ifInfo.setOidList(new ArrayList(m_objList));\n        return ifInfo;\n    }","id":104202,"modified_method":"private IfInfo createIfInfo(int ifIndex, int ifType, String ifName, CollectionType ifCollType) {\n    \tOnmsNode m_node = new OnmsNode();\n\n    \tOnmsIpInterface m_iface = new OnmsIpInterface();\n    \tm_iface.setIfIndex(new Integer(ifIndex));\n    \tm_iface.setIsSnmpPrimary(ifCollType);\n    \tm_node.addIpInterface(m_iface);\n\n    \tOnmsSnmpInterface m_snmpIface = new OnmsSnmpInterface();\n    \tm_snmpIface.setIfIndex(new Integer(ifIndex));\n    \tm_snmpIface.setIfType(new Integer(ifType));\n    \tm_snmpIface.setIfName(ifName);\n    \tm_node.addSnmpInterface(m_snmpIface);\n\n    \tCollectionInterface m_collectionInterface = new CollectionInterface(m_iface);\n\t\tIfInfo ifInfo = new IfInfo(m_collectionInterface, \"default\", m_snmpIface);\n        ifInfo.setOidList(new ArrayList(m_objList));\n        return ifInfo;\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testInvalidVar() throws Exception {\n        IfInfo ifInfo = createIfInfo(1, 24, \"lo\", CollectionType.PRIMARY);\n        \n        addMibObject(\"invalid\", \"1.3.6.1.2.1.2.2.2.10\", \"ifIndex\", \"counter\");\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = createSnmpIfCollector();\n        waitForSignal();\n        \n        // remove the failing element.  Now entries should match\n        m_objList.remove(0);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","id":104203,"modified_method":"public void testInvalidVar() throws Exception {\n        addMibObject(\"invalid\", \"1.3.6.1.2.1.2.2.2.10\", \"ifIndex\", \"counter\");\n        \n        addIfInfo(createIfInfo(1, 24, \"lo\", CollectionType.PRIMARY));\n        \n        SnmpIfCollector collector = createSnmpIfCollector();\n        waitForSignal();\n        \n        // remove the failing element.  Now entries should match\n        m_objList.remove(0);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpIfCollector createSnmpIfCollector() throws UnknownHostException {\n        SnmpIfCollector collector = new SnmpIfCollector(InetAddress.getLocalHost(), m_ifMap);\n        SnmpAgentConfig agentConfig = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getLocalHost());\n        m_walker = SnmpUtils.createWalker(agentConfig, \"snmpIfCollector\", collector);\n        m_walker.start();\n        return collector;\n    }","id":104204,"modified_method":"private SnmpIfCollector createSnmpIfCollector() throws UnknownHostException {\n        SnmpIfCollector collector = new SnmpIfCollector(InetAddress.getLocalHost(), new CollectionInterface(null).getCombinedInterfaceOids());\n        SnmpAgentConfig agentConfig = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getLocalHost());\n        m_walker = SnmpUtils.createWalker(agentConfig, \"snmpIfCollector\", collector);\n        m_walker.start();\n        return collector;\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBadApple() throws Exception {\n\n        IfInfo ifInfo = createIfInfo(1, 24, \"lo\", CollectionType.PRIMARY);\n        \n        addIfSpeed();\n        addIfInOctets();\n        // the oid below is wrong.  Make sure we collect the others anyway\n        addMibObject(\"invalid\", \"1.3.66.1.2.1.2.2.299.16\", \"ifIndex\", \"counter\");\n        addIfInErrors();\n        addIfOutErrors();\n        addIfInDiscards();\n        \n        ifInfo.setOidList(new ArrayList(m_objList));\n        \n        addIfInfo(ifInfo);\n        \n        SnmpIfCollector collector = createSnmpIfCollector();\n        waitForSignal();\n        \n        // remove the bad apple before compare\n        m_objList.remove(2);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","id":104205,"modified_method":"public void testBadApple() throws Exception {\n\n        addIfSpeed();\n        addIfInOctets();\n        // the oid below is wrong.  Make sure we collect the others anyway\n        addMibObject(\"invalid\", \"1.3.66.1.2.1.2.2.299.16\", \"ifIndex\", \"counter\");\n        addIfInErrors();\n        addIfOutErrors();\n        addIfInDiscards();\n        \n        addIfInfo(createIfInfo(1, 24, \"lo\", CollectionType.PRIMARY));\n        \n        SnmpIfCollector collector = createSnmpIfCollector();\n        waitForSignal();\n        \n        // remove the bad apple before compare\n        m_objList.remove(2);\n        assertInterfaceMibObjectsPresent(collector.getEntries());\n    }","commit_id":"16b63d44ffd3d4d737ed04a1e472efa90978f589","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void giveMediaRecorderHintRotatedScreen(final MapActivity mapActivity, final MediaRecorder mr) {\n\t\tif (Build.VERSION.SDK_INT >= 9) {\n\t\t\ttry {\n\t\t\t\tMethod m = mr.getClass().getDeclaredMethod(\"setOrientationHint\", Integer.TYPE);\n\t\t\t\tDisplay display = ((WindowManager) mapActivity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n\t\t\t\tif (display.getRotation() == Surface.ROTATION_0) {\n\t\t\t\t\tm.invoke(mr, 90);\n\t\t\t\t} else if (display.getRotation() == Surface.ROTATION_270) {\n\t\t\t\t\tm.invoke(mr, 180);\n\t\t\t\t} else if (display.getRotation() == Surface.ROTATION_180) {\n\t\t\t\t\tm.invoke(mr, 270);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","id":104206,"modified_method":"private void giveMediaRecorderHintRotatedScreen(final MapActivity mapActivity, final MediaRecorder mr) {\n\t\tif (Build.VERSION.SDK_INT >= 9) {\n\t\t\ttry {\n\t\t\t\tMethod m = mr.getClass().getDeclaredMethod(\"setOrientationHint\", Integer.TYPE);\n\t\t\t\tDisplay display = ((WindowManager) mapActivity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n\t\t\t\tif (display.getOrientation() == Surface.ROTATION_0) {\n\t\t\t\t\tm.invoke(mr, 90);\n\t\t\t\t} else if (display.getOrientation() == Surface.ROTATION_270) {\n\t\t\t\t\tm.invoke(mr, 180);\n\t\t\t\t} else if (display.getOrientation() == Surface.ROTATION_180) {\n\t\t\t\t\tm.invoke(mr, 270);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c8fe023c2be4ab4bb6dc68ade1b0b4fc3209a773","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void updatePhotoInformation(double lat, double lon, double rot) throws IOException{\n\t\t\tExifInterface exif = new ExifInterface(file.getAbsolutePath());\n\t\t\texif.setAttribute(ExifInterface.TAG_GPS_LATITUDE, convertDegToExifRational(lat));\n\t\t\texif.setAttribute(ExifInterface.TAG_GPS_LATITUDE_REF, lat > 0 ?\"N\" :\"S\");\n\t        exif.setAttribute(ExifInterface.TAG_GPS_LONGITUDE, convertDegToExifRational(lon));\n\t        exif.setAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF, lon > 0?\"E\" : \"W\");\n\t        if(!Double.isNaN(rot)){\n\t        \texif.setAttribute(\"GPSImgDirectionRef\", \"T\"); //true north\n\t        \tString rotString = (int) (rot * 100.0) + \"/100\";\n\t        \t//log.info(\"rot rational: \" + rotString);\n\t        \texif.setAttribute(\"GPSImgDirection\", rotString);\n\t        }\n\t        exif.saveAttributes();\n\t\t}","id":104207,"modified_method":"@SuppressWarnings(\"rawtypes\")\n\t\tpublic void updatePhotoInformation(double lat, double lon, double rot) throws IOException {\n\t\t\ttry {\n\t\t\t\tClass exClass = Class.forName(\"android.media.ExifInterface\");\n\t\t\t\t\n\t\t\t\tConstructor c = exClass.getConstructor(new Class[] { String.class });\n\t\t\t\tObject exInstance = c.newInstance(file.getAbsolutePath());\n\t\t\t\tMethod setAttribute = exClass.getMethod(\"setAttribute\",\n\t\t\t\t           new Class[] { String.class, String.class } );\n\t\t\t\tsetAttribute.invoke(exInstance,\"GPSLatitude\", convertDegToExifRational(lat));\n\t\t\t\tsetAttribute.invoke(exInstance,\"GPSLatitudeRef\", lat > 0 ?\"N\" :\"S\");\n\t\t\t\tsetAttribute.invoke(exInstance,\"GPSLongitude\", convertDegToExifRational(lon));\n\t\t\t\tsetAttribute.invoke(exInstance,\"GPSLongitudeRef\", lon > 0?\"E\" : \"W\");\n\t\t\t\tif(!Double.isNaN(rot)){\n\t\t\t\t\tsetAttribute.invoke(exInstance,\"GPSImgDirectionRef\", \"T\");\n\t\t\t\t\tString rotString = (int) (rot * 100.0) + \"/100\";\n\t\t\t\t\tsetAttribute.invoke(exInstance,\"GPSImgDirection\", rotString);\n\t\t\t\t}\n\t\t\t\tMethod saveAttributes = exClass.getMethod(\"saveAttributes\",\n\t\t\t\t           new Class[] {} );\n\t\t\t\tsaveAttributes.invoke(exInstance);\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tlog.error(e);\n\t\t\t}\n\t\t}","commit_id":"c8fe023c2be4ab4bb6dc68ade1b0b4fc3209a773","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private int getExifOrientation() {\n\t\t\tExifInterface exif;\n\t\t\tint orientation = 0;\n\t\t\ttry {\n\t\t\t\texif = new ExifInterface(file.getAbsolutePath());\n\t\t\t\torientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn orientation;\n\t\t}","id":104208,"modified_method":"@SuppressWarnings(\"rawtypes\")\n\t\tprivate int getExifOrientation() {\n\t\t\tint orientation = 0;\n\t\t\ttry {\n\t\t\t\tClass exClass = Class.forName(\"android.media.ExifInterface\");\n\n\t\t\t\tConstructor c = exClass.getConstructor(new Class[] { String.class });\n\t\t\t\tObject exInstance = c.newInstance(file.getAbsolutePath());\n\t\t\t\tMethod getAttributeInt = exClass.getMethod(\"getAttributeInt\",\n\t\t\t\t           new Class[] { String.class, Integer.TYPE} );\n\t\t\t\tInteger it = (Integer) getAttributeInt.invoke(exInstance, \"Orientation\", new Integer(1));\n\t\t\t\torientation = it.intValue();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tlog.error(e);\n\t\t\t}\n\t\t\treturn orientation;\n\t\t}","commit_id":"c8fe023c2be4ab4bb6dc68ade1b0b4fc3209a773","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void addCriteriaForService(OnmsCriteria criteria, int serviceId) {\n        criteria.createAlias(\"node.ipInterfaces\", \"ipInterface\");\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices\", \"monitoredService\");\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices.serviceType\", \"serviceType\");\n        criteria.add(Restrictions.eq(\"serviceType.id\", serviceId));\n    }","id":104209,"modified_method":"private void addCriteriaForService(OnmsCriteria criteria, int serviceId) {\n        criteria.createAlias(\"node.ipInterfaces\", \"ipInterface\");\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices\", \"monitoredService\");\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices.serviceType\", \"serviceType\");\n        criteria.add(Restrictions.eq(\"serviceType.id\", serviceId));\n        criteria.add(Restrictions.ne(\"monitoredService.status\", \"D\"));\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, GenericIndexResourceType> getGenericIndexResourceTypes() {\n        Map<String, GenericIndexResourceType> resourceTypes;\n        resourceTypes = new LinkedHashMap<String, GenericIndexResourceType>();\n\n        Map<String, org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n            m_dataCollectionConfig.getConfiguredResourceTypes();\n        for (org.opennms.netmgt.config.datacollection.ResourceType resourceType : configuredResourceTypes.values()) {\n            String className = resourceType.getStorageStrategy().getClazz();\n            Class<?> cinst;\n            try {\n                cinst = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not load class\",\n                                                          e);\n            }\n            StorageStrategy storageStrategy;\n            try {\n                storageStrategy = (StorageStrategy) cinst.newInstance();\n            } catch (InstantiationException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not instantiate\",\n                                                          e);\n            } catch (IllegalAccessException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not instantiate\",\n                                                          e);\n            }\n            \n            storageStrategy.setResourceTypeName(resourceType.getName());\n            \n            GenericIndexResourceType genericIndexResourceType =\n                new GenericIndexResourceType(this,\n                                                  resourceType.getName(),\n                                                  resourceType.getLabel(),\n                                                  resourceType.getResourceLabel(),\n                                                  storageStrategy);\n            resourceTypes.put(genericIndexResourceType.getName(), genericIndexResourceType);\n        }\n        return resourceTypes;\n    }","id":104210,"modified_method":"private Map<String, GenericIndexResourceType> getGenericIndexResourceTypes() {\n        Map<String, GenericIndexResourceType> resourceTypes;\n        resourceTypes = new LinkedHashMap<String, GenericIndexResourceType>();\n\n        Map<String, org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n            m_dataCollectionConfig.getConfiguredResourceTypes();\n        for (org.opennms.netmgt.config.datacollection.ResourceType resourceType : configuredResourceTypes.values()) {\n            String className = resourceType.getStorageStrategy().getClazz();\n            Class<?> cinst;\n            try {\n                cinst = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                   \"Could not load class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            }\n            StorageStrategy storageStrategy;\n            try {\n                storageStrategy = (StorageStrategy) cinst.newInstance();\n            } catch (InstantiationException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                    \"Could not instantiate class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            } catch (IllegalAccessException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                    \"Could not instantiate class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            }\n            \n            storageStrategy.setResourceTypeName(resourceType.getName());\n            \n            GenericIndexResourceType genericIndexResourceType =\n                new GenericIndexResourceType(this,\n                                                  resourceType.getName(),\n                                                  resourceType.getLabel(),\n                                                  resourceType.getResourceLabel(),\n                                                  storageStrategy);\n            resourceTypes.put(genericIndexResourceType.getName(), genericIndexResourceType);\n        }\n        return resourceTypes;\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void checkServerXmlOldOpennmsContext() throws Exception {\n        String search_regexp = \"(?ms).*<Context\\\\s+path=\\\"/opennms\\\".*\";\n        StringBuffer b = new StringBuffer();\n\n        File f = new File(m_webappdir + File.separator + \"..\"\n                + File.separator + \"conf\" + File.separator + \"server.xml\");\n\n        m_out.print(\"- Checking for old opennms context in \"\n                + f.getAbsolutePath() + \"... \");\n\n        if (!f.exists()) {\n            m_out.println(\"DID NOT CHECK (file does not exist)\");\n            return;\n        }\n\n        BufferedReader r = new BufferedReader(new FileReader(f));\n        String line;\n\n        while ((line = r.readLine()) != null) {\n            b.append(line);\n            b.append(\"\\n\");\n        }\n        r.close();\n\n        if (b.toString().matches(search_regexp)) {\n            throw new Exception(\n                                \"Old OpenNMS context found in \"\n                                        + f.getAbsolutePath()\n                                        + \".  \"\n                                        + \"You must remove this context from server.xml and re-run the \"\n                                        + \"installer.\");\n        }\n\n        m_out.println(\"OK\");\n\n        return;\n    }","id":104211,"modified_method":"public void checkServerXmlOldOpennmsContext() throws Exception {\n        String search_regexp = \"(?ms).*<Context\\\\s+path=\\\"/opennms\\\".*\";\n        StringBuffer b = new StringBuffer();\n\n        File f = new File(m_webappdir + File.separator + \"..\"\n                + File.separator + \"conf\" + File.separator + \"server.xml\");\n\n        m_out.print(\"- Checking for old opennms context in \"\n                + f.getAbsolutePath() + \"... \");\n\n        if (!f.exists()) {\n            m_out.println(\"DID NOT CHECK (file does not exist)\");\n            return;\n        }\n\n        FileReader fr = new FileReader(f);\n        BufferedReader r = new BufferedReader(fr);\n        String line;\n\n        while ((line = r.readLine()) != null) {\n            b.append(line);\n            b.append(\"\\n\");\n        }\n        r.close();\n        fr.close();\n\n        if (b.toString().matches(search_regexp)) {\n            throw new Exception(\"Old OpenNMS context found in \" + f.getAbsolutePath() +\n                                \".  You must remove this context from server.xml and re-run the installer.\");\n        }\n\n        m_out.println(\"OK\");\n\n        return;\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void parseArguments(String[] argv) throws Exception {\n\n        options.addOption(\"h\", \"help\", false, \"this help\");\n\n        // database-related options\n        options.addOption(\"d\", \"do-database\", false,\n                          \"perform database actions\");\n\n        options.addOption(\"Z\", \"remove-database\", false,\n                          \"remove the OpenNMS database\");\n        \n        options.addOption(\"u\", \"username\", true,\n                          \"username of the database account (default: 'opennms')\");\n        options.addOption(\"p\", \"password\", true,\n                          \"password of the database account (default: 'opennms')\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"username of the database administrator (default: 'postgres')\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"password of the database administrator (default: '')\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"JDBC database URL (default: jdbc:postgresql://localhost:5432/\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"name of the PostgreSQL database (default: opennms)\");\n\n        options.addOption(\"c\", \"clean-database\", false,\n                          \"clean existing database before creating\");\n        options.addOption(\"i\", \"insert-data\", false,\n                          \"insert default data into the database\");\n        options.addOption(\"s\", \"stored-procedure\", false,\n                          \"add the IPLIKE stored procedure if it's missing\");\n        options.addOption(\"U\", \"unicode\", false,\n                          \"upgrade the database to Unicode (deprecated, does nothing)\");\n        options.addOption(\"v\", \"vacuum\", false,\n                          \"vacuum (optimize) the database\");\n        options.addOption(\"f\", \"vacuum-full\", false,\n                          \"vacuum full the database (recovers unused disk space)\");\n        options.addOption(\"N\", \"ignore-not-null\", false,\n                          \"ignore NOT NULL constraint when transforming data\");\n        options.addOption(\"Q\", \"ignore-database-version\", false,\n                          \"disable the database version check\");\n\n        options.addOption(\"x\", \"database-debug\", false,\n                          \"turn on debugging for the database data transformation\");\n        options.addOption(\"R\", \"do-not-revert\", false,\n                          \"do not revert a table to the original if an error occurs\");\n        options.addOption(\"n\", \"skip-constraint\", false, \"\");\n        options.addOption(\"C\", \"repair-constraint\", true,\n                          \"fix rows that violate the specified constraint (sets key column to NULL)\");\n        options.addOption(\"X\", \"drop-constraint\", false,\n                          \"drop rows that match the constraint specified in -C, instead of fixing them\");\n\n        // tomcat-related options\n        options.addOption(\"y\", \"do-webapp\", false,\n                          \"install web application (see '-w')\");\n        options.addOption(\"T\", \"tomcat-conf\", true, \"location of tomcat.conf\");\n        options.addOption(\"w\", \"tomcat-context\", true,\n                          \"location of the tomcat context (eg, conf/Catalina/localhost)\");\n\n        // general installation options\n        options.addOption(\"l\", \"library-path\", true,\n                          \"library search path (directories separated by '\"\n                                  + File.pathSeparator + \"')\");\n        options.addOption(\"r\", \"rpm-install\", false,\n                          \"RPM install (deprecated)\");\n\n        CommandLineParser parser = new PosixParser();\n        m_commandLine = parser.parse(options, argv);\n\n        if (m_commandLine.hasOption(\"h\")) {\n            usage(options, m_commandLine);\n            System.exit(0);\n        }\n\n        options.addOption(\"u\", \"username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"p\", \"password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"replaced by opennms-datasources.xml\");\n\n        if (m_commandLine.hasOption(\"u\")\n                || m_commandLine.hasOption(\"p\")\n                || m_commandLine.hasOption(\"a\")\n                || m_commandLine.hasOption(\"A\")\n                || m_commandLine.hasOption(\"D\")\n                || m_commandLine.hasOption(\"P\")) {\n            usage(\n                  options,\n                  m_commandLine,\n                  \"The 'u', 'p', 'a', 'A', 'D', and 'P' options have all been superceded.\\nPlease edit $OPENNMS_HOME/etc/opennms-datasources.xml instead.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_force = m_commandLine.hasOption(\"c\");\n        m_fix_constraint = m_commandLine.hasOption(\"C\");\n        m_fix_constraint_name = m_commandLine.getOptionValue(\"C\");\n        m_update_database = m_commandLine.hasOption(\"d\");\n        m_remove_database = m_commandLine.hasOption(\"Z\");\n        m_do_full_vacuum = m_commandLine.hasOption(\"f\");\n        m_do_inserts = m_commandLine.hasOption(\"i\");\n        m_library_search_path = m_commandLine.getOptionValue(\"l\",\n                                                             m_library_search_path);\n        m_skip_constraints = m_commandLine.hasOption(\"n\");\n        m_ignore_not_null = m_commandLine.hasOption(\"N\");\n        m_ignore_database_version = m_commandLine.hasOption(\"Q\");\n        m_do_not_revert = m_commandLine.hasOption(\"R\");\n        m_update_iplike = m_commandLine.hasOption(\"s\");\n        m_tomcat_conf = m_commandLine.getOptionValue(\"T\", m_tomcat_conf);\n        m_update_unicode = m_commandLine.hasOption(\"U\");\n        m_do_vacuum = m_commandLine.hasOption(\"v\");\n        m_webappdir = m_commandLine.getOptionValue(\"w\", m_webappdir);\n        m_installerDb.setDebug(m_commandLine.hasOption(\"x\"));\n        m_fix_constraint_remove_rows = m_commandLine.hasOption(\"X\");\n        m_install_webapp = m_commandLine.hasOption(\"y\");\n\n        if (m_commandLine.getArgList().size() > 0) {\n            usage(options, m_commandLine, \"Unknown command-line arguments: \"\n                    + m_commandLine.getArgs(), null);\n            System.exit(1);\n        }\n    }","id":104212,"modified_method":"public void parseArguments(String[] argv) throws Exception {\n\n        options.addOption(\"h\", \"help\", false, \"this help\");\n\n        // database-related options\n        options.addOption(\"d\", \"do-database\", false,\n                          \"perform database actions\");\n\n        options.addOption(\"Z\", \"remove-database\", false,\n                          \"remove the OpenNMS database\");\n        \n        options.addOption(\"u\", \"username\", true,\n                          \"username of the database account (default: 'opennms')\");\n        options.addOption(\"p\", \"password\", true,\n                          \"password of the database account (default: 'opennms')\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"username of the database administrator (default: 'postgres')\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"password of the database administrator (default: '')\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"JDBC database URL (default: jdbc:postgresql://localhost:5432/\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"name of the PostgreSQL database (default: opennms)\");\n\n        options.addOption(\"c\", \"clean-database\", false,\n                          \"clean existing database before creating\");\n        options.addOption(\"i\", \"insert-data\", false,\n                          \"insert default data into the database\");\n        options.addOption(\"s\", \"stored-procedure\", false,\n                          \"add the IPLIKE stored procedure if it's missing\");\n        options.addOption(\"U\", \"unicode\", false,\n                          \"upgrade the database to Unicode (deprecated, does nothing)\");\n        options.addOption(\"v\", \"vacuum\", false,\n                          \"vacuum (optimize) the database\");\n        options.addOption(\"f\", \"vacuum-full\", false,\n                          \"vacuum full the database (recovers unused disk space)\");\n        options.addOption(\"N\", \"ignore-not-null\", false,\n                          \"ignore NOT NULL constraint when transforming data\");\n        options.addOption(\"Q\", \"ignore-database-version\", false,\n                          \"disable the database version check\");\n\n        options.addOption(\"x\", \"database-debug\", false,\n                          \"turn on debugging for the database data transformation\");\n        options.addOption(\"R\", \"do-not-revert\", false,\n                          \"do not revert a table to the original if an error occurs\");\n        options.addOption(\"n\", \"skip-constraint\", false, \"\");\n        options.addOption(\"C\", \"repair-constraint\", true,\n                          \"fix rows that violate the specified constraint (sets key column to NULL)\");\n        options.addOption(\"X\", \"drop-constraint\", false,\n                          \"drop rows that match the constraint specified in -C, instead of fixing them\");\n\n        // tomcat-related options\n        options.addOption(\"y\", \"do-webapp\", false,\n                          \"install web application (see '-w')\");\n        options.addOption(\"T\", \"tomcat-conf\", true, \"location of tomcat.conf\");\n        options.addOption(\"w\", \"tomcat-context\", true,\n                          \"location of the tomcat context (eg, conf/Catalina/localhost)\");\n\n        // general installation options\n        options.addOption(\"l\", \"library-path\", true,\n                          \"library search path (directories separated by '\"\n                                  + File.pathSeparator + \"')\");\n        options.addOption(\"r\", \"rpm-install\", false,\n                          \"RPM install (deprecated)\");\n\n        CommandLineParser parser = new PosixParser();\n        m_commandLine = parser.parse(options, argv);\n\n        if (m_commandLine.hasOption(\"h\")) {\n            usage(options, m_commandLine);\n            System.exit(0);\n        }\n\n        options.addOption(\"u\", \"username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"p\", \"password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"replaced by opennms-datasources.xml\");\n\n        if (m_commandLine.hasOption(\"u\")\n                || m_commandLine.hasOption(\"p\")\n                || m_commandLine.hasOption(\"a\")\n                || m_commandLine.hasOption(\"A\")\n                || m_commandLine.hasOption(\"D\")\n                || m_commandLine.hasOption(\"P\")) {\n            usage(\n                  options,\n                  m_commandLine,\n                  \"The 'u', 'p', 'a', 'A', 'D', and 'P' options have all been superceded.\\nPlease edit $OPENNMS_HOME/etc/opennms-datasources.xml instead.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_force = m_commandLine.hasOption(\"c\");\n        m_fix_constraint = m_commandLine.hasOption(\"C\");\n        m_fix_constraint_name = m_commandLine.getOptionValue(\"C\");\n        m_update_database = m_commandLine.hasOption(\"d\");\n        m_remove_database = m_commandLine.hasOption(\"Z\");\n        m_do_full_vacuum = m_commandLine.hasOption(\"f\");\n        m_do_inserts = m_commandLine.hasOption(\"i\");\n        m_library_search_path = m_commandLine.getOptionValue(\"l\", m_library_search_path);\n        m_skip_constraints = m_commandLine.hasOption(\"n\");\n        m_ignore_not_null = m_commandLine.hasOption(\"N\");\n        m_ignore_database_version = m_commandLine.hasOption(\"Q\");\n        m_do_not_revert = m_commandLine.hasOption(\"R\");\n        m_update_iplike = m_commandLine.hasOption(\"s\");\n        m_tomcat_conf = m_commandLine.getOptionValue(\"T\", m_tomcat_conf);\n        m_update_unicode = m_commandLine.hasOption(\"U\");\n        m_do_vacuum = m_commandLine.hasOption(\"v\");\n        m_webappdir = m_commandLine.getOptionValue(\"w\", m_webappdir);\n        m_installerDb.setDebug(m_commandLine.hasOption(\"x\"));\n        m_fix_constraint_remove_rows = m_commandLine.hasOption(\"X\");\n        m_install_webapp = m_commandLine.hasOption(\"y\");\n\n        if (m_commandLine.getArgList().size() > 0) {\n            usage(options, m_commandLine, \"Unknown command-line arguments: \"\n                    + Arrays.toString(m_commandLine.getArgs()), null);\n            System.exit(1);\n        }\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void printHeader() {\n        m_out.println(\"===============================================\"\n                + \"===============================\");\n        m_out.println(\"OpenNMS Installer Version \" + s_version);\n        m_out.println(\"===============================================\"\n                + \"===============================\");\n        m_out.println(\"\");\n        m_out.println(\"Configures PostgreSQL tables, users, and other \"\n                + \"miscellaneous settings.\");\n        m_out.println(\"\");\n    }","id":104213,"modified_method":"public void printHeader() {\n        m_out.println(\"==============================================================================\");\n        m_out.println(\"OpenNMS Installer Version \" + s_version);\n        m_out.println(\"==============================================================================\");\n        m_out.println(\"\");\n        m_out.println(\"Configures PostgreSQL tables, users, and other miscellaneous settings.\");\n        m_out.println(\"\");\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            usage(options, m_commandLine, \"Nothing to do.  Use -h for help.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_installerDb.setForce(m_force);\n        m_installerDb.setIgnoreNotNull(m_ignore_not_null);\n        m_installerDb.setNoRevert(m_do_not_revert);\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);\n        \n        JdbcDataSource adminDs = C3P0ConnectionFactory.marshalDataSourceFromConfig(new FileReader(cfgFile), ADMIN_DATA_SOURCE_NAME);\n        m_installerDb.setAdminDataSource(new SimpleDataSource(adminDs));\n\n        JdbcDataSource ds = C3P0ConnectionFactory.marshalDataSourceFromConfig(new FileReader(cfgFile), OPENNMS_DATA_SOURCE_NAME);\n        m_installerDb.setDataSource(new SimpleDataSource(ds));\n        \n        m_installerDb.setPostgresOpennmsUser(ds.getUserName());\n        m_installerDb.setPostgresOpennmsPassword(ds.getPassword());\n        m_installerDb.setDatabaseName(ds.getDatabaseName());\n\n        /*\n         * make sure we can load the ICMP library before we go any farther\n         */\n\n        if (!Boolean.getBoolean(\"skip-native\")) {\n            String icmp_path = findLibrary(\"jicmp\", m_library_search_path, true);\n            String jrrd_path = findLibrary(\"jrrd\", m_library_search_path, false);\n            writeLibraryConfig(icmp_path, jrrd_path);\n        }\n        \n        /*\n         * Everything needs to use the administrative data source until we\n         * verify that the opennms database is created below (and where we\n         * create it if it doesn't already exist).\n         */\n\n        // XXX Check Tomcat version?\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            if (!m_ignore_database_version) {\n                m_installerDb.databaseCheckVersion();\n            }\n            m_installerDb.databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        m_installerDb.checkUnicode();\n\n        // We can now use the opennms database\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.addColumnReplacements();\n            m_installerDb.createTables();\n            m_installerDb.closeColumnReplacements();\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_out.println(\"WARNING: the -U option is deprecated, it does nothing now\");\n        }\n\n        if (m_do_vacuum) {\n            m_installerDb.vacuumDatabase(m_do_full_vacuum);\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database && m_remove_database) {\n            m_installerDb.disconnect();\n            m_installerDb.databaseRemoveDB();\n        }\n\n        m_installerDb.disconnect();\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","id":104214,"modified_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        boolean doDatabase = (m_update_database || m_do_inserts || m_update_iplike || m_update_unicode || m_fix_constraint);\n        \n        if (!doDatabase && m_tomcat_conf == null && !m_install_webapp && m_library_search_path == null) {\n            usage(options, m_commandLine, \"Nothing to do.  Use -h for help.\", null);\n            System.exit(1);\n        }\n\n        if (doDatabase) {\n            m_installerDb.setForce(m_force);\n            m_installerDb.setIgnoreNotNull(m_ignore_not_null);\n            m_installerDb.setNoRevert(m_do_not_revert);\n    \n            File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);\n            \n            Reader fr = new FileReader(cfgFile);\n            JdbcDataSource adminDs = C3P0ConnectionFactory.marshalDataSourceFromConfig(fr, ADMIN_DATA_SOURCE_NAME);\n            fr.close();\n            m_installerDb.setAdminDataSource(new SimpleDataSource(adminDs));\n\n            fr = new FileReader(cfgFile);\n            JdbcDataSource ds = C3P0ConnectionFactory.marshalDataSourceFromConfig(fr, OPENNMS_DATA_SOURCE_NAME);\n            m_installerDb.setDataSource(new SimpleDataSource(ds));\n            fr.close();\n\n            m_installerDb.setPostgresOpennmsUser(ds.getUserName());\n            m_installerDb.setPostgresOpennmsPassword(ds.getPassword());\n            m_installerDb.setDatabaseName(ds.getDatabaseName());\n            \n        }\n\n        /*\n         * make sure we can load the ICMP library before we go any farther\n         */\n\n        if (!Boolean.getBoolean(\"skip-native\")) {\n            String icmp_path = findLibrary(\"jicmp\", m_library_search_path, true);\n            String jrrd_path = findLibrary(\"jrrd\", m_library_search_path, false);\n            writeLibraryConfig(icmp_path, jrrd_path);\n        }\n        \n        /*\n         * Everything needs to use the administrative data source until we\n         * verify that the opennms database is created below (and where we\n         * create it if it doesn't already exist).\n         */\n\n        if (doDatabase) {\n            if (!m_ignore_database_version) {\n                m_installerDb.databaseCheckVersion();\n            }\n            m_installerDb.databaseCheckLanguage();\n\n            m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsUser() + \"' as the PostgreSQL user for OpenNMS\");\n            m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsPassword() + \"' as the PostgreSQL password for OpenNMS\");\n            m_out.println(\"* using '\" + m_installerDb.getDatabaseName() + \"' as the PostgreSQL database name for OpenNMS\");\n        }\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        if (doDatabase) {\n            m_installerDb.checkUnicode();\n        }\n        \n        // We can now use the opennms database\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.addColumnReplacements();\n            m_installerDb.createTables();\n            m_installerDb.closeColumnReplacements();\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_out.println(\"WARNING: the -U option is deprecated, it does nothing now\");\n        }\n\n        if (m_do_vacuum) {\n            m_installerDb.vacuumDatabase(m_do_full_vacuum);\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database && m_remove_database) {\n            m_installerDb.disconnect();\n            m_installerDb.databaseRemoveDB();\n        }\n\n        if (doDatabase) {\n            m_installerDb.disconnect();\n        }\n        \n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyFileExists(boolean isDir, String file,\n            String description, String option) throws FileNotFoundException {\n        File f;\n\n        if (file == null) {\n            throw new FileNotFoundException(\"The user most provide the \"\n                    + \"location of \" + description\n                    + \", but this is not specified.  \" + \"Use the \" + option\n                    + \" to specify this file.\");\n        }\n\n        m_out.print(\"- using \" + description + \"... \");\n\n        f = new File(file);\n\n        if (!f.exists()) {\n            throw new FileNotFoundException(description\n                    + \" does not exist at \\\"\" + file + \"\\\".  Use the \"\n                    + option + \" to specify another location.\");\n        }\n\n        if (!isDir) {\n            if (!f.isFile()) {\n                throw new FileNotFoundException(description\n                        + \" not a file at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify another file.\");\n            }\n        } else {\n            if (!f.isDirectory()) {\n                throw new FileNotFoundException(description\n                        + \" not a directory at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify \" + \"another directory.\");\n            }\n        }\n\n        m_out.println(f.getAbsolutePath());\n    }","id":104215,"modified_method":"public void verifyFileExists(boolean isDir, String file, String description, String option)\n            throws FileNotFoundException {\n        File f;\n\n        if (file == null) {\n            throw new FileNotFoundException(\"The user most provide the location of \" + description\n                    + \", but this is not specified.  Use the \" + option\n                    + \" to specify this file.\");\n        }\n\n        m_out.print(\"- using \" + description + \"... \");\n\n        f = new File(file);\n\n        if (!f.exists()) {\n            throw new FileNotFoundException(description\n                    + \" does not exist at \\\"\" + file + \"\\\".  Use the \"\n                    + option + \" to specify another location.\");\n        }\n\n        if (!isDir) {\n            if (!f.isFile()) {\n                throw new FileNotFoundException(description\n                        + \" not a file at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify another file.\");\n            }\n        } else {\n            if (!f.isDirectory()) {\n                throw new FileNotFoundException(description\n                        + \" not a directory at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify \" + \"another directory.\");\n            }\n        }\n\n        m_out.println(f.getAbsolutePath());\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void copyFile(String source, String destination,\n            String description, boolean recursive) throws Exception {\n        File sourceFile = new File(source);\n        File destinationFile = new File(destination);\n\n        if (!sourceFile.exists()) {\n            throw new Exception(\"source file (\" + source\n                    + \") does not exist!\");\n        }\n        if (!sourceFile.isFile()) {\n            throw new Exception(\"source file (\" + source + \") is not a file!\");\n        }\n        if (!sourceFile.canRead()) {\n            throw new Exception(\"source file (\" + source\n                    + \") is not readable!\");\n        }\n        if (destinationFile.exists()) {\n            m_out.print(\"  - \" + destination + \" exists, removing... \");\n            if (destinationFile.delete()) {\n                m_out.println(\"REMOVED\");\n            } else {\n                m_out.println(\"FAILED\");\n                throw new Exception(\"unable to delete existing file: \"\n                        + sourceFile);\n            }\n        }\n\n        m_out.print(\"  - copying \" + source + \" to \" + destination + \"... \");\n        if (!destinationFile.getParentFile().exists()) {\n            destinationFile.getParentFile().mkdirs();\n        }\n        if (!destinationFile.createNewFile()) {\n            throw new Exception(\"unable to create file: \" + destinationFile);\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(sourceFile).getChannel();\n            to = new FileOutputStream(destinationFile).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n        m_out.println(\"DONE\");\n    }","id":104216,"modified_method":"public void copyFile(String source, String destination,\n            String description, boolean recursive) throws Exception {\n        File sourceFile = new File(source);\n        File destinationFile = new File(destination);\n\n        if (!sourceFile.exists()) {\n            throw new Exception(\"source file (\" + source\n                    + \") does not exist!\");\n        }\n        if (!sourceFile.isFile()) {\n            throw new Exception(\"source file (\" + source + \") is not a file!\");\n        }\n        if (!sourceFile.canRead()) {\n            throw new Exception(\"source file (\" + source\n                    + \") is not readable!\");\n        }\n        if (destinationFile.exists()) {\n            m_out.print(\"  - \" + destination + \" exists, removing... \");\n            if (destinationFile.delete()) {\n                m_out.println(\"REMOVED\");\n            } else {\n                m_out.println(\"FAILED\");\n                throw new Exception(\"unable to delete existing file: \"\n                        + sourceFile);\n            }\n        }\n\n        m_out.print(\"  - copying \" + source + \" to \" + destination + \"... \");\n        if (!destinationFile.getParentFile().exists()) {\n            if (!destinationFile.getParentFile().mkdirs()) {\n                throw new Exception(\"unable to create directory: \" + destinationFile.getParent());\n            }\n        }\n        if (!destinationFile.createNewFile()) {\n            throw new Exception(\"unable to create file: \" + destinationFile);\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(sourceFile).getChannel();\n            to = new FileOutputStream(destinationFile).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } catch (FileNotFoundException e) {\n            throw new Exception(\"unable to copy \" + sourceFile + \" to \" + destinationFile, e);\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n        m_out.println(\"DONE\");\n    }","commit_id":"1db32776828116a31eba81c85fce5a1a6418c1fc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addCriteriaForService(OnmsCriteria criteria, int serviceId) {\n        criteria.createAlias(\"node.ipInterfaces\", \"ipInterface\");\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices\", \"monitoredService\");\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices.serviceType\", \"serviceType\");\n        criteria.add(Restrictions.eq(\"serviceType.id\", serviceId));\n    }","id":104217,"modified_method":"private void addCriteriaForService(OnmsCriteria criteria, int serviceId) {\n        criteria.createAlias(\"node.ipInterfaces\", \"ipInterface\");\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices\", \"monitoredService\");\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices.serviceType\", \"serviceType\");\n        criteria.add(Restrictions.eq(\"serviceType.id\", serviceId));\n        criteria.add(Restrictions.ne(\"monitoredService.status\", \"D\"));\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, GenericIndexResourceType> getGenericIndexResourceTypes() {\n        Map<String, GenericIndexResourceType> resourceTypes;\n        resourceTypes = new LinkedHashMap<String, GenericIndexResourceType>();\n\n        Map<String, org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n            m_dataCollectionConfig.getConfiguredResourceTypes();\n        for (org.opennms.netmgt.config.datacollection.ResourceType resourceType : configuredResourceTypes.values()) {\n            String className = resourceType.getStorageStrategy().getClazz();\n            Class<?> cinst;\n            try {\n                cinst = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not load class\",\n                                                          e);\n            }\n            StorageStrategy storageStrategy;\n            try {\n                storageStrategy = (StorageStrategy) cinst.newInstance();\n            } catch (InstantiationException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not instantiate\",\n                                                          e);\n            } catch (IllegalAccessException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not instantiate\",\n                                                          e);\n            }\n            \n            storageStrategy.setResourceTypeName(resourceType.getName());\n            \n            GenericIndexResourceType genericIndexResourceType =\n                new GenericIndexResourceType(this,\n                                                  resourceType.getName(),\n                                                  resourceType.getLabel(),\n                                                  resourceType.getResourceLabel(),\n                                                  storageStrategy);\n            resourceTypes.put(genericIndexResourceType.getName(), genericIndexResourceType);\n        }\n        return resourceTypes;\n    }","id":104218,"modified_method":"private Map<String, GenericIndexResourceType> getGenericIndexResourceTypes() {\n        Map<String, GenericIndexResourceType> resourceTypes;\n        resourceTypes = new LinkedHashMap<String, GenericIndexResourceType>();\n\n        Map<String, org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n            m_dataCollectionConfig.getConfiguredResourceTypes();\n        for (org.opennms.netmgt.config.datacollection.ResourceType resourceType : configuredResourceTypes.values()) {\n            String className = resourceType.getStorageStrategy().getClazz();\n            Class<?> cinst;\n            try {\n                cinst = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                   \"Could not load class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            }\n            StorageStrategy storageStrategy;\n            try {\n                storageStrategy = (StorageStrategy) cinst.newInstance();\n            } catch (InstantiationException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                    \"Could not instantiate class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            } catch (IllegalAccessException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                    \"Could not instantiate class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            }\n            \n            storageStrategy.setResourceTypeName(resourceType.getName());\n            \n            GenericIndexResourceType genericIndexResourceType =\n                new GenericIndexResourceType(this,\n                                                  resourceType.getName(),\n                                                  resourceType.getLabel(),\n                                                  resourceType.getResourceLabel(),\n                                                  storageStrategy);\n            resourceTypes.put(genericIndexResourceType.getName(), genericIndexResourceType);\n        }\n        return resourceTypes;\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyFileExists(boolean isDir, String file,\n            String description, String option) throws FileNotFoundException {\n        File f;\n\n        if (file == null) {\n            throw new FileNotFoundException(\"The user most provide the \"\n                    + \"location of \" + description\n                    + \", but this is not specified.  \" + \"Use the \" + option\n                    + \" to specify this file.\");\n        }\n\n        m_out.print(\"- using \" + description + \"... \");\n\n        f = new File(file);\n\n        if (!f.exists()) {\n            throw new FileNotFoundException(description\n                    + \" does not exist at \\\"\" + file + \"\\\".  Use the \"\n                    + option + \" to specify another location.\");\n        }\n\n        if (!isDir) {\n            if (!f.isFile()) {\n                throw new FileNotFoundException(description\n                        + \" not a file at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify another file.\");\n            }\n        } else {\n            if (!f.isDirectory()) {\n                throw new FileNotFoundException(description\n                        + \" not a directory at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify \" + \"another directory.\");\n            }\n        }\n\n        m_out.println(f.getAbsolutePath());\n    }","id":104219,"modified_method":"public void verifyFileExists(boolean isDir, String file, String description, String option)\n            throws FileNotFoundException {\n        File f;\n\n        if (file == null) {\n            throw new FileNotFoundException(\"The user most provide the location of \" + description\n                    + \", but this is not specified.  Use the \" + option\n                    + \" to specify this file.\");\n        }\n\n        m_out.print(\"- using \" + description + \"... \");\n\n        f = new File(file);\n\n        if (!f.exists()) {\n            throw new FileNotFoundException(description\n                    + \" does not exist at \\\"\" + file + \"\\\".  Use the \"\n                    + option + \" to specify another location.\");\n        }\n\n        if (!isDir) {\n            if (!f.isFile()) {\n                throw new FileNotFoundException(description\n                        + \" not a file at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify another file.\");\n            }\n        } else {\n            if (!f.isDirectory()) {\n                throw new FileNotFoundException(description\n                        + \" not a directory at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify \" + \"another directory.\");\n            }\n        }\n\n        m_out.println(f.getAbsolutePath());\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void printHeader() {\n        m_out.println(\"===============================================\"\n                + \"===============================\");\n        m_out.println(\"OpenNMS Installer Version \" + s_version);\n        m_out.println(\"===============================================\"\n                + \"===============================\");\n        m_out.println(\"\");\n        m_out.println(\"Configures PostgreSQL tables, users, and other \"\n                + \"miscellaneous settings.\");\n        m_out.println(\"\");\n    }","id":104220,"modified_method":"public void printHeader() {\n        m_out.println(\"==============================================================================\");\n        m_out.println(\"OpenNMS Installer Version \" + s_version);\n        m_out.println(\"==============================================================================\");\n        m_out.println(\"\");\n        m_out.println(\"Configures PostgreSQL tables, users, and other miscellaneous settings.\");\n        m_out.println(\"\");\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            usage(options, m_commandLine, \"Nothing to do.  Use -h for help.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_installerDb.setForce(m_force);\n        m_installerDb.setIgnoreNotNull(m_ignore_not_null);\n        m_installerDb.setNoRevert(m_do_not_revert);\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);\n        \n        JdbcDataSource adminDs = C3P0ConnectionFactory.marshalDataSourceFromConfig(new FileReader(cfgFile), ADMIN_DATA_SOURCE_NAME);\n        m_installerDb.setAdminDataSource(new SimpleDataSource(adminDs));\n\n        JdbcDataSource ds = C3P0ConnectionFactory.marshalDataSourceFromConfig(new FileReader(cfgFile), OPENNMS_DATA_SOURCE_NAME);\n        m_installerDb.setDataSource(new SimpleDataSource(ds));\n        \n        m_installerDb.setPostgresOpennmsUser(ds.getUserName());\n        m_installerDb.setPostgresOpennmsPassword(ds.getPassword());\n        m_installerDb.setDatabaseName(ds.getDatabaseName());\n\n        /*\n         * make sure we can load the ICMP library before we go any farther\n         */\n\n        if (!Boolean.getBoolean(\"skip-native\")) {\n            String icmp_path = findLibrary(\"jicmp\", m_library_search_path, true);\n            String jrrd_path = findLibrary(\"jrrd\", m_library_search_path, false);\n            writeLibraryConfig(icmp_path, jrrd_path);\n        }\n        \n        /*\n         * Everything needs to use the administrative data source until we\n         * verify that the opennms database is created below (and where we\n         * create it if it doesn't already exist).\n         */\n\n        // XXX Check Tomcat version?\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            if (!m_ignore_database_version) {\n                m_installerDb.databaseCheckVersion();\n            }\n            m_installerDb.databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        m_installerDb.checkUnicode();\n\n        // We can now use the opennms database\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.addColumnReplacements();\n            m_installerDb.createTables();\n            m_installerDb.closeColumnReplacements();\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_out.println(\"WARNING: the -U option is deprecated, it does nothing now\");\n        }\n\n        if (m_do_vacuum) {\n            m_installerDb.vacuumDatabase(m_do_full_vacuum);\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database && m_remove_database) {\n            m_installerDb.disconnect();\n            m_installerDb.databaseRemoveDB();\n        }\n\n        m_installerDb.disconnect();\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","id":104221,"modified_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        boolean doDatabase = (m_update_database || m_do_inserts || m_update_iplike || m_update_unicode || m_fix_constraint);\n        \n        if (!doDatabase && m_tomcat_conf == null && !m_install_webapp && m_library_search_path == null) {\n            usage(options, m_commandLine, \"Nothing to do.  Use -h for help.\", null);\n            System.exit(1);\n        }\n\n        if (doDatabase) {\n            m_installerDb.setForce(m_force);\n            m_installerDb.setIgnoreNotNull(m_ignore_not_null);\n            m_installerDb.setNoRevert(m_do_not_revert);\n    \n            File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);\n            \n            Reader fr = new FileReader(cfgFile);\n            JdbcDataSource adminDs = C3P0ConnectionFactory.marshalDataSourceFromConfig(fr, ADMIN_DATA_SOURCE_NAME);\n            fr.close();\n            m_installerDb.setAdminDataSource(new SimpleDataSource(adminDs));\n\n            fr = new FileReader(cfgFile);\n            JdbcDataSource ds = C3P0ConnectionFactory.marshalDataSourceFromConfig(fr, OPENNMS_DATA_SOURCE_NAME);\n            m_installerDb.setDataSource(new SimpleDataSource(ds));\n            fr.close();\n\n            m_installerDb.setPostgresOpennmsUser(ds.getUserName());\n            m_installerDb.setPostgresOpennmsPassword(ds.getPassword());\n            m_installerDb.setDatabaseName(ds.getDatabaseName());\n            \n        }\n\n        /*\n         * make sure we can load the ICMP library before we go any farther\n         */\n\n        if (!Boolean.getBoolean(\"skip-native\")) {\n            String icmp_path = findLibrary(\"jicmp\", m_library_search_path, true);\n            String jrrd_path = findLibrary(\"jrrd\", m_library_search_path, false);\n            writeLibraryConfig(icmp_path, jrrd_path);\n        }\n        \n        /*\n         * Everything needs to use the administrative data source until we\n         * verify that the opennms database is created below (and where we\n         * create it if it doesn't already exist).\n         */\n\n        if (doDatabase) {\n            if (!m_ignore_database_version) {\n                m_installerDb.databaseCheckVersion();\n            }\n            m_installerDb.databaseCheckLanguage();\n\n            m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsUser() + \"' as the PostgreSQL user for OpenNMS\");\n            m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsPassword() + \"' as the PostgreSQL password for OpenNMS\");\n            m_out.println(\"* using '\" + m_installerDb.getDatabaseName() + \"' as the PostgreSQL database name for OpenNMS\");\n        }\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        if (doDatabase) {\n            m_installerDb.checkUnicode();\n        }\n        \n        // We can now use the opennms database\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.addColumnReplacements();\n            m_installerDb.createTables();\n            m_installerDb.closeColumnReplacements();\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_out.println(\"WARNING: the -U option is deprecated, it does nothing now\");\n        }\n\n        if (m_do_vacuum) {\n            m_installerDb.vacuumDatabase(m_do_full_vacuum);\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database && m_remove_database) {\n            m_installerDb.disconnect();\n            m_installerDb.databaseRemoveDB();\n        }\n\n        if (doDatabase) {\n            m_installerDb.disconnect();\n        }\n        \n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void checkServerXmlOldOpennmsContext() throws Exception {\n        String search_regexp = \"(?ms).*<Context\\\\s+path=\\\"/opennms\\\".*\";\n        StringBuffer b = new StringBuffer();\n\n        File f = new File(m_webappdir + File.separator + \"..\"\n                + File.separator + \"conf\" + File.separator + \"server.xml\");\n\n        m_out.print(\"- Checking for old opennms context in \"\n                + f.getAbsolutePath() + \"... \");\n\n        if (!f.exists()) {\n            m_out.println(\"DID NOT CHECK (file does not exist)\");\n            return;\n        }\n\n        BufferedReader r = new BufferedReader(new FileReader(f));\n        String line;\n\n        while ((line = r.readLine()) != null) {\n            b.append(line);\n            b.append(\"\\n\");\n        }\n        r.close();\n\n        if (b.toString().matches(search_regexp)) {\n            throw new Exception(\n                                \"Old OpenNMS context found in \"\n                                        + f.getAbsolutePath()\n                                        + \".  \"\n                                        + \"You must remove this context from server.xml and re-run the \"\n                                        + \"installer.\");\n        }\n\n        m_out.println(\"OK\");\n\n        return;\n    }","id":104222,"modified_method":"public void checkServerXmlOldOpennmsContext() throws Exception {\n        String search_regexp = \"(?ms).*<Context\\\\s+path=\\\"/opennms\\\".*\";\n        StringBuffer b = new StringBuffer();\n\n        File f = new File(m_webappdir + File.separator + \"..\"\n                + File.separator + \"conf\" + File.separator + \"server.xml\");\n\n        m_out.print(\"- Checking for old opennms context in \"\n                + f.getAbsolutePath() + \"... \");\n\n        if (!f.exists()) {\n            m_out.println(\"DID NOT CHECK (file does not exist)\");\n            return;\n        }\n\n        FileReader fr = new FileReader(f);\n        BufferedReader r = new BufferedReader(fr);\n        String line;\n\n        while ((line = r.readLine()) != null) {\n            b.append(line);\n            b.append(\"\\n\");\n        }\n        r.close();\n        fr.close();\n\n        if (b.toString().matches(search_regexp)) {\n            throw new Exception(\"Old OpenNMS context found in \" + f.getAbsolutePath() +\n                                \".  You must remove this context from server.xml and re-run the installer.\");\n        }\n\n        m_out.println(\"OK\");\n\n        return;\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void parseArguments(String[] argv) throws Exception {\n\n        options.addOption(\"h\", \"help\", false, \"this help\");\n\n        // database-related options\n        options.addOption(\"d\", \"do-database\", false,\n                          \"perform database actions\");\n\n        options.addOption(\"Z\", \"remove-database\", false,\n                          \"remove the OpenNMS database\");\n        \n        options.addOption(\"u\", \"username\", true,\n                          \"username of the database account (default: 'opennms')\");\n        options.addOption(\"p\", \"password\", true,\n                          \"password of the database account (default: 'opennms')\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"username of the database administrator (default: 'postgres')\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"password of the database administrator (default: '')\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"JDBC database URL (default: jdbc:postgresql://localhost:5432/\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"name of the PostgreSQL database (default: opennms)\");\n\n        options.addOption(\"c\", \"clean-database\", false,\n                          \"clean existing database before creating\");\n        options.addOption(\"i\", \"insert-data\", false,\n                          \"insert default data into the database\");\n        options.addOption(\"s\", \"stored-procedure\", false,\n                          \"add the IPLIKE stored procedure if it's missing\");\n        options.addOption(\"U\", \"unicode\", false,\n                          \"upgrade the database to Unicode (deprecated, does nothing)\");\n        options.addOption(\"v\", \"vacuum\", false,\n                          \"vacuum (optimize) the database\");\n        options.addOption(\"f\", \"vacuum-full\", false,\n                          \"vacuum full the database (recovers unused disk space)\");\n        options.addOption(\"N\", \"ignore-not-null\", false,\n                          \"ignore NOT NULL constraint when transforming data\");\n        options.addOption(\"Q\", \"ignore-database-version\", false,\n                          \"disable the database version check\");\n\n        options.addOption(\"x\", \"database-debug\", false,\n                          \"turn on debugging for the database data transformation\");\n        options.addOption(\"R\", \"do-not-revert\", false,\n                          \"do not revert a table to the original if an error occurs\");\n        options.addOption(\"n\", \"skip-constraint\", false, \"\");\n        options.addOption(\"C\", \"repair-constraint\", true,\n                          \"fix rows that violate the specified constraint (sets key column to NULL)\");\n        options.addOption(\"X\", \"drop-constraint\", false,\n                          \"drop rows that match the constraint specified in -C, instead of fixing them\");\n\n        // tomcat-related options\n        options.addOption(\"y\", \"do-webapp\", false,\n                          \"install web application (see '-w')\");\n        options.addOption(\"T\", \"tomcat-conf\", true, \"location of tomcat.conf\");\n        options.addOption(\"w\", \"tomcat-context\", true,\n                          \"location of the tomcat context (eg, conf/Catalina/localhost)\");\n\n        // general installation options\n        options.addOption(\"l\", \"library-path\", true,\n                          \"library search path (directories separated by '\"\n                                  + File.pathSeparator + \"')\");\n        options.addOption(\"r\", \"rpm-install\", false,\n                          \"RPM install (deprecated)\");\n\n        CommandLineParser parser = new PosixParser();\n        m_commandLine = parser.parse(options, argv);\n\n        if (m_commandLine.hasOption(\"h\")) {\n            usage(options, m_commandLine);\n            System.exit(0);\n        }\n\n        options.addOption(\"u\", \"username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"p\", \"password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"replaced by opennms-datasources.xml\");\n\n        if (m_commandLine.hasOption(\"u\")\n                || m_commandLine.hasOption(\"p\")\n                || m_commandLine.hasOption(\"a\")\n                || m_commandLine.hasOption(\"A\")\n                || m_commandLine.hasOption(\"D\")\n                || m_commandLine.hasOption(\"P\")) {\n            usage(\n                  options,\n                  m_commandLine,\n                  \"The 'u', 'p', 'a', 'A', 'D', and 'P' options have all been superceded.\\nPlease edit $OPENNMS_HOME/etc/opennms-datasources.xml instead.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_force = m_commandLine.hasOption(\"c\");\n        m_fix_constraint = m_commandLine.hasOption(\"C\");\n        m_fix_constraint_name = m_commandLine.getOptionValue(\"C\");\n        m_update_database = m_commandLine.hasOption(\"d\");\n        m_remove_database = m_commandLine.hasOption(\"Z\");\n        m_do_full_vacuum = m_commandLine.hasOption(\"f\");\n        m_do_inserts = m_commandLine.hasOption(\"i\");\n        m_library_search_path = m_commandLine.getOptionValue(\"l\",\n                                                             m_library_search_path);\n        m_skip_constraints = m_commandLine.hasOption(\"n\");\n        m_ignore_not_null = m_commandLine.hasOption(\"N\");\n        m_ignore_database_version = m_commandLine.hasOption(\"Q\");\n        m_do_not_revert = m_commandLine.hasOption(\"R\");\n        m_update_iplike = m_commandLine.hasOption(\"s\");\n        m_tomcat_conf = m_commandLine.getOptionValue(\"T\", m_tomcat_conf);\n        m_update_unicode = m_commandLine.hasOption(\"U\");\n        m_do_vacuum = m_commandLine.hasOption(\"v\");\n        m_webappdir = m_commandLine.getOptionValue(\"w\", m_webappdir);\n        m_installerDb.setDebug(m_commandLine.hasOption(\"x\"));\n        m_fix_constraint_remove_rows = m_commandLine.hasOption(\"X\");\n        m_install_webapp = m_commandLine.hasOption(\"y\");\n\n        if (m_commandLine.getArgList().size() > 0) {\n            usage(options, m_commandLine, \"Unknown command-line arguments: \"\n                    + m_commandLine.getArgs(), null);\n            System.exit(1);\n        }\n    }","id":104223,"modified_method":"public void parseArguments(String[] argv) throws Exception {\n\n        options.addOption(\"h\", \"help\", false, \"this help\");\n\n        // database-related options\n        options.addOption(\"d\", \"do-database\", false,\n                          \"perform database actions\");\n\n        options.addOption(\"Z\", \"remove-database\", false,\n                          \"remove the OpenNMS database\");\n        \n        options.addOption(\"u\", \"username\", true,\n                          \"username of the database account (default: 'opennms')\");\n        options.addOption(\"p\", \"password\", true,\n                          \"password of the database account (default: 'opennms')\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"username of the database administrator (default: 'postgres')\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"password of the database administrator (default: '')\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"JDBC database URL (default: jdbc:postgresql://localhost:5432/\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"name of the PostgreSQL database (default: opennms)\");\n\n        options.addOption(\"c\", \"clean-database\", false,\n                          \"clean existing database before creating\");\n        options.addOption(\"i\", \"insert-data\", false,\n                          \"insert default data into the database\");\n        options.addOption(\"s\", \"stored-procedure\", false,\n                          \"add the IPLIKE stored procedure if it's missing\");\n        options.addOption(\"U\", \"unicode\", false,\n                          \"upgrade the database to Unicode (deprecated, does nothing)\");\n        options.addOption(\"v\", \"vacuum\", false,\n                          \"vacuum (optimize) the database\");\n        options.addOption(\"f\", \"vacuum-full\", false,\n                          \"vacuum full the database (recovers unused disk space)\");\n        options.addOption(\"N\", \"ignore-not-null\", false,\n                          \"ignore NOT NULL constraint when transforming data\");\n        options.addOption(\"Q\", \"ignore-database-version\", false,\n                          \"disable the database version check\");\n\n        options.addOption(\"x\", \"database-debug\", false,\n                          \"turn on debugging for the database data transformation\");\n        options.addOption(\"R\", \"do-not-revert\", false,\n                          \"do not revert a table to the original if an error occurs\");\n        options.addOption(\"n\", \"skip-constraint\", false, \"\");\n        options.addOption(\"C\", \"repair-constraint\", true,\n                          \"fix rows that violate the specified constraint (sets key column to NULL)\");\n        options.addOption(\"X\", \"drop-constraint\", false,\n                          \"drop rows that match the constraint specified in -C, instead of fixing them\");\n\n        // tomcat-related options\n        options.addOption(\"y\", \"do-webapp\", false,\n                          \"install web application (see '-w')\");\n        options.addOption(\"T\", \"tomcat-conf\", true, \"location of tomcat.conf\");\n        options.addOption(\"w\", \"tomcat-context\", true,\n                          \"location of the tomcat context (eg, conf/Catalina/localhost)\");\n\n        // general installation options\n        options.addOption(\"l\", \"library-path\", true,\n                          \"library search path (directories separated by '\"\n                                  + File.pathSeparator + \"')\");\n        options.addOption(\"r\", \"rpm-install\", false,\n                          \"RPM install (deprecated)\");\n\n        CommandLineParser parser = new PosixParser();\n        m_commandLine = parser.parse(options, argv);\n\n        if (m_commandLine.hasOption(\"h\")) {\n            usage(options, m_commandLine);\n            System.exit(0);\n        }\n\n        options.addOption(\"u\", \"username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"p\", \"password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"replaced by opennms-datasources.xml\");\n\n        if (m_commandLine.hasOption(\"u\")\n                || m_commandLine.hasOption(\"p\")\n                || m_commandLine.hasOption(\"a\")\n                || m_commandLine.hasOption(\"A\")\n                || m_commandLine.hasOption(\"D\")\n                || m_commandLine.hasOption(\"P\")) {\n            usage(\n                  options,\n                  m_commandLine,\n                  \"The 'u', 'p', 'a', 'A', 'D', and 'P' options have all been superceded.\\nPlease edit $OPENNMS_HOME/etc/opennms-datasources.xml instead.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_force = m_commandLine.hasOption(\"c\");\n        m_fix_constraint = m_commandLine.hasOption(\"C\");\n        m_fix_constraint_name = m_commandLine.getOptionValue(\"C\");\n        m_update_database = m_commandLine.hasOption(\"d\");\n        m_remove_database = m_commandLine.hasOption(\"Z\");\n        m_do_full_vacuum = m_commandLine.hasOption(\"f\");\n        m_do_inserts = m_commandLine.hasOption(\"i\");\n        m_library_search_path = m_commandLine.getOptionValue(\"l\", m_library_search_path);\n        m_skip_constraints = m_commandLine.hasOption(\"n\");\n        m_ignore_not_null = m_commandLine.hasOption(\"N\");\n        m_ignore_database_version = m_commandLine.hasOption(\"Q\");\n        m_do_not_revert = m_commandLine.hasOption(\"R\");\n        m_update_iplike = m_commandLine.hasOption(\"s\");\n        m_tomcat_conf = m_commandLine.getOptionValue(\"T\", m_tomcat_conf);\n        m_update_unicode = m_commandLine.hasOption(\"U\");\n        m_do_vacuum = m_commandLine.hasOption(\"v\");\n        m_webappdir = m_commandLine.getOptionValue(\"w\", m_webappdir);\n        m_installerDb.setDebug(m_commandLine.hasOption(\"x\"));\n        m_fix_constraint_remove_rows = m_commandLine.hasOption(\"X\");\n        m_install_webapp = m_commandLine.hasOption(\"y\");\n\n        if (m_commandLine.getArgList().size() > 0) {\n            usage(options, m_commandLine, \"Unknown command-line arguments: \"\n                    + Arrays.toString(m_commandLine.getArgs()), null);\n            System.exit(1);\n        }\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void copyFile(String source, String destination,\n            String description, boolean recursive) throws Exception {\n        File sourceFile = new File(source);\n        File destinationFile = new File(destination);\n\n        if (!sourceFile.exists()) {\n            throw new Exception(\"source file (\" + source\n                    + \") does not exist!\");\n        }\n        if (!sourceFile.isFile()) {\n            throw new Exception(\"source file (\" + source + \") is not a file!\");\n        }\n        if (!sourceFile.canRead()) {\n            throw new Exception(\"source file (\" + source\n                    + \") is not readable!\");\n        }\n        if (destinationFile.exists()) {\n            m_out.print(\"  - \" + destination + \" exists, removing... \");\n            if (destinationFile.delete()) {\n                m_out.println(\"REMOVED\");\n            } else {\n                m_out.println(\"FAILED\");\n                throw new Exception(\"unable to delete existing file: \"\n                        + sourceFile);\n            }\n        }\n\n        m_out.print(\"  - copying \" + source + \" to \" + destination + \"... \");\n        if (!destinationFile.getParentFile().exists()) {\n            destinationFile.getParentFile().mkdirs();\n        }\n        if (!destinationFile.createNewFile()) {\n            throw new Exception(\"unable to create file: \" + destinationFile);\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(sourceFile).getChannel();\n            to = new FileOutputStream(destinationFile).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n        m_out.println(\"DONE\");\n    }","id":104224,"modified_method":"public void copyFile(String source, String destination,\n            String description, boolean recursive) throws Exception {\n        File sourceFile = new File(source);\n        File destinationFile = new File(destination);\n\n        if (!sourceFile.exists()) {\n            throw new Exception(\"source file (\" + source\n                    + \") does not exist!\");\n        }\n        if (!sourceFile.isFile()) {\n            throw new Exception(\"source file (\" + source + \") is not a file!\");\n        }\n        if (!sourceFile.canRead()) {\n            throw new Exception(\"source file (\" + source\n                    + \") is not readable!\");\n        }\n        if (destinationFile.exists()) {\n            m_out.print(\"  - \" + destination + \" exists, removing... \");\n            if (destinationFile.delete()) {\n                m_out.println(\"REMOVED\");\n            } else {\n                m_out.println(\"FAILED\");\n                throw new Exception(\"unable to delete existing file: \"\n                        + sourceFile);\n            }\n        }\n\n        m_out.print(\"  - copying \" + source + \" to \" + destination + \"... \");\n        if (!destinationFile.getParentFile().exists()) {\n            if (!destinationFile.getParentFile().mkdirs()) {\n                throw new Exception(\"unable to create directory: \" + destinationFile.getParent());\n            }\n        }\n        if (!destinationFile.createNewFile()) {\n            throw new Exception(\"unable to create file: \" + destinationFile);\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(sourceFile).getChannel();\n            to = new FileOutputStream(destinationFile).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } catch (FileNotFoundException e) {\n            throw new Exception(\"unable to copy \" + sourceFile + \" to \" + destinationFile, e);\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n        m_out.println(\"DONE\");\n    }","commit_id":"2c847170f51953f1f0d9e9675d20d85a4a5a7788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addCriteriaForService(OnmsCriteria criteria, int serviceId) {\n        criteria.createAlias(\"node.ipInterfaces\", \"ipInterface\");\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices\", \"monitoredService\");\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices.serviceType\", \"serviceType\");\n        criteria.add(Restrictions.eq(\"serviceType.id\", serviceId));\n    }","id":104225,"modified_method":"private void addCriteriaForService(OnmsCriteria criteria, int serviceId) {\n        criteria.createAlias(\"node.ipInterfaces\", \"ipInterface\");\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices\", \"monitoredService\");\n        criteria.createAlias(\"node.ipInterfaces.monitoredServices.serviceType\", \"serviceType\");\n        criteria.add(Restrictions.eq(\"serviceType.id\", serviceId));\n        criteria.add(Restrictions.ne(\"monitoredService.status\", \"D\"));\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, GenericIndexResourceType> getGenericIndexResourceTypes() {\n        Map<String, GenericIndexResourceType> resourceTypes;\n        resourceTypes = new LinkedHashMap<String, GenericIndexResourceType>();\n\n        Map<String, org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n            m_dataCollectionConfig.getConfiguredResourceTypes();\n        for (org.opennms.netmgt.config.datacollection.ResourceType resourceType : configuredResourceTypes.values()) {\n            String className = resourceType.getStorageStrategy().getClazz();\n            Class<?> cinst;\n            try {\n                cinst = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not load class\",\n                                                          e);\n            }\n            StorageStrategy storageStrategy;\n            try {\n                storageStrategy = (StorageStrategy) cinst.newInstance();\n            } catch (InstantiationException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not instantiate\",\n                                                          e);\n            } catch (IllegalAccessException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class,\n                                                          className,\n                                                          \"Could not instantiate\",\n                                                          e);\n            }\n            \n            storageStrategy.setResourceTypeName(resourceType.getName());\n            \n            GenericIndexResourceType genericIndexResourceType =\n                new GenericIndexResourceType(this,\n                                                  resourceType.getName(),\n                                                  resourceType.getLabel(),\n                                                  resourceType.getResourceLabel(),\n                                                  storageStrategy);\n            resourceTypes.put(genericIndexResourceType.getName(), genericIndexResourceType);\n        }\n        return resourceTypes;\n    }","id":104226,"modified_method":"private Map<String, GenericIndexResourceType> getGenericIndexResourceTypes() {\n        Map<String, GenericIndexResourceType> resourceTypes;\n        resourceTypes = new LinkedHashMap<String, GenericIndexResourceType>();\n\n        Map<String, org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n            m_dataCollectionConfig.getConfiguredResourceTypes();\n        for (org.opennms.netmgt.config.datacollection.ResourceType resourceType : configuredResourceTypes.values()) {\n            String className = resourceType.getStorageStrategy().getClazz();\n            Class<?> cinst;\n            try {\n                cinst = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                   \"Could not load class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            }\n            StorageStrategy storageStrategy;\n            try {\n                storageStrategy = (StorageStrategy) cinst.newInstance();\n            } catch (InstantiationException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                    \"Could not instantiate class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            } catch (IllegalAccessException e) {\n                throw new ObjectRetrievalFailureException(StorageStrategy.class, className,\n                    \"Could not instantiate class '\" + className + \"' for resource type '\" + resourceType.getName() + \"'\", e);\n            }\n            \n            storageStrategy.setResourceTypeName(resourceType.getName());\n            \n            GenericIndexResourceType genericIndexResourceType =\n                new GenericIndexResourceType(this,\n                                                  resourceType.getName(),\n                                                  resourceType.getLabel(),\n                                                  resourceType.getResourceLabel(),\n                                                  storageStrategy);\n            resourceTypes.put(genericIndexResourceType.getName(), genericIndexResourceType);\n        }\n        return resourceTypes;\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void printHeader() {\n        m_out.println(\"===============================================\"\n                + \"===============================\");\n        m_out.println(\"OpenNMS Installer Version \" + s_version);\n        m_out.println(\"===============================================\"\n                + \"===============================\");\n        m_out.println(\"\");\n        m_out.println(\"Configures PostgreSQL tables, users, and other \"\n                + \"miscellaneous settings.\");\n        m_out.println(\"\");\n    }","id":104227,"modified_method":"public void printHeader() {\n        m_out.println(\"==============================================================================\");\n        m_out.println(\"OpenNMS Installer Version \" + s_version);\n        m_out.println(\"==============================================================================\");\n        m_out.println(\"\");\n        m_out.println(\"Configures PostgreSQL tables, users, and other miscellaneous settings.\");\n        m_out.println(\"\");\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void checkServerXmlOldOpennmsContext() throws Exception {\n        String search_regexp = \"(?ms).*<Context\\\\s+path=\\\"/opennms\\\".*\";\n        StringBuffer b = new StringBuffer();\n\n        File f = new File(m_webappdir + File.separator + \"..\"\n                + File.separator + \"conf\" + File.separator + \"server.xml\");\n\n        m_out.print(\"- Checking for old opennms context in \"\n                + f.getAbsolutePath() + \"... \");\n\n        if (!f.exists()) {\n            m_out.println(\"DID NOT CHECK (file does not exist)\");\n            return;\n        }\n\n        BufferedReader r = new BufferedReader(new FileReader(f));\n        String line;\n\n        while ((line = r.readLine()) != null) {\n            b.append(line);\n            b.append(\"\\n\");\n        }\n        r.close();\n\n        if (b.toString().matches(search_regexp)) {\n            throw new Exception(\n                                \"Old OpenNMS context found in \"\n                                        + f.getAbsolutePath()\n                                        + \".  \"\n                                        + \"You must remove this context from server.xml and re-run the \"\n                                        + \"installer.\");\n        }\n\n        m_out.println(\"OK\");\n\n        return;\n    }","id":104228,"modified_method":"public void checkServerXmlOldOpennmsContext() throws Exception {\n        String search_regexp = \"(?ms).*<Context\\\\s+path=\\\"/opennms\\\".*\";\n        StringBuffer b = new StringBuffer();\n\n        File f = new File(m_webappdir + File.separator + \"..\"\n                + File.separator + \"conf\" + File.separator + \"server.xml\");\n\n        m_out.print(\"- Checking for old opennms context in \"\n                + f.getAbsolutePath() + \"... \");\n\n        if (!f.exists()) {\n            m_out.println(\"DID NOT CHECK (file does not exist)\");\n            return;\n        }\n\n        FileReader fr = new FileReader(f);\n        BufferedReader r = new BufferedReader(fr);\n        String line;\n\n        while ((line = r.readLine()) != null) {\n            b.append(line);\n            b.append(\"\\n\");\n        }\n        r.close();\n        fr.close();\n\n        if (b.toString().matches(search_regexp)) {\n            throw new Exception(\"Old OpenNMS context found in \" + f.getAbsolutePath() +\n                                \".  You must remove this context from server.xml and re-run the installer.\");\n        }\n\n        m_out.println(\"OK\");\n\n        return;\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyFileExists(boolean isDir, String file,\n            String description, String option) throws FileNotFoundException {\n        File f;\n\n        if (file == null) {\n            throw new FileNotFoundException(\"The user most provide the \"\n                    + \"location of \" + description\n                    + \", but this is not specified.  \" + \"Use the \" + option\n                    + \" to specify this file.\");\n        }\n\n        m_out.print(\"- using \" + description + \"... \");\n\n        f = new File(file);\n\n        if (!f.exists()) {\n            throw new FileNotFoundException(description\n                    + \" does not exist at \\\"\" + file + \"\\\".  Use the \"\n                    + option + \" to specify another location.\");\n        }\n\n        if (!isDir) {\n            if (!f.isFile()) {\n                throw new FileNotFoundException(description\n                        + \" not a file at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify another file.\");\n            }\n        } else {\n            if (!f.isDirectory()) {\n                throw new FileNotFoundException(description\n                        + \" not a directory at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify \" + \"another directory.\");\n            }\n        }\n\n        m_out.println(f.getAbsolutePath());\n    }","id":104229,"modified_method":"public void verifyFileExists(boolean isDir, String file, String description, String option)\n            throws FileNotFoundException {\n        File f;\n\n        if (file == null) {\n            throw new FileNotFoundException(\"The user most provide the location of \" + description\n                    + \", but this is not specified.  Use the \" + option\n                    + \" to specify this file.\");\n        }\n\n        m_out.print(\"- using \" + description + \"... \");\n\n        f = new File(file);\n\n        if (!f.exists()) {\n            throw new FileNotFoundException(description\n                    + \" does not exist at \\\"\" + file + \"\\\".  Use the \"\n                    + option + \" to specify another location.\");\n        }\n\n        if (!isDir) {\n            if (!f.isFile()) {\n                throw new FileNotFoundException(description\n                        + \" not a file at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify another file.\");\n            }\n        } else {\n            if (!f.isDirectory()) {\n                throw new FileNotFoundException(description\n                        + \" not a directory at \\\"\" + file + \"\\\".  Use the \"\n                        + option + \" to specify \" + \"another directory.\");\n            }\n        }\n\n        m_out.println(f.getAbsolutePath());\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void copyFile(String source, String destination,\n            String description, boolean recursive) throws Exception {\n        File sourceFile = new File(source);\n        File destinationFile = new File(destination);\n\n        if (!sourceFile.exists()) {\n            throw new Exception(\"source file (\" + source\n                    + \") does not exist!\");\n        }\n        if (!sourceFile.isFile()) {\n            throw new Exception(\"source file (\" + source + \") is not a file!\");\n        }\n        if (!sourceFile.canRead()) {\n            throw new Exception(\"source file (\" + source\n                    + \") is not readable!\");\n        }\n        if (destinationFile.exists()) {\n            m_out.print(\"  - \" + destination + \" exists, removing... \");\n            if (destinationFile.delete()) {\n                m_out.println(\"REMOVED\");\n            } else {\n                m_out.println(\"FAILED\");\n                throw new Exception(\"unable to delete existing file: \"\n                        + sourceFile);\n            }\n        }\n\n        m_out.print(\"  - copying \" + source + \" to \" + destination + \"... \");\n        if (!destinationFile.getParentFile().exists()) {\n            destinationFile.getParentFile().mkdirs();\n        }\n        if (!destinationFile.createNewFile()) {\n            throw new Exception(\"unable to create file: \" + destinationFile);\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(sourceFile).getChannel();\n            to = new FileOutputStream(destinationFile).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n        m_out.println(\"DONE\");\n    }","id":104230,"modified_method":"public void copyFile(String source, String destination,\n            String description, boolean recursive) throws Exception {\n        File sourceFile = new File(source);\n        File destinationFile = new File(destination);\n\n        if (!sourceFile.exists()) {\n            throw new Exception(\"source file (\" + source\n                    + \") does not exist!\");\n        }\n        if (!sourceFile.isFile()) {\n            throw new Exception(\"source file (\" + source + \") is not a file!\");\n        }\n        if (!sourceFile.canRead()) {\n            throw new Exception(\"source file (\" + source\n                    + \") is not readable!\");\n        }\n        if (destinationFile.exists()) {\n            m_out.print(\"  - \" + destination + \" exists, removing... \");\n            if (destinationFile.delete()) {\n                m_out.println(\"REMOVED\");\n            } else {\n                m_out.println(\"FAILED\");\n                throw new Exception(\"unable to delete existing file: \"\n                        + sourceFile);\n            }\n        }\n\n        m_out.print(\"  - copying \" + source + \" to \" + destination + \"... \");\n        if (!destinationFile.getParentFile().exists()) {\n            if (!destinationFile.getParentFile().mkdirs()) {\n                throw new Exception(\"unable to create directory: \" + destinationFile.getParent());\n            }\n        }\n        if (!destinationFile.createNewFile()) {\n            throw new Exception(\"unable to create file: \" + destinationFile);\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(sourceFile).getChannel();\n            to = new FileOutputStream(destinationFile).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } catch (FileNotFoundException e) {\n            throw new Exception(\"unable to copy \" + sourceFile + \" to \" + destinationFile, e);\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n        m_out.println(\"DONE\");\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            usage(options, m_commandLine, \"Nothing to do.  Use -h for help.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_installerDb.setForce(m_force);\n        m_installerDb.setIgnoreNotNull(m_ignore_not_null);\n        m_installerDb.setNoRevert(m_do_not_revert);\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);\n        \n        JdbcDataSource adminDs = C3P0ConnectionFactory.marshalDataSourceFromConfig(new FileReader(cfgFile), ADMIN_DATA_SOURCE_NAME);\n        m_installerDb.setAdminDataSource(new SimpleDataSource(adminDs));\n\n        JdbcDataSource ds = C3P0ConnectionFactory.marshalDataSourceFromConfig(new FileReader(cfgFile), OPENNMS_DATA_SOURCE_NAME);\n        m_installerDb.setDataSource(new SimpleDataSource(ds));\n        \n        m_installerDb.setPostgresOpennmsUser(ds.getUserName());\n        m_installerDb.setPostgresOpennmsPassword(ds.getPassword());\n        m_installerDb.setDatabaseName(ds.getDatabaseName());\n\n        /*\n         * make sure we can load the ICMP library before we go any farther\n         */\n\n        if (!Boolean.getBoolean(\"skip-native\")) {\n            String icmp_path = findLibrary(\"jicmp\", m_library_search_path, true);\n            String jrrd_path = findLibrary(\"jrrd\", m_library_search_path, false);\n            writeLibraryConfig(icmp_path, jrrd_path);\n        }\n        \n        /*\n         * Everything needs to use the administrative data source until we\n         * verify that the opennms database is created below (and where we\n         * create it if it doesn't already exist).\n         */\n\n        // XXX Check Tomcat version?\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            if (!m_ignore_database_version) {\n                m_installerDb.databaseCheckVersion();\n            }\n            m_installerDb.databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        m_installerDb.checkUnicode();\n\n        // We can now use the opennms database\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.addColumnReplacements();\n            m_installerDb.createTables();\n            m_installerDb.closeColumnReplacements();\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_out.println(\"WARNING: the -U option is deprecated, it does nothing now\");\n        }\n\n        if (m_do_vacuum) {\n            m_installerDb.vacuumDatabase(m_do_full_vacuum);\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database && m_remove_database) {\n            m_installerDb.disconnect();\n            m_installerDb.databaseRemoveDB();\n        }\n\n        m_installerDb.disconnect();\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","id":104231,"modified_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        boolean doDatabase = (m_update_database || m_do_inserts || m_update_iplike || m_update_unicode || m_fix_constraint);\n        \n        if (!doDatabase && m_tomcat_conf == null && !m_install_webapp && m_library_search_path == null) {\n            usage(options, m_commandLine, \"Nothing to do.  Use -h for help.\", null);\n            System.exit(1);\n        }\n\n        if (doDatabase) {\n            m_installerDb.setForce(m_force);\n            m_installerDb.setIgnoreNotNull(m_ignore_not_null);\n            m_installerDb.setNoRevert(m_do_not_revert);\n    \n            File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);\n            \n            Reader fr = new FileReader(cfgFile);\n            JdbcDataSource adminDs = C3P0ConnectionFactory.marshalDataSourceFromConfig(fr, ADMIN_DATA_SOURCE_NAME);\n            fr.close();\n            m_installerDb.setAdminDataSource(new SimpleDataSource(adminDs));\n\n            fr = new FileReader(cfgFile);\n            JdbcDataSource ds = C3P0ConnectionFactory.marshalDataSourceFromConfig(fr, OPENNMS_DATA_SOURCE_NAME);\n            m_installerDb.setDataSource(new SimpleDataSource(ds));\n            fr.close();\n\n            m_installerDb.setPostgresOpennmsUser(ds.getUserName());\n            m_installerDb.setPostgresOpennmsPassword(ds.getPassword());\n            m_installerDb.setDatabaseName(ds.getDatabaseName());\n            \n        }\n\n        /*\n         * make sure we can load the ICMP library before we go any farther\n         */\n\n        if (!Boolean.getBoolean(\"skip-native\")) {\n            String icmp_path = findLibrary(\"jicmp\", m_library_search_path, true);\n            String jrrd_path = findLibrary(\"jrrd\", m_library_search_path, false);\n            writeLibraryConfig(icmp_path, jrrd_path);\n        }\n        \n        /*\n         * Everything needs to use the administrative data source until we\n         * verify that the opennms database is created below (and where we\n         * create it if it doesn't already exist).\n         */\n\n        if (doDatabase) {\n            if (!m_ignore_database_version) {\n                m_installerDb.databaseCheckVersion();\n            }\n            m_installerDb.databaseCheckLanguage();\n\n            m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsUser() + \"' as the PostgreSQL user for OpenNMS\");\n            m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsPassword() + \"' as the PostgreSQL password for OpenNMS\");\n            m_out.println(\"* using '\" + m_installerDb.getDatabaseName() + \"' as the PostgreSQL database name for OpenNMS\");\n        }\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        if (doDatabase) {\n            m_installerDb.checkUnicode();\n        }\n        \n        // We can now use the opennms database\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.addColumnReplacements();\n            m_installerDb.createTables();\n            m_installerDb.closeColumnReplacements();\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_out.println(\"WARNING: the -U option is deprecated, it does nothing now\");\n        }\n\n        if (m_do_vacuum) {\n            m_installerDb.vacuumDatabase(m_do_full_vacuum);\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database && m_remove_database) {\n            m_installerDb.disconnect();\n            m_installerDb.databaseRemoveDB();\n        }\n\n        if (doDatabase) {\n            m_installerDb.disconnect();\n        }\n        \n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void parseArguments(String[] argv) throws Exception {\n\n        options.addOption(\"h\", \"help\", false, \"this help\");\n\n        // database-related options\n        options.addOption(\"d\", \"do-database\", false,\n                          \"perform database actions\");\n\n        options.addOption(\"Z\", \"remove-database\", false,\n                          \"remove the OpenNMS database\");\n        \n        options.addOption(\"u\", \"username\", true,\n                          \"username of the database account (default: 'opennms')\");\n        options.addOption(\"p\", \"password\", true,\n                          \"password of the database account (default: 'opennms')\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"username of the database administrator (default: 'postgres')\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"password of the database administrator (default: '')\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"JDBC database URL (default: jdbc:postgresql://localhost:5432/\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"name of the PostgreSQL database (default: opennms)\");\n\n        options.addOption(\"c\", \"clean-database\", false,\n                          \"clean existing database before creating\");\n        options.addOption(\"i\", \"insert-data\", false,\n                          \"insert default data into the database\");\n        options.addOption(\"s\", \"stored-procedure\", false,\n                          \"add the IPLIKE stored procedure if it's missing\");\n        options.addOption(\"U\", \"unicode\", false,\n                          \"upgrade the database to Unicode (deprecated, does nothing)\");\n        options.addOption(\"v\", \"vacuum\", false,\n                          \"vacuum (optimize) the database\");\n        options.addOption(\"f\", \"vacuum-full\", false,\n                          \"vacuum full the database (recovers unused disk space)\");\n        options.addOption(\"N\", \"ignore-not-null\", false,\n                          \"ignore NOT NULL constraint when transforming data\");\n        options.addOption(\"Q\", \"ignore-database-version\", false,\n                          \"disable the database version check\");\n\n        options.addOption(\"x\", \"database-debug\", false,\n                          \"turn on debugging for the database data transformation\");\n        options.addOption(\"R\", \"do-not-revert\", false,\n                          \"do not revert a table to the original if an error occurs\");\n        options.addOption(\"n\", \"skip-constraint\", false, \"\");\n        options.addOption(\"C\", \"repair-constraint\", true,\n                          \"fix rows that violate the specified constraint (sets key column to NULL)\");\n        options.addOption(\"X\", \"drop-constraint\", false,\n                          \"drop rows that match the constraint specified in -C, instead of fixing them\");\n\n        // tomcat-related options\n        options.addOption(\"y\", \"do-webapp\", false,\n                          \"install web application (see '-w')\");\n        options.addOption(\"T\", \"tomcat-conf\", true, \"location of tomcat.conf\");\n        options.addOption(\"w\", \"tomcat-context\", true,\n                          \"location of the tomcat context (eg, conf/Catalina/localhost)\");\n\n        // general installation options\n        options.addOption(\"l\", \"library-path\", true,\n                          \"library search path (directories separated by '\"\n                                  + File.pathSeparator + \"')\");\n        options.addOption(\"r\", \"rpm-install\", false,\n                          \"RPM install (deprecated)\");\n\n        CommandLineParser parser = new PosixParser();\n        m_commandLine = parser.parse(options, argv);\n\n        if (m_commandLine.hasOption(\"h\")) {\n            usage(options, m_commandLine);\n            System.exit(0);\n        }\n\n        options.addOption(\"u\", \"username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"p\", \"password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"replaced by opennms-datasources.xml\");\n\n        if (m_commandLine.hasOption(\"u\")\n                || m_commandLine.hasOption(\"p\")\n                || m_commandLine.hasOption(\"a\")\n                || m_commandLine.hasOption(\"A\")\n                || m_commandLine.hasOption(\"D\")\n                || m_commandLine.hasOption(\"P\")) {\n            usage(\n                  options,\n                  m_commandLine,\n                  \"The 'u', 'p', 'a', 'A', 'D', and 'P' options have all been superceded.\\nPlease edit $OPENNMS_HOME/etc/opennms-datasources.xml instead.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_force = m_commandLine.hasOption(\"c\");\n        m_fix_constraint = m_commandLine.hasOption(\"C\");\n        m_fix_constraint_name = m_commandLine.getOptionValue(\"C\");\n        m_update_database = m_commandLine.hasOption(\"d\");\n        m_remove_database = m_commandLine.hasOption(\"Z\");\n        m_do_full_vacuum = m_commandLine.hasOption(\"f\");\n        m_do_inserts = m_commandLine.hasOption(\"i\");\n        m_library_search_path = m_commandLine.getOptionValue(\"l\",\n                                                             m_library_search_path);\n        m_skip_constraints = m_commandLine.hasOption(\"n\");\n        m_ignore_not_null = m_commandLine.hasOption(\"N\");\n        m_ignore_database_version = m_commandLine.hasOption(\"Q\");\n        m_do_not_revert = m_commandLine.hasOption(\"R\");\n        m_update_iplike = m_commandLine.hasOption(\"s\");\n        m_tomcat_conf = m_commandLine.getOptionValue(\"T\", m_tomcat_conf);\n        m_update_unicode = m_commandLine.hasOption(\"U\");\n        m_do_vacuum = m_commandLine.hasOption(\"v\");\n        m_webappdir = m_commandLine.getOptionValue(\"w\", m_webappdir);\n        m_installerDb.setDebug(m_commandLine.hasOption(\"x\"));\n        m_fix_constraint_remove_rows = m_commandLine.hasOption(\"X\");\n        m_install_webapp = m_commandLine.hasOption(\"y\");\n\n        if (m_commandLine.getArgList().size() > 0) {\n            usage(options, m_commandLine, \"Unknown command-line arguments: \"\n                    + m_commandLine.getArgs(), null);\n            System.exit(1);\n        }\n    }","id":104232,"modified_method":"public void parseArguments(String[] argv) throws Exception {\n\n        options.addOption(\"h\", \"help\", false, \"this help\");\n\n        // database-related options\n        options.addOption(\"d\", \"do-database\", false,\n                          \"perform database actions\");\n\n        options.addOption(\"Z\", \"remove-database\", false,\n                          \"remove the OpenNMS database\");\n        \n        options.addOption(\"u\", \"username\", true,\n                          \"username of the database account (default: 'opennms')\");\n        options.addOption(\"p\", \"password\", true,\n                          \"password of the database account (default: 'opennms')\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"username of the database administrator (default: 'postgres')\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"password of the database administrator (default: '')\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"JDBC database URL (default: jdbc:postgresql://localhost:5432/\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"name of the PostgreSQL database (default: opennms)\");\n\n        options.addOption(\"c\", \"clean-database\", false,\n                          \"clean existing database before creating\");\n        options.addOption(\"i\", \"insert-data\", false,\n                          \"insert default data into the database\");\n        options.addOption(\"s\", \"stored-procedure\", false,\n                          \"add the IPLIKE stored procedure if it's missing\");\n        options.addOption(\"U\", \"unicode\", false,\n                          \"upgrade the database to Unicode (deprecated, does nothing)\");\n        options.addOption(\"v\", \"vacuum\", false,\n                          \"vacuum (optimize) the database\");\n        options.addOption(\"f\", \"vacuum-full\", false,\n                          \"vacuum full the database (recovers unused disk space)\");\n        options.addOption(\"N\", \"ignore-not-null\", false,\n                          \"ignore NOT NULL constraint when transforming data\");\n        options.addOption(\"Q\", \"ignore-database-version\", false,\n                          \"disable the database version check\");\n\n        options.addOption(\"x\", \"database-debug\", false,\n                          \"turn on debugging for the database data transformation\");\n        options.addOption(\"R\", \"do-not-revert\", false,\n                          \"do not revert a table to the original if an error occurs\");\n        options.addOption(\"n\", \"skip-constraint\", false, \"\");\n        options.addOption(\"C\", \"repair-constraint\", true,\n                          \"fix rows that violate the specified constraint (sets key column to NULL)\");\n        options.addOption(\"X\", \"drop-constraint\", false,\n                          \"drop rows that match the constraint specified in -C, instead of fixing them\");\n\n        // tomcat-related options\n        options.addOption(\"y\", \"do-webapp\", false,\n                          \"install web application (see '-w')\");\n        options.addOption(\"T\", \"tomcat-conf\", true, \"location of tomcat.conf\");\n        options.addOption(\"w\", \"tomcat-context\", true,\n                          \"location of the tomcat context (eg, conf/Catalina/localhost)\");\n\n        // general installation options\n        options.addOption(\"l\", \"library-path\", true,\n                          \"library search path (directories separated by '\"\n                                  + File.pathSeparator + \"')\");\n        options.addOption(\"r\", \"rpm-install\", false,\n                          \"RPM install (deprecated)\");\n\n        CommandLineParser parser = new PosixParser();\n        m_commandLine = parser.parse(options, argv);\n\n        if (m_commandLine.hasOption(\"h\")) {\n            usage(options, m_commandLine);\n            System.exit(0);\n        }\n\n        options.addOption(\"u\", \"username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"p\", \"password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"a\", \"admin-username\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"A\", \"admin-password\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"D\", \"database-url\", true,\n                          \"replaced by opennms-datasources.xml\");\n        options.addOption(\"P\", \"database-name\", true,\n                          \"replaced by opennms-datasources.xml\");\n\n        if (m_commandLine.hasOption(\"u\")\n                || m_commandLine.hasOption(\"p\")\n                || m_commandLine.hasOption(\"a\")\n                || m_commandLine.hasOption(\"A\")\n                || m_commandLine.hasOption(\"D\")\n                || m_commandLine.hasOption(\"P\")) {\n            usage(\n                  options,\n                  m_commandLine,\n                  \"The 'u', 'p', 'a', 'A', 'D', and 'P' options have all been superceded.\\nPlease edit $OPENNMS_HOME/etc/opennms-datasources.xml instead.\",\n                  null);\n            System.exit(1);\n        }\n\n        m_force = m_commandLine.hasOption(\"c\");\n        m_fix_constraint = m_commandLine.hasOption(\"C\");\n        m_fix_constraint_name = m_commandLine.getOptionValue(\"C\");\n        m_update_database = m_commandLine.hasOption(\"d\");\n        m_remove_database = m_commandLine.hasOption(\"Z\");\n        m_do_full_vacuum = m_commandLine.hasOption(\"f\");\n        m_do_inserts = m_commandLine.hasOption(\"i\");\n        m_library_search_path = m_commandLine.getOptionValue(\"l\", m_library_search_path);\n        m_skip_constraints = m_commandLine.hasOption(\"n\");\n        m_ignore_not_null = m_commandLine.hasOption(\"N\");\n        m_ignore_database_version = m_commandLine.hasOption(\"Q\");\n        m_do_not_revert = m_commandLine.hasOption(\"R\");\n        m_update_iplike = m_commandLine.hasOption(\"s\");\n        m_tomcat_conf = m_commandLine.getOptionValue(\"T\", m_tomcat_conf);\n        m_update_unicode = m_commandLine.hasOption(\"U\");\n        m_do_vacuum = m_commandLine.hasOption(\"v\");\n        m_webappdir = m_commandLine.getOptionValue(\"w\", m_webappdir);\n        m_installerDb.setDebug(m_commandLine.hasOption(\"x\"));\n        m_fix_constraint_remove_rows = m_commandLine.hasOption(\"X\");\n        m_install_webapp = m_commandLine.hasOption(\"y\");\n\n        if (m_commandLine.getArgList().size() > 0) {\n            usage(options, m_commandLine, \"Unknown command-line arguments: \"\n                    + Arrays.toString(m_commandLine.getArgs()), null);\n            System.exit(1);\n        }\n    }","commit_id":"ea1906e20dd97d5cea4a121d738a3e7e618cf3e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public JPanel getContextualPanel() {\n        if( sNodeToolPanel == null) {\n        \t\n        \tsNodeToolPanel = new NodeToolPanel();\n        \t}\n        \t\n        return sNodeToolPanel;\n    }","id":104233,"modified_method":"public JPanel getContextualPanel() {\n        return getNodeToolPanel();\n    }","commit_id":"f7a03d25d7bb64e2633fec71ffa5e6279fce2f8e","url":"https://github.com/VUE/VUE"},{"original_method":"public void paintIcon(Component c, Graphics g, int x, int y) {\n                Graphics2D g2 = (Graphics2D) g;\n                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                g2.setColor(Color.red);\n                g2.fillRect(0,0, 99,99);\n                g2.translate(3,3);\n                float gw = w;\n                //GradientPaint gradient = new GradientPaint(gw/2,0,Color.white,gw/2,h/2,bgColor,true);\n                //GradientPaint gradient = new GradientPaint(gw/6,0,Color.white,gw/2,h/2,bgColor,true);\n                GradientPaint gradient = new GradientPaint(gw/6,0,Color.white,gw*.33f,h/2,bgColor,true);\n                g2.setPaint(gradient);                \n                //g2.setColor(bgColor);\n                g2.fillRoundRect(0,0, w-3,h-3, arc,arc);\n                g2.setColor(Color.black);\n                g2.drawRoundRect(0,0, w-3,h-3, arc,arc);\n                g2.setColor(fillColor);\n                RectangularShape shape = getShape();\n                if (shape instanceof RoundRectangle2D) {\n                    // hack to deal with arcs being too small on a tiny icon\n                    shape = getShapeInstance();\n                    ((RoundRectangle2D)shape).setRoundRect(xInset, yInset, 20,12, 7,7);\n                } else\n                    shape.setFrame(xInset,yInset, 20,12);\n                //shape.setFrame(xInset,yInset, w-xInset*2, h-yInset*2);                \n                g2.fill(shape);\n                g2.setColor(Color.black);\n                g2.draw(shape);\n            }","id":104234,"modified_method":"public void paintIcon(Component c, Graphics g, int x, int y) {\n                Graphics2D g2 = (Graphics2D) g;\n                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                //g2.setColor(Color.red);\n                //g2.fillRect(0,0, 99,99);\n                if (VueUtil.isMacPlatform())\n                    g2.translate(3,3);\n                else\n                    g2.translate(1,1);\n                float gw = w;\n                //GradientPaint gradient = new GradientPaint(gw/2,0,Color.white,gw/2,h/2,mColor,true);\n                //GradientPaint gradient = new GradientPaint(gw/6,0,Color.white,gw/2,h/2,mColor,true);\n                GradientPaint gradient = new GradientPaint(gw/6,0,Color.white,gw*.33f,h/2,mColor,true);\n                // Set gradient for the whole button.\n                //g2.setPaint(gradient);\n                g2.setColor(mColor);\n                if (mDrawButton) {\n                    g2.fill3DRect(0,0, w-1,h-1, true);\n                    //g2.drawRect(0,0, w-3,h-3);\n                } else {\n                    \n                    g2.fillRoundRect(0,0, w-3,h-3, arc,arc);\n                    g2.setColor(Color.black);\n                    g2.drawRoundRect(0,0, w-3,h-3, arc,arc);\n                }\n                \n                g2.setColor(sShapeColor);\n                RectangularShape shape = getShape();\n                if (shape instanceof RoundRectangle2D) {\n                    // hack to deal with arcs being too small on a tiny icon\n                    shape = getShapeInstance();\n                    // plus 2 on x/y inset for mac?\n                    ((RoundRectangle2D)shape).setRoundRect(xInset, yInset, 20,12, 8,8);\n                } else\n                    shape.setFrame(xInset,yInset, 20,12);\n                //shape.setFrame(xInset,yInset, w-xInset*2, h-yInset*2);                \n                g2.fill(shape);\n                g2.setColor(Color.black);\n                g2.draw(shape);\n            }","commit_id":"f7a03d25d7bb64e2633fec71ffa5e6279fce2f8e","url":"https://github.com/VUE/VUE"},{"original_method":"public static LWNode createNode(String name)\n    {\n        LWNode node = new LWNode(name, getActiveSubTool().getShapeInstance());\n        VueBeanState state = sNodeToolPanel.getValue();\n        if( state != null) {\n        \tstate.applyState( node);\n        \t}\n        \n        node.setAutoSized(true);\n        return node;\n    }","id":104235,"modified_method":"public static LWNode createNode(String name)\n    {\n        LWNode node = new LWNode(name, getActiveSubTool().getShapeInstance());\n        VueBeanState state = getNodeToolPanel().getValue();\n        if( state != null) {\n        \tstate.applyState( node);\n        \t}\n        \n        node.setAutoSized(true);\n        return node;\n    }","commit_id":"f7a03d25d7bb64e2633fec71ffa5e6279fce2f8e","url":"https://github.com/VUE/VUE"},{"original_method":"public RectangularShape getShapeInstance()\n        {\n            if (shapeClass == null) {\n                String shapeClassName = getAttribute(\"shapeClass\");\n                //System.out.println(this + \" got shapeClass \" + shapeClassName);\n                try {\n                    this.shapeClass = getClass().getClassLoader().loadClass(shapeClassName);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            RectangularShape rectShape = null;\n            try {\n                rectShape = (RectangularShape) shapeClass.newInstance();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return rectShape;\n        }","id":104236,"modified_method":"public RectangularShape getShapeInstance()\n        {\n            if (shapeClass == null) {\n                String shapeClassName = getAttribute(\"shapeClass\");\n                System.out.println(this + \" got shapeClass \" + shapeClassName);\n                try {\n                    this.shapeClass = getClass().getClassLoader().loadClass(shapeClassName);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            RectangularShape rectShape = null;\n            try {\n                rectShape = (RectangularShape) shapeClass.newInstance();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return rectShape;\n        }","commit_id":"f7a03d25d7bb64e2633fec71ffa5e6279fce2f8e","url":"https://github.com/VUE/VUE"},{"original_method":"public static LWNode createTextNode(String text)\n    {\n        LWNode node = createNode(text);\n        node.setIsTextNode( true);\n        node.setAutoSized(true);\n        node.setShape(new java.awt.geom.Rectangle2D.Float());\n        node.setStrokeWidth(0f);\n        node.setFillColor(COLOR_TRANSPARENT);\n        node.setFont(FONT_TEXT_DEFAULT);\n        \n        VueBeanState state = sNodeToolPanel.getValue();\n        if( state != null) {\n        \tstate.applyState( node);\n        \t}\n        \n        return node;\n    }","id":104237,"modified_method":"public static LWNode createTextNode(String text)\n    {\n        LWNode node = createNode(text);\n        node.setIsTextNode( true);\n        node.setAutoSized(true);\n        node.setShape(new java.awt.geom.Rectangle2D.Float());\n        node.setStrokeWidth(0f);\n        node.setFillColor(COLOR_TRANSPARENT);\n        node.setFont(FONT_TEXT_DEFAULT);\n        \n        VueBeanState state = getNodeToolPanel().getValue();\n        if (state != null) {\n            state.applyState( node);\n        }\n        \n        return node;\n    }","commit_id":"f7a03d25d7bb64e2633fec71ffa5e6279fce2f8e","url":"https://github.com/VUE/VUE"},{"original_method":"protected ShapeIcon(Color c)\n            {\n                bgColor = c;\n            }","id":104238,"modified_method":"protected ShapeIcon(Color c) {\n                this(c, false, false);\n            }","commit_id":"f7a03d25d7bb64e2633fec71ffa5e6279fce2f8e","url":"https://github.com/VUE/VUE"},{"original_method":"protected void paintComponent(final Graphics g) {\n      if (myCompact) {\n        super.paintComponent(g);\n        return;\n      }\n\n      final GraphicsConfig c = new GraphicsConfig(g);\n      c.setAntialiasing(true);\n\n      int arc = 8;\n\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, arc, arc);\n      \n      Color bg = getBackground().darker().darker();\n      bg = ColorUtil.toAlpha(bg, 230);\n\n      g.setColor(bg);\n\n      final Rectangle bounds = myProcessName.getBounds();\n      final Rectangle label = SwingUtilities.convertRectangle(myProcessName.getParent(), bounds, this);\n\n\n      g.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, arc, arc);\n\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRoundRect(0, getHeight() / 2, getWidth() - 1, getHeight() / 2, arc, arc);\n      g.fillRect(0, (int)label.getMaxY() + 1, getWidth() - 1, getHeight() / 2);\n\n      g.setColor(bg);\n      g.drawRoundRect(0, 0, getWidth() - 1, getHeight() - 1, arc, arc);\n\n      c.restore();\n    }","id":104239,"modified_method":"protected void paintComponent(final Graphics g) {\n      if (myCompact) {\n        super.paintComponent(g);\n        return;\n      }\n\n      final GraphicsConfig c = GraphicsUtil.setupAAPainting(g);\n      GraphicsUtil.setupAntialiasing(g, true, true);\n\n      int arc = 8;\n      Color bg = getBackground();\n      final Rectangle bounds = myProcessName.getBounds();\n      final Rectangle label = SwingUtilities.convertRectangle(myProcessName.getParent(), bounds, this);\n\n      g.setColor(UIUtil.getPanelBackground());\n      g.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, arc, arc);\n\n      if (!UIUtil.isUnderDarcula()) {\n        bg = ColorUtil.toAlpha(bg.darker().darker(), 230);\n        g.setColor(bg);\n\n        g.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, arc, arc);\n\n        g.setColor(UIUtil.getPanelBackground());\n        g.fillRoundRect(0, getHeight() / 2, getWidth() - 1, getHeight() / 2, arc, arc);\n        g.fillRect(0, (int)label.getMaxY() + 1, getWidth() - 1, getHeight() / 2);\n      } else {\n        bg = bg.brighter();\n        g.setColor(bg);\n        g.drawLine(0, (int)label.getMaxY() + 1, getWidth() - 1, (int)label.getMaxY() + 1);\n      }\n\n      g.setColor(bg);\n      g.drawRoundRect(0, 0, getWidth() - 1, getHeight() - 1, arc, arc);\n\n      c.restore();\n    }","commit_id":"25b76815dcfdafd79bf68de4acc8a7593c59e298","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EventQueue(\n            @Nonnull NamePathMapper mapper, CommitInfo info,\n            @Nonnull NodeState before, @Nonnull NodeState after,\n            @Nonnull String basePath, @Nonnull EventFilter filter) {\n        EventHandler handler = new QueueingHandler(\n                this, mapper, info, before, after);\n        for (String name : PathUtils.elements(basePath)) {\n            before = before.getChildNode(name);\n            after = after.getChildNode(name);\n            handler = handler.getChildHandler(name, before, after);\n        }\n        handler = new FilteredHandler(\n                Filters.all(new VisibleFilter(), filter),\n                handler);\n\n        this.generator = new EventGenerator(before, after, handler);\n    }","id":104240,"modified_method":"public EventQueue(\n            @Nonnull NamePathMapper mapper, CommitInfo info,\n            @Nonnull NodeState before, @Nonnull NodeState after,\n            @Nonnull String basePath, @Nonnull EventFilter filter) {\n        EventFactory factory = new EventFactory(mapper, info);\n        EventHandler handler =\n                new QueueingHandler(this, factory, before, after);\n        for (String name : PathUtils.elements(basePath)) {\n            before = before.getChildNode(name);\n            after = after.getChildNode(name);\n            handler = handler.getChildHandler(name, before, after);\n        }\n        handler = new FilteredHandler(\n                Filters.all(new VisibleFilter(), filter),\n                handler);\n\n        this.generator = new EventGenerator(before, after, handler);\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void nodeReordered(\n            final String destName, final String name, NodeState reordered) {\n        queue.addEvent(new NodeEvent(name, reordered, identifierTracker) {\n            @Override\n            public int getType() {\n                return NODE_MOVED;\n            }\n            @Override\n            public Map<?, ?> getInfo() {\n                return ImmutableMap.of(\n                        \"srcChildRelPath\", mapper.getJcrName(name),\n                        \"destChildRelPath\", mapper.getJcrName(destName));\n            }\n        });\n    }","id":104241,"modified_method":"@Override\n    public void nodeReordered(\n            final String destName, final String name, NodeState reordered) {\n        queue.addEvent(factory.nodeReordered(\n                pathTracker.getPath(), name,\n                identifierTracker.getChildTracker(name, reordered).getIdentifier(),\n                destName));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void nodeMoved(\n            final String sourcePath, String name, NodeState moved) {\n        queue.addEvent(new NodeEvent(name, moved, identifierTracker) {\n            @Override\n            public int getType() {\n                return NODE_MOVED;\n            }\n            @Override\n            public Map<?, ?> getInfo() {\n                return ImmutableMap.of(\n                        \"srcAbsPath\", mapper.getJcrPath(sourcePath),\n                        \"destAbsPath\", getPath());\n            }\n        });\n    }","id":104242,"modified_method":"@Override\n    public void nodeMoved(\n            final String sourcePath, String name, NodeState moved) {\n        queue.addEvent(factory.nodeMoved(\n                pathTracker.getPath(), name,\n                identifierTracker.getChildTracker(name, moved).getIdentifier(),\n                sourcePath));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyAdded(PropertyState after) {\n        queue.addEvent(new ItemEvent(after.getName()) {\n            @Override\n            public int getType() {\n                return PROPERTY_ADDED;\n            }\n        });\n    }","id":104243,"modified_method":"@Override\n    public void propertyAdded(PropertyState after) {\n        queue.addEvent(factory.propertyAdded(\n                pathTracker.getPath(), after.getName(),\n                identifierTracker.getIdentifier()));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void nodeDeleted(String name, NodeState before) {\n        queue.addEvent(new NodeEvent(name, before, getBeforeIdentifierTracker()) {\n            @Override\n            public int getType() {\n                return NODE_REMOVED;\n            }\n        });\n    }","id":104244,"modified_method":"@Override\n    public void nodeDeleted(String name, NodeState before) {\n        queue.addEvent(factory.nodeDeleted(\n                pathTracker.getPath(), name,\n                getBeforeIdentifierTracker().getChildTracker(name, before).getIdentifier()));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"QueueingHandler(\n            EventQueue queue, NamePathMapper mapper, CommitInfo info,\n            NodeState before, NodeState after) {\n        this.parent = null;\n        this.name = null;\n\n        this.pathTracker = new PathTracker();\n        if (after.exists()) {\n            this.identifierTracker = new IdentifierTracker(after);\n        } else {\n            this.identifierTracker = new IdentifierTracker(before);\n        }\n\n        this.queue = queue;\n        this.mapper = mapper;\n        if (info != null) {\n            this.info = info;\n        } else {\n            // Generate a dummy CommitInfo object to avoid extra null checks.\n            // The current time is used as a rough estimate of the commit time.\n            this.info = new CommitInfo(OAK_EXTERNAL, null, null);\n        }\n\n        this.before = before;\n        this.after = after;\n    }","id":104245,"modified_method":"QueueingHandler(\n            EventQueue queue, EventFactory factory,\n            NodeState before, NodeState after) {\n        this.parent = null;\n        this.name = null;\n\n        this.pathTracker = new PathTracker();\n        if (after.exists()) {\n            this.identifierTracker = new IdentifierTracker(after);\n        } else {\n            this.identifierTracker = new IdentifierTracker(before);\n        }\n\n        this.queue = queue;\n        this.factory = factory;\n\n        this.before = before;\n        this.after = after;\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) {\n        queue.addEvent(new ItemEvent(after.getName()) {\n            @Override\n            public int getType() {\n                return PROPERTY_CHANGED;\n            }\n        });\n    }","id":104246,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) {\n        queue.addEvent(factory.propertyChanged(\n                pathTracker.getPath(), after.getName(),\n                identifierTracker.getIdentifier()));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void nodeAdded(String name, NodeState after) {\n        queue.addEvent(new NodeEvent(name, after, identifierTracker) {\n            @Override\n            public int getType() {\n                return NODE_ADDED;\n            }\n        });\n    }","id":104247,"modified_method":"@Override\n    public void nodeAdded(String name, NodeState after) {\n        queue.addEvent(factory.nodeAdded(\n                pathTracker.getPath(), name,\n                identifierTracker.getChildTracker(name, after).getIdentifier()));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private QueueingHandler(\n            QueueingHandler parent,\n            String name, NodeState before, NodeState after) {\n        this.parent = parent;\n        this.name = name;\n\n        this.pathTracker = parent.pathTracker.getChildTracker(name);\n        if (after.exists()) {\n            this.identifierTracker =\n                    parent.identifierTracker.getChildTracker(name, after);\n        } else {\n            this.identifierTracker =\n                    parent.getBeforeIdentifierTracker().getChildTracker(name, before);\n        }\n\n        this.queue = parent.queue;\n        this.mapper = parent.mapper;\n        this.info = parent.info;\n\n        this.before = before;\n        this.after = after;\n    }","id":104248,"modified_method":"private QueueingHandler(\n            QueueingHandler parent,\n            String name, NodeState before, NodeState after) {\n        this.parent = parent;\n        this.name = name;\n\n        this.pathTracker = parent.pathTracker.getChildTracker(name);\n        if (after.exists()) {\n            this.identifierTracker =\n                    parent.identifierTracker.getChildTracker(name, after);\n        } else {\n            this.identifierTracker =\n                    parent.getBeforeIdentifierTracker().getChildTracker(name, before);\n        }\n\n        this.queue = parent.queue;\n        this.factory = parent.factory;\n\n        this.before = before;\n        this.after = after;\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyDeleted(PropertyState before) {\n        queue.addEvent(new ItemEvent(before.getName()) {\n            @Override\n            public int getType() {\n                return PROPERTY_REMOVED;\n            }\n        });\n    }","id":104249,"modified_method":"@Override\n    public void propertyDeleted(PropertyState before) {\n        queue.addEvent(factory.propertyDeleted(\n                pathTracker.getPath(), before.getName(),\n                identifierTracker.getIdentifier()));\n    }","commit_id":"443facb6d580f8fc0e9e08d1ead62c97526238a9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@TaskAction\n    public void report() {\n        Project project = getProject();\n\n        StyledTextOutput textOutput = getTextOutputFactory().create(ComponentReport.class);\n        ComponentReportRenderer renderer = new ComponentReportRenderer(getFileResolver(), getBinaryRenderer());\n        renderer.setOutput(textOutput);\n\n        renderer.startProject(project);\n\n        Collection<ComponentSpec> components = new ArrayList<ComponentSpec>();\n        ComponentSpecContainer componentSpecs = getModelRegistry().find(ModelPath.path(\"components\"), ModelType.of(ComponentSpecContainer.class));\n        if (componentSpecs != null) {\n            components.addAll(componentSpecs.values());\n        }\n\n        TestSuiteContainer testSuites = getModelRegistry().find(ModelPath.path(\"testSuites\"), ModelType.of(TestSuiteContainer.class));\n        if (testSuites != null) {\n            components.addAll(testSuites.values());\n        }\n\n        renderer.renderComponents(components);\n\n        ProjectSourceSet sourceSets = getModelRegistry().find(ModelPath.path(\"sources\"), ModelType.of(ProjectSourceSet.class));\n        if (sourceSets != null) {\n            renderer.renderSourceSets(sourceSets);\n        }\n        ModelMap<BinarySpec> binaries = getModelRegistry().find(ModelPath.path(\"binaries\"), ModelTypes.modelMap(BinarySpec.class));\n        if (binaries != null) {\n            renderer.renderBinaries(binaries);\n        }\n\n        renderer.completeProject(project);\n        renderer.complete();\n    }","id":104250,"modified_method":"@TaskAction\n    public void report() {\n        Project project = getProject();\n\n        StyledTextOutput textOutput = getTextOutputFactory().create(ComponentReport.class);\n        ComponentReportRenderer renderer = new ComponentReportRenderer(getFileResolver(), getBinaryRenderer());\n        renderer.setOutput(textOutput);\n\n        renderer.startProject(project);\n\n        Collection<ComponentSpec> components = new ArrayList<ComponentSpec>();\n        ComponentSpecContainer componentSpecs = find(\"components\", ComponentSpecContainer.class);\n        if (componentSpecs != null) {\n            components.addAll(componentSpecs.values());\n        }\n\n        TestSuiteContainer testSuites = find(\"testSuites\", TestSuiteContainer.class);\n        if (testSuites != null) {\n            components.addAll(testSuites.values());\n        }\n\n        renderer.renderComponents(components);\n\n        ProjectSourceSet sourceSets = find(\"sources\", ProjectSourceSet.class);\n        if (sourceSets != null) {\n            renderer.renderSourceSets(sourceSets);\n        }\n        ModelMap<BinarySpec> binaries = find(\"binaries\", ModelTypes.modelMap(BinarySpec.class));\n        if (binaries != null) {\n            renderer.renderBinaries(binaries);\n        }\n\n        renderer.completeProject(project);\n        renderer.complete();\n    }","commit_id":"b8ece0d717ab78cabbd2c342108dfbd64a1112d3","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n   * Get a sorted List of all elements in this queue, in descending order.\n   * @return list of cached elements in descending order\n   */\n  public CachedBlock [] get() {\n    LinkedList<CachedBlock> blocks = new LinkedList<CachedBlock>();\n    while(!queue.isEmpty()) {\n      blocks.addFirst(queue.poll());\n    }\n    return blocks.toArray(new CachedBlock[blocks.size()]);\n  }","id":104251,"modified_method":"/**\n   * @return a sorted List of all elements in this queue, in descending order\n   */\n  public LinkedList<CachedBlock> get() {\n    LinkedList<CachedBlock> blocks = new LinkedList<CachedBlock>();\n    while (!queue.isEmpty()) {\n      blocks.addFirst(queue.poll());\n    }\n    return blocks;\n  }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Eviction method.\n   */\n  void evict() {\n\n    // Ensure only one eviction at a time\n    if(!evictionLock.tryLock()) return;\n\n    try {\n      evictionInProgress = true;\n\n      long bytesToFree = size.get() - minSize();\n\n      LOG.debug(\"Block cache LRU eviction started.  Attempting to free \" +\n          bytesToFree + \" bytes\");\n\n      if(bytesToFree <= 0) return;\n\n      // Instantiate priority buckets\n      BlockBucket bucketSingle = new BlockBucket(bytesToFree, blockSize,\n          singleSize());\n      BlockBucket bucketMulti = new BlockBucket(bytesToFree, blockSize,\n          multiSize());\n      BlockBucket bucketMemory = new BlockBucket(bytesToFree, blockSize,\n          memorySize());\n\n      // Scan entire map putting into appropriate buckets\n      for(CachedBlock cachedBlock : map.values()) {\n        switch(cachedBlock.getPriority()) {\n          case SINGLE: {\n            bucketSingle.add(cachedBlock);\n            break;\n          }\n          case MULTI: {\n            bucketMulti.add(cachedBlock);\n            break;\n          }\n          case MEMORY: {\n            bucketMemory.add(cachedBlock);\n            break;\n          }\n        }\n      }\n\n      PriorityQueue<BlockBucket> bucketQueue =\n        new PriorityQueue<BlockBucket>(3);\n\n      bucketQueue.add(bucketSingle);\n      bucketQueue.add(bucketMulti);\n      bucketQueue.add(bucketMemory);\n\n      int remainingBuckets = 3;\n      long bytesFreed = 0;\n\n      BlockBucket bucket;\n      while((bucket = bucketQueue.poll()) != null) {\n        long overflow = bucket.overflow();\n        if(overflow > 0) {\n          long bucketBytesToFree = Math.min(overflow,\n            (bytesToFree - bytesFreed) / remainingBuckets);\n          bytesFreed += bucket.free(bucketBytesToFree);\n        }\n        remainingBuckets--;\n      }\n\n      float singleMB = ((float)bucketSingle.totalSize())/((float)(1024*1024));\n      float multiMB = ((float)bucketMulti.totalSize())/((float)(1024*1024));\n      float memoryMB = ((float)bucketMemory.totalSize())/((float)(1024*1024));\n\n      LOG.debug(\"Block cache LRU eviction completed. \" +\n          \"Freed \" + bytesFreed + \" bytes.  \" +\n          \"Priority Sizes: \" +\n          \"Single=\" + singleMB + \"MB (\" + bucketSingle.totalSize() + \"), \" +\n          \"Multi=\" + multiMB + \"MB (\" + bucketMulti.totalSize() + \"),\" +\n          \"Memory=\" + memoryMB + \"MB (\" + bucketMemory.totalSize() + \")\");\n\n    } finally {\n      stats.evict();\n      evictionInProgress = false;\n      evictionLock.unlock();\n    }\n  }","id":104252,"modified_method":"/**\n   * Eviction method.\n   */\n  void evict() {\n\n    // Ensure only one eviction at a time\n    if(!evictionLock.tryLock()) return;\n\n    try {\n      evictionInProgress = true;\n      long currentSize = this.size.get();\n      long bytesToFree = currentSize - minSize();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Block cache LRU eviction started; Attempting to free \" +\n          StringUtils.byteDesc(bytesToFree) + \" of total=\" +\n          StringUtils.byteDesc(currentSize));\n      }\n\n      if(bytesToFree <= 0) return;\n\n      // Instantiate priority buckets\n      BlockBucket bucketSingle = new BlockBucket(bytesToFree, blockSize,\n          singleSize());\n      BlockBucket bucketMulti = new BlockBucket(bytesToFree, blockSize,\n          multiSize());\n      BlockBucket bucketMemory = new BlockBucket(bytesToFree, blockSize,\n          memorySize());\n\n      // Scan entire map putting into appropriate buckets\n      for(CachedBlock cachedBlock : map.values()) {\n        switch(cachedBlock.getPriority()) {\n          case SINGLE: {\n            bucketSingle.add(cachedBlock);\n            break;\n          }\n          case MULTI: {\n            bucketMulti.add(cachedBlock);\n            break;\n          }\n          case MEMORY: {\n            bucketMemory.add(cachedBlock);\n            break;\n          }\n        }\n      }\n\n      PriorityQueue<BlockBucket> bucketQueue =\n        new PriorityQueue<BlockBucket>(3);\n\n      bucketQueue.add(bucketSingle);\n      bucketQueue.add(bucketMulti);\n      bucketQueue.add(bucketMemory);\n\n      int remainingBuckets = 3;\n      long bytesFreed = 0;\n\n      BlockBucket bucket;\n      while((bucket = bucketQueue.poll()) != null) {\n        long overflow = bucket.overflow();\n        if(overflow > 0) {\n          long bucketBytesToFree = Math.min(overflow,\n            (bytesToFree - bytesFreed) / remainingBuckets);\n          bytesFreed += bucket.free(bucketBytesToFree);\n        }\n        remainingBuckets--;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long single = bucketSingle.totalSize();\n        long multi = bucketMulti.totalSize();\n        long memory = bucketMemory.totalSize();\n        LOG.debug(\"Block cache LRU eviction completed; \" +\n          \"freed=\" + StringUtils.byteDesc(bytesFreed) + \", \" +\n          \"total=\" + StringUtils.byteDesc(this.size.get()) + \", \" +\n          \"single=\" + StringUtils.byteDesc(single) + \", \" +\n          \"multi=\" + StringUtils.byteDesc(multi) + \", \" +\n          \"memory=\" + StringUtils.byteDesc(memory));\n      }\n    } finally {\n      stats.evict();\n      evictionInProgress = false;\n      evictionLock.unlock();\n    }\n  }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"public void logStats() {\n    // Log size\n    long totalSize = heapSize();\n    long freeSize = maxSize - totalSize;\n    float sizeMB = ((float)totalSize)/((float)(1024*1024));\n    float freeMB = ((float)freeSize)/((float)(1024*1024));\n    float maxMB = ((float)maxSize)/((float)(1024*1024));\n    LruBlockCache.LOG.debug(\"Cache Stats: Sizes: \" +\n        \"Total=\" + sizeMB + \"MB (\" + totalSize + \"), \" +\n        \"Free=\" + freeMB + \"MB (\" + freeSize + \"), \" +\n        \"Max=\" + maxMB + \"MB (\" + maxSize +\")\" +\n      \", Counts: \" +\n        \"Blocks=\" + size() +\", \" +\n        \"Access=\" + stats.getRequestCount() + \", \" +\n        \"Hit=\" + stats.getHitCount() + \", \" +\n        \"Miss=\" + stats.getMissCount() + \", \" +\n        \"Evictions=\" + stats.getEvictionCount() + \", \" +\n        \"Evicted=\" + stats.getEvictedCount() +\n      \", Ratios: \" +\n        \"Hit Ratio=\" + stats.getHitRatio()*100 + \"%, \" +\n        \"Miss Ratio=\" + stats.getMissRatio()*100 + \"%, \" +\n        \"Evicted/Run=\" + stats.evictedPerEviction());\n  }","id":104253,"modified_method":"public void logStats() {\n    if (!LOG.isDebugEnabled()) return;\n    // Log size\n    long totalSize = heapSize();\n    long freeSize = maxSize - totalSize;\n    LruBlockCache.LOG.debug(\"LRU Stats: \" +\n        \"total=\" + StringUtils.byteDesc(totalSize) + \", \" +\n        \"free=\" + StringUtils.byteDesc(freeSize) + \", \" +\n        \"max=\" + StringUtils.byteDesc(this.maxSize) + \", \" +\n        \"blocks=\" + size() +\", \" +\n        \"accesses=\" + stats.getRequestCount() + \", \" +\n        \"hits=\" + stats.getHitCount() + \", \" +\n        \"misses=\" + stats.getMissCount() + \", \" +\n        \"evictions=\" + stats.getEvictionCount() + \", \" +\n        \"evicted=\" + stats.getEvictedCount() + \", \" +\n        \"hitRatio=\" + StringUtils.formatPercent(stats.getHitRatio(), 2) + \"%, \" +\n        \"missRatio=\" + StringUtils.formatPercent(stats.getMissRatio(), 2) + \"%, \" +\n        \"evictedPerRun=\" + stats.evictedPerEviction());\n  }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"public long free(long toFree) {\n      CachedBlock [] blocks = queue.get();\n      long freedBytes = 0;\n      for(int i=0; i<blocks.length; i++) {\n        freedBytes += evictBlock(blocks[i]);\n        if(freedBytes >= toFree) {\n          return freedBytes;\n        }\n      }\n      return freedBytes;\n    }","id":104254,"modified_method":"public long free(long toFree) {\n      LinkedList<CachedBlock> blocks = queue.get();\n      long freedBytes = 0;\n      for(CachedBlock cb: blocks) {\n        freedBytes += evictBlock(cb);\n        if(freedBytes >= toFree) {\n          return freedBytes;\n        }\n      }\n      return freedBytes;\n    }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"public void testQueue() throws Exception {\n\n    CachedBlock cb1 = new CachedBlock(1000, \"cb1\", 1);\n    CachedBlock cb2 = new CachedBlock(1500, \"cb2\", 2);\n    CachedBlock cb3 = new CachedBlock(1000, \"cb3\", 3);\n    CachedBlock cb4 = new CachedBlock(1500, \"cb4\", 4);\n    CachedBlock cb5 = new CachedBlock(1000, \"cb5\", 5);\n    CachedBlock cb6 = new CachedBlock(1750, \"cb6\", 6);\n    CachedBlock cb7 = new CachedBlock(1000, \"cb7\", 7);\n    CachedBlock cb8 = new CachedBlock(1500, \"cb8\", 8);\n    CachedBlock cb9 = new CachedBlock(1000, \"cb9\", 9);\n    CachedBlock cb10 = new CachedBlock(1500, \"cb10\", 10);\n\n    CachedBlockQueue queue = new CachedBlockQueue(10000,1000);\n\n    queue.add(cb1);\n    queue.add(cb2);\n    queue.add(cb3);\n    queue.add(cb4);\n    queue.add(cb5);\n    queue.add(cb6);\n    queue.add(cb7);\n    queue.add(cb8);\n    queue.add(cb9);\n    queue.add(cb10);\n\n    // We expect cb1 through cb8 to be in the queue\n    long expectedSize = cb1.heapSize() + cb2.heapSize() + cb3.heapSize() +\n      cb4.heapSize() + cb5.heapSize() + cb6.heapSize() + cb7.heapSize() +\n      cb8.heapSize();\n\n    assertEquals(queue.heapSize(), expectedSize);\n\n    org.apache.hadoop.hbase.io.hfile.CachedBlock [] blocks = queue.get();\n    assertEquals(blocks[0].getName(), \"cb1\");\n    assertEquals(blocks[1].getName(), \"cb2\");\n    assertEquals(blocks[2].getName(), \"cb3\");\n    assertEquals(blocks[3].getName(), \"cb4\");\n    assertEquals(blocks[4].getName(), \"cb5\");\n    assertEquals(blocks[5].getName(), \"cb6\");\n    assertEquals(blocks[6].getName(), \"cb7\");\n    assertEquals(blocks[7].getName(), \"cb8\");\n\n  }","id":104255,"modified_method":"public void testQueue() throws Exception {\n\n    CachedBlock cb1 = new CachedBlock(1000, \"cb1\", 1);\n    CachedBlock cb2 = new CachedBlock(1500, \"cb2\", 2);\n    CachedBlock cb3 = new CachedBlock(1000, \"cb3\", 3);\n    CachedBlock cb4 = new CachedBlock(1500, \"cb4\", 4);\n    CachedBlock cb5 = new CachedBlock(1000, \"cb5\", 5);\n    CachedBlock cb6 = new CachedBlock(1750, \"cb6\", 6);\n    CachedBlock cb7 = new CachedBlock(1000, \"cb7\", 7);\n    CachedBlock cb8 = new CachedBlock(1500, \"cb8\", 8);\n    CachedBlock cb9 = new CachedBlock(1000, \"cb9\", 9);\n    CachedBlock cb10 = new CachedBlock(1500, \"cb10\", 10);\n\n    CachedBlockQueue queue = new CachedBlockQueue(10000,1000);\n\n    queue.add(cb1);\n    queue.add(cb2);\n    queue.add(cb3);\n    queue.add(cb4);\n    queue.add(cb5);\n    queue.add(cb6);\n    queue.add(cb7);\n    queue.add(cb8);\n    queue.add(cb9);\n    queue.add(cb10);\n\n    // We expect cb1 through cb8 to be in the queue\n    long expectedSize = cb1.heapSize() + cb2.heapSize() + cb3.heapSize() +\n      cb4.heapSize() + cb5.heapSize() + cb6.heapSize() + cb7.heapSize() +\n      cb8.heapSize();\n\n    assertEquals(queue.heapSize(), expectedSize);\n\n    LinkedList<org.apache.hadoop.hbase.io.hfile.CachedBlock> blocks =\n      queue.get();\n    assertEquals(blocks.poll().getName(), \"cb1\");\n    assertEquals(blocks.poll().getName(), \"cb2\");\n    assertEquals(blocks.poll().getName(), \"cb3\");\n    assertEquals(blocks.poll().getName(), \"cb4\");\n    assertEquals(blocks.poll().getName(), \"cb5\");\n    assertEquals(blocks.poll().getName(), \"cb6\");\n    assertEquals(blocks.poll().getName(), \"cb7\");\n    assertEquals(blocks.poll().getName(), \"cb8\");\n\n  }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"public void testQueueSmallBlockEdgeCase() throws Exception {\n\n    CachedBlock cb1 = new CachedBlock(1000, \"cb1\", 1);\n    CachedBlock cb2 = new CachedBlock(1500, \"cb2\", 2);\n    CachedBlock cb3 = new CachedBlock(1000, \"cb3\", 3);\n    CachedBlock cb4 = new CachedBlock(1500, \"cb4\", 4);\n    CachedBlock cb5 = new CachedBlock(1000, \"cb5\", 5);\n    CachedBlock cb6 = new CachedBlock(1750, \"cb6\", 6);\n    CachedBlock cb7 = new CachedBlock(1000, \"cb7\", 7);\n    CachedBlock cb8 = new CachedBlock(1500, \"cb8\", 8);\n    CachedBlock cb9 = new CachedBlock(1000, \"cb9\", 9);\n    CachedBlock cb10 = new CachedBlock(1500, \"cb10\", 10);\n\n    CachedBlockQueue queue = new CachedBlockQueue(10000,1000);\n\n    queue.add(cb1);\n    queue.add(cb2);\n    queue.add(cb3);\n    queue.add(cb4);\n    queue.add(cb5);\n    queue.add(cb6);\n    queue.add(cb7);\n    queue.add(cb8);\n    queue.add(cb9);\n    queue.add(cb10);\n\n    CachedBlock cb0 = new CachedBlock(10 + CachedBlock.PER_BLOCK_OVERHEAD, \"cb0\", 0);\n    queue.add(cb0);\n\n    // This is older so we must include it, but it will not end up kicking\n    // anything out because (heapSize - cb8.heapSize + cb0.heapSize < maxSize)\n    // and we must always maintain heapSize >= maxSize once we achieve it.\n\n    // We expect cb0 through cb8 to be in the queue\n    long expectedSize = cb1.heapSize() + cb2.heapSize() + cb3.heapSize() +\n      cb4.heapSize() + cb5.heapSize() + cb6.heapSize() + cb7.heapSize() +\n      cb8.heapSize() + cb0.heapSize();\n\n    assertEquals(queue.heapSize(), expectedSize);\n\n    org.apache.hadoop.hbase.io.hfile.CachedBlock [] blocks = queue.get();\n    assertEquals(blocks[0].getName(), \"cb0\");\n    assertEquals(blocks[1].getName(), \"cb1\");\n    assertEquals(blocks[2].getName(), \"cb2\");\n    assertEquals(blocks[3].getName(), \"cb3\");\n    assertEquals(blocks[4].getName(), \"cb4\");\n    assertEquals(blocks[5].getName(), \"cb5\");\n    assertEquals(blocks[6].getName(), \"cb6\");\n    assertEquals(blocks[7].getName(), \"cb7\");\n    assertEquals(blocks[8].getName(), \"cb8\");\n\n  }","id":104256,"modified_method":"public void testQueueSmallBlockEdgeCase() throws Exception {\n\n    CachedBlock cb1 = new CachedBlock(1000, \"cb1\", 1);\n    CachedBlock cb2 = new CachedBlock(1500, \"cb2\", 2);\n    CachedBlock cb3 = new CachedBlock(1000, \"cb3\", 3);\n    CachedBlock cb4 = new CachedBlock(1500, \"cb4\", 4);\n    CachedBlock cb5 = new CachedBlock(1000, \"cb5\", 5);\n    CachedBlock cb6 = new CachedBlock(1750, \"cb6\", 6);\n    CachedBlock cb7 = new CachedBlock(1000, \"cb7\", 7);\n    CachedBlock cb8 = new CachedBlock(1500, \"cb8\", 8);\n    CachedBlock cb9 = new CachedBlock(1000, \"cb9\", 9);\n    CachedBlock cb10 = new CachedBlock(1500, \"cb10\", 10);\n\n    CachedBlockQueue queue = new CachedBlockQueue(10000,1000);\n\n    queue.add(cb1);\n    queue.add(cb2);\n    queue.add(cb3);\n    queue.add(cb4);\n    queue.add(cb5);\n    queue.add(cb6);\n    queue.add(cb7);\n    queue.add(cb8);\n    queue.add(cb9);\n    queue.add(cb10);\n\n    CachedBlock cb0 = new CachedBlock(10 + CachedBlock.PER_BLOCK_OVERHEAD, \"cb0\", 0);\n    queue.add(cb0);\n\n    // This is older so we must include it, but it will not end up kicking\n    // anything out because (heapSize - cb8.heapSize + cb0.heapSize < maxSize)\n    // and we must always maintain heapSize >= maxSize once we achieve it.\n\n    // We expect cb0 through cb8 to be in the queue\n    long expectedSize = cb1.heapSize() + cb2.heapSize() + cb3.heapSize() +\n      cb4.heapSize() + cb5.heapSize() + cb6.heapSize() + cb7.heapSize() +\n      cb8.heapSize() + cb0.heapSize();\n\n    assertEquals(queue.heapSize(), expectedSize);\n\n    LinkedList<org.apache.hadoop.hbase.io.hfile.CachedBlock> blocks = queue.get();\n    assertEquals(blocks.poll().getName(), \"cb0\");\n    assertEquals(blocks.poll().getName(), \"cb1\");\n    assertEquals(blocks.poll().getName(), \"cb2\");\n    assertEquals(blocks.poll().getName(), \"cb3\");\n    assertEquals(blocks.poll().getName(), \"cb4\");\n    assertEquals(blocks.poll().getName(), \"cb5\");\n    assertEquals(blocks.poll().getName(), \"cb6\");\n    assertEquals(blocks.poll().getName(), \"cb7\");\n    assertEquals(blocks.poll().getName(), \"cb8\");\n\n  }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"public void testCacheSimple() throws Exception {\n\n    long maxSize = 1000000;\n    long blockSize = calculateBlockSizeDefault(maxSize, 101);\n\n    LruBlockCache cache = new LruBlockCache(maxSize, blockSize);\n\n    Block [] blocks = generateRandomBlocks(100, blockSize);\n\n    long expectedCacheSize = cache.heapSize();\n\n    // Confirm empty\n    for(Block block : blocks) {\n      assertTrue(cache.getBlock(block.blockName) == null);\n    }\n\n    // Add blocks\n    for(Block block : blocks) {\n      cache.cacheBlock(block.blockName, block.buf);\n      expectedCacheSize += block.heapSize();\n    }\n\n    // Verify correctly calculated cache heap size\n    assertEquals(expectedCacheSize, cache.heapSize());\n\n    // Check if all blocks are properly cached and retrieved\n    for(Block block : blocks) {\n      ByteBuffer buf = cache.getBlock(block.blockName);\n      assertTrue(buf != null);\n      assertEquals(buf.capacity(), block.buf.capacity());\n    }\n\n    // Re-add same blocks and ensure nothing has changed\n    for(Block block : blocks) {\n      try {\n        cache.cacheBlock(block.blockName, block.buf);\n        assertTrue(\"Cache should not allow re-caching a block\", false);\n      } catch(RuntimeException re) {\n        // expected\n      }\n    }\n\n    // Verify correctly calculated cache heap size\n    assertEquals(expectedCacheSize, cache.heapSize());\n\n    // Check if all blocks are properly cached and retrieved\n    for(Block block : blocks) {\n      ByteBuffer buf = cache.getBlock(block.blockName);\n      assertTrue(buf != null);\n      assertEquals(buf.capacity(), block.buf.capacity());\n    }\n\n    // Expect no evictions\n    assertEquals(0, cache.getEvictionCount());\n  }","id":104257,"modified_method":"public void testCacheSimple() throws Exception {\n\n    long maxSize = 1000000;\n    long blockSize = calculateBlockSizeDefault(maxSize, 101);\n\n    LruBlockCache cache = new LruBlockCache(maxSize, blockSize);\n\n    Block [] blocks = generateRandomBlocks(100, blockSize);\n\n    long expectedCacheSize = cache.heapSize();\n\n    // Confirm empty\n    for(Block block : blocks) {\n      assertTrue(cache.getBlock(block.blockName) == null);\n    }\n\n    // Add blocks\n    for(Block block : blocks) {\n      cache.cacheBlock(block.blockName, block.buf);\n      expectedCacheSize += block.heapSize();\n    }\n\n    // Verify correctly calculated cache heap size\n    assertEquals(expectedCacheSize, cache.heapSize());\n\n    // Check if all blocks are properly cached and retrieved\n    for(Block block : blocks) {\n      ByteBuffer buf = cache.getBlock(block.blockName);\n      assertTrue(buf != null);\n      assertEquals(buf.capacity(), block.buf.capacity());\n    }\n\n    // Re-add same blocks and ensure nothing has changed\n    for(Block block : blocks) {\n      try {\n        cache.cacheBlock(block.blockName, block.buf);\n        assertTrue(\"Cache should not allow re-caching a block\", false);\n      } catch(RuntimeException re) {\n        // expected\n      }\n    }\n\n    // Verify correctly calculated cache heap size\n    assertEquals(expectedCacheSize, cache.heapSize());\n\n    // Check if all blocks are properly cached and retrieved\n    for(Block block : blocks) {\n      ByteBuffer buf = cache.getBlock(block.blockName);\n      assertTrue(buf != null);\n      assertEquals(buf.capacity(), block.buf.capacity());\n    }\n\n    // Expect no evictions\n    assertEquals(0, cache.getEvictionCount());\n    Thread t = new LruBlockCache.StatisticsThread(cache);\n    t.start();\n    t.join();\n  }","commit_id":"9bb7a8ae653ea2905e69022698a520c469aed1cb","url":"https://github.com/apache/hbase"},{"original_method":"public void customizeCellRenderer(JTree tree,\n                                    Object value,\n                                    boolean selected,\n                                    boolean expanded,\n                                    boolean leaf,\n                                    int row,\n                                    boolean hasFocus) {\n    ChangesBrowserNode node = (ChangesBrowserNode)value;\n    Object object = node.getUserObject();\n    if (object instanceof ChangeList) {\n      if (object instanceof LocalChangeList) {\n        final LocalChangeList list = ((LocalChangeList)object);\n        append(list.getName(),\n               list.isDefault() ? SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES : SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n        for(ChangeListDecorator decorator: myDecorators) {\n          decorator.decorateChangeList(list, this, selected, expanded, hasFocus);\n        }\n        if (list.isInUpdate()) {\n          append(\" \" + VcsBundle.message(\"changes.nodetitle.updating\"), SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n      }\n      else {\n        final ChangeList list = ((ChangeList)object);\n        append(list.getName(), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n      }\n    }\n    else if (object instanceof Change) {\n      final Change change = (Change)object;\n      final FilePath filePath = ChangesUtil.getFilePath(change);\n      append(filePath.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, getColor(change), null));\n      if (myShowFlatten) {\n        append(\" (\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        final File parentFile = filePath.getIOFile().getParentFile();\n        if (parentFile != null) {\n          append(parentFile.getPath() + \", \", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        append(change.getFileStatus().getText() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      else if (node.getCount() != 1 || node.getDirectoryCount() != 0) {\n        appendCount(node);\n      }\n\n      if (filePath.isDirectory()) {\n        setIcon(Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        setIcon(filePath.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof VirtualFile) {\n      final VirtualFile file = (VirtualFile)object;\n      append(file.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, FileStatus.COLOR_UNKNOWN));\n      if (myShowFlatten && file.isValid()) {\n        final VirtualFile parentFile = file.getParent();\n        assert parentFile != null;\n        append(\" (\" + parentFile.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      if (file.isDirectory()) {\n        setIcon(Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        setIcon(file.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof FilePath) {\n      final FilePath path = (FilePath)object;\n      if (path.isDirectory() || !node.isLeaf()) {\n        append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n               SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        if (!node.isLeaf()) {\n          appendCount(node);\n        }\n        setIcon(expanded ? Icons.DIRECTORY_OPEN_ICON : Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        if (myShowFlatten) {\n          append(path.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          final FilePath parent = path.getParentPath();\n          append(\" (\" + parent.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        else {\n          append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n                 SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n        setIcon(path.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof Module) {\n      final Module module = (Module)object;\n\n      append(module.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n      setIcon(module.getModuleType().getNodeIcon(expanded));\n    }\n    else {\n      append(object.toString(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n    }\n  }","id":104258,"modified_method":"public void customizeCellRenderer(JTree tree,\n                                    Object value,\n                                    boolean selected,\n                                    boolean expanded,\n                                    boolean leaf,\n                                    int row,\n                                    boolean hasFocus) {\n    ChangesBrowserNode node = (ChangesBrowserNode)value;\n    Object object = node.getUserObject();\n    if (object instanceof ChangeList) {\n      if (object instanceof LocalChangeList) {\n        final LocalChangeList list = ((LocalChangeList)object);\n        append(list.getName(),\n               list.isDefault() ? SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES : SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n        for(ChangeListDecorator decorator: myDecorators) {\n          decorator.decorateChangeList(list, this, selected, expanded, hasFocus);\n        }\n        if (list.isInUpdate()) {\n          append(\" \" + VcsBundle.message(\"changes.nodetitle.updating\"), SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n      }\n      else {\n        final ChangeList list = ((ChangeList)object);\n        append(list.getName(), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n      }\n    }\n    else if (object instanceof Change) {\n      final Change change = (Change)object;\n      final FilePath filePath = ChangesUtil.getFilePath(change);\n      append(filePath.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, getColor(change), null));\n      if (myShowFlatten) {\n        append(\" (\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        final File parentFile = filePath.getIOFile().getParentFile();\n        if (parentFile != null) {\n          append(parentFile.getPath() + \", \", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        append(change.getFileStatus().getText() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      else if (node.getCount() != 1 || node.getDirectoryCount() != 0) {\n        appendCount(node);\n      }\n\n      if (filePath.isDirectory()) {\n        setIcon(Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        setIcon(filePath.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof VirtualFile) {\n      final VirtualFile file = (VirtualFile)object;\n      append(file.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, FileStatus.COLOR_UNKNOWN));\n      if (myShowFlatten && file.isValid()) {\n        final VirtualFile parentFile = file.getParent();\n        assert parentFile != null;\n        append(\" (\" + parentFile.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      else if (node.getCount() != 1 || node.getDirectoryCount() != 0) {\n        appendCount(node);\n      }\n      if (file.isDirectory()) {\n        setIcon(Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        setIcon(file.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof FilePath) {\n      final FilePath path = (FilePath)object;\n      if (path.isDirectory() || !node.isLeaf()) {\n        append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n               SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        if (!node.isLeaf()) {\n          appendCount(node);\n        }\n        setIcon(expanded ? Icons.DIRECTORY_OPEN_ICON : Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        if (myShowFlatten) {\n          append(path.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          final FilePath parent = path.getParentPath();\n          append(\" (\" + parent.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        else {\n          append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n                 SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n        setIcon(path.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof Module) {\n      final Module module = (Module)object;\n\n      append(module.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n      setIcon(module.getModuleType().getNodeIcon(expanded));\n    }\n    else {\n      append(object.toString(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n    }\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getDirectoryCount() {\n    if (myDirectoryCount == -1) {\n      if (userObject instanceof Change && ChangesUtil.getFilePath((Change) userObject).isDirectory()) {\n        myDirectoryCount = 1;\n      }\n      else if (userObject instanceof FilePath && ((FilePath) userObject).isDirectory() && isLeaf()) {\n        myDirectoryCount = 1;\n      }\n      else if (userObject instanceof VirtualFile && ((VirtualFile) userObject).isDirectory() && isLeaf()) {\n        myDirectoryCount = 1;\n      }\n      else {\n        myDirectoryCount = 0;\n      }\n\n      final Enumeration nodes = children();\n      while (nodes.hasMoreElements()) {\n        ChangesBrowserNode child = (ChangesBrowserNode)nodes.nextElement();\n        myDirectoryCount += child.getDirectoryCount();\n      }\n    }\n    return myDirectoryCount;\n  }","id":104259,"modified_method":"public int getDirectoryCount() {\n    if (myDirectoryCount == -1) {\n      if (userObject instanceof Change && ChangesUtil.getFilePath((Change) userObject).isDirectory()) {\n        myDirectoryCount = 1;\n      }\n      else if (userObject instanceof FilePath && ((FilePath) userObject).isDirectory() && isLeaf()) {\n        myDirectoryCount = 1;\n      }\n      else if (userObject instanceof VirtualFile && ((VirtualFile) userObject).isDirectory() &&\n               FileStatusManager.getInstance(myProject).getStatus((VirtualFile) userObject) != FileStatus.NOT_CHANGED) {\n        myDirectoryCount = 1;\n      }\n      else {\n        myDirectoryCount = 0;\n      }\n\n      final Enumeration nodes = children();\n      while (nodes.hasMoreElements()) {\n        ChangesBrowserNode child = (ChangesBrowserNode)nodes.nextElement();\n        myDirectoryCount += child.getDirectoryCount();\n      }\n    }\n    return myDirectoryCount;\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangesBrowserNode(Object userObject) {\n    super(userObject);\n    if ((userObject instanceof Change && !ChangesUtil.getFilePath((Change) userObject).isDirectory()) ||\n        (userObject instanceof VirtualFile && !((VirtualFile) userObject).isDirectory()) ||\n        userObject instanceof FilePath && !((FilePath)userObject).isDirectory()) {\n      count = 1;\n    }\n  }","id":104260,"modified_method":"public ChangesBrowserNode(final Project project, Object userObject) {\n    super(userObject);\n    myProject = project;\n    if ((userObject instanceof Change && !ChangesUtil.getFilePath((Change) userObject).isDirectory()) ||\n        (userObject instanceof VirtualFile && !((VirtualFile) userObject).isDirectory()) ||\n        userObject instanceof FilePath && !((FilePath)userObject).isDirectory()) {\n      count = 1;\n    }\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangesListView(final Project project) {\n    myProject = project;\n\n    getModel().setRoot(new ChangesBrowserNode(TreeModelBuilder.ROOT_NODE_VALUE));\n\n    setShowsRootHandles(true);\n    setRootVisible(false);\n\n    new TreeSpeedSearch(this, new NodeToTextConvertor());\n    SmartExpander.installOn(this);\n  }","id":104261,"modified_method":"public ChangesListView(final Project project) {\n    myProject = project;\n\n    getModel().setRoot(new ChangesBrowserNode(myProject, TreeModelBuilder.ROOT_NODE_VALUE));\n\n    setShowsRootHandles(true);\n    setRootVisible(false);\n\n    new TreeSpeedSearch(this, new NodeToTextConvertor());\n    SmartExpander.installOn(this);\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangesTreeList(final Project project, Collection<Change> initiallyIncluded, final boolean showCheckboxes) {\n    myProject = project;\n    myShowCheckboxes = showCheckboxes;\n    myIncludedChanges = new HashSet<Change>(initiallyIncluded);\n\n    myCards = new CardLayout();\n\n    setLayout(myCards);\n\n    final int checkboxWidth = new JCheckBox().getPreferredSize().width;\n    myTree = new Tree(new ChangesBrowserNode(ROOT)) {\n      public Dimension getPreferredScrollableViewportSize() {\n        Dimension size = super.getPreferredScrollableViewportSize();\n        size = new Dimension(size.width + 10, size.height);\n        return size;\n      }\n\n      protected void processMouseEvent(MouseEvent e) {\n        if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n          int row = myTree.getRowForLocation(e.getX(), e.getY());\n          if (row >= 0) {\n            final Rectangle baseRect = myTree.getRowBounds(row);\n            baseRect.setSize(checkboxWidth, baseRect.height);\n            if (baseRect.contains(e.getPoint())) {\n              myTree.setSelectionRow(row);\n              toggleSelection();\n            }\n          }\n        }\n        super.processMouseEvent(e);\n      }\n\n      public int getToggleClickCount() {\n        return -1;\n      }\n    };\n\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n\n    myTree.setCellRenderer(new MyTreeCellRenderer());\n\n    myList = new JList(new DefaultListModel());\n    myList.setVisibleRowCount(10);\n\n    add(new JScrollPane(myList), LIST_CARD);\n    add(new JScrollPane(myTree), TREE_CARD);\n\n    new ListSpeedSearch(myList) {\n      protected String getElementText(Object element) {\n        if (element instanceof Change) {\n          return ChangesUtil.getFilePath((Change)element).getName();\n        }\n        return super.getElementText(element);\n      }\n    };\n\n    myList.setCellRenderer(new MyListCellRenderer());\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        toggleSelection();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        includeSelection();\n      }\n\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_INSERT, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        excludeSelection();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    myList.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        final int idx = myList.locationToIndex(e.getPoint());\n        if (idx >= 0) {\n          final Rectangle baseRect = myList.getCellBounds(idx, idx);\n          baseRect.setSize(checkboxWidth, baseRect.height);\n          if (baseRect.contains(e.getPoint())) {\n            toggleSelection();\n            e.consume();\n          }\n          else if (e.getClickCount() == 2) {\n            myDoubleClickHandler.run();\n            e.consume();\n          }\n        }\n      }\n    });\n\n    myTree.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        final int row = myTree.getRowForLocation(e.getPoint().x, e.getPoint().y);\n        if (row >= 0) {\n          final Rectangle baseRect = myTree.getRowBounds(row);\n          baseRect.setSize(checkboxWidth, baseRect.height);\n          if (!baseRect.contains(e.getPoint()) && e.getClickCount() == 2) {\n            myDoubleClickHandler.run();\n            e.consume();\n          }\n        }\n      }\n    });\n  }","id":104262,"modified_method":"public ChangesTreeList(final Project project, Collection<Change> initiallyIncluded, final boolean showCheckboxes) {\n    myProject = project;\n    myShowCheckboxes = showCheckboxes;\n    myIncludedChanges = new HashSet<Change>(initiallyIncluded);\n\n    myCards = new CardLayout();\n\n    setLayout(myCards);\n\n    final int checkboxWidth = new JCheckBox().getPreferredSize().width;\n    myTree = new Tree(new ChangesBrowserNode(myProject, ROOT)) {\n      public Dimension getPreferredScrollableViewportSize() {\n        Dimension size = super.getPreferredScrollableViewportSize();\n        size = new Dimension(size.width + 10, size.height);\n        return size;\n      }\n\n      protected void processMouseEvent(MouseEvent e) {\n        if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n          int row = myTree.getRowForLocation(e.getX(), e.getY());\n          if (row >= 0) {\n            final Rectangle baseRect = myTree.getRowBounds(row);\n            baseRect.setSize(checkboxWidth, baseRect.height);\n            if (baseRect.contains(e.getPoint())) {\n              myTree.setSelectionRow(row);\n              toggleSelection();\n            }\n          }\n        }\n        super.processMouseEvent(e);\n      }\n\n      public int getToggleClickCount() {\n        return -1;\n      }\n    };\n\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n\n    myTree.setCellRenderer(new MyTreeCellRenderer());\n\n    myList = new JList(new DefaultListModel());\n    myList.setVisibleRowCount(10);\n\n    add(new JScrollPane(myList), LIST_CARD);\n    add(new JScrollPane(myTree), TREE_CARD);\n\n    new ListSpeedSearch(myList) {\n      protected String getElementText(Object element) {\n        if (element instanceof Change) {\n          return ChangesUtil.getFilePath((Change)element).getName();\n        }\n        return super.getElementText(element);\n      }\n    };\n\n    myList.setCellRenderer(new MyListCellRenderer());\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        toggleSelection();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        includeSelection();\n      }\n\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_INSERT, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        excludeSelection();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    myList.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        final int idx = myList.locationToIndex(e.getPoint());\n        if (idx >= 0) {\n          final Rectangle baseRect = myList.getCellBounds(idx, idx);\n          baseRect.setSize(checkboxWidth, baseRect.height);\n          if (baseRect.contains(e.getPoint())) {\n            toggleSelection();\n            e.consume();\n          }\n          else if (e.getClickCount() == 2) {\n            myDoubleClickHandler.run();\n            e.consume();\n          }\n        }\n      }\n    });\n\n    myTree.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        final int row = myTree.getRowForLocation(e.getPoint().x, e.getPoint().y);\n        if (row >= 0) {\n          final Rectangle baseRect = myTree.getRowBounds(row);\n          baseRect.setSize(checkboxWidth, baseRect.height);\n          if (!baseRect.contains(e.getPoint()) && e.getClickCount() == 2) {\n            myDoubleClickHandler.run();\n            e.consume();\n          }\n        }\n      }\n    });\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ChangesBrowserNode getNodeForModule(Module module,\n                                              Map<Module, ChangesBrowserNode> moduleNodesCache,\n                                              ChangesBrowserNode root) {\n    ChangesBrowserNode node = moduleNodesCache.get(module);\n    if (node == null) {\n      node = new ChangesBrowserNode(module);\n      model.insertNodeInto(node, root, root.getChildCount());\n      moduleNodesCache.put(module, node);\n    }\n    return node;\n  }","id":104263,"modified_method":"private ChangesBrowserNode getNodeForModule(Module module,\n                                              Map<Module, ChangesBrowserNode> moduleNodesCache,\n                                              ChangesBrowserNode root) {\n    ChangesBrowserNode node = moduleNodesCache.get(module);\n    if (node == null) {\n      node = new ChangesBrowserNode(myProject, module);\n      model.insertNodeInto(node, root, root.getChildCount());\n      moduleNodesCache.put(module, node);\n    }\n    return node;\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DefaultTreeModel buildModel(final List<? extends ChangeList> changeLists,\n                                     final List<VirtualFile> unversionedFiles,\n                                     final List<FilePath> locallyDeletedFiles) {\n\n    for (ChangeList list : changeLists) {\n      ChangesBrowserNode listNode = new ChangesBrowserNode(list);\n      model.insertNodeInto(listNode, root, 0);\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (Change change : list.getChanges()) {\n        insertChangeNode(change, foldersCache, moduleCache, listNode);\n      }\n    }\n\n    if (!unversionedFiles.isEmpty()) {\n      ChangesBrowserNode unversionedNode = new ChangesBrowserNode(VcsBundle.message(\"changes.nodetitle.unversioned.files\"));\n      model.insertNodeInto(unversionedNode, root, root.getChildCount());\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (VirtualFile file : unversionedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(file);\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, unversionedNode), 0);\n      }\n    }\n\n    if (!locallyDeletedFiles.isEmpty()) {\n      ChangesBrowserNode locallyDeletedNode = new ChangesBrowserNode(VcsBundle.message(\"changes.nodetitle.locally.deleted.files\"));\n      model.insertNodeInto(locallyDeletedNode, root, root.getChildCount());\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (FilePath file : locallyDeletedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(file);\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, locallyDeletedNode), 0);\n      }\n    }\n\n    collapseDirectories(model, root);\n    sortNodes();\n\n    return model;\n  }","id":104264,"modified_method":"public DefaultTreeModel buildModel(final List<? extends ChangeList> changeLists,\n                                     final List<VirtualFile> unversionedFiles,\n                                     final List<FilePath> locallyDeletedFiles) {\n\n    for (ChangeList list : changeLists) {\n      ChangesBrowserNode listNode = new ChangesBrowserNode(myProject, list);\n      model.insertNodeInto(listNode, root, 0);\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (Change change : list.getChanges()) {\n        insertChangeNode(change, foldersCache, moduleCache, listNode);\n      }\n    }\n\n    if (!unversionedFiles.isEmpty()) {\n      ChangesBrowserNode unversionedNode = new ChangesBrowserNode(myProject, VcsBundle.message(\"changes.nodetitle.unversioned.files\"));\n      model.insertNodeInto(unversionedNode, root, root.getChildCount());\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (VirtualFile file : unversionedFiles) {\n        insertChangeNode(file, foldersCache, moduleCache, unversionedNode);\n      }\n    }\n\n    if (!locallyDeletedFiles.isEmpty()) {\n      ChangesBrowserNode locallyDeletedNode = new ChangesBrowserNode(myProject, VcsBundle.message(\"changes.nodetitle.locally.deleted.files\"));\n      model.insertNodeInto(locallyDeletedNode, root, root.getChildCount());\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (FilePath file : locallyDeletedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(myProject, file);\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, locallyDeletedNode), 0);\n      }\n    }\n\n    collapseDirectories(model, root);\n    sortNodes();\n\n    return model;\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FilePath getPathForObject(Object o) {\n    if (o instanceof Change) {\n      return ChangesUtil.getFilePath((Change)o);\n    }\n    else if (o instanceof VirtualFile) {\n      return PeerFactory.getInstance().getVcsContextFactory().createFilePathOn((VirtualFile)o);\n    }\n    else if (o instanceof FilePath) {\n      return (FilePath)o;\n    }\n\n    return null;\n  }","id":104265,"modified_method":"private static FilePath getPathForObject(Object o) {\n    if (o instanceof Change) {\n      return ChangesUtil.getFilePath((Change)o);\n    }\n    else if (o instanceof VirtualFile) {\n      return PeerFactory.getInstance().getVcsContextFactory().createFilePathOn((VirtualFile)o);\n    }\n    else if (o instanceof FilePath) {\n      return (FilePath)o;\n    }\n\n    return null;\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ChangesBrowserNode getParentNodeFor(ChangesBrowserNode node,\n                                Map<FilePath, ChangesBrowserNode> folderNodesCache,\n                                Map<Module, ChangesBrowserNode> moduleNodesCache,\n                                ChangesBrowserNode rootNode) {\n    if (showFlatten) {\n      return rootNode;\n    }\n\n    ProjectFileIndex index = ProjectRootManager.getInstance(project).getFileIndex();\n    final FilePath path = getPathForObject(node.getUserObject());\n\n    final VirtualFile rootFolder = VcsDirtyScope.getRootFor(index, path);\n    if (rootFolder != null) {\n      if (path.getVirtualFile() == rootFolder) {\n        Module module = index.getModuleForFile(rootFolder);\n        return getNodeForModule(module, moduleNodesCache, rootNode);\n      }\n    }\n\n    FilePath parentPath = path.getParentPath();\n    if (parentPath == null) {\n      return rootNode;\n    }\n\n    ChangesBrowserNode parentNode = folderNodesCache.get(parentPath);\n    if (parentNode == null) {\n      parentNode = new ChangesBrowserNode(parentPath);\n      ChangesBrowserNode grandPa = getParentNodeFor(parentNode, folderNodesCache, moduleNodesCache, rootNode);\n      model.insertNodeInto(parentNode, grandPa, grandPa.getChildCount());\n      folderNodesCache.put(parentPath, parentNode);\n    }\n\n    return parentNode;\n  }","id":104266,"modified_method":"private ChangesBrowserNode getParentNodeFor(ChangesBrowserNode node,\n                                Map<FilePath, ChangesBrowserNode> folderNodesCache,\n                                Map<Module, ChangesBrowserNode> moduleNodesCache,\n                                ChangesBrowserNode rootNode) {\n    if (showFlatten) {\n      return rootNode;\n    }\n\n    ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n    final FilePath path = getPathForObject(node.getUserObject());\n\n    final VirtualFile rootFolder = VcsDirtyScope.getRootFor(index, path);\n    if (rootFolder != null) {\n      if (path.getVirtualFile() == rootFolder) {\n        Module module = index.getModuleForFile(rootFolder);\n        return getNodeForModule(module, moduleNodesCache, rootNode);\n      }\n    }\n\n    FilePath parentPath = path.getParentPath();\n    if (parentPath == null) {\n      return rootNode;\n    }\n\n    ChangesBrowserNode parentNode = folderNodesCache.get(parentPath);\n    if (parentNode == null) {\n      parentNode = new ChangesBrowserNode(myProject, parentPath);\n      ChangesBrowserNode grandPa = getParentNodeFor(parentNode, folderNodesCache, moduleNodesCache, rootNode);\n      model.insertNodeInto(parentNode, grandPa, grandPa.getChildCount());\n      folderNodesCache.put(parentPath, parentNode);\n    }\n\n    return parentNode;\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insertChangeNode(final Change change, final HashMap<FilePath, ChangesBrowserNode> foldersCache, final HashMap<Module, ChangesBrowserNode> moduleCache,\n                                final ChangesBrowserNode listNode) {\n    final FilePath nodePath = ChangesUtil.getFilePath(change);\n    nodePath.refresh();\n    ChangesBrowserNode oldNode = foldersCache.get(nodePath);\n    if (oldNode != null) {\n      oldNode.setUserObject(change);\n    }\n    else {\n      final ChangesBrowserNode node = new ChangesBrowserNode(change);\n      model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, listNode), 0);\n      foldersCache.put(nodePath, node);\n    }\n  }","id":104267,"modified_method":"private void insertChangeNode(final Object change, final HashMap<FilePath, ChangesBrowserNode> foldersCache, final HashMap<Module, ChangesBrowserNode> moduleCache,\n                                final ChangesBrowserNode listNode) {\n    final FilePath nodePath = getPathForObject(change);\n    nodePath.refresh();\n    ChangesBrowserNode oldNode = foldersCache.get(nodePath);\n    if (oldNode != null) {\n      oldNode.setUserObject(change);\n    }\n    else {\n      final ChangesBrowserNode node = new ChangesBrowserNode(myProject, change);\n      model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, listNode), 0);\n      foldersCache.put(nodePath, node);\n    }\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void collapseDirectories(DefaultTreeModel model, ChangesBrowserNode node) {\n    if (node.getUserObject() instanceof FilePath && node.getChildCount() == 1) {\n      final ChangesBrowserNode child = (ChangesBrowserNode)node.getChildAt(0);\n      if (child.getUserObject() instanceof FilePath && !child.isLeaf()) {\n        ChangesBrowserNode parent = (ChangesBrowserNode)node.getParent();\n        final int idx = parent.getIndex(node);\n        model.removeNodeFromParent(node);\n        model.removeNodeFromParent(child);\n        model.insertNodeInto(child, parent, idx);\n        collapseDirectories(model, parent);\n      }\n    }\n    else {\n      final Enumeration children = node.children();\n      while (children.hasMoreElements()) {\n        ChangesBrowserNode child = (ChangesBrowserNode)children.nextElement();\n        collapseDirectories(model, child);\n      }\n    }\n  }","id":104268,"modified_method":"private static void collapseDirectories(DefaultTreeModel model, ChangesBrowserNode node) {\n    if (node.getUserObject() instanceof FilePath && node.getChildCount() == 1) {\n      final ChangesBrowserNode child = (ChangesBrowserNode)node.getChildAt(0);\n      if (child.getUserObject() instanceof FilePath && !child.isLeaf()) {\n        ChangesBrowserNode parent = (ChangesBrowserNode)node.getParent();\n        final int idx = parent.getIndex(node);\n        model.removeNodeFromParent(node);\n        model.removeNodeFromParent(child);\n        model.insertNodeInto(child, parent, idx);\n        collapseDirectories(model, parent);\n      }\n    }\n    else {\n      final Enumeration children = node.children();\n      while (children.hasMoreElements()) {\n        ChangesBrowserNode child = (ChangesBrowserNode)children.nextElement();\n        collapseDirectories(model, child);\n      }\n    }\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeModelBuilder(final Project project, final boolean showFlatten) {\n    this.project = project;\n    this.showFlatten = showFlatten;\n    root = new ChangesBrowserNode(ROOT_NODE_VALUE);\n    model = new DefaultTreeModel(root);\n  }","id":104269,"modified_method":"public TreeModelBuilder(final Project project, final boolean showFlatten) {\n    myProject = project;\n    this.showFlatten = showFlatten;\n    root = new ChangesBrowserNode(myProject, ROOT_NODE_VALUE);\n    model = new DefaultTreeModel(root);\n  }","commit_id":"1934384f4a53c9a3b515134b80e75e0b7c3eed76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private WebDefinition() {\n        super(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, WebExtension.SUBSYSTEM_NAME),\n                WebExtension.getResourceDescriptionResolver(null)\n                , DEFAULT_VIRTUAL_SERVER, NATIVE, INSTANCE_ID);\n    }","id":104270,"modified_method":"private WebDefinition() {\n        super(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, WebExtension.SUBSYSTEM_NAME),\n                WebExtension.getResourceDescriptionResolver(null),\n                DEFAULT_VIRTUAL_SERVER, NATIVE, INSTANCE_ID, DEFAULT_SESSION_TIMEOUT);\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_2_0(SubsystemRegistration registration) {\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        final ResourceTransformationDescriptionBuilder hostBuilder = subsystemRoot.addChildResource(HOST_PATH);\n        final ResourceTransformationDescriptionBuilder rewriteBuilder = hostBuilder.addChildResource(REWRITE_PATH);\n        rewriteBuilder.addChildResource(REWRITECOND_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebReWriteConditionDefinition.FLAGS);\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .end()\n                .addChildResource(SSL_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSLDefinition.SSL_PROTOCOL)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL);\n\n\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(1, 2, 0));\n\n    }","id":104271,"modified_method":"private void registerTransformers_1_2_0(SubsystemRegistration registration) {\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        subsystemRoot.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(30)), WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder hostBuilder = subsystemRoot.addChildResource(HOST_PATH);\n        final ResourceTransformationDescriptionBuilder rewriteBuilder = hostBuilder.addChildResource(REWRITE_PATH);\n        rewriteBuilder.addChildResource(REWRITECOND_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebReWriteConditionDefinition.FLAGS);\n        final ResourceTransformationDescriptionBuilder ssoBuilder = hostBuilder.addChildResource(SSO_PATH);\n        ssoBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSODefinition.HTTP_ONLY)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(true)), WebSSODefinition.HTTP_ONLY)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .end()\n                .addChildResource(SSL_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSLDefinition.SSL_PROTOCOL)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL);\n\n\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(1, 2, 0));\n\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected Set<ManagementResourceRegistration> initializeLegacyModel(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WebDefinition.INSTANCE);\n        subsystem.registerXMLElementWriter(WebSubsystemParser.getInstance());\n\n        // connectors\n        final ManagementResourceRegistration connectors = registration.registerSubModel(WebConnectorDefinition.INSTANCE);\n\n        final ManagementResourceRegistration ssl = connectors.registerSubModel(WebSSLDefinition.INSTANCE);\n        connectors.registerAlias(SSL_ALIAS, new StandardWebExtensionAliasEntry(ssl));\n\n        //hosts\n        final ManagementResourceRegistration hosts = registration.registerSubModel(WebVirtualHostDefinition.INSTANCE);\n\n        // access-log.\n        final ManagementResourceRegistration accesslog = hosts.registerSubModel(WebAccessLogDefinition.INSTANCE);\n        hosts.registerAlias(ACCESS_LOG_ALIAS, new StandardWebExtensionAliasEntry(accesslog));\n\n        // access-log.\n        // the directory needs one level more\n        final ManagementResourceRegistration accessLogDir = accesslog.registerSubModel(WebAccessLogDirectoryDefinition.INSTANCE);\n        accesslog.registerAlias(DIRECTORY_ALIAS, new StandardWebExtensionAliasEntry(accessLogDir));\n\n        // sso valve.\n        final ManagementResourceRegistration sso = hosts.registerSubModel(WebSSODefinition.INSTANCE);\n        hosts.registerAlias(SSO_ALIAS, new StandardWebExtensionAliasEntry(sso));\n\n        // rewrite valve.\n        final ManagementResourceRegistration rewrite = hosts.registerSubModel(WebReWriteDefinition.INSTANCE);\n\n        // the condition needs one level more\n        rewrite.registerSubModel(WebReWriteConditionDefinition.INSTANCE);\n\n        // configuration=jsp\n        registration.registerSubModel(WebJSPDefinition.INSTANCE);\n\n        // configuration=resources\n        registration.registerSubModel(WebStaticResources.INSTANCE);\n\n        // configuration=container\n        registration.registerSubModel(WebContainerDefinition.INSTANCE);\n\n\n        // Global valve.\n        registration.registerSubModel(WebValveDefinition.INSTANCE);\n\n        if (context.isRegisterTransformers()) {\n            registerTransformers_1_1_x(subsystem, 0);\n            registerTransformers_1_1_x(subsystem, 1);\n            registerTransformers_1_2_0(subsystem);\n            registerTransformers_1_3_0(subsystem);\n            registerTransformers_2_0_0(subsystem);\n        }\n        return Collections.singleton(registration);\n    }","id":104272,"modified_method":"@Override\n    protected Set<ManagementResourceRegistration> initializeLegacyModel(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WebDefinition.INSTANCE);\n        subsystem.registerXMLElementWriter(WebSubsystemParser.getInstance());\n\n        // connectors\n        final ManagementResourceRegistration connectors = registration.registerSubModel(WebConnectorDefinition.INSTANCE);\n\n        final ManagementResourceRegistration ssl = connectors.registerSubModel(WebSSLDefinition.INSTANCE);\n        connectors.registerAlias(SSL_ALIAS, new StandardWebExtensionAliasEntry(ssl));\n\n        //hosts\n        final ManagementResourceRegistration hosts = registration.registerSubModel(WebVirtualHostDefinition.INSTANCE);\n\n        // access-log.\n        final ManagementResourceRegistration accesslog = hosts.registerSubModel(WebAccessLogDefinition.INSTANCE);\n        hosts.registerAlias(ACCESS_LOG_ALIAS, new StandardWebExtensionAliasEntry(accesslog));\n\n        // access-log.\n        // the directory needs one level more\n        final ManagementResourceRegistration accessLogDir = accesslog.registerSubModel(WebAccessLogDirectoryDefinition.INSTANCE);\n        accesslog.registerAlias(DIRECTORY_ALIAS, new StandardWebExtensionAliasEntry(accessLogDir));\n\n        // sso valve.\n        final ManagementResourceRegistration sso = hosts.registerSubModel(WebSSODefinition.INSTANCE);\n        hosts.registerAlias(SSO_ALIAS, new StandardWebExtensionAliasEntry(sso));\n\n        // rewrite valve.\n        final ManagementResourceRegistration rewrite = hosts.registerSubModel(WebReWriteDefinition.INSTANCE);\n\n        // the condition needs one level more\n        rewrite.registerSubModel(WebReWriteConditionDefinition.INSTANCE);\n\n        // configuration=jsp\n        registration.registerSubModel(WebJSPDefinition.INSTANCE);\n\n        // configuration=resources\n        registration.registerSubModel(WebStaticResources.INSTANCE);\n\n        // configuration=container\n        registration.registerSubModel(WebContainerDefinition.INSTANCE);\n\n\n        // Global valve.\n        registration.registerSubModel(WebValveDefinition.INSTANCE);\n\n        if (context.isRegisterTransformers()) {\n            registerTransformers_1_1_x(subsystem, 0);\n            registerTransformers_1_1_x(subsystem, 1);\n            registerTransformers_1_2_0(subsystem);\n            registerTransformers_1_3_0(subsystem);\n            registerTransformers_1_4_0(subsystem);\n            registerTransformers_2_0_0(subsystem);\n        }\n        return Collections.singleton(registration);\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_3_0(SubsystemRegistration registration) {\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .end();\n\n\n        connectorBuilder.addChildResource(SSL_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .end();\n\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(1, 3, 0));\n    }","id":104273,"modified_method":"private void registerTransformers_1_3_0(SubsystemRegistration registration) {\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        subsystemRoot.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(30)), WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder hostBuilder = subsystemRoot.addChildResource(HOST_PATH);\n        final ResourceTransformationDescriptionBuilder ssoBuilder = hostBuilder.addChildResource(SSO_PATH);\n        ssoBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSODefinition.HTTP_ONLY)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(true)), WebSSODefinition.HTTP_ONLY)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .end();\n\n        connectorBuilder.addChildResource(SSL_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .end();\n\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(1, 3, 0));\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_1_x(SubsystemRegistration registration, int micro) {\n\n        final int defaultRedirectPort = 443;\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        // Discard valve\n        subsystemRoot.rejectChildResource(VALVE_PATH);\n\n        // Reject expressions for configuration\n        subsystemRoot.addChildResource(JSP_CONFIGURATION_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebJSPDefinition.JSP_ATTRIBUTES);\n        subsystemRoot.addChildResource(STATIC_RESOURCES_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebStaticResources.STATIC_ATTRIBUTES);\n        subsystemRoot.addChildResource(CONTAINER_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebContainerDefinition.CONTAINER_ATTRIBUTES);\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebConnectorDefinition.CONNECTOR_ATTRIBUTES)\n                .setValueConverter(new AttributeConverter.DefaultAttributeConverter() {\n                    @Override\n                    protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {\n                        if (!attributeValue.isDefined()) {\n                            attributeValue.set(defaultRedirectPort);\n                        }\n                    }\n                }, WebConnectorDefinition.REDIRECT_PORT.getName())\n                .end()\n                .addOperationTransformationOverride(UNDEFINE_ATTRIBUTE_OPERATION)\n                .inheritResourceAttributeDefinitions() // although probably not necessary\n                .setCustomOperationTransformer(new OperationTransformer() {\n                    @Override\n                    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) throws OperationFailedException {\n                        final String attributeName = operation.require(NAME).asString();\n                        if (WebConnectorDefinition.REDIRECT_PORT.getName().equals(attributeName)) {\n                            final ModelNode transformed = new ModelNode();\n                            transformed.get(OP).set(WRITE_ATTRIBUTE_OPERATION);\n                            transformed.get(OP_ADDR).set(address.toModelNode());\n                            transformed.get(NAME).set(attributeName);\n                            transformed.get(VALUE).set(defaultRedirectPort);\n                            return new TransformedOperation(transformed, OperationResultTransformer.ORIGINAL_RESULT);\n                        }\n                        return new TransformedOperation(operation, OperationResultTransformer.ORIGINAL_RESULT);\n                    }\n                });\n        if (micro == 0) {\n                connectorBuilder.getAttributeBuilder().addRejectCheck(new RejectAttributeChecker.DefaultRejectAttributeChecker() {\n                    @Override\n                    protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {\n                        return attributeValue.isDefined();\n                    }\n\n                    @Override\n                    public String getRejectionLogMessage(Map<String, ModelNode> attributes) {\n                        return WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314();\n                    }\n                }, Constants.VIRTUAL_SERVER);\n        }\n\n\n        //\n        connectorBuilder.addChildRedirection(SSL_PATH, SSL_ALIAS).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebSSLDefinition.SSL_ATTRIBUTES)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSLDefinition.SSL_PROTOCOL)\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL)\n                .setValueConverter(new AttributeConverter.DefaultAttributeConverter() {\n                    @Override\n                    protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {\n                        if (attributeValue.isDefined() && attributeValue.asString().equals(address.getLastElement().getKey())) {\n                            attributeValue.clear();\n                        }\n                    }\n                }, WebSSLDefinition.NAME)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder hostBuilder = subsystemRoot.addChildResource(HOST_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebVirtualHostDefinition.DEFAULT_WEB_MODULE)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder rewriteBuilder = hostBuilder.addChildResource(REWRITE_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebReWriteDefinition.FLAGS, WebReWriteDefinition.PATTERN, WebReWriteDefinition.SUBSTITUTION)\n                .end();\n\n        rewriteBuilder.addChildResource(REWRITECOND_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebReWriteConditionDefinition.ATTRIBUTES)\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebReWriteConditionDefinition.FLAGS);\n\n        hostBuilder.addChildRedirection(SSO_PATH, SSO_ALIAS).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebSSODefinition.SSO_ATTRIBUTES)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder accessLogBuilder = hostBuilder.addChildRedirection(ACCESS_LOG_PATH, ACCESS_LOG_ALIAS).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebAccessLogDefinition.ACCESS_LOG_ATTRIBUTES)\n                .end();\n\n        accessLogBuilder.addChildRedirection(DIRECTORY_PATH, DIRECTORY_ALIAS);\n\n        // Register\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(1, 1, micro));\n    }","id":104274,"modified_method":"private void registerTransformers_1_1_x(SubsystemRegistration registration, int micro) {\n\n        final int defaultRedirectPort = 443;\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        subsystemRoot.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(30)), WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .end();\n\n        // Discard valve\n        subsystemRoot.rejectChildResource(VALVE_PATH);\n\n        // Reject expressions for configuration\n        subsystemRoot.addChildResource(JSP_CONFIGURATION_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebJSPDefinition.JSP_ATTRIBUTES);\n        subsystemRoot.addChildResource(STATIC_RESOURCES_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebStaticResources.STATIC_ATTRIBUTES);\n        subsystemRoot.addChildResource(CONTAINER_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebContainerDefinition.CONTAINER_ATTRIBUTES);\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebConnectorDefinition.CONNECTOR_ATTRIBUTES)\n                .setValueConverter(new AttributeConverter.DefaultAttributeConverter() {\n                    @Override\n                    protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {\n                        if (!attributeValue.isDefined()) {\n                            attributeValue.set(defaultRedirectPort);\n                        }\n                    }\n                }, WebConnectorDefinition.REDIRECT_PORT.getName())\n                .end()\n                .addOperationTransformationOverride(UNDEFINE_ATTRIBUTE_OPERATION)\n                .inheritResourceAttributeDefinitions() // although probably not necessary\n                .setCustomOperationTransformer(new OperationTransformer() {\n                    @Override\n                    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) throws OperationFailedException {\n                        final String attributeName = operation.require(NAME).asString();\n                        if (WebConnectorDefinition.REDIRECT_PORT.getName().equals(attributeName)) {\n                            final ModelNode transformed = new ModelNode();\n                            transformed.get(OP).set(WRITE_ATTRIBUTE_OPERATION);\n                            transformed.get(OP_ADDR).set(address.toModelNode());\n                            transformed.get(NAME).set(attributeName);\n                            transformed.get(VALUE).set(defaultRedirectPort);\n                            return new TransformedOperation(transformed, OperationResultTransformer.ORIGINAL_RESULT);\n                        }\n                        return new TransformedOperation(operation, OperationResultTransformer.ORIGINAL_RESULT);\n                    }\n                });\n        if (micro == 0) {\n                connectorBuilder.getAttributeBuilder().addRejectCheck(new RejectAttributeChecker.DefaultRejectAttributeChecker() {\n                    @Override\n                    protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {\n                        return attributeValue.isDefined();\n                    }\n\n                    @Override\n                    public String getRejectionLogMessage(Map<String, ModelNode> attributes) {\n                        return WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314();\n                    }\n                }, Constants.VIRTUAL_SERVER);\n        }\n\n\n        //\n        connectorBuilder.addChildRedirection(SSL_PATH, SSL_ALIAS).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebSSLDefinition.SSL_ATTRIBUTES)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSLDefinition.SSL_PROTOCOL)\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL)\n                .setValueConverter(new AttributeConverter.DefaultAttributeConverter() {\n                    @Override\n                    protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {\n                        if (attributeValue.isDefined() && attributeValue.asString().equals(address.getLastElement().getKey())) {\n                            attributeValue.clear();\n                        }\n                    }\n                }, WebSSLDefinition.NAME)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder hostBuilder = subsystemRoot.addChildResource(HOST_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebVirtualHostDefinition.DEFAULT_WEB_MODULE)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder rewriteBuilder = hostBuilder.addChildResource(REWRITE_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebReWriteDefinition.FLAGS, WebReWriteDefinition.PATTERN, WebReWriteDefinition.SUBSTITUTION)\n                .end();\n\n        rewriteBuilder.addChildResource(REWRITECOND_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebReWriteConditionDefinition.ATTRIBUTES)\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebReWriteConditionDefinition.FLAGS);\n\n        hostBuilder.addChildRedirection(SSO_PATH, SSO_ALIAS).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebSSODefinition.SSO_ATTRIBUTES)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSODefinition.HTTP_ONLY)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(true)), WebSSODefinition.HTTP_ONLY)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder accessLogBuilder = hostBuilder.addChildRedirection(ACCESS_LOG_PATH, ACCESS_LOG_ALIAS).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, WebAccessLogDefinition.ACCESS_LOG_ATTRIBUTES)\n                .end();\n\n        accessLogBuilder.addChildRedirection(DIRECTORY_PATH, DIRECTORY_ALIAS);\n\n        // Register\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(1, 1, micro));\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_2_0_0(SubsystemRegistration registration) {\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .end();\n\n        connectorBuilder.addChildResource(SSL_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .end();\n\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(2, 0, 0));\n    }","id":104275,"modified_method":"private void registerTransformers_2_0_0(SubsystemRegistration registration) {\n        final ResourceTransformationDescriptionBuilder subsystemRoot = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        subsystemRoot.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(30)), WebDefinition.DEFAULT_SESSION_TIMEOUT)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder hostBuilder = subsystemRoot.addChildResource(HOST_PATH);\n        final ResourceTransformationDescriptionBuilder ssoBuilder = hostBuilder.addChildResource(SSO_PATH);\n        ssoBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebSSODefinition.HTTP_ONLY)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(true)), WebSSODefinition.HTTP_ONLY)\n                .end();\n\n        final ResourceTransformationDescriptionBuilder connectorBuilder = subsystemRoot.addChildResource(CONNECTOR_PATH);\n        connectorBuilder.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .setDiscard(DiscardAttributeChecker.UNDEFINED, WebSSLDefinition.SSL_PROTOCOL, WebConnectorDefinition.PROXY_BINDING, WebConnectorDefinition.REDIRECT_BINDING)\n                .end();\n\n        connectorBuilder.addChildResource(SSL_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, WebSSLDefinition.CIPHER_SUITE)\n                .end();\n\n        TransformationDescription.Tools.register(subsystemRoot.build(), registration, ModelVersion.create(2, 0, 0));\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseHostAccessLog(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        PathAddress address = PathAddress.pathAddress(parent, ACCESS_LOG_PATH);\n        final ModelNode log = new ModelNode();\n        log.get(OP).set(ADD);\n        log.get(OP_ADDR).set(address.toModelNode());\n\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case PATTERN:\n                    WebAccessLogDefinition.PATTERN.parseAndSetParameter(value, log, reader);\n                    break;\n                case RESOLVE_HOSTS:\n                    WebAccessLogDefinition.RESOLVE_HOSTS.parseAndSetParameter(value, log, reader);\n                    break;\n                case EXTENDED:\n                    WebAccessLogDefinition.EXTENDED.parseAndSetParameter(value, log, reader);\n                    break;\n                case PREFIX:\n                    WebAccessLogDefinition.PREFIX.parseAndSetParameter(value, log, reader);\n                    break;\n                case ROTATE:\n                    WebAccessLogDefinition.ROTATE.parseAndSetParameter(value, log, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        list.add(log);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3:\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case DIRECTORY:\n                            parseDirOrFile(reader, address, list, WebExtension.DIRECTORY_PATH);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n\n    }","id":104276,"modified_method":"static void parseHostAccessLog(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        PathAddress address = PathAddress.pathAddress(parent, ACCESS_LOG_PATH);\n        final ModelNode log = new ModelNode();\n        log.get(OP).set(ADD);\n        log.get(OP_ADDR).set(address.toModelNode());\n\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case PATTERN:\n                    WebAccessLogDefinition.PATTERN.parseAndSetParameter(value, log, reader);\n                    break;\n                case RESOLVE_HOSTS:\n                    WebAccessLogDefinition.RESOLVE_HOSTS.parseAndSetParameter(value, log, reader);\n                    break;\n                case EXTENDED:\n                    WebAccessLogDefinition.EXTENDED.parseAndSetParameter(value, log, reader);\n                    break;\n                case PREFIX:\n                    WebAccessLogDefinition.PREFIX.parseAndSetParameter(value, log, reader);\n                    break;\n                case ROTATE:\n                    WebAccessLogDefinition.ROTATE.parseAndSetParameter(value, log, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        list.add(log);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3:\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1:\n                case WEB_2_2: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case DIRECTORY:\n                            parseDirOrFile(reader, address, list, WebExtension.DIRECTORY_PATH);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n        WebDefinition.DEFAULT_VIRTUAL_SERVER.marshallAsAttribute(node, true, writer);\n        WebDefinition.INSTANCE_ID.marshallAsAttribute(node, false, writer);\n        WebDefinition.NATIVE.marshallAsAttribute(node, true, writer);\n        if (node.hasDefined(CONFIGURATION)) {\n            writeContainerConfig(writer, node.get(CONFIGURATION));\n        }\n        if (node.hasDefined(CONNECTOR)) {\n            for (final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                 List<AttributeDefinition> connectorAttributes =  new ArrayList<>(Arrays.asList(WebConnectorDefinition.CONNECTOR_ATTRIBUTES));\n                if(config.hasDefined(Constants.PROXY_BINDING)) {\n                    connectorAttributes.remove(WebConnectorDefinition.PROXY_PORT);\n                    connectorAttributes.remove(WebConnectorDefinition.PROXY_NAME);\n                } else {\n                    connectorAttributes.remove(WebConnectorDefinition.PROXY_BINDING);\n                }\n                if(config.hasDefined(Constants.REDIRECT_BINDING)) {\n                    connectorAttributes.remove(WebConnectorDefinition.REDIRECT_PORT);\n                } else {\n                    connectorAttributes.remove(WebConnectorDefinition.REDIRECT_BINDING);\n                }\n                for (AttributeDefinition attr : connectorAttributes) {\n                    if (attr instanceof SimpleAttributeDefinition) {\n                        ((SimpleAttributeDefinition) attr).marshallAsAttribute(config, true, writer);\n                    }\n                }\n                if (config.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {\n                    ModelNode sslConfig = config.get(SSL_PATH.getKey(), SSL_PATH.getValue());\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    WebSSLDefinition.NAME.marshallAsAttribute(sslConfig, writer);\n                    for (SimpleAttributeDefinition attr : WebSSLDefinition.SSL_ATTRIBUTES) {\n                        attr.marshallAsAttribute(sslConfig, false, writer);\n                    }\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for (final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n\n                writer.writeEndElement();\n            }\n        }\n        if (node.hasDefined(VIRTUAL_SERVER)) {\n            for (final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.marshallAsAttribute(config, true, writer);\n                WebVirtualHostDefinition.DEFAULT_WEB_MODULE.marshallAsAttribute(config, true, writer);\n\n                if (config.hasDefined(ALIAS)) {\n                    for (final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                if (config.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue()).isDefined()) {\n                    ModelNode accessLog = config.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue());\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n\n                    for (SimpleAttributeDefinition attr : WebAccessLogDefinition.ACCESS_LOG_ATTRIBUTES) {\n                        attr.marshallAsAttribute(accessLog, false, writer);\n                    }\n\n                    if (accessLog.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue()).isDefined()) {\n                        ModelNode directory = accessLog.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue());\n                        String name = Element.DIRECTORY.getLocalName();\n                        boolean startwritten = false;\n                        startwritten = writeAttribute(writer, WebAccessLogDirectoryDefinition.PATH, directory, startwritten,\n                                name);\n                        startwritten = writeAttribute(writer, WebAccessLogDirectoryDefinition.RELATIVE_TO, directory,\n                                startwritten, name);\n                        if (startwritten) {\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        Property prop = rewritenode.asProperty();\n                        ModelNode rewrite = prop.getValue();\n                        writer.writeStartElement(REWRITE);\n                        writer.writeAttribute(NAME, prop.getName());\n                        WebReWriteDefinition.PATTERN.marshallAsAttribute(rewrite, false, writer);\n                        WebReWriteDefinition.SUBSTITUTION.marshallAsAttribute(rewrite, false, writer);\n                        WebReWriteDefinition.FLAGS.marshallAsAttribute(rewrite, false, writer);\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                Property conditionProp = conditionnode.asProperty();\n                                ModelNode condition = conditionProp.getValue();\n                                writer.writeStartElement(CONDITION);\n                                writer.writeAttribute(NAME, conditionProp.getName());\n                                WebReWriteConditionDefinition.TEST.marshallAsAttribute(condition, false, writer);\n                                WebReWriteConditionDefinition.PATTERN.marshallAsAttribute(condition, false, writer);\n                                WebReWriteConditionDefinition.FLAGS.marshallAsAttribute(condition, false, writer);\n                                writer.writeEndElement();\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n\n                if (config.get(SSO_PATH.getKey(), SSO_PATH.getValue()).isDefined()) {\n                    final ModelNode sso;\n                    sso = config.get(SSO_PATH.getKey(), SSO_PATH.getValue());\n                    writer.writeStartElement(SSO);\n                    for (SimpleAttributeDefinition attr : WebSSODefinition.SSO_ATTRIBUTES) {\n                        attr.marshallAsAttribute(sso, false, writer);\n                    }\n                    writer.writeEndElement();\n                }\n\n                // End of the VIRTUAL_SERVER\n                writer.writeEndElement();\n            }\n            if (node.hasDefined(VALVE)) {\n                for (final Property valve : node.get(VALVE).asPropertyList()) {\n                    final ModelNode config = valve.getValue();\n                    writer.writeStartElement(Element.VALVE.getLocalName());\n                    writer.writeAttribute(NAME, valve.getName());\n                    for (AttributeDefinition attr : WebValveDefinition.ATTRIBUTES) {\n                        if (attr instanceof SimpleAttributeDefinition) {\n                            ((SimpleAttributeDefinition) attr).marshallAsAttribute(config, false, writer);\n                        }\n                    }\n                    if (config.hasDefined(PARAM)) {\n                        for (final Property entry : config.get(PARAM).asPropertyList()) {\n                            writer.writeEmptyElement(Element.PARAM.getLocalName());\n                            writer.writeAttribute(Attribute.PARAM_NAME.getLocalName(), entry.getName());\n                            writer.writeAttribute(Attribute.PARAM_VALUE.getLocalName(), entry.getValue().asString());\n                        }\n                    }\n                    writer.writeEndElement();\n\n                }\n            }\n\n        }\n        writer.writeEndElement();\n    }","id":104277,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n        WebDefinition.DEFAULT_VIRTUAL_SERVER.marshallAsAttribute(node, true, writer);\n        WebDefinition.INSTANCE_ID.marshallAsAttribute(node, false, writer);\n        WebDefinition.NATIVE.marshallAsAttribute(node, true, writer);\n        WebDefinition.DEFAULT_SESSION_TIMEOUT.marshallAsAttribute(node, false, writer);\n        if (node.hasDefined(CONFIGURATION)) {\n            writeContainerConfig(writer, node.get(CONFIGURATION));\n        }\n        if (node.hasDefined(CONNECTOR)) {\n            for (final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                 List<AttributeDefinition> connectorAttributes =  new ArrayList<>(Arrays.asList(WebConnectorDefinition.CONNECTOR_ATTRIBUTES));\n                if(config.hasDefined(Constants.PROXY_BINDING)) {\n                    connectorAttributes.remove(WebConnectorDefinition.PROXY_PORT);\n                    connectorAttributes.remove(WebConnectorDefinition.PROXY_NAME);\n                } else {\n                    connectorAttributes.remove(WebConnectorDefinition.PROXY_BINDING);\n                }\n                if(config.hasDefined(Constants.REDIRECT_BINDING)) {\n                    connectorAttributes.remove(WebConnectorDefinition.REDIRECT_PORT);\n                } else {\n                    connectorAttributes.remove(WebConnectorDefinition.REDIRECT_BINDING);\n                }\n                for (AttributeDefinition attr : connectorAttributes) {\n                    if (attr instanceof SimpleAttributeDefinition) {\n                        ((SimpleAttributeDefinition) attr).marshallAsAttribute(config, true, writer);\n                    }\n                }\n                if (config.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {\n                    ModelNode sslConfig = config.get(SSL_PATH.getKey(), SSL_PATH.getValue());\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    WebSSLDefinition.NAME.marshallAsAttribute(sslConfig, writer);\n                    for (SimpleAttributeDefinition attr : WebSSLDefinition.SSL_ATTRIBUTES) {\n                        attr.marshallAsAttribute(sslConfig, false, writer);\n                    }\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for (final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n\n                writer.writeEndElement();\n            }\n        }\n        if (node.hasDefined(VIRTUAL_SERVER)) {\n            for (final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.marshallAsAttribute(config, true, writer);\n                WebVirtualHostDefinition.DEFAULT_WEB_MODULE.marshallAsAttribute(config, true, writer);\n\n                if (config.hasDefined(ALIAS)) {\n                    for (final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                if (config.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue()).isDefined()) {\n                    ModelNode accessLog = config.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue());\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n\n                    for (SimpleAttributeDefinition attr : WebAccessLogDefinition.ACCESS_LOG_ATTRIBUTES) {\n                        attr.marshallAsAttribute(accessLog, false, writer);\n                    }\n\n                    if (accessLog.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue()).isDefined()) {\n                        ModelNode directory = accessLog.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue());\n                        String name = Element.DIRECTORY.getLocalName();\n                        boolean startwritten = false;\n                        startwritten = writeAttribute(writer, WebAccessLogDirectoryDefinition.PATH, directory, startwritten,\n                                name);\n                        startwritten = writeAttribute(writer, WebAccessLogDirectoryDefinition.RELATIVE_TO, directory,\n                                startwritten, name);\n                        if (startwritten) {\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        Property prop = rewritenode.asProperty();\n                        ModelNode rewrite = prop.getValue();\n                        writer.writeStartElement(REWRITE);\n                        writer.writeAttribute(NAME, prop.getName());\n                        WebReWriteDefinition.PATTERN.marshallAsAttribute(rewrite, false, writer);\n                        WebReWriteDefinition.SUBSTITUTION.marshallAsAttribute(rewrite, false, writer);\n                        WebReWriteDefinition.FLAGS.marshallAsAttribute(rewrite, false, writer);\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                Property conditionProp = conditionnode.asProperty();\n                                ModelNode condition = conditionProp.getValue();\n                                writer.writeStartElement(CONDITION);\n                                writer.writeAttribute(NAME, conditionProp.getName());\n                                WebReWriteConditionDefinition.TEST.marshallAsAttribute(condition, false, writer);\n                                WebReWriteConditionDefinition.PATTERN.marshallAsAttribute(condition, false, writer);\n                                WebReWriteConditionDefinition.FLAGS.marshallAsAttribute(condition, false, writer);\n                                writer.writeEndElement();\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n\n                if (config.get(SSO_PATH.getKey(), SSO_PATH.getValue()).isDefined()) {\n                    final ModelNode sso;\n                    sso = config.get(SSO_PATH.getKey(), SSO_PATH.getValue());\n                    writer.writeStartElement(SSO);\n                    for (SimpleAttributeDefinition attr : WebSSODefinition.SSO_ATTRIBUTES) {\n                        attr.marshallAsAttribute(sso, false, writer);\n                    }\n                    writer.writeEndElement();\n                }\n\n                // End of the VIRTUAL_SERVER\n                writer.writeEndElement();\n            }\n            if (node.hasDefined(VALVE)) {\n                for (final Property valve : node.get(VALVE).asPropertyList()) {\n                    final ModelNode config = valve.getValue();\n                    writer.writeStartElement(Element.VALVE.getLocalName());\n                    writer.writeAttribute(NAME, valve.getName());\n                    for (AttributeDefinition attr : WebValveDefinition.ATTRIBUTES) {\n                        if (attr instanceof SimpleAttributeDefinition) {\n                            ((SimpleAttributeDefinition) attr).marshallAsAttribute(config, false, writer);\n                        }\n                    }\n                    if (config.hasDefined(PARAM)) {\n                        for (final Property entry : config.get(PARAM).asPropertyList()) {\n                            writer.writeEmptyElement(Element.PARAM.getLocalName());\n                            writer.writeAttribute(Attribute.PARAM_NAME.getLocalName(), entry.getName());\n                            writer.writeAttribute(Attribute.PARAM_VALUE.getLocalName(), entry.getValue().asString());\n                        }\n                    }\n                    writer.writeEndElement();\n\n                }\n            }\n\n        }\n        writer.writeEndElement();\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        PathAddress address = PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME));\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).set(address.toModelNode());\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NATIVE:\n                    WebDefinition.NATIVE.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case DEFAULT_VIRTUAL_SERVER:\n                    WebDefinition.DEFAULT_VIRTUAL_SERVER.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case INSTANCE_ID:\n                    WebDefinition.INSTANCE_ID.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        list.add(subsystem);\n        boolean containerConfigDefined = false;\n        final Namespace namespace = Namespace.forUri(reader.getNamespaceURI());\n        // elements\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (namespace) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case CONTAINER_CONFIG: {\n                            parseContainerConfig(reader, address, list);\n                            containerConfigDefined = true;\n                            break;\n                        }\n                        case CONNECTOR: {\n                            parseConnector(reader, address, list);\n                            break;\n                        }\n                        case VIRTUAL_SERVER: {\n                            parseHost(reader, address, list);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case CONTAINER_CONFIG: {\n                            parseContainerConfig(reader, address, list);\n                            containerConfigDefined = true;\n                            break;\n                        }\n                        case CONNECTOR: {\n                            parseConnector(reader, address, list);\n                            break;\n                        }\n                        case VIRTUAL_SERVER: {\n                            parseHost(reader, address, list);\n                            break;\n                        }\n                        case VALVE: {\n                            parseValve(reader, address, list);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        if (!containerConfigDefined) {\n            addDefaultContainerConfig(address, list);\n        }\n\n    }","id":104278,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        PathAddress address = PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME));\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).set(address.toModelNode());\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NATIVE:\n                    WebDefinition.NATIVE.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case DEFAULT_VIRTUAL_SERVER:\n                    WebDefinition.DEFAULT_VIRTUAL_SERVER.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case INSTANCE_ID:\n                    WebDefinition.INSTANCE_ID.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case DEFAULT_SESSION_TIMEOUT:\n                    attributeSupportedSince(Namespace.WEB_2_2, reader, i);\n                    WebDefinition.DEFAULT_SESSION_TIMEOUT.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        list.add(subsystem);\n        boolean containerConfigDefined = false;\n        final Namespace namespace = Namespace.forUri(reader.getNamespaceURI());\n        // elements\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (namespace) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case CONTAINER_CONFIG: {\n                            parseContainerConfig(reader, address, list);\n                            containerConfigDefined = true;\n                            break;\n                        }\n                        case CONNECTOR: {\n                            parseConnector(reader, address, list);\n                            break;\n                        }\n                        case VIRTUAL_SERVER: {\n                            parseHost(reader, address, list);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1:\n                case WEB_2_2: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case CONTAINER_CONFIG: {\n                            parseContainerConfig(reader, address, list);\n                            containerConfigDefined = true;\n                            break;\n                        }\n                        case CONNECTOR: {\n                            parseConnector(reader, address, list);\n                            break;\n                        }\n                        case VIRTUAL_SERVER: {\n                            parseHost(reader, address, list);\n                            break;\n                        }\n                        case VALVE: {\n                            parseValve(reader, address, list);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        if (!containerConfigDefined) {\n            addDefaultContainerConfig(address, list);\n        }\n\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseSso(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        final PathAddress address = PathAddress.pathAddress(parent, WebExtension.SSO_PATH);\n        final ModelNode operation = new ModelNode();\n        operation.get(OP).set(ADD);\n        operation.get(OP_ADDR).set(address.toModelNode());\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case CACHE_CONTAINER:\n                    WebSSODefinition.CACHE_CONTAINER.parseAndSetParameter(value, operation, reader);\n                    break;\n                case CACHE_NAME:\n                    WebSSODefinition.CACHE_NAME.parseAndSetParameter(value, operation, reader);\n                    break;\n                case DOMAIN:\n                    WebSSODefinition.DOMAIN.parseAndSetParameter(value, operation, reader);\n                    break;\n                case REAUTHENTICATE:\n                    WebSSODefinition.REAUTHENTICATE.parseAndSetParameter(value, operation, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n        list.add(operation);\n    }","id":104279,"modified_method":"static void parseSso(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        final PathAddress address = PathAddress.pathAddress(parent, WebExtension.SSO_PATH);\n        final ModelNode operation = new ModelNode();\n        operation.get(OP).set(ADD);\n        operation.get(OP_ADDR).set(address.toModelNode());\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case CACHE_CONTAINER:\n                    WebSSODefinition.CACHE_CONTAINER.parseAndSetParameter(value, operation, reader);\n                    break;\n                case CACHE_NAME:\n                    WebSSODefinition.CACHE_NAME.parseAndSetParameter(value, operation, reader);\n                    break;\n                case DOMAIN:\n                    WebSSODefinition.DOMAIN.parseAndSetParameter(value, operation, reader);\n                    break;\n                case REAUTHENTICATE:\n                    WebSSODefinition.REAUTHENTICATE.parseAndSetParameter(value, operation, reader);\n                    break;\n                case HTTP_ONLY:\n                    attributeSupportedSince(Namespace.WEB_2_2, reader, i);\n                    WebSSODefinition.HTTP_ONLY.parseAndSetParameter(value, operation, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n        list.add(operation);\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseConnector(XMLExtendedStreamReader reader, PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        String name = null;\n        final ModelNode connector = new ModelNode();\n\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    name = value;\n                    break;\n                case SOCKET_BINDING:\n                    WebConnectorDefinition.SOCKET_BINDING.parseAndSetParameter(value, connector, reader);\n                    break;\n                case SCHEME:\n                    WebConnectorDefinition.SCHEME.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROTOCOL:\n                    WebConnectorDefinition.PROTOCOL.parseAndSetParameter(value, connector, reader);\n                    break;\n                case EXECUTOR:\n                    WebConnectorDefinition.EXECUTOR.parseAndSetParameter(value, connector, reader);\n                    break;\n                case ENABLED:\n                    WebConnectorDefinition.ENABLED.parseAndSetParameter(value, connector, reader);\n                    break;\n                case ENABLE_LOOKUPS:\n                    WebConnectorDefinition.ENABLE_LOOKUPS.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROXY_BINDING:\n                    attributeSupportedSince(Namespace.WEB_2_1, reader, i);\n                    WebConnectorDefinition.PROXY_BINDING.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROXY_NAME:\n                    WebConnectorDefinition.PROXY_NAME.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROXY_PORT:\n                    WebConnectorDefinition.PROXY_PORT.parseAndSetParameter(value, connector, reader);\n                    break;\n                case MAX_POST_SIZE:\n                    WebConnectorDefinition.MAX_POST_SIZE.parseAndSetParameter(value, connector, reader);\n                    break;\n                case MAX_SAVE_POST_SIZE:\n                    WebConnectorDefinition.MAX_SAVE_POST_SIZE.parseAndSetParameter(value, connector, reader);\n                    break;\n                case SECURE:\n                    WebConnectorDefinition.SECURE.parseAndSetParameter(value, connector, reader);\n                    break;\n                case REDIRECT_BINDING:\n                    attributeSupportedSince(Namespace.WEB_2_1, reader, i);\n                    WebConnectorDefinition.REDIRECT_BINDING.parseAndSetParameter(value, connector, reader);\n                    connector.remove(WebConnectorDefinition.REDIRECT_PORT.getName());\n                    break;\n                case REDIRECT_PORT:\n                    WebConnectorDefinition.REDIRECT_PORT.parseAndSetParameter(value, connector, reader);\n                    break;\n                case MAX_CONNECTIONS:\n                    WebConnectorDefinition.MAX_CONNECTIONS.parseAndSetParameter(value, connector, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        if (name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n        connector.get(OP).set(ADD);\n        PathAddress address = PathAddress.pathAddress(parent, PathElement.pathElement(CONNECTOR, name));\n        connector.get(OP_ADDR).set(address.toModelNode());\n        list.add(connector);\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3:\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case SSL:\n                            parseSsl(reader, address, list);\n                            break;\n                        case VIRTUAL_SERVER:\n                            String value = readStringAttributeElement(reader, Attribute.NAME.getLocalName());\n                            WebConnectorDefinition.VIRTUAL_SERVER.parseAndAddParameterElement(value, connector, reader);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n\n    }","id":104280,"modified_method":"static void parseConnector(XMLExtendedStreamReader reader, PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        String name = null;\n        final ModelNode connector = new ModelNode();\n\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    name = value;\n                    break;\n                case SOCKET_BINDING:\n                    WebConnectorDefinition.SOCKET_BINDING.parseAndSetParameter(value, connector, reader);\n                    break;\n                case SCHEME:\n                    WebConnectorDefinition.SCHEME.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROTOCOL:\n                    WebConnectorDefinition.PROTOCOL.parseAndSetParameter(value, connector, reader);\n                    break;\n                case EXECUTOR:\n                    WebConnectorDefinition.EXECUTOR.parseAndSetParameter(value, connector, reader);\n                    break;\n                case ENABLED:\n                    WebConnectorDefinition.ENABLED.parseAndSetParameter(value, connector, reader);\n                    break;\n                case ENABLE_LOOKUPS:\n                    WebConnectorDefinition.ENABLE_LOOKUPS.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROXY_BINDING:\n                    attributeSupportedSince(Namespace.WEB_2_1, reader, i);\n                    WebConnectorDefinition.PROXY_BINDING.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROXY_NAME:\n                    WebConnectorDefinition.PROXY_NAME.parseAndSetParameter(value, connector, reader);\n                    break;\n                case PROXY_PORT:\n                    WebConnectorDefinition.PROXY_PORT.parseAndSetParameter(value, connector, reader);\n                    break;\n                case MAX_POST_SIZE:\n                    WebConnectorDefinition.MAX_POST_SIZE.parseAndSetParameter(value, connector, reader);\n                    break;\n                case MAX_SAVE_POST_SIZE:\n                    WebConnectorDefinition.MAX_SAVE_POST_SIZE.parseAndSetParameter(value, connector, reader);\n                    break;\n                case SECURE:\n                    WebConnectorDefinition.SECURE.parseAndSetParameter(value, connector, reader);\n                    break;\n                case REDIRECT_BINDING:\n                    attributeSupportedSince(Namespace.WEB_2_1, reader, i);\n                    WebConnectorDefinition.REDIRECT_BINDING.parseAndSetParameter(value, connector, reader);\n                    connector.remove(WebConnectorDefinition.REDIRECT_PORT.getName());\n                    break;\n                case REDIRECT_PORT:\n                    WebConnectorDefinition.REDIRECT_PORT.parseAndSetParameter(value, connector, reader);\n                    break;\n                case MAX_CONNECTIONS:\n                    WebConnectorDefinition.MAX_CONNECTIONS.parseAndSetParameter(value, connector, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        if (name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n        connector.get(OP).set(ADD);\n        PathAddress address = PathAddress.pathAddress(parent, PathElement.pathElement(CONNECTOR, name));\n        connector.get(OP_ADDR).set(address.toModelNode());\n        list.add(connector);\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3:\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1:\n                case WEB_2_2: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case SSL:\n                            parseSsl(reader, address, list);\n                            break;\n                        case VIRTUAL_SERVER:\n                            String value = readStringAttributeElement(reader, Attribute.NAME.getLocalName());\n                            WebConnectorDefinition.VIRTUAL_SERVER.parseAndAddParameterElement(value, connector, reader);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseHost(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        String name = null;\n        final ModelNode host = new ModelNode();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    name = value;\n                    break;\n                case DEFAULT_WEB_MODULE:\n                    WebVirtualHostDefinition.DEFAULT_WEB_MODULE.parseAndSetParameter(value, host, reader);\n                    break;\n                case ENABLE_WELCOME_ROOT:\n                    WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.parseAndSetParameter(value, host, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        if (name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n        final PathAddress address = PathAddress.pathAddress(parent, PathElement.pathElement(VIRTUAL_SERVER, name));\n\n        host.get(OP).set(ADD);\n        host.get(OP_ADDR).set(address.toModelNode());\n        list.add(host);\n        int rewriteCount = 0;\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case ALIAS:\n                            host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                            break;\n                        case ACCESS_LOG:\n                            parseHostAccessLog(reader, address, list);\n                            break;\n                        case REWRITE:\n                            parseHostRewrite(reader, address, list, ++rewriteCount);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case ALIAS:\n                            host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                            break;\n                        case ACCESS_LOG:\n                            parseHostAccessLog(reader, address, list);\n                            break;\n                        case REWRITE:\n                            parseHostRewrite(reader, address, list, ++rewriteCount);\n                            break;\n                        case SSO:\n                            parseSso(reader, address, list);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case ALIAS:\n                            host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                            break;\n                        case ACCESS_LOG:\n                            parseHostAccessLog(reader, address, list);\n                            break;\n                        case REWRITE:\n                            parseHostRewrite(reader, address, list, ++rewriteCount);\n                            break;\n                        case SSO:\n                            parseSso(reader, address, list);\n                            break;\n                        case VALVE:\n                            parseValve(reader, address, list);\n                            break;\n\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n    }","id":104281,"modified_method":"static void parseHost(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list)\n            throws XMLStreamException {\n        String name = null;\n        final ModelNode host = new ModelNode();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    name = value;\n                    break;\n                case DEFAULT_WEB_MODULE:\n                    WebVirtualHostDefinition.DEFAULT_WEB_MODULE.parseAndSetParameter(value, host, reader);\n                    break;\n                case ENABLE_WELCOME_ROOT:\n                    WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.parseAndSetParameter(value, host, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        if (name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n        final PathAddress address = PathAddress.pathAddress(parent, PathElement.pathElement(VIRTUAL_SERVER, name));\n\n        host.get(OP).set(ADD);\n        host.get(OP_ADDR).set(address.toModelNode());\n        list.add(host);\n        int rewriteCount = 0;\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case ALIAS:\n                            host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                            break;\n                        case ACCESS_LOG:\n                            parseHostAccessLog(reader, address, list);\n                            break;\n                        case REWRITE:\n                            parseHostRewrite(reader, address, list, ++rewriteCount);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case ALIAS:\n                            host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                            break;\n                        case ACCESS_LOG:\n                            parseHostAccessLog(reader, address, list);\n                            break;\n                        case REWRITE:\n                            parseHostRewrite(reader, address, list, ++rewriteCount);\n                            break;\n                        case SSO:\n                            parseSso(reader, address, list);\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1:\n                case WEB_2_2: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case ALIAS:\n                            host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                            break;\n                        case ACCESS_LOG:\n                            parseHostAccessLog(reader, address, list);\n                            break;\n                        case REWRITE:\n                            parseHostRewrite(reader, address, list, ++rewriteCount);\n                            break;\n                        case SSO:\n                            parseSso(reader, address, list);\n                            break;\n                        case VALVE:\n                            parseValve(reader, address, list);\n                            break;\n\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseHostRewrite(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list, int rewriteCount) throws XMLStreamException {\n        final ModelNode rewrite = Util.createAddOperation();\n        final int count = reader.getAttributeCount();\n        String name = RULE_PREFIX + rewriteCount;\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case PATTERN:\n                    WebReWriteDefinition.PATTERN.parseAndSetParameter(value, rewrite, reader);\n                    break;\n                case SUBSTITUTION:\n                    WebReWriteDefinition.SUBSTITUTION.parseAndSetParameter(value, rewrite, reader);\n                    break;\n                case FLAGS:\n                    WebReWriteDefinition.FLAGS.parseAndSetParameter(value, rewrite, reader);\n                    break;\n                case NAME:\n                    name = value;\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        final PathAddress address = PathAddress.pathAddress(parent, PathElement.pathElement(REWRITE, name));\n        rewrite.get(OP_ADDR).set(address.toModelNode());\n        list.add(rewrite);\n        int conditionCount = 0;\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3:\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case CONDITION:\n                            final ModelNode condition = Util.createAddOperation();\n                            String condName = CONDITION_PREFIX + conditionCount;\n                            final int count2 = reader.getAttributeCount();\n                            for (int i = 0; i < count2; i++) {\n                                requireNoNamespaceAttribute(reader, i);\n                                final String value = reader.getAttributeValue(i);\n                                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                                switch (attribute) {\n                                    case NAME:\n                                        condName = value;\n                                        break;\n                                    case TEST:\n                                        WebReWriteConditionDefinition.TEST.parseAndSetParameter(value, condition, reader);\n                                        break;\n                                    case PATTERN:\n                                        WebReWriteConditionDefinition.PATTERN.parseAndSetParameter(value, condition, reader);\n                                        break;\n                                    case FLAGS:\n                                        WebReWriteConditionDefinition.FLAGS.parseAndSetParameter(value, condition, reader);\n                                        break;\n                                    default:\n                                        throw unexpectedAttribute(reader, i);\n                                }\n                            }\n                            PathAddress condAddress = address.append(PathElement.pathElement(CONDITION, condName));\n                            condition.get(OP_ADDR).set(condAddress.toModelNode());\n                            requireNoContent(reader);\n                            list.add(condition);\n                            conditionCount++;\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n\n    }","id":104282,"modified_method":"static void parseHostRewrite(XMLExtendedStreamReader reader, final PathAddress parent, List<ModelNode> list, int rewriteCount) throws XMLStreamException {\n        final ModelNode rewrite = Util.createAddOperation();\n        final int count = reader.getAttributeCount();\n        String name = RULE_PREFIX + rewriteCount;\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case PATTERN:\n                    WebReWriteDefinition.PATTERN.parseAndSetParameter(value, rewrite, reader);\n                    break;\n                case SUBSTITUTION:\n                    WebReWriteDefinition.SUBSTITUTION.parseAndSetParameter(value, rewrite, reader);\n                    break;\n                case FLAGS:\n                    WebReWriteDefinition.FLAGS.parseAndSetParameter(value, rewrite, reader);\n                    break;\n                case NAME:\n                    name = value;\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        final PathAddress address = PathAddress.pathAddress(parent, PathElement.pathElement(REWRITE, name));\n        rewrite.get(OP_ADDR).set(address.toModelNode());\n        list.add(rewrite);\n        int conditionCount = 0;\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEB_1_0:\n                case WEB_1_1:\n                case WEB_1_2:\n                case WEB_1_3:\n                case WEB_1_4:\n                case WEB_1_5:\n                case WEB_2_0:\n                case WEB_2_1:\n                case WEB_2_2: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case CONDITION:\n                            final ModelNode condition = Util.createAddOperation();\n                            String condName = CONDITION_PREFIX + conditionCount;\n                            final int count2 = reader.getAttributeCount();\n                            for (int i = 0; i < count2; i++) {\n                                requireNoNamespaceAttribute(reader, i);\n                                final String value = reader.getAttributeValue(i);\n                                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                                switch (attribute) {\n                                    case NAME:\n                                        condName = value;\n                                        break;\n                                    case TEST:\n                                        WebReWriteConditionDefinition.TEST.parseAndSetParameter(value, condition, reader);\n                                        break;\n                                    case PATTERN:\n                                        WebReWriteConditionDefinition.PATTERN.parseAndSetParameter(value, condition, reader);\n                                        break;\n                                    case FLAGS:\n                                        WebReWriteConditionDefinition.FLAGS.parseAndSetParameter(value, condition, reader);\n                                        break;\n                                    default:\n                                        throw unexpectedAttribute(reader, i);\n                                }\n                            }\n                            PathAddress condAddress = address.append(PathElement.pathElement(CONDITION, condName));\n                            condition.get(OP_ADDR).set(condAddress.toModelNode());\n                            requireNoContent(reader);\n                            list.add(condition);\n                            conditionCount++;\n                            break;\n                        default:\n                            throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default:\n                    throw unexpectedElement(reader);\n            }\n        }\n\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testTransformation_1_1_0(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n        String subsystemXml = readResource(\"subsystem-1.1.0.xml\");\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization())\n                .setSubsystemXml(subsystemXml);\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        checkSubsystemModelTransformation(mainServices, modelVersion, AccessLogPrefixFixer_1_1_x.INSTANCE);\n\n        ModelNode mainModel = mainServices.readWholeModel().get(SUBSYSTEM, SUBSYSTEM_NAME);\n        ModelNode legacyModel = AccessLogPrefixFixer_1_1_x.INSTANCE.fixModel(legacyServices.readWholeModel().get(SUBSYSTEM, SUBSYSTEM_NAME));\n\n        //Now do some checks to make sure that the actual data is correct in the transformed model\n        ModelNode sslConfig = mainModel.get(Constants.CONNECTOR, \"https\", Constants.CONFIGURATION, Constants.SSL);\n        Assert.assertTrue(sslConfig.isDefined());\n        Assert.assertFalse(legacyModel.get(Constants.CONNECTOR, \"https\", Constants.CONFIGURATION, Constants.SSL).isDefined());\n        sslConfig.remove(Constants.NAME);\n        compare(sslConfig, legacyModel.get(Constants.CONNECTOR, \"https\", Constants.SSL, Constants.CONFIGURATION), true);\n\n        ModelNode ssoConfig = mainModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.SSO);\n        Assert.assertTrue(ssoConfig.isDefined());\n        Assert.assertFalse(legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.SSO).isDefined());\n        compare(ssoConfig, legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.SSO, Constants.CONFIGURATION), true);\n\n        ModelNode mainAccessLog = mainModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.ACCESS_LOG);\n        Assert.assertTrue(mainAccessLog.isDefined());\n        Assert.assertFalse(legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.ACCESS_LOG).isDefined());\n        ModelNode legacyAccessLog = legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.ACCESS_LOG, Constants.CONFIGURATION);\n        Assert.assertTrue(legacyAccessLog.isDefined());\n        ModelNode mainDir = mainAccessLog.remove(Constants.SETTING).get(Constants.DIRECTORY);\n        Assert.assertTrue(mainDir.isDefined());\n        Assert.assertFalse(legacyAccessLog.hasDefined(Constants.SETTING));\n        ModelNode legacyDir = legacyAccessLog.remove(Constants.DIRECTORY).get(Constants.CONFIGURATION);\n        Assert.assertTrue(legacyDir.isDefined());\n        compare(mainDir, legacyDir);\n        compare(mainAccessLog, legacyAccessLog, true);\n\n        //This section tests stuff that was fixed in version 1.1.1, so it should fail for 1.1.0 and pass in 1.1.1\n\n        //Test that virtual server gets rejected in the legacy controller\n        ModelNode connectorWriteVirtualServer = createOperation(WRITE_ATTRIBUTE_OPERATION, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"http\");\n        connectorWriteVirtualServer.get(NAME).set(VIRTUAL_SERVER);\n        connectorWriteVirtualServer.get(VALUE).add(\"vs1\");\n        mainServices.executeForResult(connectorWriteVirtualServer);\n        ModelNode result = mainServices.executeOperation(modelVersion, mainServices.transformOperation(modelVersion, connectorWriteVirtualServer));\n        if (modelVersion.getMicro() == 0) {\n            Assert.assertTrue(result.get(FAILURE_DESCRIPTION).asString().endsWith(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314()));\n        } else {\n            checkOutcome(result);\n        }\n\n        //Grab the current connector values and remove the connector\n        ModelNode connectorValues = mainServices.readWholeModel().get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"http\");\n        Assert.assertTrue(connectorValues.hasDefined(VIRTUAL_SERVER));\n        ModelNode connectorRemove = createOperation(REMOVE, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"http\");\n        mainServices.executeForResult(connectorRemove);\n        checkOutcome(mainServices.executeOperation(modelVersion, mainServices.transformOperation(modelVersion, connectorRemove)));\n\n        //Now test that adding the connector with virtual server fails in the legacy controller\n        ModelNode connectorAdd = createOperation(ADD, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"test\");\n        for (String key : connectorValues.keys()) {\n            connectorAdd.get(key).set(connectorValues.get(key));\n        }\n        checkOutcome(mainServices.executeOperation(connectorAdd));\n        TransformedOperation transOp = mainServices.transformOperation(modelVersion, connectorAdd);\n        result = mainServices.executeOperation(modelVersion, transOp);\n        if (modelVersion.getMicro() == 0) {\n            Assert.assertEquals(FAILED, result.get(OUTCOME).asString());\n            Assert.assertTrue(result.get(FAILURE_DESCRIPTION).asString().endsWith(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314()));\n        } else {\n            checkOutcome(result);\n        }\n\n        //End - This section tests stuff that was fixed in version 1.1.1\n\n        //Now test the correction of the default redirect-port\n\n        // First, in add\n        connectorAdd = createOperation(ADD, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"as75871\");\n        for (String key : connectorValues.keys()) {\n            if (!key.equals(REDIRECT_PORT) && !key.equals(VIRTUAL_SERVER)) {\n                connectorAdd.get(key).set(connectorValues.get(key));\n            }\n        }\n        Assert.assertFalse(connectorAdd.hasDefined(REDIRECT_PORT));\n        checkOutcome(mainServices.executeOperation(connectorAdd));\n        transOp = mainServices.transformOperation(modelVersion, connectorAdd);\n        Assert.assertTrue(transOp.getTransformedOperation().hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transOp.getTransformedOperation().get(REDIRECT_PORT).asInt());\n        checkOutcome(mainServices.executeOperation(modelVersion, transOp));\n        ModelNode transformed = mainServices.readTransformedModel(modelVersion).get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, CONNECTOR, \"as75871\");\n        Assert.assertTrue(transformed.hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transformed.get(REDIRECT_PORT).asInt());\n\n        // Next, in a write-attribute setting to undefined\n        ModelNode write = createOperation(WRITE_ATTRIBUTE_OPERATION, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"as75871\");\n        write.get(NAME).set(REDIRECT_PORT);\n        write.get(VALUE);\n        transOp = mainServices.transformOperation(modelVersion, write);\n        ModelNode translatedWrite = transOp.getTransformedOperation();\n        Assert.assertTrue(translatedWrite.hasDefined(VALUE));\n        Assert.assertEquals(443, translatedWrite.get(VALUE).asInt());\n        checkOutcome(mainServices.executeOperation(modelVersion, transOp));\n        transformed = mainServices.readTransformedModel(modelVersion).get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, CONNECTOR, \"as75871\");\n        Assert.assertTrue(transformed.hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transformed.get(REDIRECT_PORT).asInt());\n\n        // Finally, test undefine-attribute translating to write-attribute\n        ModelNode undefine = createOperation(UNDEFINE_ATTRIBUTE_OPERATION, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"as75871\");\n        undefine.get(NAME).set(REDIRECT_PORT);\n        transOp = mainServices.transformOperation(modelVersion, undefine);\n        Assert.assertEquals(translatedWrite, transOp.getTransformedOperation());\n        checkOutcome(mainServices.executeOperation(modelVersion, transOp));\n        transformed = mainServices.readTransformedModel(modelVersion).get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, CONNECTOR, \"as75871\");\n        Assert.assertTrue(transformed.hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transformed.get(REDIRECT_PORT).asInt());\n    }","id":104283,"modified_method":"private void testTransformation_1_1_0(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n        String subsystemXml = readResource(\"subsystem-1.1.0.xml\");\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization())\n                .setSubsystemXml(subsystemXml);\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        checkSubsystemModelTransformation(mainServices, modelVersion, AccessLogPrefixFixer_1_1_x.INSTANCE);\n\n        ModelNode mainModel = mainServices.readWholeModel().get(SUBSYSTEM, SUBSYSTEM_NAME);\n        ModelNode legacyModel = AccessLogPrefixFixer_1_1_x.INSTANCE.fixModel(legacyServices.readWholeModel().get(SUBSYSTEM, SUBSYSTEM_NAME));\n\n        //Now do some checks to make sure that the actual data is correct in the transformed model\n        ModelNode sslConfig = mainModel.get(Constants.CONNECTOR, \"https\", Constants.CONFIGURATION, Constants.SSL);\n        Assert.assertTrue(sslConfig.isDefined());\n        Assert.assertFalse(legacyModel.get(Constants.CONNECTOR, \"https\", Constants.CONFIGURATION, Constants.SSL).isDefined());\n        sslConfig.remove(Constants.NAME);\n        compare(sslConfig, legacyModel.get(Constants.CONNECTOR, \"https\", Constants.SSL, Constants.CONFIGURATION), true);\n\n        ModelNode ssoConfig = mainModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.SSO);\n        Assert.assertTrue(ssoConfig.isDefined());\n        if (ssoConfig.hasDefined(Constants.HTTP_ONLY) && ssoConfig.get(Constants.HTTP_ONLY).asBoolean()) {\n            ssoConfig.remove(Constants.HTTP_ONLY);\n        }\n        Assert.assertFalse(legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.SSO).isDefined());\n        compare(ssoConfig, legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.SSO, Constants.CONFIGURATION), true);\n\n        ModelNode mainAccessLog = mainModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.ACCESS_LOG);\n        Assert.assertTrue(mainAccessLog.isDefined());\n        Assert.assertFalse(legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.CONFIGURATION, Constants.ACCESS_LOG).isDefined());\n        ModelNode legacyAccessLog = legacyModel.get(Constants.VIRTUAL_SERVER, \"default-host\", Constants.ACCESS_LOG, Constants.CONFIGURATION);\n        Assert.assertTrue(legacyAccessLog.isDefined());\n        ModelNode mainDir = mainAccessLog.remove(Constants.SETTING).get(Constants.DIRECTORY);\n        Assert.assertTrue(mainDir.isDefined());\n        Assert.assertFalse(legacyAccessLog.hasDefined(Constants.SETTING));\n        ModelNode legacyDir = legacyAccessLog.remove(Constants.DIRECTORY).get(Constants.CONFIGURATION);\n        Assert.assertTrue(legacyDir.isDefined());\n        compare(mainDir, legacyDir);\n        compare(mainAccessLog, legacyAccessLog, true);\n\n        //This section tests stuff that was fixed in version 1.1.1, so it should fail for 1.1.0 and pass in 1.1.1\n\n        //Test that virtual server gets rejected in the legacy controller\n        ModelNode connectorWriteVirtualServer = createOperation(WRITE_ATTRIBUTE_OPERATION, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"http\");\n        connectorWriteVirtualServer.get(NAME).set(VIRTUAL_SERVER);\n        connectorWriteVirtualServer.get(VALUE).add(\"vs1\");\n        mainServices.executeForResult(connectorWriteVirtualServer);\n        ModelNode result = mainServices.executeOperation(modelVersion, mainServices.transformOperation(modelVersion, connectorWriteVirtualServer));\n        if (modelVersion.getMicro() == 0) {\n            Assert.assertTrue(result.get(FAILURE_DESCRIPTION).asString().endsWith(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314()));\n        } else {\n            checkOutcome(result);\n        }\n\n        //Grab the current connector values and remove the connector\n        ModelNode connectorValues = mainServices.readWholeModel().get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"http\");\n        Assert.assertTrue(connectorValues.hasDefined(VIRTUAL_SERVER));\n        ModelNode connectorRemove = createOperation(REMOVE, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"http\");\n        mainServices.executeForResult(connectorRemove);\n        checkOutcome(mainServices.executeOperation(modelVersion, mainServices.transformOperation(modelVersion, connectorRemove)));\n\n        //Now test that adding the connector with virtual server fails in the legacy controller\n        ModelNode connectorAdd = createOperation(ADD, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"test\");\n        for (String key : connectorValues.keys()) {\n            connectorAdd.get(key).set(connectorValues.get(key));\n        }\n        checkOutcome(mainServices.executeOperation(connectorAdd));\n        TransformedOperation transOp = mainServices.transformOperation(modelVersion, connectorAdd);\n        result = mainServices.executeOperation(modelVersion, transOp);\n        if (modelVersion.getMicro() == 0) {\n            Assert.assertEquals(FAILED, result.get(OUTCOME).asString());\n            Assert.assertTrue(result.get(FAILURE_DESCRIPTION).asString().endsWith(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314()));\n        } else {\n            checkOutcome(result);\n        }\n\n        //End - This section tests stuff that was fixed in version 1.1.1\n\n        //Now test the correction of the default redirect-port\n\n        // First, in add\n        connectorAdd = createOperation(ADD, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"as75871\");\n        for (String key : connectorValues.keys()) {\n            if (!key.equals(REDIRECT_PORT) && !key.equals(VIRTUAL_SERVER)) {\n                connectorAdd.get(key).set(connectorValues.get(key));\n            }\n        }\n        Assert.assertFalse(connectorAdd.hasDefined(REDIRECT_PORT));\n        checkOutcome(mainServices.executeOperation(connectorAdd));\n        transOp = mainServices.transformOperation(modelVersion, connectorAdd);\n        Assert.assertTrue(transOp.getTransformedOperation().hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transOp.getTransformedOperation().get(REDIRECT_PORT).asInt());\n        checkOutcome(mainServices.executeOperation(modelVersion, transOp));\n        ModelNode transformed = mainServices.readTransformedModel(modelVersion).get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, CONNECTOR, \"as75871\");\n        Assert.assertTrue(transformed.hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transformed.get(REDIRECT_PORT).asInt());\n\n        // Next, in a write-attribute setting to undefined\n        ModelNode write = createOperation(WRITE_ATTRIBUTE_OPERATION, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"as75871\");\n        write.get(NAME).set(REDIRECT_PORT);\n        write.get(VALUE);\n        transOp = mainServices.transformOperation(modelVersion, write);\n        ModelNode translatedWrite = transOp.getTransformedOperation();\n        Assert.assertTrue(translatedWrite.hasDefined(VALUE));\n        Assert.assertEquals(443, translatedWrite.get(VALUE).asInt());\n        checkOutcome(mainServices.executeOperation(modelVersion, transOp));\n        transformed = mainServices.readTransformedModel(modelVersion).get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, CONNECTOR, \"as75871\");\n        Assert.assertTrue(transformed.hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transformed.get(REDIRECT_PORT).asInt());\n\n        // Finally, test undefine-attribute translating to write-attribute\n        ModelNode undefine = createOperation(UNDEFINE_ATTRIBUTE_OPERATION, SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, Constants.CONNECTOR, \"as75871\");\n        undefine.get(NAME).set(REDIRECT_PORT);\n        transOp = mainServices.transformOperation(modelVersion, undefine);\n        Assert.assertEquals(translatedWrite, transOp.getTransformedOperation());\n        checkOutcome(mainServices.executeOperation(modelVersion, transOp));\n        transformed = mainServices.readTransformedModel(modelVersion).get(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME, CONNECTOR, \"as75871\");\n        Assert.assertTrue(transformed.hasDefined(REDIRECT_PORT));\n        Assert.assertEquals(443, transformed.get(REDIRECT_PORT).asInt());\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testRejectingTransformers_1_3_0(ModelTestControllerVersion controllerVersion) throws Exception {\n\n        ModelVersion modelVersion = ModelVersion.create(1, 3, 0);\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(\"main services did not boot\", mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        final PathAddress subsystem = PathAddress.EMPTY_ADDRESS.append(\"subsystem\", \"web\");\n\n        List<ModelNode> xmlOps = builder.parseXmlResource(\"subsystem-2.1.0.xml\");\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"http\")),\n                            new FailedOperationTransformationConfig.NewAttributesConfig(\"redirect-binding\", \"proxy-binding\"));\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, xmlOps, config);\n\n        checkUndefinedCipherSuite(mainServices, modelVersion);\n    }","id":104284,"modified_method":"private void testRejectingTransformers_1_3_0(ModelTestControllerVersion controllerVersion) throws Exception {\n\n        ModelVersion modelVersion = ModelVersion.create(1, 3, 0);\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(\"main services did not boot\", mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        final PathAddress subsystem = PathAddress.EMPTY_ADDRESS.append(\"subsystem\", \"web\");\n\n        List<ModelNode> xmlOps = builder.parseXmlResource(\"subsystem-2.2.0.xml\");\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n        .addFailedAttribute(subsystem, new IntExpressionConfig(\"default-session-timeout\"))\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"http\")),\n                            new FailedOperationTransformationConfig.NewAttributesConfig(\"redirect-binding\", \"proxy-binding\"))\n        .addFailedAttribute(subsystem.append(\"virtual-server\", \"default-host\").append(\"configuration\", \"sso\"), new BooleanExpressionConfig(\"http-only\"));\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, xmlOps, config);\n\n        checkUndefinedCipherSuite(mainServices, modelVersion);\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testRejectExpressions_1_1_x(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(\"main services did not boot\", mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        final PathAddress subsystem = PathAddress.EMPTY_ADDRESS.append(\"subsystem\", \"web\");\n        final PathAddress defaultHost = subsystem.append(PathElement.pathElement(\"virtual-server\", \"default-host\"));\n\n        List<ModelNode> xmlOps = builder.parseXmlResource(\"subsystem.xml\");\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n        // valve\n        .addFailedAttribute(subsystem.append(VALVE_PATH), REJECTED_RESOURCE)\n                // configuration=container\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"configuration\", \"container\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"welcome-file\"))\n                // configuration=static=resources\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"configuration\", \"static-resources\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"listings\", \"sendfile\", \"file-encoding\",\n                        \"read-only\", \"webdav\", \"secret\", \"max-depth\", \"disabled\"))\n                // configuration=jsp-configuration\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"configuration\", \"jsp-configuration\")),\n                createChainedConfig(\n                        new String[]{\n                                \"development\", \"disabled\", \"keep-generated\",\n                                \"trim-spaces\", \"tag-pooling\", \"mapped-file\", \"check-interval\", \"modification-test-interval\",\n                                \"recompile-on-fail\", \"smap\", \"dump-smap\", \"generate-strings-as-char-arrays\",\n                                \"error-on-use-bean-invalid-class-attribute\", \"scratch-dir\", \"source-vm\", \"target-vm\",\n                                \"java-encoding\", \"x-powered-by\", \"display-source-fragment\"},\n                        new String[0]))\n                // connector=http\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"http\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"socket-binding\", \"enabled\", \"enable-lookups\",\n                        \"proxy-name\", \"proxy-port\", \"max-post-size\", \"max-save-post-size\", \"redirect-port\",\n                        \"max-connections\", \"executor\"))\n                // Connector https\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"https\"), PathElement.pathElement(\"configuration\", \"ssl\")),\n                new ChainedConfig(Arrays.asList(new AttributesPathAddressConfig<?>[]{\n                        new FailedOperationTransformationConfig.RejectExpressionsConfig(\"certificate-key-file\", \"ca-certificate-file\", \"key-alias\",\n                            \"password\", \"cipher-suite\", \"protocol\", \"verify-client\", \"verify-depth\", \"certificate-file\", \"ca-revocation-url\",\n                            \"ca-certificate-password\", \"keystore-type\", \"truststore-type\", \"session-cache-size\", \"session-timeout\", \"ssl-protocol\"),\n                            new FailedOperationTransformationConfig.NewAttributesConfig(\"ssl-protocol\")\n                    }),\n                    \"certificate-key-file\", \"ca-certificate-file\", \"key-alias\",\n                    \"password\", \"cipher-suite\", \"protocol\", \"verify-client\", \"verify-depth\", \"certificate-file\", \"ca-revocation-url\",\n                    \"ca-certificate-password\", \"keystore-type\", \"truststore-type\", \"session-cache-size\", \"session-timeout\", \"ssl-protocol\"));\n\n        if (modelVersion.getMicro() == 0) {\n                // Connector http-vs\n            config.addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"http-vs\")),\n                new FailedOperationTransformationConfig.NewAttributesConfig(\"virtual-server\"));\n        }\n                // virtual-server=default-host\n        config.addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"myrewrite\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"flags\", \"pattern\", \"substitution\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"flags\", \"pattern\", \"substitution\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\"), PathElement.pathElement(\"condition\", \"https\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"flags\", \"pattern\", \"test\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\"), PathElement.pathElement(\"condition\", \"no-flags\")),\n                new SetMissingRewriteConditionFlagsConfig(\"flags\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"configuration\", \"sso\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"reauthenticate\", \"domain\"));\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, xmlOps, config);\n\n        checkUndefinedCipherSuite(mainServices, modelVersion);\n    }","id":104285,"modified_method":"private void testRejectExpressions_1_1_x(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(\"main services did not boot\", mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        final PathAddress subsystem = PathAddress.EMPTY_ADDRESS.append(\"subsystem\", \"web\");\n        final PathAddress defaultHost = subsystem.append(PathElement.pathElement(\"virtual-server\", \"default-host\"));\n\n        List<ModelNode> xmlOps = builder.parseXmlResource(\"subsystem.xml\");\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n        .addFailedAttribute(subsystem, new IntExpressionConfig(\"default-session-timeout\"))\n        // valve\n        .addFailedAttribute(subsystem.append(VALVE_PATH), REJECTED_RESOURCE)\n                // configuration=container\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"configuration\", \"container\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"welcome-file\"))\n                // configuration=static=resources\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"configuration\", \"static-resources\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"listings\", \"sendfile\", \"file-encoding\",\n                        \"read-only\", \"webdav\", \"secret\", \"max-depth\", \"disabled\"))\n                // configuration=jsp-configuration\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"configuration\", \"jsp-configuration\")),\n                createChainedConfig(\n                        new String[]{\n                                \"development\", \"disabled\", \"keep-generated\",\n                                \"trim-spaces\", \"tag-pooling\", \"mapped-file\", \"check-interval\", \"modification-test-interval\",\n                                \"recompile-on-fail\", \"smap\", \"dump-smap\", \"generate-strings-as-char-arrays\",\n                                \"error-on-use-bean-invalid-class-attribute\", \"scratch-dir\", \"source-vm\", \"target-vm\",\n                                \"java-encoding\", \"x-powered-by\", \"display-source-fragment\"},\n                        new String[0]))\n                // connector=http\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"http\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"socket-binding\", \"enabled\", \"enable-lookups\",\n                        \"proxy-name\", \"proxy-port\", \"max-post-size\", \"max-save-post-size\", \"redirect-port\",\n                        \"max-connections\", \"executor\"))\n                // Connector https\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"https\"), PathElement.pathElement(\"configuration\", \"ssl\")),\n                new ChainedConfig(Arrays.asList(new AttributesPathAddressConfig<?>[]{\n                        new FailedOperationTransformationConfig.RejectExpressionsConfig(\"certificate-key-file\", \"ca-certificate-file\", \"key-alias\",\n                            \"password\", \"cipher-suite\", \"protocol\", \"verify-client\", \"verify-depth\", \"certificate-file\", \"ca-revocation-url\",\n                            \"ca-certificate-password\", \"keystore-type\", \"truststore-type\", \"session-cache-size\", \"session-timeout\", \"ssl-protocol\"),\n                            new FailedOperationTransformationConfig.NewAttributesConfig(\"ssl-protocol\")\n                    }),\n                    \"certificate-key-file\", \"ca-certificate-file\", \"key-alias\",\n                    \"password\", \"cipher-suite\", \"protocol\", \"verify-client\", \"verify-depth\", \"certificate-file\", \"ca-revocation-url\",\n                    \"ca-certificate-password\", \"keystore-type\", \"truststore-type\", \"session-cache-size\", \"session-timeout\", \"ssl-protocol\"));\n\n        if (modelVersion.getMicro() == 0) {\n                // Connector http-vs\n            config.addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"http-vs\")),\n                new FailedOperationTransformationConfig.NewAttributesConfig(\"virtual-server\"));\n        }\n                // virtual-server=default-host\n        config.addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"myrewrite\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"flags\", \"pattern\", \"substitution\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"flags\", \"pattern\", \"substitution\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\"), PathElement.pathElement(\"condition\", \"https\")),\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"flags\", \"pattern\", \"test\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\"), PathElement.pathElement(\"condition\", \"no-flags\")),\n                new SetMissingRewriteConditionFlagsConfig(\"flags\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"configuration\", \"sso\")),\n                new FailedOperationTransformationConfig.ChainedConfig(createChainedConfigList(\n                new FailedOperationTransformationConfig.RejectExpressionsConfig(\"reauthenticate\", \"domain\"),\n                new BooleanExpressionConfig(\"http-only\")), \"reauthenticate\", \"domain\", \"http-only\"));\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, xmlOps, config);\n\n        checkUndefinedCipherSuite(mainServices, modelVersion);\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        return readResource(\"subsystem-2.1.0.xml\");\n\n    }","id":104286,"modified_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        return readResource(\"subsystem-2.2.0.xml\");\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testRejectingTransformers_1_2_0(ModelTestControllerVersion controllerVersion) throws Exception {\n        ModelVersion modelVersion = ModelVersion.create(1, 2, 0);\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(\"main services did not boot\", mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        final PathAddress subsystem = PathAddress.EMPTY_ADDRESS.append(\"subsystem\", \"web\");\n        final PathAddress defaultHost = subsystem.append(PathElement.pathElement(\"virtual-server\", \"default-host\"));\n\n        List<ModelNode> xmlOps = builder.parseXmlResource(\"subsystem.xml\");\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"https\"), PathElement.pathElement(\"configuration\", \"ssl\")),\n                            new FailedOperationTransformationConfig.NewAttributesConfig(\"ssl-protocol\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\"), PathElement.pathElement(\"condition\", \"no-flags\")),\n                new SetMissingRewriteConditionFlagsConfig(\"flags\"));\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, xmlOps, config);\n\n        checkUndefinedCipherSuite(mainServices, modelVersion);\n    }","id":104287,"modified_method":"private void testRejectingTransformers_1_2_0(ModelTestControllerVersion controllerVersion) throws Exception {\n        ModelVersion modelVersion = ModelVersion.create(1, 2, 0);\n        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-web:\" + controllerVersion.getMavenGavVersion())\n                .setExtensionClassName(\"org.jboss.as.web.WebExtension\")\n                .configureReverseControllerCheck(createAdditionalInitialization(), null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(\"main services did not boot\", mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        final PathAddress subsystem = PathAddress.EMPTY_ADDRESS.append(\"subsystem\", \"web\");\n        final PathAddress defaultHost = subsystem.append(PathElement.pathElement(\"virtual-server\", \"default-host\"));\n\n        List<ModelNode> xmlOps = builder.parseXmlResource(\"subsystem.xml\");\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n        .addFailedAttribute(subsystem, new IntExpressionConfig(\"default-session-timeout\"))\n        .addFailedAttribute(subsystem.append(PathElement.pathElement(\"connector\", \"https\"), PathElement.pathElement(\"configuration\", \"ssl\")),\n                            new FailedOperationTransformationConfig.NewAttributesConfig(\"ssl-protocol\"))\n        .addFailedAttribute(defaultHost.append(PathElement.pathElement(\"rewrite\", \"with-conditions\"), PathElement.pathElement(\"condition\", \"no-flags\")),\n                new SetMissingRewriteConditionFlagsConfig(\"flags\"))\n        .addFailedAttribute(defaultHost.append(\"configuration\", \"sso\"), new BooleanExpressionConfig(\"http-only\"));\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, xmlOps, config);\n\n        checkUndefinedCipherSuite(mainServices, modelVersion);\n    }","commit_id":"dd9534d4ca15c343c258b054130a947b35454b2c","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static final boolean appendNameValue(FastStringBuffer sb, boolean found, String name, String value) {\n        if (value != null) {\n            if (found)\n                sb.append(',');\n\n            sb.append(\"\\\"\");\n            sb.append(name);\n            sb.append(\"\\\": \\\"\");\n            sb.append(value);\n            sb.append('\"');\n            return true;\n        } else {\n            return false;\n        }\n    }","id":104288,"modified_method":"private static final boolean appendNameValue(FastStringBuffer sb, boolean found, String name, String value) {\n        if (value != null) {\n            if (found)\n                sb.append(',');\n\n            sb.append(\"\\\"\");\n            sb.append(name);\n            sb.append(\"\\\": \\\"\");\n            sb.append(value);\n            sb.append('\"');\n            return true;\n        } else {\n            return found;\n        }\n    }","commit_id":"df85a4660dba1e2e9e7cbeec6b9ced6b86cb627e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Return a JSON string containing the control -> mips and variable -> control mappings for all models.\n     *\n     * Example of output:\n     *\n     * {\n     *     \"mips\": {\n     *         \"total-control\": { \"calculate\": \"$units * $price\", ... other MIPs ... },\n     *         ... other controls ...\n     *     },\n     *     \"variables\": {\n     *         \"units\": \"units-control\",\n     *         \"price\": \"price-control\"\n     *     }\n     * };\n     *\n     * @return  JSON string\n     */\n    public static String getOfflineBindMappings(XFormsContainingDocument containingDocument) {\n        final Map idsToXFormsControls = containingDocument.getXFormsControls().getCurrentControlsState().getIdsToXFormsControls();\n        final FastStringBuffer sb = new FastStringBuffer('{');\n\n        // Handle MIPs\n        sb.append(\"\\\"mips\\\": {\");\n        {\n            boolean controlFound = false;\n            // Iterate through models\n            for (Iterator h = containingDocument.getModels().iterator(); h.hasNext();) {\n                final XFormsModel currentModel = (XFormsModel) h.next();\n                final List offlineBinds = currentModel.getBinds().getOfflineBinds();\n                //  Iterate through offline binds\n                for (Iterator i = offlineBinds.iterator(); i.hasNext();) {\n                    final Bind currentBind = (Bind) i.next();\n                    final List currentNodeset = currentBind.getNodeset();\n\n                    final List boundControls = getBoundControls(idsToXFormsControls, currentNodeset);\n                    if (boundControls.size() > 0) {\n                        for (Iterator j = boundControls.iterator(); j.hasNext();) {\n                            final XFormsControl currentControl = (XFormsControl) j.next();\n\n                            if (controlFound)\n                                sb.append(',');\n                            controlFound = true;\n\n                            // Control id\n                            sb.append('\"');\n                            sb.append(currentControl.getEffectiveId());\n                            sb.append(\"\\\": {\");\n\n                            // Output MIPs\n                            boolean mipFound = false;\n                            mipFound = mipFound || appendNameValue(sb, mipFound, \"calculate\", currentBind.getCalculate());\n                            mipFound = mipFound || appendNameValue(sb, mipFound, \"relevant\", currentBind.getRelevant());\n                            mipFound = mipFound || appendNameValue(sb, mipFound, \"readonly\", currentBind.getReadonly());\n                            mipFound = mipFound || appendNameValue(sb, mipFound, \"required\", currentBind.getRequired());\n                            mipFound = mipFound || appendNameValue(sb, mipFound, \"constraint\", currentBind.getConstraint());\n\n                            // Output type MIP as an exploded QName\n                            final String typeMip = currentBind.getType();\n                            if (typeMip != null) {\n                                final QName typeMipQName = Dom4jUtils.extractTextValueQName(containingDocument.getStaticState().getNamespaceMappings(currentBind.getBindElement()), typeMip);\n                                mipFound = mipFound || appendNameValue(sb, mipFound, \"type\", Dom4jUtils.qNameToexplodedQName(typeMipQName));\n                            }\n\n                            sb.append('}');\n                        }\n                    }\n                }\n            }\n        }\n        // Handle variables\n        sb.append(\"},\\\"variables\\\": {\");\n        {\n            // Iterate through models\n            for (Iterator h = containingDocument.getModels().iterator(); h.hasNext();) {\n                final XFormsModel currentModel = (XFormsModel) h.next();\n\n                // Iterate through variables\n                // NOTE: We assume top-level or single-node context binds\n                final Map variables = currentModel.getBinds().getVariables(null);\n                boolean controlFound = false;\n                for (Iterator i = variables.entrySet().iterator(); i.hasNext();) {\n                    final Map.Entry currentEntry = (Map.Entry) i.next();\n                    final String currentVariableName = (String) currentEntry.getKey();\n                    final SequenceExtent currentSequenceExtent = (SequenceExtent) currentEntry.getValue();\n\n                    // Find controls bound to the bind exposed as a variable\n                    final List currentNodeset = sequenceExtentToList(currentSequenceExtent);\n                    final List boundControls = getBoundControls(idsToXFormsControls, currentNodeset);\n                    if (boundControls.size() > 0) {\n                        // NOTE: We only handle the first control found\n                        final String effectiveControlId = ((XFormsControl) boundControls.get(0)).getEffectiveId();\n                        controlFound = appendNameValue(sb, controlFound, currentVariableName, effectiveControlId);\n                    }\n                }\n            }\n        }\n        sb.append('}');\n        return sb.toString();\n    }","id":104289,"modified_method":"/**\n     * Return a JSON string containing the control -> mips and variable -> control mappings for all models.\n     *\n     * Example of output:\n     *\n     * {\n     *     \"mips\": {\n     *         \"total-control\": { \"calculate\": \"$units * $price\", ... other MIPs ... },\n     *         ... other controls ...\n     *     },\n     *     \"variables\": {\n     *         \"units\": \"units-control\",\n     *         \"price\": \"price-control\"\n     *     }\n     * };\n     *\n     * @return  JSON string\n     */\n    public static String getOfflineBindMappings(XFormsContainingDocument containingDocument) {\n        final Map idsToXFormsControls = containingDocument.getXFormsControls().getCurrentControlsState().getIdsToXFormsControls();\n        final FastStringBuffer sb = new FastStringBuffer('{');\n\n        // Handle MIPs\n        sb.append(\"\\\"mips\\\": {\");\n        {\n            boolean controlFound = false;\n            // Iterate through models\n            for (Iterator h = containingDocument.getModels().iterator(); h.hasNext();) {\n                final XFormsModel currentModel = (XFormsModel) h.next();\n                final List offlineBinds = currentModel.getBinds().getOfflineBinds();\n                //  Iterate through offline binds\n                for (Iterator i = offlineBinds.iterator(); i.hasNext();) {\n                    final Bind currentBind = (Bind) i.next();\n                    final List currentNodeset = currentBind.getNodeset();\n\n                    final List boundControls = getBoundControls(idsToXFormsControls, currentNodeset);\n                    if (boundControls.size() > 0) {\n                        for (Iterator j = boundControls.iterator(); j.hasNext();) {\n                            final XFormsControl currentControl = (XFormsControl) j.next();\n\n                            if (controlFound)\n                                sb.append(',');\n                            controlFound = true;\n\n                            // Control id\n                            sb.append('\"');\n                            sb.append(currentControl.getEffectiveId());\n                            sb.append(\"\\\": {\");\n\n                            // Output MIPs\n                            boolean mipFound = false;\n                            mipFound = appendNameValue(sb, mipFound, \"calculate\", currentBind.getCalculate());\n                            mipFound = appendNameValue(sb, mipFound, \"relevant\", currentBind.getRelevant());\n                            mipFound = appendNameValue(sb, mipFound, \"readonly\", currentBind.getReadonly());\n                            mipFound = appendNameValue(sb, mipFound, \"required\", currentBind.getRequired());\n                            mipFound = appendNameValue(sb, mipFound, \"constraint\", currentBind.getConstraint());\n\n                            // Output type MIP as an exploded QName\n                            final String typeMip = currentBind.getType();\n                            if (typeMip != null) {\n                                final QName typeMipQName = Dom4jUtils.extractTextValueQName(containingDocument.getStaticState().getNamespaceMappings(currentBind.getBindElement()), typeMip);\n                                mipFound = appendNameValue(sb, mipFound, \"type\", Dom4jUtils.qNameToexplodedQName(typeMipQName));\n                            }\n\n                            sb.append('}');\n                        }\n                    }\n                }\n            }\n        }\n        // Handle variables\n        sb.append(\"},\\\"variables\\\": {\");\n        {\n            // Iterate through models\n            for (Iterator h = containingDocument.getModels().iterator(); h.hasNext();) {\n                final XFormsModel currentModel = (XFormsModel) h.next();\n\n                // Iterate through variables\n                // NOTE: We assume top-level or single-node context binds\n                final Map variables = currentModel.getBinds().getVariables(null);\n                boolean controlFound = false;\n                for (Iterator i = variables.entrySet().iterator(); i.hasNext();) {\n                    final Map.Entry currentEntry = (Map.Entry) i.next();\n                    final String currentVariableName = (String) currentEntry.getKey();\n                    final SequenceExtent currentSequenceExtent = (SequenceExtent) currentEntry.getValue();\n\n                    // Find controls bound to the bind exposed as a variable\n                    final List currentNodeset = sequenceExtentToList(currentSequenceExtent);\n                    final List boundControls = getBoundControls(idsToXFormsControls, currentNodeset);\n                    if (boundControls.size() > 0) {\n                        // NOTE: We only handle the first control found\n                        final String effectiveControlId = ((XFormsControl) boundControls.get(0)).getEffectiveId();\n                        controlFound = appendNameValue(sb, controlFound, currentVariableName, effectiveControlId);\n                    }\n                }\n            }\n        }\n        sb.append('}');\n        return sb.toString();\n    }","commit_id":"df85a4660dba1e2e9e7cbeec6b9ced6b86cb627e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static boolean isArgumentDescriptionPresent(Field field) {\n        for (Class annotation: ARGUMENT_ANNOTATIONS)\n            if (field.isAnnotationPresent(annotation))\n                return true;\n        return false;\n    }","id":104290,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static boolean isArgumentAnnotationPresent(Field field) {\n        for (Class annotation: ARGUMENT_ANNOTATIONS)\n            if (field.isAnnotationPresent(annotation))\n                return true;\n        return false;\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Retrieves the argument description from the given argument source.  Will throw an exception if\n     * the given ArgumentSource\n     * @param source source of the argument.\n     * @return Argument description annotation associated with the given field.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected ArgumentDescription getArgumentDescription( ArgumentSource source ) {\n        for (Class annotation: ARGUMENT_ANNOTATIONS)\n            if (source.field.isAnnotationPresent(annotation))\n                return new ArgumentDescription(source.field.getAnnotation(annotation));\n        throw new StingException(\"ArgumentAnnotation is not present for the argument field: \" + source.field.getName());\n    }","id":104291,"modified_method":"/**\n     * Retrieves the argument description from the given argument source.  Will throw an exception if\n     * the given ArgumentSource\n     * @param source source of the argument.\n     * @return Argument description annotation associated with the given field.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Annotation getArgumentAnnotation( ArgumentSource source ) {\n        for (Class annotation: ARGUMENT_ANNOTATIONS)\n            if (source.field.isAnnotationPresent(annotation))\n                return source.field.getAnnotation(annotation);\n        throw new StingException(\"ArgumentAnnotation is not present for the argument field: \" + source.field.getName());\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * By default, argument sources create argument definitions with a set of default values.\n     * Use this method to create the one simple argument definition.\n     * @param source argument source for which to create a default definition.\n     * @return The default definition for this argument source.\n     */\n    protected ArgumentDefinition createDefaultArgumentDefinition( ArgumentSource source ) {\n        return new ArgumentDefinition( getIOType(source),\n                                       getFullName(source),\n                                       getShortName(source),\n                                       getDoc(source),\n                                       isRequired(source),\n                                       source.isFlag(),\n                                       source.isMultiValued(),\n                                       getExclusiveOf(source),\n                                       getValidationRegex(source),\n                                       getValidOptions(source) );\n    }","id":104292,"modified_method":"/**\n     * By default, argument sources create argument definitions with a set of default values.\n     * Use this method to create the one simple argument definition.\n     * @param source argument source for which to create a default definition.\n     * @return The default definition for this argument source.\n     */\n    protected ArgumentDefinition createDefaultArgumentDefinition( ArgumentSource source ) {\n        return new ArgumentDefinition( getArgumentAnnotation(source),\n                                       source.field.getName(),\n                                       source.isFlag(),\n                                       source.isMultiValued(),\n                                       getValidOptions(source) );\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the definition of the argument representing the BAM file itself.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createGenotypeFileArgumentDefinition(ArgumentSource source) {\n        ArgumentDescription description = this.getArgumentDescription(source);\n\n        boolean isFullNameProvided = description.fullName().trim().length() > 0;\n        boolean isShortNameProvided = description.shortName().trim().length() > 0;\n\n        String fullName = isFullNameProvided ? description.fullName().trim() : \"variants_out\";\n\n        // If the short name is provided, use that.  If the user hasn't provided any names at all, use\n        // the default.  If somewhere in the middle, leave the short name blank.\n        String shortName;\n        if( isShortNameProvided )\n            shortName = description.shortName().trim();\n        else if( !isFullNameProvided )\n            shortName = \"varout\";\n        else\n            shortName = null;\n\n        return new ArgumentDefinition( getIOType(source),\n                                       fullName,\n                                       shortName,\n                                       getDoc(source),\n                                       isRequired(source),\n                                       false,\n                                       source.isMultiValued(),\n                                       getExclusiveOf(source),\n                                       getValidationRegex(source),\n                                       null );\n    }","id":104293,"modified_method":"/**\n     * Gets the definition of the argument representing the BAM file itself.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createGenotypeFileArgumentDefinition(ArgumentSource source) {\n        Annotation annotation = this.getArgumentAnnotation(source);\n\n        return new ArgumentDefinition( annotation,\n                                       \"variants_out\",\n                                       \"varout\",\n                                       false,\n                                       source.isMultiValued(),\n                                       null );\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Creates the optional compression level argument for the BAM file.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createGenotypeFormatArgumentDefinition(ArgumentSource source) {\n        return new ArgumentDefinition( getIOType(source),\n                                       \"variant_output_format\",\n                                       \"vf\",\n                                       \"Format to be used to represent variants; default is VCF\",\n                                       false,\n                                       false,\n                                       false,\n                                       null,\n                                       null,\n                                       null );\n    }","id":104294,"modified_method":"/**\n     * Creates the optional compression level argument for the BAM file.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createGenotypeFormatArgumentDefinition(ArgumentSource source) {\n        Annotation annotation = this.getArgumentAnnotation(source);\n        return new ArgumentDefinition( ArgumentDefinition.getIOType(annotation),\n                                       \"variant_output_format\",\n                                       \"vf\",\n                                       \"Format to be used to represent variants; default is VCF\",\n                                       false,\n                                       false,\n                                       false,\n                                       null,\n                                       null,\n                                       null );\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Extract all the argument sources from a given object.\n     * @param sourceClass class to act as sources for other arguments.\n     * @return A list of sources associated with this object and its aggregated objects.\n     */\n    protected static List<ArgumentSource> extractArgumentSources(Class sourceClass) {\n        List<ArgumentSource> argumentSources = new ArrayList<ArgumentSource>();\n        while( sourceClass != null ) {\n            Field[] fields = sourceClass.getDeclaredFields();\n            for( Field field: fields ) {\n                if( ArgumentTypeDescriptor.isArgumentDescriptionPresent(field) )\n                    argumentSources.add( new ArgumentSource(sourceClass,field) );\n                if( field.isAnnotationPresent(ArgumentCollection.class) )\n                    argumentSources.addAll( extractArgumentSources(field.getType()) );\n            }\n            sourceClass = sourceClass.getSuperclass();\n        }\n        return argumentSources;\n    }","id":104295,"modified_method":"/**\n     * Extract all the argument sources from a given object.\n     * @param sourceClass class to act as sources for other arguments.\n     * @return A list of sources associated with this object and its aggregated objects.\n     */\n    protected static List<ArgumentSource> extractArgumentSources(Class sourceClass) {\n        List<ArgumentSource> argumentSources = new ArrayList<ArgumentSource>();\n        while( sourceClass != null ) {\n            Field[] fields = sourceClass.getDeclaredFields();\n            for( Field field: fields ) {\n                if( ArgumentTypeDescriptor.isArgumentAnnotationPresent(field) )\n                    argumentSources.add( new ArgumentSource(sourceClass,field) );\n                if( field.isAnnotationPresent(ArgumentCollection.class) )\n                    argumentSources.addAll( extractArgumentSources(field.getType()) );\n            }\n            sourceClass = sourceClass.getSuperclass();\n        }\n        return argumentSources;\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the definition of the argument representing the BAM file itself.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createBAMArgumentDefinition(ArgumentSource source) {\n        ArgumentDescription description = this.getArgumentDescription(source);\n\n        boolean isFullNameProvided = description.fullName().trim().length() > 0;\n        boolean isShortNameProvided = description.shortName().trim().length() > 0;\n\n        String fullName = isFullNameProvided ? description.fullName().trim() : DEFAULT_ARGUMENT_FULLNAME;\n\n        // If the short name is provided, use that.  If the user hasn't provided any names at all, use\n        // the default.  If somewhere in the middle, leave the short name blank.\n        String shortName;\n        if( isShortNameProvided )\n            shortName = description.shortName().trim();\n        else if( !isFullNameProvided )\n            shortName = DEFAULT_ARGUMENT_SHORTNAME;\n        else\n            shortName = null;\n\n        return new ArgumentDefinition( getIOType(source),\n                                       fullName,\n                                       shortName,\n                                       getDoc(source),\n                                       isRequired(source),\n                                       false,\n                                       source.isMultiValued(),\n                                       getExclusiveOf(source),\n                                       getValidationRegex(source),\n                                       null );\n    }","id":104296,"modified_method":"/**\n     * Gets the definition of the argument representing the BAM file itself.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createBAMArgumentDefinition(ArgumentSource source) {\n        Annotation annotation = this.getArgumentAnnotation(source);\n        return new ArgumentDefinition( annotation,\n                                       DEFAULT_ARGUMENT_FULLNAME,\n                                       DEFAULT_ARGUMENT_SHORTNAME,\n                                       false,\n                                       source.isMultiValued(),\n                                       null );\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Creates the optional compression level argument for the BAM file.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createBAMCompressionArgumentDefinition(ArgumentSource source) {\n        return new ArgumentDefinition( getIOType(source),\n                                       COMPRESSION_FULLNAME,\n                                       COMPRESSION_SHORTNAME,\n                                       \"Compression level to use for writing BAM files\",\n                                       false,\n                                       false,\n                                       false,\n                                       null,\n                                       null,\n                                       null );\n    }","id":104297,"modified_method":"/**\n     * Creates the optional compression level argument for the BAM file.\n     * @param source Argument source for the BAM file.  Must not be null.\n     * @return Argument definition for the BAM file itself.  Will not be null.\n     */\n    private ArgumentDefinition createBAMCompressionArgumentDefinition(ArgumentSource source) {\n        Annotation annotation = this.getArgumentAnnotation(source);\n        return new ArgumentDefinition( ArgumentDefinition.getIOType(annotation),\n                                       COMPRESSION_FULLNAME,\n                                       COMPRESSION_SHORTNAME,\n                                       \"Compression level to use for writing BAM files\",\n                                       false,\n                                       false,\n                                       false,\n                                       null,\n                                       null,\n                                       null );\n    }","commit_id":"178cf64a0c817b7d6c75e47ad18432e18e4ae0ec","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n  public final void initialize(TwillContext context) {\n    super.initialize(context);\n\n    name = context.getSpecification().getName();\n    Map<String, String> configs = context.getSpecification().getConfigs();\n\n    try {\n      // Load configuration\n      hConf = new Configuration();\n      hConf.clear();\n      hConf.addResource(new File(configs.get(\"hConf\")).toURI().toURL());\n\n      UserGroupInformation.setConfiguration(hConf);\n\n      cConf = CConfiguration.create(new File(configs.get(\"cConf\")));\n\n      LOG.debug(\"{} cConf {}\", name, cConf);\n      LOG.debug(\"{} HBase conf {}\", name, hConf);\n\n      doInit(context);\n\n      services = Lists.newArrayList();\n      getServices(services);\n      Preconditions.checkArgument(!services.isEmpty(), \"Should have at least one service\");\n\n    } catch (Throwable t) {\n      throw Throwables.propagate(t);\n    }\n  }","id":104298,"modified_method":"@Override\n  public final void initialize(TwillContext context) {\n    LOG.info(\"Initializing runnable {}\", name);\n    super.initialize(context);\n\n    name = context.getSpecification().getName();\n    Map<String, String> configs = context.getSpecification().getConfigs();\n\n    try {\n      // Load configuration\n      hConf = new Configuration();\n      hConf.clear();\n      hConf.addResource(new File(configs.get(\"hConf\")).toURI().toURL());\n\n      UserGroupInformation.setConfiguration(hConf);\n\n      cConf = CConfiguration.create(new File(configs.get(\"cConf\")));\n\n      LOG.debug(\"{} cConf {}\", name, cConf);\n      LOG.debug(\"{} HBase conf {}\", name, hConf);\n\n      doInit(context);\n\n      services = Lists.newArrayList();\n      getServices(services);\n      Preconditions.checkArgument(!services.isEmpty(), \"Should have at least one service\");\n      LOG.info(\"Runnable initialized {}\", name);\n    } catch (Throwable t) {\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(MetricsCollectionService.class));\n    services.add(injector.getInstance(DatasetOpExecutorService.class));\n    services.add(injector.getInstance(MetadataService.class));\n    services.add(injector.getInstance(RemoteSystemOperationsService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n  }","id":104299,"modified_method":"@Override\n  protected void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n    services.add(injector.getInstance(MetricsCollectionService.class));\n    services.add(injector.getInstance(DatasetOpExecutorService.class));\n    services.add(injector.getInstance(MetadataService.class));\n    services.add(injector.getInstance(RemoteSystemOperationsService.class));\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Set<Privilege> listPrivileges(Principal principal) throws Exception {\n    ImmutableSet.Builder<Privilege> privileges = ImmutableSet.builder();\n    for (Map.Entry<EntityId, Set<Action>> entry : getPrivileges(principal).entrySet()) {\n      for (Action action : entry.getValue()) {\n        privileges.add(new Privilege(entry.getKey(), action));\n      }\n    }\n    LOG.debug(\"Fetched privileges for principal {} as {}\", privileges.build());\n    return privileges.build();\n  }","id":104300,"modified_method":"@Override\n  public Set<Privilege> listPrivileges(Principal principal) throws Exception {\n    ImmutableSet.Builder<Privilege> privileges = ImmutableSet.builder();\n    for (Map.Entry<EntityId, Set<Action>> entry : getPrivileges(principal).entrySet()) {\n      for (Action action : entry.getValue()) {\n        privileges.add(new Privilege(entry.getKey(), action));\n      }\n    }\n    Set<Privilege> result = privileges.build();\n    LOG.debug(\"Fetched privileges for principal {} as {}\", principal, result);\n    return result;\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(ExploreExecutorService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n  }","id":104301,"modified_method":"@Override\n  protected void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n    services.add(injector.getInstance(ExploreExecutorService.class));\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void doInit(TwillContext context) {\n    CConfiguration cConf = getCConfiguration();\n    Configuration hConf = getConfiguration();\n    URL hiveSiteURL = getClass().getClassLoader().getResource(\"hive-site.xml\");\n    if (hiveSiteURL == null) {\n      // should not happen, as its added as a twill resource in MasterServiceMain\n      LOG.warn(\"hive-site.xml could not be found as a resource.\");\n    } else {\n      hConf.addResource(hiveSiteURL);\n    }\n\n    // NOTE: twill client will try to load all the classes present here - including hive classes but it\n    // will fail since Hive classes are not in master classpath, and ignore those classes silently\n    injector = createInjector(cConf, hConf);\n\n    injector.getInstance(LogAppenderInitializer.class).initialize();\n\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.EXPLORE_HTTP_USER_SERVICE));\n    LOG.info(\"Initializing runnable {}\", name);\n\n    // Set the host name to the one provided by Twill\n    cConf.set(Constants.Explore.SERVER_ADDRESS, context.getHost().getHostName());\n  }","id":104302,"modified_method":"@Override\n  protected void doInit(TwillContext context) {\n    CConfiguration cConf = getCConfiguration();\n    Configuration hConf = getConfiguration();\n    URL hiveSiteURL = getClass().getClassLoader().getResource(\"hive-site.xml\");\n    if (hiveSiteURL == null) {\n      // should not happen, as its added as a twill resource in MasterServiceMain\n      LOG.warn(\"hive-site.xml could not be found as a resource.\");\n    } else {\n      hConf.addResource(hiveSiteURL);\n    }\n\n    // NOTE: twill client will try to load all the classes present here - including hive classes but it\n    // will fail since Hive classes are not in master classpath, and ignore those classes silently\n    injector = createInjector(cConf, hConf);\n\n    injector.getInstance(LogAppenderInitializer.class).initialize();\n\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.EXPLORE_HTTP_USER_SERVICE));\n    // Set the host name to the one provided by Twill\n    cConf.set(Constants.Explore.SERVER_ADDRESS, context.getHost().getHostName());\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void doInit(TwillContext context) {\n    try {\n      getCConfiguration().set(Constants.MetricsProcessor.ADDRESS, context.getHost().getCanonicalHostName());\n      Injector injector = createGuiceInjector(getCConfiguration(), getConfiguration());\n      injector.getInstance(LogAppenderInitializer.class).initialize();\n      LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                         Constants.Logging.COMPONENT_NAME,\n                                                                         Constants.Service.METRICS_PROCESSOR));\n\n      LOG.info(\"Initializing runnable {}\", name);\n      // Set the hostname of the machine so that cConf can be used to start internal services\n      LOG.info(\"{} Setting host name to {}\", name, context.getHost().getCanonicalHostName());\n\n      zkClientService = injector.getInstance(ZKClientService.class);\n      kafkaClientService = injector.getInstance(KafkaClientService.class);\n      metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n      MetricsContext metricsContext = metricsCollectionService.getContext(METRICS_PROCESSOR_CONTEXT);\n\n      metricsProcessorService = injector.getInstance(MetricsProcessorService.class);\n      metricsProcessorService.setMetricsContext(metricsContext);\n      metricsProcessorStatusService = injector.getInstance(MetricsProcessorStatusService.class);\n      LOG.info(\"Runnable initialized {}\", name);\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","id":104303,"modified_method":"@Override\n  protected void doInit(TwillContext context) {\n    try {\n      getCConfiguration().set(Constants.MetricsProcessor.ADDRESS, context.getHost().getCanonicalHostName());\n      injector = createGuiceInjector(getCConfiguration(), getConfiguration());\n      injector.getInstance(LogAppenderInitializer.class).initialize();\n      LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                         Constants.Logging.COMPONENT_NAME,\n                                                                         Constants.Service.METRICS_PROCESSOR));\n\n      // Set the hostname of the machine so that cConf can be used to start internal services\n      LOG.info(\"{} Setting host name to {}\", name, context.getHost().getCanonicalHostName());\n\n      metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n      MetricsContext metricsContext = metricsCollectionService.getContext(METRICS_PROCESSOR_CONTEXT);\n\n      metricsProcessorService = injector.getInstance(MetricsProcessorService.class);\n      metricsProcessorService.setMetricsContext(metricsContext);\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getServices(List<? super Service> services) {\n    services.add(zkClientService);\n    services.add(kafkaClientService);\n    services.add(metricsCollectionService);\n    services.add(metricsProcessorService);\n    services.add(metricsProcessorStatusService);\n  }","id":104304,"modified_method":"@Override\n  public void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n    services.add(metricsCollectionService);\n    services.add(metricsProcessorService);\n    services.add(injector.getInstance(MetricsProcessorStatusService.class));\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getServices(List<? super Service> services) {\n    services.add(zkClient);\n    services.add(kafkaClient);\n    services.add(metricsCollectionService);\n    services.add(metricsQueryService);\n  }","id":104305,"modified_method":"@Override\n  public void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n    services.add(injector.getInstance(MetricsQueryService.class));\n    services.add(injector.getInstance(MetricsCollectionService.class));\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void doInit(TwillContext context) {\n    try {\n      // Set the hostname of the machine so that cConf can be used to start internal services\n      getCConfiguration().set(Constants.Metrics.ADDRESS, context.getHost().getCanonicalHostName());\n\n      Injector injector = createGuiceInjector(getCConfiguration(), getConfiguration());\n      injector.getInstance(LogAppenderInitializer.class).initialize();\n\n      LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                         Constants.Logging.COMPONENT_NAME,\n                                                                         Constants.Service.METRICS));\n\n      LOG.info(\"Initializing runnable {}\", name);\n      LOG.info(\"{} Setting host name to {}\", name, context.getHost().getCanonicalHostName());\n\n      zkClient = injector.getInstance(ZKClientService.class);\n      kafkaClient = injector.getInstance(KafkaClientService.class);\n\n      // Get the Metric Services\n      metricsQueryService = injector.getInstance(MetricsQueryService.class);\n      metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n      LOG.info(\"Runnable initialized {}\", name);\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","id":104306,"modified_method":"@Override\n  protected void doInit(TwillContext context) {\n    try {\n      // Set the hostname of the machine so that cConf can be used to start internal services\n      getCConfiguration().set(Constants.Metrics.ADDRESS, context.getHost().getCanonicalHostName());\n\n      injector = createGuiceInjector(getCConfiguration(), getConfiguration());\n      injector.getInstance(LogAppenderInitializer.class).initialize();\n\n      LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                         Constants.Logging.COMPONENT_NAME,\n                                                                         Constants.Service.METRICS));\n\n      LOG.info(\"{} Setting host name to {}\", name, context.getHost().getCanonicalHostName());\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(MetricsCollectionService.class));\n    services.add(injector.getInstance(StreamHttpService.class));\n    services.add(injector.getInstance(StreamService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n  }","id":104307,"modified_method":"@Override\n  protected void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n    services.add(injector.getInstance(MetricsCollectionService.class));\n    services.add(injector.getInstance(StreamHttpService.class));\n    services.add(injector.getInstance(StreamService.class));\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getServices(List<? super Service> services) {\n    services.add(zkClient);\n    services.add(kafkaClient);\n    services.add(metricsCollectionService);\n    services.add(txService);\n  }","id":104308,"modified_method":"@Override\n  public void getServices(List<? super Service> services) {\n    services.add(injector.getInstance(ZKClientService.class));\n    services.add(injector.getInstance(KafkaClientService.class));\n    services.add(injector.getInstance(AuthorizationEnforcementService.class));\n    services.add(injector.getInstance(MetricsCollectionService.class));\n    services.add(injector.getInstance(TransactionService.class));\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void doInit(TwillContext context) {\n    try {\n      getCConfiguration().set(Constants.Transaction.Container.ADDRESS, context.getHost().getCanonicalHostName());\n\n      Injector injector = createGuiceInjector(getCConfiguration(), getConfiguration());\n      injector.getInstance(LogAppenderInitializer.class).initialize();\n      LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                         Constants.Logging.COMPONENT_NAME,\n                                                                         Constants.Service.TRANSACTION));\n\n      LOG.info(\"Initializing runnable {}\", name);\n      // Set the hostname of the machine so that cConf can be used to start internal services\n      LOG.info(\"{} Setting host name to {}\", name, context.getHost().getCanonicalHostName());\n\n\n      //Get ZooKeeper and Kafka Client Instances\n      zkClient = injector.getInstance(ZKClientService.class);\n      kafkaClient = injector.getInstance(KafkaClientService.class);\n\n      // Get the metrics collection service\n      metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n      // Get the Transaction Service\n      txService = injector.getInstance(TransactionService.class);\n\n      LOG.info(\"Runnable initialized {}\", name);\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","id":104309,"modified_method":"@Override\n  protected void doInit(TwillContext context) {\n    try {\n      getCConfiguration().set(Constants.Transaction.Container.ADDRESS, context.getHost().getCanonicalHostName());\n\n      injector = createGuiceInjector(getCConfiguration(), getConfiguration());\n      injector.getInstance(LogAppenderInitializer.class).initialize();\n      LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(NamespaceId.SYSTEM.getNamespace(),\n                                                                         Constants.Logging.COMPONENT_NAME,\n                                                                         Constants.Service.TRANSACTION));\n\n      // Set the hostname of the machine so that cConf can be used to start internal services\n      LOG.info(\"{} Setting host name to {}\", name, context.getHost().getCanonicalHostName());\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"031e885c20ac4326d7b76d030c305e0e1b1168c8","url":"https://github.com/caskdata/cdap"},{"original_method":"private void initialize(DataSource ds, RDBOptions options) throws Exception {\n\n        this.tnData = RDBJDBCTools.createTableName(options.getTablePrefix(), \"DATASTORE_DATA\");\n        this.tnMeta = RDBJDBCTools.createTableName(options.getTablePrefix(), \"DATASTORE_META\");\n\n        this.ch = new RDBConnectionHandler(ds);\n        Connection con = this.ch.getRWConnection();\n        DatabaseMetaData md = con.getMetaData();\n        String dbDesc = md.getDatabaseProductName() + \" \" + md.getDatabaseProductVersion();\n        String driverDesc = md.getDriverName() + \" \" + md.getDriverVersion();\n        String dbUrl = md.getURL();\n\n        List<String> tablesCreated = new ArrayList<String>();\n        List<String> tablesPresent = new ArrayList<String>();\n\n        Statement createStatement = null;\n\n        try {\n            for (String tableName : new String[] { this.tnData, this.tnMeta }) {\n                PreparedStatement checkStatement = null;\n                try {\n                    checkStatement = con.prepareStatement(\"select ID from \" + tableName + \" where ID = ?\");\n                    checkStatement.setString(1, \"0\");\n                    checkStatement.executeQuery();\n                    checkStatement.close();\n                    checkStatement = null;\n                    con.commit();\n                    tablesPresent.add(tableName);\n                } catch (SQLException ex) {\n                    this.ch.closeStatement(checkStatement);\n \n                    // table does not appear to exist\n                    con.rollback();\n\n                    DB db = DB.getValue(md.getDatabaseProductName());\n\n                    createStatement = con.createStatement();\n\n                    if (this.tnMeta.equals(tableName)) {\n                        String ct = db.getMetaTableCreationStatement(tableName);\n                        createStatement.execute(ct);\n                    } else {\n                        String ct = db.getDataTableCreationStatement(tableName);\n                        createStatement.execute(ct);\n                    }\n\n                    createStatement.close();\n                    createStatement = null;\n\n                    con.commit();\n\n                    tablesCreated.add(tableName);\n                }\n            }\n\n            if (options.isDropTablesOnClose()) {\n                tablesToBeDropped.addAll(tablesCreated);\n            }\n\n            LOG.info(\"RDBBlobStore instantiated for database \" + dbDesc + \", using driver: \" + driverDesc + \", connecting to: \"\n                    + dbUrl);\n            if (!tablesPresent.isEmpty()) {\n                LOG.info(\"Tables present upon startup: \" + tablesPresent);\n            }\n            if (!tablesCreated.isEmpty()) {\n                LOG.info(\"Tables created upon startup: \" + tablesCreated\n                        + (options.isDropTablesOnClose() ? \" (will be dropped on exit)\" : \"\"));\n            }\n\n            this.callStack = LOG.isDebugEnabled() ? new Exception(\"call stack of RDBBlobStore creation\") : null;\n        } finally {\n            this.ch.closeStatement(createStatement);\n            this.ch.closeConnection(con);\n        }\n    }","id":104310,"modified_method":"private void initialize(DataSource ds, RDBOptions options) throws Exception {\n\n        this.tnData = RDBJDBCTools.createTableName(options.getTablePrefix(), \"DATASTORE_DATA\");\n        this.tnMeta = RDBJDBCTools.createTableName(options.getTablePrefix(), \"DATASTORE_META\");\n\n        this.ch = new RDBConnectionHandler(ds);\n        Connection con = this.ch.getRWConnection();\n        DatabaseMetaData md = con.getMetaData();\n        String dbDesc = String.format(\"%s %s (%d.%d)\", md.getDatabaseProductName(), md.getDatabaseProductVersion(),\n                md.getDatabaseMajorVersion(), md.getDatabaseMinorVersion());\n        String driverDesc = String.format(\"%s %s (%d.%d)\", md.getDriverName(), md.getDriverVersion(), md.getDriverMajorVersion(),\n                md.getDriverMinorVersion());\n        String dbUrl = md.getURL();\n\n        List<String> tablesCreated = new ArrayList<String>();\n        List<String> tablesPresent = new ArrayList<String>();\n\n        Statement createStatement = null;\n\n        try {\n            for (String tableName : new String[] { this.tnData, this.tnMeta }) {\n                PreparedStatement checkStatement = null;\n                try {\n                    checkStatement = con.prepareStatement(\"select ID from \" + tableName + \" where ID = ?\");\n                    checkStatement.setString(1, \"0\");\n                    checkStatement.executeQuery();\n                    checkStatement.close();\n                    checkStatement = null;\n                    con.commit();\n                    tablesPresent.add(tableName);\n                } catch (SQLException ex) {\n                    this.ch.closeStatement(checkStatement);\n \n                    // table does not appear to exist\n                    con.rollback();\n\n                    DB db = DB.getValue(md.getDatabaseProductName());\n\n                    createStatement = con.createStatement();\n\n                    if (this.tnMeta.equals(tableName)) {\n                        String ct = db.getMetaTableCreationStatement(tableName);\n                        createStatement.execute(ct);\n                    } else {\n                        String ct = db.getDataTableCreationStatement(tableName);\n                        createStatement.execute(ct);\n                    }\n\n                    createStatement.close();\n                    createStatement = null;\n\n                    con.commit();\n\n                    tablesCreated.add(tableName);\n                }\n            }\n\n            if (options.isDropTablesOnClose()) {\n                tablesToBeDropped.addAll(tablesCreated);\n            }\n\n            LOG.info(\"RDBBlobStore instantiated for database \" + dbDesc + \", using driver: \" + driverDesc + \", connecting to: \"\n                    + dbUrl);\n            if (!tablesPresent.isEmpty()) {\n                LOG.info(\"Tables present upon startup: \" + tablesPresent);\n            }\n            if (!tablesCreated.isEmpty()) {\n                LOG.info(\"Tables created upon startup: \" + tablesCreated\n                        + (options.isDropTablesOnClose() ? \" (will be dropped on exit)\" : \"\"));\n            }\n\n            this.callStack = LOG.isDebugEnabled() ? new Exception(\"call stack of RDBBlobStore creation\") : null;\n        } finally {\n            this.ch.closeStatement(createStatement);\n            this.ch.closeConnection(con);\n        }\n    }","commit_id":"80985b51a18ef61015d263d2358f5c3713fea873","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void initialize(DataSource ds, DocumentMK.Builder builder, RDBOptions options) throws Exception {\n\n        this.tnNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), \"NODES\");\n        this.tnClusterNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), \"CLUSTERNODES\");\n        this.tnSettings = RDBJDBCTools.createTableName(options.getTablePrefix(), \"SETTINGS\");\n\n        this.ch = new RDBConnectionHandler(ds);\n        this.callStack = LOG.isDebugEnabled() ? new Exception(\"call stack of RDBDocumentStore creation\") : null;\n\n        this.nodesCache = builder.buildDocumentCache(this);\n        this.cacheStats = new CacheStats(nodesCache, \"Document-Documents\", builder.getWeigher(), builder.getDocumentCacheSize());\n\n        Connection con = this.ch.getRWConnection();\n        DatabaseMetaData md = con.getMetaData();\n        String dbDesc = md.getDatabaseProductName() + \" \" + md.getDatabaseProductVersion();\n        String driverDesc = md.getDriverName() + \" \" + md.getDriverVersion();\n        String dbUrl = md.getURL();\n\n        this.db = DB.getValue(md.getDatabaseProductName());\n        this.metadata = ImmutableMap.<String,String>builder()\n                .put(\"type\", \"rdb\")\n                .put(\"db\", md.getDatabaseProductName())\n                .put(\"version\", md.getDatabaseProductVersion())\n                .build();\n        db.checkVersion(md);\n\n        if (! \"\".equals(db.getInitializationStatement())) {\n            Statement stmt = null;\n            try {\n                stmt = con.createStatement();\n                stmt.execute(db.getInitializationStatement());\n                stmt.close();\n                con.commit();\n            }\n            finally {\n                this.ch.closeStatement(stmt);\n            }\n        }\n\n        List<String> tablesCreated = new ArrayList<String>();\n        List<String> tablesPresent = new ArrayList<String>();\n        try {\n            createTableFor(con, Collection.CLUSTER_NODES, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.NODES, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.SETTINGS, tablesCreated, tablesPresent);\n        } finally {\n            con.commit();\n            con.close();\n        }\n\n        if (options.isDropTablesOnClose()) {\n            tablesToBeDropped.addAll(tablesCreated);\n        }\n\n        String diag = db.getAdditionalDiagnostics(this.ch, this.tnNodes);\n\n        LOG.info(\"RDBDocumentStore instantiated for database \" + dbDesc + \", using driver: \" + driverDesc + \", connecting to: \"\n                + dbUrl + (diag.isEmpty() ? \"\" : (\", properties: \" + diag)));\n        if (!tablesPresent.isEmpty()) {\n            LOG.info(\"Tables present upon startup: \" + tablesPresent);\n        }\n        if (!tablesCreated.isEmpty()) {\n            LOG.info(\"Tables created upon startup: \" + tablesCreated\n                    + (options.isDropTablesOnClose() ? \" (will be dropped on exit)\" : \"\"));\n        }\n    }","id":104311,"modified_method":"private void initialize(DataSource ds, DocumentMK.Builder builder, RDBOptions options) throws Exception {\n\n        this.tnNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), \"NODES\");\n        this.tnClusterNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), \"CLUSTERNODES\");\n        this.tnSettings = RDBJDBCTools.createTableName(options.getTablePrefix(), \"SETTINGS\");\n\n        this.ch = new RDBConnectionHandler(ds);\n        this.callStack = LOG.isDebugEnabled() ? new Exception(\"call stack of RDBDocumentStore creation\") : null;\n\n        this.nodesCache = builder.buildDocumentCache(this);\n        this.cacheStats = new CacheStats(nodesCache, \"Document-Documents\", builder.getWeigher(), builder.getDocumentCacheSize());\n\n        Connection con = this.ch.getRWConnection();\n        DatabaseMetaData md = con.getMetaData();\n        String dbDesc = String.format(\"%s %s (%d.%d)\", md.getDatabaseProductName(), md.getDatabaseProductVersion(),\n                md.getDatabaseMajorVersion(), md.getDatabaseMinorVersion());\n        String driverDesc = String.format(\"%s %s (%d.%d)\", md.getDriverName(), md.getDriverVersion(), md.getDriverMajorVersion(),\n                md.getDriverMinorVersion());\n        String dbUrl = md.getURL();\n\n        this.db = DB.getValue(md.getDatabaseProductName());\n        this.metadata = ImmutableMap.<String,String>builder()\n                .put(\"type\", \"rdb\")\n                .put(\"db\", md.getDatabaseProductName())\n                .put(\"version\", md.getDatabaseProductVersion())\n                .build();\n        db.checkVersion(md);\n\n        if (! \"\".equals(db.getInitializationStatement())) {\n            Statement stmt = null;\n            try {\n                stmt = con.createStatement();\n                stmt.execute(db.getInitializationStatement());\n                stmt.close();\n                con.commit();\n            }\n            finally {\n                this.ch.closeStatement(stmt);\n            }\n        }\n\n        List<String> tablesCreated = new ArrayList<String>();\n        List<String> tablesPresent = new ArrayList<String>();\n        try {\n            createTableFor(con, Collection.CLUSTER_NODES, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.NODES, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.SETTINGS, tablesCreated, tablesPresent);\n        } finally {\n            con.commit();\n            con.close();\n        }\n\n        if (options.isDropTablesOnClose()) {\n            tablesToBeDropped.addAll(tablesCreated);\n        }\n\n        String diag = db.getAdditionalDiagnostics(this.ch, this.tnNodes);\n\n        LOG.info(\"RDBDocumentStore instantiated for database \" + dbDesc + \", using driver: \" + driverDesc + \", connecting to: \"\n                + dbUrl + (diag.isEmpty() ? \"\" : (\", properties: \" + diag)));\n        if (!tablesPresent.isEmpty()) {\n            LOG.info(\"Tables present upon startup: \" + tablesPresent);\n        }\n        if (!tablesCreated.isEmpty()) {\n            LOG.info(\"Tables created upon startup: \" + tablesCreated\n                    + (options.isDropTablesOnClose() ? \" (will be dropped on exit)\" : \"\"));\n        }\n    }","commit_id":"80985b51a18ef61015d263d2358f5c3713fea873","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public DbTypeMapping getDbTypeMapping(String dbName, String dbVersion, String driverName, String driverVersion) {\n        for (final DbTypeMapping dbTypeMapping : this.dbTypeMappings) {\n            final String dbNameProp = dbTypeMapping.getDbName();\n            final String dbVersionProp = dbTypeMapping.getDbVersion();\n            final String driverNameProp = dbTypeMapping.getDriverName();\n            final String driverVersionProp = dbTypeMapping.getDriverVersion();\n\n            if (dbNameProp.equalsIgnoreCase(dbName) \n                    && dbVersionProp.equalsIgnoreCase(dbVersion)\n                    && driverNameProp.equalsIgnoreCase(driverName)\n                    && (driverVersionProp.equalsIgnoreCase(driverVersion) || driverVersion == null)) {\n\n                // Found a matching database/driver combination\n                return dbTypeMapping;\n            }\n        }\n        \n        throw new IllegalStateException(\"*************** No <db-type-mapping> exists for the current configuration. ********************\\n\" +\n                \"<db-type-mapping>\\n\" +\n                \"    <db-name>\" + dbName + \"<\/db-name>\\n\" +\n                \"    <db-version>\" + dbVersion + \"<\/db-version>\\n\" +\n                \"    <driver-name>\" + driverName + \"<\/driver-name>\\n\" +\n                \"    <driver-version>\" + driverVersion + \"<\/driver-version>\\n\" +\n                \"<\/db-type-mapping>\\n\" +\n                \"Add this EXACT type mapping fragment to 'uportal-impl/src/main/resources/properties/db/dbloader.xml' along with any needed <type> mappings and re-run the command.\\n\" +\n                \"For example <type> mappings look for existing <db-type-mapping> entries for the same database you are using.\");\n    }","id":104312,"modified_method":"public DbTypeMapping getDbTypeMapping(String dbName, String dbVersion, String driverName, String driverVersion) {\n        for (final DbTypeMapping dbTypeMapping : this.dbTypeMappings) {\n            final String dbNameProp = dbTypeMapping.getDbName();\n            final String dbVersionProp = dbTypeMapping.getDbVersion();\n            final String driverNameProp = dbTypeMapping.getDriverName();\n            final String driverVersionProp = dbTypeMapping.getDriverVersion();\n\n            if (dbNameProp.equalsIgnoreCase(dbName) \n                    && dbVersionProp.equalsIgnoreCase(dbVersion)\n                    && driverNameProp.equalsIgnoreCase(driverName)\n                    && (driverVersionProp.equalsIgnoreCase(driverVersion) || driverVersion == null)) {\n\n                // Found a matching database/driver combination\n                return dbTypeMapping;\n            }\n        }\n        \n        throw new IllegalStateException(\"*************** No <db-type-mapping> exists for the current configuration. ********************\\n\" +\n                \"<db-type-mapping>\\n\" +\n                \"    <db-name>\" + dbName + \"<\/db-name>\\n\" +\n                \"    <db-version>\" + dbVersion + \"<\/db-version>\\n\" +\n                \"    <driver-name>\" + driverName + \"<\/driver-name>\\n\" +\n                \"    <driver-version>\" + driverVersion + \"<\/driver-version>\\n\" +\n                \"<\/db-type-mapping>\\n\" +\n                \"Add this EXACT (minus any '[java] ' prefix if there is one) type mapping fragment to 'uportal-impl/src/main/resources/properties/db/dbloader.xml' along with any needed <type> mappings and re-run the command.\\n\" +\n                \"For example <type> mappings look for existing <db-type-mapping> entries for the same database you are using.\");\n    }","commit_id":"0a9ee190828650a51cef2a21629372c93c5a9835","url":"https://github.com/Jasig/uPortal"},{"original_method":"static String getLocalDataTypeName (Configuration config,\n      String genericDataTypeName)\n    {\n\n\n      String localDataTypeName = null;\n\n      try\n      {\n        DatabaseMetaData dbmd = config.getConnection().getMetaData();\n        String dbName = dbmd.getDatabaseProductName();\n        String dbVersion = dbmd.getDatabaseProductVersion();\n        String driverName = dbmd.getDriverName();\n        String driverVersion = dbmd.getDriverVersion();\n\n        // Check for a mapping in DbLoader.xml\n        localDataTypeName = config.getMappedDataTypeName(dbName, dbVersion, driverName, driverVersion, genericDataTypeName);\n\n        // Find the type code for this generic type name\n        int dataTypeCode = DbUtils.getJavaSqlType(genericDataTypeName);\n        \n        if (localDataTypeName != null)\n              return localDataTypeName;\n\n        if (config.getLocalTypeMap() == null) {\n\n            Map localTypeMap = new Hashtable();\n            config.setLocalTypeMap(localTypeMap);\n\n              try {\n                  \n                  ResultSet rs = dbmd.getTypeInfo();\n                  try {\n                      while (rs.next())\n                      {\n                          Integer dbTypeCode = new Integer(rs.getInt(\"DATA_TYPE\"));\n                          String dbTypeName = rs.getString(\"TYPE_NAME\");\n\n                          // Add only first occurence of each type code\n                          // See Bugzilla for a detailed explanation                              \n                          if (!localTypeMap.containsKey(dbTypeCode)) {                            \n                              localTypeMap.put(dbTypeCode, dbTypeName);\n                          }                          \n                      }\n                  }\n                  finally {\n                      rs.close();\n                  }\n              }\n              catch (Exception e)\n              {\n                  config.getLog().println(\"Problem loading Database Meta Data. \"\n                  + e.getMessage());\n                e.printStackTrace(config.getLog());\n                DbLoader.exit(config);\n              }\n          }\n\n        Integer dataTypeCodeObj = new Integer(dataTypeCode);\n        localDataTypeName = (String)config.getLocalTypeMap().get(dataTypeCodeObj);\n\n        if (localDataTypeName != null)\n          {\n            return localDataTypeName;\n          }\n\n        // No matching type found, report an error\n        config.getLog().println(\n            \"Your database driver, '\"\n                + driverName\n                + \"', version '\"\n                + driverVersion\n                + \"', was unable to find a local type name that matches the generic type name, '\"\n                + genericDataTypeName\n                + \"'.\");\n        config.getLog().println(\n            \"Please add a mapped type for database '\"\n                + dbName\n                + \"', version '\"\n                + dbVersion\n                + \"' inside '\"\n                + config.getPropertiesURL()\n                + \"' and run this program again.\");\n        config.getLog().println(\"Exiting...\");\n        DbLoader.exit(config);\n      }\n      catch (Exception e)\n      {\n        e.printStackTrace(config.getLog());\n        DbLoader.exit(config);\n      }\n\n      return null;\n    }","id":104313,"modified_method":"static String getLocalDataTypeName (Configuration config,\n      String genericDataTypeName)\n    {\n\n      DatabaseMetaData dbmd;\n      String dbName, dbVersion, driverName, driverVersion;\n      String localDataTypeName = null;\n\n      try\n      {\n        dbmd = config.getConnection().getMetaData();\n        dbName = dbmd.getDatabaseProductName();\n        dbVersion = dbmd.getDatabaseProductVersion();\n        driverName = dbmd.getDriverName();\n        driverVersion = dbmd.getDriverVersion();\n\n        // Check for a mapping in DbLoader.xml\n        localDataTypeName = config.getMappedDataTypeName(dbName, dbVersion, driverName, driverVersion, genericDataTypeName);\n      }\n      catch (SQLException e) {\n          throw new RuntimeException(\"Failed to retrieve database information from the configured DataSource. Is the database running and is rdbm.properties correct?\");\n      }\n      \n      try {\n\n        // Find the type code for this generic type name\n        int dataTypeCode = DbUtils.getJavaSqlType(genericDataTypeName);\n        \n        if (localDataTypeName != null)\n              return localDataTypeName;\n\n        if (config.getLocalTypeMap() == null) {\n\n            Map localTypeMap = new Hashtable();\n            config.setLocalTypeMap(localTypeMap);\n\n              try {\n                  \n                  ResultSet rs = dbmd.getTypeInfo();\n                  try {\n                      while (rs.next())\n                      {\n                          Integer dbTypeCode = new Integer(rs.getInt(\"DATA_TYPE\"));\n                          String dbTypeName = rs.getString(\"TYPE_NAME\");\n\n                          // Add only first occurence of each type code\n                          // See Bugzilla for a detailed explanation                              \n                          if (!localTypeMap.containsKey(dbTypeCode)) {                            \n                              localTypeMap.put(dbTypeCode, dbTypeName);\n                          }                          \n                      }\n                  }\n                  finally {\n                      rs.close();\n                  }\n              }\n              catch (Exception e)\n              {\n                  config.getLog().println(\"Problem loading Database Meta Data. \"\n                  + e.getMessage());\n                e.printStackTrace(config.getLog());\n                DbLoader.exit(config);\n              }\n          }\n\n        Integer dataTypeCodeObj = new Integer(dataTypeCode);\n        localDataTypeName = (String)config.getLocalTypeMap().get(dataTypeCodeObj);\n\n        if (localDataTypeName != null)\n          {\n            return localDataTypeName;\n          }\n\n        // No matching type found, report an error\n        config.getLog().println(\n            \"Your database driver, '\"\n                + driverName\n                + \"', version '\"\n                + driverVersion\n                + \"', was unable to find a local type name that matches the generic type name, '\"\n                + genericDataTypeName\n                + \"'.\");\n        config.getLog().println(\n            \"Please add a mapped type for database '\"\n                + dbName\n                + \"', version '\"\n                + dbVersion\n                + \"' inside '\"\n                + config.getPropertiesURL()\n                + \"' and run this program again.\");\n        config.getLog().println(\"Exiting...\");\n        DbLoader.exit(config);\n      }\n      catch (Exception e)\n      {\n        e.printStackTrace(config.getLog());\n        DbLoader.exit(config);\n      }\n\n      return null;\n    }","commit_id":"0a9ee190828650a51cef2a21629372c93c5a9835","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public <S extends T> ModelCreator creator(MutableModelNode parentNode, ModelRuleDescriptor sourceDescriptor, ModelType<S> type, final String name) {\n        ModelPath childPath = parentNode.getPath().child(name);\n        return ManagedModelCreators.creator(sourceDescriptor, childPath, modelSchemaStore.getSchema(type));\n    }","id":104314,"modified_method":"@Override\n    public <S extends T> ModelCreator creator(MutableModelNode parentNode, ModelRuleDescriptor sourceDescriptor, ModelType<S> type, final String name) {\n        ModelPath childPath = parentNode.getPath().child(name);\n        final ModelSchema<S> schema = modelSchemaStore.getSchema(type);\n        return ModelCreators.of(childPath, schema.getNodeInitializer()).descriptor(sourceDescriptor).build();\n    }","commit_id":"1053ede3ebd65344bfa061f54c5ed736f523c9e3","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> ModelCreator buildModelCreatorForManagedType(ModelType<T> managedType, final MethodRuleDefinition<?, ?> ruleDefinition, ModelPath modelPath) {\n        ModelSchema<T> modelSchema = getModelSchema(managedType, ruleDefinition);\n\n        if (modelSchema.getKind().equals(ModelSchema.Kind.VALUE)) {\n            throw new InvalidModelRuleDeclarationException(ruleDefinition.getDescriptor(), \"a void returning model element creation rule cannot take a value type as the first parameter, which is the element being created. Return the value from the method.\");\n        }\n\n        if (!modelSchema.getKind().isManaged()) {\n            String description = String.format(\"a void returning model element creation rule has to take an instance of a managed type as the first argument\");\n            throw new InvalidModelRuleDeclarationException(ruleDefinition.getDescriptor(), description);\n        }\n\n        List<ModelReference<?>> bindings = ruleDefinition.getReferences();\n        List<ModelReference<?>> inputs = bindings.subList(1, bindings.size());\n        ModelRuleDescriptor descriptor = ruleDefinition.getDescriptor();\n\n        return ManagedModelCreators.creator(descriptor, modelPath, modelSchema, inputs, new RuleMethodBackedMutationAction<T>(ruleDefinition.getRuleInvoker()));\n    }","id":104315,"modified_method":"private <T> ModelCreator buildModelCreatorForManagedType(ModelType<T> managedType, final MethodRuleDefinition<?, ?> ruleDefinition, ModelPath modelPath) {\n        ModelSchema<T> modelSchema = getModelSchema(managedType, ruleDefinition);\n\n        if (modelSchema.getKind().equals(ModelSchema.Kind.VALUE)) {\n            throw new InvalidModelRuleDeclarationException(ruleDefinition.getDescriptor(), \"a void returning model element creation rule cannot take a value type as the first parameter, which is the element being created. Return the value from the method.\");\n        }\n\n        if (!modelSchema.getKind().isManaged()) {\n            String description = \"a void returning model element creation rule has to take an instance of a managed type as the first argument\";\n            throw new InvalidModelRuleDeclarationException(ruleDefinition.getDescriptor(), description);\n        }\n\n        List<ModelReference<?>> bindings = ruleDefinition.getReferences();\n        List<ModelReference<?>> inputs = bindings.subList(1, bindings.size());\n        ModelRuleDescriptor descriptor = ruleDefinition.getDescriptor();\n\n        final ModelReference<T> reference = ModelReference.of(modelPath, managedType);\n        return ModelCreators.of(modelPath, modelSchema.getNodeInitializer())\n            .descriptor(descriptor)\n            .action(ModelActionRole.Initialize, InputUsingModelAction.of(\n                    reference, descriptor, inputs, new RuleMethodBackedMutationAction<T>(ruleDefinition.getRuleInvoker())\n                )\n            )\n            .build();\n    }","commit_id":"1053ede3ebd65344bfa061f54c5ed736f523c9e3","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void execute(MutableModelNode modelNode, List<ModelView<?>> inputs) {\n        for (ModelProperty<?> property : modelSchema.getProperties().values()) {\n            addPropertyLink(modelNode, property);\n        }\n    }","id":104316,"modified_method":"@Override\n    public void execute(MutableModelNode modelNode, List<ModelView<?>> inputs) {\n        for (ModelProperty<?> property : modelSchema.getProperties().values()) {\n            addPropertyLink(modelNode, property);\n        }\n        if (Named.class.isAssignableFrom(modelSchema.getType().getRawClass())) {\n            // Only initialize \"name\" child node if the schema has such a node. This is not the case\n            // for a managed subtype of an unmanaged type that implements Named.\n            if (modelSchema.getProperties().containsKey(\"name\")) {\n                MutableModelNode nameLink = modelNode.getLink(\"name\");\n                if (nameLink == null) {\n                    throw new IllegalStateException(\"expected name node for \" + modelNode.getPath());\n                }\n                nameLink.setPrivateData(ModelType.of(String.class), modelNode.getPath().getName());\n            }\n        }\n    }","commit_id":"1053ede3ebd65344bfa061f54c5ed736f523c9e3","url":"https://github.com/gradle/gradle"},{"original_method":"private <P> void addPropertyLink(MutableModelNode modelNode, ModelProperty<P> property) {\n        ModelType<P> propertyType = property.getType();\n        ModelSchema<P> propertySchema = schemaStore.getSchema(propertyType);\n\n        final ModelRuleDescriptor descriptor = modelNode.getDescriptor();\n        if (propertySchema.getKind().isManaged()) {\n            if (!property.isWritable()) {\n                ModelCreator creator = ManagedModelCreators.creator(descriptor, modelNode.getPath().child(property.getName()), propertySchema);\n                modelNode.addLink(creator);\n            } else {\n                ModelStructSchema<P> structSchema = (ModelStructSchema<P>) propertySchema;\n                ModelProjection projection = new ManagedModelProjection<P>(structSchema, schemaStore, PROXY_FACTORY);\n                ModelCreator creator = ModelCreators.of(modelNode.getPath().child(property.getName()), BiActions.doNothing())\n                    .withProjection(projection)\n                    .descriptor(descriptor).build();\n                modelNode.addReference(creator);\n            }\n        } else {\n            ModelProjection projection = new UnmanagedModelProjection<P>(propertyType, true, true);\n            ModelCreator creator = ModelCreators.of(modelNode.getPath().child(property.getName()), BiActions.doNothing())\n                .withProjection(projection)\n                .descriptor(descriptor).build();\n            modelNode.addLink(creator);\n        }\n    }","id":104317,"modified_method":"private <P> void addPropertyLink(MutableModelNode modelNode, ModelProperty<P> property) {\n        ModelType<P> propertyType = property.getType();\n        ModelSchema<P> propertySchema = schemaStore.getSchema(propertyType);\n\n        final ModelRuleDescriptor descriptor = modelNode.getDescriptor();\n        if (propertySchema.getKind().isManaged()) {\n            if (!property.isWritable()) {\n                ModelCreator creator = ModelCreators.of(modelNode.getPath().child(property.getName()), propertySchema.getNodeInitializer())\n                    .descriptor(descriptor)\n                    .build();\n                modelNode.addLink(creator);\n            } else {\n                ModelStructSchema<P> structSchema = (ModelStructSchema<P>) propertySchema;\n                ModelProjection projection = new ManagedModelProjection<P>(structSchema, schemaStore, PROXY_FACTORY);\n                ModelCreator creator = ModelCreators.of(modelNode.getPath().child(property.getName()), BiActions.doNothing())\n                    .withProjection(projection)\n                    .descriptor(descriptor).build();\n                modelNode.addReference(creator);\n            }\n        } else {\n            ModelProjection projection = new UnmanagedModelProjection<P>(propertyType, true, true);\n            ModelCreator creator = ModelCreators.of(modelNode.getPath().child(property.getName()), BiActions.doNothing())\n                .withProjection(projection)\n                .descriptor(descriptor).build();\n            modelNode.addLink(creator);\n        }\n    }","commit_id":"1053ede3ebd65344bfa061f54c5ed736f523c9e3","url":"https://github.com/gradle/gradle"},{"original_method":"public static <T> ChildNodeCreatorStrategy<T> createManagedOrUsingFactory(final ModelSchemaStore schemaStore, final ModelReference<? extends InstanceFactory<? super T, String>> factoryReference) {\n        return new ChildNodeCreatorStrategy<T>() {\n            @Override\n            public <S extends T> ModelCreator creator(final MutableModelNode parentNode, ModelRuleDescriptor sourceDescriptor, final ModelType<S> type, final String name) {\n                ModelPath path = parentNode.getPath().child(name);\n                ModelSchema<S> schema = schemaStore.getSchema(type);\n                if (schema.getKind().isManaged()) {\n                    return ManagedModelCreators.creator(sourceDescriptor, path, schema);\n                } else {\n                    return creatorUsingFactory(sourceDescriptor, path, type, name, factoryReference);\n                }\n            }\n        };\n    }","id":104318,"modified_method":"public static <T> ChildNodeCreatorStrategy<T> createManagedOrUsingFactory(final ModelSchemaStore schemaStore, final ModelReference<? extends InstanceFactory<? super T, String>> factoryReference) {\n        return new ChildNodeCreatorStrategy<T>() {\n            @Override\n            public <S extends T> ModelCreator creator(final MutableModelNode parentNode, ModelRuleDescriptor sourceDescriptor, final ModelType<S> type, final String name) {\n                ModelPath path = parentNode.getPath().child(name);\n                ModelSchema<S> schema = schemaStore.getSchema(type);\n                if (schema.getKind().isManaged()) {\n                    return ModelCreators.of(path, schema.getNodeInitializer()).descriptor(sourceDescriptor).build();\n                } else {\n                    return creatorUsingFactory(sourceDescriptor, path, type, name, factoryReference);\n                }\n            }\n        };\n    }","commit_id":"1053ede3ebd65344bfa061f54c5ed736f523c9e3","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> void registerCreator(Class<T> type, Closure<?> closure) {\n        ModelRuleDescriptor descriptor = new SimpleModelRuleDescriptor(\"model.\" + modelPath);\n        ModelSchema<T> schema = modelSchemaStore.getSchema(ModelType.of(type));\n        if (!schema.getKind().isManaged()) {\n            throw new InvalidModelRuleDeclarationException(descriptor, \"Cannot create an element of type \" + type.getName() + \" as it is not a managed type\");\n        }\n\n        modelRegistry.create(ManagedModelCreators.creator(descriptor, modelPath, schema, new ClosureBackedAction<T>(closure)));\n    }","id":104319,"modified_method":"private <T> void registerCreator(Class<T> type, Closure<?> closure) {\n        ModelRuleDescriptor descriptor = new SimpleModelRuleDescriptor(\"model.\" + modelPath);\n        ModelSchema<T> schema = modelSchemaStore.getSchema(ModelType.of(type));\n        if (!schema.getKind().isManaged()) {\n            throw new InvalidModelRuleDeclarationException(descriptor, \"Cannot create an element of type \" + type.getName() + \" as it is not a managed type\");\n        }\n\n        modelRegistry.create(\n            ModelCreators.of(modelPath, schema.getNodeInitializer())\n                .descriptor(descriptor)\n                .action(ModelActionRole.Initialize, NoInputsModelAction.of(ModelReference.of(modelPath, type), descriptor, new ClosureBackedAction<T>(closure)))\n                .build()\n        );\n    }","commit_id":"1053ede3ebd65344bfa061f54c5ed736f523c9e3","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Subscribe - Add the recd. URL and related info to the category->Urls map\n     * so the sendData() can send out to appropriate Urls for each category.\n     * Also send the latest info for the category\n     */\n    public synchronized void subscribe(String url, String catlabel, String user, String passwd) {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        // send category data to the newly subscribed URL\n        // look up info for this category\n        RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n        if (cat == null) {\n            // oops! category for which we have no info!\n            log.warn(\"RTC: No information available for category: \" + catlabel);\n            return;\n        }\n\n        // create new HttpPostInfo\n        HttpPostInfo postInfo = null;\n        try {\n            postInfo = new HttpPostInfo(url, catlabel, user, passwd);\n        } catch (MalformedURLException mue) {\n            log.warn(\"ERROR subscribing: Invalid URL \\'\" + url + \"\\' - Data WILL NOT be SENT to the specified url\");\n            return;\n        }\n\n        // Add the URL to the list for the specified category\n        List<HttpPostInfo> urlList = m_catUrlMap.get(catlabel);\n        if (urlList == null) {\n            // create one\n            urlList = new ArrayList<HttpPostInfo>();\n            urlList.add(postInfo);\n            m_catUrlMap.put(catlabel, urlList);\n        } else {\n            // add to list\n            if (!urlList.contains(postInfo))\n                urlList.add(postInfo);\n            else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Already subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user + \" - IGNORING LATEST subscribe event\");\n                }\n\n                return;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user);\n        }\n\n        // send data\n        try {\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = m_euiMapper.convertToEuiLevelXML(cat);\n\n            Reader inr = new PipedMarshaller(euidata).getReader();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posting data to: \" + url);\n\n            InputStream inp = HttpUtils.post(postInfo.getURL(), inr, user, passwd, 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n            byte[] tmp = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inp.read(tmp)) != -1) {\n                if (log.isDebugEnabled()) {\n                    if (bytesRead > 0)\n                        log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                }\n            }\n\n            inp.close();\n            inr.close();\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posted data for category: \" + catlabel);\n        } catch (IOException ioE) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", ioE);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (java.lang.OutOfMemoryError oe) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", oe);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (RuntimeException e) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", e);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (Throwable t) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", t);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        }\n    }","id":104320,"modified_method":"/**\n     * Subscribe - Add the recd. URL and related info to the category->Urls map\n     * so the sendData() can send out to appropriate Urls for each category.\n     * Also send the latest info for the category\n     */\n    public synchronized void subscribe(String url, String catlabel, String user, String passwd) {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        // send category data to the newly subscribed URL\n        // look up info for this category\n        RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n        if (cat == null) {\n            // oops! category for which we have no info!\n            log.warn(\"RTC: No information available for category: \" + catlabel);\n            return;\n        }\n\n        // create new HttpPostInfo\n        HttpPostInfo postInfo = null;\n        try {\n            postInfo = new HttpPostInfo(url, catlabel, user, passwd);\n        } catch (MalformedURLException mue) {\n            log.warn(\"ERROR subscribing: Invalid URL \\'\" + url + \"\\' - Data WILL NOT be SENT to the specified url\");\n            return;\n        }\n\n        // Add the URL to the list for the specified category\n        List<HttpPostInfo> urlList = m_catUrlMap.get(catlabel);\n        if (urlList == null) {\n            // create one\n            urlList = new ArrayList<HttpPostInfo>();\n            urlList.add(postInfo);\n            m_catUrlMap.put(catlabel, urlList);\n        } else {\n            // add to list\n            if (!urlList.contains(postInfo))\n                urlList.add(postInfo);\n            else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Already subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user + \" - IGNORING LATEST subscribe event\");\n                }\n\n                return;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user);\n        }\n\n        // send data\n        Reader inr = null;\n        InputStream inp = null;\n        try {\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = m_euiMapper.convertToEuiLevelXML(cat);\n\n            inr = new PipedMarshaller(euidata).getReader();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posting data to: \" + url);\n\n            inp = HttpUtils.post(postInfo.getURL(), inr, user, passwd, 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n            byte[] tmp = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inp.read(tmp)) != -1) {\n                if (log.isDebugEnabled()) {\n                    if (bytesRead > 0)\n                        log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posted data for category: \" + catlabel);\n        } catch (IOException ioE) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", ioE);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (java.lang.OutOfMemoryError oe) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", oe);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (RuntimeException e) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", e);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (Throwable t) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", t);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } finally {\n            IOUtils.closeQuietly(inp);\n            IOUtils.closeQuietly(inr);\n        }\n    }","commit_id":"a6176830d9132df807a21dceb0f968993812430b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Subscribe - Add the recd. URL and related info to the category->Urls map\n     * so the sendData() can send out to appropriate Urls for each category.\n     * Also send the latest info for the category\n     */\n    public synchronized void subscribe(String url, String catlabel, String user, String passwd) {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        // send category data to the newly subscribed URL\n        // look up info for this category\n        RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n        if (cat == null) {\n            // oops! category for which we have no info!\n            log.warn(\"RTC: No information available for category: \" + catlabel);\n            return;\n        }\n\n        // create new HttpPostInfo\n        HttpPostInfo postInfo = null;\n        try {\n            postInfo = new HttpPostInfo(url, catlabel, user, passwd);\n        } catch (MalformedURLException mue) {\n            log.warn(\"ERROR subscribing: Invalid URL \\'\" + url + \"\\' - Data WILL NOT be SENT to the specified url\");\n            return;\n        }\n\n        // Add the URL to the list for the specified category\n        List<HttpPostInfo> urlList = m_catUrlMap.get(catlabel);\n        if (urlList == null) {\n            // create one\n            urlList = new ArrayList<HttpPostInfo>();\n            urlList.add(postInfo);\n            m_catUrlMap.put(catlabel, urlList);\n        } else {\n            // add to list\n            if (!urlList.contains(postInfo))\n                urlList.add(postInfo);\n            else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Already subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user + \" - IGNORING LATEST subscribe event\");\n                }\n\n                return;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user);\n        }\n\n        // send data\n        try {\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = m_euiMapper.convertToEuiLevelXML(cat);\n\n            Reader inr = new PipedMarshaller(euidata).getReader();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posting data to: \" + url);\n\n            InputStream inp = HttpUtils.post(postInfo.getURL(), inr, user, passwd, 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n            byte[] tmp = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inp.read(tmp)) != -1) {\n                if (log.isDebugEnabled()) {\n                    if (bytesRead > 0)\n                        log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                }\n            }\n\n            inp.close();\n            inr.close();\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posted data for category: \" + catlabel);\n        } catch (IOException ioE) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", ioE);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (java.lang.OutOfMemoryError oe) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", oe);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (RuntimeException e) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", e);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (Throwable t) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", t);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        }\n    }","id":104321,"modified_method":"/**\n     * Subscribe - Add the recd. URL and related info to the category->Urls map\n     * so the sendData() can send out to appropriate Urls for each category.\n     * Also send the latest info for the category\n     */\n    public synchronized void subscribe(String url, String catlabel, String user, String passwd) {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        // send category data to the newly subscribed URL\n        // look up info for this category\n        RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n        if (cat == null) {\n            // oops! category for which we have no info!\n            log.warn(\"RTC: No information available for category: \" + catlabel);\n            return;\n        }\n\n        // create new HttpPostInfo\n        HttpPostInfo postInfo = null;\n        try {\n            postInfo = new HttpPostInfo(url, catlabel, user, passwd);\n        } catch (MalformedURLException mue) {\n            log.warn(\"ERROR subscribing: Invalid URL \\'\" + url + \"\\' - Data WILL NOT be SENT to the specified url\");\n            return;\n        }\n\n        // Add the URL to the list for the specified category\n        List<HttpPostInfo> urlList = m_catUrlMap.get(catlabel);\n        if (urlList == null) {\n            // create one\n            urlList = new ArrayList<HttpPostInfo>();\n            urlList.add(postInfo);\n            m_catUrlMap.put(catlabel, urlList);\n        } else {\n            // add to list\n            if (!urlList.contains(postInfo))\n                urlList.add(postInfo);\n            else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Already subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user + \" - IGNORING LATEST subscribe event\");\n                }\n\n                return;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user);\n        }\n\n        // send data\n        Reader inr = null;\n        InputStream inp = null;\n        try {\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = m_euiMapper.convertToEuiLevelXML(cat);\n\n            inr = new PipedMarshaller(euidata).getReader();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posting data to: \" + url);\n\n            inp = HttpUtils.post(postInfo.getURL(), inr, user, passwd, 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n            byte[] tmp = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inp.read(tmp)) != -1) {\n                if (log.isDebugEnabled()) {\n                    if (bytesRead > 0)\n                        log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posted data for category: \" + catlabel);\n        } catch (IOException ioE) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", ioE);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (java.lang.OutOfMemoryError oe) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", oe);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (RuntimeException e) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", e);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (Throwable t) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", t);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } finally {\n            IOUtils.closeQuietly(inp);\n            IOUtils.closeQuietly(inr);\n        }\n    }","commit_id":"d77c5ac51009c0d5257b5ece31753aa74b0a682b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Loop through the categories and send out data for all categories that\n     * have changed\n     */\n    public synchronized void sendData() {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        log.debug(\"In DataSender sendData()\");\n\n        // loop through and send info\n        Iterator catsIter = m_categories.values().iterator();\n        while (catsIter.hasNext()) {\n            RTCCategory cat = (RTCCategory) catsIter.next();\n\n            // get label\n            String catlabel = cat.getLabel();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender:sendData(): Category \\'\" + catlabel);\n\n            // get the post info for this category\n            List urlList = (List) m_catUrlMap.get(catlabel);\n            if (urlList == null || urlList.size() <= 0) {\n                // a category that no one is listening for?\n                if (log.isDebugEnabled())\n                    log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has no listeners\");\n\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has listeners - converting to xml...\");\n\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = null;\n            try {\n                euidata = m_euiMapper.convertToEuiLevelXML(cat);\n            } catch (java.lang.OutOfMemoryError oe) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, oe);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                continue;\n            } catch (Throwable t) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, t);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n            }\n\n            // do a HTTP POST if subscribed\n            if (urlList != null && urlList.size() > 0) {\n                Iterator urlIter = urlList.listIterator();\n                while (urlIter.hasNext()) {\n                    HttpPostInfo postInfo = (HttpPostInfo) urlIter.next();\n\n                    try {\n                        Reader inr = new PipedMarshaller(euidata).getReader();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posting data to: \" + postInfo.getURLString());\n\n                        InputStream inp = HttpUtils.post(postInfo.getURL(), inr, postInfo.getUser(), postInfo.getPassword(), 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posted data for category: \" + catlabel);\n\n                        byte[] tmp = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = inp.read(tmp)) != -1) {\n                            if (log.isDebugEnabled()) {\n                                if (bytesRead > 0)\n                                    log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                            }\n                        }\n\n                        inp.close();\n                        inr.close();\n\n                        postInfo.clearErrors();\n\n                    } catch (IOException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        postInfo.incrementErrors();\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (java.lang.OutOfMemoryError e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (RuntimeException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (Throwable t) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + t.getClass().getName() + \": \" + t.getMessage(), t);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    }\n\n                    // check to see if URL had too many errors\n                    if (POST_ERROR_LIMIT > 0 && postInfo.getErrors() >= POST_ERROR_LIMIT) {\n                        // unsubscribe the URL\n                        urlIter.remove();\n\n                        log.warn(\"URL \" + postInfo.getURLString() + \" UNSUBSCRIBED due to reaching error limit \" + postInfo.getErrors());\n                    }\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n        }\n    }","id":104322,"modified_method":"/**\n     * Loop through the categories and send out data for all categories that\n     * have changed\n     */\n    public synchronized void sendData() {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        log.debug(\"In DataSender sendData()\");\n\n        // loop through and send info\n        Iterator catsIter = m_categories.values().iterator();\n        while (catsIter.hasNext()) {\n            RTCCategory cat = (RTCCategory) catsIter.next();\n\n            // get label\n            String catlabel = cat.getLabel();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender:sendData(): Category \\'\" + catlabel);\n\n            // get the post info for this category\n            List urlList = (List) m_catUrlMap.get(catlabel);\n            if (urlList == null || urlList.size() <= 0) {\n                // a category that no one is listening for?\n                if (log.isDebugEnabled())\n                    log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has no listeners\");\n\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has listeners - converting to xml...\");\n\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = null;\n            try {\n                euidata = m_euiMapper.convertToEuiLevelXML(cat);\n            } catch (java.lang.OutOfMemoryError oe) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, oe);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                continue;\n            } catch (Throwable t) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, t);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n            }\n\n            // do a HTTP POST if subscribed\n            if (urlList != null && urlList.size() > 0) {\n                Iterator urlIter = urlList.listIterator();\n                while (urlIter.hasNext()) {\n                    HttpPostInfo postInfo = (HttpPostInfo) urlIter.next();\n\n                    Reader inr = null;\n                    InputStream inp = null;\n                    try {\n                        inr = new PipedMarshaller(euidata).getReader();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posting data to: \" + postInfo.getURLString());\n\n                        inp = HttpUtils.post(postInfo.getURL(), inr, postInfo.getUser(), postInfo.getPassword(), 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posted data for category: \" + catlabel);\n                        \n\n                        byte[] tmp = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = inp.read(tmp)) != -1) {\n                            if (log.isDebugEnabled()) {\n                                if (bytesRead > 0)\n                                    log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                            }\n                        }\n\n                        postInfo.clearErrors();\n\n                    } catch (IOException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        postInfo.incrementErrors();\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (java.lang.OutOfMemoryError e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (RuntimeException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (Throwable t) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + t.getClass().getName() + \": \" + t.getMessage(), t);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } finally {\n                        IOUtils.closeQuietly(inp);\n                        IOUtils.closeQuietly(inr);\n                    }\n\n                    // check to see if URL had too many errors\n                    if (POST_ERROR_LIMIT > 0 && postInfo.getErrors() >= POST_ERROR_LIMIT) {\n                        // unsubscribe the URL\n                        urlIter.remove();\n\n                        log.warn(\"URL \" + postInfo.getURLString() + \" UNSUBSCRIBED due to reaching error limit \" + postInfo.getErrors());\n                    }\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n        }\n    }","commit_id":"e609482d053ab5fedc3efe2604655a72a2d3531c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Subscribe - Add the recd. URL and related info to the category->Urls map\n     * so the sendData() can send out to appropriate Urls for each category.\n     * Also send the latest info for the category\n     */\n    public synchronized void subscribe(String url, String catlabel, String user, String passwd) {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        // send category data to the newly subscribed URL\n        // look up info for this category\n        RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n        if (cat == null) {\n            // oops! category for which we have no info!\n            log.warn(\"RTC: No information available for category: \" + catlabel);\n            return;\n        }\n\n        // create new HttpPostInfo\n        HttpPostInfo postInfo = null;\n        try {\n            postInfo = new HttpPostInfo(url, catlabel, user, passwd);\n        } catch (MalformedURLException mue) {\n            log.warn(\"ERROR subscribing: Invalid URL \\'\" + url + \"\\' - Data WILL NOT be SENT to the specified url\");\n            return;\n        }\n\n        // Add the URL to the list for the specified category\n        List<HttpPostInfo> urlList = m_catUrlMap.get(catlabel);\n        if (urlList == null) {\n            // create one\n            urlList = new ArrayList<HttpPostInfo>();\n            urlList.add(postInfo);\n            m_catUrlMap.put(catlabel, urlList);\n        } else {\n            // add to list\n            if (!urlList.contains(postInfo))\n                urlList.add(postInfo);\n            else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Already subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user + \" - IGNORING LATEST subscribe event\");\n                }\n\n                return;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user);\n        }\n\n        // send data\n        try {\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = m_euiMapper.convertToEuiLevelXML(cat);\n\n            Reader inr = new PipedMarshaller(euidata).getReader();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posting data to: \" + url);\n\n            InputStream inp = HttpUtils.post(postInfo.getURL(), inr, user, passwd, 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n            byte[] tmp = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inp.read(tmp)) != -1) {\n                if (log.isDebugEnabled()) {\n                    if (bytesRead > 0)\n                        log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                }\n            }\n\n            inp.close();\n            inr.close();\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posted data for category: \" + catlabel);\n        } catch (IOException ioE) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", ioE);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (java.lang.OutOfMemoryError oe) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", oe);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (RuntimeException e) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", e);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (Throwable t) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", t);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        }\n    }","id":104323,"modified_method":"/**\n     * Subscribe - Add the recd. URL and related info to the category->Urls map\n     * so the sendData() can send out to appropriate Urls for each category.\n     * Also send the latest info for the category\n     */\n    public synchronized void subscribe(String url, String catlabel, String user, String passwd) {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        // send category data to the newly subscribed URL\n        // look up info for this category\n        RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n        if (cat == null) {\n            // oops! category for which we have no info!\n            log.warn(\"RTC: No information available for category: \" + catlabel);\n            return;\n        }\n\n        // create new HttpPostInfo\n        HttpPostInfo postInfo = null;\n        try {\n            postInfo = new HttpPostInfo(url, catlabel, user, passwd);\n        } catch (MalformedURLException mue) {\n            log.warn(\"ERROR subscribing: Invalid URL \\'\" + url + \"\\' - Data WILL NOT be SENT to the specified url\");\n            return;\n        }\n\n        // Add the URL to the list for the specified category\n        List<HttpPostInfo> urlList = m_catUrlMap.get(catlabel);\n        if (urlList == null) {\n            // create one\n            urlList = new ArrayList<HttpPostInfo>();\n            urlList.add(postInfo);\n            m_catUrlMap.put(catlabel, urlList);\n        } else {\n            // add to list\n            if (!urlList.contains(postInfo))\n                urlList.add(postInfo);\n            else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Already subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user + \" - IGNORING LATEST subscribe event\");\n                }\n\n                return;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Subscribed to URL: \" + url + \"\\tcatlabel: \" + catlabel + \"\\tuser:\" + user);\n        }\n\n        // send data\n        Reader inr = null;\n        InputStream inp = null;\n        try {\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = m_euiMapper.convertToEuiLevelXML(cat);\n\n            inr = new PipedMarshaller(euidata).getReader();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posting data to: \" + url);\n\n            inp = HttpUtils.post(postInfo.getURL(), inr, user, passwd, 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n            byte[] tmp = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inp.read(tmp)) != -1) {\n                if (log.isDebugEnabled()) {\n                    if (bytesRead > 0)\n                        log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: posted data for category: \" + catlabel);\n        } catch (IOException ioE) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", ioE);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (java.lang.OutOfMemoryError oe) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", oe);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (RuntimeException e) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", e);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } catch (Throwable t) {\n            log.warn(\"DataSender:  Unable to send category \\'\" + catlabel + \"\\' to URL \\'\" + url + \"\\': \", t);\n            setCurrentThreadPriority(Thread.NORM_PRIORITY);\n        } finally {\n            IOUtils.closeQuietly(inp);\n            IOUtils.closeQuietly(inr);\n        }\n    }","commit_id":"875fbc34b1d0b118885710a47b87621952b2a196","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Loop through the categories and send out data for all categories that\n     * have changed\n     */\n    public synchronized void sendData() {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        log.debug(\"In DataSender sendData()\");\n\n        // loop through and send info\n        Iterator catsIter = m_categories.values().iterator();\n        while (catsIter.hasNext()) {\n            RTCCategory cat = (RTCCategory) catsIter.next();\n\n            // get label\n            String catlabel = cat.getLabel();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender:sendData(): Category \\'\" + catlabel);\n\n            // get the post info for this category\n            List urlList = (List) m_catUrlMap.get(catlabel);\n            if (urlList == null || urlList.size() <= 0) {\n                // a category that no one is listening for?\n                if (log.isDebugEnabled())\n                    log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has no listeners\");\n\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has listeners - converting to xml...\");\n\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = null;\n            try {\n                euidata = m_euiMapper.convertToEuiLevelXML(cat);\n            } catch (java.lang.OutOfMemoryError oe) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, oe);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                continue;\n            } catch (Throwable t) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, t);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n            }\n\n            // do a HTTP POST if subscribed\n            if (urlList != null && urlList.size() > 0) {\n                Iterator urlIter = urlList.listIterator();\n                while (urlIter.hasNext()) {\n                    HttpPostInfo postInfo = (HttpPostInfo) urlIter.next();\n\n                    try {\n                        Reader inr = new PipedMarshaller(euidata).getReader();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posting data to: \" + postInfo.getURLString());\n\n                        InputStream inp = HttpUtils.post(postInfo.getURL(), inr, postInfo.getUser(), postInfo.getPassword(), 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posted data for category: \" + catlabel);\n\n                        byte[] tmp = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = inp.read(tmp)) != -1) {\n                            if (log.isDebugEnabled()) {\n                                if (bytesRead > 0)\n                                    log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                            }\n                        }\n\n                        inp.close();\n                        inr.close();\n\n                        postInfo.clearErrors();\n\n                    } catch (IOException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        postInfo.incrementErrors();\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (java.lang.OutOfMemoryError e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (RuntimeException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (Throwable t) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + t.getClass().getName() + \": \" + t.getMessage(), t);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    }\n\n                    // check to see if URL had too many errors\n                    if (POST_ERROR_LIMIT > 0 && postInfo.getErrors() >= POST_ERROR_LIMIT) {\n                        // unsubscribe the URL\n                        urlIter.remove();\n\n                        log.warn(\"URL \" + postInfo.getURLString() + \" UNSUBSCRIBED due to reaching error limit \" + postInfo.getErrors());\n                    }\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n        }\n    }","id":104324,"modified_method":"/**\n     * Loop through the categories and send out data for all categories that\n     * have changed\n     */\n    public synchronized void sendData() {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        log.debug(\"In DataSender sendData()\");\n\n        // loop through and send info\n        Iterator catsIter = m_categories.values().iterator();\n        while (catsIter.hasNext()) {\n            RTCCategory cat = (RTCCategory) catsIter.next();\n\n            // get label\n            String catlabel = cat.getLabel();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender:sendData(): Category \\'\" + catlabel);\n\n            // get the post info for this category\n            List urlList = (List) m_catUrlMap.get(catlabel);\n            if (urlList == null || urlList.size() <= 0) {\n                // a category that no one is listening for?\n                if (log.isDebugEnabled())\n                    log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has no listeners\");\n\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has listeners - converting to xml...\");\n\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = null;\n            try {\n                euidata = m_euiMapper.convertToEuiLevelXML(cat);\n            } catch (java.lang.OutOfMemoryError oe) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, oe);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                continue;\n            } catch (Throwable t) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, t);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n            }\n\n            // do a HTTP POST if subscribed\n            if (urlList != null && urlList.size() > 0) {\n                Iterator urlIter = urlList.listIterator();\n                while (urlIter.hasNext()) {\n                    HttpPostInfo postInfo = (HttpPostInfo) urlIter.next();\n\n                    Reader inr = null;\n                    InputStream inp = null;\n                    try {\n                        inr = new PipedMarshaller(euidata).getReader();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posting data to: \" + postInfo.getURLString());\n\n                        inp = HttpUtils.post(postInfo.getURL(), inr, postInfo.getUser(), postInfo.getPassword(), 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posted data for category: \" + catlabel);\n                        \n\n                        byte[] tmp = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = inp.read(tmp)) != -1) {\n                            if (log.isDebugEnabled()) {\n                                if (bytesRead > 0)\n                                    log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                            }\n                        }\n\n                        postInfo.clearErrors();\n\n                    } catch (IOException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        postInfo.incrementErrors();\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (java.lang.OutOfMemoryError e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (RuntimeException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (Throwable t) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + t.getClass().getName() + \": \" + t.getMessage(), t);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } finally {\n                        IOUtils.closeQuietly(inp);\n                        IOUtils.closeQuietly(inr);\n                    }\n\n                    // check to see if URL had too many errors\n                    if (POST_ERROR_LIMIT > 0 && postInfo.getErrors() >= POST_ERROR_LIMIT) {\n                        // unsubscribe the URL\n                        urlIter.remove();\n\n                        log.warn(\"URL \" + postInfo.getURLString() + \" UNSUBSCRIBED due to reaching error limit \" + postInfo.getErrors());\n                    }\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n        }\n    }","commit_id":"7923cc024b305b03103392918d8e593d4b359231","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Loop through the categories and send out data for all categories that\n     * have changed\n     */\n    public synchronized void sendData() {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        log.debug(\"In DataSender sendData()\");\n\n        // loop through and send info\n        Iterator catsIter = m_categories.values().iterator();\n        while (catsIter.hasNext()) {\n            RTCCategory cat = (RTCCategory) catsIter.next();\n\n            // get label\n            String catlabel = cat.getLabel();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender:sendData(): Category \\'\" + catlabel);\n\n            // get the post info for this category\n            List urlList = (List) m_catUrlMap.get(catlabel);\n            if (urlList == null || urlList.size() <= 0) {\n                // a category that no one is listening for?\n                if (log.isDebugEnabled())\n                    log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has no listeners\");\n\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has listeners - converting to xml...\");\n\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = null;\n            try {\n                euidata = m_euiMapper.convertToEuiLevelXML(cat);\n            } catch (java.lang.OutOfMemoryError oe) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, oe);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                continue;\n            } catch (Throwable t) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, t);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n            }\n\n            // do a HTTP POST if subscribed\n            if (urlList != null && urlList.size() > 0) {\n                Iterator urlIter = urlList.listIterator();\n                while (urlIter.hasNext()) {\n                    HttpPostInfo postInfo = (HttpPostInfo) urlIter.next();\n\n                    try {\n                        Reader inr = new PipedMarshaller(euidata).getReader();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posting data to: \" + postInfo.getURLString());\n\n                        InputStream inp = HttpUtils.post(postInfo.getURL(), inr, postInfo.getUser(), postInfo.getPassword(), 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posted data for category: \" + catlabel);\n\n                        byte[] tmp = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = inp.read(tmp)) != -1) {\n                            if (log.isDebugEnabled()) {\n                                if (bytesRead > 0)\n                                    log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                            }\n                        }\n\n                        inp.close();\n                        inr.close();\n\n                        postInfo.clearErrors();\n\n                    } catch (IOException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        postInfo.incrementErrors();\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (java.lang.OutOfMemoryError e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (RuntimeException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (Throwable t) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + t.getClass().getName() + \": \" + t.getMessage(), t);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    }\n\n                    // check to see if URL had too many errors\n                    if (POST_ERROR_LIMIT > 0 && postInfo.getErrors() >= POST_ERROR_LIMIT) {\n                        // unsubscribe the URL\n                        urlIter.remove();\n\n                        log.warn(\"URL \" + postInfo.getURLString() + \" UNSUBSCRIBED due to reaching error limit \" + postInfo.getErrors());\n                    }\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n        }\n    }","id":104325,"modified_method":"/**\n     * Loop through the categories and send out data for all categories that\n     * have changed\n     */\n    public synchronized void sendData() {\n        Category log = ThreadCategory.getInstance(this.getClass());\n\n        log.debug(\"In DataSender sendData()\");\n\n        // loop through and send info\n        Iterator catsIter = m_categories.values().iterator();\n        while (catsIter.hasNext()) {\n            RTCCategory cat = (RTCCategory) catsIter.next();\n\n            // get label\n            String catlabel = cat.getLabel();\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender:sendData(): Category \\'\" + catlabel);\n\n            // get the post info for this category\n            List urlList = (List) m_catUrlMap.get(catlabel);\n            if (urlList == null || urlList.size() <= 0) {\n                // a category that no one is listening for?\n                if (log.isDebugEnabled())\n                    log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has no listeners\");\n\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"DataSender: category \\'\" + catlabel + \"\\' has listeners - converting to xml...\");\n\n            // Run at a higher than normal priority since we do have to send\n            // the update on time\n            int oldPriority = setCurrentThreadPriority(Thread.MAX_PRIORITY);\n\n            EuiLevel euidata = null;\n            try {\n                euidata = m_euiMapper.convertToEuiLevelXML(cat);\n            } catch (java.lang.OutOfMemoryError oe) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, oe);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                continue;\n            } catch (Throwable t) {\n                log.warn(\"DataSender: unable to convert data to xml for category: \" + catlabel, t);\n                setCurrentThreadPriority(Thread.NORM_PRIORITY);\n            }\n\n            // do a HTTP POST if subscribed\n            if (urlList != null && urlList.size() > 0) {\n                Iterator urlIter = urlList.listIterator();\n                while (urlIter.hasNext()) {\n                    HttpPostInfo postInfo = (HttpPostInfo) urlIter.next();\n\n                    Reader inr = null;\n                    InputStream inp = null;\n                    try {\n                        inr = new PipedMarshaller(euidata).getReader();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posting data to: \" + postInfo.getURLString());\n\n                        inp = HttpUtils.post(postInfo.getURL(), inr, postInfo.getUser(), postInfo.getPassword(), 8 * HttpUtils.DEFAULT_POST_BUFFER_SIZE);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"DataSender: posted data for category: \" + catlabel);\n                        \n\n                        byte[] tmp = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = inp.read(tmp)) != -1) {\n                            if (log.isDebugEnabled()) {\n                                if (bytesRead > 0)\n                                    log.debug(\"DataSender: post response: \" + new String(tmp, 0, bytesRead));\n                            }\n                        }\n\n                        postInfo.clearErrors();\n\n                    } catch (IOException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        postInfo.incrementErrors();\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (java.lang.OutOfMemoryError e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (RuntimeException e) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + e.getClass().getName() + \": \" + e.getMessage(), e);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } catch (Throwable t) {\n                        log.warn(\"DataSender: unable to send data for category: \" + catlabel + \" due to \" + t.getClass().getName() + \": \" + t.getMessage(), t);\n                        setCurrentThreadPriority(Thread.NORM_PRIORITY);\n                    } finally {\n                        IOUtils.closeQuietly(inp);\n                        IOUtils.closeQuietly(inr);\n                    }\n\n                    // check to see if URL had too many errors\n                    if (POST_ERROR_LIMIT > 0 && postInfo.getErrors() >= POST_ERROR_LIMIT) {\n                        // unsubscribe the URL\n                        urlIter.remove();\n\n                        log.warn(\"URL \" + postInfo.getURLString() + \" UNSUBSCRIBED due to reaching error limit \" + postInfo.getErrors());\n                    }\n                }\n            }\n\n            // return current thread to its previous priority\n            oldPriority = setCurrentThreadPriority(oldPriority);\n        }\n    }","commit_id":"6572ba5cf7c653df383b1345da8918d1a1b36066","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        // Cache the buffer to the specified Cache against the specified key\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n\n        if (isValid(cacheManager, cacheName, key)) {\n            cache = cacheManager.getCache(cacheName);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Replacing Token \" + replacementToken + \"in Message with value stored against key \"\n                         + key + \" in CacheName \" + cacheName);\n            }\n            exchange.getIn().setHeader(\"CACHE_KEY\", key);\n            Object body = exchange.getIn().getBody();\n            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, body);\n\n            byte[] buffer = IOConverter.toBytes(is);\n            is.close();\n\n            // Note: The value in the cache must be a String\n            String cacheValue = exchange.getContext().getTypeConverter().convertTo(\n                                                                                   String.class,\n                                                                                   cache.get(key)\n                                                                                       .getObjectValue());\n            String replacedTokenString = new String(buffer).replaceAll(replacementToken, cacheValue);\n            LOG.debug(\"replacedTokenString = \" + replacedTokenString);\n            exchange.getIn().setBody(replacedTokenString.getBytes());\n        }\n    }","id":104326,"modified_method":"public void process(Exchange exchange) throws Exception {\n        // Cache the buffer to the specified Cache against the specified key\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n\n        if (isValid(cacheManager, cacheName, key)) {\n            cache = cacheManager.getCache(cacheName);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Replacing Token \" + replacementToken + \"in Message with value stored against key \"\n                         + key + \" in CacheName \" + cacheName);\n            }\n            exchange.getIn().setHeader(\"CACHE_KEY\", key);\n            Object body = exchange.getIn().getBody();\n            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, body);\n\n            byte[] buffer = IOConverter.toBytes(is);\n            is.close();\n\n            // Note: The value in the cache must be a String\n            String cacheValue = exchange.getContext().getTypeConverter()\n                    .convertTo(String.class, cache.get(key).getObjectValue());\n            String replacedTokenString = new String(buffer).replaceAll(replacementToken, cacheValue);\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"replacedTokenString = \" + replacedTokenString);\n            }\n            exchange.getIn().setBody(replacedTokenString.getBytes());\n        }\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        // Cache the buffer to the specified Cache against the specified key\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n\n        if (isValid(cacheManager, cacheName, key)) {\n            cache = cacheManager.getCache(cacheName);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Replacing XPath value \" + xpath + \"in Message with value stored against key \" + key\n                        + \" in CacheName \" + cacheName);\n            }\n            exchange.getIn().setHeader(\"CACHE_KEY\", key);\n            Object body = exchange.getIn().getBody();\n            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, body);\n            try {\n                document = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, is);\n            } finally {\n                is.close();\n            }\n\n            InputStream cis = exchange.getContext().getTypeConverter()\n                .convertTo(InputStream.class, cache.get(key).getObjectValue());\n\n            try {\n                Document cacheValueDocument = exchange.getContext().getTypeConverter()\n                    .convertTo(Document.class, exchange, cis);\n\n                // Create/setup the Transformer\n                XmlConverter xmlConverter = new XmlConverter();\n                String xslString = IOConverter.toString(new File(\"./src/main/resources/xpathreplacer.xsl\"));\n                xslString = xslString.replace(\"##match_token##\", xpath);\n                Source xslSource = xmlConverter.toStreamSource(new StringReader(xslString));\n                TransformerFactory transformerFactory = xmlConverter.createTransformerFactory();\n                Transformer transformer = transformerFactory.newTransformer(xslSource);\n                source = xmlConverter.toSource(document);\n                result = new DOMResult();\n\n                transformer.setParameter(\"cacheValue\", cacheValueDocument);\n                transformer.transform(source, result);\n            } finally {\n                cis.close();\n            }\n        }\n\n        // DOMSource can be coverted to byte[] by camel type converter mechanism\n        DOMSource dom = new DOMSource(result.getNode());\n        exchange.getIn().setBody(dom, byte[].class);\n    }","id":104327,"modified_method":"public void process(Exchange exchange) throws Exception {\n        // Cache the buffer to the specified Cache against the specified key\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n\n        if (isValid(cacheManager, cacheName, key)) {\n            cache = cacheManager.getCache(cacheName);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Replacing XPath value \" + xpath + \"in Message with value stored against key \" + key\n                        + \" in CacheName \" + cacheName);\n            }\n            exchange.getIn().setHeader(\"CACHE_KEY\", key);\n            Object body = exchange.getIn().getBody();\n            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, body);\n            try {\n                document = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, is);\n            } finally {\n                is.close();\n            }\n\n            InputStream cis = exchange.getContext().getTypeConverter()\n                .convertTo(InputStream.class, cache.get(key).getObjectValue());\n\n            try {\n                Document cacheValueDocument = exchange.getContext().getTypeConverter()\n                    .convertTo(Document.class, exchange, cis);\n\n                // Create/setup the Transformer\n                XmlConverter xmlConverter = new XmlConverter();\n                String xslString = IOConverter.toString(new File(\"./src/main/resources/xpathreplacer.xsl\"), exchange);\n                xslString = xslString.replace(\"##match_token##\", xpath);\n                Source xslSource = xmlConverter.toStreamSource(new StringReader(xslString));\n                TransformerFactory transformerFactory = xmlConverter.createTransformerFactory();\n                Transformer transformer = transformerFactory.newTransformer(xslSource);\n                source = xmlConverter.toSource(document);\n                result = new DOMResult();\n\n                transformer.setParameter(\"cacheValue\", cacheValueDocument);\n                transformer.transform(source, result);\n            } finally {\n                cis.close();\n            }\n        }\n\n        // DOMSource can be converted to byte[] by camel type converter mechanism\n        DOMSource dom = new DOMSource(result.getNode());\n        exchange.getIn().setBody(dom, byte[].class);\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"public void parseURI(URI uri) throws Exception {\n        String protocol = uri.getScheme();\n        \n        if (!protocol.equalsIgnoreCase(\"cache\")) {\n            throw new IllegalArgumentException(\"Unrecognized Cache protocol: \" + protocol + \" for uri: \" + uri);\n        }\n        \n        setCacheName(uri.getHost());\n        \n        cacheSettings = URISupport.parseParameters(uri);\n        if (cacheSettings.containsKey(\"maxElementsInMemory\")) {\n            setMaxElementsInMemory(Integer.valueOf((String) cacheSettings.get(\"maxElementsInMemory\")).intValue());\n        }\n        if (cacheSettings.containsKey(\"overflowToDisk\")) {\n            setOverflowToDisk(Boolean.valueOf((String) cacheSettings.get(\"overflowToDisk\")));\n            if (cacheSettings.containsKey(\"diskStorePath\")) {\n                setDiskStorePath((String)cacheSettings.get(\"diskStorePath\"));\n            }\n        }\n        if (cacheSettings.containsKey(\"eternal\")) {\n            setEternal(Boolean.valueOf((String) cacheSettings.get(\"eternal\")));\n        }\n        if (cacheSettings.containsKey(\"timeToLiveSeconds\")) {\n            setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get(\"timeToLiveSeconds\")).longValue());\n        }\n        if (cacheSettings.containsKey(\"timeToIdleSeconds\")) {\n            setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get(\"timeToIdleSeconds\")).longValue());\n        }\n        if (cacheSettings.containsKey(\"diskPersistent\")) {\n            setEternal(Boolean.valueOf((String) cacheSettings.get(\"diskPersistent\")));\n        }\n        if (cacheSettings.containsKey(\"diskExpiryThreadIntervalSeconds\")) {\n            setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get(\"diskExpiryThreadIntervalSeconds\")).longValue());\n        }\n        \n    }","id":104328,"modified_method":"public void parseURI(URI uri) throws Exception {\n        String protocol = uri.getScheme();\n        \n        if (!protocol.equalsIgnoreCase(\"cache\")) {\n            throw new IllegalArgumentException(\"Unrecognized Cache protocol: \" + protocol + \" for uri: \" + uri);\n        }\n        \n        setCacheName(uri.getHost());\n        \n        Map cacheSettings = URISupport.parseParameters(uri);\n        if (cacheSettings.containsKey(\"maxElementsInMemory\")) {\n            setMaxElementsInMemory(Integer.valueOf((String) cacheSettings.get(\"maxElementsInMemory\")).intValue());\n        }\n        if (cacheSettings.containsKey(\"overflowToDisk\")) {\n            setOverflowToDisk(Boolean.valueOf((String) cacheSettings.get(\"overflowToDisk\")));\n            if (cacheSettings.containsKey(\"diskStorePath\")) {\n                setDiskStorePath((String)cacheSettings.get(\"diskStorePath\"));\n            }\n        }\n        if (cacheSettings.containsKey(\"eternal\")) {\n            setEternal(Boolean.valueOf((String) cacheSettings.get(\"eternal\")));\n        }\n        if (cacheSettings.containsKey(\"timeToLiveSeconds\")) {\n            setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get(\"timeToLiveSeconds\")).longValue());\n        }\n        if (cacheSettings.containsKey(\"timeToIdleSeconds\")) {\n            setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get(\"timeToIdleSeconds\")).longValue());\n        }\n        if (cacheSettings.containsKey(\"diskPersistent\")) {\n            setEternal(Boolean.valueOf((String) cacheSettings.get(\"diskPersistent\")));\n        }\n        if (cacheSettings.containsKey(\"diskExpiryThreadIntervalSeconds\")) {\n            setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get(\"diskExpiryThreadIntervalSeconds\")).longValue());\n        }\n        \n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStop() throws Exception {\n        // TODO Auto-generated method stub\n        super.doStop();\n        removeConsumerCacheConnection();\n    }","id":104329,"modified_method":"@Override\n    protected void doStop() throws Exception {\n        removeConsumerCacheConnection();\n        super.doStop();\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"private void removeConsumerCacheConnection() {\n        cacheManager.removeCache(config.getCacheName());\n        if (cacheManager.getCacheNames().length == 0) {\n            cacheManager.shutdown();\n        }\n    }","id":104330,"modified_method":"protected void removeConsumerCacheConnection() {\n        cacheManager.removeCache(config.getCacheName());\n        if (cacheManager.getCacheNames().length == 0) {\n            cacheManager.shutdown();\n        }\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"private void createConsumerCacheConnection() {\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n        CacheEventListener cacheEventListener = new CacheEventListenerFactory().createCacheEventListener(null);\n        cacheEventListener.setCacheConsumer(this);\n\n        if (cacheManager.cacheExists(config.getCacheName())) {\n            cache = cacheManager.getCache(config.getCacheName());\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n        } else {\n            cache = new Cache(config.getCacheName(), \n                    config.getMaxElementsInMemory(),\n                    config.getMemoryStoreEvictionPolicy(), \n                    config.isOverflowToDisk(), \n                    config.getDiskStorePath(), \n                    config.isEternal(), \n                    config.getTimeToLiveSeconds(), \n                    config.getTimeToIdleSeconds(), \n                    config.isDiskPersistent(), \n                    config.getDiskExpiryThreadIntervalSeconds(), \n                    null);\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n            cacheManager.addCache(cache);\n            LOG.debug(\"Added a new cache: \" + cache.getName());  \n        }\n    }","id":104331,"modified_method":"protected void createConsumerCacheConnection() {\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n        CacheEventListener cacheEventListener = new CacheEventListenerFactory().createCacheEventListener(null);\n        cacheEventListener.setCacheConsumer(this);\n\n        if (cacheManager.cacheExists(config.getCacheName())) {\n            cache = cacheManager.getCache(config.getCacheName());\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n        } else {\n            cache = new Cache(config.getCacheName(), \n                    config.getMaxElementsInMemory(),\n                    config.getMemoryStoreEvictionPolicy(), \n                    config.isOverflowToDisk(), \n                    config.getDiskStorePath(), \n                    config.isEternal(), \n                    config.getTimeToLiveSeconds(), \n                    config.getTimeToIdleSeconds(), \n                    config.isDiskPersistent(), \n                    config.getDiskExpiryThreadIntervalSeconds(), \n                    null);\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n            cacheManager.addCache(cache);\n\n            LOG.info(\"Added a new cache: \" + cache.getName());\n        }\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"private void dispatchExchange(Ehcache cache, Element element, String operation) {\n        Exchange exchange;\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Consumer Dispatching the Exchange containing the Element \" + element.toString() + \" in cache \" + cache.getName());\n        }\n        if (element == null) {\n            exchange = cacheConsumer.getEndpoint().createCacheExchange(operation, \"\", \"\");\n        } else {\n            exchange = cacheConsumer.getEndpoint().createCacheExchange(operation, (String) element.getObjectKey(), element.getObjectValue());\n        }\n        try {\n            cacheConsumer.getProcessor().process(exchange);\n        } catch (Exception e) {\n            throw new CacheException(\"Error in consumer while dispatching exchange containing Key \" + (String) element.getObjectKey() + \" for further processing  \", e);\n        }\n    }","id":104332,"modified_method":"private void dispatchExchange(Ehcache cache, Element element, String operation) {\n        Exchange exchange;\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Consumer Dispatching the Exchange containing the Element \" + element.toString() + \" in cache \" + cache.getName());\n        }\n        if (element == null) {\n            exchange = cacheConsumer.getEndpoint().createCacheExchange(operation, \"\", \"\");\n        } else {\n            exchange = cacheConsumer.getEndpoint().createCacheExchange(operation, (String) element.getObjectKey(), element.getObjectValue());\n        }\n        try {\n            cacheConsumer.getProcessor().process(exchange);\n        } catch (Exception e) {\n            throw new CacheException(\"Error in consumer while dispatching exchange containing Key \" + element.getObjectKey() + \" for further processing\", e);\n        }\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"public boolean isValid(CacheManager cacheManager, String cacheName, String key) {\n        LOG.debug(\"Cache Name: \" + cacheName);\n        if (!cacheManager.cacheExists(cacheName)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No existing Cache found with name: \"\n                      + cacheName\n                      + \". Please ensure a cache is first instantiated using a Cache Consumer or Cache Producer\");\n                LOG.debug(\"Replacement will not be performed since the cache \" + cacheName\n                     + \"does not presently exist\");\n            }\n            return false;\n        }\n\n        LOG.debug(\"Found an existing cache: \" + cacheName);\n        LOG.debug(\"Cache \" + cacheName + \" currently contains \" + cacheManager.getCache(cacheName).getSize()\n                 + \" elements\");\n        Ehcache cache = cacheManager.getCache(cacheName);\n        if (!cache.isKeyInCache(key)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No Key with name: \"\n                      + key\n                      + \"presently exists in the cache. It is also possible that the key may have expired in the cache\");\n                LOG.debug(\"Replacement will not be performed until an appropriate key/value pair is added to (or) found in the cache.\");\n            }\n            return false;\n\n        }\n\n        return true;\n    }","id":104333,"modified_method":"public boolean isValid(CacheManager cacheManager, String cacheName, String key) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Cache Name: \" + cacheName);\n        }\n\n        if (!cacheManager.cacheExists(cacheName)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No existing Cache found with name: \" + cacheName\n                        + \". Please ensure a cache is first instantiated using a Cache Consumer or Cache Producer.\"\n                        + \" Replacement will not be performed since the cache \" + cacheName + \"does not presently exist\");\n            }\n            return false;\n        }\n\n        LOG.debug(\"Found an existing cache: \" + cacheName);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Cache \" + cacheName + \" currently contains \" + cacheManager.getCache(cacheName).getSize() + \" elements\");\n        }\n        Ehcache cache = cacheManager.getCache(cacheName);\n\n        if (!cache.isKeyInCache(key)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No Key with name: \" + key\n                        + \"presently exists in the cache. It is also possible that the key may have expired in the cache.\"\n                        + \" Replacement will not be performed until an appropriate key/value pair is added to (or) found in the cache.\");\n            }\n            return false;\n        }\n\n        return true;\n    }","commit_id":"e4a8235b9ea913777664c18989a5d97fef6afc58","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public MachineDetails getMachineDetails() {\n        Optional<String> name = Optional.absent();\n        Optional<String> version = Optional.absent();\n        Optional<String> architecture = Optional.absent();\n\n        OperatingSystem os = node.getOperatingSystem();\n        if (os == null && getTemplate() != null && getTemplate().getImage() != null)\n            // some nodes (eg cloudstack, gce) might not get OS available on the node,\n            // so also try taking it from the template if available\n            os = getTemplate().getImage().getOperatingSystem();\n\n        if (os != null) {\n            // Note using family rather than name. Name is often unset.\n            name = Optional.fromNullable(os.getFamily() != null && !OsFamily.UNRECOGNIZED.equals(os.getFamily()) ? os.getFamily().toString() : null);\n            version = Optional.fromNullable(!Strings.isBlank(os.getVersion()) ? os.getVersion() : null);\n            // Using is64Bit rather then getArch because getArch often returns \"paravirtual\"\n            architecture = Optional.fromNullable(os.is64Bit() ? BasicOsDetails.OsArchs.X_86_64 : BasicOsDetails.OsArchs.I386);\n        }\n\n        Hardware hardware = node.getHardware();\n        Optional<Integer> ram = hardware==null ? Optional.<Integer>absent() : Optional.fromNullable(hardware.getRam());\n        Optional<Integer> cpus = hardware==null ? Optional.<Integer>absent() : Optional.fromNullable(hardware.getProcessors() != null ? hardware.getProcessors().size() : null);\n\n        // Skip superclass' SSH to machine if all data is present, otherwise defer to super\n        if (name.isPresent() && version.isPresent() && architecture.isPresent() && ram.isPresent() && cpus.isPresent()) {\n            LOG.debug(\"Gathered machine details from Jclouds, skipping SSH test on {}\", this);\n            OsDetails osD = new BasicOsDetails(name.get(), architecture.get(), version.get());\n            HardwareDetails hwD = new BasicHardwareDetails(cpus.get(), ram.get());\n            return new BasicMachineDetails(hwD, osD);\n        } else {\n            LOG.debug(\"Machine details for {} missing from Jclouds, using SSH test instead. name={}, version={}, \" +\n                    \"arch={}, ram={}, #cpus={}\",\n                    new Object[]{this, name, version, architecture, ram, cpus});\n            return super.getMachineDetails();\n        }\n    }","id":104334,"modified_method":"@Override\n    public MachineDetails getMachineDetails() {\n        Optional<String> name = Optional.absent();\n        Optional<String> version = Optional.absent();\n        Optional<String> architecture = Optional.absent();\n\n        OperatingSystem os = node.getOperatingSystem();\n        if (os == null && getTemplate() != null && getTemplate().getImage() != null)\n            // some nodes (eg cloudstack, gce) might not get OS available on the node,\n            // so also try taking it from the template if available\n            os = getTemplate().getImage().getOperatingSystem();\n\n        if (os != null) {\n            // Note using family rather than name. Name is often unset.\n            name = Optional.fromNullable(os.getFamily() != null && !OsFamily.UNRECOGNIZED.equals(os.getFamily()) ? os.getFamily().toString() : null);\n            version = Optional.fromNullable(!Strings.isBlank(os.getVersion()) ? os.getVersion() : null);\n            // Using is64Bit rather then getArch because getArch often returns \"paravirtual\"\n            architecture = Optional.fromNullable(os.is64Bit() ? BasicOsDetails.OsArchs.X_86_64 : BasicOsDetails.OsArchs.I386);\n        }\n\n        Hardware hardware = node.getHardware();\n        Optional<Integer> ram = hardware==null ? Optional.<Integer>absent() : Optional.fromNullable(hardware.getRam());\n        Optional<Integer> cpus = hardware==null ? Optional.<Integer>absent() : Optional.fromNullable(hardware.getProcessors() != null ? hardware.getProcessors().size() : null);\n\n        // Skip superclass' SSH to machine if all data is present, otherwise defer to super\n        if (name.isPresent() && version.isPresent() && architecture.isPresent() && ram.isPresent() && cpus.isPresent()) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Gathered machine details from Jclouds, skipping SSH test on {}\", this);\n            }\n            OsDetails osD = new BasicOsDetails(name.get(), architecture.get(), version.get());\n            HardwareDetails hwD = new BasicHardwareDetails(cpus.get(), ram.get());\n            return new BasicMachineDetails(hwD, osD);\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Machine details for {} missing from Jclouds, using SSH test instead. name={}, version={}, \" +\n                                \"arch={}, ram={}, #cpus={}\",\n                        new Object[]{this, name, version, architecture, ram, cpus}\n                );\n            }\n            return super.getMachineDetails();\n        }\n    }","commit_id":"775763296f97090e1e1c04fba63f7e349008dce9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Populates the given XMPP message from the inbound exchange\n     */\n    public void populateXmppMessage(Message message, Exchange exchange) {\n        message.setBody(exchange.getIn().getBody(String.class));\n\n        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {\n\n                if (\"subject\".equalsIgnoreCase(name)) {\n                    // special for subject\n                    String subject = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setSubject(subject);\n                } else if (\"language\".equalsIgnoreCase(name)) {\n                    // special for language\n                    String language = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setLanguage(language);\n                } else {\n                    try {\n                        message.setProperty(name, value);\n                        LOG.debug(\"Added property name: \" + name + \" value: \" + value.toString());\n                    } catch (IllegalArgumentException iae) {\n                        LOG.debug(\"Not adding property \" + name + \" to XMPP message due to \" + iae);\n                    }\n                }\n            }\n        }\n        \n        String id = exchange.getExchangeId();\n        if (id != null) {\n            message.setProperty(\"exchangeId\", id);\n        }\n    }","id":104335,"modified_method":"/**\n     * Populates the given XMPP message from the inbound exchange\n     */\n    public void populateXmppMessage(Message message, Exchange exchange) {\n        message.setBody(exchange.getIn().getBody(String.class));\n\n        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {\n\n                if (\"subject\".equalsIgnoreCase(name)) {\n                    // special for subject\n                    String subject = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setSubject(subject);\n                } else if (\"language\".equalsIgnoreCase(name)) {\n                    // special for language\n                    String language = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setLanguage(language);\n                } else {\n                    try {\n                        message.setProperty(name, value);\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Added property name: \" + name + \" value: \" + value.toString());\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Cannot add property \" + name + \" to XMPP message due: \", iae);\n                        }\n                    }\n                }\n            }\n        }\n        \n        String id = exchange.getExchangeId();\n        if (id != null) {\n            message.setProperty(\"exchangeId\", id);\n        }\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\n        if (endpointCache.containsKey(uri)) {\n            LOG.debug(\"Using cached endpoint for URI \" + uri);\n            return endpointCache.get(uri);\n        }\n\n        LOG.debug(\"Creating new endpoint for URI \" + uri);\n        XmppEndpoint endpoint = new XmppEndpoint(uri, this);\n\n        URI u = new URI(uri);\n        endpoint.setHost(u.getHost());\n        endpoint.setPort(u.getPort());\n        if (u.getUserInfo() != null) {\n            endpoint.setUser(u.getUserInfo());\n        }\n        String remainingPath = u.getPath();\n        if (remainingPath != null) {\n            if (remainingPath.startsWith(\"/\")) {\n                remainingPath = remainingPath.substring(1);\n            }\n\n            // assume its a participant\n            if (remainingPath.length() > 0) {\n                endpoint.setParticipant(remainingPath);\n            }\n        }\n\n        endpointCache.put(uri, endpoint);\n        \n        return endpoint;\n    }","id":104336,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\n        if (endpointCache.containsKey(uri)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Using cached endpoint for URI \" + uri);\n            }\n            return endpointCache.get(uri);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating new endpoint for URI \" + uri);\n        }\n        XmppEndpoint endpoint = new XmppEndpoint(uri, this);\n\n        URI u = new URI(uri);\n        endpoint.setHost(u.getHost());\n        endpoint.setPort(u.getPort());\n        if (u.getUserInfo() != null) {\n            endpoint.setUser(u.getUserInfo());\n        }\n        String remainingPath = u.getPath();\n        if (remainingPath != null) {\n            if (remainingPath.startsWith(\"/\")) {\n                remainingPath = remainingPath.substring(1);\n            }\n\n            // assume its a participant\n            if (remainingPath.length() > 0) {\n                endpoint.setParticipant(remainingPath);\n            }\n        }\n\n        endpointCache.put(uri, endpoint);\n        \n        return endpoint;\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected synchronized void doStop() throws Exception {\n        for (Map.Entry<String, XmppEndpoint> entry : endpointCache.entrySet()) {\n            entry.getValue().destroy();\n        }\n    }","id":104337,"modified_method":"@Override\n    protected synchronized void doStop() throws Exception {\n        for (Map.Entry<String, XmppEndpoint> entry : endpointCache.entrySet()) {\n            entry.getValue().destroy();\n        }\n        endpointCache.clear();\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"public void processMessage(Chat chat, Message message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received XMPP message for \" + endpoint.getUser() + \" from \" + endpoint.getParticipant() + \" : \" + message.getBody());\n        }\n\n        Exchange exchange = endpoint.createExchange(message);\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n    }","id":104338,"modified_method":"public void processMessage(Chat chat, Message message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received XMPP message for \" + endpoint.getUser() + \" from \" + endpoint.getParticipant() + \" : \" + message.getBody());\n        }\n\n        Exchange exchange = endpoint.createExchange(message);\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        } finally {\n            // must remove message from muc to avoid messages stacking up and causing OutOfMemoryError\n            // pollMessage is a non blocking method\n            // (see http://issues.igniterealtime.org/browse/SMACK-129)\n            if (muc != null) {\n                muc.pollMessage();\n            }\n        }\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) {\n        Message message = chat.createMessage();\n        message.setTo(room);\n        message.setFrom(endpoint.getUser());\n\n        endpoint.getBinding().populateXmppMessage(message, exchange);\n        try {\n            // make sure we are connected\n            if (!connection.isConnected()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Reconnecting to: \" + XmppEndpoint.getConnectionMessage(connection));\n                }\n                connection.connect();\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message: \" + message.getBody());\n            }\n            chat.sendMessage(message);\n            // must invoke nextMessage to consume the response from the server\n            // otherwise the client local queue will fill up (CAMEL-1467)\n            chat.nextMessage();\n        } catch (XMPPException e) {\n            throw new RuntimeExchangeException(\"Cannot send XMPP message: \" + message, exchange, e);\n        }\n    }","id":104339,"modified_method":"public void process(Exchange exchange) {\n        Message message = chat.createMessage();\n        message.setTo(room);\n        message.setFrom(endpoint.getUser());\n\n        endpoint.getBinding().populateXmppMessage(message, exchange);\n        try {\n            // make sure we are connected\n            if (!connection.isConnected()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Reconnecting to: \" + XmppEndpoint.getConnectionMessage(connection));\n                }\n                connection.connect();\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message: \" + message.getBody());\n            }\n            chat.sendMessage(message);\n            // must invoke nextMessage to consume the response from the server\n            // otherwise the client local queue will fill up (CAMEL-1467)\n            chat.pollMessage();\n        } catch (XMPPException e) {\n            throw new RuntimeExchangeException(\"Cannot send XMPP message: \" + message, exchange, e);\n        }\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {\n        super(endpoint);\n        this.endpoint = endpoint;\n        this.participant = participant;\n        ObjectHelper.notEmpty(participant, \"participant\");\n        LOG.debug(\"Creating XmppPrivateChatProducer to participant \" + participant);\n    }","id":104340,"modified_method":"public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {\n        super(endpoint);\n        this.endpoint = endpoint;\n        this.participant = participant;\n        ObjectHelper.notEmpty(participant, \"participant\");\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating XmppPrivateChatProducer to participant \" + participant);\n        }\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) {\n        try {\n            if (connection == null) {\n                connection = endpoint.createConnection();\n            }\n\n            // make sure we are connected\n            if (!connection.isConnected()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Reconnecting to: \" + XmppEndpoint.getConnectionMessage(connection));\n                }\n                connection.connect();\n            }\n        } catch (XMPPException e) {\n            throw new RuntimeExchangeException(\"Cannot connect to: \"\n                    + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n\n        ChatManager chatManager = connection.getChatManager();\n        LOG.debug(\"Looking for existing chat instance with thread ID \" + endpoint.getChatId());\n        Chat chat = chatManager.getThreadChat(endpoint.getChatId());\n        if (chat == null) {\n            LOG.debug(\"Creating new chat instance with thread ID \" + endpoint.getChatId());\n            chat = chatManager.createChat(getParticipant(), endpoint.getChatId(), new MessageListener() {\n                public void processMessage(Chat chat, Message message) {\n                    // not here to do conversation\n                    LOG.debug(\"Received and discarding message from \" + getParticipant() + \" : \" + message.getBody());\n                }\n            });\n        }\n\n        Message message = null;\n        try {\n            message = new Message();\n            message.setTo(getParticipant());\n            message.setThread(endpoint.getChatId());\n            message.setType(Message.Type.normal);\n\n            endpoint.getBinding().populateXmppMessage(message, exchange);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message to \" + endpoint.getParticipant() + \" from \" + endpoint.getUser() + \" : \" + message.getBody());\n            }\n            chat.sendMessage(message);\n        } catch (XMPPException xmppe) {\n            throw new RuntimeExchangeException(\"Cannot send XMPP message: to \" + endpoint.getParticipant() + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, xmppe);\n        } catch (Exception e) {\n            throw new RuntimeExchangeException(\"Cannot send XMPP message to \" + endpoint.getParticipant() + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n    }","id":104341,"modified_method":"public void process(Exchange exchange) {\n        try {\n            if (connection == null) {\n                connection = endpoint.createConnection();\n            }\n\n            // make sure we are connected\n            if (!connection.isConnected()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Reconnecting to: \" + XmppEndpoint.getConnectionMessage(connection));\n                }\n                connection.connect();\n            }\n        } catch (XMPPException e) {\n            throw new RuntimeExchangeException(\"Cannot connect to: \"\n                    + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n\n        ChatManager chatManager = connection.getChatManager();\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Looking for existing chat instance with thread ID \" + endpoint.getChatId());\n        }\n        Chat chat = chatManager.getThreadChat(endpoint.getChatId());\n        if (chat == null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Creating new chat instance with thread ID \" + endpoint.getChatId());\n            }\n            chat = chatManager.createChat(getParticipant(), endpoint.getChatId(), new MessageListener() {\n                public void processMessage(Chat chat, Message message) {\n                    // not here to do conversation\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Received and discarding message from \" + getParticipant() + \" : \" + message.getBody());\n                    }\n                }\n            });\n        }\n\n        Message message = null;\n        try {\n            message = new Message();\n            message.setTo(getParticipant());\n            message.setThread(endpoint.getChatId());\n            message.setType(Message.Type.normal);\n\n            endpoint.getBinding().populateXmppMessage(message, exchange);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message to \" + endpoint.getParticipant() + \" from \" + endpoint.getUser() + \" : \" + message.getBody());\n            }\n            chat.sendMessage(message);\n        } catch (XMPPException xmppe) {\n            throw new RuntimeExchangeException(\"Cannot send XMPP message: to \" + endpoint.getParticipant() + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, xmppe);\n        } catch (Exception e) {\n            throw new RuntimeExchangeException(\"Cannot send XMPP message to \" + endpoint.getParticipant() + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n    }","commit_id":"9cae2aaa1a4c71599d3dcce9ea3e893ee36b7194","url":"https://github.com/apache/camel"},{"original_method":"protected synchronized void addServerPoolMember(Entity member) {\n        if (LOG.isTraceEnabled()) LOG.trace(\"Considering to add to {}, new member {} in locations {} - \"+\n                \"waiting for service to be up\", new Object[] {this, member, member.getLocations()});\n        if (serverPoolTargets.contains(member)) return;\n        \n        String address = getAddressOfEntity(member);\n        if (address != null) {\n            serverPoolAddresses.add(address);\n        }\n\n        LOG.info(\"Adding to {}, new member {} with address {}\", new Object[] {this, member, address});\n        \n        update();\n        serverPoolTargets.add(member);\n    }","id":104342,"modified_method":"protected synchronized void addServerPoolMember(Entity member) {\n        if (serverPoolTargets.contains(member)) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"For {}, not adding as already have member {}\", new Object[] {this, member});\n            return;\n        }\n        \n        String address = getAddressOfEntity(member);\n        if (address != null) {\n            serverPoolAddresses.add(address);\n        }\n\n        LOG.info(\"Adding to {}, new member {} with address {}\", new Object[] {this, member, address});\n        \n        update();\n        serverPoolTargets.add(member);\n    }","commit_id":"fe9e98c96366f562104e72394d18c4663a37ba2d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void onServerPoolMemberChanged(Entity member) {\n        if (LOG.isTraceEnabled()) LOG.trace(\"Start {} checkEntity {}\", this, member);\n        if (belongsInServerPool(member)) {\n            addServerPoolMember(member);\n        } else {\n            removeServerPoolMember(member);\n        }\n        if (LOG.isTraceEnabled()) LOG.trace(\"Done {} checkEntity {}\", this, member);\n    }","id":104343,"modified_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (LOG.isTraceEnabled()) LOG.trace(\"For {}, considering membership of {} which is in locations {}\", \n                new Object[] {this, member, member.getLocations()});\n        if (belongsInServerPool(member)) {\n            addServerPoolMember(member);\n        } else {\n            removeServerPoolMember(member);\n        }\n        if (LOG.isTraceEnabled()) LOG.trace(\"Done {} checkEntity {}\", this, member);\n    }","commit_id":"fe9e98c96366f562104e72394d18c4663a37ba2d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected synchronized void removeServerPoolMember(Entity member) {\n        if (LOG.isTraceEnabled()) LOG.trace(\"Considering to remove from {}, member {} in locations {} - \"+\n                \"waiting for service to be up\", new Object[] {this, member, member.getLocations()});\n        if (!serverPoolTargets.contains(member)) return;\n        \n        String address = getAddressOfEntity(member);\n        if (address != null) {\n            serverPoolAddresses.remove(address);\n        }\n        \n        LOG.info(\"Removing from {}, member {} with address {}\", new Object[] {this, member, address});\n        \n        update();\n        serverPoolTargets.remove(member);\n    }","id":104344,"modified_method":"protected synchronized void removeServerPoolMember(Entity member) {\n        if (!serverPoolTargets.contains(member)) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"For {}, not removing as don't have member {}\", new Object[] {this, member});\n            return;\n        }\n        \n        String address = getAddressOfEntity(member);\n        if (address != null) {\n            serverPoolAddresses.remove(address);\n        }\n        \n        LOG.info(\"Removing from {}, member {} with address {}\", new Object[] {this, member, address});\n        \n        update();\n        serverPoolTargets.remove(member);\n    }","commit_id":"fe9e98c96366f562104e72394d18c4663a37ba2d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected String getAddressOfEntity(Entity member) {\n        String ip = member.getAttribute(Attributes.HOSTNAME);\n        Integer port = member.getAttribute(Attributes.HTTP_PORT);\n        if (ip!=null && port!=null) {\n            return ip+\":\"+port;\n        }\n        LOG.error(\"Unable to construct hostname:port representation for \"+member+\"; skipping in \"+this);\n        return null;\n    }","id":104345,"modified_method":"protected String getAddressOfEntity(Entity member) {\n        String ip = member.getAttribute(Attributes.HOSTNAME);\n        Integer port = member.getAttribute(Attributes.HTTP_PORT);\n        if (ip!=null && port!=null) {\n            return ip+\":\"+port;\n        }\n        LOG.error(\"Unable to construct hostname:port representation for {} ({}:{}); skipping in {}\", \n                new Object[] {member, ip, port, this});\n        return null;\n    }","commit_id":"fe9e98c96366f562104e72394d18c4663a37ba2d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected boolean belongsInServerPool(Entity member) {\n        if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {\n            LOG.debug(\"Members of {}, checking {}, eliminating because not up\", getDisplayName(), member.getDisplayName());\n            return false;\n        }\n        if (!getServerPool().getMembers().contains(member)) {\n            LOG.debug(\"Members of {}, checking {}, eliminating because not member\", getDisplayName(), member.getDisplayName());\n            return false;\n        }\n        LOG.debug(\"Members of {}, checking {}, approving\", getDisplayName(), member.getDisplayName());\n        return true;\n    }","id":104346,"modified_method":"protected boolean belongsInServerPool(Entity member) {\n        if (!groovyTruth(member.getAttribute(Startable.SERVICE_UP))) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Members of {}, checking {}, eliminating because not up\", getDisplayName(), member.getDisplayName());\n            return false;\n        }\n        if (!getServerPool().getMembers().contains(member)) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Members of {}, checking {}, eliminating because not member\", getDisplayName(), member.getDisplayName());\n            return false;\n        }\n        if (LOG.isTraceEnabled()) LOG.trace(\"Members of {}, checking {}, approving\", getDisplayName(), member.getDisplayName());\n        return true;\n    }","commit_id":"fe9e98c96366f562104e72394d18c4663a37ba2d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Pools the given file or directory for files to process.\n     *\n     * @param fileOrDirectory  file or directory\n     * @param processDir  recursive\n     * @return the number of files processed or being processed async.\n     */\n    protected int pollFileOrDirectory(File fileOrDirectory, boolean processDir) {\n        if (!fileOrDirectory.isDirectory()) {\n            return pollFile(fileOrDirectory); // process the file\n        } else if (processDir) {\n            int rc = 0;\n            if (isValidFile(fileOrDirectory)) {\n                LOG.debug(\"Polling directory \" + fileOrDirectory);\n                File[] files = fileOrDirectory.listFiles();\n                for (File file : files) {\n                    rc += pollFileOrDirectory(file, isRecursive()); // self-recursion\n                }\n            }\n            return rc;\n        } else {\n            LOG.debug(\"Skipping directory \" + fileOrDirectory);\n            return 0;\n        }\n    }","id":104347,"modified_method":"/**\n     * Pools the given file or directory for files to process.\n     *\n     * @param fileOrDirectory  file or directory\n     * @param processDir  recursive\n     * @return the number of files processed or being processed async.\n     */\n    protected int pollFileOrDirectory(File fileOrDirectory, boolean processDir) {\n        if (!fileOrDirectory.isDirectory()) {\n            // process the file\n            return pollFile(fileOrDirectory);\n        } else if (processDir) {\n            // directory that can be recursive\n            int rc = 0;\n            if (isValidFile(fileOrDirectory)) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Polling directory \" + fileOrDirectory);\n                }\n                File[] files = fileOrDirectory.listFiles();\n                for (File file : files) {\n                    rc += pollFileOrDirectory(file, isRecursive()); // self-recursion\n                }\n            }\n            return rc;\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Skipping directory \" + fileOrDirectory);\n            }\n            return 0;\n        }\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"protected void acquireExclusiveRead(File file) throws IOException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Waiting for exclusive lock to file: \" + file);\n        }\n\n        // try to acquire rw lock on the file before we can consume it\n        FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel();\n        try {\n            FileLock lock = channel.lock();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Acquired exclusive lock: \" + lock + \" to file: \" + file);\n            }\n            // just release it now we dont want to hold it during the rest of the processing\n            lock.release();\n        } finally {\n            // must close channel\n            ObjectHelper.close(channel, \"FileConsumer during acquiring of exclusive lock\", LOG);\n        }\n    }","id":104348,"modified_method":"/**\n     * Acquires exclusive read lock to the given file. Will wait until the lock is granted.\n     * After granting the read lock it is realeased, we just want to make sure that when we start\n     * consuming the file its not currently in progress of being written by third party.\n     */\n    protected void acquireExclusiveReadLock(File file) throws IOException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Waiting for exclusive read lock to file: \" + file);\n        }\n\n        // try to acquire rw lock on the file before we can consume it\n        FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel();\n        try {\n            FileLock lock = channel.lock();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Acquired exclusive read lock: \" + lock + \" to file: \" + file);\n            }\n            // just release it now we dont want to hold it during the rest of the processing\n            lock.release();\n        } finally {\n            // must close channel\n            ObjectHelper.close(channel, \"FileConsumer during acquiring of exclusive read lock\", LOG);\n        }\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"public void setExclusiveRead(boolean exclusiveRead) {\n        this.exclusiveRead = exclusiveRead;\n    }","id":104349,"modified_method":"public void setExclusiveReadLock(boolean exclusiveReadLock) {\n        this.exclusiveReadLock = exclusiveReadLock;\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"public boolean isExclusiveRead() {\n        return exclusiveRead;\n    }","id":104350,"modified_method":"public boolean isExclusiveReadLock() {\n        return exclusiveReadLock;\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Polls the given file\n     *\n     * @param file  the file\n     * @return returns 1 if the file was processed, 0 otherwise.\n     */\n    protected int pollFile(final File file) {\n\n        if (!file.exists()) {\n            return 0;\n        }\n        if (!isValidFile(file)) {\n            return 0;\n        }\n        // we only care about file modified times if we are not deleting/moving files\n        if (!endpoint.isNoop()) {\n            if (filesBeingProcessed.contains(file)) {\n                return 1;\n            }\n            filesBeingProcessed.put(file, file);\n        }\n\n        final FileProcessStrategy processStrategy = endpoint.getFileStrategy();\n        final FileExchange exchange = endpoint.createExchange(file);\n\n        endpoint.configureMessage(file, exchange.getIn());\n        try {\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveRead) {\n                acquireExclusiveRead(file);\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"About to process file: \" + file + \" using exchange: \" + exchange);\n            }\n            if (processStrategy.begin(endpoint, exchange, file)) {\n\n                // Use the async processor interface so that processing of\n                // the exchange can happen asynchronously\n                getAsyncProcessor().process(exchange, new AsyncCallback() {\n                    public void done(boolean sync) {\n                        boolean failed = exchange.isFailed();\n                        boolean handled = DeadLetterChannel.isFailureHandled(exchange);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Done processing file: \" + file + \". Status is: \" + (failed ? \"failed: \" + failed + \", handled by failure processor: \" + handled : \"processed OK\"));\n                        }\n\n                        if (!failed || handled) {\n                            // commit the file strategy if there was no failure or already handled by the DeadLetterChannel\n                            processStrategyCommit(processStrategy, exchange, file, handled);\n                        } else if (failed && !handled) {\n                            // there was an exception but it was not handled by the DeadLetterChannel\n                            handleException(exchange.getException());\n                        }\n\n                        filesBeingProcessed.remove(file);\n                    }\n                });\n\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(endpoint + \" cannot process file: \" + file);\n                }\n            }\n        } catch (Throwable e) {\n            handleException(e);\n        }\n\n        return 1;\n    }","id":104351,"modified_method":"/**\n     * Polls the given file\n     *\n     * @param file  the file\n     * @return returns 1 if the file was processed, 0 otherwise.\n     */\n    protected int pollFile(final File file) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + file);\n        }\n\n        if (!file.exists()) {\n            return 0;\n        }\n        if (!isValidFile(file)) {\n            return 0;\n        }\n        // we only care about file modified times if we are not deleting/moving files\n        if (!endpoint.isNoop()) {\n            if (filesBeingProcessed.contains(file)) {\n                return 1;\n            }\n            filesBeingProcessed.put(file, file);\n        }\n\n        final FileProcessStrategy processStrategy = endpoint.getFileStrategy();\n        final FileExchange exchange = endpoint.createExchange(file);\n\n        endpoint.configureMessage(file, exchange.getIn());\n        try {\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveReadLock) {\n                acquireExclusiveReadLock(file);\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"About to process file: \" + file + \" using exchange: \" + exchange);\n            }\n            if (processStrategy.begin(endpoint, exchange, file)) {\n\n                // Use the async processor interface so that processing of\n                // the exchange can happen asynchronously\n                getAsyncProcessor().process(exchange, new AsyncCallback() {\n                    public void done(boolean sync) {\n                        boolean failed = exchange.isFailed();\n                        boolean handled = DeadLetterChannel.isFailureHandled(exchange);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Done processing file: \" + file + \". Status is: \" + (failed ? \"failed: \" + failed + \", handled by failure processor: \" + handled : \"processed OK\"));\n                        }\n\n                        if (!failed || handled) {\n                            // commit the file strategy if there was no failure or already handled by the DeadLetterChannel\n                            processStrategyCommit(processStrategy, exchange, file, handled);\n                        } else if (failed && !handled) {\n                            // there was an exception but it was not handled by the DeadLetterChannel\n                            handleException(exchange.getException());\n                        }\n\n                        filesBeingProcessed.remove(file);\n                    }\n                });\n\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(endpoint + \" can not process file: \" + file);\n                }\n            }\n        } catch (Throwable e) {\n            handleException(e);\n        }\n\n        return 1;\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"private void pollFile(FTPFile ftpFile) throws Exception {\n        if (ftpFile == null) {\n            return;\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + ftpFile);\n        }\n\n        long ts = ftpFile.getTimestamp().getTimeInMillis();\n        // TODO do we need to adjust the TZ? can we?\n        if (ts > lastPollTime && isMatched(ftpFile)) {\n            String fullFileName = getFullFileName(ftpFile);\n\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveRead) {\n                acquireExclusiveRead(client, ftpFile);\n            }\n\n            // retrieve the file\n            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Retrieved file: \" + ftpFile.getName() + \" from: \" + remoteServer());\n            }\n\n            RemoteFileExchange exchange = endpoint.createExchange(fullFileName, byteArrayOutputStream);\n\n            if (isSetNames()) {\n                // set the filename in the special header filename marker to the ftp filename\n                String ftpBasePath = endpoint.getConfiguration().getFile();\n                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);\n                relativePath = relativePath.replaceFirst(\"/\", \"\");\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Setting exchange filename to \" + relativePath);\n                }\n                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n            }\n\n            if (deleteFile) {\n                // delete file after consuming\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Deleteing file: \" + ftpFile.getName() + \" from: \" + remoteServer());\n                }\n                boolean deleted = client.deleteFile(ftpFile.getName());\n                if (!deleted) {\n                    // ignore just log a warning\n                    LOG.warn(\"Could not delete file: \" + ftpFile.getName() + \" from: \" + remoteServer());\n                }\n            } else if (isMoveFile()) {\n                String fromName = ftpFile.getName();\n                String toName = getMoveFileName(fromName);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Moving file: \" + fromName + \" to: \" + toName);\n                }\n\n                // delete any existing file\n                boolean deleted = client.deleteFile(toName);\n                if (!deleted) {\n                    // if we could not delete any existing file then maybe the folder is missing\n                    // build folder if needed\n                    int lastPathIndex = toName.lastIndexOf('/');\n                    if (lastPathIndex != -1) {\n                        String directory = toName.substring(0, lastPathIndex);\n                        if (!FtpUtils.buildDirectory(client, directory)) {\n                            LOG.warn(\"Couldn't build directory: \" + directory + \" (could be because of denied permissions)\");\n                        }\n                    }\n                }\n\n                // try to rename\n                boolean success = client.rename(fromName, toName);\n                if (!success) {\n                    LOG.warn(\"Could not move file: \" + fromName + \" to: \" + toName);\n                }\n            }\n\n            getProcessor().process(exchange);\n        }\n    }","id":104352,"modified_method":"private void pollFile(FTPFile ftpFile) throws Exception {\n        if (ftpFile == null) {\n            return;\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + ftpFile);\n        }\n\n        long ts = ftpFile.getTimestamp().getTimeInMillis();\n        // TODO do we need to adjust the TZ? can we?\n        if (ts > lastPollTime && isMatched(ftpFile)) {\n            String fullFileName = getFullFileName(ftpFile);\n\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveReadLock) {\n                acquireExclusiveReadLock(client, ftpFile);\n            }\n\n            // retrieve the file\n            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Retrieved file: \" + ftpFile.getName() + \" from: \" + remoteServer());\n            }\n\n            RemoteFileExchange exchange = endpoint.createExchange(fullFileName, byteArrayOutputStream);\n\n            if (isSetNames()) {\n                // set the filename in the special header filename marker to the ftp filename\n                String ftpBasePath = endpoint.getConfiguration().getFile();\n                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);\n                relativePath = relativePath.replaceFirst(\"/\", \"\");\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Setting exchange filename to \" + relativePath);\n                }\n                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n            }\n\n            if (deleteFile) {\n                // delete file after consuming\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Deleteing file: \" + ftpFile.getName() + \" from: \" + remoteServer());\n                }\n                boolean deleted = client.deleteFile(ftpFile.getName());\n                if (!deleted) {\n                    // ignore just log a warning\n                    LOG.warn(\"Can not delete file: \" + ftpFile.getName() + \" from: \" + remoteServer());\n                }\n            } else if (isMoveFile()) {\n                String fromName = ftpFile.getName();\n                String toName = getMoveFileName(fromName);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Moving file: \" + fromName + \" to: \" + toName);\n                }\n\n                // delete any existing file\n                boolean deleted = client.deleteFile(toName);\n                if (!deleted) {\n                    // if we could not delete any existing file then maybe the folder is missing\n                    // build folder if needed\n                    int lastPathIndex = toName.lastIndexOf('/');\n                    if (lastPathIndex != -1) {\n                        String directory = toName.substring(0, lastPathIndex);\n                        if (!FtpUtils.buildDirectory(client, directory)) {\n                            LOG.warn(\"Can not build directory: \" + directory + \" (maybe because of denied permissions)\");\n                        }\n                    }\n                }\n\n                // try to rename\n                boolean success = client.rename(fromName, toName);\n                if (!success) {\n                    LOG.warn(\"Can not move file: \" + fromName + \" to: \" + toName);\n                }\n            }\n\n            getProcessor().process(exchange);\n        }\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"protected void acquireExclusiveRead(FTPClient client, FTPFile ftpFile) throws IOException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Waiting for exclusive lock to file: \" + ftpFile);\n        }\n\n        // the trick is to try to rename the file, if we can rename then we have exclusive read\n        // since its a remote file we can not use java.nio to get a RW lock\n        String originalName = ftpFile.getName();\n        String newName = originalName + \".camelExclusiveRead\";\n        boolean exclusive = false;\n        while (!exclusive) {\n            exclusive = client.rename(originalName, newName);\n            if (exclusive) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Acquired exclusive lock to file: \" + originalName);\n                }\n                // rename it back so we can read it\n                client.rename(newName, originalName);\n            } else {\n                LOG.trace(\"Exclusive lock not granted. Sleeping for 1000 millis.\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }\n    }","id":104353,"modified_method":"protected void acquireExclusiveReadLock(FTPClient client, FTPFile ftpFile) throws IOException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Waiting for exclusive read lock to file: \" + ftpFile);\n        }\n\n        // the trick is to try to rename the file, if we can rename then we have exclusive read\n        // since its a remote file we can not use java.nio to get a RW lock\n        String originalName = ftpFile.getName();\n        String newName = originalName + \".camelExclusiveReadLock\";\n        boolean exclusive = false;\n        while (!exclusive) {\n            exclusive = client.rename(originalName, newName);\n            if (exclusive) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Acquired exclusive read lock to file: \" + originalName);\n                }\n                // rename it back so we can read it\n                client.rename(newName, originalName);\n            } else {\n                LOG.trace(\"Exclusive read lock not granted. Sleeping for 1000 millis.\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"protected void pollDirectory(String dir) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling directory: \" + dir);\n        }\n        String currentDir = client.printWorkingDirectory();\n\n        client.changeWorkingDirectory(dir);\n        for (FTPFile ftpFile : client.listFiles()) {\n            if (ftpFile.isFile()) {\n                pollFile(ftpFile);\n            } else if (ftpFile.isDirectory()) {\n                if (isRecursive()) {\n                    pollDirectory(getFullFileName(ftpFile));\n                }\n            } else {\n                LOG.debug(\"Unsupported type of FTPFile: \" + ftpFile + \" (not a file or directory). Is skipped.\");\n            }\n        }\n\n        // change back to original current dir\n        client.changeWorkingDirectory(currentDir);\n    }","id":104354,"modified_method":"protected void pollDirectory(String dir) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling directory: \" + dir);\n        }\n        String currentDir = client.printWorkingDirectory();\n\n        client.changeWorkingDirectory(dir);\n        for (FTPFile ftpFile : client.listFiles()) {\n            if (ftpFile.isFile()) {\n                pollFile(ftpFile);\n            } else if (ftpFile.isDirectory()) {\n                if (isRecursive()) {\n                    pollDirectory(getFullFileName(ftpFile));\n                }\n            } else {\n                LOG.debug(\"Unsupported type of FTPFile: \" + ftpFile + \" (not a file or directory). It is skipped.\");\n            }\n        }\n\n        // change back to original current dir\n        client.changeWorkingDirectory(currentDir);\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"public boolean isExclusiveRead() {\n        return exclusiveRead;\n    }","id":104355,"modified_method":"public boolean isExclusiveReadLock() {\n        return exclusiveReadLock;\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"public void setExclusiveRead(boolean exclusiveRead) {\n        this.exclusiveRead = exclusiveRead;\n    }","id":104356,"modified_method":"public void setExclusiveReadLock(boolean exclusiveReadLock) {\n        this.exclusiveReadLock = exclusiveReadLock;\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + sftpFile);\n        }\n\n        long ts = sftpFile.getAttrs().getMTime() * 1000L;\n\n        // TODO do we need to adjust the TZ? can we?\n        if (ts > lastPollTime && isMatched(sftpFile)) {\n            String fullFileName = getFullFileName(sftpFile);\n\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveRead) {\n                acquireExclusiveRead(sftpFile);\n            }\n\n            // retrieve the file\n            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            channel.get(sftpFile.getFilename(), byteArrayOutputStream);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Retrieved file: \" + sftpFile.getFilename() + \" from: \" + remoteServer());\n            }\n\n            RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile), byteArrayOutputStream);\n\n            if (isSetNames()) {\n                String ftpBasePath = endpoint.getConfiguration().getFile();\n                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);\n                relativePath = relativePath.replaceFirst(\"/\", \"\");\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Setting exchange filename to \" + relativePath);\n                }\n                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n            }\n\n            if (deleteFile) {\n                // delete file after consuming\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Deleteing file: \" + sftpFile.getFilename() + \" from: \" + remoteServer());\n                }\n                deleteFile(sftpFile.getFilename());\n            } else if (isMoveFile()) {\n                String fromName = sftpFile.getFilename();\n                String toName = getMoveFileName(fromName);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Moving file: \" + fromName + \" to: \" + toName);\n                }\n\n                // delete any existing file\n                boolean deleted = deleteFile(toName);\n                if (!deleted) {\n                    // if we could not delete any existing file then maybe the folder is missing\n                    // build folder if needed\n                    int lastPathIndex = toName.lastIndexOf('/');\n                    if (lastPathIndex != -1) {\n                        String directory = toName.substring(0, lastPathIndex);\n                        if (!SftpUtils.buildDirectory(channel, directory)) {\n                            LOG.warn(\"Couldn't build directory: \" + directory + \" (could be because of denied permissions)\");\n                        }\n                    }\n                }\n\n                // try to rename\n                try {\n                    channel.rename(fromName, toName);\n                } catch (SftpException e) {\n                    // ignore just log a warning\n                    LOG.warn(\"Could not move file: \" + fromName + \" to: \" + toName);\n                }\n            }\n\n            getProcessor().process(exchange);\n        }\n    }","id":104357,"modified_method":"private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + sftpFile);\n        }\n\n        long ts = sftpFile.getAttrs().getMTime() * 1000L;\n\n        // TODO do we need to adjust the TZ? can we?\n        if (ts > lastPollTime && isMatched(sftpFile)) {\n            String fullFileName = getFullFileName(sftpFile);\n\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveReadLock) {\n                acquireExclusiveReadLock(sftpFile);\n            }\n\n            // retrieve the file\n            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            channel.get(sftpFile.getFilename(), byteArrayOutputStream);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Retrieved file: \" + sftpFile.getFilename() + \" from: \" + remoteServer());\n            }\n\n            RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile), byteArrayOutputStream);\n\n            if (isSetNames()) {\n                String ftpBasePath = endpoint.getConfiguration().getFile();\n                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);\n                relativePath = relativePath.replaceFirst(\"/\", \"\");\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Setting exchange filename to \" + relativePath);\n                }\n                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n            }\n\n            if (deleteFile) {\n                // delete file after consuming\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Deleteing file: \" + sftpFile.getFilename() + \" from: \" + remoteServer());\n                }\n                deleteFile(sftpFile.getFilename());\n            } else if (isMoveFile()) {\n                String fromName = sftpFile.getFilename();\n                String toName = getMoveFileName(fromName);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Moving file: \" + fromName + \" to: \" + toName);\n                }\n\n                // delete any existing file\n                boolean deleted = deleteFile(toName);\n                if (!deleted) {\n                    // if we could not delete any existing file then maybe the folder is missing\n                    // build folder if needed\n                    int lastPathIndex = toName.lastIndexOf('/');\n                    if (lastPathIndex != -1) {\n                        String directory = toName.substring(0, lastPathIndex);\n                        if (!SftpUtils.buildDirectory(channel, directory)) {\n                            LOG.warn(\"Can not build directory: \" + directory + \" (maybe because of denied permissions)\");\n                        }\n                    }\n                }\n\n                // try to rename\n                try {\n                    channel.rename(fromName, toName);\n                } catch (SftpException e) {\n                    // ignore just log a warning\n                    LOG.warn(\"Can not move file: \" + fromName + \" to: \" + toName);\n                }\n            }\n\n            getProcessor().process(exchange);\n        }\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"protected void acquireExclusiveRead(ChannelSftp.LsEntry sftpFile) throws SftpException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Waiting for exclusive lock to file: \" + sftpFile);\n        }\n\n        // the trick is to try to rename the file, if we can rename then we have exclusive read\n        // since its a remote file we can not use java.nio to get a RW access\n        String originalName = sftpFile.getFilename();\n        String newName = originalName + \".camelExclusiveRead\";\n        boolean exclusive = false;\n        while (!exclusive) {\n            try {\n                channel.rename(originalName, newName);\n                exclusive = true;\n            } catch (SftpException e) {\n                // ignore we can not rename it\n            }\n\n            if (exclusive) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Acquired exclusive lock to file: \" + originalName);\n                }\n                // rename it back so we can read it\n                channel.rename(newName, originalName);\n            } else {\n                LOG.trace(\"Exclusive lock not granted. Sleeping for 1000 millis\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }\n    }","id":104358,"modified_method":"protected void acquireExclusiveReadLock(ChannelSftp.LsEntry sftpFile) throws SftpException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Waiting for exclusive read lock to file: \" + sftpFile);\n        }\n\n        // the trick is to try to rename the file, if we can rename then we have exclusive read\n        // since its a remote file we can not use java.nio to get a RW access\n        String originalName = sftpFile.getFilename();\n        String newName = originalName + \".camelExclusiveReadLock\";\n        boolean exclusive = false;\n        while (!exclusive) {\n            try {\n                channel.rename(originalName, newName);\n                exclusive = true;\n            } catch (SftpException e) {\n                // ignore we can not rename it\n            }\n\n            if (exclusive) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Acquired exclusive read lock to file: \" + originalName);\n                }\n                // rename it back so we can read it\n                channel.rename(newName, originalName);\n            } else {\n                LOG.trace(\"Exclusive read lock not granted. Sleeping for 1000 millis\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }\n    }","commit_id":"4f0082749e3715a0fe1f65db5dc963fc58102829","url":"https://github.com/apache/camel"},{"original_method":"/**\n   * Run the given file through each of the cleaners to see if it should be deleted, deleting it if\n   * necessary.\n   * @param filePath path of the file to check (and possibly delete)\n   * @throws IOException if cann't delete a file because of a filesystem issue\n   * @throws IllegalArgumentException if the file is a directory and has children\n   */\n  private boolean checkAndDelete(Path filePath) throws IOException, IllegalArgumentException {\n    // first check to see if the path is valid\n    if (!validate(filePath)) {\n      LOG.warn(\"Found a wrongly formatted file: \" + filePath.getName() + \" deleting it.\");\n      boolean success = this.fs.delete(filePath, true);\n      if(!success)\n        LOG.warn(\"Attempted to delete: \" + filePath\n            + \", but couldn't. Run cleaner chain and attempt to delete on next pass.\");\n\n      return success;\n    }\n\n    // check each of the cleaners for the file\n    for (T cleaner : cleanersChain) {\n      if (cleaner.isStopped() || this.stopper.isStopped()) {\n        LOG.warn(\"A file cleaner\" + this.getName() + \" is stopped, won't delete any file in:\"\n            + this.oldFileDir);\n        return false;\n      }\n\n      if (!cleaner.isFileDeletable(filePath)) {\n        // this file is not deletable, then we are done\n        LOG.debug(filePath + \" is not deletable according to:\" + cleaner);\n        return false;\n      }\n    }\n    // delete this file if it passes all the cleaners\n    LOG.debug(\"Removing: \" + filePath + \" from archive\");\n    boolean success = this.fs.delete(filePath, false);\n    if (!success) {\n      LOG.warn(\"Attempted to delete:\" + filePath\n          + \", but couldn't. Run cleaner chain and attempt to delete on next pass.\");\n    }\n    return success;\n  }","id":104359,"modified_method":"/**\n   * Run the given file through each of the cleaners to see if it should be deleted, deleting it if\n   * necessary.\n   * @param filePath path of the file to check (and possibly delete)\n   * @throws IOException if cann't delete a file because of a filesystem issue\n   * @throws IllegalArgumentException if the file is a directory and has children\n   */\n  private boolean checkAndDelete(Path filePath) throws IOException, IllegalArgumentException {\n    // first check to see if the path is valid\n    if (!validate(filePath)) {\n      LOG.warn(\"Found a wrongly formatted file: \" + filePath.getName() + \" deleting it.\");\n      boolean success = this.fs.delete(filePath, true);\n      if(!success)\n        LOG.warn(\"Attempted to delete: \" + filePath\n            + \", but couldn't. Run cleaner chain and attempt to delete on next pass.\");\n\n      return success;\n    }\n\n    // check each of the cleaners for the file\n    for (T cleaner : cleanersChain) {\n      if (cleaner.isStopped() || this.stopper.isStopped()) {\n        LOG.warn(\"A file cleaner\" + this.getName() + \" is stopped, won't delete any file in:\"\n            + this.oldFileDir);\n        return false;\n      }\n\n      if (!cleaner.isFileDeletable(filePath)) {\n        // this file is not deletable, then we are done\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(filePath + \" is not deletable according to:\" + cleaner);\n        }\n        return false;\n      }\n    }\n    // delete this file if it passes all the cleaners\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Removing: \" + filePath + \" from archive\");\n    }\n    boolean success = this.fs.delete(filePath, false);\n    if (!success) {\n      LOG.warn(\"Attempted to delete:\" + filePath\n          + \", but couldn't. Run cleaner chain and attempt to delete on next pass.\");\n    }\n    return success;\n  }","commit_id":"d8ceacc577a90e0cfcc137983d37ed7b9d77e3fe","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Attempt to delete a directory and all files under that directory. Each child file is passed\n   * through the delegates to see if it can be deleted. If the directory has no children when the\n   * cleaners have finished it is deleted.\n   * <p>\n   * If new children files are added between checks of the directory, the directory will <b>not<\/b>\n   * be deleted.\n   * @param toCheck directory to check\n   * @return <tt>true<\/tt> if the directory was deleted, <tt>false<\/tt> otherwise.\n   * @throws IOException if there is an unexpected filesystem error\n   */\n  private boolean checkAndDeleteDirectory(Path toCheck) throws IOException {\n    LOG.debug(\"Checking directory: \" + toCheck);\n    FileStatus[] children = FSUtils.listStatus(fs, toCheck);\n    // if the directory doesn't exist, then we are done\n    if (children == null) return true;\n\n    boolean canDeleteThis = true;\n    for (FileStatus child : children) {\n      Path path = child.getPath();\n      // attempt to delete all the files under the directory\n      if (child.isDir()) {\n        if (!checkAndDeleteDirectory(path)) {\n          canDeleteThis = false;\n        }\n      }\n      // otherwise we can just check the file\n      else if (!checkAndDelete(path)) {\n        canDeleteThis = false;\n      }\n    }\n\n    // if all the children have been deleted, then we should try to delete this directory. However,\n    // don't do so recursively so we don't delete files that have been added since we checked.\n    return canDeleteThis ? fs.delete(toCheck, false) : false;\n  }","id":104360,"modified_method":"/**\n   * Attempt to delete a directory and all files under that directory. Each child file is passed\n   * through the delegates to see if it can be deleted. If the directory has no children when the\n   * cleaners have finished it is deleted.\n   * <p>\n   * If new children files are added between checks of the directory, the directory will <b>not<\/b>\n   * be deleted.\n   * @param toCheck directory to check\n   * @return <tt>true<\/tt> if the directory was deleted, <tt>false<\/tt> otherwise.\n   * @throws IOException if there is an unexpected filesystem error\n   */\n  private boolean checkAndDeleteDirectory(Path toCheck) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Checking directory: \" + toCheck);\n    }\n    FileStatus[] children = FSUtils.listStatus(fs, toCheck);\n    // if the directory doesn't exist, then we are done\n    if (children == null) return true;\n\n    boolean canDeleteThis = true;\n    for (FileStatus child : children) {\n      Path path = child.getPath();\n      // attempt to delete all the files under the directory\n      if (child.isDir()) {\n        if (!checkAndDeleteDirectory(path)) {\n          canDeleteThis = false;\n        }\n      }\n      // otherwise we can just check the file\n      else if (!checkAndDelete(path)) {\n        canDeleteThis = false;\n      }\n    }\n\n    // if all the children have been deleted, then we should try to delete this directory. However,\n    // don't do so recursively so we don't delete files that have been added since we checked.\n    return canDeleteThis ? fs.delete(toCheck, false) : false;\n  }","commit_id":"d8ceacc577a90e0cfcc137983d37ed7b9d77e3fe","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public boolean isFileDeletable(Path filePath) {\n    if (!instantiateFS()) {\n      return false;\n    }\n    long time = 0;\n    long currentTime = EnvironmentEdgeManager.currentTimeMillis();\n    try {\n      FileStatus fStat = fs.getFileStatus(filePath);\n      time = fStat.getModificationTime();\n    } catch (IOException e) {\n      LOG.error(\"Unable to get modification time of file \" + filePath.getName()\n          + \", not deleting it.\", e);\n      return false;\n    }\n    long life = currentTime - time;\n    LOG.debug(\"Life:\" + life + \", ttl:\" + ttl + \", current:\" + currentTime + \", from: \" + time);\n    if (life < 0) {\n      LOG.warn(\"Found a log (\" + filePath + \") newer than current time (\" + currentTime + \" < \"\n          + time + \"), probably a clock skew\");\n      return false;\n    }\n    return life > ttl;\n  }","id":104361,"modified_method":"@Override\n  public boolean isFileDeletable(Path filePath) {\n    if (!instantiateFS()) {\n      return false;\n    }\n    long time = 0;\n    long currentTime = EnvironmentEdgeManager.currentTimeMillis();\n    try {\n      FileStatus fStat = fs.getFileStatus(filePath);\n      time = fStat.getModificationTime();\n    } catch (IOException e) {\n      LOG.error(\"Unable to get modification time of file \" + filePath.getName()\n          + \", not deleting it.\", e);\n      return false;\n    }\n    long life = currentTime - time;\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"HFile life:\" + life + \", ttl:\" + ttl + \", current:\" + currentTime + \", from: \"\n          + time);\n    }\n    if (life < 0) {\n      LOG.warn(\"Found a log (\" + filePath + \") newer than current time (\" + currentTime + \" < \"\n          + time + \"), probably a clock skew\");\n      return false;\n    }\n    return life > ttl;\n  }","commit_id":"d8ceacc577a90e0cfcc137983d37ed7b9d77e3fe","url":"https://github.com/apache/hbase"},{"original_method":"public CreateSnapshotResponseType CreateSnapshot( CreateSnapshotType request ) throws EucalyptusCloudException {\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    Volume vol = db.recast( Volume.class ).getUnique( Volume.named( userName, request.getVolumeId() ) );\n\n    String newId = null;\n    Snapshot snap = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( new Snapshot( null, newId ) );\n        snap = new Snapshot( request.getUserId(), newId, vol.getDisplayName() );\n        db.add( snap );\n        break;\n      } catch ( EucalyptusCloudException e ) {}\n    }\n\n    CreateStorageSnapshotType scRequest = new CreateStorageSnapshotType( newId, vol.getDisplayName() );\n    CreateStorageSnapshotResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageSnapshotResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n      snap.setMappedState( scReply.getStatus() );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageSnapshot:\" + e.getMessage() );\n    }\n    db.commit();\n\n    CreateSnapshotResponseType reply = ( CreateSnapshotResponseType ) request.getReply();\n    edu.ucsb.eucalyptus.msgs.Snapshot snapMsg = snap.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n    snapMsg.setProgress( snapMsg.getProgress() );\n    reply.setSnapshot( snapMsg );\n    return reply;\n  }","id":104362,"modified_method":"public CreateSnapshotResponseType CreateSnapshot( CreateSnapshotType request ) throws EucalyptusCloudException {\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    Volume vol = db.recast( Volume.class ).getUnique( Volume.named( userName, request.getVolumeId() ) );\n\n    String newId = null;\n    Snapshot snap = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( Snapshot.ownedBy( newId ) );\n        snap = new Snapshot( request.getUserId(), newId, vol.getDisplayName() );\n        db.add( snap );\n        break;\n      } catch ( EucalyptusCloudException e ) {}\n    }\n\n    CreateStorageSnapshotType scRequest = new CreateStorageSnapshotType( newId, vol.getDisplayName() );\n    CreateStorageSnapshotResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageSnapshotResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n      snap.setMappedState( scReply.getStatus() );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageSnapshot:\" + e.getMessage() );\n    }\n    db.commit();\n\n    CreateSnapshotResponseType reply = ( CreateSnapshotResponseType ) request.getReply();\n    edu.ucsb.eucalyptus.msgs.Snapshot snapMsg = snap.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n    snapMsg.setProgress( snapMsg.getProgress() );\n    reply.setSnapshot( snapMsg );\n    return reply;\n  }","commit_id":"fbe203fa0a40985672dab2fce7a11db69e2bc015","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DetachVolumeResponseType DetachVolume( DetachVolumeType request ) throws EucalyptusCloudException {\n    DetachVolumeResponseType reply = ( DetachVolumeResponseType ) request.getReply();\n\n    VmInstance vm = null;\n    try {\n      vm = VmInstances.getInstance().lookup( request.getInstanceId() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Instance does not exist: \" + request.getInstanceId() );\n    }\n    Cluster cluster = null;\n    try {\n      cluster = Clusters.getInstance().lookup( vm.getPlacement() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + vm.getPlacement() );\n    }\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator()?null:request.getUserId();\n    try {\n      db.getUnique( new Volume( userName, request.getVolumeId() ) );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId() );\n    }\n    db.commit();\n    AttachedVolume volume = null;\n    for( VmInstance v : VmInstances.getInstance().listValues() ) {\n      for( AttachedVolume vol : v.getVolumes() ) {\n        if( vol.getVolumeId().equals( request.getVolumeId() ) ) {\n          volume = vol;\n        }\n      }\n    }\n    if( volume == null )\n        throw new EucalyptusCloudException( \"Volume is not attached: \"+ request.getVolumeId() );\n\n    request.setRemoteDevice( volume.getRemoteDevice() );\n    QueuedEvent<DetachVolumeType> event = QueuedEvent.make( new VolumeDetachCallback( cluster ), request);\n    cluster.getMessageQueue().enqueue( event );\n\n    reply.setDetachedVolume( volume );\n    return reply;\n  }","id":104363,"modified_method":"public DetachVolumeResponseType DetachVolume( DetachVolumeType request ) throws EucalyptusCloudException {\n    DetachVolumeResponseType reply = ( DetachVolumeResponseType ) request.getReply();\n\n    VmInstance vm = null;\n    try {\n      vm = VmInstances.getInstance().lookup( request.getInstanceId() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Instance does not exist: \" + request.getInstanceId() );\n    }\n    Cluster cluster = null;\n    try {\n      cluster = Clusters.getInstance().lookup( vm.getPlacement() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + vm.getPlacement() );\n    }\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator()?null:request.getUserId();\n    try {\n      db.getUnique( Volume.named( userName, request.getVolumeId() ) );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId() );\n    }\n    db.commit();\n    AttachedVolume volume = null;\n    for( VmInstance v : VmInstances.getInstance().listValues() ) {\n      for( AttachedVolume vol : v.getVolumes() ) {\n        if( vol.getVolumeId().equals( request.getVolumeId() ) ) {\n          volume = vol;\n        }\n      }\n    }\n    if( volume == null )\n        throw new EucalyptusCloudException( \"Volume is not attached: \"+ request.getVolumeId() );\n\n    request.setRemoteDevice( volume.getRemoteDevice() );\n    QueuedEvent<DetachVolumeType> event = QueuedEvent.make( new VolumeDetachCallback( cluster ), request);\n    cluster.getMessageQueue().enqueue( event );\n\n    reply.setDetachedVolume( volume );\n    return reply;\n  }","commit_id":"fbe203fa0a40985672dab2fce7a11db69e2bc015","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public AttachVolumeResponseType AttachVolume( AttachVolumeType request ) throws EucalyptusCloudException {\n    AttachVolumeResponseType reply = ( AttachVolumeResponseType ) request.getReply();\n\n    VmInstance vm = null;\n    try {\n      vm = VmInstances.getInstance().lookup( request.getInstanceId() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Instance does not exist: \" + request.getInstanceId() );\n    }\n    Cluster cluster = null;\n    try {\n      cluster = Clusters.getInstance().lookup( vm.getPlacement() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + vm.getPlacement() );\n    }\n    for( VmInstance v : VmInstances.getInstance().listValues() ) {\n      for( AttachedVolume vol : v.getVolumes() ) {\n        if( vol.getVolumeId().equals( request.getVolumeId() ) ) {\n          throw new EucalyptusCloudException( \"Volume already attached: \" + request.getVolumeId() );\n        }\n      }\n    }\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator()?null:request.getUserId();\n    Volume volume = null;\n    try {\n      db.getUnique( new Volume( userName, request.getVolumeId() ) );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId() );\n    }\n\n    request.setRemoteDevice( volume.getRemoteDevice() );\n    QueuedEvent<AttachVolumeType> event = QueuedEvent.make( new VolumeAttachCallback( cluster ), request);\n    cluster.getMessageQueue().enqueue( event );\n\n    return reply;\n  }","id":104364,"modified_method":"public AttachVolumeResponseType AttachVolume( AttachVolumeType request ) throws EucalyptusCloudException {\n    AttachVolumeResponseType reply = ( AttachVolumeResponseType ) request.getReply();\n\n    VmInstance vm = null;\n    try {\n      vm = VmInstances.getInstance().lookup( request.getInstanceId() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Instance does not exist: \" + request.getInstanceId() );\n    }\n    Cluster cluster = null;\n    try {\n      cluster = Clusters.getInstance().lookup( vm.getPlacement() );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + vm.getPlacement() );\n    }\n    for( VmInstance v : VmInstances.getInstance().listValues() ) {\n      for( AttachedVolume vol : v.getVolumes() ) {\n        if( vol.getVolumeId().equals( request.getVolumeId() ) ) {\n          throw new EucalyptusCloudException( \"Volume already attached: \" + request.getVolumeId() );\n        }\n      }\n    }\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator()?null:request.getUserId();\n    Volume volume = null;\n    try {\n      db.getUnique( Volume.named( userName, request.getVolumeId() ) );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId() );\n    }\n\n    request.setRemoteDevice( volume.getRemoteDevice() );\n    QueuedEvent<AttachVolumeType> event = QueuedEvent.make( new VolumeAttachCallback( cluster ), request);\n    cluster.getMessageQueue().enqueue( event );\n\n    return reply;\n  }","commit_id":"fbe203fa0a40985672dab2fce7a11db69e2bc015","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Thread startNamedThread( Runnable r ) {\n    Thread t = new Thread( r );\n    t.setName( String.format( \"%s-%s@%X\", r.getClass().getSimpleName(), this.getName(), t.hashCode() ) );\n    t.start();\n    return t;\n  }","id":104365,"modified_method":"private Thread startNamedThread( Runnable r ) {\n    Thread t = new Thread( r );\n    t.setName( String.format( \"%s-%s@%X\", r.getClass().getSimpleName(), this.getName(), t.hashCode() ) );\n    t.start();\n    LOG.info( \"Starting threads for [ \" + this.getName() + \" ] \" + t.getName() );\n    return t;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public synchronized void start() {\n    //:: should really be organized as a thread group etc etc :://\n    LOG.info( \"Starting cluster: \" + this.clusterInfo.getUri() );\n    if ( this.mqThread == null || this.mqThread.isAlive() )\n      this.mqThread = this.startNamedThread( messageQueue );\n\n    if ( this.rscThread == null || this.rscThread.isAlive() )\n      this.rscThread = this.startNamedThread( rscUpdater );\n\n    if ( this.vmThread == null || this.vmThread.isAlive() )\n      this.vmThread = this.startNamedThread( vmUpdater );\n\n    if ( this.addrThread == null || this.addrThread.isAlive() )\n      this.addrThread = this.startNamedThread( addrUpdater );\n  }","id":104366,"modified_method":"public synchronized void start() {\n    //:: should really be organized as a thread group etc etc :://\n    LOG.info( \"Starting cluster: \" + this.clusterInfo.getUri() );\n    if ( this.mqThread == null || this.mqThread.isAlive() )\n      this.mqThread = this.startNamedThread( messageQueue );\n\n    if ( this.rscThread == null || this.rscThread.isAlive() )\n      this.rscThread = this.startNamedThread( rscUpdater );\n\n    if ( this.vmThread == null || this.vmThread.isAlive() )\n      this.vmThread = this.startNamedThread( vmUpdater );\n\n    if ( this.addrThread == null || this.addrThread.isAlive() )\n      this.addrThread = this.startNamedThread( addrUpdater );\n    this.fireNodeThreads();\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String mapState( ) {\n    switch(this.getState()) {\n      case GENERATING: return \"pending\";\n      case EXTANT: return \"completed\";\n      case ASSPLODED: return \"failed\";\n      default: return null;\n    }\n  }","id":104367,"modified_method":"public String mapState( ) {\n    switch(this.getState()) {\n      case GENERATING: return \"pending\";\n      case EXTANT: return \"completed\";\n      default: return \"failed\";\n    }\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Snapshot(  ) {\n    super( null, null );\n  }","id":104368,"modified_method":"public Snapshot(  ) {\n    super( );\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateSnapshotResponseType CreateSnapshot( CreateSnapshotType request ) throws EucalyptusCloudException\n  {\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator()?null:request.getUserId();\n    Volume vol = db.recast( Volume.class ).getUnique( new Volume( userName, request.getVolumeId() ) );\n\n    String newId = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( new Snapshot( null, newId ) );\n        break;\n      } catch ( EucalyptusCloudException e ) {}\n    }\n\n    CreateStorageSnapshotType scRequest = new CreateStorageSnapshotType( newId, vol.getDisplayName() );\n    CreateStorageSnapshotResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageSnapshotResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageSnapshot:\" + e.getMessage() );\n    }\n\n    Snapshot snap = new Snapshot( request.getUserId(), newId, vol.getDisplayName() );\n    db.add( snap );\n    db.commit();\n\n    CreateSnapshotResponseType reply = (CreateSnapshotResponseType ) request.getReply();\n    reply.setSnapshot( snap.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() ));\n\n    return reply;\n  }","id":104369,"modified_method":"public CreateSnapshotResponseType CreateSnapshot( CreateSnapshotType request ) throws EucalyptusCloudException {\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    Volume vol = db.recast( Volume.class ).getUnique( Volume.named( userName, request.getVolumeId() ) );\n\n    String newId = null;\n    Snapshot snap = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( new Snapshot( null, newId ) );\n        snap = new Snapshot( request.getUserId(), newId, vol.getDisplayName() );\n        db.add( snap );\n        break;\n      } catch ( EucalyptusCloudException e ) {}\n    }\n\n    CreateStorageSnapshotType scRequest = new CreateStorageSnapshotType( newId, vol.getDisplayName() );\n    CreateStorageSnapshotResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageSnapshotResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n      snap.setMappedState( scReply.getStatus() );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageSnapshot:\" + e.getMessage() );\n    }\n    db.commit();\n\n    CreateSnapshotResponseType reply = ( CreateSnapshotResponseType ) request.getReply();\n    edu.ucsb.eucalyptus.msgs.Snapshot snapMsg = snap.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n    snapMsg.setProgress( snapMsg.getProgress() );\n    reply.setSnapshot( snapMsg );\n    return reply;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteSnapshotResponseType DeleteSnapshot( DeleteSnapshotType request ) throws EucalyptusCloudException\n  {\n    DeleteSnapshotResponseType reply = ( DeleteSnapshotResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Snapshot snap = db.getUnique( new Snapshot( userName, request.getSnapshotId() ) );\n      //:: TODO-1.5: state checks and snapshot tree check here :://\n      Messaging.dispatch( StorageProperties.STORAGE_REF, new DeleteStorageSnapshotType( snap.getDisplayName() ) );\n      db.delete( snap );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error deleting storage volume:\" + e.getMessage() );\n    }\n    reply.set_return( true );\n    return reply;\n  }","id":104370,"modified_method":"public DeleteSnapshotResponseType DeleteSnapshot( DeleteSnapshotType request ) throws EucalyptusCloudException {\n    DeleteSnapshotResponseType reply = ( DeleteSnapshotResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Snapshot> db = SnapshotManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Snapshot snap = db.getUnique( Snapshot.named( userName, request.getSnapshotId() ) );\n      //:: TODO-1.5: state checks and snapshot tree check here :://\n      Messaging.dispatch( StorageProperties.STORAGE_REF, new DeleteStorageSnapshotType( snap.getDisplayName() ) );\n      db.delete( snap );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error deleting storage volume:\" + e.getMessage() );\n    }\n    reply.set_return( true );\n    return reply;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeSnapshotsResponseType DescribeSnapshots( DescribeSnapshotsType request ) throws EucalyptusCloudException\n  {\n    DescribeSnapshotsResponseType reply = ( DescribeSnapshotsResponseType ) request.getReply();\n    EntityWrapper<Snapshot> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    List<Snapshot> Snapshots = db.query( new Snapshot( userName, null ) );\n    for ( Snapshot v : Snapshots ) {\n      if ( request.getSnapshotSet().isEmpty() || request.getSnapshotSet().contains( v.getDisplayName() ) ) {\n        reply.getSnapshotSet().add( v.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() ) );\n      }\n    }\n    db.commit();\n    return reply;\n  }","id":104371,"modified_method":"public DescribeSnapshotsResponseType DescribeSnapshots( DescribeSnapshotsType request ) throws EucalyptusCloudException {\n    DescribeSnapshotsResponseType reply = ( DescribeSnapshotsResponseType ) request.getReply();\n    EntityWrapper<Snapshot> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    List<Snapshot> Snapshots = db.query( Snapshot.ownedBy( userName ) );\n    for ( Snapshot v : Snapshots ) {\n      if ( request.getSnapshotSet().isEmpty() || request.getSnapshotSet().contains( v.getDisplayName() ) ) {\n        reply.getSnapshotSet().add( v.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() ) );\n      }\n    }\n    db.commit();\n    return reply;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String mapState( ) {\n    switch(this.getState()) {\n      case GENERATING: return \"creating\";\n      case EXTANT: return \"available\";\n      case ANNIHILATING: return \"deleting\";\n      case ANNILATED: return \"deleted\";\n      case ASSPLODED: return \"failed\";      \n      default: return null;\n    }\n  }","id":104372,"modified_method":"public String mapState( ) {\n    switch(this.getState()) {\n      case GENERATING: return \"creating\";\n      case EXTANT: return \"available\";\n      case ANNIHILATING: return \"deleting\";\n      case ANNILATED: return \"deleted\";\n      case FAIL: return \"failed\";\n      default: return \"unavailable\";\n    }\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public edu.ucsb.eucalyptus.msgs.Volume morph( final edu.ucsb.eucalyptus.msgs.Volume vol ) {\n    vol.setAvailabilityZone( this.getCluster() );\n    vol.setCreateTime( this.getBirthday() );\n    vol.setVolumeId( this.getDisplayName() );\n    vol.setSnapshotId( this.getParentSnapshot() );\n    vol.setStatus( this.mapState() );\n    vol.setSize( this.getState().toString() );\n    return vol;\n  }","id":104373,"modified_method":"public edu.ucsb.eucalyptus.msgs.Volume morph( final edu.ucsb.eucalyptus.msgs.Volume vol ) {\n    vol.setAvailabilityZone( this.getCluster() );\n    vol.setCreateTime( this.getBirthday() );\n    vol.setVolumeId( this.getDisplayName() );\n    vol.setSnapshotId( this.getParentSnapshot() );\n    vol.setStatus( this.mapState() );\n    vol.setSize( this.getSize().toString() );\n    return vol;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Volume() {\n    super( null, null );\n  }","id":104374,"modified_method":"public Volume() {\n    super( );\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateVolumeResponseType CreateVolume( CreateVolumeType request ) throws EucalyptusCloudException {\n    if ( !Clusters.getInstance().contains( request.getAvailabilityZone() ) ) {\n      throw new EucalyptusCloudException( \"Zone does not exist: \" + request.getAvailabilityZone() );\n    }\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    if ( !(request.getSnapshotId() == null )) {\n      String userName = request.isAdministrator()?null:request.getUserId();\n      try {\n        db.recast( Snapshot.class ).getUnique( new Snapshot( userName, request.getSnapshotId() ) );\n      } catch ( EucalyptusCloudException e ) {\n        LOG.debug( e, e );\n        db.rollback();\n        throw new EucalyptusCloudException( \"Snapshot does not exist: \" + request.getSnapshotId() );\n      }\n    }\n    String newId = null;\n    Volume newVol = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( new Volume( null, newId ) );\n      } catch ( EucalyptusCloudException e ) {\n        newVol = new Volume( request.getUserId(), newId, new Integer( request.getSize() ),\n                             request.getAvailabilityZone(), request.getSnapshotId() );\n        db.add( newVol );\n        break;\n      }\n    }\n    CreateStorageVolumeType scRequest = new CreateStorageVolumeType( newId, request.getSize(), request.getSnapshotId() );\n    CreateStorageVolumeResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageVolumeResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageVolume:\" + e.getMessage() );\n    }\n    db.commit();\n    CreateVolumeResponseType reply = ( CreateVolumeResponseType ) request.getReply();\n    reply.setVolume( newVol.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n    return reply;\n  }","id":104375,"modified_method":"public CreateVolumeResponseType CreateVolume( CreateVolumeType request ) throws EucalyptusCloudException {\n    if ( !Clusters.getInstance().contains( request.getAvailabilityZone() ) ) {\n      throw new EucalyptusCloudException( \"Zone does not exist: \" + request.getAvailabilityZone() );\n    }\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    if ( !(request.getSnapshotId() == null )) {\n      String userName = request.isAdministrator()?null:request.getUserId();\n      try {\n        db.recast( Snapshot.class ).getUnique( new Snapshot( userName, request.getSnapshotId() ) );\n      } catch ( EucalyptusCloudException e ) {\n        LOG.debug( e, e );\n        db.rollback();\n        throw new EucalyptusCloudException( \"Snapshot does not exist: \" + request.getSnapshotId() );\n      }\n    }\n    String newId = null;\n    Volume newVol = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( new Volume( null, newId ) );\n      } catch ( EucalyptusCloudException e ) {\n        newVol = new Volume( request.getUserId(), newId, new Integer( request.getSize() ),\n                             request.getAvailabilityZone(), request.getSnapshotId() );\n        db.add( newVol );\n        break;\n      }\n    }\n    newVol.setState( State.GENERATING );\n    CreateStorageVolumeType scRequest = new CreateStorageVolumeType( newId, request.getSize(), request.getSnapshotId() );\n    CreateStorageVolumeResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageVolumeResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageVolume:\" + e.getMessage() );\n    }\n    db.commit();\n    CreateVolumeResponseType reply = ( CreateVolumeResponseType ) request.getReply();\n    reply.setVolume( newVol.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n    return reply;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteVolumeResponseType DeleteVolume( DeleteVolumeType request ) throws EucalyptusCloudException {\n    DeleteVolumeResponseType reply = ( DeleteVolumeResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Volume vol = db.getUnique( new Volume( userName, request.getVolumeId() ) );\n      //:: TODO-1.5: state checks and snapshot tree check here :://\n      Messaging.dispatch( StorageProperties.STORAGE_REF, new DeleteStorageVolumeType( vol.getDisplayName() ) );\n      db.delete( vol );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error deleting storage volume:\" + e.getMessage() );\n    }\n    reply.set_return( true );\n    return reply;\n  }","id":104376,"modified_method":"public DeleteVolumeResponseType DeleteVolume( DeleteVolumeType request ) throws EucalyptusCloudException {\n    DeleteVolumeResponseType reply = ( DeleteVolumeResponseType ) request.getReply();\n    reply.set_return( false );\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    try {\n      Volume vol = db.getUnique( Volume.named( userName, request.getVolumeId() ) );\n      //:: TODO-1.5: state checks and snapshot tree check here :://\n      Messaging.dispatch( StorageProperties.STORAGE_REF, new DeleteStorageVolumeType( vol.getDisplayName() ) );\n      db.delete( vol );\n      db.commit();\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      return reply;\n    }\n    reply.set_return( true );\n    return reply;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeVolumesResponseType DescribeVolumes( DescribeVolumesType request ) throws EucalyptusCloudException {\n    DescribeVolumesResponseType reply = ( DescribeVolumesResponseType ) request.getReply();\n    EntityWrapper<Volume> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    List<Volume> volumes = db.query( new Volume( userName, null ) );\n    for ( Volume v : volumes ) {\n      if ( request.getVolumeSet().isEmpty() || request.getVolumeSet().contains( v.getDisplayName() ) ) {\n        reply.getVolumeSet().add( v.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n      }\n    }\n    db.commit();\n    return reply;\n  }","id":104377,"modified_method":"public DescribeVolumesResponseType DescribeVolumes( DescribeVolumesType request ) throws EucalyptusCloudException {\n    DescribeVolumesResponseType reply = ( DescribeVolumesResponseType ) request.getReply();\n    EntityWrapper<Volume> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    LOG.debug( request );\n    List<Volume> volumes = db.query( Volume.ownedBy( userName ) );\n    for ( Volume v : volumes ) {\n      if ( request.getVolumeSet().isEmpty() || request.getVolumeSet().contains( v.getDisplayName() ) ) {\n        DescribeStorageVolumesResponseType volState = (DescribeStorageVolumesResponseType)Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageVolumesType( Lists.newArrayList( v.getDisplayName() ) ) );\n        String volumeState = \"unavailable\";\n        if( !volState.getVolumeSet().isEmpty() ) {\n          StorageVolume vol = volState.getVolumeSet().get( 0 );\n          volumeState = vol.getStatus();\n        }\n        v.setMappedState( volumeState );\n        reply.getVolumeSet().add( v.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n      }\n    }\n    db.commit();\n    return reply;\n  }","commit_id":"2dd48f927567f3682d036e6fce3d83513ab6ddd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n     * @param comment the comment to use when/if saving the document\n     * @param previousDocument the previous version of the document\n     * @param currentDocument the current version of the document\n     * @param nextDocument the new version of the document\n     * @param configuration various setup for the import\n     * @return the result of the merge\n     * @throws Exception when failed to save the document\n     */\n    public XarEntryMergeResult saveDocument(String comment, XWikiDocument previousDocument,\n        XWikiDocument currentDocument, XWikiDocument nextDocument, PackageConfiguration configuration) throws Exception\n    {\n        XarEntryMergeResult mergeResult = null;\n\n        // Merge and save\n        if (currentDocument != null && !currentDocument.isNew()) {\n            if (previousDocument != null) {\n                // 3 ways merge\n                mergeResult = merge(comment, currentDocument, previousDocument, nextDocument, configuration);\n            } else {\n                // Check if a mandatory document initializer exists for the current document\n                XWikiDocument mandatoryDocument = getMandatoryDocument(nextDocument.getDocumentReference());\n\n                if (mandatoryDocument != null) {\n                    // 3 ways merge\n                    mergeResult = merge(comment, currentDocument, mandatoryDocument, nextDocument, configuration);\n                } else {\n                    // Already existing document in database but without previous version\n                    if (!currentDocument.equalsData(nextDocument)) {\n                        XWikiDocument documentToSave;\n                        if (configuration.isInteractive()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = configuration.getUserReference();\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n                            for (XWikiAttachment attachment : nextDocument.getAttachmentList()) {\n                                attachment.setAuthor(nextDocument.getAuthor());\n                            }\n\n                            documentToSave =\n                                askDocumentToSave(currentDocument, previousDocument, nextDocument, null, configuration);\n                        } else {\n                            documentToSave = nextDocument;\n                        }\n\n                        if (documentToSave != currentDocument) {\n                            saveDocument(documentToSave, comment, false, configuration);\n                        }\n                    }\n                }\n            }\n        } else if (previousDocument == null) {\n            saveDocument(nextDocument, comment, true, configuration);\n        }\n\n        return mergeResult;\n    }","id":104378,"modified_method":"/**\n     * @param comment the comment to use when/if saving the document\n     * @param previousDocument the previous version of the document\n     * @param currentDocument the current version of the document\n     * @param nextDocument the new version of the document\n     * @param configuration various setup for the import\n     * @return the result of the merge\n     * @throws Exception when failed to save the document\n     */\n    public XarEntryMergeResult saveDocument(String comment, XWikiDocument previousDocument,\n        XWikiDocument currentDocument, XWikiDocument nextDocument, PackageConfiguration configuration) throws Exception\n    {\n        XarEntryMergeResult mergeResult = null;\n\n        // Merge and save\n        if (currentDocument != null && !currentDocument.isNew()) {\n            if (previousDocument != null) {\n                // 3 ways merge\n                mergeResult = merge(comment, currentDocument, previousDocument, nextDocument, configuration);\n            } else {\n                // Check if a mandatory document initializer exists for the current document\n                XWikiDocument mandatoryDocument = getMandatoryDocument(nextDocument.getDocumentReference());\n\n                if (mandatoryDocument != null) {\n                    // 3 ways merge\n                    mergeResult = merge(comment, currentDocument, mandatoryDocument, nextDocument, configuration);\n                } else {\n                    // Already existing document in database but without previous version\n                    if (!currentDocument.equalsData(nextDocument)) {\n                        XWikiDocument documentToSave;\n                        if (configuration.isInteractive()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = configuration.getUserReference();\n                            if (userReference != null) {\n                                nextDocument.setAuthorReference(userReference);\n                                nextDocument.setContentAuthorReference(userReference);\n                                for (XWikiAttachment attachment : nextDocument.getAttachmentList()) {\n                                    attachment.setAuthor(nextDocument.getAuthor());\n                                }\n                            }\n\n                            documentToSave =\n                                askDocumentToSave(currentDocument, previousDocument, nextDocument, null, configuration);\n                        } else {\n                            documentToSave = nextDocument;\n                        }\n\n                        if (documentToSave != currentDocument) {\n                            saveDocument(documentToSave, comment, false, configuration);\n                        }\n                    }\n                }\n            }\n        } else if (previousDocument == null) {\n            saveDocument(nextDocument, comment, true, configuration);\n        }\n\n        return mergeResult;\n    }","commit_id":"89599eccc3938bc8b897ec944883430396e30dea","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\r\n            if (controller.searchLibrary(target, game)) {\r\n                if (target.getTargets().size() > 0) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    Cards revealed = new CardsImpl();\r\n                    revealed.add(card);\r\n                    controller.revealCards(\"Renowned Weaponsmith\", revealed, game);\r\n                    controller.moveCardToHandWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\r\n                    controller.shuffleLibrary(game);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":104379,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (sourceObject != null && controller != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\r\n            if (controller.searchLibrary(target, game)) {\r\n                if (target.getTargets().size() > 0) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    Cards revealed = new CardsImpl();\r\n                    revealed.add(card);\r\n                    controller.revealCards(sourceObject.getLogName(), revealed, game);\r\n                    controller.moveCardToHandWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);                    \r\n                }\r\n            }\r\n            controller.shuffleLibrary(game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"5b04f40a66d90f1b9d08f70da1fffe85aaad6e5b","url":"https://github.com/magefree/mage"},{"original_method":"private void setText() {\n        StringBuilder sb = new StringBuilder();\n        if (excludeSource) {\n            sb.append(\"Other \");\n        }\n        sb.append(filter.getMessage());\n        if (duration.equals(Duration.WhileOnBattlefield)) {\n            if (filter.getMessage().toLowerCase().startsWith(\"each\")) {\n                sb.append(\" has \");\n            } else {\n                sb.append(\" have \");\n            }\n        } else {\n            if (filter.getMessage().toLowerCase().startsWith(\"each\")) {\n                sb.append(\" gains \");\n            } else {\n                sb.append(\" gain \");\n            }            \n        }\n        sb.append(ability.getRule());\n        if (duration.toString().length() > 0) {\n            sb.append(\" \").append(duration.toString());\n        }\n        staticText = sb.toString();\n    }","id":104380,"modified_method":"private void setText() {\n        StringBuilder sb = new StringBuilder();\n        boolean quotes = (ability instanceof SimpleActivatedAbility) || (ability instanceof TriggeredAbility);\n        if (excludeSource) {\n            sb.append(\"Other \");\n        }\n        sb.append(filter.getMessage());\n        if (duration.equals(Duration.WhileOnBattlefield)) {\n            if (filter.getMessage().toLowerCase().startsWith(\"each\")) {\n                sb.append(\" has \");\n            } else {\n                sb.append(\" have \");\n            }\n        } else {\n            if (filter.getMessage().toLowerCase().startsWith(\"each\")) {\n                sb.append(\" gains \");\n            } else {\n                sb.append(\" gain \");\n            }            \n        }\n        if (quotes) {\n            sb.append(\"\\\"\");\n        }\n        sb.append(ability.getRule());\n        if (quotes) {\n            sb.append(\"\\\"\");\n        }\n        if (duration.toString().length() > 0) {\n            sb.append(\" \").append(duration.toString());\n        }\n        staticText = sb.toString();\n    }","commit_id":"943ff0d78df0b5e01fa5bdeb0ab82647bfdd3daa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Object call() {\n        try {\n            game.start(choosingPlayerId);\n            game.fireUpdatePlayersEvent();\n            result.gameResult(game.getWinner());\n            game.cleanUp();\n        } catch (MageException ex) {\n            logger.fatal(\"GameWorker mage error [\" + game.getId() + \"]\", ex);\n        } catch (Exception e) {\n            logger.fatal(\"GameWorker general exception [\" + game.getId() + \"]\", e);\n        } catch (Error err) {\n            logger.fatal(\"GameWorker general error [\" + game.getId() + \"]\", err);\n        }\n        return null;\n    }","id":104381,"modified_method":"@Override\n    public Object call() {\n        try {\n            game.start(choosingPlayerId);\n            game.fireUpdatePlayersEvent();\n            result.gameResult(game.getWinner());\n            game.cleanUp();\n        } catch (MageException ex) {\n            logger.fatal(\"GameWorker mage error [\" + game.getId() + \"]\" +ex, ex);\n        } catch (Exception e) {\n            logger.fatal(\"GameWorker general exception [\" + game.getId() + \"]\" + e, e);\n        } catch (Error err) {\n            logger.fatal(\"GameWorker general error [\" + game.getId() + \"]\" +err, err);\n        }\n        return null;\n    }","commit_id":"943ff0d78df0b5e01fa5bdeb0ab82647bfdd3daa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        FilterCard filter = new FilterCard(\"card in your hand to exile\");\r\n        FilterCard filter2 = new FilterCard(\"card exiled by Scroll Rack to put on top of library\");\r\n        Player you = game.getPlayer(source.getControllerId());\r\n\r\n        if (you != null) {\r\n            TargetCardInHand target = new TargetCardInHand(0, you.getHand().size(), filter);\r\n            target.setRequired(false);\r\n            int amountExiled = 0;\r\n            if (target.canChoose(source.getControllerId(), game) && target.choose(Outcome.Neutral, source.getControllerId(), source.getId(), game)) {\r\n                if (!target.getTargets().isEmpty()) {\r\n                    List<UUID> targets = target.getTargets();\r\n                    for (UUID targetId : targets) {\r\n                        Card card = game.getCard(targetId);\r\n                        if (card != null) {\r\n                            card.setFaceDown(true);\r\n                            if (card.moveToExile(source.getSourceId(), \"Scroll Rack Exile\", source.getId(), game)) {\r\n                                amountExiled++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (amountExiled > 0) {\r\n                int count = Math.min(you.getLibrary().size(), amountExiled);\r\n                for (int i = 0; i < count; i++) {\r\n                    Card card = you.getLibrary().removeFromTop(game);\r\n                    if (card != null) {\r\n                        card.moveToZone(Zone.HAND, id, game, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            TargetCardInExile target2 = new TargetCardInExile(filter2, source.getSourceId());\r\n            ExileZone scrollRackExileZone = game.getExile().getExileZone(source.getSourceId());\r\n            if (scrollRackExileZone != null) {\r\n                while (you.isInGame() && scrollRackExileZone.count(filter, game) > 1) {\r\n                    you.lookAtCards(\"exiled cards with \" + game.getCard(source.getSourceId()).getName(), scrollRackExileZone, game);\r\n                    you.choose(Outcome.Neutral, scrollRackExileZone, target2, game);\r\n                    Card card = game.getCard(target2.getFirstTarget());\r\n                    if (card != null) {\r\n                        game.getExile().removeCard(card, game);\r\n                        card.moveToZone(Zone.LIBRARY, source.getId(), game, true);\r\n                    }\r\n                    target2.clearChosen();\r\n                }\r\n                if (scrollRackExileZone.count(filter, game) == 1) {\r\n                    Card card = scrollRackExileZone.get(scrollRackExileZone.iterator().next(), game);\r\n                    card.moveToZone(Zone.LIBRARY, source.getId(), game, true);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":104382,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller != null && sourceObject != null) {\r\n            FilterCard filter = new FilterCard(\"card in your hand to exile\");\r\n            FilterCard filter2 = new FilterCard(\"(move the window) card exiled by \" + sourceObject.getLogName() + \" to put on top of library\");\r\n            TargetCardInHand target = new TargetCardInHand(0, controller.getHand().size(), filter);\r\n            target.setRequired(false);\r\n            int amountExiled = 0;\r\n            if (target.canChoose(source.getControllerId(), game) && target.choose(Outcome.Neutral, source.getControllerId(), source.getSourceId(), game)) {\r\n                if (!target.getTargets().isEmpty()) {\r\n                    List<UUID> targets = target.getTargets();\r\n                    for (UUID targetId : targets) {\r\n                        Card card = game.getCard(targetId);\r\n                        if (card != null) {\r\n                            card.setFaceDown(true);\r\n                            if (card.moveToExile(source.getSourceId(), sourceObject.getLogName(), source.getSourceId(), game)) {\r\n                                amountExiled++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            game.informPlayers(controller.getName() + \" exiles \" + amountExiled + \" card\" + (amountExiled == 1 ? \" \":\"s \") + \"face down from his or her hand\");\r\n            if (amountExiled > 0) {\r\n                int count = Math.min(controller.getLibrary().size(), amountExiled);\r\n                for (int i = 0; i < count; i++) {\r\n                    Card card = controller.getLibrary().removeFromTop(game);\r\n                    if (card != null) {\r\n                        card.moveToZone(Zone.HAND, source.getSourceId(), game, false);\r\n                    }\r\n                }\r\n            }\r\n            game.informPlayers(controller.getName() + \" moves \" + amountExiled + \" card\" + (amountExiled == 1 ? \" \":\"s \") + \"from library to hand\");\r\n\r\n            TargetCardInExile target2 = new TargetCardInExile(filter2, source.getSourceId());\r\n            ExileZone scrollRackExileZone = game.getExile().getExileZone(source.getSourceId());\r\n            if (scrollRackExileZone != null) {\r\n                while (controller.isInGame() && scrollRackExileZone.count(filter, game) > 1) {\r\n                    controller.lookAtCards(\"exiled cards with \" + sourceObject.getLogName(), scrollRackExileZone, game);\r\n                    controller.choose(Outcome.Neutral, scrollRackExileZone, target2, game);\r\n                    Card card = game.getCard(target2.getFirstTarget());\r\n                    if (card != null) {\r\n                        game.getExile().removeCard(card, game);\r\n                        controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.EXILED, true, false);\r\n                    }\r\n                    target2.clearChosen();\r\n                }\r\n                if (scrollRackExileZone.count(filter, game) == 1) {\r\n                    Card card = scrollRackExileZone.get(scrollRackExileZone.iterator().next(), game);\r\n                    controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.EXILED, true, false);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"943ff0d78df0b5e01fa5bdeb0ab82647bfdd3daa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player == null)\n            return false;\n        if (player.searchLibrary(target, game)) {\n            List<Card> cards = new ArrayList<Card>();\n            for (UUID cardId: (List<UUID>)target.getTargets()) {\n                Card card = player.getLibrary().remove(cardId, game);\n                if (card != null)\n                    cards.add(card);\n            }\n            Cards foundCards = new CardsImpl();\n            foundCards.addAll(cards);\n            if (reveal) {\n                player.revealCards(\"Revealed\", foundCards, game);\n            }\n            if (forceShuffle) {\n                player.shuffleLibrary(game);\n            }\n            for (Card card: cards) {\n                card.moveToZone(Zone.LIBRARY, source.getId(), game, true);\n            }\n            return true;\n        }\n        // shuffle\n        if (forceShuffle)\n            player.shuffleLibrary(game);\n        return false;\n    }","id":104383,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller == null || sourceObject == null) {\n            return false;\n        }\n        if (controller.searchLibrary(target, game)) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID cardId: (List<UUID>)target.getTargets()) {\n                Card card = controller.getLibrary().remove(cardId, game);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            Cards foundCards = new CardsImpl();\n            foundCards.addAll(cards);\n            if (reveal) {\n                controller.revealCards(sourceObject.getLogName(), foundCards, game);\n            }\n            if (forceShuffle) {\n                controller.shuffleLibrary(game);\n            }\n            if (cards.size() > 0) {\n                game.informPlayers(controller.getName() + \" moves \" + cards.size() + \" card\" + (cards.size() == 1 ? \" \":\"s \") + \"on top of his or her library\");\n            }\n            for (Card card: cards) {                \n                card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\n            }\n            return true;\n        }\n        // shuffle\n        if (forceShuffle) {\n            controller.shuffleLibrary(game);\n        }\n        return false;\n    }","commit_id":"943ff0d78df0b5e01fa5bdeb0ab82647bfdd3daa","url":"https://github.com/magefree/mage"},{"original_method":"public TheTabernacleAtPendrellVale(UUID ownerId) {\r\n        super(ownerId, 252, \"The Tabernacle at Pendrell Vale\", Rarity.RARE, new CardType[]{CardType.LAND}, \"\");\r\n        this.expansionSetCode = \"LEG\";\r\n        this.supertype.add(\"Legendary\");\r\n\r\n        // All creatures have \"At the beginning of your upkeep, destroy this creature unless you pay {1}.\"\r\n        Ability ability = new BeginningOfUpkeepTriggeredAbility(new DestroySourceUnlessPaysEffect(new ManaCostsImpl(\"{1}\")), TargetController.YOU, false);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(ability, Duration.WhileOnBattlefield, new FilterCreaturePermanent())));\r\n    }","id":104384,"modified_method":"public TheTabernacleAtPendrellVale(UUID ownerId) {\r\n        super(ownerId, 252, \"The Tabernacle at Pendrell Vale\", Rarity.RARE, new CardType[]{CardType.LAND}, \"\");\r\n        this.expansionSetCode = \"LEG\";\r\n        this.supertype.add(\"Legendary\");\r\n\r\n        // All creatures have \"At the beginning of your upkeep, destroy this creature unless you pay {1}.\"\r\n        Ability ability = new BeginningOfUpkeepTriggeredAbility(new DestroySourceUnlessPaysEffect(new ManaCostsImpl(\"{1}\")), TargetController.YOU, false);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(ability, Duration.WhileOnBattlefield, new FilterCreaturePermanent(\"Creatures\"))));\r\n    }","commit_id":"943ff0d78df0b5e01fa5bdeb0ab82647bfdd3daa","url":"https://github.com/magefree/mage"},{"original_method":"public void checkTriggers(GameEvent event, Game game) {\n        for (TriggeredAbility ability: this.values()) {\n            // for effects like when leaves battlefield use ShortLKI to check if permanent was in the correct zone before (e.g. Oblivion Ring)\n            if (ability.isInUseableZone(game, null, event.getType().equals(GameEvent.EventType.ZONE_CHANGE) ? true :false)) {\n                MageObject object = null;\n                if (!ability.getZone().equals(Zone.COMMAND) && !game.getState().getZone(ability.getSourceId()).equals(ability.getZone())) {\n                    object = game.getShortLivingLKI(ability.getSourceId(), ability.getZone());\n                }\n                if (object == null) {\n                    object = getMageObject(event, game, ability);\n                }\n                if (object != null) {\n                    if (checkAbilityStillExists(ability, event, object)) {\n                        if (object instanceof Permanent) {\n                            ability.setControllerId(((Permanent) object).getControllerId());\n                        }\n                        ability.setSourceObject(object);\n                        if (ability.checkTrigger(event, game)) {\n                            UUID controllerId = ability.getControllerId();\n                            ability.trigger(game, controllerId);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":104385,"modified_method":"public void checkTriggers(GameEvent event, Game game) {\n        for (TriggeredAbility ability: this.values()) {\n            // for effects like when leaves battlefield use ShortLKI to check if permanent was in the correct zone before (e.g. Oblivion Ring)\n            if (ability.isInUseableZone(game, null, event.getType().equals(GameEvent.EventType.ZONE_CHANGE))) {\n                MageObject object = null;\n                if (!ability.getZone().equals(Zone.COMMAND) && !game.getState().getZone(ability.getSourceId()).equals(ability.getZone())) {\n                    object = game.getShortLivingLKI(ability.getSourceId(), ability.getZone());\n                }\n                if (object == null) {\n                    object = getMageObject(event, game, ability);\n                }\n                if (object != null) {\n                    if (checkAbilityStillExists(ability, event, object)) {\n                        if (object instanceof Permanent) {\n                            ability.setControllerId(((Permanent) object).getControllerId());\n                        }\n                        ability.setSourceObject(object);\n                        if (ability.checkTrigger(event, game)) {\n                            UUID controllerId = ability.getControllerId();\n                            ability.trigger(game, controllerId);\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"943ff0d78df0b5e01fa5bdeb0ab82647bfdd3daa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player == null) {\n            return false;\n        }\n        int xCost = source.getManaCostsToPay().getX();\n        FilterCard filter = new FilterCard(new StringBuilder(\"creature card with converted mana cost \").append(xCost).append(\" or less\").toString());\n        filter.add(new CardTypePredicate(CardType.CREATURE));\n        //Set the mana cost one higher to 'emulate' a less than or equal to comparison.\n        filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, xCost + 1));\n        TargetCardInLibrary target = new TargetCardInLibrary(filter);\n        if (player.searchLibrary(target, game)) {\n            if (target.getTargets().size() > 0) {\n                Card card = player.getLibrary().getCard(target.getFirstTarget(), game);\n                if (card != null) {\n                    card.putOntoBattlefield(game, Constants.Zone.LIBRARY, source.getId(), source.getControllerId());\n                }\n            }\n            player.shuffleLibrary(game);\n            return true;\n        }\n        player.shuffleLibrary(game);\n        return false;\n    }","id":104386,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        Card sourceCard = game.getCard(source.getSourceId());\n        if (player == null || sourceCard == null) {\n            return false;\n        }\n        int xCost = source.getManaCostsToPay().getX();\n        FilterCard filter = new FilterCard(new StringBuilder(\"creature card with converted mana cost \").append(xCost).append(\" or less\").toString());\n        filter.add(new CardTypePredicate(CardType.CREATURE));\n        //Set the mana cost one higher to 'emulate' a less than or equal to comparison.\n        filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, xCost + 1));\n        TargetCardInLibrary target = new TargetCardInLibrary(filter);\n        if (player.searchLibrary(target, game)) {\n            if (target.getTargets().size() > 0) {\n                Card card = player.getLibrary().getCard(target.getFirstTarget(), game);\n                if (card != null) {\n                    game.informPlayers(new StringBuilder(sourceCard.getName()).append(\": Put \").append(card.getName()).append(\" onto the battlefield\").toString());\n                    card.putOntoBattlefield(game, Constants.Zone.LIBRARY, source.getSourceId(), source.getControllerId());\n                }\n            }\n            player.shuffleLibrary(game);\n            return true;\n        }\n        player.shuffleLibrary(game);\n        return false;\n    }","commit_id":"cb16edcbbd1a680442af33042e9a522d1f468cb0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Card card = game.getCard(targetPointer.getFirst(game, source));\r\n        if (card != null) {\r\n            Integer zoneChanges = (Integer) getValue(\"zoneChanges\");\r\n            if (card.getZoneChangeCounter() == zoneChanges) {\r\n                Zone currentZone = game.getState().getZone(card.getId());\r\n                if (card.putOntoBattlefield(game, currentZone, source.getId(), source.getControllerId())) {\r\n                    Permanent creature = game.getPermanent(card.getId());\r\n                    creature.addCounters(CounterType.P1P1.createInstance(), game);\r\n                    ContinuousEffectImpl effect = new GraveBetrayalContiniousEffect();\r\n                    effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n                    game.addEffect(effect, source);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":104387,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Card card = game.getCard(targetPointer.getFirst(game, source));\r\n        if (card != null) {\r\n            Integer zoneChanges = (Integer) getValue(\"zoneChanges\");\r\n            if (card.getZoneChangeCounter() == zoneChanges) {\r\n                Zone currentZone = game.getState().getZone(card.getId());\r\n                if (card.putOntoBattlefield(game, currentZone, source.getSourceId(), source.getControllerId())) {\r\n                    Permanent creature = game.getPermanent(card.getId());\r\n                    creature.addCounters(CounterType.P1P1.createInstance(), game);\r\n                    ContinuousEffect effect = new GraveBetrayalContiniousEffect();\r\n                    effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n                    game.addEffect(effect, source);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"cb16edcbbd1a680442af33042e9a522d1f468cb0","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Returns the data for the given container page.<p>\n     * \n     * @param resource the container page's resource \n     * @param cntPage the container page to use\n     * \n     * @return the data for the given container page\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    protected JSONObject getContainerPage(CmsResource resource, CmsContainerPageBean cntPage)\n    throws CmsException, JSONException {\n\n        CmsObject cms = getCmsObject();\n\n        // create empty result object\n        JSONObject result = new JSONObject();\n        JSONObject resElements = new JSONObject();\n        JSONObject resContainers = new JSONObject();\n        result.put(P_ELEMENTS, resElements);\n        result.put(P_CONTAINERS, resContainers);\n        result.put(P_LOCALE, cms.getRequestContext().getLocale().toString());\n\n        // get the container page itself\n        CmsResourceUtil resUtil = new CmsResourceUtil(cms, resource);\n        Set<String> types = cntPage.getTypes();\n\n        // collect some basic data\n        result.put(CmsADEServer.P_ALLOWEDIT, resUtil.getLock().isLockableBy(cms.getRequestContext().currentUser())\n            && resUtil.isEditable());\n        result.put(CmsADEServer.P_LOCKED, resUtil.getLockedByName());\n\n        // collect new elements\n        resElements.merge(getNewElements(cntPage.getNewConfig(), types), false, false);\n\n        // collect page elements\n        CmsElementUtil elemUtil = new CmsElementUtil(cms, getRequest(), getResponse());\n        Set<CmsUUID> ids = new HashSet<CmsUUID>();\n        for (Map.Entry<String, CmsContainerBean> entry : cntPage.getContainers().entrySet()) {\n            CmsContainerBean container = entry.getValue();\n\n            // set the container data\n            JSONObject resContainer = new JSONObject();\n            resContainer.put(P_NAME, container.getName());\n            resContainer.put(P_TYPE, container.getType());\n            resContainer.put(P_MAXELEMENTS, container.getMaxElements());\n            JSONArray resContainerElems = new JSONArray();\n            resContainer.put(P_ELEMENTS, resContainerElems);\n\n            // get the actual number of elements to render\n            int renderElems = container.getElements().size();\n            if ((container.getMaxElements() > -1) && (renderElems > container.getMaxElements())) {\n                renderElems = container.getMaxElements();\n            }\n            // iterate the elements\n            for (CmsContainerElementBean element : container.getElements()) {\n                if (renderElems < 1) {\n                    // just collect as many elements as allowed in the template\n                    break;\n                }\n                renderElems--;\n\n                // check if the element already exists\n                String id = CmsElementUtil.createId(element.getElement().getStructureId());\n                // collect ids\n                resContainerElems.put(id);\n                if (ids.contains(element.getElement().getStructureId())) {\n                    continue;\n                }\n                // get the element data\n                JSONObject resElement = elemUtil.getElementData(element.getElement(), types);\n                // store element data\n                ids.add(element.getElement().getStructureId());\n                resElements.put(id, resElement);\n            }\n\n            resContainers.put(container.getName(), resContainer);\n        }\n        // collect the favorites\n        JSONArray resFavorites = getFavoriteList(resElements, types);\n        result.put(P_FAVORITES, resFavorites);\n        // collect the recent list\n        JSONArray resRecent = CmsRecentListManager.getInstance().getRecentList(\n            cms,\n            resElements,\n            types,\n            getRequest(),\n            getResponse());\n        result.put(P_RECENT, resRecent);\n\n        return result;\n    }","id":104388,"modified_method":"/**\n     * Returns the data for the given container page.<p>\n     * \n     * @param resource the container page's resource \n     * @param cntPage the container page to use\n     * \n     * @return the data for the given container page\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    protected JSONObject getContainerPage(CmsResource resource, CmsContainerPageBean cntPage)\n    throws CmsException, JSONException {\n\n        CmsObject cms = getCmsObject();\n\n        // create empty result object\n        JSONObject result = new JSONObject();\n        JSONObject resElements = new JSONObject();\n        JSONObject resContainers = new JSONObject();\n        result.put(P_ELEMENTS, resElements);\n        result.put(P_CONTAINERS, resContainers);\n        result.put(P_LOCALE, cms.getRequestContext().getLocale().toString());\n\n        // get the container page itself\n        CmsResourceUtil resUtil = new CmsResourceUtil(cms, resource);\n        Set<String> types = cntPage.getTypes();\n\n        // collect some basic data\n        result.put(CmsADEServer.P_ALLOWEDIT, resUtil.getLock().isLockableBy(cms.getRequestContext().currentUser())\n            && resUtil.isEditable());\n        result.put(CmsADEServer.P_LOCKED, resUtil.getLockedByName());\n\n        // collect new elements\n        resElements.merge(getNewElements(cntPage.getNewConfig(), types), true, false);\n\n        // collect page elements\n        CmsElementUtil elemUtil = new CmsElementUtil(cms, getRequest(), getResponse());\n        Set<CmsUUID> ids = new HashSet<CmsUUID>();\n        for (Map.Entry<String, CmsContainerBean> entry : cntPage.getContainers().entrySet()) {\n            CmsContainerBean container = entry.getValue();\n\n            // set the container data\n            JSONObject resContainer = new JSONObject();\n            resContainer.put(P_NAME, container.getName());\n            resContainer.put(P_TYPE, container.getType());\n            resContainer.put(P_MAXELEMENTS, container.getMaxElements());\n            JSONArray resContainerElems = new JSONArray();\n            resContainer.put(P_ELEMENTS, resContainerElems);\n\n            // get the actual number of elements to render\n            int renderElems = container.getElements().size();\n            if ((container.getMaxElements() > -1) && (renderElems > container.getMaxElements())) {\n                renderElems = container.getMaxElements();\n            }\n            // iterate the elements\n            for (CmsContainerElementBean element : container.getElements()) {\n                if (renderElems < 1) {\n                    // just collect as many elements as allowed in the template\n                    break;\n                }\n                renderElems--;\n\n                // check if the element already exists\n                String id = CmsElementUtil.createId(element.getElement().getStructureId());\n                // collect ids\n                resContainerElems.put(id);\n                if (ids.contains(element.getElement().getStructureId())) {\n                    continue;\n                }\n                // get the element data\n                JSONObject resElement = elemUtil.getElementData(element.getElement(), types);\n                // store element data\n                ids.add(element.getElement().getStructureId());\n                resElements.put(id, resElement);\n            }\n\n            resContainers.put(container.getName(), resContainer);\n        }\n        // collect the favorites\n        JSONArray resFavorites = getFavoriteList(resElements, types);\n        result.put(P_FAVORITES, resFavorites);\n        // collect the recent list\n        JSONArray resRecent = CmsRecentListManager.getInstance().getRecentList(\n            cms,\n            resElements,\n            types,\n            getRequest(),\n            getResponse());\n        result.put(P_RECENT, resRecent);\n\n        return result;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Handles all ADE get requests.<p>\n     * \n     * @return the result\n     * \n     * @throws JSONException if there is any problem with JSON\n     * @throws CmsException if there is a problem with the cms context\n     */\n    protected JSONObject executeActionGet() throws CmsException, JSONException {\n\n        JSONObject result = new JSONObject();\n\n        HttpServletRequest request = getRequest();\n\n        String objParam = request.getParameter(PARAMETER_OBJ);\n        if (objParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_OBJ));\n            return result;\n        }\n        String urlParam = request.getParameter(PARAMETER_URL);\n        if (urlParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_URL));\n            return result;\n        }\n\n        CmsObject cms = getCmsObject();\n        CmsResource cntPageRes = cms.readResource(urlParam);\n        CmsContainerPageBean cntPage = CmsContainerPageCache.getInstance().getCache(\n            cms,\n            cntPageRes,\n            cms.getRequestContext().getLocale());\n\n        if (objParam.equals(OBJ_ALL)) {\n            // first load, get everything\n            result = getContainerPage(cntPageRes, cntPage);\n        } else if (objParam.equals(OBJ_ELEM)) {\n            // get element data\n            String elemParam = request.getParameter(PARAMETER_ELEM);\n            if (elemParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_ELEM));\n                return result;\n            }\n            CmsElementUtil elemUtil = new CmsElementUtil(cms, request, getResponse());\n            JSONObject resElements = new JSONObject();\n            if (elemParam.startsWith(\"[\")) {\n                // element list\n                JSONArray elems = new JSONArray(elemParam);\n                for (int i = 0; i < elems.length(); i++) {\n                    String elem = elems.getString(i);\n                    resElements.put(elem, elemUtil.getElementData(CmsElementUtil.parseId(elem), cntPage.getTypes()));\n                }\n            } else {\n                // single element\n                resElements.put(elemParam, elemUtil.getElementData(\n                    CmsElementUtil.parseId(elemParam),\n                    cntPage.getTypes()));\n            }\n            result.put(P_ELEMENTS, resElements);\n        } else if (objParam.equals(OBJ_FAV)) {\n            // get the favorite list\n            result.put(P_FAVORITES, getFavoriteList(null, cntPage.getTypes()));\n        } else if (objParam.equals(OBJ_REC)) {\n            // get recent list\n            result.put(P_RECENT, CmsRecentListManager.getInstance().getRecentList(\n                cms,\n                null,\n                cntPage.getTypes(),\n                request,\n                getResponse()));\n        } else if (objParam.equals(OBJ_SEARCH)) {\n            // search items\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = getSearchResult(searchOptions, cntPage.getTypes());\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_NEW)) {\n            // get a new element\n            String dataParam = request.getParameter(PARAMETER_DATA);\n            if (dataParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_DATA));\n                return result;\n            }\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n\n            String type = dataParam;\n            CmsElementCreator elemCreator = new CmsElementCreator(cms, cms.readResource(containerPageUri));\n\n            CmsResource newResource = elemCreator.createElement(cms, type);\n            result.put(P_ID, CmsElementUtil.createId(newResource.getStructureId()));\n            result.put(P_URI, cms.getSitePath(newResource));\n        } else {\n            result.put(RES_ERROR, Messages.get().getBundle().key(\n                Messages.ERR_JSON_WRONG_PARAMETER_VALUE_2,\n                PARAMETER_OBJ,\n                objParam));\n        }\n        return result;\n    }","id":104389,"modified_method":"/**\n     * Handles all ADE get requests.<p>\n     * \n     * @return the result\n     * \n     * @throws JSONException if there is any problem with JSON\n     * @throws CmsException if there is a problem with the cms context\n     */\n    protected JSONObject executeActionGet() throws CmsException, JSONException {\n\n        JSONObject result = new JSONObject();\n\n        HttpServletRequest request = getRequest();\n\n        String objParam = request.getParameter(PARAMETER_OBJ);\n        if (objParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_OBJ));\n            return result;\n        }\n        String urlParam = request.getParameter(PARAMETER_URL);\n        if (urlParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_URL));\n            return result;\n        }\n\n        CmsObject cms = getCmsObject();\n        CmsResource cntPageRes = cms.readResource(urlParam);\n        CmsContainerPageBean cntPage = CmsContainerPageCache.getInstance().getCache(\n            cms,\n            cntPageRes,\n            cms.getRequestContext().getLocale());\n\n        if (objParam.equals(OBJ_ALL)) {\n            // first load, get everything\n            result = getContainerPage(cntPageRes, cntPage);\n        } else if (objParam.equals(OBJ_ELEM)) {\n            // get element data\n            String elemParam = request.getParameter(PARAMETER_ELEM);\n            if (elemParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_ELEM));\n                return result;\n            }\n            CmsElementUtil elemUtil = new CmsElementUtil(cms, request, getResponse());\n            JSONObject resElements = new JSONObject();\n            if (elemParam.startsWith(\"[\")) {\n                // element list\n                JSONArray elems = new JSONArray(elemParam);\n                for (int i = 0; i < elems.length(); i++) {\n                    String elem = elems.getString(i);\n                    resElements.put(elem, elemUtil.getElementData(CmsElementUtil.parseId(elem), cntPage.getTypes()));\n                }\n            } else {\n                // single element\n                resElements.put(elemParam, elemUtil.getElementData(\n                    CmsElementUtil.parseId(elemParam),\n                    cntPage.getTypes()));\n            }\n            result.put(P_ELEMENTS, resElements);\n        } else if (objParam.equals(OBJ_FAV)) {\n            // get the favorite list\n            result.put(P_FAVORITES, getFavoriteList(null, cntPage.getTypes()));\n        } else if (objParam.equals(OBJ_REC)) {\n            // get recent list\n            result.put(P_RECENT, CmsRecentListManager.getInstance().getRecentList(\n                cms,\n                null,\n                cntPage.getTypes(),\n                request,\n                getResponse()));\n        } else if (objParam.equals(OBJ_SEARCH)) {\n            // new search\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = CmsSearchListManager.getInstance().getSearchResult(\n                cms,\n                searchOptions,\n                cntPage.getTypes(),\n                request,\n                getResponse());\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_LS)) {\n            // last search\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = CmsSearchListManager.getInstance().getLastSearchResult(\n                cms,\n                searchOptions,\n                cntPage.getTypes(),\n                request,\n                getResponse());\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_NEW)) {\n            // get a new element\n            String dataParam = request.getParameter(PARAMETER_DATA);\n            if (dataParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_DATA));\n                return result;\n            }\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n\n            String type = dataParam;\n            CmsElementCreator elemCreator = new CmsElementCreator(cms, cms.readResource(containerPageUri));\n\n            CmsResource newResource = elemCreator.createElement(cms, type);\n            result.put(P_ID, CmsElementUtil.createId(newResource.getStructureId()));\n            result.put(P_URI, cms.getSitePath(newResource));\n        } else {\n            result.put(RES_ERROR, Messages.get().getBundle().key(\n                Messages.ERR_JSON_WRONG_PARAMETER_VALUE_2,\n                PARAMETER_OBJ,\n                objParam));\n        }\n        return result;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the data for new elements from the given configuration file.<p>\n     * \n     * @param newConfig the configuration file to use \n     * @param types the supported container page types\n     * \n     * @return the data for the given container page\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    protected JSONObject getNewElements(CmsResource newConfig, Set<String> types) throws CmsException, JSONException {\n\n        JSONObject resElements = new JSONObject();\n        CmsElementUtil elemUtil = new CmsElementUtil(getCmsObject(), getRequest(), getResponse());\n        CmsElementCreator creator = new CmsElementCreator(getCmsObject(), newConfig);\n        Map<String, CmsTypeConfigurationItem> typeConfig = creator.getConfiguration();\n        for (Map.Entry<String, CmsTypeConfigurationItem> entry : typeConfig.entrySet()) {\n            String type = entry.getKey();\n            String elementUri = entry.getValue().getSourceFile();\n            JSONObject resElement = elemUtil.getElementData(elementUri, types);\n            // overwrite some special fields for new elements\n            resElement.put(P_ID, type);\n            resElement.put(P_STATUS, \"x\");\n            resElement.put(P_TYPE, type);\n            resElement.put(P_TYPENAME, CmsWorkplaceMessages.getResourceName(\n                getCmsObject().getRequestContext().getLocale(),\n                type));\n            resElements.put(type, resElement);\n        }\n        return resElements;\n    }","id":104390,"modified_method":"/**\n     * Returns the data for new elements from the given configuration file.<p>\n     * \n     * @param newConfig the configuration file to use \n     * @param types the supported container page types\n     * \n     * @return the data for the given container page\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    protected JSONObject getNewElements(CmsResource newConfig, Set<String> types) throws CmsException, JSONException {\n\n        JSONObject resElements = new JSONObject();\n        CmsElementUtil elemUtil = new CmsElementUtil(getCmsObject(), getRequest(), getResponse());\n        CmsElementCreator creator = new CmsElementCreator(getCmsObject(), newConfig);\n        Map<String, CmsTypeConfigurationItem> typeConfig = creator.getConfiguration();\n        for (Map.Entry<String, CmsTypeConfigurationItem> entry : typeConfig.entrySet()) {\n            String type = entry.getKey();\n            String elementUri = entry.getValue().getSourceFile();\n            JSONObject resElement = elemUtil.getElementData(elementUri, types);\n            // overwrite some special fields for new elements\n            resElement.put(P_ID, type);\n            resElement.put(P_STATUS, ELEMENT_NEWCONFIG);\n            resElement.put(P_TYPE, type);\n            resElement.put(P_TYPENAME, CmsWorkplaceMessages.getResourceName(\n                getCmsObject().getRequestContext().getLocale(),\n                type));\n            resElements.put(type, resElement);\n        }\n        return resElements;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Saves the new state of the container page.<p>\n     * \n     * @param uri the uri of the container page to save\n     * @param cntPage the container page data\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    protected void setContainerPage(String uri, JSONObject cntPage) throws CmsException, JSONException {\n\n        CmsObject cms = getCmsObject();\n        cms.lockResourceTemporary(uri);\n        CmsFile containerPage = cms.readFile(uri);\n        CmsXmlContent xmlCnt = CmsXmlContentFactory.unmarshal(cms, containerPage);\n\n        Locale locale = CmsLocaleManager.getLocale(cntPage.getString(P_LOCALE));\n        if (xmlCnt.hasLocale(locale)) {\n            // remove the locale \n            xmlCnt.removeLocale(locale);\n        }\n        xmlCnt.addLocale(cms, locale);\n\n        JSONObject cnts = cntPage.getJSONObject(P_CONTAINERS);\n        int cntCount = 0;\n        Iterator itCnt = cnts.keys();\n        while (itCnt.hasNext()) {\n            String cntKey = (String)itCnt.next();\n            JSONObject cnt = cnts.getJSONObject(cntKey);\n\n            I_CmsXmlContentValue cntValue = xmlCnt.getValue(CmsContainerPageLoader.N_CONTAINER, locale, cntCount);\n            if (cntValue == null) {\n                cntValue = xmlCnt.addValue(cms, CmsContainerPageLoader.N_CONTAINER, locale, cntCount);\n            }\n\n            String name = cnt.getString(P_NAME);\n            xmlCnt.getValue(CmsXmlUtils.concatXpath(cntValue.getPath(), CmsContainerPageLoader.N_NAME), locale, 0).setStringValue(\n                cms,\n                name);\n\n            String type = cnt.getString(P_TYPE);\n            xmlCnt.getValue(CmsXmlUtils.concatXpath(cntValue.getPath(), CmsContainerPageLoader.N_TYPE), locale, 0).setStringValue(\n                cms,\n                type);\n\n            JSONArray elems = cnt.getJSONArray(P_ELEMENTS);\n            for (int i = 0; i < elems.length(); i++) {\n                JSONObject elem = cnt.getJSONArray(P_ELEMENTS).getJSONObject(i);\n\n                String formatter = elem.getString(P_FORMATTER);\n                String elemUri = elem.getString(P_URI);\n\n                I_CmsXmlContentValue elemValue = xmlCnt.addValue(cms, CmsXmlUtils.concatXpath(\n                    cntValue.getPath(),\n                    CmsContainerPageLoader.N_ELEMENT), locale, i);\n                xmlCnt.getValue(CmsXmlUtils.concatXpath(elemValue.getPath(), CmsContainerPageLoader.N_URI), locale, 0).setStringValue(\n                    cms,\n                    elemUri);\n                xmlCnt.getValue(\n                    CmsXmlUtils.concatXpath(elemValue.getPath(), CmsContainerPageLoader.N_FORMATTER),\n                    locale,\n                    0).setStringValue(cms, formatter);\n            }\n            cntCount++;\n        }\n        containerPage.setContents(xmlCnt.marshal());\n        cms.writeFile(containerPage);\n    }","id":104391,"modified_method":"/**\n     * Saves the new state of the container page.<p>\n     * \n     * @param uri the uri of the container page to save\n     * @param cntPage the container page data\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    protected void setContainerPage(String uri, JSONObject cntPage) throws CmsException, JSONException {\n\n        CmsObject cms = getCmsObject();\n        cms.lockResourceTemporary(uri);\n        CmsFile containerPage = cms.readFile(uri);\n        CmsXmlContent xmlCnt = CmsXmlContentFactory.unmarshal(cms, containerPage);\n\n        Locale locale = CmsLocaleManager.getLocale(cntPage.getString(P_LOCALE));\n        if (xmlCnt.hasLocale(locale)) {\n            // remove the locale \n            xmlCnt.removeLocale(locale);\n        }\n        xmlCnt.addLocale(cms, locale);\n\n        JSONObject cnts = cntPage.getJSONObject(P_CONTAINERS);\n        int cntCount = 0;\n        Iterator<String> itCnt = cnts.keys();\n        while (itCnt.hasNext()) {\n            String cntKey = itCnt.next();\n            JSONObject cnt = cnts.getJSONObject(cntKey);\n\n            I_CmsXmlContentValue cntValue = xmlCnt.getValue(CmsContainerPageLoader.N_CONTAINER, locale, cntCount);\n            if (cntValue == null) {\n                cntValue = xmlCnt.addValue(cms, CmsContainerPageLoader.N_CONTAINER, locale, cntCount);\n            }\n\n            String name = cnt.getString(P_NAME);\n            xmlCnt.getValue(CmsXmlUtils.concatXpath(cntValue.getPath(), CmsContainerPageLoader.N_NAME), locale, 0).setStringValue(\n                cms,\n                name);\n\n            String type = cnt.getString(P_TYPE);\n            xmlCnt.getValue(CmsXmlUtils.concatXpath(cntValue.getPath(), CmsContainerPageLoader.N_TYPE), locale, 0).setStringValue(\n                cms,\n                type);\n\n            JSONArray elems = cnt.getJSONArray(P_ELEMENTS);\n            for (int i = 0; i < elems.length(); i++) {\n                JSONObject elem = cnt.getJSONArray(P_ELEMENTS).getJSONObject(i);\n\n                String formatter = elem.getString(P_FORMATTER);\n                String elemUri = elem.getString(P_URI);\n\n                I_CmsXmlContentValue elemValue = xmlCnt.addValue(cms, CmsXmlUtils.concatXpath(\n                    cntValue.getPath(),\n                    CmsContainerPageLoader.N_ELEMENT), locale, i);\n                xmlCnt.getValue(CmsXmlUtils.concatXpath(elemValue.getPath(), CmsContainerPageLoader.N_URI), locale, 0).setStringValue(\n                    cms,\n                    elemUri);\n                xmlCnt.getValue(\n                    CmsXmlUtils.concatXpath(elemValue.getPath(), CmsContainerPageLoader.N_FORMATTER),\n                    locale,\n                    0).setStringValue(cms, formatter);\n            }\n            cntCount++;\n        }\n        containerPage.setContents(xmlCnt.marshal());\n        cms.writeFile(containerPage);\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new cachable object from the xml content.<p>\n     * \n     * @param cms the cms context\n     * @param content the xml content\n     * \n     * @return the cachable object for the given content \n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected Map<Locale, CmsContainerPageBean> serialize(CmsObject cms, CmsXmlContent content) throws CmsException {\n\n        Map<Locale, CmsContainerPageBean> result = new HashMap<Locale, CmsContainerPageBean>();\n\n        // get the new element configuration file, will be the same for every locale\n        String cfgPath = cms.readPropertyObject(content.getFile(), PROPERTY_CONTAINER_NEW_CONFIG, true).getValue(\"\");\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_NOT_SET_2,\n                cms.getSitePath(content.getFile()),\n                PROPERTY_CONTAINER_NEW_CONFIG));\n        }\n        CmsResource newConfigRes;\n        try {\n            newConfigRes = cms.readResource(cfgPath);\n        } catch (Exception e) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_NOT_FOUND_3,\n                cms.getSitePath(content.getFile()),\n                PROPERTY_CONTAINER_NEW_CONFIG,\n                cfgPath));\n        }\n        if (newConfigRes.getTypeId() != 14) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_WRONG_TYPE_3,\n                cms.getSitePath(content.getFile()),\n                PROPERTY_CONTAINER_NEW_CONFIG,\n                cfgPath));\n        }\n\n        // iterate over every locale\n        Iterator itLocales = content.getLocales().iterator();\n        while (itLocales.hasNext()) {\n            Locale locale = (Locale)itLocales.next();\n\n            CmsContainerPageBean cntPage = new CmsContainerPageBean(locale, newConfigRes);\n\n            // iterate over every container in the given locale\n            Iterator itContainers = content.getValues(CmsContainerPageLoader.N_CONTAINER, locale).iterator();\n            while (itContainers.hasNext()) {\n                I_CmsXmlContentValue container = (I_CmsXmlContentValue)itContainers.next();\n                String containerPath = container.getPath();\n                // get the name and type\n                String name = content.getValue(\n                    CmsXmlUtils.concatXpath(containerPath, CmsContainerPageLoader.N_NAME),\n                    locale).getStringValue(cms);\n                String type = content.getValue(\n                    CmsXmlUtils.concatXpath(containerPath, CmsContainerPageLoader.N_TYPE),\n                    locale).getStringValue(cms);\n\n                // HACK: maxElem will be updated later while executing the template\n                CmsContainerBean cnt = new CmsContainerBean(name, type, -1);\n\n                // iterate over the container elements\n                Iterator itElements = content.getValues(\n                    CmsXmlUtils.concatXpath(containerPath, CmsContainerPageLoader.N_ELEMENT),\n                    locale).iterator();\n                while (itElements.hasNext()) {\n                    I_CmsXmlContentValue element = (I_CmsXmlContentValue)itElements.next();\n                    String elementPath = element.getPath();\n                    // get uri and formatter\n                    String elemUri = content.getValue(\n                        CmsXmlUtils.concatXpath(elementPath, CmsContainerPageLoader.N_URI),\n                        locale).getStringValue(cms);\n                    CmsResource elemRes = cms.readResource(elemUri);\n\n                    String formatter = content.getValue(\n                        CmsXmlUtils.concatXpath(elementPath, CmsContainerPageLoader.N_FORMATTER),\n                        locale).getStringValue(cms);\n                    CmsResource formatterRes = cms.readResource(formatter);\n\n                    CmsContainerElementBean elem = new CmsContainerElementBean(elemRes, formatterRes);\n\n                    // add element to container\n                    cnt.addElement(elem);\n                }\n                // add container to container page\n                cntPage.addContainer(cnt);\n            }\n\n            // collect containers\n            result.put(locale, cntPage);\n        }\n\n        return result;\n    }","id":104392,"modified_method":"/**\n     * Creates a new cachable object from the xml content.<p>\n     * \n     * @param cms the cms context\n     * @param content the xml content\n     * \n     * @return the cachable object for the given content \n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected Map<Locale, CmsContainerPageBean> serialize(CmsObject cms, CmsXmlContent content) throws CmsException {\n\n        Map<Locale, CmsContainerPageBean> result = new HashMap<Locale, CmsContainerPageBean>();\n\n        // get the new element configuration file, will be the same for every locale\n        String cfgPath = cms.readPropertyObject(content.getFile(), PROPERTY_CONTAINER_NEW_CONFIG, true).getValue(\"\");\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_NOT_SET_2,\n                cms.getSitePath(content.getFile()),\n                PROPERTY_CONTAINER_NEW_CONFIG));\n        }\n        CmsResource newConfigRes;\n        try {\n            newConfigRes = cms.readResource(cfgPath);\n        } catch (Exception e) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_NOT_FOUND_3,\n                cms.getSitePath(content.getFile()),\n                PROPERTY_CONTAINER_NEW_CONFIG,\n                cfgPath));\n        }\n        if (newConfigRes.getTypeId() != 14) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_WRONG_TYPE_3,\n                cms.getSitePath(content.getFile()),\n                PROPERTY_CONTAINER_NEW_CONFIG,\n                cfgPath));\n        }\n\n        // iterate over every locale\n        Iterator<Locale> itLocales = content.getLocales().iterator();\n        while (itLocales.hasNext()) {\n            Locale locale = itLocales.next();\n\n            CmsContainerPageBean cntPage = new CmsContainerPageBean(locale, newConfigRes);\n\n            // iterate over every container in the given locale\n            Iterator<I_CmsXmlContentValue> itContainers = content.getValues(CmsContainerPageLoader.N_CONTAINER, locale).iterator();\n            while (itContainers.hasNext()) {\n                I_CmsXmlContentValue container = itContainers.next();\n                String containerPath = container.getPath();\n                // get the name and type\n                String name = content.getValue(\n                    CmsXmlUtils.concatXpath(containerPath, CmsContainerPageLoader.N_NAME),\n                    locale).getStringValue(cms);\n                String type = content.getValue(\n                    CmsXmlUtils.concatXpath(containerPath, CmsContainerPageLoader.N_TYPE),\n                    locale).getStringValue(cms);\n\n                // HACK: maxElem will be updated later while executing the template\n                CmsContainerBean cnt = new CmsContainerBean(name, type, -1);\n\n                // iterate over the container elements\n                Iterator<I_CmsXmlContentValue> itElements = content.getValues(\n                    CmsXmlUtils.concatXpath(containerPath, CmsContainerPageLoader.N_ELEMENT),\n                    locale).iterator();\n                while (itElements.hasNext()) {\n                    I_CmsXmlContentValue element = itElements.next();\n                    String elementPath = element.getPath();\n                    // get uri and formatter\n                    String elemUri = content.getValue(\n                        CmsXmlUtils.concatXpath(elementPath, CmsContainerPageLoader.N_URI),\n                        locale).getStringValue(cms);\n                    CmsResource elemRes = cms.readResource(elemUri);\n\n                    String formatter = content.getValue(\n                        CmsXmlUtils.concatXpath(elementPath, CmsContainerPageLoader.N_FORMATTER),\n                        locale).getStringValue(cms);\n                    CmsResource formatterRes = cms.readResource(formatter);\n\n                    CmsContainerElementBean elem = new CmsContainerElementBean(elemRes, formatterRes);\n\n                    // add element to container\n                    cnt.addElement(elem);\n                }\n                // add container to container page\n                cntPage.addContainer(cnt);\n            }\n\n            // collect containers\n            result.put(locale, cntPage);\n        }\n\n        return result;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes a bunch of cached resources from the offline cache, but keeps their properties\n     * in the cache.<p>\n     * \n     * @param resources a list of resources\n     * \n     * @see #uncacheResource(CmsResource)\n     */\n    protected void uncacheResources(List resources) {\n\n        if (resources == null) {\n            LOG.warn(Messages.get().container(Messages.LOG_WARN_UNCACHE_NULL_0));\n            return;\n        }\n\n        for (int i = 0, n = resources.size(); i < n; i++) {\n            // remove the resource\n            uncacheResource((CmsResource)resources.get(i));\n        }\n    }","id":104393,"modified_method":"/**\n     * Removes a bunch of cached resources from the offline cache, but keeps their properties\n     * in the cache.<p>\n     * \n     * @param resources a list of resources\n     * \n     * @see #uncacheResource(CmsResource)\n     */\n    protected void uncacheResources(List<CmsResource> resources) {\n\n        if (resources == null) {\n            LOG.warn(Messages.get().container(Messages.LOG_WARN_UNCACHE_NULL_0));\n            return;\n        }\n\n        for (int i = 0, n = resources.size(); i < n; i++) {\n            // remove the resource\n            uncacheResource(resources.get(i));\n        }\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Takes care of cache synchronization and consistency.<p>\n     * \n     * @param event the event to handle\n     */\n    public void cmsEvent(CmsEvent event) {\n\n        CmsResource resource = null;\n        List resources = null;\n\n        switch (event.getType()) {\n            case I_CmsEventListener.EVENT_RESOURCE_AND_PROPERTIES_MODIFIED:\n            case I_CmsEventListener.EVENT_RESOURCE_MODIFIED:\n                // a resource has been modified in a way that it *IS NOT* necessary also to clear \n                // lists of cached sub-resources where the specified resource might be contained inside.\n                // all siblings are removed from the cache, too.\n                resource = (CmsResource)event.getData().get(\"resource\");\n                uncacheResource(resource);\n                break;\n\n            case I_CmsEventListener.EVENT_RESOURCES_AND_PROPERTIES_MODIFIED:\n                // a list of resources and all of their properties have been modified\n                resources = (List)event.getData().get(\"resources\");\n                uncacheResources(resources);\n                break;\n\n            case I_CmsEventListener.EVENT_RESOURCE_DELETED:\n            case I_CmsEventListener.EVENT_RESOURCES_MODIFIED:\n                // a list of resources has been modified\n                resources = (List)event.getData().get(\"resources\");\n                uncacheResources(resources);\n                break;\n\n            case I_CmsEventListener.EVENT_CLEAR_ONLINE_CACHES:\n            case I_CmsEventListener.EVENT_PUBLISH_PROJECT:\n                OpenCms.getMemoryMonitor().flushContainerPages(true);\n                break;\n\n            case I_CmsEventListener.EVENT_CLEAR_CACHES:\n                OpenCms.getMemoryMonitor().flushContainerPages(true);\n                OpenCms.getMemoryMonitor().flushContainerPages(false);\n                break;\n\n            case I_CmsEventListener.EVENT_CLEAR_OFFLINE_CACHES:\n                OpenCms.getMemoryMonitor().flushContainerPages(false);\n                break;\n\n            default:\n                // noop\n                break;\n        }\n    }","id":104394,"modified_method":"/**\n     * Takes care of cache synchronization and consistency.<p>\n     * \n     * @param event the event to handle\n     */\n    public void cmsEvent(CmsEvent event) {\n\n        CmsResource resource = null;\n        List<CmsResource> resources = null;\n\n        switch (event.getType()) {\n            case I_CmsEventListener.EVENT_RESOURCE_AND_PROPERTIES_MODIFIED:\n            case I_CmsEventListener.EVENT_RESOURCE_MODIFIED:\n                // a resource has been modified in a way that it *IS NOT* necessary also to clear \n                // lists of cached sub-resources where the specified resource might be contained inside.\n                // all siblings are removed from the cache, too.\n                resource = (CmsResource)event.getData().get(\"resource\");\n                uncacheResource(resource);\n                break;\n\n            case I_CmsEventListener.EVENT_RESOURCES_AND_PROPERTIES_MODIFIED:\n                // a list of resources and all of their properties have been modified\n                resources = (List<CmsResource>)event.getData().get(\"resources\");\n                uncacheResources(resources);\n                break;\n\n            case I_CmsEventListener.EVENT_RESOURCE_DELETED:\n            case I_CmsEventListener.EVENT_RESOURCES_MODIFIED:\n                // a list of resources has been modified\n                resources = (List<CmsResource>)event.getData().get(\"resources\");\n                uncacheResources(resources);\n                break;\n\n            case I_CmsEventListener.EVENT_CLEAR_ONLINE_CACHES:\n            case I_CmsEventListener.EVENT_PUBLISH_PROJECT:\n                OpenCms.getMemoryMonitor().flushContainerPages(true);\n                break;\n\n            case I_CmsEventListener.EVENT_CLEAR_CACHES:\n                OpenCms.getMemoryMonitor().flushContainerPages(true);\n                OpenCms.getMemoryMonitor().flushContainerPages(false);\n                break;\n\n            case I_CmsEventListener.EVENT_CLEAR_OFFLINE_CACHES:\n                OpenCms.getMemoryMonitor().flushContainerPages(false);\n                break;\n\n            default:\n                // noop\n                break;\n        }\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Validates container names, so that they are unique in the page.<p>\n     * \n     * @param cms the cms context\n     * @param value the value to validate\n     * @param content the container page to validate\n     * \n     * @throws CmsXmlException if there are duplicated names\n     */\n    protected void validateNames(CmsObject cms, I_CmsXmlContentValue value, CmsXmlContent content)\n    throws CmsXmlException {\n\n        // get the current name\n        Locale locale = value.getLocale();\n        String namePath = CmsXmlUtils.concatXpath(value.getPath(), CmsContainerPageLoader.N_NAME);\n        String name = content.getValue(namePath, locale).getStringValue(cms);\n        // iterate over all containers\n        Iterator itValues = content.getValues(CmsContainerPageLoader.N_CONTAINER, locale).iterator();\n        while (itValues.hasNext()) {\n            I_CmsXmlContentValue itValue = (I_CmsXmlContentValue)itValues.next();\n            if (itValue.getPath().equals(value.getPath())) {\n                // skip current container\n                continue;\n            }\n            // get container name\n            namePath = CmsXmlUtils.concatXpath(itValue.getPath(), CmsContainerPageLoader.N_NAME);\n            String itName = content.getValue(namePath, locale).getStringValue(cms);\n            // validate\n            if (name.equals(itName)) {\n                throw new CmsXmlException(Messages.get().container(Messages.ERR_DUPLICATE_NAME_1, name));\n            }\n        }\n    }","id":104395,"modified_method":"/**\n     * Validates container names, so that they are unique in the page.<p>\n     * \n     * @param cms the cms context\n     * @param value the value to validate\n     * @param content the container page to validate\n     * \n     * @throws CmsXmlException if there are duplicated names\n     */\n    protected void validateNames(CmsObject cms, I_CmsXmlContentValue value, CmsXmlContent content)\n    throws CmsXmlException {\n\n        // get the current name\n        Locale locale = value.getLocale();\n        String namePath = CmsXmlUtils.concatXpath(value.getPath(), CmsContainerPageLoader.N_NAME);\n        String name = content.getValue(namePath, locale).getStringValue(cms);\n        // iterate over all containers\n        Iterator<I_CmsXmlContentValue> itValues = content.getValues(CmsContainerPageLoader.N_CONTAINER, locale).iterator();\n        while (itValues.hasNext()) {\n            I_CmsXmlContentValue itValue = itValues.next();\n            if (itValue.getPath().equals(value.getPath())) {\n                // skip current container\n                continue;\n            }\n            // get container name\n            namePath = CmsXmlUtils.concatXpath(itValue.getPath(), CmsContainerPageLoader.N_NAME);\n            String itName = content.getValue(namePath, locale).getStringValue(cms);\n            // validate\n            if (name.equals(itName)) {\n                throw new CmsXmlException(Messages.get().container(Messages.ERR_DUPLICATE_NAME_1, name));\n            }\n        }\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a new file name for an element to be created based on a pattern.<p>\n     * \n     * The pattern consists of a path which may contain the macro %(number), which \n     * will be replaced by the first 5-digit sequence for which the resulting file name is not already\n     * used.<p>\n     * \n     * Although this method is synchronized, it may still return a used file name in the unlikely\n     * case that it is called after a previous call to this method, but before the resulting file name\n     * was used to create a file.<p>  \n     * \n     * This method was adapted from the method {@link org.opencms.file.collectors.A_CmsResourceCollector}<code>#getCreateInFolder<\/code>.<p>\n     *\n     * @param cms the CmsObject used for checking the existence of file names\n     * @param pattern the pattern for new files\n     * \n     * @return the new file name\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public static synchronized String getNewFileName(CmsObject cms, String pattern) throws CmsException {\n\n        // this method was adapted from A_CmsResourceCollector#getCreateInFolder\n        pattern = cms.getRequestContext().removeSiteRoot(pattern);\n        PrintfFormat format = new PrintfFormat(FILE_NUMBER_FORMAT);\n        String folderName = CmsResource.getFolderPath(pattern);\n        List resources = cms.readResources(folderName, CmsResourceFilter.ALL, false);\n        // now create a list of all resources that just contains the file names\n        Set<String> result = new HashSet<String>();\n        for (int i = 0; i < resources.size(); i++) {\n            CmsResource resource = (CmsResource)resources.get(i);\n            result.add(cms.getSitePath(resource));\n        }\n\n        String checkFileName, checkTempFileName, number;\n        CmsMacroResolver resolver = CmsMacroResolver.newInstance();\n        int j = 0;\n        do {\n            number = format.sprintf(++j);\n            resolver.addMacro(MACRO_NUMBER, number);\n            // resolve macros in file name\n            checkFileName = resolver.resolveMacros(pattern);\n            // get name of the resolved temp file\n            checkTempFileName = CmsWorkplace.getTemporaryFileName(checkFileName);\n        } while (result.contains(checkFileName) || result.contains(checkTempFileName));\n        return checkFileName;\n    }","id":104396,"modified_method":"/**\n     * Returns a new file name for an element to be created based on a pattern.<p>\n     * \n     * The pattern consists of a path which may contain the macro %(number), which \n     * will be replaced by the first 5-digit sequence for which the resulting file name is not already\n     * used.<p>\n     * \n     * Although this method is synchronized, it may still return a used file name in the unlikely\n     * case that it is called after a previous call to this method, but before the resulting file name\n     * was used to create a file.<p>  \n     * \n     * This method was adapted from the method {@link org.opencms.file.collectors.A_CmsResourceCollector}<code>#getCreateInFolder<\/code>.<p>\n     *\n     * @param cms the CmsObject used for checking the existence of file names\n     * @param pattern the pattern for new files\n     * \n     * @return the new file name\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public static synchronized String getNewFileName(CmsObject cms, String pattern) throws CmsException {\n\n        // this method was adapted from A_CmsResourceCollector#getCreateInFolder\n        pattern = cms.getRequestContext().removeSiteRoot(pattern);\n        PrintfFormat format = new PrintfFormat(FILE_NUMBER_FORMAT);\n        String folderName = CmsResource.getFolderPath(pattern);\n        List<CmsResource> resources = cms.readResources(folderName, CmsResourceFilter.ALL, false);\n        // now create a list of all resources that just contains the file names\n        Set<String> result = new HashSet<String>();\n        for (int i = 0; i < resources.size(); i++) {\n            CmsResource resource = resources.get(i);\n            result.add(cms.getSitePath(resource));\n        }\n\n        String checkFileName, checkTempFileName, number;\n        CmsMacroResolver resolver = CmsMacroResolver.newInstance();\n        int j = 0;\n        do {\n            number = format.sprintf(++j);\n            resolver.addMacro(MACRO_NUMBER, number);\n            // resolve macros in file name\n            checkFileName = resolver.resolveMacros(pattern);\n            // get name of the resolved temp file\n            checkTempFileName = CmsWorkplace.getTemporaryFileName(checkFileName);\n        } while (result.contains(checkFileName) || result.contains(checkTempFileName));\n        return checkFileName;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Parses a type configuration contained in an XML content.<p>\n     * \n     * This method uses the first locale from the following list which has a corresponding\n     * element in the XML content:\n     * <ul>\n     *  <li>the request context's locale<\/li>\n     *  <li>the default locale<\/li>\n     *  <li>the first locale available in the XML content<\/li>\n     * <\/ul><p>\n     *\n     * @param cms the CmsObject to use for VFS operations\n     * @param content the XML content with the type configuration\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public void parseConfiguration(CmsObject cms, I_CmsXmlDocument content) throws CmsException {\n\n        Locale currentLocale = cms.getRequestContext().getLocale();\n        Locale defaultLocale = CmsLocaleManager.getDefaultLocale();\n        Locale locale = null;\n        if (content.hasLocale(currentLocale)) {\n            locale = currentLocale;\n        } else if (content.hasLocale(defaultLocale)) {\n            locale = defaultLocale;\n        } else {\n            List locales = content.getLocales();\n            if (locales.size() == 0) {\n\n                throw new CmsException(Messages.get().container(\n                    Messages.ERR_NO_TYPE_CONFIG_1,\n                    content.getFile().getRootPath()));\n            }\n            locale = (Locale)locales.get(0);\n        }\n\n        Iterator itTypes = content.getValues(N_ADE_TYPE, locale).iterator();\n        while (itTypes.hasNext()) {\n            I_CmsXmlContentValue xmlType = (I_CmsXmlContentValue)itTypes.next();\n            String typePath = xmlType.getPath();\n            String source = content.getValue(CmsXmlUtils.concatXpath(typePath, N_SOURCE), locale).getStringValue(cms);\n            String destination = content.getValue(\n                CmsXmlUtils.concatXpath(typePath, CmsXmlUtils.concatXpath(N_DESTINATION, N_FOLDER)),\n                locale).getStringValue(cms);\n            destination += content.getValue(\n                CmsXmlUtils.concatXpath(typePath, CmsXmlUtils.concatXpath(N_DESTINATION, N_PATTERN)),\n                locale).getStringValue(cms);\n            CmsTypeConfigurationItem configItem = new CmsTypeConfigurationItem(source, destination);\n            CmsResource resource = cms.readResource(source);\n            String type = getTypeName(resource.getTypeId());\n            m_configuration.put(type, configItem);\n        }\n    }","id":104397,"modified_method":"/**\n     * Parses a type configuration contained in an XML content.<p>\n     * \n     * This method uses the first locale from the following list which has a corresponding\n     * element in the XML content:\n     * <ul>\n     *  <li>the request context's locale<\/li>\n     *  <li>the default locale<\/li>\n     *  <li>the first locale available in the XML content<\/li>\n     * <\/ul><p>\n     *\n     * @param cms the CmsObject to use for VFS operations\n     * @param content the XML content with the type configuration\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public void parseConfiguration(CmsObject cms, I_CmsXmlDocument content) throws CmsException {\n\n        Locale currentLocale = cms.getRequestContext().getLocale();\n        Locale defaultLocale = CmsLocaleManager.getDefaultLocale();\n        Locale locale = null;\n        if (content.hasLocale(currentLocale)) {\n            locale = currentLocale;\n        } else if (content.hasLocale(defaultLocale)) {\n            locale = defaultLocale;\n        } else {\n            List<Locale> locales = content.getLocales();\n            if (locales.size() == 0) {\n                throw new CmsException(Messages.get().container(\n                    Messages.ERR_NO_TYPE_CONFIG_1,\n                    content.getFile().getRootPath()));\n            }\n            locale = locales.get(0);\n        }\n\n        Iterator<I_CmsXmlContentValue> itTypes = content.getValues(N_ADE_TYPE, locale).iterator();\n        while (itTypes.hasNext()) {\n            I_CmsXmlContentValue xmlType = itTypes.next();\n            String typePath = xmlType.getPath();\n            String source = content.getValue(CmsXmlUtils.concatXpath(typePath, N_SOURCE), locale).getStringValue(cms);\n            String destination = content.getValue(\n                CmsXmlUtils.concatXpath(typePath, CmsXmlUtils.concatXpath(N_DESTINATION, N_FOLDER)),\n                locale).getStringValue(cms);\n            destination += content.getValue(\n                CmsXmlUtils.concatXpath(typePath, CmsXmlUtils.concatXpath(N_DESTINATION, N_PATTERN)),\n                locale).getStringValue(cms);\n            CmsTypeConfigurationItem configItem = new CmsTypeConfigurationItem(source, destination);\n            CmsResource resource = cms.readResource(source);\n            String type = getTypeName(resource.getTypeId());\n            m_configuration.put(type, configItem);\n        }\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the data for an element.<p>\n     * \n     * @param resource the resource\n     * @param types the types supported by the container page\n     * \n     * @return the data for an element\n     * \n     * @throws CmsException if something goes wrong\n     * @throws JSONException if something goes wrong in the json manipulation\n     */\n    public JSONObject getElementData(CmsResource resource, Collection<String> types) throws CmsException, JSONException {\n\n        // create new json object for the element\n        JSONObject resElement = new JSONObject();\n        resElement.put(CmsADEServer.P_ID, CmsElementUtil.ADE_ID_PREFIX + resource.getStructureId().toString());\n        resElement.put(CmsADEServer.P_FILE, m_cms.getSitePath(resource));\n        resElement.put(CmsADEServer.P_DATE, resource.getDateLastModified());\n        resElement.put(CmsADEServer.P_USER, m_cms.readUser(resource.getUserLastModified()).getName());\n        resElement.put(CmsADEServer.P_NAVTEXT, m_cms.readPropertyObject(\n            resource,\n            CmsPropertyDefinition.PROPERTY_NAVTEXT,\n            false).getValue(\"\"));\n        resElement.put(CmsADEServer.P_TITLE, m_cms.readPropertyObject(\n            resource,\n            CmsPropertyDefinition.PROPERTY_TITLE,\n            false).getValue(\"\"));\n        CmsResourceUtil resUtil = new CmsResourceUtil(m_cms, resource);\n        resElement.put(\n            CmsADEServer.P_ALLOWEDIT,\n            resUtil.getLock().isLockableBy(m_cms.getRequestContext().currentUser()) && resUtil.isEditable());\n        resElement.put(CmsADEServer.P_LOCKED, resUtil.getLockedByName());\n        resElement.put(CmsADEServer.P_STATUS, \"\" + resUtil.getStateAbbreviation());\n        // add formatted elements\n        JSONObject resContents = new JSONObject();\n        resElement.put(CmsADEServer.P_CONTENTS, resContents);\n        // add formatter uris\n        JSONObject formatters = new JSONObject();\n        resElement.put(CmsADEServer.P_FORMATTERS, formatters);\n        if (resource.getTypeId() == CmsResourceTypeContainerPage.getStaticTypeId()) {\n            Iterator itTypes = types.iterator();\n            while (itTypes.hasNext()) {\n                String type = (String)itTypes.next();\n                formatters.put(type, \"\"); // empty formatters\n                resContents.put(type, \"\"); // empty contents\n            }\n            // this container page should contain exactly one container\n            CmsContainerPageBean cntPage = CmsContainerPageCache.getInstance().getCache(\n                m_cms,\n                resource,\n                m_cms.getRequestContext().getLocale());\n            CmsContainerBean container = cntPage.getContainers().values().iterator().next();\n\n            // add subitems\n            JSONArray subitems = new JSONArray();\n            resElement.put(CmsADEServer.P_SUBITEMS, subitems);\n            // iterate the elements\n            for (CmsContainerElementBean element : container.getElements()) {\n                CmsUUID id = element.getElement().getStructureId();\n                // collect ids\n                subitems.put(createId(id));\n            }\n        } else {\n            // TODO: this may not be performing well, any way to access the content handler without unmarshal??\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(m_cms, m_cms.readFile(resource));\n            Iterator it = content.getContentDefinition().getContentHandler().getFormatters().entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry entry = (Map.Entry)it.next();\n                String type = (String)entry.getKey();\n                if (!types.contains(type) && !type.equals(CmsDefaultXmlContentHandler.DEFAULT_FORMATTER_TYPE)) {\n                    // skip not supported types\n                    continue;\n                }\n                String formatterUri = (String)entry.getValue();\n                formatters.put(type, formatterUri);\n                // execute the formatter jsp for the given element\n                try {\n                    String jspResult = getElementContent(resource, m_cms.readResource(formatterUri));\n                    // set the results\n                    resContents.put(type, jspResult);\n                } catch (Exception e) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.ERR_GENERATE_FORMATTED_ELEMENT_3,\n                        m_cms.getSitePath(resource),\n                        formatterUri,\n                        type), e);\n                }\n            }\n        }\n\n        return resElement;\n    }","id":104398,"modified_method":"/**\n     * Returns the data for an element.<p>\n     * \n     * @param resource the resource\n     * @param types the types supported by the container page\n     * \n     * @return the data for an element\n     * \n     * @throws CmsException if something goes wrong\n     * @throws JSONException if something goes wrong in the json manipulation\n     */\n    public JSONObject getElementData(CmsResource resource, Collection<String> types) throws CmsException, JSONException {\n\n        // create new json object for the element\n        JSONObject resElement = new JSONObject();\n        resElement.put(CmsADEServer.P_ID, CmsElementUtil.ADE_ID_PREFIX + resource.getStructureId().toString());\n        resElement.put(CmsADEServer.P_FILE, m_cms.getSitePath(resource));\n        resElement.put(CmsADEServer.P_DATE, resource.getDateLastModified());\n        resElement.put(CmsADEServer.P_USER, m_cms.readUser(resource.getUserLastModified()).getName());\n        resElement.put(CmsADEServer.P_NAVTEXT, m_cms.readPropertyObject(\n            resource,\n            CmsPropertyDefinition.PROPERTY_NAVTEXT,\n            false).getValue(\"\"));\n        resElement.put(CmsADEServer.P_TITLE, m_cms.readPropertyObject(\n            resource,\n            CmsPropertyDefinition.PROPERTY_TITLE,\n            false).getValue(\"\"));\n        CmsResourceUtil resUtil = new CmsResourceUtil(m_cms, resource);\n        resElement.put(\n            CmsADEServer.P_ALLOWEDIT,\n            resUtil.getLock().isLockableBy(m_cms.getRequestContext().currentUser()) && resUtil.isEditable());\n        resElement.put(CmsADEServer.P_LOCKED, resUtil.getLockedByName());\n        resElement.put(CmsADEServer.P_STATUS, \"\" + resUtil.getStateAbbreviation());\n        // add formatted elements\n        JSONObject resContents = new JSONObject();\n        resElement.put(CmsADEServer.P_CONTENTS, resContents);\n        // add formatter uris\n        JSONObject formatters = new JSONObject();\n        resElement.put(CmsADEServer.P_FORMATTERS, formatters);\n        if (resource.getTypeId() == CmsResourceTypeContainerPage.getStaticTypeId()) {\n            Iterator<String> itTypes = types.iterator();\n            while (itTypes.hasNext()) {\n                String type = itTypes.next();\n                formatters.put(type, \"\"); // empty formatters\n                resContents.put(type, \"\"); // empty contents\n            }\n            // this container page should contain exactly one container\n            CmsContainerPageBean cntPage = CmsContainerPageCache.getInstance().getCache(\n                m_cms,\n                resource,\n                m_cms.getRequestContext().getLocale());\n            CmsContainerBean container = cntPage.getContainers().values().iterator().next();\n\n            // add subitems\n            JSONArray subitems = new JSONArray();\n            resElement.put(CmsADEServer.P_SUBITEMS, subitems);\n            // iterate the elements\n            for (CmsContainerElementBean element : container.getElements()) {\n                CmsUUID id = element.getElement().getStructureId();\n                // collect ids\n                subitems.put(createId(id));\n            }\n        } else {\n            // TODO: this may not be performing well, any way to access the content handler without unmarshal??\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(m_cms, m_cms.readFile(resource));\n            Iterator<Map.Entry<String, String>> it = content.getContentDefinition().getContentHandler().getFormatters().entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry<String, String> entry = it.next();\n                String type = entry.getKey();\n                if (!types.contains(type) && !type.equals(CmsDefaultXmlContentHandler.DEFAULT_FORMATTER_TYPE)) {\n                    // skip not supported types\n                    continue;\n                }\n                String formatterUri = entry.getValue();\n                formatters.put(type, formatterUri);\n                // execute the formatter jsp for the given element\n                try {\n                    String jspResult = getElementContent(resource, m_cms.readResource(formatterUri));\n                    // set the results\n                    resContents.put(type, jspResult);\n                } catch (Exception e) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.ERR_GENERATE_FORMATTED_ELEMENT_3,\n                        m_cms.getSitePath(resource),\n                        formatterUri,\n                        type), e);\n                }\n            }\n        }\n\n        return resElement;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the cached list, or creates it if not available.<p>\n     * \n     * @param cms the current cms context\n     * \n     * @return the cached recent list\n     */\n    protected List<CmsUUID> getRecentListFromCache(CmsObject cms) {\n\n        CmsUser user = cms.getRequestContext().currentUser();\n        List<CmsUUID> recentList = m_recentListCache.get(user.getId().toString());\n        if (recentList == null) {\n            Integer maxElems = (Integer)user.getAdditionalInfo(ADDINFO_ADE_RECENTLIST_SIZE);\n            if (maxElems == null) {\n                maxElems = new Integer(DEFAULT_RECENT_LIST_SIZE);\n            }\n            recentList = new NodeCachingLinkedList(maxElems.intValue());\n            m_recentListCache.put(user.getId().toString(), recentList);\n        }\n        return recentList;\n    }","id":104399,"modified_method":"/**\n     * Returns the cached list, or creates it if not available.<p>\n     * \n     * @param cms the current cms context\n     * \n     * @return the cached recent list\n     */\n    protected List<CmsUUID> getRecentListFromCache(CmsObject cms) {\n\n        CmsUser user = cms.getRequestContext().currentUser();\n        List<CmsUUID> recentList = m_recentListCache.get(user.getId().toString());\n        if (recentList == null) {\n            Integer maxElems = (Integer)user.getAdditionalInfo(ADDINFO_ADE_RECENTLIST_SIZE);\n            if (maxElems == null) {\n                maxElems = new Integer(DEFAULT_RECENT_LIST_SIZE);\n            }\n            recentList = new NodeCachingLinkedList(maxElems.intValue());\n            m_recentListCache.put(user.getId(), recentList);\n        }\n        return recentList;\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new instance.<p>\n     */\n    private CmsRecentListManager() {\n\n        m_recentListCache = new HashMap<String, List<CmsUUID>>();\n    }","id":104400,"modified_method":"/**\n     * Creates a new instance.<p>\n     */\n    private CmsRecentListManager() {\n\n        m_recentListCache = new HashMap<CmsUUID, List<CmsUUID>>();\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Validates all parameters.<p>\n     * \n     * @param location the vfs location to search\n     * @param text the search query\n     * @param type the type of resources to search\n     * @param page the page number to use, zero based\n     */\n    protected void init(String location, String text, String type, int page) {\n\n        m_text = text;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_text)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_JSON_MISSING_PARAMETER_1,\n                CmsADEServer.PARAMETER_TEXT));\n        }\n        m_location = location;\n        if (m_location == null) {\n            m_location = \"/\";\n        }\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(type)) {\n            type = null;\n        }\n        m_type = type;\n        m_page = page;\n        if (m_page < 0) {\n            m_page = 0;\n        }\n    }","id":104401,"modified_method":"/**\n     * Validates all parameters.<p>\n     * \n     * @param location the vfs location to search\n     * @param text the search query\n     * @param type the type of resources to search\n     * @param page the page number to use, zero based\n     */\n    protected void init(String location, String text, String type, int page) {\n\n        m_text = text;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_text)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_JSON_MISSING_PARAMETER_1,\n                CmsADEServer.PARAMETER_TEXT));\n        }\n        m_location = location;\n        if (m_location == null) {\n            m_location = \"/\";\n        }\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(type)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_JSON_MISSING_PARAMETER_1,\n                CmsADEServer.PARAMETER_TYPE));\n        }\n        m_type = type;\n        m_page = page;\n        if (m_page < 0) {\n            m_page = 0;\n        }\n    }","commit_id":"7e72fb8671671add29f94bb46c763546db0c0699","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Deindex a single control.\n     *\n     * @param control           control to deindex\n     * @param registerEvents    whether to register a relevance event if the control was bound and relevant\n     */\n    private void deindexControl(XFormsControl control, boolean registerEvents) {\n\n        // Remove by effective id\n        if (effectiveIdsToControls != null) {\n            effectiveIdsToControls.remove(control.getEffectiveId());\n        }\n\n        // Remove by control type (for certain controls we know we need)\n        if (mustMapControl(control)) {\n            if (controlTypes != null) {\n                final Map controlsMap = controlTypes.get(control.getName());\n                if (controlsMap != null) {\n                    controlsMap.remove(control.getEffectiveId());\n                }\n            }\n        }\n\n        // Add event if necessary\n        // NOTE: We don't dispatch events to repeat iterations\n        if (registerEvents && control instanceof XFormsSingleNodeControl && !(control instanceof XFormsRepeatIterationControl)) {\n            final XFormsSingleNodeControl singleNodeControl = (XFormsSingleNodeControl) control;\n            final NodeInfo boundNode = singleNodeControl.getBoundNode();\n            if (boundNode != null && InstanceData.getInheritedRelevant(boundNode)) {\n                // Control was bound to a node and relevant and is going out of existence\n                eventsToDispatch.put(singleNodeControl.getEffectiveId(),\n                        new XFormsControls.EventSchedule(singleNodeControl.getEffectiveId(), XFormsControls.EventSchedule.RELEVANT_BINDING, singleNodeControl));\n            }\n        }\n    }","id":104402,"modified_method":"/**\n     * Deindex a single control.\n     *\n     * @param control           control to deindex\n     * @param registerEvents    whether to register a relevance event if the control was bound and relevant\n     */\n    private void deindexControl(XFormsControl control, boolean registerEvents) {\n\n        // Remove by effective id\n        if (effectiveIdsToControls != null) {\n            effectiveIdsToControls.remove(control.getEffectiveId());\n        }\n\n        // Remove by control type (for certain controls we know we need)\n        if (mustMapControlByType(control)) {\n            if (controlTypes != null) {\n                final Map controlsMap = controlTypes.get(control.getName());\n                if (controlsMap != null) {\n                    controlsMap.remove(control.getEffectiveId());\n                }\n            }\n        }\n\n        // Add event if necessary\n        // NOTE: We don't dispatch events to repeat iterations\n        if (registerEvents && control instanceof XFormsSingleNodeControl && !(control instanceof XFormsRepeatIterationControl)) {\n            final XFormsSingleNodeControl singleNodeControl = (XFormsSingleNodeControl) control;\n            final NodeInfo boundNode = singleNodeControl.getBoundNode();\n            if (boundNode != null && InstanceData.getInheritedRelevant(boundNode)) {\n                // Control was bound to a node and relevant and is going out of existence\n                eventsToDispatch.put(singleNodeControl.getEffectiveId(),\n                        new XFormsControls.EventSchedule(singleNodeControl.getEffectiveId(), XFormsControls.EventSchedule.RELEVANT_BINDING, singleNodeControl));\n            }\n        }\n    }","commit_id":"02c34c083129b7e0b7c224450a118e0c2f501640","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Map<String, XFormsControl> getRepeatControls() {\n        return (controlTypes != null) ? controlTypes.get(\"repeat\") : null;\n    }","id":104403,"modified_method":"public Map<String, XFormsControl> getRepeatControls() {\n        return (controlTypes != null) ? controlTypes.get(XFormsConstants.REPEAT_NAME) : null;\n    }","commit_id":"02c34c083129b7e0b7c224450a118e0c2f501640","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Index a single controls.\n     *\n     * @param control           control to index\n     * @param registerEvents    whether to register a relevance event if the control is bound and relevant\n     */\n    private void indexControl(XFormsControl control, boolean registerEvents) {\n        // Remember by effective id\n        if (effectiveIdsToControls == null)\n            effectiveIdsToControls = new LinkedHashMap<String, XFormsControl>();// order is not strictly needed, but it can help debugging\n\n        effectiveIdsToControls.put(control.getEffectiveId(), control);\n\n        // Remember by control type (for certain controls we know we need)\n        if (mustMapControl(control)) {\n            if (controlTypes == null)\n                controlTypes = new HashMap<String, Map<String, XFormsControl>>();// no need for order here\n\n            Map<String, XFormsControl> controlsMap = controlTypes.get(control.getName());\n            if (controlsMap == null) {\n                controlsMap = new LinkedHashMap<String, XFormsControl>(); // need for order here!\n                controlTypes.put(control.getName(), controlsMap);\n            }\n\n            controlsMap.put(control.getEffectiveId(), control);\n        }\n\n        // Add event if necessary\n        // NOTE: We don't dispatch events to repeat iterations\n        if (registerEvents && control instanceof XFormsSingleNodeControl && !(control instanceof XFormsRepeatIterationControl)) {\n            final XFormsSingleNodeControl singleNodeControl = (XFormsSingleNodeControl) control;\n            final NodeInfo boundNode = singleNodeControl.getBoundNode();\n            if (boundNode != null && InstanceData.getInheritedRelevant(boundNode)) {\n                // Control just came to existence and is now bound to a node and relevant\n                eventsToDispatch.put(singleNodeControl.getEffectiveId(),\n                        new XFormsControls.EventSchedule(singleNodeControl.getEffectiveId(), XFormsControls.EventSchedule.RELEVANT_BINDING, singleNodeControl));\n            }\n        }\n    }","id":104404,"modified_method":"/**\n     * Index a single controls.\n     *\n     * @param control           control to index\n     * @param registerEvents    whether to register a relevance event if the control is bound and relevant\n     */\n    private void indexControl(XFormsControl control, boolean registerEvents) {\n        // Remember by effective id\n        if (effectiveIdsToControls == null)\n            effectiveIdsToControls = new LinkedHashMap<String, XFormsControl>();// order is not strictly needed, but it can help debugging\n\n        effectiveIdsToControls.put(control.getEffectiveId(), control);\n\n        // Remember by control type (for certain controls we know we need)\n        if (mustMapControlByType(control)) {\n            if (controlTypes == null)\n                controlTypes = new HashMap<String, Map<String, XFormsControl>>();// no need for order here\n\n            Map<String, XFormsControl> controlsMap = controlTypes.get(control.getName());\n            if (controlsMap == null) {\n                controlsMap = new LinkedHashMap<String, XFormsControl>(); // need for order here!\n                controlTypes.put(control.getName(), controlsMap);\n            }\n\n            controlsMap.put(control.getEffectiveId(), control);\n        }\n\n        // Add event if necessary\n        // NOTE: We don't dispatch events to repeat iterations\n        if (registerEvents && control instanceof XFormsSingleNodeControl && !(control instanceof XFormsRepeatIterationControl)) {\n            final XFormsSingleNodeControl singleNodeControl = (XFormsSingleNodeControl) control;\n            final NodeInfo boundNode = singleNodeControl.getBoundNode();\n            if (boundNode != null && InstanceData.getInheritedRelevant(boundNode)) {\n                // Control just came to existence and is now bound to a node and relevant\n                eventsToDispatch.put(singleNodeControl.getEffectiveId(),\n                        new XFormsControls.EventSchedule(singleNodeControl.getEffectiveId(), XFormsControls.EventSchedule.RELEVANT_BINDING, singleNodeControl));\n            }\n        }\n    }","commit_id":"02c34c083129b7e0b7c224450a118e0c2f501640","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Map<String, XFormsControl> getUploadControls() {\n        return (controlTypes != null) ? controlTypes.get(\"upload\") : null;\n    }","id":104405,"modified_method":"public Map<String, XFormsControl> getUploadControls() {\n        return (controlTypes != null) ? controlTypes.get(XFormsConstants.UPLOAD_NAME) : null;\n    }","commit_id":"02c34c083129b7e0b7c224450a118e0c2f501640","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private boolean mustMapControl(XFormsControl control) {\n\n        // Remember:\n        // xforms:upload\n        // xforms:repeat\n        // xforms:select[@appearance = 'full'] in noscript mode\n        return control instanceof XFormsUploadControl\n                || control instanceof XFormsRepeatControl\n                || (isNoscript && control instanceof XFormsSelectControl && ((XFormsSelectControl) control).isFullAppearance());\n    }","id":104406,"modified_method":"private boolean mustMapControlByType(XFormsControl control) {\n\n        // Remember:\n        // xforms:upload\n        // xforms:repeat\n        // xxforms:dialog\n        // xforms:select[@appearance = 'full'] in noscript mode\n        return control instanceof XFormsUploadControl\n                || control instanceof XFormsRepeatControl\n                || control instanceof XXFormsDialogControl\n                || (isNoscript && control instanceof XFormsSelectControl && ((XFormsSelectControl) control).isFullAppearance());\n    }","commit_id":"02c34c083129b7e0b7c224450a118e0c2f501640","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n\n        // Register control handlers on controller\n        {\n            final ElementHandlerController controller = handlerContext.getController();\n            controller.registerHandler(XXFormsTextHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"text\");\n        }\n\n        // Declare xmlns:f\n        formattingPrefix = handlerContext.findFormattingPrefixDeclare();\n\n        // Open head element\n        contentHandler.startElement(uri, localname, qName, attributes);\n\n        final ContentHandlerHelper helper = new ContentHandlerHelper(contentHandler);\n        final String xhtmlPrefix = XMLUtils.prefixFromQName(qName); // current prefix for XHTML\n\n        // Gather information about appearances of controls which use Script\n        // Map<String controlName, Map<String appearanceOrMediatype, List<String effectiveId>>>\n        // TODO: This would probably be done better, and more correctly, based on statically-gathered information in XFormsStaticState\n        final Map javaScriptControlsAppearancesMap = new HashMap();\n        {\n            final XFormsControls xformsControls = containingDocument.getControls();\n            xformsControls.visitAllControls(new XFormsControls.XFormsControlVisitorListener() {\n                public void startVisitControl(XFormsControl control) {\n                    final String controlName = control.getName();\n\n                    // Don't run JavaScript initialization if the control is static readonly (could change in the\n                    // future if some static readonly controls require JS initialization)\n                    final boolean hasJavaScriptInitialization = control.hasJavaScriptInitialization() && !control.isStaticReadonly();\n                    if (hasJavaScriptInitialization) {\n                        Map listForControlNameMap = (Map) javaScriptControlsAppearancesMap.get(controlName);\n                        if (listForControlNameMap == null) {\n                            listForControlNameMap = new HashMap();\n                            javaScriptControlsAppearancesMap.put(control.getName(), listForControlNameMap);\n                        }\n                        final String controlAppearanceOrMediatype;\n                        {\n                            final String controlAppearance = control.getAppearance();\n                            controlAppearanceOrMediatype = (controlAppearance != null) ? controlAppearance : control.getMediatype();\n                        }\n\n                        List idsForAppearanceOrMediatypeList = (List) listForControlNameMap.get(controlAppearanceOrMediatype);\n                        if (idsForAppearanceOrMediatypeList == null) {\n                            idsForAppearanceOrMediatypeList = new ArrayList();\n                            listForControlNameMap.put(controlAppearanceOrMediatype, idsForAppearanceOrMediatypeList);\n                        }\n                        idsForAppearanceOrMediatypeList.add(control.getEffectiveId());\n                    }\n                }\n\n                public void endVisitControl(XFormsControl xformsControl) {}\n            });\n        }\n\n        // Create prefix for combined resources if needed\n        final boolean isMinimal = XFormsProperties.isMinimalResources(containingDocument);\n        final boolean isVersionedResources = URLRewriterUtils.isResourcesVersioned();\n        final String combinedResourcesPrefix = XFormsFeatures.getCombinedResourcesPrefix(containingDocument, javaScriptControlsAppearancesMap, isMinimal, isVersionedResources);\n\n        final boolean isCombineResources = XFormsProperties.isCombinedResources(containingDocument);\n        final boolean isCacheCombinedResources = isCombineResources && XFormsProperties.isCacheCombinedResources();\n\n        final IndentedLogger resourcesIndentedLogger = XFormsResourceServer.getIndentedLogger();\n        if (isCombineResources) {\n            resourcesIndentedLogger.logDebug(\"\", \"creating xhtml:head with combined resources\");\n            if (isCacheCombinedResources) {\n                resourcesIndentedLogger.logDebug(\"\", \"attempting to cache combined resources\");\n            }\n        }\n\n        // Stylesheets\n        final AttributesImpl attributesImpl = new AttributesImpl();\n        {\n            // Main CSS resources\n            if (isCombineResources) {\n                final String combinedResourceName = combinedResourcesPrefix + \".css\";\n\n                attributesImpl.clear();\n                final String[] attributesList = new String[] { \"rel\", \"stylesheet\", \"href\", combinedResourceName, \"type\", \"text/css\", \"media\", \"all\" };\n                ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"link\", attributesImpl);\n\n                if (isCacheCombinedResources) {\n                    // Attempt to cache combined resources\n                    // Do it at this point so that deployments using an HTTP server front-end can access the resource on disk directly\n                    final List<XFormsFeatures.ResourceConfig> resources = XFormsFeatures.getCSSResources(containingDocument, javaScriptControlsAppearancesMap);\n                    final long combinedLastModified = XFormsResourceServer.computeCombinedLastModified(resources, isMinimal);\n                    XFormsResourceServer.cacheResources(resourcesIndentedLogger, resources, pipelineContext, combinedResourceName, combinedLastModified, true, isMinimal);\n                }\n            } else {\n                for (final XFormsFeatures.ResourceConfig resourceConfig: XFormsFeatures.getCSSResources(containingDocument, javaScriptControlsAppearancesMap)) {\n                    // Only include stylesheet if needed\n                    attributesImpl.clear();\n                    final String[] attributesList = new String[]{\"rel\", \"stylesheet\", \"href\", resourceConfig.getResourcePath(isMinimal), \"type\", \"text/css\", \"media\", \"all\"};\n                    ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                    helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"link\", attributesImpl);\n                }\n            }\n\n            // XBL resources\n            final List<Element> xblStyles = containingDocument.getStaticState().getXblBindings().getXBLStyles();\n            if (xblStyles != null) {\n                for (final Element styleElement: xblStyles) {\n                    attributesImpl.clear();\n                    if (styleElement.attributeValue(\"src\") != null) {\n                        // xhtml:link\n                        final String[] attributesList = new String[]{\"rel\", \"stylesheet\", \"href\", styleElement.attributeValue(\"src\"), \"type\", \"text/css\", \"media\", styleElement.attributeValue(\"media\")};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"link\", attributesImpl);\n                    } else {\n                        // xhtml:style\n                        final String[] attributesList = new String[]{\"rel\", \"stylesheet\", \"type\", \"text/css\", \"media\", styleElement.attributeValue(\"media\")};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"style\", attributesImpl);\n                        helper.text(styleElement.getText());\n                        helper.endElement();\n                    }\n                }\n            }\n        }\n\n        // Scripts\n        // TODO: Have option to put this at the bottom of the page. See theme-plain.xsl and http://developer.yahoo.com/performance/rules.html#js_bottom -->\n        if (!handlerContext.isNoScript() && !XFormsProperties.isReadonly(containingDocument)) {\n\n            // Main JavaScript resources\n            if (isCombineResources) {\n                final String combinedResourceName = combinedResourcesPrefix + \".js\";\n\n                attributesImpl.clear();\n                final String[] attributesList = new String[] { \"type\", \"text/javascript\", \"src\", combinedResourceName };\n                ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n\n                if (isCacheCombinedResources) {\n                    // Attempt to cache combined resources\n                    // Do it at this point so that deployments using an HTTP server front-end can access the resource on disk directly\n                    final List<XFormsFeatures.ResourceConfig> resources = XFormsFeatures.getJavaScriptResources(containingDocument, javaScriptControlsAppearancesMap);\n                    final long combinedLastModified = XFormsResourceServer.computeCombinedLastModified(resources, isMinimal);\n                    XFormsResourceServer.cacheResources(resourcesIndentedLogger, resources, pipelineContext, combinedResourceName, combinedLastModified, false, isMinimal);\n                }\n\n            } else {\n                for (final XFormsFeatures.ResourceConfig resourceConfig: XFormsFeatures.getJavaScriptResources(containingDocument, javaScriptControlsAppearancesMap)) {\n                    // Only include stylesheet if needed\n                    attributesImpl.clear();\n                    final String[] attributesList = new String[]{\"type\", \"text/javascript\", \"src\", resourceConfig.getResourcePath(isMinimal)};\n                    ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                    helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n                }\n            }\n\n            // XBL scripts\n            final List<Element> xblScripts = containingDocument.getStaticState().getXblBindings().getXBLScripts();\n            if (xblScripts != null) {\n                for (final Element scriptElement: xblScripts) {\n                    attributesImpl.clear();\n                    if (scriptElement.attributeValue(\"src\") != null) {\n                        // xhtml:script with @src\n                        final String[] attributesList = new String[]{\"type\", \"text/javascript\", \"src\", scriptElement.attributeValue(\"src\")};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n                    } else {\n                        // xhtml:script without @src\n                        final String[] attributesList = new String[]{\"type\", \"text/javascript\"};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n                        helper.text(scriptElement.getText());\n                        helper.endElement();\n                    }\n                }\n            }\n\n            // Configuration properties\n            {\n                final Map clientPropertiesMap;\n                {\n                    // Dynamic properties\n                    final Map<String, Object> dynamicProperties = new HashMap<String, Object>();\n                    {\n                        // Heartbeat delay\n                        {\n                            final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(XFormsProperties.SESSION_HEARTBEAT_DELAY_PROPERTY);\n                            final long heartbeatDelay = XFormsStateManager.getHeartbeatDelay(containingDocument, handlerContext.getExternalContext());\n                            if (heartbeatDelay != ((Number) propertyDefinition.getDefaultValue()).longValue())\n                                dynamicProperties.put(XFormsProperties.SESSION_HEARTBEAT_DELAY_PROPERTY, heartbeatDelay);\n                        }\n\n                        // Produce JavaScript paths for use on the client\n                        {\n                            // FCKeditor path\n                            {\n                                final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(XFormsProperties.FCK_EDITOR_BASE_PATH_PROPERTY);\n                                final String fckEditorPath = isVersionedResources ? \"/\" + Version.getVersion() + propertyDefinition.getDefaultValue() : (String) propertyDefinition.getDefaultValue();\n                                if (!fckEditorPath.equals(propertyDefinition.getDefaultValue()))\n                                    dynamicProperties.put(XFormsProperties.FCK_EDITOR_BASE_PATH_PROPERTY, fckEditorPath);\n                            }\n                        }\n\n                        // Help events\n                        {\n                            final boolean hasHandlerForXFormsHelp = containingDocument.getControls().hasHandlerForEvent(XFormsEvents.XFORMS_HELP);\n                            if (hasHandlerForXFormsHelp) {\n                                dynamicProperties.put(XFormsProperties.HELP_HANDLER_PROPERTY, Boolean.TRUE);\n                            }\n                        }\n\n                        // Application version\n                        {\n                            // This is not an XForms property but we want to expose it on the client\n                            if (isVersionedResources != URLRewriterUtils.RESOURCES_VERSIONED_DEFAULT)\n                                dynamicProperties.put(URLRewriterUtils.RESOURCES_VERSIONED_PROPERTY, Boolean.toString(isVersionedResources));\n\n                            if (isVersionedResources) {\n                                final String applicationVersion = URLRewriterUtils.getApplicationResourceVersion();\n                                if (applicationVersion != null) {\n                                    // This is not an XForms property but we want to expose it on the client \n                                    dynamicProperties.put(URLRewriterUtils.RESOURCES_VERSION_NUMBER_PROPERTY, applicationVersion);\n                                }\n                            }\n                        }\n\n                        // Offline mode\n//                        if (containingDocument.getStaticState().isHasOfflineSupport()) {\n//                            dynamicProperties.put(XFormsProperties.OFFLINE_SUPPORT_PROPERTY, Boolean.TRUE);\n//                        }\n                    }\n\n                    final Map nonDefaultProperties = containingDocument.getStaticState().getNonDefaultProperties();\n                    clientPropertiesMap = new CompositeMap(new Map[] { nonDefaultProperties, dynamicProperties });\n                }\n                \n                FastStringBuffer sb = null;\n                if (clientPropertiesMap.size() > 0) {\n\n                    for (Object o: clientPropertiesMap.entrySet()) {\n                        final Map.Entry currentEntry = (Map.Entry) o;\n                        final String propertyName = (String) currentEntry.getKey();\n                        final Object propertyValue = currentEntry.getValue();\n\n                        final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(propertyName);\n                        if (propertyDefinition != null && propertyDefinition.isPropagateToClient()\n                                || URLRewriterUtils.RESOURCES_VERSION_NUMBER_PROPERTY.equals(propertyName)\n                                || URLRewriterUtils.RESOURCES_VERSIONED_PROPERTY.equals(propertyName)) {\n\n                            if (sb == null) {\n                                // First property found\n                                helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", new String[]{\n                                        \"type\", \"text/javascript\"});\n                                sb = new FastStringBuffer(\"var opsXFormsProperties = {\");\n                            } else {\n                                // Subsequent property found\n                                sb.append(',');\n                            }\n\n                            sb.append('\\\"');\n                            sb.append(propertyName);\n                            sb.append(\"\\\":\");\n                            if (propertyValue instanceof String) {\n                                // This is a string, add quotes\n                                sb.append('\\\"');\n                                sb.append(propertyValue.toString());\n                                sb.append('\\\"');\n                            } else {\n                                // Don't need quotes\n                                sb.append(propertyValue.toString());\n                            }\n                        }\n                    }\n\n                    if (sb != null) {\n                        // Close everything\n                        sb.append(\"};\");\n                        helper.text(sb.toString());\n                        helper.endElement();\n                    }\n                }\n            }\n\n            // User-defined scripts (with xxforms:script)\n            final Map<String, String> scriptsToDeclare = containingDocument.getScripts();\n            final String focusElementId = containingDocument.getClientFocusEffectiveControlId();\n            final List<XFormsContainingDocument.Message> messagesToRun = containingDocument.getMessagesToRun();\n            if (scriptsToDeclare != null || focusElementId != null || messagesToRun != null) {\n                helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", new String[] {\n                    \"type\", \"text/javascript\"});\n\n                if (scriptsToDeclare != null) {\n                    for (final Map.Entry<String, String> currentEntry: scriptsToDeclare.entrySet()) {\n                        helper.text(\"\\nfunction \" + XFormsUtils.scriptIdToScriptName(currentEntry.getKey()) + \"(event) {\\n\");\n                        helper.text(currentEntry.getValue());\n                        helper.text(\"}\\n\");\n                    }\n                }\n\n                final List<XFormsContainingDocument.Script> scriptsToRun = containingDocument.getScriptsToRun();\n\n                if (focusElementId != null || scriptsToRun != null || messagesToRun != null) {\n                    final FastStringBuffer sb = new FastStringBuffer(\"\\nfunction xformsPageLoadedServer() { \");\n\n                    // Initial setfocus if present\n                    if (focusElementId != null) {\n                        sb.append(\"ORBEON.xforms.Controls.setFocus(\\\"\");\n                        sb.append(focusElementId);\n                        sb.append(\"\\\");\");\n                    }\n\n                    // Initial xxforms:script executions if present\n                    if (scriptsToRun != null) {\n                        for (final XFormsContainingDocument.Script script: scriptsToRun) {\n                            sb.append(\"ORBEON.xforms.Server.callUserScript(\\\"\");\n                            sb.append(script.getFunctionName());\n                            sb.append(\"\\\",\\\"\");\n                            sb.append(script.getEventTargetId());\n                            sb.append(\"\\\",\\\"\");\n                            sb.append(script.getEventObserverId());\n                            sb.append(\"\\\");\");\n                        }\n                    }\n\n                    // Initial xforms:message to run if present\n                    if (messagesToRun != null) {\n                        for (final XFormsContainingDocument.Message message: messagesToRun) {\n                            if (\"modal\".equals(message.getLevel())) {\n                                // TODO: should not call directly alert() but a client-side method\n                                sb.append(\"alert(\\\"\");\n                                sb.append(XFormsUtils.escapeJavaScript(message.getMessage()));\n                                sb.append(\"\\\");\");\n                            }\n                        }\n                    }\n\n                    sb.append(\" }\");\n\n                    helper.text(sb.toString());\n                }\n\n                helper.endElement();\n            }\n\n            // Store information about \"special\" controls that need JavaScript initialization\n            {\n                helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", new String[] {\n                        \"type\", \"text/javascript\"});\n\n                // Produce JSON output\n                if (javaScriptControlsAppearancesMap.size() > 0) {\n                    final FastStringBuffer sb = new FastStringBuffer(\"var opsXFormsControls = {\\\"controls\\\":{\");\n\n                    for (Iterator i = javaScriptControlsAppearancesMap.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry1 = (Map.Entry) i.next();\n                        final String controlName = (String) currentEntry1.getKey();\n                        final Map controlMap = (Map) currentEntry1.getValue();\n\n                        sb.append(\"\\\"\");\n                        sb.append(controlName);\n                        sb.append(\"\\\":{\");\n\n                        for (Iterator j = controlMap.entrySet().iterator(); j.hasNext();) {\n                            final Map.Entry currentEntry2 = (Map.Entry) j.next();\n                            final String controlAppearance = (String) currentEntry2.getKey();\n                            final List idsForAppearanceList = (List) currentEntry2.getValue();\n\n                            sb.append('\"');\n                            sb.append(controlAppearance != null ? controlAppearance : \"\");\n                            sb.append(\"\\\":[\");\n\n                            for (Iterator k = idsForAppearanceList.iterator(); k.hasNext();) {\n                                final String controlId = (String) k.next();\n                                sb.append('\"');\n                                sb.append(controlId);\n                                sb.append('\"');\n                                if (k.hasNext())\n                                    sb.append(',');\n                            }\n\n                            sb.append(']');\n                            if (j.hasNext())\n                                sb.append(',');\n                        }\n\n                        sb.append(\"}\");\n                        if (i.hasNext())\n                            sb.append(',');\n                    }\n\n                    sb.append(\"}};\");\n\n                    helper.text(sb.toString());\n                }\n\n                helper.endElement();\n            }\n        }\n    }","id":104407,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n\n        // Register control handlers on controller\n        {\n            final ElementHandlerController controller = handlerContext.getController();\n            controller.registerHandler(XXFormsTextHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"text\");\n        }\n\n        // Declare xmlns:f\n        formattingPrefix = handlerContext.findFormattingPrefixDeclare();\n\n        // Open head element\n        contentHandler.startElement(uri, localname, qName, attributes);\n\n        final ContentHandlerHelper helper = new ContentHandlerHelper(contentHandler);\n        final String xhtmlPrefix = XMLUtils.prefixFromQName(qName); // current prefix for XHTML\n\n        // Gather information about appearances of controls which use Script\n        // Map<String controlName, Map<String appearanceOrMediatype, List<String effectiveId>>>\n        // TODO: This would probably be done better, and more correctly, based on statically-gathered information in XFormsStaticState\n        final Map<String, Map<String, List<String>>> javaScriptControlsAppearancesMap = new HashMap<String, Map<String, List<String>>>();\n        {\n            final XFormsControls xformsControls = containingDocument.getControls();\n            xformsControls.visitAllControls(new XFormsControls.XFormsControlVisitorListener() {\n                public void startVisitControl(XFormsControl control) {\n                    final String controlName = control.getName();\n\n                    // Don't run JavaScript initialization if the control is static readonly (could change in the\n                    // future if some static readonly controls require JS initialization)\n                    final boolean hasJavaScriptInitialization = control.hasJavaScriptInitialization() && !control.isStaticReadonly();\n                    if (hasJavaScriptInitialization) {\n                        Map<String, List<String>> listForControlNameMap = javaScriptControlsAppearancesMap.get(controlName);\n                        if (listForControlNameMap == null) {\n                            listForControlNameMap = new HashMap<String, List<String>>();\n                            javaScriptControlsAppearancesMap.put(control.getName(), listForControlNameMap);\n                        }\n                        final String controlAppearanceOrMediatype;\n                        {\n                            final String controlAppearance = control.getAppearance();\n                            controlAppearanceOrMediatype = (controlAppearance != null) ? controlAppearance : control.getMediatype();\n                        }\n\n                        List<String> idsForAppearanceOrMediatypeList = listForControlNameMap.get(controlAppearanceOrMediatype);\n                        if (idsForAppearanceOrMediatypeList == null) {\n                            idsForAppearanceOrMediatypeList = new ArrayList<String>();\n                            listForControlNameMap.put(controlAppearanceOrMediatype, idsForAppearanceOrMediatypeList);\n                        }\n                        idsForAppearanceOrMediatypeList.add(control.getEffectiveId());\n                    }\n                }\n\n                public void endVisitControl(XFormsControl xformsControl) {}\n            });\n        }\n\n        // Create prefix for combined resources if needed\n        final boolean isMinimal = XFormsProperties.isMinimalResources(containingDocument);\n        final boolean isVersionedResources = URLRewriterUtils.isResourcesVersioned();\n        final String combinedResourcesPrefix = XFormsFeatures.getCombinedResourcesPrefix(containingDocument, javaScriptControlsAppearancesMap, isMinimal, isVersionedResources);\n\n        final boolean isCombineResources = XFormsProperties.isCombinedResources(containingDocument);\n        final boolean isCacheCombinedResources = isCombineResources && XFormsProperties.isCacheCombinedResources();\n\n        final IndentedLogger resourcesIndentedLogger = XFormsResourceServer.getIndentedLogger();\n        if (isCombineResources) {\n            resourcesIndentedLogger.logDebug(\"\", \"creating xhtml:head with combined resources\");\n            if (isCacheCombinedResources) {\n                resourcesIndentedLogger.logDebug(\"\", \"attempting to cache combined resources\");\n            }\n        }\n\n        // Stylesheets\n        final AttributesImpl attributesImpl = new AttributesImpl();\n        {\n            // Main CSS resources\n            if (isCombineResources) {\n                final String combinedResourceName = combinedResourcesPrefix + \".css\";\n\n                attributesImpl.clear();\n                final String[] attributesList = new String[] { \"rel\", \"stylesheet\", \"href\", combinedResourceName, \"type\", \"text/css\", \"media\", \"all\" };\n                ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"link\", attributesImpl);\n\n                if (isCacheCombinedResources) {\n                    // Attempt to cache combined resources\n                    // Do it at this point so that deployments using an HTTP server front-end can access the resource on disk directly\n                    final List<XFormsFeatures.ResourceConfig> resources = XFormsFeatures.getCSSResources(containingDocument, javaScriptControlsAppearancesMap);\n                    final long combinedLastModified = XFormsResourceServer.computeCombinedLastModified(resources, isMinimal);\n                    XFormsResourceServer.cacheResources(resourcesIndentedLogger, resources, pipelineContext, combinedResourceName, combinedLastModified, true, isMinimal);\n                }\n            } else {\n                for (final XFormsFeatures.ResourceConfig resourceConfig: XFormsFeatures.getCSSResources(containingDocument, javaScriptControlsAppearancesMap)) {\n                    // Only include stylesheet if needed\n                    attributesImpl.clear();\n                    final String[] attributesList = new String[]{\"rel\", \"stylesheet\", \"href\", resourceConfig.getResourcePath(isMinimal), \"type\", \"text/css\", \"media\", \"all\"};\n                    ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                    helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"link\", attributesImpl);\n                }\n            }\n\n            // XBL resources\n            final List<Element> xblStyles = containingDocument.getStaticState().getXblBindings().getXBLStyles();\n            if (xblStyles != null) {\n                for (final Element styleElement: xblStyles) {\n                    attributesImpl.clear();\n                    if (styleElement.attributeValue(\"src\") != null) {\n                        // xhtml:link\n                        final String[] attributesList = new String[]{\"rel\", \"stylesheet\", \"href\", styleElement.attributeValue(\"src\"), \"type\", \"text/css\", \"media\", styleElement.attributeValue(\"media\")};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"link\", attributesImpl);\n                    } else {\n                        // xhtml:style\n                        final String[] attributesList = new String[]{\"rel\", \"stylesheet\", \"type\", \"text/css\", \"media\", styleElement.attributeValue(\"media\")};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"style\", attributesImpl);\n                        helper.text(styleElement.getText());\n                        helper.endElement();\n                    }\n                }\n            }\n        }\n\n        // Scripts\n        // TODO: Have option to put this at the bottom of the page. See theme-plain.xsl and http://developer.yahoo.com/performance/rules.html#js_bottom -->\n        if (!handlerContext.isNoScript() && !XFormsProperties.isReadonly(containingDocument)) {\n\n            // Main JavaScript resources\n            if (isCombineResources) {\n                final String combinedResourceName = combinedResourcesPrefix + \".js\";\n\n                attributesImpl.clear();\n                final String[] attributesList = new String[] { \"type\", \"text/javascript\", \"src\", combinedResourceName };\n                ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n\n                if (isCacheCombinedResources) {\n                    // Attempt to cache combined resources\n                    // Do it at this point so that deployments using an HTTP server front-end can access the resource on disk directly\n                    final List<XFormsFeatures.ResourceConfig> resources = XFormsFeatures.getJavaScriptResources(containingDocument, javaScriptControlsAppearancesMap);\n                    final long combinedLastModified = XFormsResourceServer.computeCombinedLastModified(resources, isMinimal);\n                    XFormsResourceServer.cacheResources(resourcesIndentedLogger, resources, pipelineContext, combinedResourceName, combinedLastModified, false, isMinimal);\n                }\n\n            } else {\n                for (final XFormsFeatures.ResourceConfig resourceConfig: XFormsFeatures.getJavaScriptResources(containingDocument, javaScriptControlsAppearancesMap)) {\n                    // Only include stylesheet if needed\n                    attributesImpl.clear();\n                    final String[] attributesList = new String[]{\"type\", \"text/javascript\", \"src\", resourceConfig.getResourcePath(isMinimal)};\n                    ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                    helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n                }\n            }\n\n            // XBL scripts\n            final List<Element> xblScripts = containingDocument.getStaticState().getXblBindings().getXBLScripts();\n            if (xblScripts != null) {\n                for (final Element scriptElement: xblScripts) {\n                    attributesImpl.clear();\n                    if (scriptElement.attributeValue(\"src\") != null) {\n                        // xhtml:script with @src\n                        final String[] attributesList = new String[]{\"type\", \"text/javascript\", \"src\", scriptElement.attributeValue(\"src\")};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.element(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n                    } else {\n                        // xhtml:script without @src\n                        final String[] attributesList = new String[]{\"type\", \"text/javascript\"};\n                        ContentHandlerHelper.populateAttributes(attributesImpl, attributesList);\n                        helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", attributesImpl);\n                        helper.text(scriptElement.getText());\n                        helper.endElement();\n                    }\n                }\n            }\n\n            // Configuration properties\n            {\n                final Map clientPropertiesMap;\n                {\n                    // Dynamic properties\n                    final Map<String, Object> dynamicProperties = new HashMap<String, Object>();\n                    {\n                        // Heartbeat delay\n                        {\n                            final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(XFormsProperties.SESSION_HEARTBEAT_DELAY_PROPERTY);\n                            final long heartbeatDelay = XFormsStateManager.getHeartbeatDelay(containingDocument, handlerContext.getExternalContext());\n                            if (heartbeatDelay != ((Number) propertyDefinition.getDefaultValue()).longValue())\n                                dynamicProperties.put(XFormsProperties.SESSION_HEARTBEAT_DELAY_PROPERTY, heartbeatDelay);\n                        }\n\n                        // Produce JavaScript paths for use on the client\n                        {\n                            // FCKeditor path\n                            {\n                                final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(XFormsProperties.FCK_EDITOR_BASE_PATH_PROPERTY);\n                                final String fckEditorPath = isVersionedResources ? \"/\" + Version.getVersion() + propertyDefinition.getDefaultValue() : (String) propertyDefinition.getDefaultValue();\n                                if (!fckEditorPath.equals(propertyDefinition.getDefaultValue()))\n                                    dynamicProperties.put(XFormsProperties.FCK_EDITOR_BASE_PATH_PROPERTY, fckEditorPath);\n                            }\n                        }\n\n                        // Help events\n                        {\n                            final boolean hasHandlerForXFormsHelp = containingDocument.getControls().hasHandlerForEvent(XFormsEvents.XFORMS_HELP);\n                            if (hasHandlerForXFormsHelp) {\n                                dynamicProperties.put(XFormsProperties.HELP_HANDLER_PROPERTY, Boolean.TRUE);\n                            }\n                        }\n\n                        // Application version\n                        {\n                            // This is not an XForms property but we want to expose it on the client\n                            if (isVersionedResources != URLRewriterUtils.RESOURCES_VERSIONED_DEFAULT)\n                                dynamicProperties.put(URLRewriterUtils.RESOURCES_VERSIONED_PROPERTY, Boolean.toString(isVersionedResources));\n\n                            if (isVersionedResources) {\n                                final String applicationVersion = URLRewriterUtils.getApplicationResourceVersion();\n                                if (applicationVersion != null) {\n                                    // This is not an XForms property but we want to expose it on the client \n                                    dynamicProperties.put(URLRewriterUtils.RESOURCES_VERSION_NUMBER_PROPERTY, applicationVersion);\n                                }\n                            }\n                        }\n\n                        // Offline mode\n//                        if (containingDocument.getStaticState().isHasOfflineSupport()) {\n//                            dynamicProperties.put(XFormsProperties.OFFLINE_SUPPORT_PROPERTY, Boolean.TRUE);\n//                        }\n                    }\n\n                    final Map<String, Object> nonDefaultProperties = containingDocument.getStaticState().getNonDefaultProperties();\n                    clientPropertiesMap = new CompositeMap(new Map[] { nonDefaultProperties, dynamicProperties });\n                }\n                \n                StringBuilder sb = null;\n                if (clientPropertiesMap.size() > 0) {\n\n                    for (Object o: clientPropertiesMap.entrySet()) {\n                        final Map.Entry currentEntry = (Map.Entry) o;\n                        final String propertyName = (String) currentEntry.getKey();\n                        final Object propertyValue = currentEntry.getValue();\n\n                        final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(propertyName);\n                        if (propertyDefinition != null && propertyDefinition.isPropagateToClient()\n                                || URLRewriterUtils.RESOURCES_VERSION_NUMBER_PROPERTY.equals(propertyName)\n                                || URLRewriterUtils.RESOURCES_VERSIONED_PROPERTY.equals(propertyName)) {\n\n                            if (sb == null) {\n                                // First property found\n                                helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", new String[]{\n                                        \"type\", \"text/javascript\"});\n                                sb = new StringBuilder(\"var opsXFormsProperties = {\");\n                            } else {\n                                // Subsequent property found\n                                sb.append(',');\n                            }\n\n                            sb.append('\\\"');\n                            sb.append(propertyName);\n                            sb.append(\"\\\":\");\n                            if (propertyValue instanceof String) {\n                                // This is a string, add quotes\n                                sb.append('\\\"');\n                                sb.append(propertyValue.toString());\n                                sb.append('\\\"');\n                            } else {\n                                // Don't need quotes\n                                sb.append(propertyValue.toString());\n                            }\n                        }\n                    }\n\n                    if (sb != null) {\n                        // Close everything\n                        sb.append(\"};\");\n                        helper.text(sb.toString());\n                        helper.endElement();\n                    }\n                }\n            }\n\n            // User-defined scripts (with xxforms:script)\n            final Map<String, String> scriptsToDeclare = containingDocument.getScripts();\n            final String focusElementId = containingDocument.getClientFocusEffectiveControlId();\n            final List<XFormsContainingDocument.Message> messagesToRun = containingDocument.getMessagesToRun();\n            final List<XXFormsDialogControl> dialogsToOpen = new ArrayList<XXFormsDialogControl>(); {\n                final Map<String, XFormsControl> dialogsMap = containingDocument.getControls().getCurrentControlTree().getDialogControls();\n                if (dialogsMap != null && dialogsMap.size() > 0) {\n                    for (final XFormsControl control: dialogsMap.values()) {\n                        final XXFormsDialogControl dialogControl = (XXFormsDialogControl) control;\n                        if (dialogControl.isVisible()) {\n                            dialogsToOpen.add(dialogControl);\n                        }\n                    }\n                }\n            }\n            if (scriptsToDeclare != null || focusElementId != null || messagesToRun != null || dialogsToOpen.size() > 0) {\n                helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", new String[] {\n                    \"type\", \"text/javascript\"});\n\n                if (scriptsToDeclare != null) {\n                    for (final Map.Entry<String, String> currentEntry: scriptsToDeclare.entrySet()) {\n                        helper.text(\"\\nfunction \" + XFormsUtils.scriptIdToScriptName(currentEntry.getKey()) + \"(event) {\\n\");\n                        helper.text(currentEntry.getValue());\n                        helper.text(\"}\\n\");\n                    }\n                }\n\n                final List<XFormsContainingDocument.Script> scriptsToRun = containingDocument.getScriptsToRun();\n\n                if (scriptsToRun != null || focusElementId != null || messagesToRun != null || dialogsToOpen.size() > 0) {\n                    final StringBuilder sb = new StringBuilder(\"\\nfunction xformsPageLoadedServer() { \");\n\n                    // Initial setfocus if present\n                    if (focusElementId != null) {\n                        sb.append(\"ORBEON.xforms.Controls.setFocus(\\\"\");\n                        sb.append(focusElementId);\n                        sb.append(\"\\\");\");\n                    }\n\n                    // Initial xxforms:script executions if present\n                    if (scriptsToRun != null) {\n                        for (final XFormsContainingDocument.Script script: scriptsToRun) {\n                            sb.append(\"ORBEON.xforms.Server.callUserScript(\\\"\");\n                            sb.append(script.getFunctionName());\n                            sb.append(\"\\\",\\\"\");\n                            sb.append(script.getEventTargetId());\n                            sb.append(\"\\\",\\\"\");\n                            sb.append(script.getEventObserverId());\n                            sb.append(\"\\\");\");\n                        }\n                    }\n\n                    // Initial xforms:message to run if present\n                    if (messagesToRun != null) {\n                        for (final XFormsContainingDocument.Message message: messagesToRun) {\n                            if (\"modal\".equals(message.getLevel())) {\n                                // TODO: should not call directly alert() but a client-side method\n                                sb.append(\"alert(\\\"\");\n                                sb.append(XFormsUtils.escapeJavaScript(message.getMessage()));\n                                sb.append(\"\\\");\");\n                            }\n                        }\n                    }\n\n                    // Initial dialogs to open\n                    if (dialogsToOpen.size() > 0) {\n                        for (final XXFormsDialogControl dialogControl: dialogsToOpen) {\n                            sb.append(\"ORBEON.xforms.Controls.showDialog(\\\"\");\n                            sb.append(dialogControl.getEffectiveId());\n                            sb.append(\"\\\", \");\n                            if (dialogControl.getNeighborControlId() != null) {\n                                sb.append('\"');\n                                sb.append(dialogControl.getNeighborControlId());\n                                sb.append('\"');\n                            } else {\n                                sb.append(\"null\");\n                            }\n                            sb.append(\");\");\n                        }\n                    }\n\n                    sb.append(\" }\");\n\n                    helper.text(sb.toString());\n                }\n\n                helper.endElement();\n            }\n\n            // Store information about \"special\" controls that need JavaScript initialization\n            {\n                helper.startElement(xhtmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"script\", new String[] {\n                        \"type\", \"text/javascript\"});\n\n                // Produce JSON output\n                if (javaScriptControlsAppearancesMap.size() > 0) {\n                    final StringBuilder sb = new StringBuilder(\"var opsXFormsControls = {\\\"controls\\\":{\");\n\n                    for (Iterator<Map.Entry<String,Map<String,List<String>>>> i = javaScriptControlsAppearancesMap.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry<String,Map<String,List<String>>> currentEntry1 = i.next();\n                        final String controlName = currentEntry1.getKey();\n                        final Map<String, List<String>> controlMap = currentEntry1.getValue();\n\n                        sb.append(\"\\\"\");\n                        sb.append(controlName);\n                        sb.append(\"\\\":{\");\n\n                        for (Iterator<Map.Entry<String,List<String>>> j = controlMap.entrySet().iterator(); j.hasNext();) {\n                            final Map.Entry<String,List<String>> currentEntry2 = j.next();\n                            final String controlAppearance = currentEntry2.getKey();\n                            final List<String> idsForAppearanceList = currentEntry2.getValue();\n\n                            sb.append('\"');\n                            sb.append(controlAppearance != null ? controlAppearance : \"\");\n                            sb.append(\"\\\":[\");\n\n                            for (Iterator<String> k = idsForAppearanceList.iterator(); k.hasNext();) {\n                                final String controlId = k.next();\n                                sb.append('\"');\n                                sb.append(controlId);\n                                sb.append('\"');\n                                if (k.hasNext())\n                                    sb.append(',');\n                            }\n\n                            sb.append(']');\n                            if (j.hasNext())\n                                sb.append(',');\n                        }\n\n                        sb.append(\"}\");\n                        if (i.hasNext())\n                            sb.append(',');\n                    }\n\n                    sb.append(\"}};\");\n\n                    helper.text(sb.toString());\n                }\n\n                helper.endElement();\n            }\n        }\n    }","commit_id":"02c34c083129b7e0b7c224450a118e0c2f501640","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n\t * Make a new AssessmentGradingData object for delivery\n\t * \n\t * @param publishedAssessment\n\t *            the PublishedAssessmentFacade\n\t * @param delivery\n\t *            the DeliveryBean\n\t * @param itemGradingHash\n\t *            the item data\n\t * @return\n\t */\n\tprivate AssessmentGradingData makeNewAssessmentGrading(\n\t\t\tPublishedAssessmentFacade publishedAssessment,\n\t\t\tDeliveryBean delivery, HashSet itemGradingHash) {\n\t\tPersonBean person = (PersonBean) ContextUtil.lookupBean(\"person\");\n\t\tAssessmentGradingData adata = new AssessmentGradingData();\n\t\tadata.setAgentId(person.getId());\n\t\tadata.setPublishedAssessmentId(publishedAssessment\n\t\t\t\t.getPublishedAssessmentId());\n\t\tadata.setForGrade(Boolean.valueOf(delivery.getForGrade()));\n\t\tadata.setItemGradingSet(itemGradingHash);\n\t\tadata.setAttemptDate(new Date());\n\t\tadata.setIsLate(Boolean.FALSE);\n\t\tadata.setStatus(Integer.valueOf(0));\n\t\tadata.setTotalOverrideScore(Float.valueOf(0));\n\t\tadata.setTimeElapsed(Integer.valueOf(\"0\"));\n\t\treturn adata;\n\t}","id":104408,"modified_method":"/**\n\t * Make a new AssessmentGradingData object for delivery\n\t * \n\t * @param publishedAssessment\n\t *            the PublishedAssessmentFacade\n\t * @param delivery\n\t *            the DeliveryBean\n\t * @param itemGradingHash\n\t *            the item data\n\t * @return\n\t */\n\tprivate AssessmentGradingData makeNewAssessmentGrading(\n\t\t\tPublishedAssessmentFacade publishedAssessment,\n\t\t\tDeliveryBean delivery, HashSet<ItemGradingData> itemGradingHash) {\n\t\tPersonBean person = (PersonBean) ContextUtil.lookupBean(\"person\");\n\t\tAssessmentGradingData adata = new AssessmentGradingData();\n\t\tadata.setAgentId(person.getId());\n\t\tadata.setPublishedAssessmentId(publishedAssessment\n\t\t\t\t.getPublishedAssessmentId());\n\t\tadata.setForGrade(Boolean.valueOf(delivery.getForGrade()));\n\t\tadata.setItemGradingSet(itemGradingHash);\n\t\tadata.setAttemptDate(new Date());\n\t\tadata.setIsLate(Boolean.FALSE);\n\t\tadata.setStatus(Integer.valueOf(0));\n\t\tadata.setTotalOverrideScore(Float.valueOf(0));\n\t\tadata.setTimeElapsed(Integer.valueOf(\"0\"));\n\t\treturn adata;\n\t}","commit_id":"ecd216f6e1f73b38e582e782e10c7ba4f2613703","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void prepareItemGradingPerItem(ActionEvent ae, DeliveryBean delivery,\n\t\t\tItemContentsBean item, HashSet adds, HashSet removes) {\n\t\tArrayList grading = item.getItemGradingDataArray();\n\t\tint typeId = item.getItemData().getTypeId().intValue();\n\t\t\n\t\t//no matter what kinds of type questions, if it marks as review, add it in.\n\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\tif (itemgrading.getItemGradingId() == null && (itemgrading.getReview() != null && itemgrading.getReview().booleanValue())  == true) {\n\t\t\t\tadds.addAll(grading);\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\t\t\n\t\t// 1. add all the new itemgrading for MC/Survey and discard any\n\t\t// itemgrading for MC/Survey\n\t\t// 2. add any modified SAQ/TF/FIB/Matching/MCMR/Audio/FIN\n\t\tswitch (typeId) {\n\t\tcase 1: // MC\n\t\tcase 12: // MC Single Selection\n\t\tcase 3: // Survey\n\t\t\tboolean answerModified = false;\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\n\t\t\t\tif (itemgrading.getItemGradingId() == null\n\t\t\t\t\t\t|| itemgrading.getItemGradingId().intValue() <= 0) { // =>\n\t\t\t\t\t// new answer\n\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null || (itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) { \n\t\t\t\t\t\tanswerModified = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Click the Reset Selection link\n\t\t\tif(item.getUnanswered()) {\n\t\t\t\tanswerModified = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (answerModified) {\n\t\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading\n\t\t\t\t\t.get(m);\n\t\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\t\t// remove all old answer for MC & Surevy\n\t\t\t\t\t\tremoves.add(itemgrading);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// add new answer\n\t\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null\n\t\t\t\t\t\t\t|| itemgrading.getAnswerText() != null\n\t\t\t\t\t\t\t|| (itemgrading.getRationale() != null \n\t\t\t\t\t\t\t\t&& !itemgrading.getRationale().trim().equals(\"\"))) { \n\t\t\t\t\t\t\t// null=> skipping this question\n\t\t\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\t\t\tif (itemgrading.getRationale() != null && itemgrading.getRationale().length() > 0) {\n\t\t\t\t\t\t\t\titemgrading.setRationale(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, itemgrading.getRationale()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// the rest of the info is collected by\n\t\t\t\t\t\t\t// ItemContentsBean via JSF form\n\t\t\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\thandleMarkForReview(grading, adds);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4: // T/F\n\t\tcase 9: // Matching\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t}\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif ((itemgrading.getItemGradingId() != null\t&& itemgrading.getItemGradingId().intValue() > 0) ||\n\t\t\t\t\t(itemgrading.getPublishedAnswerId() != null || itemgrading.getAnswerText() != null) ||\n\t\t\t\t\t(itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) {\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5: // SAQ\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t}\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (itemgrading.getAnswerText() != null && !itemgrading.getAnswerText().equals(\"\")) {\n\t\t\t\t\t// Change to allow student submissions in rich-text [SAK-17021]\n\t\t\t\t\titemgrading.setAnswerText(ContextUtil.stringWYSIWYG(itemgrading.getAnswerText()));\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\t\t\t\n\t\tcase 8: // FIB\n\t\tcase 15: // CALCULATED_QUESTION\n\t\tcase 11: // FIN\n\t\t\tboolean addedToAdds = false;\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t}\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (itemgrading.getAnswerText() != null && !itemgrading.getAnswerText().equals(\"\")) {\n\t\t\t\t\tString s = itemgrading.getAnswerText();\n\t\t\t\t\tlog.debug(\"s = \" + s);\n\t\t\t\t\t// Change to allow student submissions in rich-text [SAK-17021]\n\t\t\t\t\titemgrading.setAnswerText(ContextUtil.stringWYSIWYG(s));\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tif (!addedToAdds) {\n\t\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\t\taddedToAdds = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // MCMR\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\t// old answer, check which one to keep, not keeping null  answer\n\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null || \n\t\t\t\t\t\t(itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) {\n\t\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoves.add(itemgrading);\n\t\t\t\t\t}\n\t\t\t\t} else { \n\t\t\t\t\t // new answer\n\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null ||\n\t\t\t\t\t\t\t(itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) {\n\t\t\t\t\t\t// new  addition  not accepting any new answer with null for MCMR\n\t\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6: // File Upload\n\t\tcase 7: // Audio\n                        handleMarkForReview(grading, adds);\n                        break;\n\t\tcase 13: //Matrix Choices question\n\t\t\tanswerModified = false;\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading != null) {\n\t\t\t\t\tlog.debug(\"\\n:ItemId>>itemTextId>>answerId \"+ itemgrading.getPublishedItemId()+itemgrading.getPublishedItemTextId()+itemgrading.getPublishedAnswerId()+\"\\n\");\t    \n\n\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\tif (itemgrading.getRationale() != null && itemgrading.getRationale().length() > 0) {\n\t\t\t\t\t\titemgrading.setRationale(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, itemgrading.getRationale()));\n\t\t\t\t\t}\n\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t\t// if it is linear access and there is not answer, we add an fake ItemGradingData\n\t\tString actionCommand = \"\";\n\t\tif (ae != null) {\n\t\t\tactionCommand = ae.getComponent().getId();\n\t\t\tlog.debug(\"ae is not null, getActionCommand() = \" + actionCommand);\t\n\t\t}\n\t\telse {\n\t\t\tlog.debug(\"ae is null\");\n\t\t}\n\t\t\n\t\tif (delivery.getNavigation().equals(\"1\") && adds.size() ==0 && !\"showFeedback\".equals(actionCommand)) {\n\t\t\tlog.debug(\"enter here\");\n\t\t\tLong assessmentGradingId = delivery.getAssessmentGrading().getAssessmentGradingId();\n\t\t\tLong publishedItemId = item.getItemData().getItemId();\n\t\t\tlog.debug(\"assessmentGradingId = \" + assessmentGradingId);\n\t\t\tlog.debug(\"publishedItemId = \" + publishedItemId);\n\t\t\tGradingService gradingService = new GradingService();\n\t\t\t\n\t\t\tif (gradingService.getItemGradingData(assessmentGradingId.toString(), publishedItemId.toString()) == null) {\n\t\t\t\tlog.debug(\"Create a new (fake) ItemGradingData\");\n\t\t\t\tItemGradingData itemGrading = new ItemGradingData();\n\t\t\t\titemGrading.setAssessmentGradingId(assessmentGradingId);\n\t\t\t\titemGrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemGrading.setPublishedItemId(publishedItemId);\n\t\t\t\tItemService itemService = new ItemService();\n\t\t\t\tLong itemTextId = itemService.getItemTextId(publishedItemId);\n\t\t\t\tlog.debug(\"itemTextId = \" + itemTextId);\n\t\t\t\titemGrading.setPublishedItemTextId(itemTextId);\n\t\t\t\tadds.add(itemGrading);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// For File Upload question, if user clicks on \"Upload\", a ItemGradingData will be created. \n\t\t\t\t// Therefore, when user clicks on \"Next\", we shouldn't create it again.\n\t\t\t\t// Same for Audio question, if user records anything, a ItemGradingData will be created.\n\t\t\t\t// We don't create it again when user clicks on \"Next\".\n\t\t\t\tif ((typeId == 6 || typeId == 7)) {\n\t\t\t\t\tlog.debug(\"File Upload or Audio! Do not create empty ItemGradingData if there exists one\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":104409,"modified_method":"private void prepareItemGradingPerItem(ActionEvent ae, DeliveryBean delivery,\n\t\t\tItemContentsBean item, HashSet<ItemGradingData> adds, HashSet<ItemGradingData> removes) {\n\t\tArrayList grading = item.getItemGradingDataArray();\n\t\tint typeId = item.getItemData().getTypeId().intValue();\n\t\t\n\t\t//no matter what kinds of type questions, if it marks as review, add it in.\n\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\tif (itemgrading.getItemGradingId() == null && (itemgrading.getReview() != null && itemgrading.getReview().booleanValue())  == true) {\n\t\t\t\tadds.addAll(grading);\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\t\t\n\t\t// 1. add all the new itemgrading for MC/Survey and discard any\n\t\t// itemgrading for MC/Survey\n\t\t// 2. add any modified SAQ/TF/FIB/Matching/MCMR/Audio/FIN\n\t\tswitch (typeId) {\n\t\tcase 1: // MC\n\t\tcase 12: // MC Single Selection\n\t\tcase 3: // Survey\n\t\t\tboolean answerModified = false;\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\n\t\t\t\tif (itemgrading.getItemGradingId() == null\n\t\t\t\t\t\t|| itemgrading.getItemGradingId().intValue() <= 0) { // =>\n\t\t\t\t\t// new answer\n\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null || (itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) { \n\t\t\t\t\t\tanswerModified = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Click the Reset Selection link\n\t\t\tif(item.getUnanswered()) {\n\t\t\t\tanswerModified = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (answerModified) {\n\t\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading\n\t\t\t\t\t.get(m);\n\t\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\t\t// remove all old answer for MC & Surevy\n\t\t\t\t\t\tremoves.add(itemgrading);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// add new answer\n\t\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null\n\t\t\t\t\t\t\t|| itemgrading.getAnswerText() != null\n\t\t\t\t\t\t\t|| (itemgrading.getRationale() != null \n\t\t\t\t\t\t\t\t&& !itemgrading.getRationale().trim().equals(\"\"))) { \n\t\t\t\t\t\t\t// null=> skipping this question\n\t\t\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\t\t\tif (itemgrading.getRationale() != null && itemgrading.getRationale().length() > 0) {\n\t\t\t\t\t\t\t\titemgrading.setRationale(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, itemgrading.getRationale()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// the rest of the info is collected by\n\t\t\t\t\t\t\t// ItemContentsBean via JSF form\n\t\t\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\thandleMarkForReview(grading, adds);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4: // T/F\n\t\tcase 9: // Matching\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t}\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif ((itemgrading.getItemGradingId() != null\t&& itemgrading.getItemGradingId().intValue() > 0) ||\n\t\t\t\t\t(itemgrading.getPublishedAnswerId() != null || itemgrading.getAnswerText() != null) ||\n\t\t\t\t\t(itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) {\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5: // SAQ\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t}\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (itemgrading.getAnswerText() != null && !itemgrading.getAnswerText().equals(\"\")) {\n\t\t\t\t\t// Change to allow student submissions in rich-text [SAK-17021]\n\t\t\t\t\titemgrading.setAnswerText(ContextUtil.stringWYSIWYG(itemgrading.getAnswerText()));\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\t\t\t\n\t\tcase 8: // FIB\n\t\tcase 15: // CALCULATED_QUESTION\n\t\tcase 11: // FIN\n\t\t\tboolean addedToAdds = false;\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t}\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (itemgrading.getAnswerText() != null && !itemgrading.getAnswerText().equals(\"\")) {\n\t\t\t\t\tString s = itemgrading.getAnswerText();\n\t\t\t\t\tlog.debug(\"s = \" + s);\n\t\t\t\t\t// Change to allow student submissions in rich-text [SAK-17021]\n\t\t\t\t\titemgrading.setAnswerText(ContextUtil.stringWYSIWYG(s));\n\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\tif (!addedToAdds) {\n\t\t\t\t\t\tadds.addAll(grading);\n\t\t\t\t\t\taddedToAdds = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // MCMR\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading.getItemGradingId() != null\n\t\t\t\t\t\t&& itemgrading.getItemGradingId().intValue() > 0) {\n\t\t\t\t\t// old answer, check which one to keep, not keeping null  answer\n\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null || \n\t\t\t\t\t\t(itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) {\n\t\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoves.add(itemgrading);\n\t\t\t\t\t}\n\t\t\t\t} else { \n\t\t\t\t\t // new answer\n\t\t\t\t\tif (itemgrading.getPublishedAnswerId() != null ||\n\t\t\t\t\t\t\t(itemgrading.getRationale() != null && !itemgrading.getRationale().trim().equals(\"\"))) {\n\t\t\t\t\t\t// new  addition  not accepting any new answer with null for MCMR\n\t\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6: // File Upload\n\t\tcase 7: // Audio\n                        handleMarkForReview(grading, adds);\n                        break;\n\t\tcase 13: //Matrix Choices question\n\t\t\tanswerModified = false;\n\t\t\tfor (int m = 0; m < grading.size(); m++) {\n\t\t\t\tItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n\t\t\t\tif (itemgrading != null) {\n\t\t\t\t\tlog.debug(\"\\n:ItemId>>itemTextId>>answerId \"+ itemgrading.getPublishedItemId()+itemgrading.getPublishedItemTextId()+itemgrading.getPublishedAnswerId()+\"\\n\");\t    \n\n\t\t\t\t\titemgrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\t\titemgrading.setSubmittedDate(new Date());\n\t\t\t\t\tif (itemgrading.getRationale() != null && itemgrading.getRationale().length() > 0) {\n\t\t\t\t\t\titemgrading.setRationale(TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, itemgrading.getRationale()));\n\t\t\t\t\t}\n\t\t\t\t\tadds.add(itemgrading);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t\t// if it is linear access and there is not answer, we add an fake ItemGradingData\n\t\tString actionCommand = \"\";\n\t\tif (ae != null) {\n\t\t\tactionCommand = ae.getComponent().getId();\n\t\t\tlog.debug(\"ae is not null, getActionCommand() = \" + actionCommand);\t\n\t\t}\n\t\telse {\n\t\t\tlog.debug(\"ae is null\");\n\t\t}\n\t\t\n\t\tif (delivery.getNavigation().equals(\"1\") && adds.size() ==0 && !\"showFeedback\".equals(actionCommand)) {\n\t\t\tlog.debug(\"enter here\");\n\t\t\tLong assessmentGradingId = delivery.getAssessmentGrading().getAssessmentGradingId();\n\t\t\tLong publishedItemId = item.getItemData().getItemId();\n\t\t\tlog.debug(\"assessmentGradingId = \" + assessmentGradingId);\n\t\t\tlog.debug(\"publishedItemId = \" + publishedItemId);\n\t\t\tGradingService gradingService = new GradingService();\n\t\t\t\n\t\t\tif (gradingService.getItemGradingData(assessmentGradingId.toString(), publishedItemId.toString()) == null) {\n\t\t\t\tlog.debug(\"Create a new (fake) ItemGradingData\");\n\t\t\t\tItemGradingData itemGrading = new ItemGradingData();\n\t\t\t\titemGrading.setAssessmentGradingId(assessmentGradingId);\n\t\t\t\titemGrading.setAgentId(AgentFacade.getAgentString());\n\t\t\t\titemGrading.setPublishedItemId(publishedItemId);\n\t\t\t\tItemService itemService = new ItemService();\n\t\t\t\tLong itemTextId = itemService.getItemTextId(publishedItemId);\n\t\t\t\tlog.debug(\"itemTextId = \" + itemTextId);\n\t\t\t\titemGrading.setPublishedItemTextId(itemTextId);\n\t\t\t\tadds.add(itemGrading);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// For File Upload question, if user clicks on \"Upload\", a ItemGradingData will be created. \n\t\t\t\t// Therefore, when user clicks on \"Next\", we shouldn't create it again.\n\t\t\t\t// Same for Audio question, if user records anything, a ItemGradingData will be created.\n\t\t\t\t// We don't create it again when user clicks on \"Next\".\n\t\t\t\tif ((typeId == 6 || typeId == 7)) {\n\t\t\t\t\tlog.debug(\"File Upload or Audio! Do not create empty ItemGradingData if there exists one\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"ecd216f6e1f73b38e582e782e10c7ba4f2613703","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private HashSet getUpdateItemGradingSet(Set oldItemGradingSet,\n\t\t\tSet newItemGradingSet, HashMap fibMap, HashMap finMap, HashMap calcQuestionMap, HashMap mcmrMap,\n\t\t\tAssessmentGradingData adata) {\n\t\tlog.debug(\"Submitforgrading: oldItemGradingSet.size = \"\n\t\t\t\t+ oldItemGradingSet.size());\n\t\tlog.debug(\"Submitforgrading: newItemGradingSet.size = \"\n\t\t\t\t+ newItemGradingSet.size());\n\t\tHashSet updateItemGradingSet = new HashSet();\n\t\tIterator iter = oldItemGradingSet.iterator();\n\t\tHashMap map = new HashMap();\n\t\twhile (iter.hasNext()) { // create a map with old itemGrading\n\t\t\tItemGradingData item = (ItemGradingData) iter.next();\n\t\t\tmap.put(item.getItemGradingId(), item);\n\t\t}\n\n\t\t// go through new itemGrading\n\t\tIterator iter1 = newItemGradingSet.iterator();\n\t\twhile (iter1.hasNext()) {\n\t\t\tItemGradingData newItem = (ItemGradingData) iter1.next();\n\t\t\tItemGradingData oldItem = (ItemGradingData) map.get(newItem\n\t\t\t\t\t.getItemGradingId());\n\t\t\tif (oldItem != null) {\n\t\t\t\t// itemGrading exists and value has been change, then need\n\t\t\t\t// update\n\t\t\t\tBoolean oldReview = oldItem.getReview();\n\t\t\t\tBoolean newReview = newItem.getReview();\n\t\t\t\tLong oldAnswerId = oldItem.getPublishedAnswerId();\n\t\t\t\tLong newAnswerId = newItem.getPublishedAnswerId();\n\t\t\t\tString oldRationale = oldItem.getRationale();\n\t\t\t\tString newRationale = TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, newItem.getRationale());\n\t\t\t\tString oldAnswerText = oldItem.getAnswerText();\n\t\t\t\t// Change to allow student submissions in rich-text [SAK-17021]\n\t\t\t\tString newAnswerText = ContextUtil.stringWYSIWYG(newItem.getAnswerText());\n\t\t\t\tif ((oldReview != null && !oldReview.equals(newReview))\n\t\t\t\t    || (newReview!=null && !newReview.equals(oldReview))\n\t\t\t\t\t\t|| (oldAnswerId != null && !oldAnswerId\n\t\t\t\t\t\t\t\t.equals(newAnswerId))\n\t\t\t\t\t\t|| (newAnswerId != null && !newAnswerId\n\t\t\t\t\t\t\t\t.equals(oldAnswerId))\n\t\t\t\t\t\t|| (oldRationale != null && !oldRationale\n\t\t\t\t\t\t\t\t.equals(newRationale))\n\t\t\t\t\t\t|| (newRationale != null && !newRationale\n\t\t\t\t\t\t\t\t.equals(oldRationale))\n\t\t\t\t\t\t|| (oldAnswerText != null && !oldAnswerText\n\t\t\t\t\t\t\t\t.equals(newAnswerText))\n\t\t\t\t\t\t|| (newAnswerText != null && !newAnswerText\n\t\t\t\t\t\t\t\t.equals(oldAnswerText))\n\t\t\t\t\t\t|| fibMap.get(oldItem.getPublishedItemId()) != null\n\t\t\t\t\t\t|| finMap.get(oldItem.getPublishedItemId())!=null\n\t\t\t\t\t\t|| calcQuestionMap.get(oldItem.getPublishedItemId())!=null\n\t\t\t\t\t\t|| mcmrMap.get(oldItem.getPublishedItemId()) != null) {\n\t\t\t\t\toldItem.setReview(newItem.getReview());\n\t\t\t\t\toldItem.setPublishedAnswerId(newItem.getPublishedAnswerId());\n\t\t\t\t\toldItem.setRationale(newRationale);\n\t\t\t\t\t\t\t\n\t\t\t\t\toldItem.setAnswerText(newAnswerText);\n\t\t\t\t\toldItem.setSubmittedDate(new Date());\n\t\t\t\t\toldItem.setAutoScore(newItem.getAutoScore());\n\t\t\t\t\toldItem.setOverrideScore(newItem.getOverrideScore());\n\t\t\t\t\tupdateItemGradingSet.add(oldItem);\n\t\t\t\t\t// log.debug(\"**** SubmitToGrading: need update\n\t\t\t\t\t// \"+oldItem.getItemGradingId());\n\t\t\t\t}\n\t\t\t} else { // itemGrading from new set doesn't exist, add to set in\n\t\t\t\t// this case\n\t\t\t\t// log.debug(\"**** SubmitToGrading: need add new item\");\n\t\t\t\tnewItem.setAgentId(adata.getAgentId());\n\t\t\t\tupdateItemGradingSet.add(newItem);\n\t\t\t}\n\t\t}\n\t\treturn updateItemGradingSet;\n\t}","id":104410,"modified_method":"private HashSet<ItemGradingData> getUpdateItemGradingSet(Set oldItemGradingSet,\n\t\t\tSet<ItemGradingData> newItemGradingSet, HashMap fibMap, HashMap finMap, HashMap calcQuestionMap, HashMap mcmrMap,\n\t\t\tAssessmentGradingData adata) {\n\t\tlog.debug(\"Submitforgrading: oldItemGradingSet.size = \"\n\t\t\t\t+ oldItemGradingSet.size());\n\t\tlog.debug(\"Submitforgrading: newItemGradingSet.size = \"\n\t\t\t\t+ newItemGradingSet.size());\n\t\tHashSet<ItemGradingData> updateItemGradingSet = new HashSet<ItemGradingData>();\n\t\tIterator iter = oldItemGradingSet.iterator();\n\t\tHashMap<Long, ItemGradingData> map = new HashMap<Long, ItemGradingData>();\n\t\twhile (iter.hasNext()) { // create a map with old itemGrading\n\t\t\tItemGradingData item = (ItemGradingData) iter.next();\n\t\t\tmap.put(item.getItemGradingId(), item);\n\t\t}\n\n\t\t// go through new itemGrading\n\t\tIterator<ItemGradingData> iter1 = newItemGradingSet.iterator();\n\t\twhile (iter1.hasNext()) {\n\t\t\tItemGradingData newItem = iter1.next();\n\t\t\tItemGradingData oldItem = map.get(newItem\n\t\t\t\t\t.getItemGradingId());\n\t\t\tif (oldItem != null) {\n\t\t\t\t// itemGrading exists and value has been change, then need\n\t\t\t\t// update\n\t\t\t\tBoolean oldReview = oldItem.getReview();\n\t\t\t\tBoolean newReview = newItem.getReview();\n\t\t\t\tLong oldAnswerId = oldItem.getPublishedAnswerId();\n\t\t\t\tLong newAnswerId = newItem.getPublishedAnswerId();\n\t\t\t\tString oldRationale = oldItem.getRationale();\n\t\t\t\tString newRationale = TextFormat.convertPlaintextToFormattedTextNoHighUnicode(log, newItem.getRationale());\n\t\t\t\tString oldAnswerText = oldItem.getAnswerText();\n\t\t\t\t// Change to allow student submissions in rich-text [SAK-17021]\n\t\t\t\tString newAnswerText = ContextUtil.stringWYSIWYG(newItem.getAnswerText());\n\t\t\t\tif ((oldReview != null && !oldReview.equals(newReview))\n\t\t\t\t    || (newReview!=null && !newReview.equals(oldReview))\n\t\t\t\t\t\t|| (oldAnswerId != null && !oldAnswerId\n\t\t\t\t\t\t\t\t.equals(newAnswerId))\n\t\t\t\t\t\t|| (newAnswerId != null && !newAnswerId\n\t\t\t\t\t\t\t\t.equals(oldAnswerId))\n\t\t\t\t\t\t|| (oldRationale != null && !oldRationale\n\t\t\t\t\t\t\t\t.equals(newRationale))\n\t\t\t\t\t\t|| (newRationale != null && !newRationale\n\t\t\t\t\t\t\t\t.equals(oldRationale))\n\t\t\t\t\t\t|| (oldAnswerText != null && !oldAnswerText\n\t\t\t\t\t\t\t\t.equals(newAnswerText))\n\t\t\t\t\t\t|| (newAnswerText != null && !newAnswerText\n\t\t\t\t\t\t\t\t.equals(oldAnswerText))\n\t\t\t\t\t\t|| fibMap.get(oldItem.getPublishedItemId()) != null\n\t\t\t\t\t\t|| finMap.get(oldItem.getPublishedItemId())!=null\n\t\t\t\t\t\t|| calcQuestionMap.get(oldItem.getPublishedItemId())!=null\n\t\t\t\t\t\t|| mcmrMap.get(oldItem.getPublishedItemId()) != null) {\n\t\t\t\t\toldItem.setReview(newItem.getReview());\n\t\t\t\t\toldItem.setPublishedAnswerId(newItem.getPublishedAnswerId());\n\t\t\t\t\toldItem.setRationale(newRationale);\n\t\t\t\t\t\t\t\n\t\t\t\t\toldItem.setAnswerText(newAnswerText);\n\t\t\t\t\toldItem.setSubmittedDate(new Date());\n\t\t\t\t\toldItem.setAutoScore(newItem.getAutoScore());\n\t\t\t\t\toldItem.setOverrideScore(newItem.getOverrideScore());\n\t\t\t\t\tupdateItemGradingSet.add(oldItem);\n\t\t\t\t\t// log.debug(\"**** SubmitToGrading: need update\n\t\t\t\t\t// \"+oldItem.getItemGradingId());\n\t\t\t\t}\n\t\t\t} else { // itemGrading from new set doesn't exist, add to set in\n\t\t\t\t// this case\n\t\t\t\t// log.debug(\"**** SubmitToGrading: need add new item\");\n\t\t\t\tnewItem.setAgentId(adata.getAgentId());\n\t\t\t\tupdateItemGradingSet.add(newItem);\n\t\t\t}\n\t\t}\n\t\treturn updateItemGradingSet;\n\t}","commit_id":"ecd216f6e1f73b38e582e782e10c7ba4f2613703","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void handleMarkForReview(ArrayList grading, HashSet adds){\n      for (int m = 0; m < grading.size(); m++) {\n        ItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n        if (itemgrading.getItemGradingId() != null \n            && itemgrading.getItemGradingId().intValue() > 0\n            && itemgrading.getReview() != null)  {\n            // we will save itemgarding even though answer was not modified \n            // 'cos mark for review may have been modified\n          adds.add(itemgrading);\n        }\n      }\n    }","id":104411,"modified_method":"private void handleMarkForReview(ArrayList grading, HashSet<ItemGradingData> adds){\n      for (int m = 0; m < grading.size(); m++) {\n        ItemGradingData itemgrading = (ItemGradingData) grading.get(m);\n        if (itemgrading.getItemGradingId() != null \n            && itemgrading.getItemGradingId().intValue() > 0\n            && itemgrading.getReview() != null)  {\n            // we will save itemgarding even though answer was not modified \n            // 'cos mark for review may have been modified\n          adds.add(itemgrading);\n        }\n      }\n    }","commit_id":"ecd216f6e1f73b38e582e782e10c7ba4f2613703","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Invoke submission and return the grading data\n\t * \n\t * @param publishedAssessment\n\t * @param delivery\n\t * @return\n\t */\n\tprivate synchronized AssessmentGradingData submitToGradingService(\n\t\t\tActionEvent ae, PublishedAssessmentFacade publishedAssessment, DeliveryBean delivery, HashMap invalidFINMap, ArrayList invalidSALengthList) throws FinFormatException {\n\t\tlog.debug(\"****1a. inside submitToGradingService \");\n\t\tString submissionId = \"\";\n\t\tHashSet itemGradingHash = new HashSet();\n\t\t// daisyf decoding: get page contents contains SectionContentsBean, a\n\t\t// wrapper for SectionDataIfc\n\t\tIterator iter = delivery.getPageContents().getPartsContents()\n\t\t\t\t.iterator();\n\t\tlog.debug(\"****1b. inside submitToGradingService, iter= \" + iter);\n\t\tHashSet adds = new HashSet();\n\t\tHashSet removes = new HashSet();\n\t\t\n\t\t// we go through all the answer collected from JSF form per each\n\t\t// publsihedItem and\n\t\t// work out which answer is an new addition and in cases like\n\t\t// MC/MCMR/Survey, we will\n\t\t// discard any existing one and just save teh new one. For other\n\t\t// question type, we\n\t\t// simply modify the publishedText or publishedAnswer of teh existing\n\t\t// ones.\n\t\twhile (iter.hasNext()) {\n\t\t\tSectionContentsBean part = (SectionContentsBean) iter.next();\n\t\t\tlog.debug(\"****1c. inside submitToGradingService, part \" + part);\n\t\t\tIterator iter2 = part.getItemContents().iterator();\n\t\t\twhile (iter2.hasNext()) { // go through each item from form\n\t\t\t\tItemContentsBean item = (ItemContentsBean) iter2.next();\n\t\t\t\tlog.debug(\"****** before prepareItemGradingPerItem\");\n\t\t\t\tprepareItemGradingPerItem(ae, delivery, item, adds, removes);\n\t\t\t\tlog.debug(\"****** after prepareItemGradingPerItem\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssessmentGradingData adata = persistAssessmentGrading(ae, delivery,\n\t\t\t\titemGradingHash, publishedAssessment, adds, removes, invalidFINMap, invalidSALengthList);\n\n\t\t\n\t\tStringBuffer redrawAnchorName = new StringBuffer(\"p\");\n\t\tString tmpAnchorName = \"\";\n\n\t\tIterator iterPart = delivery.getPageContents().getPartsContents().iterator();\n\t\twhile (iterPart.hasNext()) {\n\t\t\tSectionContentsBean part = (SectionContentsBean) iterPart.next();\n\t\t\tString partSeq = part.getNumber();\n\t\t\tIterator iterItem = part.getItemContents().iterator();\n\t\t\twhile (iterItem.hasNext()) { // go through each item from form\n\t\t\t\tItemContentsBean item = (ItemContentsBean) iterItem.next();\n\t\t\t\tString itemSeq = item.getSequence();\n\t\t\t\tLong itemId = item.getItemData().getItemId();\n\t\t\t\tif (item.getItemData().getTypeId() == 5) {\n\t\t\t\t\tif (invalidSALengthList.contains(itemId)) {\n\t\t\t\t\t\titem.setIsInvalidSALengthInput(true);\n\t\t\t\t\t\tredrawAnchorName.append(partSeq);\n\t\t\t\t\t\tredrawAnchorName.append(\"q\");\n\t\t\t\t\t\tredrawAnchorName.append(itemSeq);\n\t\t\t\t\t\tif (tmpAnchorName.equals(\"\") || tmpAnchorName.compareToIgnoreCase(redrawAnchorName.toString()) > 0) {\n\t\t\t\t\t\t\ttmpAnchorName = redrawAnchorName.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem.setIsInvalidSALengthInput(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (item.getItemData().getTypeId() == 11) {\n\t\t\t\t\tif (invalidFINMap.containsKey(itemId)) {\n\t\t\t\t\t\titem.setIsInvalidFinInput(true);\n\t\t\t\t\t\tredrawAnchorName.append(partSeq);\n\t\t\t\t\t\tredrawAnchorName.append(\"q\");\n\t\t\t\t\t\tredrawAnchorName.append(itemSeq);\n\t\t\t\t\t\tif (tmpAnchorName.equals(\"\") || tmpAnchorName.compareToIgnoreCase(redrawAnchorName.toString()) > 0) {\n\t\t\t\t\t\t\ttmpAnchorName = redrawAnchorName.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList list = (ArrayList) invalidFINMap.get(itemId);\n\t\t\t\t\t\tArrayList finArray = item.getFinArray();\n\t\t\t\t\t\tIterator iterFin = finArray.iterator();\n\t\t\t\t\t\twhile (iterFin.hasNext()) {\n\t\t\t\t\t\t\tFinBean finBean = (FinBean) iterFin.next();\n\t\t\t\t\t\t\tif (finBean.getItemGradingData() != null) {\n\t\t\t\t\t\t\t\tLong itemGradingId = finBean.getItemGradingData().getItemGradingId();\n\t\t\t\t\t\t\t\tif (list.contains(itemGradingId)) {\n\t\t\t\t\t\t\t\t\tfinBean.setIsCorrect(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem.setIsInvalidFinInput(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif (tmpAnchorName != null && !tmpAnchorName.equals(\"\")) {\n\t\t\tdelivery.setRedrawAnchorName(tmpAnchorName.toString());\n\t\t}\n\t\telse {\n\t\t\tdelivery.setRedrawAnchorName(\"\");\n\t\t}\n\t\t\n\t\tdelivery.setSubmissionId(submissionId);\n\t\tdelivery.setSubmissionTicket(submissionId);// is this the same thing?\n\t\t// hmmmm\n\t\tdelivery.setSubmissionDate(new Date());\n\t\tdelivery.setSubmitted(true);\n\t\treturn adata;\n\t}","id":104412,"modified_method":"/**\n\t * Invoke submission and return the grading data\n\t * \n\t * @param publishedAssessment\n\t * @param delivery\n\t * @return\n\t */\n\tprivate synchronized AssessmentGradingData submitToGradingService(\n\t\t\tActionEvent ae, PublishedAssessmentFacade publishedAssessment, DeliveryBean delivery, HashMap invalidFINMap, ArrayList invalidSALengthList) throws FinFormatException {\n\t\tlog.debug(\"****1a. inside submitToGradingService \");\n\t\tString submissionId = \"\";\n\t\tHashSet<ItemGradingData> itemGradingHash = new HashSet<ItemGradingData>();\n\t\t// daisyf decoding: get page contents contains SectionContentsBean, a\n\t\t// wrapper for SectionDataIfc\n\t\tIterator<SectionContentsBean> iter = delivery.getPageContents().getPartsContents()\n\t\t\t\t.iterator();\n\t\tlog.debug(\"****1b. inside submitToGradingService, iter= \" + iter);\n\t\tHashSet<ItemGradingData> adds = new HashSet<ItemGradingData>();\n\t\tHashSet<ItemGradingData> removes = new HashSet<ItemGradingData>();\n\t\t\n\t\t// we go through all the answer collected from JSF form per each\n\t\t// publsihedItem and\n\t\t// work out which answer is an new addition and in cases like\n\t\t// MC/MCMR/Survey, we will\n\t\t// discard any existing one and just save teh new one. For other\n\t\t// question type, we\n\t\t// simply modify the publishedText or publishedAnswer of teh existing\n\t\t// ones.\n\t\twhile (iter.hasNext()) {\n\t\t\tSectionContentsBean part = iter.next();\n\t\t\tlog.debug(\"****1c. inside submitToGradingService, part \" + part);\n\t\t\tIterator<ItemContentsBean> iter2 = part.getItemContents().iterator();\n\t\t\twhile (iter2.hasNext()) { // go through each item from form\n\t\t\t\tItemContentsBean item = iter2.next();\n\t\t\t\tlog.debug(\"****** before prepareItemGradingPerItem\");\n\t\t\t\tprepareItemGradingPerItem(ae, delivery, item, adds, removes);\n\t\t\t\tlog.debug(\"****** after prepareItemGradingPerItem\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tAssessmentGradingData adata = persistAssessmentGrading(ae, delivery,\n\t\t\t\titemGradingHash, publishedAssessment, adds, removes, invalidFINMap, invalidSALengthList);\n\n\t\t\n\t\tStringBuffer redrawAnchorName = new StringBuffer(\"p\");\n\t\tString tmpAnchorName = \"\";\n\n\t\tIterator<SectionContentsBean> iterPart = delivery.getPageContents().getPartsContents().iterator();\n\t\twhile (iterPart.hasNext()) {\n\t\t\tSectionContentsBean part = iterPart.next();\n\t\t\tString partSeq = part.getNumber();\n\t\t\tIterator<ItemContentsBean> iterItem = part.getItemContents().iterator();\n\t\t\twhile (iterItem.hasNext()) { // go through each item from form\n\t\t\t\tItemContentsBean item = iterItem.next();\n\t\t\t\tString itemSeq = item.getSequence();\n\t\t\t\tLong itemId = item.getItemData().getItemId();\n\t\t\t\tif (item.getItemData().getTypeId() == 5) {\n\t\t\t\t\tif (invalidSALengthList.contains(itemId)) {\n\t\t\t\t\t\titem.setIsInvalidSALengthInput(true);\n\t\t\t\t\t\tredrawAnchorName.append(partSeq);\n\t\t\t\t\t\tredrawAnchorName.append(\"q\");\n\t\t\t\t\t\tredrawAnchorName.append(itemSeq);\n\t\t\t\t\t\tif (tmpAnchorName.equals(\"\") || tmpAnchorName.compareToIgnoreCase(redrawAnchorName.toString()) > 0) {\n\t\t\t\t\t\t\ttmpAnchorName = redrawAnchorName.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem.setIsInvalidSALengthInput(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (item.getItemData().getTypeId() == 11) {\n\t\t\t\t\tif (invalidFINMap.containsKey(itemId)) {\n\t\t\t\t\t\titem.setIsInvalidFinInput(true);\n\t\t\t\t\t\tredrawAnchorName.append(partSeq);\n\t\t\t\t\t\tredrawAnchorName.append(\"q\");\n\t\t\t\t\t\tredrawAnchorName.append(itemSeq);\n\t\t\t\t\t\tif (tmpAnchorName.equals(\"\") || tmpAnchorName.compareToIgnoreCase(redrawAnchorName.toString()) > 0) {\n\t\t\t\t\t\t\ttmpAnchorName = redrawAnchorName.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList list = (ArrayList) invalidFINMap.get(itemId);\n\t\t\t\t\t\tArrayList<FinBean> finArray = item.getFinArray();\n\t\t\t\t\t\tIterator<FinBean> iterFin = finArray.iterator();\n\t\t\t\t\t\twhile (iterFin.hasNext()) {\n\t\t\t\t\t\t\tFinBean finBean = iterFin.next();\n\t\t\t\t\t\t\tif (finBean.getItemGradingData() != null) {\n\t\t\t\t\t\t\t\tLong itemGradingId = finBean.getItemGradingData().getItemGradingId();\n\t\t\t\t\t\t\t\tif (list.contains(itemGradingId)) {\n\t\t\t\t\t\t\t\t\tfinBean.setIsCorrect(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem.setIsInvalidFinInput(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif (tmpAnchorName != null && !tmpAnchorName.equals(\"\")) {\n\t\t\tdelivery.setRedrawAnchorName(tmpAnchorName.toString());\n\t\t}\n\t\telse {\n\t\t\tdelivery.setRedrawAnchorName(\"\");\n\t\t}\n\t\t\n\t\tdelivery.setSubmissionId(submissionId);\n\t\tdelivery.setSubmissionTicket(submissionId);// is this the same thing?\n\t\t// hmmmm\n\t\tdelivery.setSubmissionDate(new Date());\n\t\tdelivery.setSubmitted(true);\n\t\treturn adata;\n\t}","commit_id":"ecd216f6e1f73b38e582e782e10c7ba4f2613703","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private AssessmentGradingData persistAssessmentGrading(ActionEvent ae, \n\t\t\tDeliveryBean delivery, HashSet itemGradingHash,\n\t\t\tPublishedAssessmentFacade publishedAssessment, HashSet adds,\n\t\t\tHashSet removes, HashMap invalidFINMap, ArrayList invalidSALengthList) throws FinFormatException {\n\t\tAssessmentGradingData adata = null;\n\t\tif (delivery.getAssessmentGrading() != null) {\n\t\t\tadata = delivery.getAssessmentGrading();\n\t\t}\n\n\t\tGradingService service = new GradingService();\n\t\tlog.debug(\"**adata=\" + adata);\n\t\tif (adata == null) { // <--- this shouldn't happened 'cos it should\n\t\t\t// have been created by BeginDelivery\n\t\t\tadata = makeNewAssessmentGrading(publishedAssessment, delivery,\n\t\t\t\t\titemGradingHash);\n\t\t\tdelivery.setAssessmentGrading(adata);\n\t\t} else {\n\t\t\t// 1. add all the new itemgrading for MC/Survey and discard any\n\t\t\t// itemgrading for MC/Survey\n\t\t\t// 2. add any modified SAQ/TF/FIB/Matching/MCMR/FIN\n\t\t\t// 3. save any modified Mark for Review in FileUplaod/Audio\n\n\t\t\tHashMap fibMap = getFIBMap(publishedAssessment);\n\t\t\tHashMap finMap = getFINMap(publishedAssessment);\n\t\t\tHashMap calcQuestionMap = getCalcQuestionMap(publishedAssessment); // CALCULATED_QUESTION\n\t\t\tHashMap mcmrMap = getMCMRMap(publishedAssessment);\n\t\t\tSet itemGradingSet = adata.getItemGradingSet();\n\t\t\tlog.debug(\"*** 2a. before removal & addition \" + (new Date()));\n\t\t\tif (itemGradingSet != null) {\n\t\t\t\tlog.debug(\"*** 2aa. removing old itemGrading \" + (new Date()));\n\t\t\t\titemGradingSet.removeAll(removes);\n\t\t\t\tservice.deleteAll(removes);\n\t\t\t\t// refresh itemGradingSet & assessmentGrading after removal\n\t\t\t\tlog.debug(\"*** 2ab. reload itemGradingSet \" + (new Date()));\n\t\t\t\titemGradingSet = service.getItemGradingSet(adata\n\t\t\t\t\t\t.getAssessmentGradingId().toString());\n\t\t\t\tlog.debug(\"*** 2ac. load assessmentGarding \" + (new Date()));\n\t\t\t\tadata = service.load(adata.getAssessmentGradingId().toString());\n\n\t\t\t\tIterator iter = adds.iterator();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t((ItemGradingData) iter.next()).setAssessmentGradingId(adata\n\t\t\t\t\t\t\t.getAssessmentGradingId());\n\t\t\t\t}\n\t\t\t\t// make update to old item and insert new item\n\t\t\t\t// and we will only update item that has been changed\n\t\t\t\tlog\n\t\t\t\t\t\t.debug(\"*** 2ad. set assessmentGrading with new/updated itemGrading \"\n\t\t\t\t\t\t\t\t+ (new Date()));\n\t\t\t\tlog\n\t\t\t\t\t\t.debug(\"Submitforgrading: before calling .....................oldItemGradingSet.size = \"\n\t\t\t\t\t\t\t\t+ itemGradingSet.size());\n\t\t\t\tlog.debug(\"Submitforgrading: newItemGradingSet.size = \"\n\t\t\t\t\t\t+ adds.size());\n\n\t\t\t\tHashSet updateItemGradingSet = getUpdateItemGradingSet(\n\t\t\t\t\t\titemGradingSet, adds, fibMap, finMap, calcQuestionMap,mcmrMap, adata);\n\t\t\t\tadata.setItemGradingSet(updateItemGradingSet);\n\t\t\t}\n\t\t}\n\n\t\tadata.setIsLate(isLate(publishedAssessment));\n\t\tadata.setForGrade(Boolean.valueOf(delivery.getForGrade()));\n\t\t\n\t\t// If this assessment grading data has been updated (comments or adj. score) by grader and then republic and allow student to resubmit\n\t\t// when the student submit his answers, we update the status back to 0 and remove the grading entry/info.\n\t\tif (AssessmentGradingData.ASSESSMENT_UPDATED_NEED_RESUBMIT.equals(adata.getStatus()) || AssessmentGradingData.ASSESSMENT_UPDATED.equals(adata.getStatus())) {\n\t\t\tadata.setStatus(Integer.valueOf(0));\n\t\t\tadata.setGradedBy(null);\n\t\t\tadata.setGradedDate(null);\n\t\t\tadata.setComments(null);\n\t\t\tadata.setTotalOverrideScore(Float.valueOf(0f));\n\t\t}\n\t\n\t\tlog.debug(\"*** 2b. before storingGrades, did all the removes and adds \"\n\t\t\t\t+ (new Date()));\n\t\t\n\t\tif (delivery.getNavigation().equals(\"1\") && ae != null && \"showFeedback\".equals(ae.getComponent().getId())) {\n\t\t\tlog.debug(\"Do not persist to db if it is linear access and the action is show feedback\");\n\t\t\t// 3. let's build three HashMap with (publishedItemId, publishedItem),\n\t\t\t// (publishedItemTextId, publishedItem), (publishedAnswerId,\n\t\t\t// publishedItem) to help with storing grades to adata only, not db\n\t\t\tHashMap publishedItemHash = delivery.getPublishedItemHash();\n\t\t\tHashMap publishedItemTextHash = delivery.getPublishedItemTextHash();\n\t\t\tHashMap publishedAnswerHash = delivery.getPublishedAnswerHash();\n\t\t\tservice.storeGrades(adata, publishedAssessment, publishedItemHash, publishedItemTextHash, publishedAnswerHash, false, invalidFINMap, invalidSALengthList);\n\t\t}\n\t\telse {\n\t\t\tlog.debug(\"Persist to db otherwise\");\n\t\t\t// The following line seems redundant. I cannot see a reason why we need to save the adata here\n\t\t\t// and then again in following service.storeGrades(). Comment it out.\n\t\t\t//service.saveOrUpdateAssessmentGrading(adata);\n\t\t\tlog.debug(\"*** 3. before storingGrades, did all the removes and adds \" + (new Date()));\n\t\t\t// 3. let's build three HashMap with (publishedItemId, publishedItem),\n\t\t\t// (publishedItemTextId, publishedItem), (publishedAnswerId,\n\t\t\t// publishedItem) to help with storing grades to adata and then persist to DB\n\t\t\tHashMap publishedItemHash = delivery.getPublishedItemHash();\n\t\t\tHashMap publishedItemTextHash = delivery.getPublishedItemTextHash();\n\t\t\tHashMap publishedAnswerHash = delivery.getPublishedAnswerHash();\n\t\t\tservice.storeGrades(adata, publishedAssessment, publishedItemHash, publishedItemTextHash, publishedAnswerHash, invalidFINMap, invalidSALengthList);\n\t\t}\n\t\treturn adata;\n\t}","id":104413,"modified_method":"private AssessmentGradingData persistAssessmentGrading(ActionEvent ae, \n\t\t\tDeliveryBean delivery, HashSet<ItemGradingData> itemGradingHash,\n\t\t\tPublishedAssessmentFacade publishedAssessment, HashSet<ItemGradingData> adds,\n\t\t\tHashSet<ItemGradingData> removes, HashMap invalidFINMap, ArrayList invalidSALengthList) throws FinFormatException {\n\t\tAssessmentGradingData adata = null;\n\t\tif (delivery.getAssessmentGrading() != null) {\n\t\t\tadata = delivery.getAssessmentGrading();\n\t\t}\n\n\t\tGradingService service = new GradingService();\n\t\tlog.debug(\"**adata=\" + adata);\n\t\tif (adata == null) { // <--- this shouldn't happened 'cos it should\n\t\t\t// have been created by BeginDelivery\n\t\t\tadata = makeNewAssessmentGrading(publishedAssessment, delivery,\n\t\t\t\t\titemGradingHash);\n\t\t\tdelivery.setAssessmentGrading(adata);\n\t\t} else {\n\t\t\t// 1. add all the new itemgrading for MC/Survey and discard any\n\t\t\t// itemgrading for MC/Survey\n\t\t\t// 2. add any modified SAQ/TF/FIB/Matching/MCMR/FIN\n\t\t\t// 3. save any modified Mark for Review in FileUplaod/Audio\n\n\t\t\tHashMap fibMap = getFIBMap(publishedAssessment);\n\t\t\tHashMap finMap = getFINMap(publishedAssessment);\n\t\t\tHashMap calcQuestionMap = getCalcQuestionMap(publishedAssessment); // CALCULATED_QUESTION\n\t\t\tHashMap mcmrMap = getMCMRMap(publishedAssessment);\n\t\t\tSet itemGradingSet = adata.getItemGradingSet();\n\t\t\tlog.debug(\"*** 2a. before removal & addition \" + (new Date()));\n\t\t\tif (itemGradingSet != null) {\n\t\t\t\tlog.debug(\"*** 2aa. removing old itemGrading \" + (new Date()));\n\t\t\t\titemGradingSet.removeAll(removes);\n\t\t\t\tservice.deleteAll(removes);\n\t\t\t\t// refresh itemGradingSet & assessmentGrading after removal\n\t\t\t\tlog.debug(\"*** 2ab. reload itemGradingSet \" + (new Date()));\n\t\t\t\titemGradingSet = service.getItemGradingSet(adata\n\t\t\t\t\t\t.getAssessmentGradingId().toString());\n\t\t\t\tlog.debug(\"*** 2ac. load assessmentGarding \" + (new Date()));\n\t\t\t\tadata = service.load(adata.getAssessmentGradingId().toString());\n\n\t\t\t\tIterator<ItemGradingData> iter = adds.iterator();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\titer.next().setAssessmentGradingId(adata\n\t\t\t\t\t\t\t.getAssessmentGradingId());\n\t\t\t\t}\n\t\t\t\t// make update to old item and insert new item\n\t\t\t\t// and we will only update item that has been changed\n\t\t\t\tlog\n\t\t\t\t\t\t.debug(\"*** 2ad. set assessmentGrading with new/updated itemGrading \"\n\t\t\t\t\t\t\t\t+ (new Date()));\n\t\t\t\tlog\n\t\t\t\t\t\t.debug(\"Submitforgrading: before calling .....................oldItemGradingSet.size = \"\n\t\t\t\t\t\t\t\t+ itemGradingSet.size());\n\t\t\t\tlog.debug(\"Submitforgrading: newItemGradingSet.size = \"\n\t\t\t\t\t\t+ adds.size());\n\n\t\t\t\tHashSet<ItemGradingData> updateItemGradingSet = getUpdateItemGradingSet(\n\t\t\t\t\t\titemGradingSet, adds, fibMap, finMap, calcQuestionMap,mcmrMap, adata);\n\t\t\t\tadata.setItemGradingSet(updateItemGradingSet);\n\t\t\t}\n\t\t}\n\n\t\tadata.setIsLate(isLate(publishedAssessment));\n\t\tadata.setForGrade(Boolean.valueOf(delivery.getForGrade()));\n\t\t\n\t\t// If this assessment grading data has been updated (comments or adj. score) by grader and then republic and allow student to resubmit\n\t\t// when the student submit his answers, we update the status back to 0 and remove the grading entry/info.\n\t\tif (AssessmentGradingData.ASSESSMENT_UPDATED_NEED_RESUBMIT.equals(adata.getStatus()) || AssessmentGradingData.ASSESSMENT_UPDATED.equals(adata.getStatus())) {\n\t\t\tadata.setStatus(Integer.valueOf(0));\n\t\t\tadata.setGradedBy(null);\n\t\t\tadata.setGradedDate(null);\n\t\t\tadata.setComments(null);\n\t\t\tadata.setTotalOverrideScore(Float.valueOf(0f));\n\t\t}\n\t\n\t\tlog.debug(\"*** 2b. before storingGrades, did all the removes and adds \"\n\t\t\t\t+ (new Date()));\n\t\t\n\t\tif (delivery.getNavigation().equals(\"1\") && ae != null && \"showFeedback\".equals(ae.getComponent().getId())) {\n\t\t\tlog.debug(\"Do not persist to db if it is linear access and the action is show feedback\");\n\t\t\t// 3. let's build three HashMap with (publishedItemId, publishedItem),\n\t\t\t// (publishedItemTextId, publishedItem), (publishedAnswerId,\n\t\t\t// publishedItem) to help with storing grades to adata only, not db\n\t\t\tHashMap publishedItemHash = delivery.getPublishedItemHash();\n\t\t\tHashMap publishedItemTextHash = delivery.getPublishedItemTextHash();\n\t\t\tHashMap publishedAnswerHash = delivery.getPublishedAnswerHash();\n\t\t\tservice.storeGrades(adata, publishedAssessment, publishedItemHash, publishedItemTextHash, publishedAnswerHash, false, invalidFINMap, invalidSALengthList);\n\t\t}\n\t\telse {\n\t\t\tlog.debug(\"Persist to db otherwise\");\n\t\t\t// The following line seems redundant. I cannot see a reason why we need to save the adata here\n\t\t\t// and then again in following service.storeGrades(). Comment it out.\n\t\t\t//service.saveOrUpdateAssessmentGrading(adata);\n\t\t\tlog.debug(\"*** 3. before storingGrades, did all the removes and adds \" + (new Date()));\n\t\t\t// 3. let's build three HashMap with (publishedItemId, publishedItem),\n\t\t\t// (publishedItemTextId, publishedItem), (publishedAnswerId,\n\t\t\t// publishedItem) to help with storing grades to adata and then persist to DB\n\t\t\tHashMap publishedItemHash = delivery.getPublishedItemHash();\n\t\t\tHashMap publishedItemTextHash = delivery.getPublishedItemTextHash();\n\t\t\tHashMap publishedAnswerHash = delivery.getPublishedAnswerHash();\n\t\t\tservice.storeGrades(adata, publishedAssessment, publishedItemHash, publishedItemTextHash, publishedAnswerHash, invalidFINMap, invalidSALengthList);\n\t\t}\n\t\treturn adata;\n\t}","commit_id":"ecd216f6e1f73b38e582e782e10c7ba4f2613703","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void applyInplace(SModel inputModel, TemplateGenerator generator) {\n    // make the structure change, at last\n    for (DeltaRoot dr : myDelta) {\n      // additions from NewRoot and ReplacedRoot come in the order they were scheduled to be applied\n      // not the order they were ready - to get same order in parallel gen. Although additions from replaced\n      // come to the tail of root nodes list as there's no way to keep index of root node.\n      if (dr instanceof NewRoot) {\n        inputModel.addRootNode(((NewRoot) dr).myRoot);\n      } else if (dr instanceof ReplacedRoot) {\n        ReplacedRoot rr = (ReplacedRoot) dr;\n        // XXX Seems there's no way to replace root node in its original position ?!\n        inputModel.removeRootNode(rr.myReplacedRoot);\n        for (SNode replacement : rr.myReplacements) {\n          inputModel.addRootNode(replacement);\n        }\n      } else {\n        CopyRoot root = (CopyRoot) dr;\n        if (root.deleted) {\n          assert root.myRoot.getModel() == inputModel;\n          inputModel.removeRootNode(root.myRoot);\n          continue;\n        }\n        // replace nodes\n        for (SubTree tree : root.mySubTrees) {\n          if (tree.isCopySrcRoot()) {\n            continue;\n          }\n          assert tree.myInputNode.getModel() == inputModel;\n          SNode inputParentNode = tree.myInputNode.getParent();\n          SNode anchor = tree.myInputNode.getNextSibling();\n          inputParentNode.removeChild(tree.myInputNode);\n          for (SNode replacement : tree.mySubTree) {\n            inputParentNode.insertChildBefore(tree.myRoleInParent, replacement, anchor);\n          }\n        }\n      }\n    }\n  }","id":104414,"modified_method":"public void applyInplace(SModel inputModel) {\n    // make the structure change, at last\n    for (DeltaRoot dr : myDelta) {\n      // additions from NewRoot and ReplacedRoot come in the order they were scheduled to be applied\n      // not the order they were ready - to get same order in parallel gen. Although additions from replaced\n      // come to the tail of root nodes list as there's no way to keep index of root node.\n      if (dr instanceof NewRoot) {\n        inputModel.addRootNode(((NewRoot) dr).myRoot);\n      } else if (dr instanceof ReplacedRoot) {\n        ReplacedRoot rr = (ReplacedRoot) dr;\n        // XXX Seems there's no way to replace root node in its original position ?!\n        inputModel.removeRootNode(rr.myReplacedRoot);\n        for (SNode replacement : rr.myReplacements) {\n          inputModel.addRootNode(replacement);\n        }\n      } else {\n        CopyRoot root = (CopyRoot) dr;\n        if (root.deleted) {\n          assert root.myRoot.getModel() == inputModel;\n          inputModel.removeRootNode(root.myRoot);\n          continue;\n        }\n        // replace nodes\n        for (SubTree tree : root.mySubTrees) {\n          if (tree.isCopySrcRoot()) {\n            continue;\n          }\n          assert tree.myInputNode.getModel() == inputModel;\n          SNode inputParentNode = tree.myInputNode.getParent();\n          SNode anchor = tree.myInputNode.getNextSibling();\n          inputParentNode.removeChild(tree.myInputNode);\n          for (SNode replacement : tree.mySubTree) {\n            inputParentNode.insertChildBefore(tree.myRoleInParent, replacement, anchor);\n          }\n        }\n      }\n    }\n  }","commit_id":"d2c112929a23b66832dbf2b0ed4cf487be4be4a4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void registerRoot(@Nullable SNode oldRoot, @NotNull SNode newRoot) {\n    if (oldRoot == null) {\n      myDelta.add(new NewRoot(newRoot));\n    } else if (oldRoot == newRoot) {\n      CopyRoot cr = null;\n      for (CopyRoot r : myCopyRoots) {\n        if (r.myRoot == newRoot) {\n          cr = r;\n          break;\n        }\n      }\n      if (cr == null) {\n        throw new IllegalStateException();\n      }\n      myDelta.add(cr);\n    } else {\n      ReplacedRoot rr = null;\n      for (ReplacedRoot r : myReplacedRoots) {\n        if (r.myReplacedRoot == oldRoot) {\n          rr = r;\n          break;\n        }\n      }\n      if (rr == null) {\n        myDelta.add(rr = new ReplacedRoot(oldRoot, newRoot));\n        myReplacedRoots.add(rr);\n      } else {\n        rr.myReplacements.add(newRoot);\n      }\n    }\n  }","id":104415,"modified_method":"public void registerRoot(@Nullable SNode oldRoot, @NotNull SNode newRoot) {\n    if (oldRoot == null) {\n      NewRoot r = new NewRoot(newRoot);\n      myDelta.add(r);\n      myNewRoots.add(r);\n    } else if (oldRoot == newRoot) {\n      CopyRoot cr = null;\n      for (CopyRoot r : myCopyRoots) {\n        if (r.myRoot == newRoot) {\n          cr = r;\n          break;\n        }\n      }\n      if (cr == null) {\n        throw new IllegalStateException();\n      }\n      myDelta.add(cr);\n    } else {\n      ReplacedRoot rr = null;\n      for (ReplacedRoot r : myReplacedRoots) {\n        if (r.myReplacedRoot == oldRoot) {\n          rr = r;\n          break;\n        }\n      }\n      if (rr == null) {\n        myDelta.add(rr = new ReplacedRoot(oldRoot, newRoot));\n        myReplacedRoots.add(rr);\n      } else {\n        rr.myReplacements.add(newRoot);\n      }\n    }\n  }","commit_id":"d2c112929a23b66832dbf2b0ed4cf487be4be4a4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void dismissTopRule(SNode ruleConsequence) {\n      SNode message = RuleUtil.getDismissTopRule_message(ruleConsequence);\n      DismissTopMappingRuleException.MessageType messageType = GeneratorUtilEx.getGeneratorMessage_kind(message);\n      String text = GeneratorUtilEx.getGeneratorMessage_text(message);\n      GeneratorUtil.log(getLog(),ruleConsequence.getReference(), messageType, text, GeneratorUtil.describeIfExists(myTemplateContext.getInput(), \"input node\"));\n      myDismissRuleException = new DismissTopMappingRuleException(messageType, text);\n    }","id":104416,"modified_method":"@Override\n    public void dismissTopRule(SNode ruleConsequence) {\n      SNode message = RuleUtil.getDismissTopRule_message(ruleConsequence);\n      DismissTopMappingRuleException.MessageType messageType = GeneratorUtilEx.getGeneratorMessage_kind(message);\n      String text = GeneratorUtilEx.getGeneratorMessage_text(message);\n      if (message != null) {\n        GeneratorUtil.log(getLog(),ruleConsequence.getReference(), messageType, text, GeneratorUtil.describeIfExists(myTemplateContext.getInput(), \"input node\"));\n      }\n      myDismissRuleException = new DismissTopMappingRuleException(messageType, text);\n    }","commit_id":"d2c112929a23b66832dbf2b0ed4cf487be4be4a4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean apply(boolean isPrimary) throws GenerationFailureException, GenerationCanceledException {\n    checkMonitorCanceled();\n    final IPerformanceTracer ttrace = getGeneratorSessionContext().getPerformanceTracer();\n    myAreMappingsReady = false;\n    // prepare weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor = new WeavingProcessor(this);\n    myWeavingProcessor.prepareWeavingRules(getInputModel(), myRuleManager.getWeaving_MappingRules());\n    ttrace.pop();\n\n\n    ttrace.push(\"reductions\", false);\n    applyReductions(isPrimary);\n    ttrace.pop();\n\n    if (myDeltaBuilder != null) {\n      ttrace.push(\"apply delta changes\", false);\n//      myDeltaBuilder.dump();\n      myInplaceModelChange = true;\n      if (myDeltaBuilder.hasChanges()) {\n        myDeltaBuilder.prepareReferences(getInputModel(), this);\n        myDeltaBuilder.applyInplace(getInputModel(), this);\n      }\n      myOutputRoots.clear();\n      myDeltaBuilder = null;\n      ttrace.pop();\n    }\n\n    myAreMappingsReady = true;\n    myChanged |= myDependenciesBuilder.isStepRequired(); // TODO optimize: if step is required, it should be the last step\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty() && !myWeavingProcessor.hasWeavingRulesToApply()) {\n      return false;\n    }\n\n    if (!myInplaceModelChange) {\n      // publish roots\n      for (SNode outputRoot : myOutputRoots) {\n        myOutputModel.addRootNode(outputRoot);\n      }\n\n      // reload \"required\" roots from cache\n      ttrace.push(\"reloading roots from cache\", false);\n      myDependenciesBuilder.reloadRequired(getMappings());\n      ttrace.pop();\n    } // XXX if in-place change, every required root has been reloaded on previous step, imo\n\n    checkMonitorCanceled();\n\n    if (myWeavingProcessor.hasWeavingRulesToApply()) {\n      ttrace.push(\"weavings\", false);\n      myWeavingProcessor.apply();\n      myWeavingProcessor = null;\n      ttrace.pop();\n    }\n\n    // execute mapper in all $MAP_SRC$/$MAP_SRCL$\n    ttrace.push(\"delayed mappings\", false);\n    myDelayedChanges.doAllChanges(this);\n    ttrace.pop();\n\n    checkMonitorCanceled();\n\n    if (!myPostponedRefs.isEmpty()) {\n      // new unresolved references could appear after applying reduction rules (all delayed changes should be done before this, like replacing children)\n      ttrace.push(\"restoring references\", false);\n      myPostponedRefs.prepare();\n      myPostponedRefs.replace();\n      ttrace.pop();\n    }\n\n    if (myChanged || isPrimary) {\n      // advance blocked reduction data\n      getBlockedReductionsData().advanceStep();\n      checkMonitorCanceled();\n    }\n    return myChanged;\n  }","id":104417,"modified_method":"public boolean apply(boolean isPrimary) throws GenerationFailureException, GenerationCanceledException {\n    checkMonitorCanceled();\n    final IPerformanceTracer ttrace = getGeneratorSessionContext().getPerformanceTracer();\n    myAreMappingsReady = false;\n    // prepare weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor = new WeavingProcessor(this);\n    myWeavingProcessor.prepareWeavingRules(getInputModel(), myRuleManager.getWeaving_MappingRules());\n    ttrace.pop();\n\n\n    ttrace.push(\"reductions\", false);\n    applyReductions(isPrimary);\n    ttrace.pop();\n    myInplaceModelChange = myDeltaBuilder != null;\n\n    myAreMappingsReady = true;\n    myChanged |= myDependenciesBuilder.isStepRequired(); // TODO optimize: if step is required, it should be the last step\n\n    if (myDeltaBuilder == null) {\n      // publish roots\n      for (SNode outputRoot : myOutputRoots) {\n        myOutputModel.addRootNode(outputRoot);\n      }\n\n      // reload \"required\" roots from cache\n      ttrace.push(\"reloading roots from cache\", false);\n      myDependenciesBuilder.reloadRequired(getMappings());\n      ttrace.pop();\n    } // XXX if in-place change, every required root has been reloaded on previous step, imo\n\n    if (myWeavingProcessor.hasWeavingRulesToApply()) {\n      checkMonitorCanceled();\n      ttrace.push(\"weavings\", false);\n      myWeavingProcessor.apply();\n      myWeavingProcessor = null;\n      ttrace.pop();\n    }\n\n    if (!myDelayedChanges.isEmpty()) {\n      checkMonitorCanceled();\n      // execute mapper in all $MAP_SRC$/$MAP_SRCL$\n      ttrace.push(\"delayed mappings\", false);\n      myDelayedChanges.doAllChanges(this);\n      ttrace.pop();\n    }\n\n    if (myDeltaBuilder != null) {\n      ttrace.push(\"apply delta changes\", false);\n//      myDeltaBuilder.dump();\n      if (myDeltaBuilder.hasChanges()) {\n        myDeltaBuilder.prepareReferences(getInputModel(), this);\n        myDeltaBuilder.applyInplace(getInputModel());\n      }\n      myOutputRoots.clear();\n      myDeltaBuilder = null;\n      ttrace.pop();\n    }\n\n    if (!myPostponedRefs.isEmpty()) {\n      // new unresolved references could appear after applying reduction rules (all delayed changes should be done before this, like replacing children)\n      ttrace.push(\"restoring references\", false);\n      myPostponedRefs.prepare();\n      myPostponedRefs.replace();\n      ttrace.pop();\n    }\n\n    if (myChanged || isPrimary) {\n      // advance blocked reduction data\n      getBlockedReductionsData().advanceStep();\n      checkMonitorCanceled();\n    }\n    return myChanged;\n  }","commit_id":"d2c112929a23b66832dbf2b0ed4cf487be4be4a4","url":"https://github.com/JetBrains/MPS"},{"original_method":"void replacePlaceholderNode(@NotNull SNode placeholder, @NotNull SNode actual, @NotNull TemplateContext ctx, SNodeReference templateNode) {\n    assert placeholder.getModel() != null || placeholder.getParent() != null : \"Can't replace node that is not part of another structure (hangs in the air)\";\n    // check new child\n    SNode parent = placeholder.getParent();\n    final boolean isRoot = placeholder.getModel() != null && parent == null;\n    if (parent != null) {\n      String childRole = placeholder.getRoleInParent();\n      final Status status = getChildRoleValidator(parent, childRole).validate(actual);\n      if (status != null) {\n        status.reportProblem(false, parent, \"\",\n            GeneratorUtil.describe(ctx.getInput(), \"input\"),\n            GeneratorUtil.describe(templateNode, \"template\"));\n      }\n    }\n    SNodeUtil.replaceWithAnother(placeholder, actual);\n    if (isRoot) {\n      myDependenciesBuilder.rootReplaced(placeholder, actual);\n    }\n    getGenerationTracer().replaceOutputNode(placeholder, actual);\n  }","id":104418,"modified_method":"void replacePlaceholderNode(@NotNull SNode placeholder, @NotNull SNode actual, @NotNull TemplateContext ctx, SNodeReference templateNode) {\n    assert placeholder.getModel() != null || placeholder.getParent() != null : \"Can't replace node that is not part of another structure (hangs in the air)\";\n    // check new child\n    SNode parent = placeholder.getParent();\n    if (parent != null) {\n      String childRole = placeholder.getRoleInParent();\n      final Status status = getChildRoleValidator(parent, childRole).validate(actual);\n      if (status != null) {\n        status.reportProblem(false, parent, \"\",\n            GeneratorUtil.describe(ctx.getInput(), \"input\"),\n            GeneratorUtil.describe(templateNode, \"template\"));\n      }\n    }\n    if (myDeltaBuilder != null) {\n      myDeltaBuilder.replacePlaceholderNode(placeholder, actual);\n    } else {\n      SNodeUtil.replaceWithAnother(placeholder, actual);\n    }\n    if (parent == null) {\n      myDependenciesBuilder.rootReplaced(placeholder, actual);\n    }\n    getGenerationTracer().replaceOutputNode(placeholder, actual);\n  }","commit_id":"d2c112929a23b66832dbf2b0ed4cf487be4be4a4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyInplace(SModel inputModel, TemplateGenerator generator) {\n    HashSet<SNode> allReplacedNodes = new HashSet<SNode>();\n    for (CopyRoot root : myCopyRoots) {\n      if (root.deleted) {\n        // reference target under deleted root needs update, too\n        allReplacedNodes.add(root.myRoot);\n      } else {\n        allReplacedNodes.addAll(root.getReplacedNodes());\n      }\n    }\n    for (ReplacedRoot rr : myReplacedRoots) {\n      allReplacedNodes.add(rr.myReplacedRoot);\n    }\n    // FastNodeFinder update mechanism performs poorly (badly, in fact) with massive in-place updates.\n    // It's faster to rebuild FNF completely than to update it. E.g step 4 for lang.editor/editor\n    // spent 90 seconds out of 105 in replace of 9k children\n    // TODO make use of standalone FNF\n    if (inputModel instanceof SModelInternal) {\n      ((SModelInternal) inputModel).disposeFastNodeFinder();\n    }\n    final SModelReference inputModelRef = inputModel.getReference();\n    // update references between changed model elements\n    for (CopyRoot root : myCopyRoots) {\n      final Set<SNode> replacedNodes;\n      if (root.deleted) {\n        continue;\n      }\n      replacedNodes = root.getReplacedNodes();\n      TreeIterator<SNode> it = (TreeIterator<SNode>) SNodeUtil.getDescendants(root.myRoot).iterator();\n      while (it.hasNext()) {\n        SNode next = it.next();\n        if (replacedNodes.contains(next)) {\n          // nodes under replaced already have PostponedReferences\n          it.skipChildren();\n          continue;\n        }\n        for (SReference reference : next.getReferences()) {\n          assert reference instanceof PostponedReference == false : \"!!! unexpected PostponedReference in the input model\";\n          if (!inputModelRef.equals(reference.getTargetSModelReference())) {\n            continue;\n          }\n          SNode target = reference.getTargetNode();\n          while (target != null) {\n            if (allReplacedNodes.contains(target)) {\n              // reference points elsewhere in this model under a replaced node.\n              // reference needs update, its target is among replaced nodes\n              ReferenceInfo refInfo = new ReferenceInfo_CopiedInputNode(reference.getRole(), next, reference.getSourceNode(), target);\n              PostponedReference pr = generator.register(new PostponedReference(refInfo));\n              pr.setReferenceInOutputSourceNode();\n              break; // while target\n            }\n            target = target.getParent();\n          }\n        }\n      }\n    }\n    // make references to point to node directly, not (ModelId+NodeId)\n    // as it would be impossible to resolve model once root is detached\n    for (SNode rn : allReplacedNodes) {\n      for (SNode n : SNodeUtil.getDescendants(rn)) {\n        for (SReference r : n.getReferences()) {\n          if (!inputModelRef.equals(r.getTargetSModelReference()) || ! (r instanceof StaticReference)) {\n            continue;\n          }\n          ((StaticReference) r).makeDirect();\n        }\n      }\n    }\n    // make the structure change, at last\n    for (DeltaRoot dr : myDelta) {\n      // additions from NewRoot and ReplacedRoot come in the order they were scheduled to be applied\n      // not the order they were ready - to get same order in parallel gen. Although additions from replaced\n      // come to the tail of root nodes list as there's no way to keep index of root node.\n      if (dr instanceof NewRoot) {\n        inputModel.addRootNode(((NewRoot) dr).myRoot);\n      } else if (dr instanceof ReplacedRoot) {\n        ReplacedRoot rr = (ReplacedRoot) dr;\n        // XXX Seems there's no way to replace root node in its original position ?!\n        inputModel.removeRootNode(rr.myReplacedRoot);\n        for (SNode replacement : rr.myReplacements) {\n          inputModel.addRootNode(replacement);\n        }\n      } else {\n        CopyRoot root = (CopyRoot) dr;\n        if (root.deleted) {\n          assert root.myRoot.getModel() == inputModel;\n          inputModel.removeRootNode(root.myRoot);\n          continue;\n        }\n        // replace nodes\n        for (SubTree tree : root.mySubTrees) {\n          if (tree.isCopySrcRoot()) {\n            continue;\n          }\n          assert tree.myInputNode.getModel() == inputModel;\n          SNode inputParentNode = tree.myInputNode.getParent();\n          SNode anchor = tree.myInputNode.getNextSibling();\n          inputParentNode.removeChild(tree.myInputNode);\n          for (SNode replacement : tree.mySubTree) {\n            inputParentNode.insertChildBefore(tree.myRoleInParent, replacement, anchor);\n          }\n        }\n      }\n    }\n  }","id":104419,"modified_method":"public void applyInplace(SModel inputModel, TemplateGenerator generator) {\n    // make the structure change, at last\n    for (DeltaRoot dr : myDelta) {\n      // additions from NewRoot and ReplacedRoot come in the order they were scheduled to be applied\n      // not the order they were ready - to get same order in parallel gen. Although additions from replaced\n      // come to the tail of root nodes list as there's no way to keep index of root node.\n      if (dr instanceof NewRoot) {\n        inputModel.addRootNode(((NewRoot) dr).myRoot);\n      } else if (dr instanceof ReplacedRoot) {\n        ReplacedRoot rr = (ReplacedRoot) dr;\n        // XXX Seems there's no way to replace root node in its original position ?!\n        inputModel.removeRootNode(rr.myReplacedRoot);\n        for (SNode replacement : rr.myReplacements) {\n          inputModel.addRootNode(replacement);\n        }\n      } else {\n        CopyRoot root = (CopyRoot) dr;\n        if (root.deleted) {\n          assert root.myRoot.getModel() == inputModel;\n          inputModel.removeRootNode(root.myRoot);\n          continue;\n        }\n        // replace nodes\n        for (SubTree tree : root.mySubTrees) {\n          if (tree.isCopySrcRoot()) {\n            continue;\n          }\n          assert tree.myInputNode.getModel() == inputModel;\n          SNode inputParentNode = tree.myInputNode.getParent();\n          SNode anchor = tree.myInputNode.getNextSibling();\n          inputParentNode.removeChild(tree.myInputNode);\n          for (SNode replacement : tree.mySubTree) {\n            inputParentNode.insertChildBefore(tree.myRoleInParent, replacement, anchor);\n          }\n        }\n      }\n    }\n  }","commit_id":"f1bbc6dddab5a9feeb63341f96f6f2a118a09fcc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean apply(boolean isPrimary) throws GenerationFailureException, GenerationCanceledException {\n    checkMonitorCanceled();\n    final IPerformanceTracer ttrace = getGeneratorSessionContext().getPerformanceTracer();\n    myAreMappingsReady = false;\n    // prepare weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor = new WeavingProcessor(this);\n    myWeavingProcessor.prepareWeavingRules(getInputModel(), myRuleManager.getWeaving_MappingRules());\n    ttrace.pop();\n\n\n    ttrace.push(\"reductions\", false);\n    applyReductions(isPrimary);\n    ttrace.pop();\n\n    if (myDeltaBuilder != null) {\n      ttrace.push(\"apply delta changes\", false);\n//      myDeltaBuilder.dump();\n      myInplaceModelChange = true;\n      if (myDeltaBuilder.hasChanges()) {\n        myDeltaBuilder.applyInplace(getInputModel(), this);\n      }\n      myOutputRoots.clear();\n      myDeltaBuilder = null;\n      ttrace.pop();\n    }\n\n    myAreMappingsReady = true;\n    myChanged |= myDependenciesBuilder.isStepRequired(); // TODO optimize: if step is required, it should be the last step\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty() && !myRuleManager.hasWeavings()) {\n      return false;\n    }\n\n    if (!myInplaceModelChange) {\n      // publish roots\n      for (SNode outputRoot : myOutputRoots) {\n        myOutputModel.addRootNode(outputRoot);\n      }\n\n      // reload \"required\" roots from cache\n      ttrace.push(\"reloading roots from cache\", false);\n      myDependenciesBuilder.reloadRequired(getMappings());\n      ttrace.pop();\n    } // XXX if in-place change, every required root has been reloaded on previous step, imo\n\n    checkMonitorCanceled();\n\n    // weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor.apply();\n    myWeavingProcessor = null;\n    ttrace.pop();\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty()) {\n      return false;\n    }\n\n    // execute mapper in all $MAP_SRC$/$MAP_SRCL$\n    ttrace.push(\"delayed mappings\", false);\n    myDelayedChanges.doAllChanges(this);\n    ttrace.pop();\n\n    checkMonitorCanceled();\n\n    if (myChanged || isPrimary) {\n      // new unresolved references could appear after applying reduction rules (all delayed changes should be done before this, like replacing children)\n      ttrace.push(\"restoring references\", false);\n      myPostponedRefs.prepare();\n      myPostponedRefs.replace();\n      ttrace.pop();\n\n      // advance blocked reduction data\n      getBlockedReductionsData().advanceStep();\n      checkMonitorCanceled();\n    }\n    return myChanged;\n  }","id":104420,"modified_method":"public boolean apply(boolean isPrimary) throws GenerationFailureException, GenerationCanceledException {\n    checkMonitorCanceled();\n    final IPerformanceTracer ttrace = getGeneratorSessionContext().getPerformanceTracer();\n    myAreMappingsReady = false;\n    // prepare weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor = new WeavingProcessor(this);\n    myWeavingProcessor.prepareWeavingRules(getInputModel(), myRuleManager.getWeaving_MappingRules());\n    ttrace.pop();\n\n\n    ttrace.push(\"reductions\", false);\n    applyReductions(isPrimary);\n    ttrace.pop();\n\n    if (myDeltaBuilder != null) {\n      ttrace.push(\"apply delta changes\", false);\n//      myDeltaBuilder.dump();\n      myInplaceModelChange = true;\n      if (myDeltaBuilder.hasChanges()) {\n        myDeltaBuilder.prepareReferences(getInputModel(), this);\n        myDeltaBuilder.applyInplace(getInputModel(), this);\n      }\n      myOutputRoots.clear();\n      myDeltaBuilder = null;\n      ttrace.pop();\n    }\n\n    myAreMappingsReady = true;\n    myChanged |= myDependenciesBuilder.isStepRequired(); // TODO optimize: if step is required, it should be the last step\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty() && !myWeavingProcessor.hasWeavingRulesToApply()) {\n      return false;\n    }\n\n    if (!myInplaceModelChange) {\n      // publish roots\n      for (SNode outputRoot : myOutputRoots) {\n        myOutputModel.addRootNode(outputRoot);\n      }\n\n      // reload \"required\" roots from cache\n      ttrace.push(\"reloading roots from cache\", false);\n      myDependenciesBuilder.reloadRequired(getMappings());\n      ttrace.pop();\n    } // XXX if in-place change, every required root has been reloaded on previous step, imo\n\n    checkMonitorCanceled();\n\n    if (myWeavingProcessor.hasWeavingRulesToApply()) {\n      ttrace.push(\"weavings\", false);\n      myWeavingProcessor.apply();\n      myWeavingProcessor = null;\n      ttrace.pop();\n    }\n\n    // execute mapper in all $MAP_SRC$/$MAP_SRCL$\n    ttrace.push(\"delayed mappings\", false);\n    myDelayedChanges.doAllChanges(this);\n    ttrace.pop();\n\n    checkMonitorCanceled();\n\n    if (!myPostponedRefs.isEmpty()) {\n      // new unresolved references could appear after applying reduction rules (all delayed changes should be done before this, like replacing children)\n      ttrace.push(\"restoring references\", false);\n      myPostponedRefs.prepare();\n      myPostponedRefs.replace();\n      ttrace.pop();\n    }\n\n    if (myChanged || isPrimary) {\n      // advance blocked reduction data\n      getBlockedReductionsData().advanceStep();\n      checkMonitorCanceled();\n    }\n    return myChanged;\n  }","commit_id":"f1bbc6dddab5a9feeb63341f96f6f2a118a09fcc","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Release an instance back into the cache (this will reset the \n     * state)\n     */\n    public static void release(ReusableGZIPInputStream released) {\n        synchronized (_available) {\n            if (_available.size() < 8)\n                _available.add(released);\n        }\n    }","id":104421,"modified_method":"/**\n     * Release an instance back into the cache (this will reset the \n     * state)\n     */\n    public static void release(ReusableGZIPInputStream released) {\n        if (ENABLE_CACHING)\n            _available.offer(released);\n    }","commit_id":"43b4fe830074d998a74fa21fe324b853283770d9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Pull a cached instance\n     */\n    public static ReusableGZIPInputStream acquire() {\n        ReusableGZIPInputStream rv = null;\n        synchronized (_available) {\n            if (_available.size() > 0)\n                rv = (ReusableGZIPInputStream)_available.remove(0);\n        }\n        if (rv == null) {\n            rv = new ReusableGZIPInputStream();\n        } \n        return rv;\n    }","id":104422,"modified_method":"/**\n     * Pull a cached instance\n     */\n    public static ReusableGZIPInputStream acquire() {\n        ReusableGZIPInputStream rv = null;\n        // Apache Harmony 5.0M13 Deflater doesn't work after reset()\n        if (ENABLE_CACHING)\n            rv = _available.poll();\n        if (rv == null) {\n            rv = new ReusableGZIPInputStream();\n        } \n        return rv;\n    }","commit_id":"43b4fe830074d998a74fa21fe324b853283770d9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Pull a cached instance\n     */\n    public static ReusableGZIPOutputStream acquire() {\n        ReusableGZIPOutputStream rv = null;\n        synchronized (_available) {\n            if (_available.size() > 0)\n                rv = (ReusableGZIPOutputStream)_available.remove(0);\n        }\n        if (rv == null) {\n            rv = new ReusableGZIPOutputStream();\n        } \n        return rv;\n    }","id":104423,"modified_method":"/**\n     * Pull a cached instance\n     */\n    public static ReusableGZIPOutputStream acquire() {\n        ReusableGZIPOutputStream rv = null;\n        if (ENABLE_CACHING)\n            rv = _available.poll();\n        if (rv == null) {\n            rv = new ReusableGZIPOutputStream();\n        } \n        return rv;\n    }","commit_id":"43b4fe830074d998a74fa21fe324b853283770d9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Release an instance back into the cache (this will discard any\n     * state)\n     */\n    public static void release(ReusableGZIPOutputStream out) {\n        out.reset();\n        synchronized (_available) {\n            if (_available.size() < 16)\n                _available.add(out);\n        }\n    }","id":104424,"modified_method":"/**\n     * Release an instance back into the cache (this will discard any\n     * state)\n     */\n    public static void release(ReusableGZIPOutputStream out) {\n        out.reset();\n        if (ENABLE_CACHING)\n            _available.offer(out);\n    }","commit_id":"43b4fe830074d998a74fa21fe324b853283770d9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Get the next available structure, either from the cache or a brand new one\n     *\n     */\n    public final KeyCacheEntry acquireKey() {\n        synchronized (_availableKeys) {\n            if (!_availableKeys.isEmpty())\n                return (KeyCacheEntry)_availableKeys.remove(0);\n        }\n        return createNew();\n    }","id":104425,"modified_method":"/**\n     * Get the next available structure, either from the cache or a brand new one\n     *\n     */\n    public final KeyCacheEntry acquireKey() {\n        KeyCacheEntry rv = _availableKeys.poll();\n        if (rv != null)\n            return rv;\n        return createNew();\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Put this structure back onto the available cache for reuse\n     *\n     */\n    public final void releaseKey(KeyCacheEntry key) {\n        synchronized (_availableKeys) {\n            if (_availableKeys.size() < MAX_KEYS)\n                _availableKeys.add(key);\n        }\n    }","id":104426,"modified_method":"/**\n     * Put this structure back onto the available cache for reuse\n     *\n     */\n    public final void releaseKey(KeyCacheEntry key) {\n        _availableKeys.offer(key);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public CryptixAESKeyCache() {\n        _availableKeys = new ArrayList(MAX_KEYS);\n    }","id":104427,"modified_method":"public CryptixAESKeyCache() {\n        _availableKeys = new LinkedBlockingQueue(MAX_KEYS);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static Hash calculateHash(byte[] source, int offset, int len) {\n        SHA1 h = new SHA1();\n        h.engineUpdate(source, offset, len);\n        byte digested[] = h.digest();\n        return new Hash(digested);\n    }","id":104428,"modified_method":"/** @return hash SHA-1 hash, NOT a SHA-256 hash */\n    public static SHA1Hash calculateHash(byte[] source, int offset, int len) {\n        SHA1 h = new SHA1();\n        h.engineUpdate(source, offset, len);\n        byte digested[] = h.digest();\n        return new SHA1Hash(digested);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public boolean verifySignature(Signature signature, Hash hash, SigningPublicKey verifyingKey) {\n        long start = _context.clock().now();\n\n        try {\n            byte[] sigbytes = signature.getData();\n            byte rbytes[] = new byte[20];\n            byte sbytes[] = new byte[20];\n            for (int x = 0; x < 40; x++) {\n                if (x < 20) {\n                    rbytes[x] = sigbytes[x];\n                } else {\n                    sbytes[x - 20] = sigbytes[x];\n                }\n            }\n            BigInteger s = new NativeBigInteger(1, sbytes);\n            BigInteger r = new NativeBigInteger(1, rbytes);\n            BigInteger y = new NativeBigInteger(1, verifyingKey.getData());\n            BigInteger w = null;\n            try {\n                w = s.modInverse(CryptoConstants.dsaq);\n            } catch (ArithmeticException ae) {\n                return false;\n            }\n            byte data[] = hash.getData();\n            NativeBigInteger bi = new NativeBigInteger(1, data);\n            BigInteger u1 = bi.multiply(w).mod(CryptoConstants.dsaq);\n            BigInteger u2 = r.multiply(w).mod(CryptoConstants.dsaq);\n            BigInteger modval = CryptoConstants.dsag.modPow(u1, CryptoConstants.dsap);\n            BigInteger modmulval = modval.multiply(y.modPow(u2,CryptoConstants.dsap));\n            BigInteger v = (modmulval).mod(CryptoConstants.dsap).mod(CryptoConstants.dsaq);\n\n            boolean ok = v.compareTo(r) == 0;\n\n            long diff = _context.clock().now() - start;\n            if (diff > 1000) {\n                if (_log.shouldLog(Log.WARN)) \n                    _log.warn(\"Took too long to verify the signature (\" + diff + \"ms)\");\n            }\n            return ok;\n        } catch (Exception e) {\n            _log.log(Log.CRIT, \"Error verifying the signature\", e);\n            return false;\n        }\n    }","id":104429,"modified_method":"/** @param hash SHA-1 hash, NOT a SHA-256 hash */\n    public boolean verifySignature(Signature signature, SHA1Hash hash, SigningPublicKey verifyingKey) {\n        long start = _context.clock().now();\n\n        try {\n            byte[] sigbytes = signature.getData();\n            byte rbytes[] = new byte[20];\n            byte sbytes[] = new byte[20];\n            for (int x = 0; x < 40; x++) {\n                if (x < 20) {\n                    rbytes[x] = sigbytes[x];\n                } else {\n                    sbytes[x - 20] = sigbytes[x];\n                }\n            }\n            BigInteger s = new NativeBigInteger(1, sbytes);\n            BigInteger r = new NativeBigInteger(1, rbytes);\n            BigInteger y = new NativeBigInteger(1, verifyingKey.getData());\n            BigInteger w = null;\n            try {\n                w = s.modInverse(CryptoConstants.dsaq);\n            } catch (ArithmeticException ae) {\n                return false;\n            }\n            byte data[] = hash.getData();\n            NativeBigInteger bi = new NativeBigInteger(1, data);\n            BigInteger u1 = bi.multiply(w).mod(CryptoConstants.dsaq);\n            BigInteger u2 = r.multiply(w).mod(CryptoConstants.dsaq);\n            BigInteger modval = CryptoConstants.dsag.modPow(u1, CryptoConstants.dsap);\n            BigInteger modmulval = modval.multiply(y.modPow(u2,CryptoConstants.dsap));\n            BigInteger v = (modmulval).mod(CryptoConstants.dsap).mod(CryptoConstants.dsaq);\n\n            boolean ok = v.compareTo(r) == 0;\n\n            long diff = _context.clock().now() - start;\n            if (diff > 1000) {\n                if (_log.shouldLog(Log.WARN)) \n                    _log.warn(\"Took too long to verify the signature (\" + diff + \"ms)\");\n            }\n            return ok;\n        } catch (Exception e) {\n            _log.log(Log.CRIT, \"Error verifying the signature\", e);\n            return false;\n        }\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Signature sign(InputStream in, SigningPrivateKey signingKey) {\n        if ((signingKey == null) || (in == null) ) return null;\n        Hash h = calculateHash(in);\n        return sign(h, signingKey);\n    }","id":104430,"modified_method":"public Signature sign(InputStream in, SigningPrivateKey signingKey) {\n        if ((signingKey == null) || (in == null) ) return null;\n        SHA1Hash h = calculateHash(in);\n        return sign(h, signingKey);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Signature sign(byte data[], int offset, int length, SigningPrivateKey signingKey) {\n        if ((signingKey == null) || (data == null) || (data.length <= 0)) return null;\n        Hash h = calculateHash(data, offset, length);\n        return sign(h, signingKey);\n    }","id":104431,"modified_method":"public Signature sign(byte data[], int offset, int length, SigningPrivateKey signingKey) {\n        if ((signingKey == null) || (data == null) || (data.length <= 0)) return null;\n        SHA1Hash h = calculateHash(data, offset, length);\n        return sign(h, signingKey);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Hash calculateHash(InputStream in) {\n        SHA1 digest = new SHA1();\n        byte buf[] = new byte[64];\n        int read = 0;\n        try {\n            while ( (read = in.read(buf)) != -1) {\n                digest.engineUpdate(buf, 0, read);\n            }\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Unable to hash the stream\", ioe);\n            return null;\n        }\n        return new Hash(digest.engineDigest());\n    }","id":104432,"modified_method":"/** @return hash SHA-1 hash, NOT a SHA-256 hash */\n    public SHA1Hash calculateHash(InputStream in) {\n        SHA1 digest = new SHA1();\n        byte buf[] = new byte[64];\n        int read = 0;\n        try {\n            while ( (read = in.read(buf)) != -1) {\n                digest.engineUpdate(buf, 0, read);\n            }\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Unable to hash the stream\", ioe);\n            return null;\n        }\n        return new SHA1Hash(digest.engineDigest());\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Signature sign(Hash hash, SigningPrivateKey signingKey) {\n        if ((signingKey == null) || (hash == null)) return null;\n        long start = _context.clock().now();\n\n        Signature sig = new Signature();\n        BigInteger k;\n\n        boolean ok = false;\n        do {\n            k = new BigInteger(160, _context.random());\n            ok = k.compareTo(CryptoConstants.dsaq) != 1;\n            ok = ok && !k.equals(BigInteger.ZERO);\n            //System.out.println(\"K picked (ok? \" + ok + \"): \" + k.bitLength() + \": \" + k.toString());\n        } while (!ok);\n\n        BigInteger r = CryptoConstants.dsag.modPow(k, CryptoConstants.dsap).mod(CryptoConstants.dsaq);\n        BigInteger kinv = k.modInverse(CryptoConstants.dsaq);\n\n        BigInteger M = new NativeBigInteger(1, hash.getData());\n        BigInteger x = new NativeBigInteger(1, signingKey.getData());\n        BigInteger s = (kinv.multiply(M.add(x.multiply(r)))).mod(CryptoConstants.dsaq);\n\n        byte[] rbytes = r.toByteArray();\n        byte[] sbytes = s.toByteArray();\n        byte[] out = new byte[40];\n\n        // (q^random)%p is computationally random\n        _context.random().harvester().feedEntropy(\"DSA.sign\", rbytes, 0, rbytes.length);\n        \n        if (rbytes.length == 20) {\n            for (int i = 0; i < 20; i++) {\n                out[i] = rbytes[i];\n            }\n        } else if (rbytes.length == 21) {\n            for (int i = 0; i < 20; i++) {\n                out[i] = rbytes[i + 1];\n            }\n        } else {\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Using short rbytes.length [\" + rbytes.length + \"]\");\n            for (int i = 0; i < rbytes.length; i++)\n                out[i + 20 - rbytes.length] = rbytes[i];\n        }\n        if (sbytes.length == 20) {\n            for (int i = 0; i < 20; i++) {\n                out[i + 20] = sbytes[i];\n            }\n        } else if (sbytes.length == 21) {\n            for (int i = 0; i < 20; i++) {\n                out[i + 20] = sbytes[i + 1];\n            }\n        } else {\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Using short sbytes.length [\" + sbytes.length + \"]\");\n            for (int i = 0; i < sbytes.length; i++)\n                out[i + 20 + 20 - sbytes.length] = sbytes[i];\n        }\n        sig.setData(out);\n\n        long diff = _context.clock().now() - start;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Took too long to sign (\" + diff + \"ms)\");\n        }\n\n        return sig;\n    }","id":104433,"modified_method":"/** @param hash SHA-1 hash, NOT a SHA-256 hash */\n    public Signature sign(SHA1Hash hash, SigningPrivateKey signingKey) {\n        if ((signingKey == null) || (hash == null)) return null;\n        long start = _context.clock().now();\n\n        Signature sig = new Signature();\n        BigInteger k;\n\n        boolean ok = false;\n        do {\n            k = new BigInteger(160, _context.random());\n            ok = k.compareTo(CryptoConstants.dsaq) != 1;\n            ok = ok && !k.equals(BigInteger.ZERO);\n            //System.out.println(\"K picked (ok? \" + ok + \"): \" + k.bitLength() + \": \" + k.toString());\n        } while (!ok);\n\n        BigInteger r = CryptoConstants.dsag.modPow(k, CryptoConstants.dsap).mod(CryptoConstants.dsaq);\n        BigInteger kinv = k.modInverse(CryptoConstants.dsaq);\n\n        BigInteger M = new NativeBigInteger(1, hash.getData());\n        BigInteger x = new NativeBigInteger(1, signingKey.getData());\n        BigInteger s = (kinv.multiply(M.add(x.multiply(r)))).mod(CryptoConstants.dsaq);\n\n        byte[] rbytes = r.toByteArray();\n        byte[] sbytes = s.toByteArray();\n        byte[] out = new byte[40];\n\n        // (q^random)%p is computationally random\n        _context.random().harvester().feedEntropy(\"DSA.sign\", rbytes, 0, rbytes.length);\n        \n        if (rbytes.length == 20) {\n            for (int i = 0; i < 20; i++) {\n                out[i] = rbytes[i];\n            }\n        } else if (rbytes.length == 21) {\n            for (int i = 0; i < 20; i++) {\n                out[i] = rbytes[i + 1];\n            }\n        } else {\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Using short rbytes.length [\" + rbytes.length + \"]\");\n            for (int i = 0; i < rbytes.length; i++)\n                out[i + 20 - rbytes.length] = rbytes[i];\n        }\n        if (sbytes.length == 20) {\n            for (int i = 0; i < 20; i++) {\n                out[i + 20] = sbytes[i];\n            }\n        } else if (sbytes.length == 21) {\n            for (int i = 0; i < 20; i++) {\n                out[i + 20] = sbytes[i + 1];\n            }\n        } else {\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Using short sbytes.length [\" + sbytes.length + \"]\");\n            for (int i = 0; i < sbytes.length; i++)\n                out[i + 20 + 20 - sbytes.length] = sbytes[i];\n        }\n        sig.setData(out);\n\n        long diff = _context.clock().now() - start;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Took too long to sign (\" + diff + \"ms)\");\n        }\n\n        return sig;\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    protected I2PHMac acquire() {\n        synchronized (_available) {\n            if (!_available.isEmpty())\n                return (I2PHMac)_available.remove(0);\n        }\n        // the HMAC is hardcoded to use SHA256 digest size\n        // for backwards compatability.  next time we have a backwards\n        // incompatible change, we should update this by removing \", 32\"\n        return new I2PHMac(new Sha256ForMAC());\n    }","id":104434,"modified_method":"@Override\n    protected I2PHMac acquire() {\n        I2PHMac rv = _available.poll();\n        if (rv != null)\n            return rv;\n        // the HMAC is hardcoded to use SHA256 digest size\n        // for backwards compatability.  next time we have a backwards\n        // incompatible change, we should update this by removing \", 32\"\n        return new I2PHMac(new Sha256ForMAC());\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private byte[] acquireTmp() {\n        byte rv[] = null;\n        synchronized (_availableTmp) {\n            if (!_availableTmp.isEmpty())\n                rv = (byte[])_availableTmp.remove(0);\n        }\n        if (rv != null)\n            Arrays.fill(rv, (byte)0x0);\n        else\n            rv = new byte[Hash.HASH_LENGTH];\n        return rv;\n    }","id":104435,"modified_method":"private byte[] acquireTmp() {\n        byte rv[] = _availableTmp.poll();\n        if (rv != null)\n            Arrays.fill(rv, (byte)0x0);\n        else\n            rv = new byte[Hash.HASH_LENGTH];\n        return rv;\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public HMACGenerator(I2PAppContext context) {\n        _context = context;\n        _available = new ArrayList(32);\n        _availableTmp = new ArrayList(32);\n    }","id":104436,"modified_method":"public HMACGenerator(I2PAppContext context) {\n        _context = context;\n        _available = new LinkedBlockingQueue(32);\n        _availableTmp = new LinkedBlockingQueue(32);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected I2PHMac acquire() {\n        synchronized (_available) {\n            if (!_available.isEmpty())\n                return (I2PHMac)_available.remove(0);\n        }\n        // the HMAC is hardcoded to use SHA256 digest size\n        // for backwards compatability.  next time we have a backwards\n        // incompatible change, we should update this by removing \", 32\"\n        return new I2PHMac(new MD5Digest(), 32);\n    }","id":104437,"modified_method":"protected I2PHMac acquire() {\n        I2PHMac rv = _available.poll();\n        if (rv != null)\n            return rv;\n        // the HMAC is hardcoded to use SHA256 digest size\n        // for backwards compatability.  next time we have a backwards\n        // incompatible change, we should update this by removing \", 32\"\n        return new I2PHMac(new MD5Digest(), 32);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void release(Mac mac) {\n        synchronized (_available) {\n            if (_available.size() < 64)\n                _available.add(mac);\n        }\n    }","id":104438,"modified_method":"private void release(I2PHMac mac) {\n        _available.offer(mac);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void releaseTmp(byte tmp[]) {\n        synchronized (_availableTmp) {\n            if (_availableTmp.size() < 64)\n                _availableTmp.add((Object)tmp);\n        }\n    }","id":104439,"modified_method":"private void releaseTmp(byte tmp[]) {\n        _availableTmp.offer(tmp);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private static final int addValues(BigInteger yk[]) {\n        int sz = 0;\n        synchronized (_values) {\n            _values.add(yk);\n            sz = _values.size();\n        }\n        return sz;\n    }","id":104440,"modified_method":"/** @return true if successful, false if full */\n    private static final boolean addValues(BigInteger yk[]) {\n        return _values.offer(yk);\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private static final int getSize() {\n        synchronized (_values) {\n            return _values.size();\n        }\n    }","id":104441,"modified_method":"private static final int getSize() {\n        return _values.size();\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private static final BigInteger[] generateYK() {\n        NativeBigInteger k = null;\n        BigInteger y = null;\n        long t0 = 0;\n        long t1 = 0;\n        while (k == null) {\n            t0 = Clock.getInstance().now();\n            k = new NativeBigInteger(KeyGenerator.PUBKEY_EXPONENT_SIZE, RandomSource.getInstance());\n            t1 = Clock.getInstance().now();\n            if (BigInteger.ZERO.compareTo(k) == 0) {\n                k = null;\n                continue;\n            }\n            BigInteger kPlus2 = k.add(_two);\n            if (kPlus2.compareTo(CryptoConstants.elgp) > 0) k = null;\n        }\n        long t2 = Clock.getInstance().now();\n        y = CryptoConstants.elgg.modPow(k, CryptoConstants.elgp);\n\n        BigInteger yk[] = new BigInteger[2];\n        yk[0] = y;\n        yk[1] = k;\n\n        long diff = t2 - t0;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Took too long to generate YK value for ElGamal (\" + diff + \"ms)\");\n        }\n\n        return yk;\n    }","id":104442,"modified_method":"/** @return rv[0] = Y; rv[1] = K */\n    private static final BigInteger[] generateYK() {\n        NativeBigInteger k = null;\n        BigInteger y = null;\n        //long t0 = 0;\n        //long t1 = 0;\n        while (k == null) {\n            //t0 = Clock.getInstance().now();\n            k = new NativeBigInteger(KeyGenerator.PUBKEY_EXPONENT_SIZE, ctx.random());\n            //t1 = Clock.getInstance().now();\n            if (BigInteger.ZERO.compareTo(k) == 0) {\n                k = null;\n                continue;\n            }\n            BigInteger kPlus2 = k.add(_two);\n            if (kPlus2.compareTo(CryptoConstants.elgp) > 0) k = null;\n        }\n        //long t2 = Clock.getInstance().now();\n        y = CryptoConstants.elgg.modPow(k, CryptoConstants.elgp);\n\n        BigInteger yk[] = new BigInteger[2];\n        yk[0] = y;\n        yk[1] = k;\n\n        //long diff = t2 - t0;\n        //if (diff > 1000) {\n        //    if (_log.shouldLog(Log.WARN)) _log.warn(\"Took too long to generate YK value for ElGamal (\" + diff + \"ms)\");\n        //}\n\n        return yk;\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static BigInteger[] getNextYK() {\n        if (true) {\n            synchronized (_values) {\n                if (!_values.isEmpty()) {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Sufficient precalculated YK values - fetch the existing\");\n                    return (BigInteger[]) _values.remove(0);\n                }\n            }\n        }\n        if (_log.shouldLog(Log.INFO)) _log.info(\"Insufficient precalculated YK values - create a new one\");\n        return generateYK();\n    }","id":104443,"modified_method":"/** @return rv[0] = Y; rv[1] = K */\n    public static BigInteger[] getNextYK() {\n        ctx.statManager().addRateData(\"crypto.YKUsed\", 1, 0);\n        BigInteger[] rv = _values.poll();\n        if (rv != null)\n            return rv;\n        ctx.statManager().addRateData(\"crypto.YKEmpty\", 1, 0);\n        return generateYK();\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            while (true) {\n                int curSize = 0;\n                long start = Clock.getInstance().now();\n                int startSize = getSize();\n                curSize = startSize;\n                while (curSize < _minSize) {\n                    while (curSize < _maxSize) {\n                        long begin = Clock.getInstance().now();\n                        curSize = addValues(generateYK());\n                        long end = Clock.getInstance().now();\n                        if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Precalculated YK value in \" + (end - begin) + \"ms\");\n                        // for some relief...\n                        try {\n                            Thread.sleep(CALC_DELAY);\n                        } catch (InterruptedException ie) { // nop\n                        }\n                    }\n                }\n                long end = Clock.getInstance().now();\n                int numCalc = curSize - startSize;\n                if (numCalc > 0) {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Precalced \" + numCalc + \" to \" + curSize + \" in \"\n                                   + (end - start - CALC_DELAY * numCalc) + \"ms (not counting \"\n                                   + (CALC_DELAY * numCalc) + \"ms relief).  now sleeping\");\n                }\n                try {\n                    Thread.sleep(CHECK_DELAY);\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n        }","id":104444,"modified_method":"public void run() {\n            while (true) {\n                int curSize = 0;\n                //long start = Clock.getInstance().now();\n                int startSize = getSize();\n                // Adjust delay\n                if (startSize <= (_minSize / 2) && CHECK_DELAY > 1000)\n                    CHECK_DELAY -= 1000;\n                else if (startSize > (_minSize * 2) && CHECK_DELAY < 60000)\n                         CHECK_DELAY += 1000;\n                curSize = startSize;\n                if (curSize < _minSize) {\n                    for (int i = curSize; i < _maxSize; i++) {\n                        //long begin = Clock.getInstance().now();\n                        if (!addValues(generateYK()))\n                            break;\n                        //long end = Clock.getInstance().now();\n                        //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Precalculated YK value in \" + (end - begin) + \"ms\");\n                        // for some relief...\n                        try {\n                            Thread.sleep(CALC_DELAY);\n                        } catch (InterruptedException ie) { // nop\n                        }\n                    }\n                }\n                //long end = Clock.getInstance().now();\n                //int numCalc = curSize - startSize;\n                //if (numCalc > 0) {\n                //    if (_log.shouldLog(Log.DEBUG))\n                //        _log.debug(\"Precalced \" + numCalc + \" to \" + curSize + \" in \"\n                //                   + (end - start - CALC_DELAY * numCalc) + \"ms (not counting \"\n                //                   + (CALC_DELAY * numCalc) + \"ms relief).  now sleeping\");\n                //}\n                try {\n                    Thread.sleep(CHECK_DELAY);\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n        }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static void main(String args[]) {\n        RandomSource.getInstance().nextBoolean(); // warm it up\n        try {\n            Thread.sleep(20 * 1000);\n        } catch (InterruptedException ie) { // nop\n        }\n        _log.debug(\"\\n\\n\\n\\nBegin test\\n\");\n        long negTime = 0;\n        for (int i = 0; i < 5; i++) {\n            long startNeg = Clock.getInstance().now();\n            getNextYK();\n            long endNeg = Clock.getInstance().now();\n        }\n        _log.debug(\"YK fetch time for 5 runs: \" + negTime + \" @ \" + negTime / 5l + \"ms each\");\n        try {\n            Thread.sleep(30 * 1000);\n        } catch (InterruptedException ie) { // nop\n        }\n    }","id":104445,"modified_method":"public static void main(String args[]) {\n        System.out.println(\"\\n\\n\\n\\nBegin test\\n\");\n        long negTime = 0;\n        for (int i = 0; i < 5; i++) {\n            long startNeg = Clock.getInstance().now();\n            getNextYK();\n            long endNeg = Clock.getInstance().now();\n            negTime += endNeg - startNeg;\n        }\n        System.out.println(\"YK fetch time for 5 runs: \" + negTime + \" @ \" + negTime / 5l + \"ms each\");\n    }","commit_id":"53dd0c76551a3fcf1e6c501affdbedba2125f7e6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected int charsToNextDelimiter( char[] data, int offset, int length )\n        {\n            for ( int i = 0; i < length-1; i++ )\n            {\n                if ( data[offset+i] == arrayDelimiter )\n                {\n                    return i;\n                }\n            }\n            return data[offset+length-1] == arrayDelimiter ? length-1 : length;\n        }","id":104446,"modified_method":"protected int charsToNextDelimiter( char[] data, int offset, int length )\n        {\n            for ( int i = 0; i < length; i++ )\n            {\n                if ( data[offset+i] == arrayDelimiter )\n                {\n                    return i;\n                }\n            }\n            return length;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public short[] extract( char[] data, int offset, int length )\n        {\n            short[] array = new short[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                array[index] = safeCastLongToShort( extractLong( data, offset+i, numberOfChars ) );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104447,"modified_method":"@Override\n        public short[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            short[] array = numberOfValues > 0 ? new short[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                array[arrayIndex] = safeCastLongToShort( extractLong( data, offset+charIndex, numberOfChars ) );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected int numberOfValues( char[] data, int offset, int length )\n        {\n            int count = 1;\n            // \"length-1\" because even if the last char is a delimiter we shouldn't count it anyways\n            for ( int i = 0; i < length-1; i++ )\n            {\n                if ( data[offset+i] == arrayDelimiter )\n                {\n                    count++;\n                }\n            }\n            return count;\n        }","id":104448,"modified_method":"protected int numberOfValues( char[] data, int offset, int length )\n        {\n            int count = length > 0 ? 1 : 0;\n            for ( int i = 0; i < length; i++ )\n            {\n                if ( data[offset+i] == arrayDelimiter )\n                {\n                    count++;\n                }\n            }\n            return count;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public String[] extract( char[] data, int offset, int length )\n        {\n            String[] array = new String[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                array[index] = new String( data, offset+i, numberOfChars );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104449,"modified_method":"@Override\n        public String[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            String[] array = numberOfValues > 0 ? new String[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                array[arrayIndex] = new String( data, offset+charIndex, numberOfChars );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public boolean[] extract( char[] data, int offset, int length )\n        {\n            boolean[] array = new boolean[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                array[index] = extractBoolean( data, offset+i, length-i );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104450,"modified_method":"@Override\n        public boolean[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            boolean[] array = numberOfValues > 0 ? new boolean[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                array[arrayIndex] = extractBoolean( data, offset+charIndex, numberOfChars );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public double[] extract( char[] data, int offset, int length )\n        {\n            double[] array = new double[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                // TODO Figure out a way to do this conversion without round tripping to String\n                array[index] = Double.parseDouble( String.valueOf( data, offset+i, length-i ) );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104451,"modified_method":"@Override\n        public double[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            double[] array = numberOfValues > 0 ? new double[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                // TODO Figure out a way to do this conversion without round tripping to String\n                array[arrayIndex] = Double.parseDouble( String.valueOf( data, offset+charIndex, numberOfChars ) );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public long[] extract( char[] data, int offset, int length )\n        {\n            long[] array = new long[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                array[index] = extractLong( data, offset+i, numberOfChars );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104452,"modified_method":"@Override\n        public long[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            long[] array = numberOfValues > 0 ? new long[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                array[arrayIndex] = extractLong( data, offset+charIndex, numberOfChars );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static long extractLong( char[] data, int offset, int length )\n    {\n        long result = 0;\n        int i = 0;\n        boolean negate = false;\n        if ( data[offset] == '-' )\n        {\n            negate = true;\n            i++;\n        }\n        for ( ; i < length; i++ )\n        {\n            result = result*10 + digit( data[offset+i] );\n        }\n        return negate ? -result : result;\n    }","id":104453,"modified_method":"private static long extractLong( char[] data, int offset, int length )\n    {\n        if ( length == 0 )\n        {\n            throw new NumberFormatException( \"For input string \\\"\" + String.valueOf( data, offset, length ) + \"\\\"\" );\n        }\n\n        long result = 0;\n        int i = 0;\n        boolean negate = false;\n        if ( data[offset] == '-' )\n        {\n            negate = true;\n            i++;\n        }\n        for ( ; i < length; i++ )\n        {\n            result = result*10 + digit( data[offset+i] );\n        }\n        return negate ? -result : result;\n    }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public byte[] extract( char[] data, int offset, int length )\n        {\n            byte[] array = new byte[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                array[index] = safeCastLongToByte( extractLong( data, offset+i, numberOfChars ) );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104454,"modified_method":"@Override\n        public byte[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            byte[] array = numberOfValues > 0 ? new byte[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                array[arrayIndex] = safeCastLongToByte( extractLong( data, offset+charIndex, numberOfChars ) );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public float[] extract( char[] data, int offset, int length )\n        {\n            float[] array = new float[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                // TODO Figure out a way to do this conversion without round tripping to String\n                array[index] = Float.parseFloat( String.valueOf( data, offset+i, length-i ) );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104455,"modified_method":"@Override\n        public float[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            float[] array = numberOfValues > 0 ? new float[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                // TODO Figure out a way to do this conversion without round tripping to String\n                array[arrayIndex] = Float.parseFloat( String.valueOf( data, offset+charIndex, numberOfChars ) );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public int[] extract( char[] data, int offset, int length )\n        {\n            int[] array = new int[numberOfValues( data, offset, length )];\n            for ( int i = 0, index = 0; i < length; i++, index++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+i, length-i );\n                array[index] = safeCastLongToInt( extractLong( data, offset+i, numberOfChars ) );\n                i += numberOfChars;\n            }\n            return array;\n        }","id":104456,"modified_method":"@Override\n        public int[] extract( char[] data, int offset, int length )\n        {\n            int numberOfValues = numberOfValues( data, offset, length );\n            int[] array = numberOfValues > 0 ? new int[numberOfValues] : EMPTY;\n            for ( int arrayIndex = 0, charIndex = 0; arrayIndex < numberOfValues; arrayIndex++, charIndex++ )\n            {\n                int numberOfChars = charsToNextDelimiter( data, offset+charIndex, length-charIndex );\n                array[arrayIndex] = safeCastLongToInt( extractLong( data, offset+charIndex, numberOfChars ) );\n                charIndex += numberOfChars;\n            }\n            return array;\n        }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String toString( long[] longData, char delimiter )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( long value : longData )\n        {\n            builder.append( builder.length() > 0 ? delimiter : \"\" ).append( value );\n        }\n        return builder.toString();\n    }","id":104457,"modified_method":"private String toString( long[] values, char delimiter )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( long value : values )\n        {\n            builder.append( builder.length() > 0 ? delimiter : \"\" ).append( value );\n        }\n        return builder.toString();\n    }","commit_id":"1028274c3d6a9c24c5fc03c4fcab8f9388142e43","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void absolutePaths(String[] paths, int[] lineNumbers) {\n        absolutePaths.addAll(Arrays.asList(paths));\n        for (int lineNumber : lineNumbers) {\n            absolutePathLineNumbers.add(lineNumber);\n        }\n    }","id":104458,"modified_method":"public void ownPaths(String[] paths, int[] lineNumbers) {\n        ownPaths.addAll(Arrays.asList(paths));\n        for (int lineNumber : lineNumbers) {\n            ownLineNumbers.add(lineNumber);\n        }\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"public List<Integer> getAbsolutePathLineNumbers() {\n        return absolutePathLineNumbers;\n    }","id":104459,"modified_method":"public List<Integer> getAllPathLineNumbers() {\n        List<Integer> result = new ArrayList<Integer>(ownLineNumbers.size() + nestedLineNumbers.size());\n        result.addAll(ownLineNumbers);\n        result.addAll(nestedLineNumbers);\n        return result;\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean isEmpty() {\n        return relativePaths.isEmpty() && absolutePaths.isEmpty();\n    }","id":104460,"modified_method":"public boolean isEmpty() {\n        return ownPaths.isEmpty() && nestedPaths.isEmpty();\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> getAbsolutePaths() {\n        return Lists.newArrayList(absolutePaths);\n    }","id":104461,"modified_method":"public List<String> getAllPaths() {\n        List<String> result = new ArrayList<String>(ownPaths.size() + nestedPaths.size());\n        result.addAll(ownPaths);\n        result.addAll(nestedPaths);\n        return result;\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"public PotentialInputs(List<ModelView<?>> modelViews, Iterable<PotentialInput> inputs) {\n        this.modelViews = modelViews;\n        this.inputs = Maps.uniqueIndex(inputs, new Function<PotentialInput, String>() {\n            @Override\n            public String apply(PotentialInput input) {\n                return input.getConsumerPath();\n            }\n        });\n    }","id":104462,"modified_method":"public PotentialInputs(List<ModelView<?>> modelViews, Map<String, PotentialInput> inputs) {\n        this.modelViews = modelViews;\n        this.inputs = inputs;\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitPropertyExpression(PropertyExpression expr) {\n        String modelPath = isDollarPathExpression(expr);\n        if (modelPath != null) {\n            inputs.absolutePath(modelPath, expr.getLineNumber());\n            replaceVisitedExpressionWith(inputReferenceExpression(modelPath));\n        } else {\n            super.visitPropertyExpression(expr);\n        }\n    }","id":104463,"modified_method":"@Override\n    public void visitPropertyExpression(PropertyExpression expr) {\n        String modelPath = isDollarPathExpression(expr);\n        if (modelPath != null) {\n            inputs.reference(modelPath, expr.getLineNumber());\n            replaceVisitedExpressionWith(inputReferenceExpression(modelPath));\n        } else {\n            super.visitPropertyExpression(expr);\n        }\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"private void visitInputMethod(MethodCallExpression call) {\n        ConstantExpression argExpression = AstUtils.hasSingleConstantStringArg(call);\n        if (argExpression == null) { // not a valid signature\n            error(call, INVALID_ARGUMENT_LIST);\n        } else {\n            String modelPath = argExpression.getText();\n            if (modelPath.isEmpty()) {\n                error(argExpression, INVALID_ARGUMENT_LIST);\n                return;\n            }\n\n            try {\n                ModelPath.validatePath(modelPath);\n            } catch (ModelPath.InvalidPathException e) {\n                // TODO find a better way to present this information in the error message\n                // Attempt to mimic Gradle nested exception output\n                String message = \"Invalid model path given as rule input.\" + SystemProperties.getInstance().getLineSeparator()\n                        + \"  > \" + e.getMessage();\n                if (e.getCause() != null) {\n                    // if there is a cause, it's an invalid name exception\n                    message += SystemProperties.getInstance().getLineSeparator() + \"    > \" + e.getCause().getMessage();\n                }\n                error(argExpression, message);\n                return;\n            }\n\n            inputs.absolutePath(modelPath, call.getLineNumber());\n            replaceVisitedExpressionWith(inputReferenceExpression(modelPath));\n        }\n    }","id":104464,"modified_method":"private void visitInputMethod(MethodCallExpression call) {\n        ConstantExpression argExpression = AstUtils.hasSingleConstantStringArg(call);\n        if (argExpression == null) { // not a valid signature\n            error(call, INVALID_ARGUMENT_LIST);\n        } else {\n            String modelPath = argExpression.getText();\n            if (modelPath.isEmpty()) {\n                error(argExpression, INVALID_ARGUMENT_LIST);\n                return;\n            }\n\n            try {\n                ModelPath.validatePath(modelPath);\n            } catch (ModelPath.InvalidPathException e) {\n                // TODO find a better way to present this information in the error message\n                // Attempt to mimic Gradle nested exception output\n                String message = \"Invalid model path given as rule input.\" + SystemProperties.getInstance().getLineSeparator()\n                        + \"  > \" + e.getMessage();\n                if (e.getCause() != null) {\n                    // if there is a cause, it's an invalid name exception\n                    message += SystemProperties.getInstance().getLineSeparator() + \"    > \" + e.getCause().getMessage();\n                }\n                error(argExpression, message);\n                return;\n            }\n\n            inputs.reference(modelPath, call.getLineNumber());\n            replaceVisitedExpressionWith(inputReferenceExpression(modelPath));\n        }\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"public static void visitGeneratedClosure(ClassNode node) {\n        MethodNode method = AstUtils.getGeneratedClosureImplMethod(node);\n        Statement closureCode = method.getCode();\n        SourceLocation sourceLocation = closureCode.getNodeMetaData(AST_NODE_METADATA_LOCATION_KEY);\n        if (sourceLocation != null) {\n            AnnotationNode metadataAnnotation = new AnnotationNode(RULE_METADATA);\n\n            metadataAnnotation.addMember(\"absoluteScriptSourceLocation\", new ConstantExpression(sourceLocation.getUri().toString()));\n            metadataAnnotation.addMember(\"lineNumber\", new ConstantExpression(sourceLocation.getLineNumber()));\n            metadataAnnotation.addMember(\"columnNumber\", new ConstantExpression(sourceLocation.getColumnNumber()));\n\n            InputReferences inputs = closureCode.getNodeMetaData(AST_NODE_METADATA_INPUTS_KEY);\n            if (!inputs.isEmpty()) {\n                metadataAnnotation.addMember(\"absoluteInputPaths\", new ListExpression(constants(inputs.getAbsolutePaths())));\n                metadataAnnotation.addMember(\"absoluteInputLineNumbers\", new ListExpression(constants(inputs.getAbsolutePathLineNumbers())));\n            }\n\n            node.addAnnotation(metadataAnnotation);\n\n            node.addInterface(TRANSFORMED_CLOSURE);\n            node.addField(new FieldNode(INPUTS_FIELD_NAME, Modifier.PUBLIC, POTENTIAL_INPUTS, node, null));\n            List<Statement> statements = new ArrayList<Statement>();\n            statements.add(new ExpressionStatement(new BinaryExpression(new VariableExpression(INPUTS_FIELD_NAME), ASSIGN, new VariableExpression(\"inputs\"))));\n            node.addMethod(new MethodNode(\"applyRuleInputs\", Modifier.PUBLIC, ClassHelper.VOID_TYPE,\n                    new Parameter[]{new Parameter(POTENTIAL_INPUTS, \"inputs\")},\n                    new ClassNode[0],\n                    new BlockStatement(statements, new VariableScope())));\n        }\n    }","id":104465,"modified_method":"public static void visitGeneratedClosure(ClassNode node) {\n        MethodNode method = AstUtils.getGeneratedClosureImplMethod(node);\n        Statement closureCode = method.getCode();\n        SourceLocation sourceLocation = closureCode.getNodeMetaData(AST_NODE_METADATA_LOCATION_KEY);\n        if (sourceLocation != null) {\n            AnnotationNode metadataAnnotation = new AnnotationNode(RULE_METADATA);\n\n            metadataAnnotation.addMember(\"absoluteScriptSourceLocation\", new ConstantExpression(sourceLocation.getUri().toString()));\n            metadataAnnotation.addMember(\"lineNumber\", new ConstantExpression(sourceLocation.getLineNumber()));\n            metadataAnnotation.addMember(\"columnNumber\", new ConstantExpression(sourceLocation.getColumnNumber()));\n\n            InputReferences inputs = closureCode.getNodeMetaData(AST_NODE_METADATA_INPUTS_KEY);\n            if (!inputs.isEmpty()) {\n                metadataAnnotation.addMember(\"ownInputPaths\", new ListExpression(constants(inputs.getOwnPaths())));\n                metadataAnnotation.addMember(\"ownInputLineNumbers\", new ListExpression(constants(inputs.getOwnPathLineNumbers())));\n                metadataAnnotation.addMember(\"nestedInputPaths\", new ListExpression(constants(inputs.getNestedPaths())));\n                metadataAnnotation.addMember(\"nestedInputLineNumbers\", new ListExpression(constants(inputs.getNestedPathLineNumbers())));\n            }\n\n            node.addAnnotation(metadataAnnotation);\n\n            node.addInterface(TRANSFORMED_CLOSURE);\n            node.addField(new FieldNode(INPUTS_FIELD_NAME, Modifier.PUBLIC, POTENTIAL_INPUTS, node, null));\n            List<Statement> statements = new ArrayList<Statement>();\n            statements.add(new ExpressionStatement(new BinaryExpression(new VariableExpression(INPUTS_FIELD_NAME), ASSIGN, new VariableExpression(\"inputs\"))));\n            node.addMethod(new MethodNode(\"applyRuleInputs\", Modifier.PUBLIC, ClassHelper.VOID_TYPE,\n                    new Parameter[]{new Parameter(POTENTIAL_INPUTS, \"inputs\")},\n                    new ClassNode[0],\n                    new BlockStatement(statements, new VariableScope())));\n        }\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"public void visitRuleClosure(ClosureExpression expression, SourceLocation sourceLocation) {\n        InputReferences parentInputs = inputs;\n        VariableExpression parentInputsVariable = inputsVariable;\n        try {\n            if (inputs == null) {\n                inputs = new InputReferences();\n            }\n            inputsVariable = new VariableExpression(\"__rule_inputs_var_\" + (counter++), POTENTIAL_INPUTS);\n            inputsVariable.setClosureSharedVariable(true);\n            super.visitClosureExpression(expression);\n            BlockStatement code = (BlockStatement) expression.getCode();\n            code.setNodeMetaData(AST_NODE_METADATA_LOCATION_KEY, sourceLocation);\n            code.setNodeMetaData(AST_NODE_METADATA_INPUTS_KEY, inputs);\n            if (parentInputsVariable != null) {\n                expression.getVariableScope().putReferencedLocalVariable(parentInputsVariable);\n            }\n            code.getVariableScope().putDeclaredVariable(inputsVariable);\n\n            if (parentInputsVariable == null) {\n                // <inputs-lvar> = <inputs-field>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN, new VariableExpression(INPUTS_FIELD_NAME));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n\n            } else {\n                // <inputs-lvar> = <inputs-field> ?: <parent-inputs-lvar>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN,\n                        new ElvisOperatorExpression(\n                                new VariableExpression(INPUTS_FIELD_NAME),\n                                parentInputsVariable));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n            }\n\n            // Move default values into body of closure, so they can use <inputs-lvar>\n            for (Parameter parameter : expression.getParameters()) {\n                if (parameter.hasInitialExpression()) {\n                    code.getStatements().add(1, new ExpressionStatement(new BinaryExpression(new VariableExpression(parameter.getName()), ASSIGN, parameter.getInitialExpression())));\n                    parameter.setInitialExpression(ConstantExpression.NULL);\n                }\n            }\n        } finally {\n            inputs = parentInputs;\n            inputsVariable = parentInputsVariable;\n        }\n    }","id":104466,"modified_method":"public void visitRuleClosure(ClosureExpression expression, SourceLocation sourceLocation) {\n        InputReferences parentInputs = inputs;\n        VariableExpression parentInputsVariable = inputsVariable;\n        try {\n            inputs = new InputReferences();\n            inputsVariable = new VariableExpression(\"__rule_inputs_var_\" + (counter++), POTENTIAL_INPUTS);\n            inputsVariable.setClosureSharedVariable(true);\n            super.visitClosureExpression(expression);\n            BlockStatement code = (BlockStatement) expression.getCode();\n            code.setNodeMetaData(AST_NODE_METADATA_LOCATION_KEY, sourceLocation);\n            code.setNodeMetaData(AST_NODE_METADATA_INPUTS_KEY, inputs);\n            if (parentInputsVariable != null) {\n                expression.getVariableScope().putReferencedLocalVariable(parentInputsVariable);\n            }\n            code.getVariableScope().putDeclaredVariable(inputsVariable);\n\n            if (parentInputsVariable == null) {\n                // <inputs-lvar> = <inputs-field>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN, new VariableExpression(INPUTS_FIELD_NAME));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n\n            } else {\n                // <inputs-lvar> = <inputs-field> ?: <parent-inputs-lvar>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN,\n                        new ElvisOperatorExpression(\n                                new VariableExpression(INPUTS_FIELD_NAME),\n                                parentInputsVariable));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n            }\n\n            // Move default values into body of closure, so they can use <inputs-lvar>\n            for (Parameter parameter : expression.getParameters()) {\n                if (parameter.hasInitialExpression()) {\n                    code.getStatements().add(1, new ExpressionStatement(new BinaryExpression(new VariableExpression(parameter.getName()), ASSIGN, parameter.getInitialExpression())));\n                    parameter.setInitialExpression(ConstantExpression.NULL);\n                }\n            }\n        } finally {\n            if (parentInputs != null) {\n                parentInputs.addNestedReferences(inputs);\n            }\n            inputs = parentInputs;\n            inputsVariable = parentInputsVariable;\n        }\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> void registerAction(final ModelPath modelPath, final Class<T> viewType, final ModelRuleDescriptor descriptor, final ModelActionRole role, final Closure<?> closure) {\n        final ModelReference<T> reference = ModelReference.of(modelPath, viewType);\n        modelRegistry.configure(ModelActionRole.Initialize, DirectNodeNoInputsModelAction.of(reference, descriptor, new Action<MutableModelNode>() {\n            @Override\n            public void execute(MutableModelNode mutableModelNode) {\n                InputReferences inputs = inputPathsExtractor.transform(closure);\n                List<String> absolutePaths = inputs.getAbsolutePaths();\n                List<Integer> absolutePathLineNumbers = inputs.getAbsolutePathLineNumbers();\n                final List<PotentialInput> potentialInputs = Lists.newArrayListWithCapacity(absolutePaths.size());\n                List<ModelReference<?>> actualInputs = Lists.newArrayListWithCapacity(potentialInputs.size());\n\n                for (int i = 0; i < absolutePaths.size(); i++) {\n                    String description = String.format(\"@ line %d\", absolutePathLineNumbers.get(i));\n                    String path = absolutePaths.get(i);\n                    potentialInputs.add(PotentialInput.absoluteInput(path, actualInputs.size()));\n                    actualInputs.add(ModelReference.untyped(ModelPath.path(path), description));\n                }\n                mutableModelNode.applyToSelf(role, InputUsingModelAction.of(reference, descriptor, actualInputs, new BiAction<T, List<ModelView<?>>>() {\n                    @Override\n                    public void execute(final T t, List<ModelView<?>> modelViews) {\n                        ((TransformedClosure) closure).applyRuleInputs(new PotentialInputs(modelViews, potentialInputs));\n                        ClosureBackedAction.execute(t, closure.rehydrate(null, closure.getThisObject(), closure.getThisObject()));\n                    }\n                }));\n            }\n        }));\n    }","id":104467,"modified_method":"private <T> void registerAction(final ModelPath modelPath, final Class<T> viewType, final ModelRuleDescriptor descriptor, final ModelActionRole role, final Closure<?> closure) {\n        final ModelReference<T> reference = ModelReference.of(modelPath, viewType);\n        modelRegistry.configure(ModelActionRole.Initialize, DirectNodeNoInputsModelAction.of(reference, descriptor, new Action<MutableModelNode>() {\n            @Override\n            public void execute(MutableModelNode mutableModelNode) {\n                InputReferences inputs = inputPathsExtractor.transform(closure);\n                List<String> absolutePaths = inputs.getAllPaths();\n                List<Integer> absolutePathLineNumbers = inputs.getAllPathLineNumbers();\n                final Map<String, PotentialInput> inputValues = Maps.newLinkedHashMap();\n                List<ModelReference<?>> inputReferences = Lists.newArrayList();\n\n                for (int i = 0; i < absolutePaths.size(); i++) {\n                    String description = String.format(\"@ line %d\", absolutePathLineNumbers.get(i));\n                    String path = absolutePaths.get(i);\n                    if (!inputValues.containsKey(path)) {\n                        inputValues.put(path, PotentialInput.absoluteInput(path, inputReferences.size()));\n                        inputReferences.add(ModelReference.untyped(ModelPath.path(path), description));\n                    }\n                }\n\n                mutableModelNode.applyToSelf(role, InputUsingModelAction.of(reference, descriptor, inputReferences, new BiAction<T, List<ModelView<?>>>() {\n                    @Override\n                    public void execute(final T t, List<ModelView<?>> modelViews) {\n                        ((TransformedClosure) closure).applyRuleInputs(new PotentialInputs(modelViews, inputValues));\n                        ClosureBackedAction.execute(t, closure.rehydrate(null, closure.getThisObject(), closure.getThisObject()));\n                    }\n                }));\n            }\n        }));\n    }","commit_id":"80154c66bb3bbfd2744fefaebaf35eedd388e731","url":"https://github.com/gradle/gradle"},{"original_method":"private void visitInputMethod(MethodCallExpression call) {\n        ConstantExpression argExpression = AstUtils.hasSingleConstantStringArg(call);\n        if (argExpression == null) { // not a valid signature\n            error(call, INVALID_ARGUMENT_LIST);\n        } else {\n            String modelPath = argExpression.getText();\n            if (modelPath.isEmpty()) {\n                error(argExpression, INVALID_ARGUMENT_LIST);\n                return;\n            }\n\n            try {\n                ModelPath.validatePath(modelPath);\n            } catch (ModelPath.InvalidPathException e) {\n                // TODO find a better way to present this information in the error message\n                // Attempt to mimic Gradle nested exception output\n                String message = \"Invalid model path given as rule input.\" + SystemProperties.getInstance().getLineSeparator()\n                    + \"  > \" + e.getMessage();\n                if (e.getCause() != null) {\n                    // if there is a cause, it's an invalid name exception\n                    message += SystemProperties.getInstance().getLineSeparator() + \"    > \" + e.getCause().getMessage();\n                }\n                error(argExpression, message);\n                return;\n            }\n\n            inputs.put(modelPath, call.getLineNumber());\n            call.setObjectExpression(new VariableExpression(accessVariable));\n            call.setMethod(new ConstantExpression(INPUT));\n        }\n    }","id":104468,"modified_method":"private void visitInputMethod(MethodCallExpression call) {\n        ConstantExpression argExpression = AstUtils.hasSingleConstantStringArg(call);\n        if (argExpression == null) { // not a valid signature\n            error(call, INVALID_ARGUMENT_LIST);\n        } else {\n            String modelPath = argExpression.getText();\n            if (modelPath.isEmpty()) {\n                error(argExpression, INVALID_ARGUMENT_LIST);\n                return;\n            }\n\n            try {\n                ModelPath.validatePath(modelPath);\n            } catch (ModelPath.InvalidPathException e) {\n                // TODO find a better way to present this information in the error message\n                // Attempt to mimic Gradle nested exception output\n                String message = \"Invalid model path given as rule input.\" + SystemProperties.getInstance().getLineSeparator()\n                    + \"  > \" + e.getMessage();\n                if (e.getCause() != null) {\n                    // if there is a cause, it's an invalid name exception\n                    message += SystemProperties.getInstance().getLineSeparator() + \"    > \" + e.getCause().getMessage();\n                }\n                error(argExpression, message);\n                return;\n            }\n\n            inputs.absolutePath(modelPath, call.getLineNumber());\n            call.setObjectExpression(new VariableExpression(accessVariable));\n            call.setMethod(new ConstantExpression(INPUT));\n        }\n    }","commit_id":"79b58e3f9786b73e8c9854464c535bcccaba6a06","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitClosureExpression(ClosureExpression expression) {\n        if (inputs == null) {\n            inputs = ImmutableListMultimap.builder();\n            try {\n                accessVariable = new VariableExpression(ACCESS_HOLDER_FIELD, ACCESS_API_TYPE);\n\n                super.visitClosureExpression(expression);\n\n                BlockStatement code = (BlockStatement) expression.getCode();\n                code.setNodeMetaData(AST_NODE_METADATA_INPUTS_KEY, inputs.build());\n                accessVariable.setClosureSharedVariable(true);\n                StaticMethodCallExpression getAccessCall = new StaticMethodCallExpression(CONTEXTUAL_INPUT_TYPE, GET_ACCESS, ArgumentListExpression.EMPTY_ARGUMENTS);\n                DeclarationExpression variableDeclaration = new DeclarationExpression(accessVariable, new Token(Types.ASSIGN, \"=\", -1, -1), getAccessCall);\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n                code.getVariableScope().putDeclaredVariable(accessVariable);\n            } finally {\n                inputs = null;\n            }\n        } else {\n            expression.getVariableScope().putReferencedLocalVariable(accessVariable);\n            super.visitClosureExpression(expression);\n        }\n    }","id":104469,"modified_method":"@Override\n    public void visitClosureExpression(ClosureExpression expression) {\n        if (inputs == null) {\n            inputs = new InputReferences();\n            try {\n                accessVariable = new VariableExpression(ACCESS_HOLDER_FIELD, ACCESS_API_TYPE);\n\n                super.visitClosureExpression(expression);\n\n                BlockStatement code = (BlockStatement) expression.getCode();\n                code.setNodeMetaData(AST_NODE_METADATA_INPUTS_KEY, inputs);\n                accessVariable.setClosureSharedVariable(true);\n                StaticMethodCallExpression getAccessCall = new StaticMethodCallExpression(CONTEXTUAL_INPUT_TYPE, GET_ACCESS, ArgumentListExpression.EMPTY_ARGUMENTS);\n                DeclarationExpression variableDeclaration = new DeclarationExpression(accessVariable, new Token(Types.ASSIGN, \"=\", -1, -1), getAccessCall);\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n                code.getVariableScope().putDeclaredVariable(accessVariable);\n            } finally {\n                inputs = null;\n            }\n        } else {\n            expression.getVariableScope().putReferencedLocalVariable(accessVariable);\n            super.visitClosureExpression(expression);\n        }\n    }","commit_id":"79b58e3f9786b73e8c9854464c535bcccaba6a06","url":"https://github.com/gradle/gradle"},{"original_method":"public static void visitGeneratedClosure(ClassNode node) {\n        MethodNode method = AstUtils.getGeneratedClosureImplMethod(node);\n        Statement closureCode = method.getCode();\n        SourceLocation sourceLocation = closureCode.getNodeMetaData(AST_NODE_METADATA_LOCATION_KEY);\n        if (sourceLocation != null) {\n            AnnotationNode metadataAnnotation = new AnnotationNode(ANNOTATION_CLASS_NODE);\n\n            metadataAnnotation.addMember(\"scriptSourceDescription\", new ConstantExpression(sourceLocation.getScriptSourceDescription()));\n            metadataAnnotation.addMember(\"lineNumber\", new ConstantExpression(sourceLocation.getLineNumber()));\n            metadataAnnotation.addMember(\"columnNumber\", new ConstantExpression(sourceLocation.getColumnNumber()));\n\n            ListMultimap<String, Integer> inputs = closureCode.getNodeMetaData(AST_NODE_METADATA_INPUTS_KEY);\n            if (!inputs.isEmpty()) {\n                List<Expression> pathValues = Lists.newArrayListWithCapacity(inputs.size());\n                List<Expression> lineNumberValues = Lists.newArrayListWithCapacity(inputs.size());\n                for (Map.Entry<String, List<Integer>> input : Multimaps.asMap(inputs).entrySet()) {\n                    pathValues.add(new ConstantExpression(input.getKey()));\n                    lineNumberValues.add(new ConstantExpression(input.getValue().get(0)));\n                }\n\n                metadataAnnotation.addMember(\"inputPaths\", new ListExpression(pathValues));\n                metadataAnnotation.addMember(\"inputLineNumbers\", new ListExpression(lineNumberValues));\n            }\n\n            node.addAnnotation(metadataAnnotation);\n        }\n    }","id":104470,"modified_method":"public static void visitGeneratedClosure(ClassNode node) {\n        MethodNode method = AstUtils.getGeneratedClosureImplMethod(node);\n        Statement closureCode = method.getCode();\n        SourceLocation sourceLocation = closureCode.getNodeMetaData(AST_NODE_METADATA_LOCATION_KEY);\n        if (sourceLocation != null) {\n            AnnotationNode metadataAnnotation = new AnnotationNode(ANNOTATION_CLASS_NODE);\n\n            metadataAnnotation.addMember(\"scriptSourceDescription\", new ConstantExpression(sourceLocation.getScriptSourceDescription()));\n            metadataAnnotation.addMember(\"lineNumber\", new ConstantExpression(sourceLocation.getLineNumber()));\n            metadataAnnotation.addMember(\"columnNumber\", new ConstantExpression(sourceLocation.getColumnNumber()));\n\n            InputReferences inputs = closureCode.getNodeMetaData(AST_NODE_METADATA_INPUTS_KEY);\n            if (!inputs.isEmpty()) {\n                metadataAnnotation.addMember(\"absoluteInputPaths\", new ListExpression(constants(inputs.absolutePaths)));\n                metadataAnnotation.addMember(\"absoluteInputLineNumbers\", new ListExpression(constants(inputs.absolutePathLineNumbers)));\n                metadataAnnotation.addMember(\"relativeInputPaths\", new ListExpression(constants(inputs.relativePaths)));\n                metadataAnnotation.addMember(\"relativeInputLineNumbers\", new ListExpression(constants(inputs.relativePathLineNumbers)));\n            }\n\n            node.addAnnotation(metadataAnnotation);\n        }\n    }","commit_id":"79b58e3f9786b73e8c9854464c535bcccaba6a06","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitPropertyExpression(PropertyExpression expression) {\n        ArrayList<String> names = Lists.newArrayList();\n        boolean propertyIsLiteral = extractPropertyPath(expression, names);\n        if (names.isEmpty() || !names.get(0).equals(\"thing\")) {\n            super.visitPropertyExpression(expression);\n        } else {\n            String modelPath = ModelPath.pathString(names);\n            ConstantExpression modelPathConstantExpression = new ConstantExpression(modelPath);\n            inputs.put(modelPath, expression.getLineNumber());\n            VariableExpression inputsVariable = new VariableExpression(accessVariable);\n            Expression originalObjectExpression = expression.getObjectExpression();\n            ArgumentListExpression modelPathArgumentExpression = new ArgumentListExpression(modelPathConstantExpression);\n            expression.setObjectExpression(new TernaryExpression(\n                new BooleanExpression(new MethodCallExpression(inputsVariable, HAS, modelPathArgumentExpression)),\n                new MethodCallExpression(inputsVariable, propertyIsLiteral ? PROPERTY : INPUT, modelPathArgumentExpression),\n                originalObjectExpression\n            ));\n        }\n    }","id":104471,"modified_method":"@Override\n    public void visitPropertyExpression(PropertyExpression expression) {\n        ArrayList<String> names = Lists.newArrayList();\n        boolean propertyIsLiteral = extractPropertyPath(expression, names);\n        if (names.isEmpty() || !names.get(0).equals(\"thing\")) {\n            super.visitPropertyExpression(expression);\n        } else {\n            String modelPath = ModelPath.pathString(names);\n            ConstantExpression modelPathConstantExpression = new ConstantExpression(modelPath);\n            inputs.relativePath(modelPath, expression.getLineNumber());\n            VariableExpression inputsVariable = new VariableExpression(accessVariable);\n            Expression originalObjectExpression = expression.getObjectExpression();\n            ArgumentListExpression modelPathArgumentExpression = new ArgumentListExpression(modelPathConstantExpression);\n            expression.setObjectExpression(new TernaryExpression(\n                new BooleanExpression(new MethodCallExpression(inputsVariable, HAS, modelPathArgumentExpression)),\n                new MethodCallExpression(inputsVariable, propertyIsLiteral ? PROPERTY : INPUT, modelPathArgumentExpression),\n                originalObjectExpression\n            ));\n        }\n    }","commit_id":"79b58e3f9786b73e8c9854464c535bcccaba6a06","url":"https://github.com/gradle/gradle"},{"original_method":"public void run()\n        {\n            try {\n                RequestContext.setEvent(event);\n                doDispatch(event);\n                if(connector.isEnableMessageEvents()) {\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), event.getComponent().getDescriptor().getName(), MessageNotification.MESSAGE_DISPATCHED));\n                }\n            } catch (Exception e) {\n                getConnector().handleException(e);\n            }\n        }","id":104472,"modified_method":"public void run()\n        {\n            try {\n                RequestContext.setEvent(event);\n                doDispatch(event);\n                if(connector.isEnableMessageEvents()) {\n                    String component = null;\n                    if(event.getComponent()!=null) {\n                        component = event.getComponent().getDescriptor().getName();\n                    }\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                }\n            } catch (Exception e) {\n                getConnector().handleException(e);\n            }\n        }","commit_id":"9471c05c63a59636fabbe1bbbaa147b6cd7f5055","url":"https://github.com/mulesoft/mule"},{"original_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), event.getComponent().getDescriptor().getName(), MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":104473,"modified_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"9471c05c63a59636fabbe1bbbaa147b6cd7f5055","url":"https://github.com/mulesoft/mule"},{"original_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), event.getComponent().getDescriptor().getName(), MessageNotification.MESSAGE_SENT));\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":104474,"modified_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    try {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_SENT));\n                    } catch (NullPointerException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"9471c05c63a59636fabbe1bbbaa147b6cd7f5055","url":"https://github.com/mulesoft/mule"},{"original_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), event.getComponent().getDescriptor().getName(), MessageNotification.MESSAGE_SENT));\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":104475,"modified_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    try {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_SENT));\n                    } catch (NullPointerException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"99aef11ff4245b45a7b44521c60b0aed59165304","url":"https://github.com/mulesoft/mule"},{"original_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), event.getComponent().getDescriptor().getName(), MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":104476,"modified_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"99aef11ff4245b45a7b44521c60b0aed59165304","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run()\n        {\n            try {\n                RequestContext.setEvent(event);\n                doDispatch(event);\n                if(connector.isEnableMessageEvents()) {\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), event.getComponent().getDescriptor().getName(), MessageNotification.MESSAGE_DISPATCHED));\n                }\n            } catch (Exception e) {\n                getConnector().handleException(e);\n            }\n        }","id":104477,"modified_method":"public void run()\n        {\n            try {\n                RequestContext.setEvent(event);\n                doDispatch(event);\n                if(connector.isEnableMessageEvents()) {\n                    String component = null;\n                    if(event.getComponent()!=null) {\n                        component = event.getComponent().getDescriptor().getName();\n                    }\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                }\n            } catch (Exception e) {\n                getConnector().handleException(e);\n            }\n        }","commit_id":"99aef11ff4245b45a7b44521c60b0aed59165304","url":"https://github.com/mulesoft/mule"},{"original_method":"@NotNull\n  public List<SNode> getNodes(Condition<SNode> condition) {\n    if (this.myLocalVariables == null) {\n      this.myLocalVariables = new ArrayList<SNode>();\n      ILocalVariableElementList statementList = LocalVariablesScope.findThisOrParent(this.myContextNode, ILocalVariableElementList.class);\n      if (statementList != null) {\n        ILocalVariableElement currentStatement = LocalVariablesScope.findThisOrParent(this.myContextNode, ILocalVariableElement.class);\n        this._populateLocalVariables(statementList, currentStatement, this.myLocalVariables);\n      }\n      AbstractLoopStatement loopStatement = LocalVariablesScope.findThisOrParent(this.myContextNode, AbstractLoopStatement.class);\n      if (loopStatement != null) {\n        this._populateLocalVariables(loopStatement, this.myLocalVariables);\n      }\n      CatchClause catchClause = LocalVariablesScope.findThisOrParent(this.myContextNode, CatchClause.class);\n      if (catchClause != null) {\n        this._populateLocalVariables(catchClause, this.myLocalVariables);\n      }\n    }\n    if (condition == AbstractSearchScope.TRUE_CONDITION) {\n      return this.myLocalVariables;\n    }\n    List<SNode> result = new ArrayList<SNode>(this.myLocalVariables.size());\n    for (SNode node : this.myLocalVariables) {\n      if (condition.met(node)) {\n        result.add(node);\n      }\n    }\n    return result;\n  }","id":104478,"modified_method":"@NotNull\n  public List<SNode> getNodes(Condition<SNode> condition) {\n    if (this.myLocalVariables == null) {\n      this.myLocalVariables = new ArrayList<SNode>();\n      SNode statementList = SNodeOperations.as(LocalVariablesScope.findThisOrParent(this.myContextNode, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ILocalVariableElementList\")), \"jetbrains.mps.baseLanguage.structure.ILocalVariableElementList\");\n      if (statementList != null) {\n        SNode currentStatement = SNodeOperations.as(LocalVariablesScope.findThisOrParent(this.myContextNode, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ILocalVariableElement\")), \"jetbrains.mps.baseLanguage.structure.ILocalVariableElement\");\n        this._populateLocalVariables(statementList, currentStatement, this.myLocalVariables);\n      }\n      SNode loopStatement = SNodeOperations.as(LocalVariablesScope.findThisOrParent(this.myContextNode, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\")), \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\");\n      if (loopStatement != null) {\n        this._populateLocalVariables(loopStatement, this.myLocalVariables);\n      }\n      SNode catchClause = SNodeOperations.as(LocalVariablesScope.findThisOrParent(this.myContextNode, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.CatchClause\")), \"jetbrains.mps.baseLanguage.structure.CatchClause\");\n      if (catchClause != null) {\n        this._populateLocalVariablesForCatch(catchClause, this.myLocalVariables);\n      }\n    }\n    if (condition == AbstractSearchScope.TRUE_CONDITION) {\n      return this.myLocalVariables;\n    }\n    List<SNode> result = new ArrayList<SNode>(this.myLocalVariables.size());\n    for (SNode node : this.myLocalVariables) {\n      if (condition.met(node)) {\n        result.add(node);\n      }\n    }\n    return result;\n  }","commit_id":"e8f8de710aacf53ec61d6b8932a872e3a116d137","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void _populateLocalVariables(CatchClause tryCatchStatement, List<SNode> result) {\n    if (tryCatchStatement.getThrowable() != null) {\n      LocalVariableDeclaration throwable = tryCatchStatement.getThrowable();\n      result.add(throwable.getNode());\n    }\n    CatchClause containingCatchClause = LocalVariablesScope.findThisOrParent(tryCatchStatement.getParent(), CatchClause.class);\n    if (containingCatchClause != null) {\n      this._populateLocalVariables(containingCatchClause, result);\n    }\n  }","id":104479,"modified_method":"private void _populateLocalVariables(SNode loopStatement, List<SNode> result) {\n    for (SNode child : SNodeOperations.getChildren(loopStatement)) {\n      if (child.getRole_().equals(AbstractLoopStatement.BODY)) {\n        continue;\n      }\n      if (SNodeOperations.isInstanceOf(child, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\")) {\n        result.add(child);\n      }\n      List<SNode> moreChildren = SNodeOperations.getDescendants(child, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\", false, new String[]{});\n      for (SNode child_ : moreChildren) {\n        result.add(child_);\n      }\n    }\n    SNode containingLoop = SNodeOperations.as(LocalVariablesScope.findThisOrParent(SNodeOperations.getParent(loopStatement), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\")), \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\");\n    if (containingLoop != null) {\n      this._populateLocalVariables(containingLoop, result);\n    }\n  }","commit_id":"e8f8de710aacf53ec61d6b8932a872e3a116d137","url":"https://github.com/JetBrains/MPS"},{"original_method":"public LocalVariablesScope(SNode contextNode) {\n    this.myContextNode = BaseAdapter.fromNode(contextNode);\n  }","id":104480,"modified_method":"public LocalVariablesScope(SNode contextNode) {\n    this.myContextNode = contextNode;\n  }","commit_id":"e8f8de710aacf53ec61d6b8932a872e3a116d137","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static <BA extends INodeAdapter> BA findThisOrParent(INodeAdapter sourceNode, Class<BA> clazz) {\n    INodeAdapter testNode = sourceNode;\n    while (testNode != null) {\n      if (clazz.isAssignableFrom(testNode.getClass())) {\n        return (BA) testNode;\n      }\n      if (ConceptFunction.class.isAssignableFrom(testNode.getClass())) {\n        if (!(Closure.class.isAssignableFrom(testNode.getClass()))) {\n          break;\n        }\n      }\n      testNode = testNode.getParent();\n    }\n    return null;\n  }","id":104481,"modified_method":"private static SNode findThisOrParent(SNode sourceNode, SNode concept) {\n    SNode testNode = sourceNode;\n    while (testNode != null) {\n      if (testNode.isInstanceOfConcept(concept)) {\n        return testNode;\n      }\n      if (SNodeOperations.isInstanceOf(testNode, \"jetbrains.mps.baseLanguage.structure.ConceptFunction\")) {\n        if (!(SNodeOperations.isInstanceOf(testNode, \"jetbrains.mps.baseLanguage.structure.Closure\"))) {\n          break;\n        }\n      }\n      testNode = SNodeOperations.getParent(testNode);\n    }\n    return null;\n  }","commit_id":"e8f8de710aacf53ec61d6b8932a872e3a116d137","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void _populateLocalVariables(ILocalVariableElementList statementList, ILocalVariableElement beforeStatement, List<SNode> result) {\n    if (statementList == null) {\n      return;\n    }\n    if (statementList != beforeStatement) {\n      List<SNode> varElements = ILocalVariableElementList_Behavior.call_getLocalVariableElements_1238805763253(BaseAdapter.fromAdapter(statementList));\n      for (SNode sNode : varElements) {\n        INodeAdapter n = BaseAdapter.fromNode(sNode);\n        if (!((n instanceof ILocalVariableElement))) {\n          continue;\n        }\n        ILocalVariableElement statement = (ILocalVariableElement) n;\n        if (statement == beforeStatement) {\n          break;\n        }\n        SNode declarationNode = ILocalVariableElement_Behavior.call_getLocalVariableDeclaration_1238803857389(BaseAdapter.fromAdapter(statement));\n        if (declarationNode != null) {\n          result.add(declarationNode);\n        }\n      }\n    }\n    ILocalVariableElement containingStatement = LocalVariablesScope.findThisOrParent(statementList, ILocalVariableElement.class);\n    if (containingStatement != null) {\n      statementList = containingStatement.findParent(ILocalVariableElementList.class);\n      this._populateLocalVariables(statementList, containingStatement, result);\n    }\n  }","id":104482,"modified_method":"private void _populateLocalVariables(SNode statementList, SNode beforeStatement, List<SNode> result) {\n    if (statementList == null) {\n      return;\n    }\n    if (statementList != beforeStatement) {\n      List<SNode> varElements = ILocalVariableElementList_Behavior.call_getLocalVariableElements_1238805763253(statementList);\n      for (SNode sNode : varElements) {\n        if (!((SNodeOperations.isInstanceOf(sNode, \"jetbrains.mps.baseLanguage.structure.ILocalVariableElement\")))) {\n          continue;\n        }\n        SNode statement = SNodeOperations.cast(sNode, \"jetbrains.mps.baseLanguage.structure.ILocalVariableElement\");\n        if (statement == beforeStatement) {\n          break;\n        }\n        SNode declNode = ILocalVariableElement_Behavior.call_getLocalVariableDeclaration_1238803857389(statement);\n        if (declNode != null) {\n          result.add(declNode);\n        }\n      }\n    }\n    SNode containingStatement = SNodeOperations.as(LocalVariablesScope.findThisOrParent(statementList, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ILocalVariableElement\")), \"jetbrains.mps.baseLanguage.structure.ILocalVariableElement\");\n    if (containingStatement != null) {\n      statementList = SNodeOperations.getAncestor(containingStatement, \"jetbrains.mps.baseLanguage.structure.ILocalVariableElementList\", false, false);\n      this._populateLocalVariables(statementList, containingStatement, result);\n    }\n  }","commit_id":"e8f8de710aacf53ec61d6b8932a872e3a116d137","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void _populateLocalVariables(AbstractLoopStatement loopStatement, List<SNode> result) {\n    for (INodeAdapter child : loopStatement.getChildren()) {\n      if (child.getRole_().equals(AbstractLoopStatement.BODY)) {\n        continue;\n      }\n      if (child instanceof LocalVariableDeclaration) {\n        result.add(child.getNode());\n      }\n      List<LocalVariableDeclaration> moreChildren = child.getDescendants(LocalVariableDeclaration.class);\n      for (LocalVariableDeclaration child_ : moreChildren) {\n        result.add(child_.getNode());\n      }\n    }\n    AbstractLoopStatement containingLoop = LocalVariablesScope.findThisOrParent(loopStatement.getParent(), AbstractLoopStatement.class);\n    if (containingLoop != null) {\n      this._populateLocalVariables(containingLoop, result);\n    }\n  }","id":104483,"modified_method":"private void _populateLocalVariablesForCatch(SNode tryCatchStatement, List<SNode> result) {\n    SNode throwable = SLinkOperations.getTarget(tryCatchStatement, \"throwable\", true);\n    if (throwable != null) {\n      result.add(throwable);\n    }\n    SNode containingCatchClause = SNodeOperations.as(LocalVariablesScope.findThisOrParent(SNodeOperations.getParent(tryCatchStatement), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.CatchClause\")), \"jetbrains.mps.baseLanguage.structure.CatchClause\");\n    if (containingCatchClause != null) {\n      this._populateLocalVariablesForCatch(containingCatchClause, result);\n    }\n  }","commit_id":"e8f8de710aacf53ec61d6b8932a872e3a116d137","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void viewArtifact(final BlackboardArtifact art) {\n        BlackboardArtifact.ARTIFACT_TYPE type = BlackboardArtifact.ARTIFACT_TYPE.fromID(art.getArtifactTypeID());\n        Children rootChilds = em.getRootContext().getChildren();\n        Node treeNode = null;\n        Node resultsNode = rootChilds.findChild(ResultsNode.NAME);\n        Children resultsChilds = resultsNode.getChildren();\n        if (type.equals(BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT)) {\n            Node hashsetRootNode = resultsChilds.findChild(type.getLabel());\n            Children hashsetRootChilds = hashsetRootNode.getChildren();\n            try {\n                String setName = null;\n                List<BlackboardAttribute> attributes = art.getAttributes();\n                for (BlackboardAttribute att : attributes) {\n                    int typeId = att.getAttributeTypeID();\n                    if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()) {\n                        setName = att.getValueString();\n                    }\n                }\n                treeNode = hashsetRootChilds.findChild(setName);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Error retrieving attributes\", ex); //NON-NLS\n            }\n        } else if (type.equals(BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT)) {\n            Node keywordRootNode = resultsChilds.findChild(type.getLabel());\n            Children keywordRootChilds = keywordRootNode.getChildren();\n            try {\n                String listName = null;\n                String keywordName = null;\n                List<BlackboardAttribute> attributes = art.getAttributes();\n                for (BlackboardAttribute att : attributes) {\n                    int typeId = att.getAttributeTypeID();\n                    if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()) {\n                        listName = att.getValueString();\n                    } else if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD.getTypeID()) {\n                        keywordName = att.getValueString();\n                    }\n                }\n                Node listNode = keywordRootChilds.findChild(listName);\n                if (listNode == null) {\n                    return;\n                }\n                Children listChildren = listNode.getChildren();\n                if (listChildren == null) {\n                    return;\n                }\n                treeNode = listChildren.findChild(keywordName);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Error retrieving attributes\", ex); //NON-NLS\n            }\n        } else if (type.equals(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT)\n                || type.equals(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT)) {\n            Node interestingItemsRootNode = resultsChilds.findChild(type.getLabel());\n            Children interestingItemsRootChildren = interestingItemsRootNode.getChildren();\n            try {\n                String setName = null;\n                List<BlackboardAttribute> attributes = art.getAttributes();\n                for (BlackboardAttribute att : attributes) {\n                    int typeId = att.getAttributeTypeID();\n                    if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()) {\n                        setName = att.getValueString();\n                    }\n                }\n                treeNode = interestingItemsRootChildren.findChild(setName);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Error retrieving attributes\", ex); //NON-NLS\n            }\n        } else {\n            Node extractedContent = resultsChilds.findChild(ExtractedContent.NAME);\n            Children extractedChilds = extractedContent.getChildren();\n            if (extractedChilds == null) {\n                return;\n            }\n            treeNode = extractedChilds.findChild(type.getLabel());\n        }\n\n        if (treeNode == null) {\n            return;\n        }\n\n        try {\n            em.setExploredContextAndSelection(treeNode, new Node[]{treeNode});\n        } catch (PropertyVetoException ex) {\n            logger.log(Level.WARNING, \"Property Veto: \", ex); //NON-NLS\n        }\n\n        // Another thread is needed because we have to wait for dataResult to populate\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                Children resultChilds = dataResult.getRootNode().getChildren();\n                Node select = resultChilds.findChild(Long.toString(art.getArtifactID()));\n                if (select != null) {\n                    dataResult.requestActive();\n                    dataResult.setSelectedNodes(new Node[]{select});\n                    fireViewerComplete();\n                }\n            }\n        });\n    }","id":104484,"modified_method":"@Override\n    public void viewArtifact(final BlackboardArtifact art) {\n        int typeID = art.getArtifactTypeID();\n        String typeName = art.getArtifactTypeName();\n        Children rootChilds = em.getRootContext().getChildren();\n        Node treeNode = null;\n        Node resultsNode = rootChilds.findChild(ResultsNode.NAME);\n        Children resultsChilds = resultsNode.getChildren();\n        if (typeID == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n            Node hashsetRootNode = resultsChilds.findChild(typeName);\n            Children hashsetRootChilds = hashsetRootNode.getChildren();\n            try {\n                String setName = null;\n                List<BlackboardAttribute> attributes = art.getAttributes();\n                for (BlackboardAttribute att : attributes) {\n                    int typeId = att.getAttributeTypeID();\n                    if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()) {\n                        setName = att.getValueString();\n                    }\n                }\n                treeNode = hashsetRootChilds.findChild(setName);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Error retrieving attributes\", ex); //NON-NLS\n            }\n        } else if (typeID == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n            Node keywordRootNode = resultsChilds.findChild(typeName);\n            Children keywordRootChilds = keywordRootNode.getChildren();\n            try {\n                String listName = null;\n                String keywordName = null;\n                List<BlackboardAttribute> attributes = art.getAttributes();\n                for (BlackboardAttribute att : attributes) {\n                    int typeId = att.getAttributeTypeID();\n                    if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()) {\n                        listName = att.getValueString();\n                    } else if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD.getTypeID()) {\n                        keywordName = att.getValueString();\n                    }\n                }\n                Node listNode = keywordRootChilds.findChild(listName);\n                if (listNode == null) {\n                    return;\n                }\n                Children listChildren = listNode.getChildren();\n                if (listChildren == null) {\n                    return;\n                }\n                treeNode = listChildren.findChild(keywordName);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Error retrieving attributes\", ex); //NON-NLS\n            }\n        } else if (typeID == BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getTypeID()\n                || typeID == BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT.getTypeID()) {\n            Node interestingItemsRootNode = resultsChilds.findChild(typeName);\n            Children interestingItemsRootChildren = interestingItemsRootNode.getChildren();\n            try {\n                String setName = null;\n                List<BlackboardAttribute> attributes = art.getAttributes();\n                for (BlackboardAttribute att : attributes) {\n                    int typeId = att.getAttributeTypeID();\n                    if (typeId == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()) {\n                        setName = att.getValueString();\n                    }\n                }\n                treeNode = interestingItemsRootChildren.findChild(setName);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Error retrieving attributes\", ex); //NON-NLS\n            }\n        } else {\n            Node extractedContent = resultsChilds.findChild(ExtractedContent.NAME);\n            Children extractedChilds = extractedContent.getChildren();\n            if (extractedChilds == null) {\n                return;\n            }\n            treeNode = extractedChilds.findChild(typeName);\n        }\n\n        if (treeNode == null) {\n            return;\n        }\n\n        try {\n            em.setExploredContextAndSelection(treeNode, new Node[]{treeNode});\n        } catch (PropertyVetoException ex) {\n            logger.log(Level.WARNING, \"Property Veto: \", ex); //NON-NLS\n        }\n\n        // Another thread is needed because we have to wait for dataResult to populate\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                Children resultChilds = dataResult.getRootNode().getChildren();\n                Node select = resultChilds.findChild(Long.toString(art.getArtifactID()));\n                if (select != null) {\n                    dataResult.requestActive();\n                    dataResult.setSelectedNodes(new Node[]{select});\n                    fireViewerComplete();\n                }\n            }\n        });\n    }","commit_id":"672a25056e20cf0251af9df84f609aa0b750cc90","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** how long we allow tests to run for before failing them */\n    private int getTestPeriod() {\n        if (_outTunnel == null || _replyTunnel == null)\n            return 15*1000;\n        // Give it 2.5s per hop + 5s (2 hop tunnel = length 3, so this will be 15s for two 2-hop tunnels)\n        // Minimum is 7.5s (since a 0-hop could be the expl. tunnel, but only >= 1-hop client tunnels are tested)\n        // Network average for success is about 1.5s.\n        // Another possibility - make configurable via pool options\n        //\n        // Try to prevent congestion collapse (failing all our tunnels and then clogging our outbound\n        // with new tunnel build requests) by adding in three times the average outbound delay.\n        int delay = 3 * (int) getContext().statManager().getRate(\"transport.sendProcessingTime\").getRate(60*1000).getAverageValue();\n        return delay + (2500 * (_outTunnel.getLength() + _replyTunnel.getLength()));\n    }","id":104485,"modified_method":"/** how long we allow tests to run for before failing them */\n    private int getTestPeriod() {\n        if (_outTunnel == null || _replyTunnel == null)\n            return 15*1000;\n        // Give it 2.5s per hop + 5s (2 hop tunnel = length 3, so this will be 15s for two 2-hop tunnels)\n        // Minimum is 7.5s (since a 0-hop could be the expl. tunnel, but only >= 1-hop client tunnels are tested)\n        // Network average for success is about 1.5s.\n        // Another possibility - make configurable via pool options\n        //\n        // Try to prevent congestion collapse (failing all our tunnels and then clogging our outbound\n        // with new tunnel build requests) by adding in three times the average outbound delay.\n        RateStat tspt = getContext().statManager().getRate(\"transport.sendProcessingTime\");\n        if (tspt != null) {\n            Rate r = tspt.getRate(60*1000);\n            if (r != null) {\n                int delay = 3 * (int) r.getAverageValue();\n                return delay + (2500 * (_outTunnel.getLength() + _replyTunnel.getLength()));\n            }\n        }\n        return 15*1000;\n    }","commit_id":"b41c58341f06528d9c23f81db61712dc37b71be8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public boolean acceptTunnelRequest(TunnelCreateMessage msg) { \n        long lag = _context.jobQueue().getMaxLag();\n        Rate throttleRate = _context.statManager().getRate(\"router.throttleNetworkCause\").getRate(10*60*1000);\n        long throttleEvents = throttleRate.getCurrentEventCount() + throttleRate.getLastEventCount();\n        if (throttleEvents > THROTTLE_EVENT_LIMIT) {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Refusing tunnel request with the job lag of \" + lag \n                           + \" since there have been \" + throttleEvents \n                           + \" throttle events in the last 15 minutes or so\");\n            _context.statManager().addRateData(\"router.throttleTunnelCause\", lag, lag);\n            return false;\n        }\n        \n        // ok, we're not hosed, but can we handle the bandwidth requirements \n        // of another tunnel?\n        double msgsPerTunnel = _context.statManager().getRate(\"tunnel.participatingMessagesProcessed\").getRate(10*60*1000).getAverageValue();\n        double bytesPerMsg = _context.statManager().getRate(\"tunnel.relayMessageSize\").getRate(10*60*1000).getAverageValue();\n        double bytesPerTunnel = msgsPerTunnel * bytesPerMsg;\n\n\n        int numTunnels = _context.tunnelManager().getParticipatingCount();\n        double bytesAllocated =  (numTunnels + 1) * bytesPerTunnel;\n\n        _context.statManager().addRateData(\"tunnel.bytesAllocatedAtAccept\", (long)bytesAllocated, msg.getTunnelDurationSeconds()*1000);\n        // todo: um, throttle (include bw usage of the netDb, our own tunnels, the clients,\n        // and check to see that they are less than the bandwidth limits\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Accepting a new tunnel request (now allocating \" + bytesAllocated + \" bytes across \" + numTunnels \n                       + \" tunnels with lag of \" + lag + \" and \" + throttleEvents + \" throttle events)\");\n        return true;\n    }","id":104486,"modified_method":"public boolean acceptTunnelRequest(TunnelCreateMessage msg) { \n        long lag = _context.jobQueue().getMaxLag();\n        RateStat rs = _context.statManager().getRate(\"router.throttleNetworkCause\");\n        Rate r = null;\n        if (rs != null)\n            r = rs.getRate(10*60*1000);\n        long throttleEvents = (r != null ? r.getCurrentEventCount() + r.getLastEventCount() : 0);\n        if (throttleEvents > THROTTLE_EVENT_LIMIT) {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Refusing tunnel request with the job lag of \" + lag \n                           + \" since there have been \" + throttleEvents \n                           + \" throttle events in the last 15 minutes or so\");\n            _context.statManager().addRateData(\"router.throttleTunnelCause\", lag, lag);\n            return false;\n        }\n        \n         \n        \n        // ok, we're not hosed, but can we handle the bandwidth requirements \n        // of another tunnel?\n        rs = _context.statManager().getRate(\"tunnel.participatingMessagesProcessed\");\n        r = null;\n        if (rs != null)\n            r = rs.getRate(10*60*1000);\n        double msgsPerTunnel = (r != null ? r.getAverageValue() : 0);\n        r = null;\n        rs = _context.statManager().getRate(\"tunnel.relayMessageSize\");\n        if (rs != null)\n            r = rs.getRate(10*60*1000);\n        double bytesPerMsg = (r != null ? r.getAverageValue() : 0);\n        double bytesPerTunnel = msgsPerTunnel * bytesPerMsg;\n\n\n        int numTunnels = _context.tunnelManager().getParticipatingCount();\n        double bytesAllocated =  (numTunnels + 1) * bytesPerTunnel;\n\n        _context.statManager().addRateData(\"tunnel.bytesAllocatedAtAccept\", (long)bytesAllocated, msg.getTunnelDurationSeconds()*1000);\n        // todo: um, throttle (include bw usage of the netDb, our own tunnels, the clients,\n        // and check to see that they are less than the bandwidth limits\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Accepting a new tunnel request (now allocating \" + bytesAllocated + \" bytes across \" + numTunnels \n                       + \" tunnels with lag of \" + lag + \" and \" + throttleEvents + \" throttle events)\");\n        return true;\n    }","commit_id":"2d6af89f605f578c0c03c0772068a067c643976d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void afterPropertiesSet() {\n        Assert.state(m_configResource != null, \"property configResource must be set and be non-null\");\n    \n        V config = loadConfig(m_configResource);\n        m_container = new FileReloadContainer<V>(config, m_configResource, m_callback);\n    }","id":104487,"modified_method":"public void afterPropertiesSet() {\n        Assert.state(m_configResource != null, \"property configResource must be set and be non-null\");\n    \n        V config = loadConfig(m_configResource);\n        m_container = new FileReloadContainer<V>(config, m_configResource, m_callback);\n\n        if (m_reloadCheckInterval != null) {\n            m_container.setReloadCheckInterval(m_reloadCheckInterval);\n        }\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AbstractCastorConfigDao(Class<K> entityClass) {\n        super();\n        \n        m_castorClass = entityClass;\n    }","id":104488,"modified_method":"public AbstractCastorConfigDao(Class<K> entityClass, String description) {\n        super();\n        \n        m_castorClass = entityClass;\n        m_description = description;\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected V loadConfig(Resource resource) {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        V config;\n        try {\n            log().debug(\"loading configuration\");\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n            log().debug(\"configuration loaded\");\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        return config;\n    }","id":104489,"modified_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"': \" + e, e);\n        }\n    \n        V config;\n        try {\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TestCastorConfigDao() {\n            super(Userinfo.class);\n        }","id":104490,"modified_method":"public TestCastorConfigDao() {\n            super(Userinfo.class, \"user information configuration\");\n        }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DefaultStatisticsDaemonConfigDao() {\n        super(StatisticsDaemonConfiguration.class);\n    }","id":104491,"modified_method":"public DefaultStatisticsDaemonConfigDao() {\n        super(StatisticsDaemonConfiguration.class, \"statistics daemon configuration\");\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DefaultSurveillanceViewConfigDao() {\n        super(SurveillanceViewConfiguration.class);\n    }","id":104492,"modified_method":"public DefaultSurveillanceViewConfigDao() {\n        super(SurveillanceViewConfiguration.class, \"surveillance view configuration\");\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Creates a new container with an object and a file underlying that\n     * object.  The {@link FileReloadCallback#reload(Object, File) reload}\n     * on the callback will be called when the file is modified.\n     *  \n     * @param object object to be stored in this container\n     * @param file file underlying the object\n     * @param callback {@link FileReloadCallback#reload(Object, File) reload}\n     *  will be called when the underlying file object is modified\n     * @throws IllegalArgumentException if object, file, or callback are null\n     */\n    public FileReloadContainer(T object, Resource resource,\n                               FileReloadCallback<T> callback) {\n        Assert.notNull(object, \"argument object cannot be null\");\n        Assert.notNull(resource, \"argument file cannot be null\");\n        Assert.notNull(callback, \"argument callback cannot be null\");\n        \n        m_object = object;\n        m_resource = resource;\n        m_callback = callback;\n        \n        try {\n            m_file = resource.getFile();\n            m_lastModified = m_file.lastModified();\n        } catch (IOException e) {\n            // Do nothing... we'll fall back to using the InputStream\n            log().info(\"Resource '\" + resource + \"' does not seem to have an underlying File object; assuming this is not an auto-reloadable file resource\");\n        }\n    }","id":104493,"modified_method":"/**\n     * Creates a new container with an object and a file underlying that\n     * object.  If reloadCheckInterval is set to a non-negative value\n     * (default is 1000 milliseconds), the last modified timestamp on\n     * the file will be checked and the\n     * {@link FileReloadCallback#reload(Object, File) reload}\n     * on the callback will be called when the file is modified.  The\n     * check will be performed when {@link #getObject()} is called and\n     * at least reloadCheckInterval milliseconds have passed. \n     *  \n     * @param object object to be stored in this container\n     * @param file file underlying the object\n     * @param callback {@link FileReloadCallback#reload(Object, File) reload}\n     *  will be called when the underlying file object is modified\n     * @throws IllegalArgumentException if object, file, or callback are null\n     */\n    public FileReloadContainer(T object, Resource resource,\n                               FileReloadCallback<T> callback) {\n        Assert.notNull(object, \"argument object cannot be null\");\n        Assert.notNull(resource, \"argument file cannot be null\");\n        Assert.notNull(callback, \"argument callback cannot be null\");\n        \n        m_object = object;\n        m_resource = resource;\n        m_callback = callback;\n        \n        try {\n            m_file = resource.getFile();\n            m_lastModified = m_file.lastModified();\n        } catch (IOException e) {\n            // Do nothing... we'll fall back to using the InputStream\n            log().info(\"Resource '\" + resource + \"' does not seem to have an underlying File object; assuming this is not an auto-reloadable file resource\");\n        }\n        \n        m_lastReloadCheck = System.currentTimeMillis();\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized void checkForUpdates() throws DataAccessResourceFailureException {\n        if (m_file == null) {\n            return;\n        }\n        \n        long lastModified = m_file.lastModified();\n        \n        if (lastModified <= m_lastModified) {\n            return;\n        }\n        \n        /*\n         * Always update the timestamp, even if we have an error. \n         * XXX What if someone is writing the file while we are reading it,\n         * we get an error, and the (correct) file is written completely\n         * within the same second, so lastModified doesn't get updated.\n         */\n        m_lastModified = lastModified;\n            \n        T object;\n        try {\n            object = m_callback.reload(m_object, m_resource);\n        } catch (Throwable t) {\n            String message = \n                \"Failed reloading data for object '\" + m_object + \"' \"\n                + \"from file '\" + m_file.getAbsolutePath() + \"'.  \"\n                + \"Unexpected Throwable received while \"\n                + \"issuing reload: \" + t.getMessage();\n            log().error(message, t);\n            throw new DataAccessResourceFailureException(message, t);\n        }\n        \n        if (object == null) {\n            log().info(\"Not updating object for file '\"\n                       + m_file.getAbsolutePath()\n                       + \"' due to reload callback returning null\");\n        } else {\n            m_object = object;\n        }\n    }","id":104494,"modified_method":"private synchronized void checkForUpdates() throws DataAccessResourceFailureException {\n        if (m_file == null || m_reloadCheckInterval < 0\n                || (m_lastReloadCheck + m_reloadCheckInterval) < System.currentTimeMillis()) {\n            return;\n        }\n        \n        m_lastReloadCheck = System.currentTimeMillis();\n        \n        if (m_file.lastModified() <= m_lastModified) {\n            return;\n        }\n        \n        reload();\n    }","commit_id":"ccb08cfc68d3c15897f90628724ef5b75f88a995","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected V loadConfig(Resource resource) {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        V config;\n        try {\n            log().debug(\"loading configuration\");\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n            log().debug(\"configuration loaded\");\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        return config;\n    }","id":104495,"modified_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"': \" + e, e);\n        }\n    \n        V config;\n        try {\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() {\n        Assert.state(m_configResource != null, \"property configResource must be set and be non-null\");\n    \n        V config = loadConfig(m_configResource);\n        m_container = new FileReloadContainer<V>(config, m_configResource, m_callback);\n    }","id":104496,"modified_method":"public void afterPropertiesSet() {\n        Assert.state(m_configResource != null, \"property configResource must be set and be non-null\");\n    \n        V config = loadConfig(m_configResource);\n        m_container = new FileReloadContainer<V>(config, m_configResource, m_callback);\n\n        if (m_reloadCheckInterval != null) {\n            m_container.setReloadCheckInterval(m_reloadCheckInterval);\n        }\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AbstractCastorConfigDao(Class<K> entityClass) {\n        super();\n        \n        m_castorClass = entityClass;\n    }","id":104497,"modified_method":"public AbstractCastorConfigDao(Class<K> entityClass, String description) {\n        super();\n        \n        m_castorClass = entityClass;\n        m_description = description;\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TestCastorConfigDao() {\n            super(Userinfo.class);\n        }","id":104498,"modified_method":"public TestCastorConfigDao() {\n            super(Userinfo.class, \"user information configuration\");\n        }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DefaultStatisticsDaemonConfigDao() {\n        super(StatisticsDaemonConfiguration.class);\n    }","id":104499,"modified_method":"public DefaultStatisticsDaemonConfigDao() {\n        super(StatisticsDaemonConfiguration.class, \"statistics daemon configuration\");\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DefaultSurveillanceViewConfigDao() {\n        super(SurveillanceViewConfiguration.class);\n    }","id":104500,"modified_method":"public DefaultSurveillanceViewConfigDao() {\n        super(SurveillanceViewConfiguration.class, \"surveillance view configuration\");\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized void checkForUpdates() throws DataAccessResourceFailureException {\n        if (m_file == null) {\n            return;\n        }\n        \n        long lastModified = m_file.lastModified();\n        \n        if (lastModified <= m_lastModified) {\n            return;\n        }\n        \n        /*\n         * Always update the timestamp, even if we have an error. \n         * XXX What if someone is writing the file while we are reading it,\n         * we get an error, and the (correct) file is written completely\n         * within the same second, so lastModified doesn't get updated.\n         */\n        m_lastModified = lastModified;\n            \n        T object;\n        try {\n            object = m_callback.reload(m_object, m_resource);\n        } catch (Throwable t) {\n            String message = \n                \"Failed reloading data for object '\" + m_object + \"' \"\n                + \"from file '\" + m_file.getAbsolutePath() + \"'.  \"\n                + \"Unexpected Throwable received while \"\n                + \"issuing reload: \" + t.getMessage();\n            log().error(message, t);\n            throw new DataAccessResourceFailureException(message, t);\n        }\n        \n        if (object == null) {\n            log().info(\"Not updating object for file '\"\n                       + m_file.getAbsolutePath()\n                       + \"' due to reload callback returning null\");\n        } else {\n            m_object = object;\n        }\n    }","id":104501,"modified_method":"private synchronized void checkForUpdates() throws DataAccessResourceFailureException {\n        if (m_file == null || m_reloadCheckInterval < 0\n                || (m_lastReloadCheck + m_reloadCheckInterval) < System.currentTimeMillis()) {\n            return;\n        }\n        \n        m_lastReloadCheck = System.currentTimeMillis();\n        \n        if (m_file.lastModified() <= m_lastModified) {\n            return;\n        }\n        \n        reload();\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Creates a new container with an object and a file underlying that\n     * object.  The {@link FileReloadCallback#reload(Object, File) reload}\n     * on the callback will be called when the file is modified.\n     *  \n     * @param object object to be stored in this container\n     * @param file file underlying the object\n     * @param callback {@link FileReloadCallback#reload(Object, File) reload}\n     *  will be called when the underlying file object is modified\n     * @throws IllegalArgumentException if object, file, or callback are null\n     */\n    public FileReloadContainer(T object, Resource resource,\n                               FileReloadCallback<T> callback) {\n        Assert.notNull(object, \"argument object cannot be null\");\n        Assert.notNull(resource, \"argument file cannot be null\");\n        Assert.notNull(callback, \"argument callback cannot be null\");\n        \n        m_object = object;\n        m_resource = resource;\n        m_callback = callback;\n        \n        try {\n            m_file = resource.getFile();\n            m_lastModified = m_file.lastModified();\n        } catch (IOException e) {\n            // Do nothing... we'll fall back to using the InputStream\n            log().info(\"Resource '\" + resource + \"' does not seem to have an underlying File object; assuming this is not an auto-reloadable file resource\");\n        }\n    }","id":104502,"modified_method":"/**\n     * Creates a new container with an object and a file underlying that\n     * object.  If reloadCheckInterval is set to a non-negative value\n     * (default is 1000 milliseconds), the last modified timestamp on\n     * the file will be checked and the\n     * {@link FileReloadCallback#reload(Object, File) reload}\n     * on the callback will be called when the file is modified.  The\n     * check will be performed when {@link #getObject()} is called and\n     * at least reloadCheckInterval milliseconds have passed. \n     *  \n     * @param object object to be stored in this container\n     * @param file file underlying the object\n     * @param callback {@link FileReloadCallback#reload(Object, File) reload}\n     *  will be called when the underlying file object is modified\n     * @throws IllegalArgumentException if object, file, or callback are null\n     */\n    public FileReloadContainer(T object, Resource resource,\n                               FileReloadCallback<T> callback) {\n        Assert.notNull(object, \"argument object cannot be null\");\n        Assert.notNull(resource, \"argument file cannot be null\");\n        Assert.notNull(callback, \"argument callback cannot be null\");\n        \n        m_object = object;\n        m_resource = resource;\n        m_callback = callback;\n        \n        try {\n            m_file = resource.getFile();\n            m_lastModified = m_file.lastModified();\n        } catch (IOException e) {\n            // Do nothing... we'll fall back to using the InputStream\n            log().info(\"Resource '\" + resource + \"' does not seem to have an underlying File object; assuming this is not an auto-reloadable file resource\");\n        }\n        \n        m_lastReloadCheck = System.currentTimeMillis();\n    }","commit_id":"9d2ea16ef09751617d9fb20ce5e2c2efef6f0d35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() {\n        Assert.state(m_configResource != null, \"property configResource must be set and be non-null\");\n    \n        V config = loadConfig(m_configResource);\n        m_container = new FileReloadContainer<V>(config, m_configResource, m_callback);\n    }","id":104503,"modified_method":"public void afterPropertiesSet() {\n        Assert.state(m_configResource != null, \"property configResource must be set and be non-null\");\n    \n        V config = loadConfig(m_configResource);\n        m_container = new FileReloadContainer<V>(config, m_configResource, m_callback);\n\n        if (m_reloadCheckInterval != null) {\n            m_container.setReloadCheckInterval(m_reloadCheckInterval);\n        }\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AbstractCastorConfigDao(Class<K> entityClass) {\n        super();\n        \n        m_castorClass = entityClass;\n    }","id":104504,"modified_method":"public AbstractCastorConfigDao(Class<K> entityClass, String description) {\n        super();\n        \n        m_castorClass = entityClass;\n        m_description = description;\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected V loadConfig(Resource resource) {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        V config;\n        try {\n            log().debug(\"loading configuration\");\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n            log().debug(\"configuration loaded\");\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        return config;\n    }","id":104505,"modified_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"': \" + e, e);\n        }\n    \n        V config;\n        try {\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TestCastorConfigDao() {\n            super(Userinfo.class);\n        }","id":104506,"modified_method":"public TestCastorConfigDao() {\n            super(Userinfo.class, \"user information configuration\");\n        }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DefaultStatisticsDaemonConfigDao() {\n        super(StatisticsDaemonConfiguration.class);\n    }","id":104507,"modified_method":"public DefaultStatisticsDaemonConfigDao() {\n        super(StatisticsDaemonConfiguration.class, \"statistics daemon configuration\");\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DefaultSurveillanceViewConfigDao() {\n        super(SurveillanceViewConfiguration.class);\n    }","id":104508,"modified_method":"public DefaultSurveillanceViewConfigDao() {\n        super(SurveillanceViewConfiguration.class, \"surveillance view configuration\");\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized void checkForUpdates() throws DataAccessResourceFailureException {\n        if (m_file == null) {\n            return;\n        }\n        \n        long lastModified = m_file.lastModified();\n        \n        if (lastModified <= m_lastModified) {\n            return;\n        }\n        \n        /*\n         * Always update the timestamp, even if we have an error. \n         * XXX What if someone is writing the file while we are reading it,\n         * we get an error, and the (correct) file is written completely\n         * within the same second, so lastModified doesn't get updated.\n         */\n        m_lastModified = lastModified;\n            \n        T object;\n        try {\n            object = m_callback.reload(m_object, m_resource);\n        } catch (Throwable t) {\n            String message = \n                \"Failed reloading data for object '\" + m_object + \"' \"\n                + \"from file '\" + m_file.getAbsolutePath() + \"'.  \"\n                + \"Unexpected Throwable received while \"\n                + \"issuing reload: \" + t.getMessage();\n            log().error(message, t);\n            throw new DataAccessResourceFailureException(message, t);\n        }\n        \n        if (object == null) {\n            log().info(\"Not updating object for file '\"\n                       + m_file.getAbsolutePath()\n                       + \"' due to reload callback returning null\");\n        } else {\n            m_object = object;\n        }\n    }","id":104509,"modified_method":"private synchronized void checkForUpdates() throws DataAccessResourceFailureException {\n        if (m_file == null || m_reloadCheckInterval < 0\n                || (m_lastReloadCheck + m_reloadCheckInterval) < System.currentTimeMillis()) {\n            return;\n        }\n        \n        m_lastReloadCheck = System.currentTimeMillis();\n        \n        if (m_file.lastModified() <= m_lastModified) {\n            return;\n        }\n        \n        reload();\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Creates a new container with an object and a file underlying that\n     * object.  The {@link FileReloadCallback#reload(Object, File) reload}\n     * on the callback will be called when the file is modified.\n     *  \n     * @param object object to be stored in this container\n     * @param file file underlying the object\n     * @param callback {@link FileReloadCallback#reload(Object, File) reload}\n     *  will be called when the underlying file object is modified\n     * @throws IllegalArgumentException if object, file, or callback are null\n     */\n    public FileReloadContainer(T object, Resource resource,\n                               FileReloadCallback<T> callback) {\n        Assert.notNull(object, \"argument object cannot be null\");\n        Assert.notNull(resource, \"argument file cannot be null\");\n        Assert.notNull(callback, \"argument callback cannot be null\");\n        \n        m_object = object;\n        m_resource = resource;\n        m_callback = callback;\n        \n        try {\n            m_file = resource.getFile();\n            m_lastModified = m_file.lastModified();\n        } catch (IOException e) {\n            // Do nothing... we'll fall back to using the InputStream\n            log().info(\"Resource '\" + resource + \"' does not seem to have an underlying File object; assuming this is not an auto-reloadable file resource\");\n        }\n    }","id":104510,"modified_method":"/**\n     * Creates a new container with an object and a file underlying that\n     * object.  If reloadCheckInterval is set to a non-negative value\n     * (default is 1000 milliseconds), the last modified timestamp on\n     * the file will be checked and the\n     * {@link FileReloadCallback#reload(Object, File) reload}\n     * on the callback will be called when the file is modified.  The\n     * check will be performed when {@link #getObject()} is called and\n     * at least reloadCheckInterval milliseconds have passed. \n     *  \n     * @param object object to be stored in this container\n     * @param file file underlying the object\n     * @param callback {@link FileReloadCallback#reload(Object, File) reload}\n     *  will be called when the underlying file object is modified\n     * @throws IllegalArgumentException if object, file, or callback are null\n     */\n    public FileReloadContainer(T object, Resource resource,\n                               FileReloadCallback<T> callback) {\n        Assert.notNull(object, \"argument object cannot be null\");\n        Assert.notNull(resource, \"argument file cannot be null\");\n        Assert.notNull(callback, \"argument callback cannot be null\");\n        \n        m_object = object;\n        m_resource = resource;\n        m_callback = callback;\n        \n        try {\n            m_file = resource.getFile();\n            m_lastModified = m_file.lastModified();\n        } catch (IOException e) {\n            // Do nothing... we'll fall back to using the InputStream\n            log().info(\"Resource '\" + resource + \"' does not seem to have an underlying File object; assuming this is not an auto-reloadable file resource\");\n        }\n        \n        m_lastReloadCheck = System.currentTimeMillis();\n    }","commit_id":"daa28bf7488dcdd0f8808382c270fac40f6fa718","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n  public void testExistingGetter() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@Getter int foo = 1\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"def getFoo() {\");\n      _builder.newLine();\n      _builder.append(\"\\t\\t\");\n      _builder.append(\"2\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String text = _builder.toString();\n      XtendClass _clazz = this.clazz(text);\n      this._validationTestHelper.assertWarning(_clazz, XtendPackage.Literals.XTEND_FIELD, \"user.issue\", \"no effect\");\n      final IAcceptor<CompilationTestHelper.Result> _function = new IAcceptor<CompilationTestHelper.Result>() {\n        public void accept(final CompilationTestHelper.Result it) {\n          try {\n            Class<?> _compiledClass = it.getCompiledClass();\n            final Object instance = _compiledClass.newInstance();\n            Class<?> _compiledClass_1 = it.getCompiledClass();\n            final Method getFoo = _compiledClass_1.getDeclaredMethod(\"getFoo\");\n            Object _invoke = getFoo.invoke(instance);\n            Assert.assertEquals(Integer.valueOf(2), _invoke);\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      this.compilationTestHelper.compile(text, _function);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":104511,"modified_method":"@Test\n  public void testExistingGetter() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@Getter int foo = 1\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"def getFoo() {\");\n      _builder.newLine();\n      _builder.append(\"\\t\\t\");\n      _builder.append(\"2\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String text = _builder.toString();\n      XtendClass _clazz = this.clazz(text);\n      this._validationTestHelper.assertWarning(_clazz, XAnnotationsPackage.Literals.XANNOTATION, \"user.issue\", \"no effect\");\n      final IAcceptor<CompilationTestHelper.Result> _function = new IAcceptor<CompilationTestHelper.Result>() {\n        public void accept(final CompilationTestHelper.Result it) {\n          try {\n            Class<?> _compiledClass = it.getCompiledClass();\n            final Object instance = _compiledClass.newInstance();\n            Class<?> _compiledClass_1 = it.getCompiledClass();\n            final Method getFoo = _compiledClass_1.getDeclaredMethod(\"getFoo\");\n            Object _invoke = getFoo.invoke(instance);\n            Assert.assertEquals(Integer.valueOf(2), _invoke);\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      this.compilationTestHelper.compile(text, _function);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"9140627bffdb0865793e22e4b385b7923dfc2938","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _transform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final GetterProcessor.Util util = new GetterProcessor.Util(context);\n    boolean _hasGetter = util.hasGetter(it);\n    if (_hasGetter) {\n      context.addWarning(it, \"A getter is already defined, this annotation has no effect\");\n    } else {\n      util.addGetter(it);\n    }\n  }","id":104512,"modified_method":"protected void _transform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final GetterProcessor.Util util = new GetterProcessor.Util(context);\n    boolean _hasGetter = util.hasGetter(it);\n    if (_hasGetter) {\n      Type _findTypeGlobally = context.findTypeGlobally(Getter.class);\n      final AnnotationReference annotation = it.findAnnotation(_findTypeGlobally);\n      context.addWarning(annotation, \"A getter is already defined, this annotation has no effect\");\n    } else {\n      util.addGetter(it);\n    }\n  }","commit_id":"9140627bffdb0865793e22e4b385b7923dfc2938","url":"https://github.com/eclipse/xtext"},{"original_method":"public void addGetter(final MutableFieldDeclaration field) {\n      field.markAsRead();\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _getterName = this.getGetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          AnnotationReference _newAnnotationReference = Util.this.context.newAnnotationReference(Pure.class);\n          it.addAnnotation(_newAnnotationReference);\n          TypeReference _type = field.getType();\n          it.setReturnType(_type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              _builder.append(\"return this.\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n        }\n      };\n      _declaringType.addMethod(_getterName, _function);\n    }","id":104513,"modified_method":"public void addGetter(final MutableFieldDeclaration field) {\n      field.markAsRead();\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _getterName = this.getGetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          AnnotationReference _newAnnotationReference = Util.this.context.newAnnotationReference(Pure.class);\n          it.addAnnotation(_newAnnotationReference);\n          TypeReference _type = field.getType();\n          it.setReturnType(_type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              _builder.append(\"return \");\n              Object _fieldOwner = Util.this.fieldOwner(field);\n              _builder.append(_fieldOwner, \"\");\n              _builder.append(\".\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n          boolean _isStatic = field.isStatic();\n          it.setStatic(_isStatic);\n        }\n      };\n      _declaringType.addMethod(_getterName, _function);\n    }","commit_id":"9140627bffdb0865793e22e4b385b7923dfc2938","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testExistingSetter() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@Setter int foo\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"def setFoo(int foo) {\");\n      _builder.newLine();\n      _builder.append(\"\\t\\t\");\n      _builder.append(\"this.foo = 2\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String text = _builder.toString();\n      XtendClass _clazz = this.clazz(text);\n      this._validationTestHelper.assertWarning(_clazz, XtendPackage.Literals.XTEND_FIELD, \"user.issue\", \"no effect\");\n      final IAcceptor<CompilationTestHelper.Result> _function = new IAcceptor<CompilationTestHelper.Result>() {\n        public void accept(final CompilationTestHelper.Result it) {\n          try {\n            Class<?> _compiledClass = it.getCompiledClass();\n            final Object instance = _compiledClass.newInstance();\n            Class<?> _compiledClass_1 = it.getCompiledClass();\n            final Method setFoo = _compiledClass_1.getDeclaredMethod(\"setFoo\", int.class);\n            Class<?> _compiledClass_2 = it.getCompiledClass();\n            Field _declaredField = _compiledClass_2.getDeclaredField(\"foo\");\n            final Procedure1<Field> _function = new Procedure1<Field>() {\n              public void apply(final Field it) {\n                it.setAccessible(true);\n              }\n            };\n            final Field fooField = ObjectExtensions.<Field>operator_doubleArrow(_declaredField, _function);\n            setFoo.invoke(instance, Integer.valueOf(1));\n            Object _get = fooField.get(instance);\n            Assert.assertEquals(Integer.valueOf(2), _get);\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      this.compilationTestHelper.compile(text, _function);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":104514,"modified_method":"@Test\n  public void testExistingSetter() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@Setter int foo\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"def setFoo(int foo) {\");\n      _builder.newLine();\n      _builder.append(\"\\t\\t\");\n      _builder.append(\"this.foo = 2\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String text = _builder.toString();\n      XtendClass _clazz = this.clazz(text);\n      this._validationTestHelper.assertWarning(_clazz, XAnnotationsPackage.Literals.XANNOTATION, \"user.issue\", \"no effect\");\n      final IAcceptor<CompilationTestHelper.Result> _function = new IAcceptor<CompilationTestHelper.Result>() {\n        public void accept(final CompilationTestHelper.Result it) {\n          try {\n            Class<?> _compiledClass = it.getCompiledClass();\n            final Object instance = _compiledClass.newInstance();\n            Class<?> _compiledClass_1 = it.getCompiledClass();\n            final Method setFoo = _compiledClass_1.getDeclaredMethod(\"setFoo\", int.class);\n            Class<?> _compiledClass_2 = it.getCompiledClass();\n            Field _declaredField = _compiledClass_2.getDeclaredField(\"foo\");\n            final Procedure1<Field> _function = new Procedure1<Field>() {\n              public void apply(final Field it) {\n                it.setAccessible(true);\n              }\n            };\n            final Field fooField = ObjectExtensions.<Field>operator_doubleArrow(_declaredField, _function);\n            setFoo.invoke(instance, Integer.valueOf(1));\n            Object _get = fooField.get(instance);\n            Assert.assertEquals(Integer.valueOf(2), _get);\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      this.compilationTestHelper.compile(text, _function);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"9140627bffdb0865793e22e4b385b7923dfc2938","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _transform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final SetterProcessor.Util util = new SetterProcessor.Util(context);\n    boolean _hasSetter = util.hasSetter(it);\n    if (_hasSetter) {\n      context.addWarning(it, \"A setter is already defined, this annotation has no effect\");\n    } else {\n      util.addSetter(it);\n    }\n  }","id":104515,"modified_method":"protected void _transform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final SetterProcessor.Util util = new SetterProcessor.Util(context);\n    boolean _hasSetter = util.hasSetter(it);\n    if (_hasSetter) {\n      Type _findTypeGlobally = context.findTypeGlobally(Setter.class);\n      final AnnotationReference annotation = it.findAnnotation(_findTypeGlobally);\n      context.addWarning(annotation, \"A setter is already defined, this annotation has no effect\");\n    } else {\n      util.addSetter(it);\n    }\n  }","commit_id":"9140627bffdb0865793e22e4b385b7923dfc2938","url":"https://github.com/eclipse/xtext"},{"original_method":"public void addSetter(final MutableFieldDeclaration field) {\n      boolean _isFinal = field.isFinal();\n      if (_isFinal) {\n        this.context.addError(field, \"Cannot set a final field\");\n        return;\n      }\n      TypeReference _type = field.getType();\n      boolean _isInferred = _type.isInferred();\n      if (_isInferred) {\n        this.context.addError(field, \"Type cannot be inferred.\");\n        return;\n      }\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _setterName = this.getSetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          TypeReference _primitiveVoid = Util.this.context.getPrimitiveVoid();\n          it.setReturnType(_primitiveVoid);\n          String _simpleName = field.getSimpleName();\n          TypeReference _type = field.getType();\n          final MutableParameterDeclaration param = it.addParameter(_simpleName, _type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              _builder.append(\"this.\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\" = \");\n              String _simpleName_1 = param.getSimpleName();\n              _builder.append(_simpleName_1, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n        }\n      };\n      _declaringType.addMethod(_setterName, _function);\n    }","id":104516,"modified_method":"public void addSetter(final MutableFieldDeclaration field) {\n      boolean _isFinal = field.isFinal();\n      if (_isFinal) {\n        this.context.addError(field, \"Cannot set a final field\");\n        return;\n      }\n      TypeReference _type = field.getType();\n      boolean _isInferred = _type.isInferred();\n      if (_isInferred) {\n        this.context.addError(field, \"Type cannot be inferred.\");\n        return;\n      }\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _setterName = this.getSetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          TypeReference _primitiveVoid = Util.this.context.getPrimitiveVoid();\n          it.setReturnType(_primitiveVoid);\n          String _simpleName = field.getSimpleName();\n          TypeReference _type = field.getType();\n          final MutableParameterDeclaration param = it.addParameter(_simpleName, _type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              Object _fieldOwner = Util.this.fieldOwner(field);\n              _builder.append(_fieldOwner, \"\");\n              _builder.append(\".\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\" = \");\n              String _simpleName_1 = param.getSimpleName();\n              _builder.append(_simpleName_1, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n          boolean _isStatic = field.isStatic();\n          it.setStatic(_isStatic);\n        }\n      };\n      _declaringType.addMethod(_setterName, _function);\n    }","commit_id":"9140627bffdb0865793e22e4b385b7923dfc2938","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testExistingEquals() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"@EqualsHashCode class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"int a = 1\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"override equals(Object o) {\");\n      _builder.newLine();\n      _builder.append(\"\\t\\t\");\n      _builder.append(\"true\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String text = _builder.toString();\n      XtendClass _clazz = this.clazz(text);\n      this._validationTestHelper.assertWarning(_clazz, XtendPackage.Literals.XTEND_CLASS, \"user.issue\", \"no effect\");\n      final IAcceptor<CompilationTestHelper.Result> _function = new IAcceptor<CompilationTestHelper.Result>() {\n        public void accept(final CompilationTestHelper.Result it) {\n          try {\n            Class<?> _compiledClass = it.getCompiledClass();\n            final Object instance = _compiledClass.newInstance();\n            Assert.assertEquals(instance, \"foo\");\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      this.compilationTestHelper.compile(text, _function);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":104517,"modified_method":"@Test\n  public void testExistingEquals() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"@EqualsHashCode class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"int a = 1\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"override equals(Object o) {\");\n      _builder.newLine();\n      _builder.append(\"\\t\\t\");\n      _builder.append(\"true\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String text = _builder.toString();\n      XtendClass _clazz = this.clazz(text);\n      this._validationTestHelper.assertWarning(_clazz, XAnnotationsPackage.Literals.XANNOTATION, \"user.issue\", \"no effect\");\n      final IAcceptor<CompilationTestHelper.Result> _function = new IAcceptor<CompilationTestHelper.Result>() {\n        public void accept(final CompilationTestHelper.Result it) {\n          try {\n            Class<?> _compiledClass = it.getCompiledClass();\n            final Object instance = _compiledClass.newInstance();\n            Assert.assertEquals(instance, \"foo\");\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      this.compilationTestHelper.compile(text, _function);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"9f8e6f133abf9892ebf621f0d99eb83fec5998d1","url":"https://github.com/eclipse/xtext"},{"original_method":"public void doTransform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final EqualsHashCodeProcessor.Util util = new EqualsHashCodeProcessor.Util(context);\n    @Extension\n    final ValueObjectProcessor.Util voUtil = new ValueObjectProcessor.Util(context);\n    boolean _hasEquals = util.hasEquals(it);\n    if (_hasEquals) {\n      context.addWarning(it, \"equals is already defined, this annotation has no effect\");\n    } else {\n      boolean _hasHashCode = util.hasHashCode(it);\n      if (_hasHashCode) {\n        context.addWarning(it, \"hashCode is already defined, this annotation has no effect\");\n      } else {\n        TypeReference _extendedClass = it.getExtendedClass();\n        TypeReference _object = context.getObject();\n        final boolean hasSuperClass = (!Objects.equal(_extendedClass, _object));\n        Iterable<? extends MutableFieldDeclaration> _valueObjectFields = voUtil.getValueObjectFields(it);\n        util.addEquals(it, _valueObjectFields, hasSuperClass);\n        Iterable<? extends MutableFieldDeclaration> _valueObjectFields_1 = voUtil.getValueObjectFields(it);\n        util.addHashCode(it, _valueObjectFields_1, hasSuperClass);\n      }\n    }\n  }","id":104518,"modified_method":"public void doTransform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final EqualsHashCodeProcessor.Util util = new EqualsHashCodeProcessor.Util(context);\n    @Extension\n    final ValueObjectProcessor.Util voUtil = new ValueObjectProcessor.Util(context);\n    boolean _hasEquals = util.hasEquals(it);\n    if (_hasEquals) {\n      Type _findTypeGlobally = context.findTypeGlobally(EqualsHashCode.class);\n      final AnnotationReference annotation = it.findAnnotation(_findTypeGlobally);\n      context.addWarning(annotation, \"equals is already defined, this annotation has no effect\");\n    } else {\n      boolean _hasHashCode = util.hasHashCode(it);\n      if (_hasHashCode) {\n        context.addWarning(it, \"hashCode is already defined, this annotation has no effect\");\n      } else {\n        final boolean hasSuperEquals = util.hasSuperEquals(it);\n        Iterable<? extends MutableFieldDeclaration> _valueObjectFields = voUtil.getValueObjectFields(it);\n        util.addEquals(it, _valueObjectFields, hasSuperEquals);\n        Iterable<? extends MutableFieldDeclaration> _valueObjectFields_1 = voUtil.getValueObjectFields(it);\n        util.addHashCode(it, _valueObjectFields_1, hasSuperEquals);\n      }\n    }\n  }","commit_id":"9f8e6f133abf9892ebf621f0d99eb83fec5998d1","url":"https://github.com/eclipse/xtext"},{"original_method":"private String contributeToHashCode(final FieldDeclaration it) {\n      String _switchResult = null;\n      TypeReference _type = it.getType();\n      String _name = _type.getName();\n      boolean _matched = false;\n      if (!_matched) {\n        String _name_1 = Double.TYPE.getName();\n        if (Objects.equal(_name, _name_1)) {\n          _matched=true;\n          String _simpleName = it.getSimpleName();\n          String _plus = (\"result = prime * result + (int) (Double.doubleToLongBits(this.\" + _simpleName);\n          String _plus_1 = (_plus + \n            \") ^ (Double.doubleToLongBits(this.\");\n          String _simpleName_1 = it.getSimpleName();\n          String _plus_2 = (_plus_1 + _simpleName_1);\n          _switchResult = (_plus_2 + \") >>> 32));\");\n        }\n      }\n      if (!_matched) {\n        String _name_2 = Float.TYPE.getName();\n        if (Objects.equal(_name, _name_2)) {\n          _matched=true;\n          String _simpleName_2 = it.getSimpleName();\n          String _plus_3 = (\"result = prime * result + Float.floatToIntBits(this.\" + _simpleName_2);\n          _switchResult = (_plus_3 + \");\");\n        }\n      }\n      if (!_matched) {\n        String _name_3 = Boolean.TYPE.getName();\n        if (Objects.equal(_name, _name_3)) {\n          _matched=true;\n          String _simpleName_3 = it.getSimpleName();\n          String _plus_4 = (\"result = prime * result + (this.\" + _simpleName_3);\n          _switchResult = (_plus_4 + \" ? 1231 : 1237);\");\n        }\n      }\n      if (!_matched) {\n        String _name_4 = Integer.TYPE.getName();\n        if (Objects.equal(_name, _name_4)) {\n          _matched=true;\n        }\n        if (!_matched) {\n          String _name_5 = Character.TYPE.getName();\n          if (Objects.equal(_name, _name_5)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_6 = Byte.TYPE.getName();\n          if (Objects.equal(_name, _name_6)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_7 = Short.TYPE.getName();\n          if (Objects.equal(_name, _name_7)) {\n            _matched=true;\n          }\n        }\n        if (_matched) {\n          String _simpleName_4 = it.getSimpleName();\n          String _plus_5 = (\"result = prime * result + this.\" + _simpleName_4);\n          _switchResult = (_plus_5 + \";\");\n        }\n      }\n      if (!_matched) {\n        String _name_8 = Long.TYPE.getName();\n        if (Objects.equal(_name, _name_8)) {\n          _matched=true;\n          String _simpleName_5 = it.getSimpleName();\n          String _plus_6 = (\"result = prime * result + (int) (this.\" + _simpleName_5);\n          String _plus_7 = (_plus_6 + \" ^ (this.\");\n          String _simpleName_6 = it.getSimpleName();\n          String _plus_8 = (_plus_7 + _simpleName_6);\n          _switchResult = (_plus_8 + \" >>> 32));\");\n        }\n      }\n      if (!_matched) {\n        String _simpleName_7 = it.getSimpleName();\n        String _plus_9 = (\"result = prime * result + ((this.\" + _simpleName_7);\n        String _plus_10 = (_plus_9 + \"== null) ? 0 : this.\");\n        String _simpleName_8 = it.getSimpleName();\n        String _plus_11 = (_plus_10 + _simpleName_8);\n        _switchResult = (_plus_11 + \n          \".hashCode());\");\n      }\n      return _switchResult;\n    }","id":104519,"modified_method":"public String contributeToHashCode(final FieldDeclaration it) {\n      String _switchResult = null;\n      TypeReference _type = it.getType();\n      String _name = _type.getName();\n      boolean _matched = false;\n      if (!_matched) {\n        String _name_1 = Double.TYPE.getName();\n        if (Objects.equal(_name, _name_1)) {\n          _matched=true;\n          String _simpleName = it.getSimpleName();\n          String _plus = (\"result = prime * result + (int) (Double.doubleToLongBits(this.\" + _simpleName);\n          String _plus_1 = (_plus + \n            \") ^ (Double.doubleToLongBits(this.\");\n          String _simpleName_1 = it.getSimpleName();\n          String _plus_2 = (_plus_1 + _simpleName_1);\n          _switchResult = (_plus_2 + \") >>> 32));\");\n        }\n      }\n      if (!_matched) {\n        String _name_2 = Float.TYPE.getName();\n        if (Objects.equal(_name, _name_2)) {\n          _matched=true;\n          String _simpleName_2 = it.getSimpleName();\n          String _plus_3 = (\"result = prime * result + Float.floatToIntBits(this.\" + _simpleName_2);\n          _switchResult = (_plus_3 + \");\");\n        }\n      }\n      if (!_matched) {\n        String _name_3 = Boolean.TYPE.getName();\n        if (Objects.equal(_name, _name_3)) {\n          _matched=true;\n          String _simpleName_3 = it.getSimpleName();\n          String _plus_4 = (\"result = prime * result + (this.\" + _simpleName_3);\n          _switchResult = (_plus_4 + \" ? 1231 : 1237);\");\n        }\n      }\n      if (!_matched) {\n        String _name_4 = Integer.TYPE.getName();\n        if (Objects.equal(_name, _name_4)) {\n          _matched=true;\n        }\n        if (!_matched) {\n          String _name_5 = Character.TYPE.getName();\n          if (Objects.equal(_name, _name_5)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_6 = Byte.TYPE.getName();\n          if (Objects.equal(_name, _name_6)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_7 = Short.TYPE.getName();\n          if (Objects.equal(_name, _name_7)) {\n            _matched=true;\n          }\n        }\n        if (_matched) {\n          String _simpleName_4 = it.getSimpleName();\n          String _plus_5 = (\"result = prime * result + this.\" + _simpleName_4);\n          _switchResult = (_plus_5 + \";\");\n        }\n      }\n      if (!_matched) {\n        String _name_8 = Long.TYPE.getName();\n        if (Objects.equal(_name, _name_8)) {\n          _matched=true;\n          String _simpleName_5 = it.getSimpleName();\n          String _plus_6 = (\"result = prime * result + (int) (this.\" + _simpleName_5);\n          String _plus_7 = (_plus_6 + \" ^ (this.\");\n          String _simpleName_6 = it.getSimpleName();\n          String _plus_8 = (_plus_7 + _simpleName_6);\n          _switchResult = (_plus_8 + \" >>> 32));\");\n        }\n      }\n      if (!_matched) {\n        String _simpleName_7 = it.getSimpleName();\n        String _plus_9 = (\"result = prime * result + ((this.\" + _simpleName_7);\n        String _plus_10 = (_plus_9 + \"== null) ? 0 : this.\");\n        String _simpleName_8 = it.getSimpleName();\n        String _plus_11 = (_plus_10 + _simpleName_8);\n        _switchResult = (_plus_11 + \n          \".hashCode());\");\n      }\n      return _switchResult;\n    }","commit_id":"9f8e6f133abf9892ebf621f0d99eb83fec5998d1","url":"https://github.com/eclipse/xtext"},{"original_method":"private String contributeToEquals(final FieldDeclaration it) {\n      String _switchResult = null;\n      TypeReference _type = it.getType();\n      String _name = _type.getName();\n      boolean _matched = false;\n      if (!_matched) {\n        String _name_1 = Double.TYPE.getName();\n        if (Objects.equal(_name, _name_1)) {\n          _matched=true;\n          StringConcatenation _builder = new StringConcatenation();\n          _builder.append(\"if (Double.doubleToLongBits(other.\");\n          String _simpleName = it.getSimpleName();\n          _builder.append(_simpleName, \"\");\n          _builder.append(\") != Double.doubleToLongBits(this.\");\n          String _simpleName_1 = it.getSimpleName();\n          _builder.append(_simpleName_1, \"\");\n          _builder.append(\"))\");\n          _builder.newLineIfNotEmpty();\n          _builder.append(\"  \");\n          _builder.append(\"return false; \");\n          _builder.newLine();\n          _switchResult = _builder.toString();\n        }\n      }\n      if (!_matched) {\n        String _name_2 = Float.TYPE.getName();\n        if (Objects.equal(_name, _name_2)) {\n          _matched=true;\n          StringConcatenation _builder_1 = new StringConcatenation();\n          _builder_1.append(\"if (Float.floatToIntBits(other.\");\n          String _simpleName_2 = it.getSimpleName();\n          _builder_1.append(_simpleName_2, \"\");\n          _builder_1.append(\") != Float.floatToIntBits(this.\");\n          String _simpleName_3 = it.getSimpleName();\n          _builder_1.append(_simpleName_3, \"\");\n          _builder_1.append(\"))\");\n          _builder_1.newLineIfNotEmpty();\n          _builder_1.append(\"  \");\n          _builder_1.append(\"return false; \");\n          _builder_1.newLine();\n          _switchResult = _builder_1.toString();\n        }\n      }\n      if (!_matched) {\n        String _name_3 = Boolean.TYPE.getName();\n        if (Objects.equal(_name, _name_3)) {\n          _matched=true;\n        }\n        if (!_matched) {\n          String _name_4 = Integer.TYPE.getName();\n          if (Objects.equal(_name, _name_4)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_5 = Character.TYPE.getName();\n          if (Objects.equal(_name, _name_5)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_6 = Byte.TYPE.getName();\n          if (Objects.equal(_name, _name_6)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_7 = Short.TYPE.getName();\n          if (Objects.equal(_name, _name_7)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_8 = Long.TYPE.getName();\n          if (Objects.equal(_name, _name_8)) {\n            _matched=true;\n          }\n        }\n        if (_matched) {\n          StringConcatenation _builder_2 = new StringConcatenation();\n          _builder_2.append(\"if (other.\");\n          String _simpleName_4 = it.getSimpleName();\n          _builder_2.append(_simpleName_4, \"\");\n          _builder_2.append(\" != this.\");\n          String _simpleName_5 = it.getSimpleName();\n          _builder_2.append(_simpleName_5, \"\");\n          _builder_2.append(\")\");\n          _builder_2.newLineIfNotEmpty();\n          _builder_2.append(\"  \");\n          _builder_2.append(\"return false;\");\n          _builder_2.newLine();\n          _switchResult = _builder_2.toString();\n        }\n      }\n      if (!_matched) {\n        StringConcatenation _builder_3 = new StringConcatenation();\n        _builder_3.append(\"if (this.\");\n        String _simpleName_6 = it.getSimpleName();\n        _builder_3.append(_simpleName_6, \"\");\n        _builder_3.append(\" == null) {\");\n        _builder_3.newLineIfNotEmpty();\n        _builder_3.append(\"  \");\n        _builder_3.append(\"if (other.\");\n        String _simpleName_7 = it.getSimpleName();\n        _builder_3.append(_simpleName_7, \"  \");\n        _builder_3.append(\" != null)\");\n        _builder_3.newLineIfNotEmpty();\n        _builder_3.append(\"    \");\n        _builder_3.append(\"return false;\");\n        _builder_3.newLine();\n        _builder_3.append(\"} else if (!this.\");\n        String _simpleName_8 = it.getSimpleName();\n        _builder_3.append(_simpleName_8, \"\");\n        _builder_3.append(\".equals(other.\");\n        String _simpleName_9 = it.getSimpleName();\n        _builder_3.append(_simpleName_9, \"\");\n        _builder_3.append(\"))\");\n        _builder_3.newLineIfNotEmpty();\n        _builder_3.append(\"  \");\n        _builder_3.append(\"return false;\");\n        _builder_3.newLine();\n        _switchResult = _builder_3.toString();\n      }\n      return _switchResult;\n    }","id":104520,"modified_method":"public String contributeToEquals(final FieldDeclaration it) {\n      String _switchResult = null;\n      TypeReference _type = it.getType();\n      String _name = _type.getName();\n      boolean _matched = false;\n      if (!_matched) {\n        String _name_1 = Double.TYPE.getName();\n        if (Objects.equal(_name, _name_1)) {\n          _matched=true;\n          StringConcatenation _builder = new StringConcatenation();\n          _builder.append(\"if (Double.doubleToLongBits(other.\");\n          String _simpleName = it.getSimpleName();\n          _builder.append(_simpleName, \"\");\n          _builder.append(\") != Double.doubleToLongBits(this.\");\n          String _simpleName_1 = it.getSimpleName();\n          _builder.append(_simpleName_1, \"\");\n          _builder.append(\"))\");\n          _builder.newLineIfNotEmpty();\n          _builder.append(\"  \");\n          _builder.append(\"return false; \");\n          _builder.newLine();\n          _switchResult = _builder.toString();\n        }\n      }\n      if (!_matched) {\n        String _name_2 = Float.TYPE.getName();\n        if (Objects.equal(_name, _name_2)) {\n          _matched=true;\n          StringConcatenation _builder_1 = new StringConcatenation();\n          _builder_1.append(\"if (Float.floatToIntBits(other.\");\n          String _simpleName_2 = it.getSimpleName();\n          _builder_1.append(_simpleName_2, \"\");\n          _builder_1.append(\") != Float.floatToIntBits(this.\");\n          String _simpleName_3 = it.getSimpleName();\n          _builder_1.append(_simpleName_3, \"\");\n          _builder_1.append(\"))\");\n          _builder_1.newLineIfNotEmpty();\n          _builder_1.append(\"  \");\n          _builder_1.append(\"return false; \");\n          _builder_1.newLine();\n          _switchResult = _builder_1.toString();\n        }\n      }\n      if (!_matched) {\n        String _name_3 = Boolean.TYPE.getName();\n        if (Objects.equal(_name, _name_3)) {\n          _matched=true;\n        }\n        if (!_matched) {\n          String _name_4 = Integer.TYPE.getName();\n          if (Objects.equal(_name, _name_4)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_5 = Character.TYPE.getName();\n          if (Objects.equal(_name, _name_5)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_6 = Byte.TYPE.getName();\n          if (Objects.equal(_name, _name_6)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_7 = Short.TYPE.getName();\n          if (Objects.equal(_name, _name_7)) {\n            _matched=true;\n          }\n        }\n        if (!_matched) {\n          String _name_8 = Long.TYPE.getName();\n          if (Objects.equal(_name, _name_8)) {\n            _matched=true;\n          }\n        }\n        if (_matched) {\n          StringConcatenation _builder_2 = new StringConcatenation();\n          _builder_2.append(\"if (other.\");\n          String _simpleName_4 = it.getSimpleName();\n          _builder_2.append(_simpleName_4, \"\");\n          _builder_2.append(\" != this.\");\n          String _simpleName_5 = it.getSimpleName();\n          _builder_2.append(_simpleName_5, \"\");\n          _builder_2.append(\")\");\n          _builder_2.newLineIfNotEmpty();\n          _builder_2.append(\"  \");\n          _builder_2.append(\"return false;\");\n          _builder_2.newLine();\n          _switchResult = _builder_2.toString();\n        }\n      }\n      if (!_matched) {\n        StringConcatenation _builder_3 = new StringConcatenation();\n        _builder_3.append(\"if (this.\");\n        String _simpleName_6 = it.getSimpleName();\n        _builder_3.append(_simpleName_6, \"\");\n        _builder_3.append(\" == null) {\");\n        _builder_3.newLineIfNotEmpty();\n        _builder_3.append(\"  \");\n        _builder_3.append(\"if (other.\");\n        String _simpleName_7 = it.getSimpleName();\n        _builder_3.append(_simpleName_7, \"  \");\n        _builder_3.append(\" != null)\");\n        _builder_3.newLineIfNotEmpty();\n        _builder_3.append(\"    \");\n        _builder_3.append(\"return false;\");\n        _builder_3.newLine();\n        _builder_3.append(\"} else if (!this.\");\n        String _simpleName_8 = it.getSimpleName();\n        _builder_3.append(_simpleName_8, \"\");\n        _builder_3.append(\".equals(other.\");\n        String _simpleName_9 = it.getSimpleName();\n        _builder_3.append(_simpleName_9, \"\");\n        _builder_3.append(\"))\");\n        _builder_3.newLineIfNotEmpty();\n        _builder_3.append(\"  \");\n        _builder_3.append(\"return false;\");\n        _builder_3.newLine();\n        _switchResult = _builder_3.toString();\n      }\n      return _switchResult;\n    }","commit_id":"9f8e6f133abf9892ebf621f0d99eb83fec5998d1","url":"https://github.com/eclipse/xtext"},{"original_method":"public void handleError(int status, String message,\n            HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n\n        if (message == null) {\n            message = String.valueOf(status);\n        } else {\n            message = status + \" - \" + message;\n        }\n        \n        if (response.isCommitted()) {\n            log.error(\"handleError: Response already committed; cannot send error \"\n                + status + message);\n        } else {\n        \n            // reset anything in the response first\n            response.reset();\n            \n            // set the status, content type and encoding\n            response.setStatus(status);\n            response.setContentType(\"text/html; charset=UTF-8\");\n            \n            PrintWriter pw = response.getWriter();\n            pw.println(\"<html><head><title>\");\n            pw.println(message);\n            pw.println(\"<\/title><\/head><body><h1>\");\n            pw.println(\"HTTP ERROR:\" + message);\n            pw.println(\"<\/h1><p>\");\n            pw.println(\"RequestURI=\" + request.getRequestURI());\n            pw.println(\"<\/p><hr /><address>\");\n            pw.println(getServerInfo());\n            pw.println(\"<\/address><\/body><\/html>\");\n\n            // commit the response\n            response.flushBuffer();\n\n        }\n    }","id":104521,"modified_method":"public void handleError(int status, String message,\n            HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n\n        if (message == null) {\n            message = String.valueOf(status);\n        } else {\n            message = status + \" - \" + message;\n        }\n        \n        if (response.isCommitted()) {\n            log.error(\"handleError: Response already committed; cannot send error \"\n                + status + message);\n        } else {\n        \n            // error situation\n            String servletName = (String) request.getAttribute(ERROR_SERVLET_NAME);\n            String requestURI = (String) request.getAttribute(ERROR_REQUEST_URI);\n            if (requestURI == null) {\n                requestURI = request.getRequestURI();\n            }\n\n            // reset anything in the response first\n            response.reset();\n            \n            // set the status, content type and encoding\n            response.setStatus(status);\n            response.setContentType(\"text/html; charset=UTF-8\");\n            \n            PrintWriter pw = response.getWriter();\n            pw.println(\"<html><head><title>\");\n            pw.println(message);\n            pw.println(\"<\/title><\/head><body><h1>\");\n            pw.println(\"HTTP ERROR:\" + message);\n            pw.println(\"<\/h1><p>\");\n            pw.println(\"RequestURI=\" + requestURI);\n            if (servletName != null) {\n                pw.println(\"<\/p>Servlet=\" + servletName + \"<p>\");\n            }\n            pw.println(\"<\/p><hr /><address>\");\n            pw.println(getServerInfo());\n            pw.println(\"<\/address><\/body><\/html>\");\n\n            // commit the response\n            response.flushBuffer();\n\n        }\n    }","commit_id":"217db6d82bf63b5849dfb5ec9f84b0e35d712e49","url":"https://github.com/apache/sling"},{"original_method":"public void handleError(Throwable throwable, HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        if (response.isCommitted()) {\n            log.error(\n                \"handleError: Response already committed; cannot send error\",\n                throwable);\n        } else {\n        \n            // reset anything in the response first\n            response.reset();\n            \n            // set the status, content type and encoding\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            response.setContentType(\"text/html; charset=UTF-8\");\n\n            PrintWriter pw = response.getWriter();\n            pw.println(\"<html><head><title>\");\n            pw.println(throwable.getMessage());\n            pw.println(\"<\/title><\/head><body><h1>\");\n            pw.println(throwable.toString());\n            pw.println(\"<\/h1><p>\");\n            pw.println(\"RequestURI=\" + request.getRequestURI());\n            pw.println(\"<\/p><pre>\");\n            throwable.printStackTrace(pw);\n            pw.println(\"<\/pre><hr /><address>\");\n            pw.println(getServerInfo());\n            pw.println(\"<\/address><\/body><\/html>\");\n            \n            // commit the response\n            response.flushBuffer();\n\n        }\n    }","id":104522,"modified_method":"public void handleError(Throwable throwable, HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        if (response.isCommitted()) {\n            log.error(\n                \"handleError: Response already committed; cannot send error\",\n                throwable);\n        } else {\n        \n            // error situation\n            String servletName = (String) request.getAttribute(ERROR_SERVLET_NAME);\n            String requestURI = (String) request.getAttribute(ERROR_REQUEST_URI);\n            if (requestURI == null) {\n                requestURI = request.getRequestURI();\n            }\n\n            // reset anything in the response first\n            response.reset();\n            \n            // set the status, content type and encoding\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            response.setContentType(\"text/html; charset=UTF-8\");\n\n            PrintWriter pw = response.getWriter();\n            pw.println(\"<html><head><title>\");\n            pw.println(throwable.getMessage());\n            pw.println(\"<\/title><\/head><body><h1>\");\n            pw.println(throwable.toString());\n            pw.println(\"<\/h1><p>\");\n            pw.println(\"RequestURI=\" + request.getRequestURI());\n            if (servletName != null) {\n                pw.println(\"<\/p>Servlet=\" + servletName + \"<p>\");\n            }\n            pw.println(\"<\/p><pre>\");\n            throwable.printStackTrace(pw);\n            pw.println(\"<\/pre><hr /><address>\");\n            pw.println(getServerInfo());\n            pw.println(\"<\/address><\/body><\/html>\");\n            \n            // commit the response\n            response.flushBuffer();\n\n        }\n    }","commit_id":"217db6d82bf63b5849dfb5ec9f84b0e35d712e49","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * From the HttpServletRequest, parse the groovy script path using the URL,\n     * adding the extension \".groovy\" as needed.\n     */\n    private String getGroovyScriptPath(HttpServletRequest request) {\n\n        // Get the name of the Groovy script\n        int contextLength = request.getContextPath().length();\n        String scriptFilename = request.getRequestURI()\n            .substring(contextLength).substring(1);\n\n        // if the servlet mapping is .groovy, we don't need to strip the mapping from the filename.\n        // if the mapping is anything else, we need to strip it and append .groovy\n        if (scriptFilename.endsWith(GROOVY_EXTENSION))\n            return scriptFilename;\n\n        // strip the servlet mapping (from the last \".\") and append .groovy\n        int lastDot = scriptFilename.lastIndexOf(\".\");\n        scriptFilename = scriptFilename.substring(0, lastDot)\n            + GROOVY_EXTENSION;\n        return scriptFilename;\n\n    }","id":104523,"modified_method":"/**\n     * From the HttpServletRequest, parse the groovy script path using the URL,\n     * adding the extension \".groovy\" as needed.\n     */\n    private String getGroovyScriptPath(HttpServletRequest request) {\n\n        // Get the name of the Groovy script - include aware (GROOVY-815)\n        String includeURI = (String)request.getAttribute(\"javax.servlet.include.request_uri\");\n        String strURI = null;\n        if (includeURI != null) {\n            strURI = includeURI; \n        } else {\n            strURI = request.getRequestURI(); \n        }\n\n        int contextLength = request.getContextPath().length();\n        String scriptFilename = strURI.substring(contextLength).substring(1);\n\n        // if the servlet mapping is .groovy, we don't need to strip the mapping from the filename.\n        // if the mapping is anything else, we need to strip it and append .groovy\n        if (scriptFilename.endsWith(GROOVY_EXTENSION))\n            return scriptFilename;\n\n        // strip the servlet mapping (from the last \".\") and append .groovy\n        int lastDot = scriptFilename.lastIndexOf(\".\");\n        scriptFilename = scriptFilename.substring(0, lastDot)\n            + GROOVY_EXTENSION;\n        return scriptFilename;\n\n    }","commit_id":"542cb3e0fea2c1163cbf2c61c0c05847d36f1d6a","url":"https://github.com/apache/groovy"},{"original_method":"public void setScaffoldResponseHandlerFactory(ScaffoldResponseHandlerFactory factory) {\n\t\t\tthis.scaffoldResponseFactory = factory;\n\t\t\tthis.scaffoldResponseHandler = this.scaffoldResponseFactory.getScaffoldResponseHandler(request.getRequestURI());\n\t\t}","id":104524,"modified_method":"public void setScaffoldResponseHandlerFactory(ScaffoldResponseHandlerFactory factory) {\n\t\t\tthis.scaffoldResponseFactory = factory;\n            Object includeUri = request.getAttribute(\"javax.servlet.include.request_uri\");\n            String uri;\n            if (includeUri != null) {\n            \turi = (String) includeUri;\n            } else {\n            \turi = request.getRequestURI();\n            }\n\t\t\tthis.scaffoldResponseHandler = this.scaffoldResponseFactory.getScaffoldResponseHandler(uri);\n\t\t}","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Lookup page class or load new one if needed.\n     * @param uri\n     * @param pageUrl\n     * @param spillGroovy\n     * @return\n     * @throws IOException\n     * @throws javax.servlet.ServletException\n     */\n    protected PageMeta getPage(String uri, ServletContext context,URL pageUrl, boolean spillGroovy)\n            throws IOException, ServletException  {\n            // Lock on the uri to ensure that only one compile occurs for any script\n        synchronized (uri) {\n                // Get the URLConnection\n            URLConnection groovyScriptConn = pageUrl.openConnection();\n                // URL last modified\n            long lastModified = groovyScriptConn.getLastModified();\n                // Check the cache for the script\n            PageMeta pageMeta = (PageMeta)pageCache.get(uri);\n                // If the pageMeta isn't null check all the dependencies\n            boolean dependencyOutOfDate = false;\n            if (pageMeta != null && !spillGroovy) {\n                isPageNew(pageMeta);\n            }\n            if (pageMeta == null || pageMeta.lastModified < lastModified || dependencyOutOfDate || spillGroovy) {\n                pageMeta = newPage(uri, context,groovyScriptConn, lastModified, spillGroovy);\n            }\n            return pageMeta;\n        }\n    }","id":104525,"modified_method":"/**\n     * Lookup page class or load new one if needed.\n     * @param uri The URI of the page as a String\n     * @param pageUrl The URL instance of the page\n     * @param spillGroovy Whether to show the generated source\n     * @return The PageMeta instance of the page with info about the last modified date, the class and so on\n     *\n     * @throws IOException Thrown when there were problems reading the page or writing to the response\n     * @throws javax.servlet.ServletException\n     * @param context The ServletContext instance\n     *\n     */\n    protected PageMeta getPage(String uri, ServletContext context,URL pageUrl, boolean spillGroovy)\n            throws IOException, ServletException  {\n            // Lock on the uri to ensure that only one compile occurs for any script\n        synchronized (uri) {\n                // Get the URLConnection\n            URLConnection groovyScriptConn = pageUrl.openConnection();\n                // URL last modified\n            long lastModified = groovyScriptConn.getLastModified();\n                // Check the cache for the script\n            PageMeta pageMeta = (PageMeta)pageCache.get(uri);\n                // If the pageMeta isn't null check all the dependencies\n            boolean dependencyOutOfDate = false;\n            if (pageMeta != null && !spillGroovy) {\n                isPageNew(pageMeta);\n            }\n            if (pageMeta == null || pageMeta.lastModified < lastModified || dependencyOutOfDate || spillGroovy) {\n                pageMeta = newPage(uri, context,groovyScriptConn, lastModified, spillGroovy);\n            }\n            return pageMeta;\n        }\n    }","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Return the page URL from the request path.\n     * @param pageId\n     * @return\n     * @throws java.net.MalformedURLException\n     */\n    protected URL getPageUrl(ServletContext context, String pageId) throws MalformedURLException {\n        // Check to make sure that the file exists in the web application\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Loading GSP for url [\"+pageId+\"]\");\n        }\n        URL url = context.getResource(pageId);\n        if(url == null) {\n        \tStringBuffer buf = new StringBuffer();\n        \tString[] tokens;\n        \tif(pageId.startsWith(\"/\"))\n        \t\ttokens = pageId.substring(1).split(\"/\");\n        \telse\n        \t\ttokens = pageId.split(\"/\");\n        \t  \n        \tbuf.append(GrailsApplicationAttributes.PATH_TO_VIEWS);\n        \tbuf.append('/');\n        \tif(tokens.length > 0) {\n        \t\tbuf.append(tokens[0]);\n        \t\tbuf.append('/');\n        \t}\n        \tif(tokens.length > 1) {\n        \t\tbuf.append(tokens[1]);\n        \t}        \t\n        \tbuf.append(GrailsApplicationAttributes.GSP_FILE_EXTENSION);\n        \t\n        \tString secondTry = buf.toString();\n        \t\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Page [\"+pageId+\"] doesn't exist, trying [\"+secondTry+\"]\");\n            }        \t\n        \turl = context.getResource(secondTry);\n        }\n        return url;\n    }","id":104526,"modified_method":"/**\n     * Return the page URL from the request path.\n     * @param pageId  The page URI as a string\n     * @return  The java.net.URL of the page or null\n     * @throws java.net.MalformedURLException\n     * @param context The ServletContext instances\n     */\n    protected URL getPageUrl(ServletContext context, String pageId) throws MalformedURLException {\n        // Check to make sure that the file exists in the web application\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Loading GSP for url [\"+pageId+\"]\");\n        }\n        URL url = context.getResource(pageId);\n        if(url == null) {\n        \tStringBuffer buf = new StringBuffer();\n        \tString[] tokens;\n        \tif(pageId.startsWith(\"/\"))\n        \t\ttokens = pageId.substring(1).split(\"/\");\n        \telse\n        \t\ttokens = pageId.split(\"/\");\n        \t  \n        \tbuf.append(GrailsApplicationAttributes.PATH_TO_VIEWS);\n        \tbuf.append('/');\n        \tif(tokens.length > 0) {\n        \t\tbuf.append(tokens[0]);\n        \t\tbuf.append('/');\n        \t}\n        \tif(tokens.length > 1) {\n        \t\tbuf.append(tokens[1]);\n        \t}        \t\n        \tbuf.append(GrailsApplicationAttributes.GSP_FILE_EXTENSION);\n        \t\n        \tString secondTry = buf.toString();\n        \t\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Page [\"+pageId+\"] doesn't exist, trying [\"+secondTry+\"]\");\n            }        \t\n        \turl = context.getResource(secondTry);\n        }\n        return url;\n    }","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Return the page identifier.\n     * @param request\n     * @return The page id\n     */\n    protected String getPageId(HttpServletRequest request) {\n        // Get the name of the Groovy script (intern the name so that we can\n        // lock on it)\n        int contextLength = request.getContextPath().length();\n        return request.getRequestURI().substring(contextLength).intern();\n    }","id":104527,"modified_method":"/**\n     * Return the page identifier.\n     * @param request The HttpServletRequest instance\n     * @return The page id\n     */\n    protected String getPageId(HttpServletRequest request) {\n        // Get the name of the Groovy script (intern the name so that we can\n        // lock on it)\n        Object includePath = request.getAttribute(\"javax.servlet.include.servlet_path\");\n        if (includePath != null) {\n        \treturn ((String) includePath).intern();\n        } else {\n        \treturn request.getServletPath().intern();\n        }\n    }","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Create a template for the current request\n     *\n     * @param context\n     * @param request\n     * @param response\n     * @return  The created template or null if the page was not found\n     * @throws IOException\n     * @throws ServletException\n     */\n    public Template createTemplate(ServletContext context, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        ClassLoader parent = Thread.currentThread().getContextClassLoader();\n        if (parent == null) parent = getClass().getClassLoader();\n\n        String uri = getPageId(request);\n        return createTemplate(uri,context,request,response);\n    }","id":104528,"modified_method":"/**\n     * Create a template for the current request\n     *\n     * @param context  The ServletContext instance\n     * @param request   The HttpServletRequest instance\n     * @param response  The HttpServletResponse instance\n     * @return  The created template or null if the page was not found\n     * @throws IOException\n     * @throws ServletException\n     */\n    public Template createTemplate(ServletContext context, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String uri = getPageId(request);\n        return createTemplate(uri,context,request,response);\n    }","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Load and compile new page.\n     * @param uri\n     * @param groovyScriptConn\n     * @param lastModified\n     * @param spillGroovy\n     * @return\n     * @throws IOException\n     * @throws ServletException\n     */\n    private PageMeta newPage(String uri, ServletContext context,URLConnection groovyScriptConn, long lastModified,\n                             boolean spillGroovy) throws IOException, ServletException {\n        Parse parse = new Parse(uri, groovyScriptConn.getInputStream());\n        InputStream in = parse.parse();\n        // Make a new pageMeta\n        PageMeta pageMeta = new PageMeta();\n        pageMeta.contentType = parse.getContentType();\n        pageMeta.lineNumbers = parse.getLineNumberMatrix();\n\n            // just return groovy and don't compile if asked\n        if (spillGroovy) {\n        \tif(LOG.isDebugEnabled()){\n        \t\tLOG.debug(\"Show source enabled, display generated GSP source...\");\n        \t}\n            pageMeta.groovySource = in;\n            return pageMeta;\n        }\n            // Compile the script into an object\n\n        Loader loader = new Loader(classLoader, context, uri, pageMeta.dependencies);\n        Class scriptClass;\n        try {\n            scriptClass =\n                loader.parseClass(in, uri.substring(1));\n        } catch (CompilationFailedException e) {\n        \tLOG.error(\"Compilation error compiling GSP [\"+uri+\"]:\" + e.getMessage(), e);\n            throw new ServletException(\"Could not parse script: \" + uri, e);\n        }\n        pageMeta.servletScriptClass = scriptClass;\n        pageMeta.lastModified = lastModified;\n        pageCache.put(uri, pageMeta);\n        return pageMeta;\n    }","id":104529,"modified_method":"/**\n     * Creates a new PageMeta instance of the specified page URI\n     * @param uri The URI of the page as a String\n     * @param groovyScriptConn The URLConnection for the page\n     * @param lastModified The last time it was modified\n     * @param spillGroovy Whether to show the generated source\n     * @return The created PageMeta instance\n     * @throws IOException   Thrown when an error occurs reading or writing the page\n     * @throws ServletException\n    * @param context The ServletContext instance\n     */\n    private PageMeta newPage(String uri, ServletContext context,URLConnection groovyScriptConn, long lastModified,\n                             boolean spillGroovy) throws IOException, ServletException {\n        Parse parse = new Parse(uri, groovyScriptConn.getInputStream());\n        InputStream in = parse.parse();\n        // Make a new pageMeta\n        PageMeta pageMeta = new PageMeta();\n        pageMeta.contentType = parse.getContentType();\n        pageMeta.lineNumbers = parse.getLineNumberMatrix();\n\n            // just return groovy and don't compile if asked\n        if (spillGroovy) {\n        \tif(LOG.isDebugEnabled()){\n        \t\tLOG.debug(\"Show source enabled, display generated GSP source...\");\n        \t}\n            pageMeta.groovySource = in;\n            return pageMeta;\n        }\n            // Compile the script into an object\n\n        Loader loader = new Loader(classLoader, context, uri, pageMeta.dependencies);\n        Class scriptClass;\n        try {\n            scriptClass =\n                loader.parseClass(in, uri.substring(1));\n        } catch (CompilationFailedException e) {\n        \tLOG.error(\"Compilation error compiling GSP [\"+uri+\"]:\" + e.getMessage(), e);\n            throw new ServletException(\"Could not parse script: \" + uri, e);\n        }\n        pageMeta.servletScriptClass = scriptClass;\n        pageMeta.lastModified = lastModified;\n        pageCache.put(uri, pageMeta);\n        return pageMeta;\n    }","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"public ModelAndView handleResponse(HttpServletRequest request,\n\t\t\tHttpServletResponse response, String actionName, Map model) {\n\t\tif(scaffoldViewResolver == null)\n\t\t\tthrow new IllegalStateException(\"Property [viewResolver] is required to be set, but is null\");\n\t\t\n\t\t\n\t\treturn new ModelAndView(\n\t\t\t\tscaffoldViewResolver.resolveViewForUriAndAction(request.getRequestURI(), actionName), \n\t\t\t\t\tmodel );\n\t}","id":104530,"modified_method":"public ModelAndView handleResponse(HttpServletRequest request,\n\t\t\tHttpServletResponse response, String actionName, Map model) {\n\t\tif(scaffoldViewResolver == null)\n\t\t\tthrow new IllegalStateException(\"Property [viewResolver] is required to be set, but is null\");\n\t\t\n\t\t\n        Object includeUri = request.getAttribute(\"javax.servlet.include.request_uri\");\n        String uri;\n        if (includeUri != null) {\n        \turi = (String) includeUri;\n        } else {\n        \turi = request.getRequestURI();\n        }\n\t\treturn new ModelAndView(\n\t\t\t\tscaffoldViewResolver.resolveViewForUriAndAction(uri, actionName),\n\t\t\t\t\tmodel );\n\t}","commit_id":"8f437ade5e2fd07aeb51b071528e08fc29c1a205","url":"https://github.com/grails/grails-core"},{"original_method":"public void restorePreviousSync() {\n\t\t\tif (_sync != null) {\n\t\t\t\tProxyModeThreadLocal.setForceSync(_forceSync);\n\t\t\t}\n\t\t}","id":104531,"modified_method":"public void restorePreviousSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(_forceSync);\n\n\t\t\tif (_asyncServiceDestination != null) {\n\t\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\t\tmessageBus.replace(_asyncServiceDestination);\n\n\t\t\t\t_asyncServiceDestination = null;\n\t\t\t}\n\t\t}","commit_id":"447e796a83cd25f60bcd7c412b94caf4095739bf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void enableSync() {\n\t\t\tif (_sync != null) {\n\t\t\t\tProxyModeThreadLocal.setForceSync(true);\n\t\t\t}\n\t\t}","id":104532,"modified_method":"public void enableSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(true);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tDestination destination = messageBus.getDestination(\n\t\t\t\tDestinationNames.ASYNC_SERVICE);\n\n\t\t\tif (destination instanceof BaseAsyncDestination) {\n\t\t\t\t_asyncServiceDestination = destination;\n\n\t\t\t\tSynchronousDestination synchronousDestination =\n\t\t\t\t\tnew SynchronousDestination();\n\n\t\t\t\tsynchronousDestination.setName(DestinationNames.ASYNC_SERVICE);\n\n\t\t\t\tmessageBus.replace(synchronousDestination);\n\t\t\t}\n\t\t}","commit_id":"447e796a83cd25f60bcd7c412b94caf4095739bf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doReceive(Message message) throws Exception {\n\t\tRunnable runnable = (Runnable)message.getPayload();\n\n\t\trunnable.run();\n\t}","id":104533,"modified_method":"@Override\n\tprotected void doReceive(Message message) throws Exception {\n\t\tString responseDestinationName = message.getResponseDestinationName();\n\n\t\tRunnable runnable = (Runnable)message.getPayload();\n\n\t\ttry {\n\t\t\trunnable.run();\n\t\t}\n\t\tcatch (RuntimeException re) {\n\t\t\tif (Validator.isNotNull(responseDestinationName)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(re, re);\n\t\t\t\t}\n\t\t\t\telse if (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(re, re);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(responseDestinationName)) {\n\t\t\tMessage responseMessage = MessageBusUtil.createResponseMessage(\n\t\t\t\tmessage);\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tresponseDestinationName, responseMessage);\n\t\t}\n\t}","commit_id":"19355b290bacfef6c4ab1115f609d1b6f6497159","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void enableSync() {\n\t\t\tif (_sync != null) {\n\t\t\t\tProxyModeThreadLocal.setForceSync(true);\n\t\t\t}\n\t\t}","id":104534,"modified_method":"public void enableSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(true);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tif (messageBus.hasDestination(_TARGET_ASYNC_DESTINATION_NAME)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_oldAsyncDestination = (BaseDestination)messageBus.getDestination(\n\t\t\t\tDestinationNames.ASYNC_SERVICE);\n\n\t\t\tMessageBusUtil.addDestination(\n\t\t\t\tnew SynchronizedAsyncDestination(\n\t\t\t\t\t_TARGET_ASYNC_DESTINATION_NAME));\n\n\t\t\t_oldAsyncDestination.setName(_TARGET_ASYNC_DESTINATION_NAME);\n\n\t\t\tMessageBusUtil.addDestination(_oldAsyncDestination);\n\t\t}","commit_id":"19355b290bacfef6c4ab1115f609d1b6f6497159","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void restorePreviousSync() {\n\t\t\tif (_sync != null) {\n\t\t\t\tProxyModeThreadLocal.setForceSync(_forceSync);\n\t\t\t}\n\t\t}","id":104535,"modified_method":"public void restorePreviousSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(_forceSync);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tif ((_oldAsyncDestination == null) ||\n\t\t\t\t!messageBus.hasDestination(_TARGET_ASYNC_DESTINATION_NAME)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCollection<Destination> destinations = messageBus.getDestinations();\n\n\t\t\tdestinations.remove(_oldAsyncDestination);\n\n\t\t\tMessageBusUtil.removeDestination(DestinationNames.ASYNC_SERVICE);\n\n\t\t\t_oldAsyncDestination.setName(DestinationNames.ASYNC_SERVICE);\n\n\t\t\tMessageBusUtil.addDestination(_oldAsyncDestination);\n\t\t}","commit_id":"19355b290bacfef6c4ab1115f609d1b6f6497159","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void receive(Message message) {\n\t\tif (!message.getResponseId().equals(_responseId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\t_results = message.getPayload();\n\n\t\t\tnotify();\n\t\t}\n\t}","id":104536,"modified_method":"@Override\n\tpublic void receive(Message message) {\n\t\tif (!message.getResponseId().equals(_responseId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tif (message.getPayload() == null) {\n\t\t\t\t_results = _NULL_RESPONSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_results = message.getPayload();\n\t\t\t}\n\n\t\t\tnotify();\n\t\t}\n\t}","commit_id":"19355b290bacfef6c4ab1115f609d1b6f6497159","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object send() throws MessageBusException {\n\t\tString destinationName = _message.getDestinationName();\n\t\tString responseDestinationName = _message.getResponseDestinationName();\n\n\t\t_messageBus.registerMessageListener(responseDestinationName, this);\n\n\t\ttry {\n\t\t\tsynchronized (this) {\n\t\t\t\t_messageBus.sendMessage(destinationName, _message);\n\n\t\t\t\twait(_timeout);\n\n\t\t\t\tif (_results == null) {\n\t\t\t\t\tthrow new MessageBusException(\n\t\t\t\t\t\t\"No reply received for message: \" + _message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn _results;\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t\tthrow new MessageBusException(\n\t\t\t\t\"Message sending interrupted for: \" + _message, ie);\n\t\t}\n\t\tfinally {\n\t\t\t_messageBus.unregisterMessageListener(\n\t\t\t\tresponseDestinationName, this);\n\n\t\t\tEntityCacheUtil.clearLocalCache();\n\t\t\tFinderCacheUtil.clearLocalCache();\n\t\t\tThreadLocalCacheManager.destroy();\n\t\t}\n\t}","id":104537,"modified_method":"public Object send() throws MessageBusException {\n\t\tString destinationName = _message.getDestinationName();\n\t\tString responseDestinationName = _message.getResponseDestinationName();\n\n\t\t_messageBus.registerMessageListener(responseDestinationName, this);\n\n\t\ttry {\n\t\t\tsynchronized (this) {\n\t\t\t\t_messageBus.sendMessage(destinationName, _message);\n\n\t\t\t\twait(_timeout);\n\n\t\t\t\tif (_results == null) {\n\t\t\t\t\tthrow new MessageBusException(\n\t\t\t\t\t\t\"No reply received for message: \" + _message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_results == _NULL_RESPONSE) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn _results;\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t\tthrow new MessageBusException(\n\t\t\t\t\"Message sending interrupted for: \" + _message, ie);\n\t\t}\n\t\tfinally {\n\t\t\t_messageBus.unregisterMessageListener(\n\t\t\t\tresponseDestinationName, this);\n\n\t\t\tEntityCacheUtil.clearLocalCache();\n\t\t\tFinderCacheUtil.clearLocalCache();\n\t\t\tThreadLocalCacheManager.destroy();\n\t\t}\n\t}","commit_id":"19355b290bacfef6c4ab1115f609d1b6f6497159","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Id.Namespace.SYSTEM.getId(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    Futures.allAsList(\n      ImmutableList.of(\n        notificationService.start(),\n        schedulerService.start(),\n        applicationLifecycleService.start(),\n        systemArtifactLoader.start(),\n        programRuntimeService.start(),\n        streamCoordinatorClient.start(),\n        programLifecycleService.start(),\n        pluginService.start()\n      )\n    ).get();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          })));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n    defaultNamespaceEnsurer.startAndWait();\n  }","id":104538,"modified_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Id.Namespace.SYSTEM.getId(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    Futures.allAsList(\n      ImmutableList.of(\n        notificationService.start(),\n        schedulerService.start(),\n        applicationLifecycleService.start(),\n        systemArtifactLoader.start(),\n        programRuntimeService.start(),\n        streamCoordinatorClient.start(),\n        programLifecycleService.start(),\n        pluginService.start()\n      )\n    ).get();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setPort(configuration.getInt(Constants.AppFabric.SERVER_PORT))\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          })));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n    defaultNamespaceEnsurer.startAndWait();\n  }","commit_id":"e21f9943665104acd9b697ab4cc7a9d4a96b5179","url":"https://github.com/caskdata/cdap"},{"original_method":"@Provides\n    @Named(Constants.AppFabric.SERVER_ADDRESS)\n    @SuppressWarnings(\"unused\")\n    public InetAddress providesHostname(CConfiguration cConf) {\n      return Networks.resolve(cConf.get(Constants.AppFabric.SERVER_ADDRESS),\n                              new InetSocketAddress(\"localhost\", 0).getAddress());\n    }","id":104539,"modified_method":"@Provides\n    @Named(Constants.AppFabric.SERVER_ADDRESS)\n    @SuppressWarnings(\"unused\")\n    public InetAddress providesHostname(CConfiguration cConf) {\n      String address = cConf.get(Constants.AppFabric.SERVER_ADDRESS);\n      return Networks.resolve(address, new InetSocketAddress(\"localhost\", 0).getAddress());\n    }","commit_id":"e21f9943665104acd9b697ab4cc7a9d4a96b5179","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        DatasetTypeManager typeManager,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        Set<DatasetMetricsReporter> metricReporters,\n                        DatasetTypeService datasetTypeService,\n                        DatasetInstanceService datasetInstanceService,\n                        AuthorizationEnforcementService authorizationEnforcementService) throws Exception {\n    this.typeManager = typeManager;\n    this.authorizationEnforcementService = authorizationEnforcementService;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(datasetTypeService);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(datasetInstanceService);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler,\n                                             datasetInstanceHandler));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.metricReporters = metricReporters;\n  }","id":104540,"modified_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        DatasetTypeManager typeManager,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        Set<DatasetMetricsReporter> metricReporters,\n                        DatasetTypeService datasetTypeService,\n                        DatasetInstanceService datasetInstanceService,\n                        AuthorizationEnforcementService authorizationEnforcementService) throws Exception {\n    this.typeManager = typeManager;\n    this.authorizationEnforcementService = authorizationEnforcementService;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(datasetTypeService);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(datasetInstanceService);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler,\n                                             datasetInstanceHandler));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setPort(cConf.getInt(Constants.Dataset.Manager.PORT));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.metricReporters = metricReporters;\n  }","commit_id":"e21f9943665104acd9b697ab4cc7a9d4a96b5179","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting Metadata Service\");\n    httpService = new CommonNettyHttpServiceBuilder(cConf)\n      .addHttpHandlers(handlers)\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.METADATA_SERVICE)))\n      .setHost(cConf.get(Constants.Metadata.SERVICE_BIND_ADDRESS))\n      .setWorkerThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_WORKER_THREADS))\n      .setExecThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_EXEC_THREADS))\n      .setConnectionBacklog(20000)\n      .build();\n    httpService.addListener(new ServiceListenerAdapter() {\n      private Cancellable cancellable;\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"Metadata service running at {}\", socketAddress);\n        cancellable = discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n          @Override\n          public String getName() {\n            return Constants.Service.METADATA_SERVICE;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return socketAddress;\n          }\n        }));\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"Metadata HTTP service stopped\");\n        cancellable.cancel();\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"Metadata HTTP service stopped with failure.\", failure);\n        cancellable.cancel();\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","id":104541,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting Metadata Service\");\n    httpService = new CommonNettyHttpServiceBuilder(cConf)\n      .addHttpHandlers(handlers)\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.METADATA_SERVICE)))\n      .setHost(cConf.get(Constants.Metadata.SERVICE_BIND_ADDRESS))\n      .setPort(cConf.getInt(Constants.Metadata.SERVICE_BIND_PORT))\n      .setWorkerThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_WORKER_THREADS))\n      .setExecThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_EXEC_THREADS))\n      .setConnectionBacklog(20000)\n      .build();\n    httpService.addListener(new ServiceListenerAdapter() {\n      private Cancellable cancellable;\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"Metadata service running at {}\", socketAddress);\n        cancellable = discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n          @Override\n          public String getName() {\n            return Constants.Service.METADATA_SERVICE;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return socketAddress;\n          }\n        }));\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"Metadata HTTP service stopped\");\n        cancellable.cancel();\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"Metadata HTTP service stopped with failure.\", failure);\n        cancellable.cancel();\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","commit_id":"e21f9943665104acd9b697ab4cc7a9d4a96b5179","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Id.Namespace.SYSTEM.getId(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    Futures.allAsList(\n      ImmutableList.of(\n        notificationService.start(),\n        schedulerService.start(),\n        applicationLifecycleService.start(),\n        systemArtifactLoader.start(),\n        programRuntimeService.start(),\n        streamCoordinatorClient.start(),\n        programLifecycleService.start(),\n        pluginService.start(),\n        privilegesFetcherProxyService.start()\n      )\n    ).get();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          })));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n    defaultNamespaceEnsurer.startAndWait();\n  }","id":104542,"modified_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Id.Namespace.SYSTEM.getId(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    Futures.allAsList(\n      ImmutableList.of(\n        notificationService.start(),\n        schedulerService.start(),\n        applicationLifecycleService.start(),\n        systemArtifactLoader.start(),\n        programRuntimeService.start(),\n        streamCoordinatorClient.start(),\n        programLifecycleService.start(),\n        pluginService.start(),\n        privilegesFetcherProxyService.start()\n      )\n    ).get();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setPort(configuration.getInt(Constants.AppFabric.SERVER_PORT))\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          })));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n    defaultNamespaceEnsurer.startAndWait();\n  }","commit_id":"1894720593bf6e97ef2441aa9c15aaa2974a4668","url":"https://github.com/caskdata/cdap"},{"original_method":"@Provides\n    @Named(Constants.AppFabric.SERVER_ADDRESS)\n    @SuppressWarnings(\"unused\")\n    public InetAddress providesHostname(CConfiguration cConf) {\n      return Networks.resolve(cConf.get(Constants.AppFabric.SERVER_ADDRESS),\n                              new InetSocketAddress(\"localhost\", 0).getAddress());\n    }","id":104543,"modified_method":"@Provides\n    @Named(Constants.AppFabric.SERVER_ADDRESS)\n    @SuppressWarnings(\"unused\")\n    public InetAddress providesHostname(CConfiguration cConf) {\n      String address = cConf.get(Constants.AppFabric.SERVER_ADDRESS);\n      return Networks.resolve(address, new InetSocketAddress(\"localhost\", 0).getAddress());\n    }","commit_id":"1894720593bf6e97ef2441aa9c15aaa2974a4668","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        Set<DatasetMetricsReporter> metricReporters,\n                        DatasetTypeService datasetTypeService,\n                        DatasetInstanceService datasetInstanceService) throws Exception {\n    this.typeService = datasetTypeService;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(datasetTypeService);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(datasetInstanceService);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler,\n                                             datasetInstanceHandler));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.metricReporters = metricReporters;\n  }","id":104544,"modified_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        Set<DatasetMetricsReporter> metricReporters,\n                        DatasetTypeService datasetTypeService,\n                        DatasetInstanceService datasetInstanceService) throws Exception {\n    this.typeService = datasetTypeService;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(datasetTypeService);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(datasetInstanceService);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler,\n                                             datasetInstanceHandler));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setPort(cConf.getInt(Constants.Dataset.Manager.PORT));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.metricReporters = metricReporters;\n  }","commit_id":"1894720593bf6e97ef2441aa9c15aaa2974a4668","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting Metadata Service\");\n    httpService = new CommonNettyHttpServiceBuilder(cConf)\n      .addHttpHandlers(handlers)\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.METADATA_SERVICE)))\n      .setHost(cConf.get(Constants.Metadata.SERVICE_BIND_ADDRESS))\n      .setWorkerThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_WORKER_THREADS))\n      .setExecThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_EXEC_THREADS))\n      .setConnectionBacklog(20000)\n      .build();\n    httpService.addListener(new ServiceListenerAdapter() {\n      private Cancellable cancellable;\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"Metadata service running at {}\", socketAddress);\n        cancellable = discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n          @Override\n          public String getName() {\n            return Constants.Service.METADATA_SERVICE;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return socketAddress;\n          }\n        }));\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"Metadata HTTP service stopped\");\n        cancellable.cancel();\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"Metadata HTTP service stopped with failure.\", failure);\n        cancellable.cancel();\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","id":104545,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting Metadata Service\");\n    httpService = new CommonNettyHttpServiceBuilder(cConf)\n      .addHttpHandlers(handlers)\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.METADATA_SERVICE)))\n      .setHost(cConf.get(Constants.Metadata.SERVICE_BIND_ADDRESS))\n      .setPort(cConf.getInt(Constants.Metadata.SERVICE_BIND_PORT))\n      .setWorkerThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_WORKER_THREADS))\n      .setExecThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_EXEC_THREADS))\n      .setConnectionBacklog(20000)\n      .build();\n    httpService.addListener(new ServiceListenerAdapter() {\n      private Cancellable cancellable;\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"Metadata service running at {}\", socketAddress);\n        cancellable = discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n          @Override\n          public String getName() {\n            return Constants.Service.METADATA_SERVICE;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return socketAddress;\n          }\n        }));\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"Metadata HTTP service stopped\");\n        cancellable.cancel();\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"Metadata HTTP service stopped with failure.\", failure);\n        cancellable.cancel();\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","commit_id":"1894720593bf6e97ef2441aa9c15aaa2974a4668","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Id.Namespace.SYSTEM.getId(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    Futures.allAsList(\n      ImmutableList.of(\n        notificationService.start(),\n        schedulerService.start(),\n        applicationLifecycleService.start(),\n        systemArtifactLoader.start(),\n        programRuntimeService.start(),\n        streamCoordinatorClient.start(),\n        programLifecycleService.start(),\n        pluginService.start()\n      )\n    ).get();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          })));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n    defaultNamespaceEnsurer.startAndWait();\n  }","id":104546,"modified_method":"/**\n   * Configures the AppFabricService pre-start.\n   */\n  @Override\n  protected void startUp() throws Exception {\n    LoggingContextAccessor.setLoggingContext(new ServiceLoggingContext(Id.Namespace.SYSTEM.getId(),\n                                                                       Constants.Logging.COMPONENT_NAME,\n                                                                       Constants.Service.APP_FABRIC_HTTP));\n    Futures.allAsList(\n      ImmutableList.of(\n        notificationService.start(),\n        schedulerService.start(),\n        applicationLifecycleService.start(),\n        systemArtifactLoader.start(),\n        programRuntimeService.start(),\n        streamCoordinatorClient.start(),\n        programLifecycleService.start(),\n        pluginService.start()\n      )\n    ).get();\n\n    // Create handler hooks\n    ImmutableList.Builder<HandlerHook> builder = ImmutableList.builder();\n    for (String hook : handlerHookNames) {\n      builder.add(new MetricsReporterHook(metricsCollectionService, hook));\n    }\n\n    // Run http service on random port\n    httpService = new CommonNettyHttpServiceBuilder(configuration)\n      .setHost(hostname.getCanonicalHostName())\n      .setPort(configuration.getInt(Constants.AppFabric.SERVER_PORT))\n      .setHandlerHooks(builder.build())\n      .addHttpHandlers(handlers)\n      .setConnectionBacklog(configuration.getInt(Constants.AppFabric.BACKLOG_CONNECTIONS,\n                                                 Constants.AppFabric.DEFAULT_BACKLOG))\n      .setExecThreadPoolSize(configuration.getInt(Constants.AppFabric.EXEC_THREADS,\n                                                  Constants.AppFabric.DEFAULT_EXEC_THREADS))\n      .setBossThreadPoolSize(configuration.getInt(Constants.AppFabric.BOSS_THREADS,\n                                                  Constants.AppFabric.DEFAULT_BOSS_THREADS))\n      .setWorkerThreadPoolSize(configuration.getInt(Constants.AppFabric.WORKER_THREADS,\n                                                    Constants.AppFabric.DEFAULT_WORKER_THREADS))\n      .build();\n\n    // Add a listener so that when the service started, register with service discovery.\n    // Remove from service discovery when it is stopped.\n    httpService.addListener(new ServiceListenerAdapter() {\n\n      private List<Cancellable> cancellables = Lists.newArrayList();\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"AppFabric HTTP Service started at {}\", socketAddress);\n\n        // TODO accept a list of services, and start them here\n        // When it is running, register it with service discovery\n        for (final String serviceName : servicesNames) {\n          cancellables.add(discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n            @Override\n            public String getName() {\n              return serviceName;\n            }\n\n            @Override\n            public InetSocketAddress getSocketAddress() {\n              return socketAddress;\n            }\n          })));\n        }\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"AppFabric HTTP service stopped.\");\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"AppFabric HTTP service stopped with failure.\", failure);\n        for (Cancellable cancellable : cancellables) {\n          if (cancellable != null) {\n            cancellable.cancel();\n          }\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n    defaultNamespaceEnsurer.startAndWait();\n  }","commit_id":"32fdba079d7bee3d747a9734763cc980fabf248e","url":"https://github.com/caskdata/cdap"},{"original_method":"@Provides\n    @Named(Constants.AppFabric.SERVER_ADDRESS)\n    @SuppressWarnings(\"unused\")\n    public InetAddress providesHostname(CConfiguration cConf) {\n      return Networks.resolve(cConf.get(Constants.AppFabric.SERVER_ADDRESS),\n                              new InetSocketAddress(\"localhost\", 0).getAddress());\n    }","id":104547,"modified_method":"@Provides\n    @Named(Constants.AppFabric.SERVER_ADDRESS)\n    @SuppressWarnings(\"unused\")\n    public InetAddress providesHostname(CConfiguration cConf) {\n      String address = cConf.get(Constants.AppFabric.SERVER_ADDRESS);\n      return Networks.resolve(address, new InetSocketAddress(\"localhost\", 0).getAddress());\n    }","commit_id":"32fdba079d7bee3d747a9734763cc980fabf248e","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        NamespacedLocationFactory namespacedLocationFactory,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        DatasetTypeManager typeManager,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        Set<DatasetMetricsReporter> metricReporters,\n                        DatasetInstanceService datasetInstanceService,\n                        NamespaceQueryAdmin namespaceQueryAdmin) throws Exception {\n\n    this.typeManager = typeManager;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(typeManager, cConf, namespacedLocationFactory,\n                                                                   namespaceQueryAdmin);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(datasetInstanceService);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler,\n                                             datasetInstanceHandler));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.metricReporters = metricReporters;\n  }","id":104548,"modified_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        NamespacedLocationFactory namespacedLocationFactory,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        DatasetTypeManager typeManager,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        Set<DatasetMetricsReporter> metricReporters,\n                        DatasetInstanceService datasetInstanceService,\n                        NamespaceQueryAdmin namespaceQueryAdmin) throws Exception {\n\n    this.typeManager = typeManager;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(typeManager, cConf, namespacedLocationFactory,\n                                                                   namespaceQueryAdmin);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(datasetInstanceService);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler,\n                                             datasetInstanceHandler));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setPort(cConf.getInt(Constants.Dataset.Manager.PORT));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.metricReporters = metricReporters;\n  }","commit_id":"32fdba079d7bee3d747a9734763cc980fabf248e","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting Metadata Service\");\n    httpService = new CommonNettyHttpServiceBuilder(cConf)\n      .addHttpHandlers(handlers)\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.METADATA_SERVICE)))\n      .setHost(cConf.get(Constants.Metadata.SERVICE_BIND_ADDRESS))\n      .setWorkerThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_WORKER_THREADS))\n      .setExecThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_EXEC_THREADS))\n      .setConnectionBacklog(20000)\n      .build();\n    httpService.addListener(new ServiceListenerAdapter() {\n      private Cancellable cancellable;\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"Metadata service running at {}\", socketAddress);\n        cancellable = discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n          @Override\n          public String getName() {\n            return Constants.Service.METADATA_SERVICE;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return socketAddress;\n          }\n        }));\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"Metadata HTTP service stopped\");\n        cancellable.cancel();\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"Metadata HTTP service stopped with failure.\", failure);\n        cancellable.cancel();\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","id":104549,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting Metadata Service\");\n    httpService = new CommonNettyHttpServiceBuilder(cConf)\n      .addHttpHandlers(handlers)\n      .setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                Constants.Service.METADATA_SERVICE)))\n      .setHost(cConf.get(Constants.Metadata.SERVICE_BIND_ADDRESS))\n      .setPort(cConf.getInt(Constants.Metadata.SERVICE_BIND_PORT))\n      .setWorkerThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_WORKER_THREADS))\n      .setExecThreadPoolSize(cConf.getInt(Constants.Metadata.SERVICE_EXEC_THREADS))\n      .setConnectionBacklog(20000)\n      .build();\n    httpService.addListener(new ServiceListenerAdapter() {\n      private Cancellable cancellable;\n\n      @Override\n      public void running() {\n        final InetSocketAddress socketAddress = httpService.getBindAddress();\n        LOG.info(\"Metadata service running at {}\", socketAddress);\n        cancellable = discoveryService.register(ResolvingDiscoverable.of(new Discoverable() {\n          @Override\n          public String getName() {\n            return Constants.Service.METADATA_SERVICE;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return socketAddress;\n          }\n        }));\n      }\n\n      @Override\n      public void terminated(State from) {\n        LOG.info(\"Metadata HTTP service stopped\");\n        cancellable.cancel();\n      }\n\n      @Override\n      public void failed(State from, Throwable failure) {\n        LOG.info(\"Metadata HTTP service stopped with failure.\", failure);\n        cancellable.cancel();\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    httpService.startAndWait();\n  }","commit_id":"32fdba079d7bee3d747a9734763cc980fabf248e","url":"https://github.com/caskdata/cdap"},{"original_method":"public BooleanClass() {\n        this(null);\n    }","id":104550,"modified_method":"public BooleanClass() {\n        this(null);\n        setDisplayFormType(\"select\");\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n        if (getDisplayType().equals(\"checkbox\")) {\n            displayCheckboxEdit(buffer, name, prefix, object, context);\n        } else {\n            displaySelectEdit(buffer, name, prefix, object, context);\n        }\n    }","id":104551,"modified_method":"public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n        String displayFormType = getDisplayFormType();\n\n        if (getDisplayType().equals(\"checkbox\")) {\n         displayFormType = \"checkbox\";\n       }\n\n        if (displayFormType.equals(\"checkbox\")) {\n            displayCheckboxEdit(buffer, name, prefix, object, context);\n        } else if (displayFormType.equals(\"select\")) {\n            displaySelectEdit(buffer, name, prefix, object, context);\n        } else {\n            displayRadioEdit(buffer, name, prefix, object, context);\n        }\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void displaySelectEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n        select select = new select(prefix + name, 1);\n        String String0 = getDisplayValue(context, 0);\n        String String1 = getDisplayValue(context, 1);\n\n        option[] options = { new option(\"---\", \"\"), new option(String1, \"1\"), new option(String0, \"0\") };\n        options[0].addElement(\"---\");\n        options[1].addElement(String1);\n        options[2].addElement(String0);\n\n        try {\n            IntegerProperty prop = (IntegerProperty) object.safeget(name);\n            if (prop != null) {\n                Integer ivalue = (Integer) prop.getValue();\n                if (ivalue != null) {\n                    int value = ivalue.intValue();\n                    if (value == 1)\n                        options[1].setSelected(true);\n                    else if (value == 0)\n                        options[2].setSelected(true);\n                } else {\n                    int value = getDefaultValue();\n                    if (value == 1)\n                        options[1].setSelected(true);\n                    else if (value == 0)\n                        options[2].setSelected(true);\n                }\n            }\n        } catch (Exception e) {\n            // This should not happen\n            e.printStackTrace();\n        }\n        select.addElement(options);\n        buffer.append(select.toString());\n    }","id":104552,"modified_method":"public void displaySelectEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n        select select = new select(prefix + name, 1);\n        String String0 = getDisplayValue(context, 0);\n        String String1 = getDisplayValue(context, 1);\n        int nb1 = 1;\n        int nb2 = 2;\n\n\n        option[] options;\n\n        if (getDefaultValue()==-1) {\n            options = new option[] { new option(\"---\", \"\"), new option(String1, \"1\"), new option(String0, \"0\") };\n            options[0].addElement(\"---\");\n            options[1].addElement(String1);\n            options[2].addElement(String0);\n        } else {\n            options = new option[] { new option(String1, \"1\"), new option(String0, \"0\") };\n            options[0].addElement(String1);\n            options[1].addElement(String0);\n            nb1 = 0;\n            nb2 = 1;\n        }\n\n        try {\n            IntegerProperty prop = (IntegerProperty) object.safeget(name);\n            Integer ivalue = (prop==null) ? null : (Integer) prop.getValue();\n                if (ivalue != null) {\n                    int value = ivalue.intValue();\n                    if (value == 1)\n                        options[nb1].setSelected(true);\n                    else if (value == 0)\n                        options[nb2].setSelected(true);\n                } else {\n                    int value = getDefaultValue();\n                    if (value == 1)\n                        options[nb1].setSelected(true);\n                    else if (value == 0)\n                        options[nb2].setSelected(true);\n                    else if (value == -1) {\n                        options[0].setSelected(true);\n                    }\n                }\n        } catch (Exception e) {\n            // This should not happen\n            e.printStackTrace();\n        }\n        select.addElement(options);\n        buffer.append(select.toString());\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getDisplayValue(XWikiContext context, int value) {\n        try {\n            XWikiMessageTool msg = (XWikiMessageTool) context.get(\"msg\");\n            String strname = getDisplayType() + \"_\" + value;\n            String result = msg.get(strname);\n            if (result.equals(strname)) {\n                return \"\" + value;\n            }\n            return result;\n        } catch (Exception e) {\n            return \"\" + value;\n        }\n    }","id":104553,"modified_method":"private String getDisplayValue(XWikiContext context, int value) {\n        try {\n            XWikiMessageTool msg = (XWikiMessageTool) context.get(\"msg\");\n            String strname = getDisplayType() + \"_\" + value;\n            String result = msg.get(strname);\n            if (result.equals(strname)) {\n                if (value==2)\n                 return \"---\";\n                else\n                 return \"\" + value;\n            }\n            return result;\n        } catch (Exception e) {\n            return \"\" + value;\n        }\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public BooleanMetaClass() {\r\n        super();\r\n        setPrettyName(\"Boolean Class\");\r\n        setName(BooleanClass.class.getName());\r\n\r\n        StringClass type_class = new StringClass(this);\r\n        type_class.setName(\"displayType\");\r\n        type_class.setPrettyName(\"Display Type\");\r\n        type_class.setSize(20);\r\n        safeput(\"displayType\", type_class);\r\n\r\n        NumberClass default_value_class = new NumberClass(this);\r\n        default_value_class.setName(\"defaultValue\");\r\n        default_value_class.setPrettyName(\"Default Value\");\r\n        default_value_class.setSize(5);\r\n        default_value_class.setClassType(\"integer\");\r\n        safeput(\"defaultValue\", default_value_class);\r\n    }","id":104554,"modified_method":"public BooleanMetaClass() {\r\n        super();\r\n        setPrettyName(\"Boolean Class\");\r\n        setName(BooleanClass.class.getName());\r\n\r\n        StaticListClass type_class = new StaticListClass(this);\r\n        type_class.setName(\"displayFormType\");\r\n        type_class.setPrettyName(\"Display Form Type\");\r\n        type_class.setValues(\"radio|checkbox|select\");\r\n        safeput(\"displayFormType\", type_class);\r\n        \r\n        StringClass value_class = new StringClass(this);\r\n        value_class.setName(\"displayType\");\r\n        value_class.setPrettyName(\"Display Type\");\r\n        value_class.setSize(20);\r\n        safeput(\"displayType\", value_class);\r\n\r\n        NumberClass default_value_class = new NumberClass(this);\r\n        default_value_class.setName(\"defaultValue\");\r\n        default_value_class.setPrettyName(\"Default Value\");\r\n        default_value_class.setSize(5);\r\n        default_value_class.setClassType(\"integer\");\r\n        safeput(\"defaultValue\", default_value_class);\r\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n\t\tif (getDisplayType().equals(\"input\")) {\n\t\t\tinput input = new input();\n\t\t\tBaseProperty prop = (BaseProperty) object.safeget(name);\n\t\t\tif (prop != null)\n\t\t\t\tinput.setValue(prop.toFormString());\n\t\t\tinput.setType(\"text\");\n\t\t\tinput.setSize(getSize());\n\t\t\tinput.setName(prefix + name);\n\t\t\tinput.setID(prefix + name);\n\t\t\tbuffer.append(input.toString());\n\t\t} else if (getDisplayType().equals(\"radio\")||getDisplayType().equals(\"checkbox\")) {\n\t\t\tdisplayRadioEdit(buffer, name, prefix, object, context);\n\t\t} else {\n\t\t\tdisplaySelectEdit(buffer, name, prefix, object, context);\n\t\t}\n\t}","id":104555,"modified_method":"public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n\t\tif (getDisplayType().equals(\"input\")) {\n\t\t\tinput input = new input();\n\t\t\tBaseProperty prop = (BaseProperty) object.safeget(name);\n\t\t\tif (prop != null)\n\t\t\t\tinput.setValue(prop.toFormString());\n\t\t\tinput.setType(\"text\");\n\t\t\tinput.setSize(getSize());\n\t\t\tinput.setName(prefix + name);\n\t\t\tinput.setID(prefix + name);\n\t\t\tbuffer.append(input.toString());\n\t\t} else if (getDisplayType().equals(\"radio\")||getDisplayType().equals(\"checkbox\")) {\n\t\t\tdisplayRadioEdit(buffer, name, prefix, object, context);\n\t\t} else {\n\t\t\tdisplaySelectEdit(buffer, name, prefix, object, context);\n\t\t}\n\n        org.apache.ecs.xhtml.input hidden = new input(input.hidden, prefix + name, \"\");\n        buffer.append(hidden);\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void displayRadioEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n\t\tList list = getList(context);\n        Map map = getMap(context);\n\t\tList selectlist;\n\n\t\tBaseProperty prop = (BaseProperty) object.safeget(name);\n\t\tif (prop == null) {\n\t\t\tselectlist = new ArrayList();\n\t\t} else if ((prop instanceof ListProperty) || (prop instanceof DBStringListProperty)) {\n\t\t\tselectlist = (List) prop.getValue();\n\t\t} else {\n\t\t\tselectlist = new ArrayList();\n\t\t\tselectlist.add(prop.getValue());\n\t\t}\n\n\t\t// Add options from Set\n\t\tfor (Iterator it = list.iterator(); it.hasNext();) {\n\t\t\tString value = it.next().toString();\n\t\t\tinput radio = new input(getDisplayType().equals(\"radio\") ? input.radio : input.checkbox, prefix + name, value);\n\n\t\t\tif (selectlist.contains(value))\n\t\t\t\tradio.setChecked(true);\n\t\t\tradio.addElement(getDisplayValue(value, map, context));\n            buffer.append(radio.toString());\n\t\t\tif (it.hasNext()) {\n\t\t\t\tbuffer.append(\"<br/>\");\n\t\t\t}\n\t\t}\n\t}","id":104556,"modified_method":"protected void displayRadioEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context) {\n\t\tList list = getList(context);\n        Map map = getMap(context);\n\t\tList selectlist;\n\n\t\tBaseProperty prop = (BaseProperty) object.safeget(name);\n\t\tif (prop == null) {\n\t\t\tselectlist = new ArrayList();\n\t\t} else if ((prop instanceof ListProperty) || (prop instanceof DBStringListProperty)) {\n\t\t\tselectlist = (List) prop.getValue();\n\t\t} else {\n\t\t\tselectlist = new ArrayList();\n\t\t\tselectlist.add(prop.getValue());\n\t\t}\n\n\t\t// Add options from Set\n\t\tfor (Iterator it = list.iterator(); it.hasNext();) {\n\t\t\tString value = it.next().toString();\n\t\t\tinput radio = new input((getDisplayType().equals(\"radio\")&&isMultiSelect()) ? input.radio : input.checkbox, prefix + name, value);\n\n\t\t\tif (selectlist.contains(value))\n\t\t\t\tradio.setChecked(true);\n\t\t\tradio.addElement(getDisplayValue(value, map, context));\n\n            buffer.append(\"<span class=\\\"xwiki-form-listclass\\\" id=\\\"xwiki-form-\" + name + \"\\\">\");\n            buffer.append(radio.toString());\n            buffer.append(\"<\/span>\");\n\t\t}\n\n        org.apache.ecs.xhtml.input hidden = new input(input.hidden, prefix + name, \"\");\n        buffer.append(hidden);\n    }","commit_id":"f98d852f69a06219e2bcebaca68158a18d6782a0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DateClass()\n    {\n        this(null);\n    }","id":104557,"modified_method":"/**\n     * Default constructor.\n     */\n    public DateClass()\n    {\n        this(null);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getPicker()\n    {\n        return getIntValue(\"picker\");\n    }","id":104558,"modified_method":"/**\n     * @return {@code 1} if a date picker should be used to choose the date, {@code 0} otherwise\n     */\n    public int getPicker()\n    {\n        return getIntValue(META_PROPERTY_PICKER);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public BaseProperty newPropertyfromXML(Element ppcel)\n    {\n        String value = ppcel.getText();\n        BaseProperty property = newProperty();\n\n        if (StringUtils.isEmpty(value)) {\n            return property;\n        }\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n        try {\n            property.setValue(sdf.parse(value));\n        } catch (ParseException e) {\n            SimpleDateFormat sdf2 = new SimpleDateFormat(\"EEE MMM d HH:mm:ss z yyyy\", Locale.US);\n            try {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\"Failed to parse date [\" + value + \"] using format [\"\n                        + sdf.toString() + \"]. Trying again with format [\"\n                        + sdf2.toString() + \"]\");\n                }\n                property.setValue(sdf2.parse(value));\n            } catch (ParseException e2) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\"Failed to parse date [\" + value + \"] using format [\"\n                        + sdf2.toString() + \"]. Defaulting to the current date.\");\n                }\n                property.setValue(new Date());\n            }\n        }\n        return property;\n    }","id":104559,"modified_method":"/**\n     * {@inheritDoc}\n     * <p>\n     * We have to overwrite this method because the value of a date property is not serialized using the date format\n     * specified in the XClass nor the time stamp but a custom hard-coded date format.. Changing this now will break\n     * existing XARs..\n     */\n    @Override\n    public BaseProperty newPropertyfromXML(Element element)\n    {\n        String value = element.getText();\n        BaseProperty property = newProperty();\n\n        if (StringUtils.isEmpty(value)) {\n            return property;\n        }\n\n        // FIXME: The value of a date property should be serialized using the date timestamp or the date format\n        // specified in the XClass the date property belongs to.\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n        try {\n            property.setValue(sdf.parse(value));\n        } catch (ParseException e) {\n            // I suppose this is a date format used a long time ago. DateProperty is using the above date format now.\n            SimpleDateFormat sdfOld = new SimpleDateFormat(\"EEE MMM d HH:mm:ss z yyyy\", Locale.US);\n            LOGGER.warn(\"Failed to parse date [{}] using format [{}]. Trying again with format [{}].\", value,\n                sdf.toString(), sdfOld.toString());\n            try {\n                property.setValue(sdfOld.parse(value));\n            } catch (ParseException exception) {\n                LOGGER.warn(\"Failed to parse date [{}] using format [{}]. Defaulting to the current date.\", value,\n                    sdfOld.toString());\n                property.setValue(new Date());\n            }\n        }\n        return property;\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getEmptyIsToday()\n    {\n        return getIntValue(\"emptyIsToday\");\n    }","id":104560,"modified_method":"/**\n     * @return {@code 1} if an empty date value represents the current date, {@code 0} otherwise\n     */\n    public int getEmptyIsToday()\n    {\n        return getIntValue(META_PROPERTY_EMPTY_IS_TODAY);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setEmptyIsToday(int emptyIsToday)\n    {\n        setIntValue(\"emptyIsToday\", emptyIsToday);\n    }","id":104561,"modified_method":"/**\n     * Sets whether an empty date value represents the current date or not.\n     * \n     * @param emptyIsToday {@code 1} if an empty date value should represent the current date, {@code 0} otherwise\n     */\n    public void setEmptyIsToday(int emptyIsToday)\n    {\n        setIntValue(META_PROPERTY_EMPTY_IS_TODAY, emptyIsToday);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setSize(int size)\n    {\n        setIntValue(\"size\", size);\n    }","id":104562,"modified_method":"/**\n     * Sets the size of the date input in edit mode.\n     * \n     * @param size the size of the date input in edit mode\n     */\n    public void setSize(int size)\n    {\n        setIntValue(META_PROPERTY_SIZE, size);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setPicker(int picker)\n    {\n        setIntValue(\"picker\", picker);\n    }","id":104563,"modified_method":"/**\n     * Sets whether to use a date picker or not to select the date in edit mode.\n     * \n     * @param picker {@code 1} to use a date picker, {@code 0} otherwise\n     */\n    public void setPicker(int picker)\n    {\n        setIntValue(META_PROPERTY_PICKER, picker);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context)\n    {\n        input input = new input();\n\n        BaseProperty prop = (BaseProperty) object.safeget(name);\n        if (prop != null) {\n            input.setValue(toFormString(prop));\n        }\n\n        input.setType(\"text\");\n        input.setName(prefix + name);\n        input.setID(prefix + name);\n        input.setSize(getSize());\n        input.setDisabled(isDisabled());\n        buffer.append(input.toString());\n    }","id":104564,"modified_method":"@Override\n    public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object,\n        XWikiContext context)\n    {\n        input input = new input();\n\n        BaseProperty prop = (BaseProperty) object.safeget(name);\n        String styleName = \"datetime\";\n        if (prop != null) {\n            input.setValue(toFormString(prop));\n            // This is useful if the client doesn't understand the date format.\n            styleName += \" t\" + ((Date) prop.getValue()).getTime();\n        }\n\n        input.setType(\"text\");\n        input.setName(prefix + name);\n        input.setID(prefix + name);\n        input.setSize(getSize());\n        input.setDisabled(isDisabled());\n\n        if (getPicker() == 1) {\n            // Mark the date input so that it can be enhanced with a date picker.\n            input.setClass(styleName);\n            // Pass the date format to the client in the title attribute.\n            input.setTitle(getDateFormat());\n            // Pull the resources needed by the date picker.\n            String basePath = \"uicomponents/widgets/datepicker/\";\n            Map<String, Object> parameters = Collections.singletonMap(\"forceSkinAction\", (Object) true);\n            SkinExtension ssfx = Utils.getComponent(SkinExtension.class, \"ssfx\");\n            ssfx.use(basePath + \"calendarDateSelect.css\", parameters);\n            SkinExtension jsfx = Utils.getComponent(SkinExtension.class, \"jsfx\");\n            // A simple date picker widget.\n            jsfx.use(basePath + \"calendarDateSelect.js\", parameters);\n            // Used to parse and serialize the selected date using the date format specified in the XClass.\n            jsfx.use(basePath + \"simpleDateFormat.js\", parameters);\n            // A wrapper over the CalendarDateSelect widget that uses the SimpleDateFormat to parse/serialize the dates.\n            jsfx.use(basePath + \"dateTimePicker.js\");\n        }\n\n        buffer.append(input.toString());\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String toFormString(BaseProperty property)\n    {\n        if (property.getValue() == null) {\n            return \"\";\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat());\n        return sdf.format(property.getValue());\n    }","id":104565,"modified_method":"/**\n     * @param property a date property\n     * @return the value of the given date property serialized using the {@link #getDateFormat()} format\n     */\n    public String toFormString(BaseProperty property)\n    {\n        return property.getValue() == null ? \"\" : new SimpleDateFormat(getDateFormat()).format(property.getValue());\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void displayView(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context)\n    {\n        BaseProperty prop = (BaseProperty) object.safeget(name);\n        if (prop != null) {\n            buffer.append(toFormString(prop));\n        }\n    }","id":104566,"modified_method":"@Override\n    public void displayView(StringBuffer buffer, String name, String prefix, BaseCollection object,\n        XWikiContext context)\n    {\n        BaseProperty property = (BaseProperty) object.safeget(name);\n        if (property != null) {\n            buffer.append(toFormString(property));\n        }\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setDateFormat(String dformat)\n    {\n        setStringValue(\"dateFormat\", dformat);\n    }","id":104567,"modified_method":"/**\n     * Sets the date format.\n     * \n     * @param format the new date format\n     */\n    public void setDateFormat(String format)\n    {\n        setStringValue(META_PROPERTY_DATE_FORMAT, format);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DateClass(PropertyMetaClass wclass)\n    {\n        super(XCLASSNAME, \"Date\", wclass);\n        setSize(20);\n        setDateFormat(\"dd/MM/yyyy HH:mm:ss\");\n        setEmptyIsToday(1);\n        setPicker(1);\n    }","id":104568,"modified_method":"/**\n     * Creates a new Date property that is described by the given meta class.\n     * \n     * @param metaClass the meta class that defines the list of meta properties associated with this property type\n     */\n    public DateClass(PropertyMetaClass metaClass)\n    {\n        super(\"date\", \"Date\", metaClass);\n\n        setSize(20);\n        setDateFormat(\"dd/MM/yyyy HH:mm:ss\");\n        setEmptyIsToday(1);\n        setPicker(1);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getSize()\n    {\n        return getIntValue(\"size\");\n    }","id":104569,"modified_method":"/**\n     * @return the size of the date input in edit mode\n     */\n    public int getSize()\n    {\n        return getIntValue(META_PROPERTY_SIZE);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getDateFormat()\n    {\n        return getStringValue(\"dateFormat\");\n    }","id":104570,"modified_method":"/**\n     * @return the date format\n     */\n    public String getDateFormat()\n    {\n        return getStringValue(META_PROPERTY_DATE_FORMAT);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public BaseProperty fromString(String value)\n    {\n        BaseProperty property = newProperty();\n\n        if ((value == null) || (value.equals(\"\"))) {\n            if (getEmptyIsToday() == 1) {\n                property.setValue(new Date());\n            }\n            return property;\n        }\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat());\n            property.setValue(sdf.parse(value));\n        } catch (ParseException e) {\n            return null;\n        }\n        return property;\n    }","id":104571,"modified_method":"@Override\n    public BaseProperty fromString(String value)\n    {\n        BaseProperty property = newProperty();\n\n        if (StringUtils.isEmpty(value)) {\n            if (getEmptyIsToday() == 1) {\n                property.setValue(new Date());\n            }\n            return property;\n        }\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat());\n            property.setValue(sdf.parse(value));\n            return property;\n        } catch (ParseException e) {\n            return null;\n        }\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Default constructor. Initializes the default meta properties of a Date XClass property.\n     */\n    public DateMetaClass()\n    {\n        setPrettyName(\"Date\");\n        setName(getClass().getAnnotation(Named.class).value());\n\n        NumberClass sizeClass = new NumberClass(this);\n        sizeClass.setName(\"size\");\n        sizeClass.setPrettyName(\"Size\");\n        sizeClass.setSize(5);\n        sizeClass.setNumberType(\"integer\");\n        safeput(sizeClass.getName(), sizeClass);\n\n        NumberClass emptyIsTodayClass = new NumberClass(this);\n        emptyIsTodayClass.setName(\"emptyIsToday\");\n        emptyIsTodayClass.setPrettyName(\"Empty Is Today\");\n        emptyIsTodayClass.setSize(5);\n        emptyIsTodayClass.setNumberType(sizeClass.getNumberType());\n        safeput(emptyIsTodayClass.getName(), emptyIsTodayClass);\n\n        StringClass dateFormatClass = new StringClass(this);\n        dateFormatClass.setName(\"dateFormat\");\n        dateFormatClass.setPrettyName(\"Date Format\");\n        dateFormatClass.setSize(20);\n        safeput(dateFormatClass.getName(), dateFormatClass);\n    }","id":104572,"modified_method":"/**\n     * Default constructor. Initializes the default meta properties of a Date XClass property.\n     */\n    public DateMetaClass()\n    {\n        setPrettyName(\"Date\");\n        setName(getClass().getAnnotation(Named.class).value());\n\n        NumberClass sizeClass = new NumberClass(this);\n        sizeClass.setName(\"size\");\n        sizeClass.setPrettyName(\"Size\");\n        sizeClass.setSize(5);\n        sizeClass.setNumberType(\"integer\");\n        safeput(sizeClass.getName(), sizeClass);\n\n        BooleanClass emptyIsTodayClass = new BooleanClass(this);\n        emptyIsTodayClass.setName(\"emptyIsToday\");\n        emptyIsTodayClass.setPrettyName(\"Empty Is Today\");\n        emptyIsTodayClass.setDisplayType(\"yesno\");\n        emptyIsTodayClass.setDisplayFormType(\"checkbox\");\n        emptyIsTodayClass.setDefaultValue(1);\n        safeput(emptyIsTodayClass.getName(), emptyIsTodayClass);\n\n        BooleanClass pickerClass = new BooleanClass(this);\n        pickerClass.setName(\"picker\");\n        pickerClass.setPrettyName(\"Use Date Picker\");\n        pickerClass.setDisplayType(emptyIsTodayClass.getDisplayType());\n        pickerClass.setDisplayFormType(emptyIsTodayClass.getDisplayFormType());\n        pickerClass.setDefaultValue(1);\n        safeput(pickerClass.getName(), pickerClass);\n\n        StringClass dateFormatClass = new StringClass(this);\n        dateFormatClass.setName(\"dateFormat\");\n        dateFormatClass.setPrettyName(\"Date Format\");\n        dateFormatClass.setSize(20);\n        safeput(dateFormatClass.getName(), dateFormatClass);\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public String toText()\n    {\n        if (getValue() == null) {\n            return \"\";\n        }\n        \n        return (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\")).format(getValue());        \n    }","id":104573,"modified_method":"@Override\n    public String toText()\n    {\n        // FIXME: The value of a date property should be serialized using the date timestamp or the date format\n        // specified in the XClass the date property belongs to.\n        return getValue() == null ? \"\" : new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\").format(getValue());\n    }","commit_id":"37a1aa4006d91449f9e77e9cb3cb8a610d9ecc6a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getSize()\n    {\n        return getIntValue(\"size\");\n    }","id":104574,"modified_method":"/**\n     * @return the size of the date input in edit mode\n     */\n    public int getSize()\n    {\n        return getIntValue(META_PROPERTY_SIZE);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setPicker(int picker)\n    {\n        setIntValue(\"picker\", picker);\n    }","id":104575,"modified_method":"/**\n     * Sets whether to use a date picker or not to select the date in edit mode.\n     * \n     * @param picker {@code 1} to use a date picker, {@code 0} otherwise\n     */\n    public void setPicker(int picker)\n    {\n        setIntValue(META_PROPERTY_PICKER, picker);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getPicker()\n    {\n        return getIntValue(\"picker\");\n    }","id":104576,"modified_method":"/**\n     * @return {@code 1} if a date picker should be used to choose the date, {@code 0} otherwise\n     */\n    public int getPicker()\n    {\n        return getIntValue(META_PROPERTY_PICKER);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String toFormString(BaseProperty property)\n    {\n        if (property.getValue() == null) {\n            return \"\";\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat());\n        return sdf.format(property.getValue());\n    }","id":104577,"modified_method":"/**\n     * @param property a date property\n     * @return the value of the given date property serialized using the {@link #getDateFormat()} format\n     */\n    public String toFormString(BaseProperty property)\n    {\n        return property.getValue() == null ? \"\" : new SimpleDateFormat(getDateFormat()).format(property.getValue());\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getDateFormat()\n    {\n        return getStringValue(\"dateFormat\");\n    }","id":104578,"modified_method":"/**\n     * @return the date format\n     */\n    public String getDateFormat()\n    {\n        return getStringValue(META_PROPERTY_DATE_FORMAT);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setDateFormat(String dformat)\n    {\n        setStringValue(\"dateFormat\", dformat);\n    }","id":104579,"modified_method":"/**\n     * Sets the date format.\n     * \n     * @param format the new date format\n     */\n    public void setDateFormat(String format)\n    {\n        setStringValue(META_PROPERTY_DATE_FORMAT, format);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void displayView(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context)\n    {\n        BaseProperty prop = (BaseProperty) object.safeget(name);\n        if (prop != null) {\n            buffer.append(toFormString(prop));\n        }\n    }","id":104580,"modified_method":"@Override\n    public void displayView(StringBuffer buffer, String name, String prefix, BaseCollection object,\n        XWikiContext context)\n    {\n        BaseProperty property = (BaseProperty) object.safeget(name);\n        if (property != null) {\n            buffer.append(toFormString(property));\n        }\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DateClass(PropertyMetaClass wclass)\n    {\n        super(XCLASSNAME, \"Date\", wclass);\n        setSize(20);\n        setDateFormat(\"dd/MM/yyyy HH:mm:ss\");\n        setEmptyIsToday(1);\n        setPicker(1);\n    }","id":104581,"modified_method":"/**\n     * Creates a new Date property that is described by the given meta class.\n     * \n     * @param metaClass the meta class that defines the list of meta properties associated with this property type\n     */\n    public DateClass(PropertyMetaClass metaClass)\n    {\n        super(\"date\", \"Date\", metaClass);\n\n        setSize(20);\n        setDateFormat(\"dd/MM/yyyy HH:mm:ss\");\n        setEmptyIsToday(1);\n        setPicker(1);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DateClass()\n    {\n        this(null);\n    }","id":104582,"modified_method":"/**\n     * Default constructor.\n     */\n    public DateClass()\n    {\n        this(null);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public BaseProperty fromString(String value)\n    {\n        BaseProperty property = newProperty();\n\n        if ((value == null) || (value.equals(\"\"))) {\n            if (getEmptyIsToday() == 1) {\n                property.setValue(new Date());\n            }\n            return property;\n        }\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat());\n            property.setValue(sdf.parse(value));\n        } catch (ParseException e) {\n            return null;\n        }\n        return property;\n    }","id":104583,"modified_method":"@Override\n    public BaseProperty fromString(String value)\n    {\n        BaseProperty property = newProperty();\n\n        if (StringUtils.isEmpty(value)) {\n            if (getEmptyIsToday() == 1) {\n                property.setValue(new Date());\n            }\n            return property;\n        }\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat());\n            property.setValue(sdf.parse(value));\n            return property;\n        } catch (ParseException e) {\n            return null;\n        }\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setEmptyIsToday(int emptyIsToday)\n    {\n        setIntValue(\"emptyIsToday\", emptyIsToday);\n    }","id":104584,"modified_method":"/**\n     * Sets whether an empty date value represents the current date or not.\n     * \n     * @param emptyIsToday {@code 1} if an empty date value should represent the current date, {@code 0} otherwise\n     */\n    public void setEmptyIsToday(int emptyIsToday)\n    {\n        setIntValue(META_PROPERTY_EMPTY_IS_TODAY, emptyIsToday);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object, XWikiContext context)\n    {\n        input input = new input();\n\n        BaseProperty prop = (BaseProperty) object.safeget(name);\n        if (prop != null) {\n            input.setValue(toFormString(prop));\n        }\n\n        input.setType(\"text\");\n        input.setName(prefix + name);\n        input.setID(prefix + name);\n        input.setSize(getSize());\n        input.setDisabled(isDisabled());\n        buffer.append(input.toString());\n    }","id":104585,"modified_method":"@Override\n    public void displayEdit(StringBuffer buffer, String name, String prefix, BaseCollection object,\n        XWikiContext context)\n    {\n        input input = new input();\n\n        BaseProperty prop = (BaseProperty) object.safeget(name);\n        String styleName = \"datetime\";\n        if (prop != null) {\n            input.setValue(toFormString(prop));\n            // This is useful if the client doesn't understand the date format.\n            styleName += \" t\" + ((Date) prop.getValue()).getTime();\n        }\n\n        input.setType(\"text\");\n        input.setName(prefix + name);\n        input.setID(prefix + name);\n        input.setSize(getSize());\n        input.setDisabled(isDisabled());\n\n        if (getPicker() == 1) {\n            // Mark the date input so that it can be enhanced with a date picker.\n            input.setClass(styleName);\n            // Pass the date format to the client in the title attribute.\n            input.setTitle(getDateFormat());\n            // Pull the resources needed by the date picker.\n            String basePath = \"uicomponents/widgets/datepicker/\";\n            Map<String, Object> parameters = Collections.singletonMap(\"forceSkinAction\", (Object) true);\n            SkinExtension ssfx = Utils.getComponent(SkinExtension.class, \"ssfx\");\n            ssfx.use(basePath + \"calendarDateSelect.css\", parameters);\n            SkinExtension jsfx = Utils.getComponent(SkinExtension.class, \"jsfx\");\n            // A simple date picker widget.\n            jsfx.use(basePath + \"calendarDateSelect.js\", parameters);\n            // Used to parse and serialize the selected date using the date format specified in the XClass.\n            jsfx.use(basePath + \"simpleDateFormat.js\", parameters);\n            // A wrapper over the CalendarDateSelect widget that uses the SimpleDateFormat to parse/serialize the dates.\n            jsfx.use(basePath + \"dateTimePicker.js\");\n        }\n\n        buffer.append(input.toString());\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setSize(int size)\n    {\n        setIntValue(\"size\", size);\n    }","id":104586,"modified_method":"/**\n     * Sets the size of the date input in edit mode.\n     * \n     * @param size the size of the date input in edit mode\n     */\n    public void setSize(int size)\n    {\n        setIntValue(META_PROPERTY_SIZE, size);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getEmptyIsToday()\n    {\n        return getIntValue(\"emptyIsToday\");\n    }","id":104587,"modified_method":"/**\n     * @return {@code 1} if an empty date value represents the current date, {@code 0} otherwise\n     */\n    public int getEmptyIsToday()\n    {\n        return getIntValue(META_PROPERTY_EMPTY_IS_TODAY);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public BaseProperty newPropertyfromXML(Element ppcel)\n    {\n        String value = ppcel.getText();\n        BaseProperty property = newProperty();\n\n        if (StringUtils.isEmpty(value)) {\n            return property;\n        }\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n        try {\n            property.setValue(sdf.parse(value));\n        } catch (ParseException e) {\n            SimpleDateFormat sdf2 = new SimpleDateFormat(\"EEE MMM d HH:mm:ss z yyyy\", Locale.US);\n            try {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\"Failed to parse date [\" + value + \"] using format [\"\n                        + sdf.toString() + \"]. Trying again with format [\"\n                        + sdf2.toString() + \"]\");\n                }\n                property.setValue(sdf2.parse(value));\n            } catch (ParseException e2) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\"Failed to parse date [\" + value + \"] using format [\"\n                        + sdf2.toString() + \"]. Defaulting to the current date.\");\n                }\n                property.setValue(new Date());\n            }\n        }\n        return property;\n    }","id":104588,"modified_method":"/**\n     * {@inheritDoc}\n     * <p>\n     * We have to overwrite this method because the value of a date property is not serialized using the date format\n     * specified in the XClass nor the time stamp but a custom hard-coded date format.. Changing this now will break\n     * existing XARs..\n     */\n    @Override\n    public BaseProperty newPropertyfromXML(Element element)\n    {\n        String value = element.getText();\n        BaseProperty property = newProperty();\n\n        if (StringUtils.isEmpty(value)) {\n            return property;\n        }\n\n        // FIXME: The value of a date property should be serialized using the date timestamp or the date format\n        // specified in the XClass the date property belongs to.\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n        try {\n            property.setValue(sdf.parse(value));\n        } catch (ParseException e) {\n            // I suppose this is a date format used a long time ago. DateProperty is using the above date format now.\n            SimpleDateFormat sdfOld = new SimpleDateFormat(\"EEE MMM d HH:mm:ss z yyyy\", Locale.US);\n            LOGGER.warn(\"Failed to parse date [{}] using format [{}]. Trying again with format [{}].\", value,\n                sdf.toString(), sdfOld.toString());\n            try {\n                property.setValue(sdfOld.parse(value));\n            } catch (ParseException exception) {\n                LOGGER.warn(\"Failed to parse date [{}] using format [{}]. Defaulting to the current date.\", value,\n                    sdfOld.toString());\n                property.setValue(new Date());\n            }\n        }\n        return property;\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Default constructor. Initializes the default meta properties of a Date XClass property.\n     */\n    public DateMetaClass()\n    {\n        setPrettyName(\"Date\");\n        setName(getClass().getAnnotation(Named.class).value());\n\n        NumberClass sizeClass = new NumberClass(this);\n        sizeClass.setName(\"size\");\n        sizeClass.setPrettyName(\"Size\");\n        sizeClass.setSize(5);\n        sizeClass.setNumberType(\"integer\");\n        safeput(sizeClass.getName(), sizeClass);\n\n        NumberClass emptyIsTodayClass = new NumberClass(this);\n        emptyIsTodayClass.setName(\"emptyIsToday\");\n        emptyIsTodayClass.setPrettyName(\"Empty Is Today\");\n        emptyIsTodayClass.setSize(5);\n        emptyIsTodayClass.setNumberType(sizeClass.getNumberType());\n        safeput(emptyIsTodayClass.getName(), emptyIsTodayClass);\n\n        StringClass dateFormatClass = new StringClass(this);\n        dateFormatClass.setName(\"dateFormat\");\n        dateFormatClass.setPrettyName(\"Date Format\");\n        dateFormatClass.setSize(20);\n        safeput(dateFormatClass.getName(), dateFormatClass);\n    }","id":104589,"modified_method":"/**\n     * Default constructor. Initializes the default meta properties of a Date XClass property.\n     */\n    public DateMetaClass()\n    {\n        setPrettyName(\"Date\");\n        setName(getClass().getAnnotation(Named.class).value());\n\n        NumberClass sizeClass = new NumberClass(this);\n        sizeClass.setName(\"size\");\n        sizeClass.setPrettyName(\"Size\");\n        sizeClass.setSize(5);\n        sizeClass.setNumberType(\"integer\");\n        safeput(sizeClass.getName(), sizeClass);\n\n        BooleanClass emptyIsTodayClass = new BooleanClass(this);\n        emptyIsTodayClass.setName(\"emptyIsToday\");\n        emptyIsTodayClass.setPrettyName(\"Empty Is Today\");\n        emptyIsTodayClass.setDisplayType(\"yesno\");\n        emptyIsTodayClass.setDisplayFormType(\"checkbox\");\n        emptyIsTodayClass.setDefaultValue(1);\n        safeput(emptyIsTodayClass.getName(), emptyIsTodayClass);\n\n        BooleanClass pickerClass = new BooleanClass(this);\n        pickerClass.setName(\"picker\");\n        pickerClass.setPrettyName(\"Use Date Picker\");\n        pickerClass.setDisplayType(emptyIsTodayClass.getDisplayType());\n        pickerClass.setDisplayFormType(emptyIsTodayClass.getDisplayFormType());\n        pickerClass.setDefaultValue(1);\n        safeput(pickerClass.getName(), pickerClass);\n\n        StringClass dateFormatClass = new StringClass(this);\n        dateFormatClass.setName(\"dateFormat\");\n        dateFormatClass.setPrettyName(\"Date Format\");\n        dateFormatClass.setSize(20);\n        safeput(dateFormatClass.getName(), dateFormatClass);\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public String toText()\n    {\n        if (getValue() == null) {\n            return \"\";\n        }\n        \n        return (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\")).format(getValue());        \n    }","id":104590,"modified_method":"@Override\n    public String toText()\n    {\n        // FIXME: The value of a date property should be serialized using the date timestamp or the date format\n        // specified in the XClass the date property belongs to.\n        return getValue() == null ? \"\" : new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\").format(getValue());\n    }","commit_id":"05439b5b34df2c5b43f19f75e91b61a4ec24b34a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void updateRootKBFolderId(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortalException {\n\n\t\tlong kbFolderId = ParamUtil.getLong(actionRequest, \"rootKBFolderId\");\n\n\t\tif (kbFolderId == KBFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\treturn;\n\t\t}\n\n\t\tKBFolder kbFolder = KBFolderServiceUtil.getKBFolder(kbFolderId);\n\n\t\tPortalPreferences portalPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\tPortalUtil.getLiferayPortletRequest(actionRequest));\n\n\t\tportalPreferences.setValue(\n\t\t\tPortletKeys.KNOWLEDGE_BASE_DISPLAY, \"preferredKBFolderUrlTitle\",\n\t\t\tkbFolder.getUrlTitle());\n\n\t\tString urlTitle = ParamUtil.getString(actionRequest, \"urlTitle\");\n\n\t\tif (Validator.isNotNull(urlTitle)) {\n\t\t\tKBArticle kbArticle =\n\t\t\t\tKBArticleLocalServiceUtil.fetchKBArticleByUrlTitle(\n\t\t\t\t\tkbFolder.getGroupId(), kbFolder.getUrlTitle(), urlTitle);\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tif ((kbArticle != null) &&\n\t\t\t\tKBArticlePermission.contains(\n\t\t\t\t\t\tthemeDisplay.getPermissionChecker(), kbArticle,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"kbFolderUrlTitle\", kbFolder.getUrlTitle());\n\t\t\t\tactionResponse.setRenderParameter(\"urlTitle\", urlTitle);\n\t\t\t}\n\t\t}\n\t}","id":104591,"modified_method":"public void updateRootKBFolderId(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortalException {\n\n\t\tlong kbFolderId = ParamUtil.getLong(actionRequest, \"rootKBFolderId\");\n\n\t\tif (kbFolderId == KBFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\treturn;\n\t\t}\n\n\t\tKBFolder kbFolder = KBFolderServiceUtil.getKBFolder(kbFolderId);\n\n\t\tPortalPreferences portalPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\tPortalUtil.getLiferayPortletRequest(actionRequest));\n\n\t\tportalPreferences.setValue(\n\t\t\tPortletKeys.KNOWLEDGE_BASE_DISPLAY, \"preferredKBFolderUrlTitle\",\n\t\t\tkbFolder.getUrlTitle());\n\n\t\tString urlTitle = ParamUtil.getString(actionRequest, \"urlTitle\");\n\n\t\tif (Validator.isNull(urlTitle)) {\n\t\t\treturn;\n\t\t}\n\n\t\tKBArticle kbArticle =\n\t\t\tKBArticleLocalServiceUtil.fetchKBArticleByUrlTitle(\n\t\t\t\tkbFolder.getGroupId(), kbFolder.getUrlTitle(), urlTitle);\n\n\t\tif (kbArticle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (!KBArticlePermission.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(), kbArticle,\n\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tactionResponse.setRenderParameter(\n\t\t\t\"kbFolderUrlTitle\", kbFolder.getUrlTitle());\n\t\tactionResponse.setRenderParameter(\"urlTitle\", urlTitle);\n\t}","commit_id":"22e65c00c5c1ec3327a43526af90dc0835e8f86d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic ServletContext getServletContext() {\n\n\t\tServletContext servletContext = super.getServletContext();\n\n\t\tif (Validator.isNotNull(_portletId)) {\n\t\t\ttry {\n\t\t\t\tservletContext = getServletContext(\n\t\t\t\t\tservletContext, getServletRequest());\n\t\t\t}\n\t\t\tcatch (SystemException e) {\n\t\t\t}\n\t\t}\n\n\t\treturn servletContext;\n\t}","id":104592,"modified_method":"public ServletContext getServletContext() {\n\t\tServletContext servletContext = super.getServletContext();\n\n\t\ttry {\n\t\t\tif (Validator.isNull(_portletId)) {\n\t\t\t\treturn servletContext;\n\t\t\t}\n\n\t\t\tHttpServletRequest request = getServletRequest();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tthemeDisplay.getCompanyId(), _portletId);\n\n\t\t\tif (portlet == null) {\n\t\t\t\treturn servletContext;\n\t\t\t}\n\n\t\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\t\tif (!portletApp.isWARFile()) {\n\t\t\t\treturn servletContext;\n\t\t\t}\n\n\t\t\treturn PortalUtil.getServletContext(portlet, servletContext);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\treturn servletContext;\n\t\t}\n\t}","commit_id":"ff6d94099150ac49cc52ec14823a89b4ac556a72","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void include(String page) throws Exception {\n\t\tHttpServletRequest request = getServletRequest();\n\n\t\trequest.setAttribute(WebKeys.SERVLET_PATH, page);\n\n\t\tServletContext servletContext = getServletContext();\n\n\t\tservletContext = getServletContext(servletContext, request);\n\n\t\tif (_DIRECT_SERVLET_CONTEXT_ENABLED) {\n\t\t\tservletContext = new DirectServletContext(servletContext);\n\t\t}\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\tservletContext.getRequestDispatcher(page);\n\n\t\tHttpServletResponse response = new PipingServletResponse(\n\t\t\tpageContext, isTrimNewLines());\n\n\t\tif (!isWARFile(request)) {\n\t\t\trequestDispatcher.include(request, response);\n\t\t}\n\t\telse {\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\tClass<?> classObj = classLoader.loadClass(\n\t\t\t\t_LIFERAY_REQUEST_DISPATCHER);\n\n\t\t\tConstructor<?> constructor = classObj.getConstructor(\n\t\t\t\tRequestDispatcher.class, String.class);\n\n\t\t\tObject obj = constructor.newInstance(requestDispatcher, page);\n\n\t\t\tMethod method = classObj.getMethod(\n\t\t\t\t\"include\", ServletRequest.class, ServletResponse.class,\n\t\t\t\tboolean.class);\n\n\t\t\tmethod.invoke(obj, request, response, true);\n\t\t}\n\t}","id":104593,"modified_method":"protected void include(String page) throws Exception {\n\t\tServletContext servletContext = getServletContext();\n\n\t\tif (_DIRECT_SERVLET_CONTEXT_ENABLED) {\n\t\t\tservletContext = new DirectServletContext(servletContext);\n\t\t}\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\tservletContext.getRequestDispatcher(page);\n\n\t\tHttpServletRequest request = getServletRequest();\n\n\t\trequest.setAttribute(WebKeys.SERVLET_PATH, page);\n\n\t\tHttpServletResponse response = new PipingServletResponse(\n\t\t\tpageContext, isTrimNewLines());\n\n\t\tif (!isWARFile(request)) {\n\t\t\trequestDispatcher.include(request, response);\n\t\t}\n\t\telse {\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\tClass<?> classObj = classLoader.loadClass(\n\t\t\t\t_LIFERAY_REQUEST_DISPATCHER);\n\n\t\t\tConstructor<?> constructor = classObj.getConstructor(\n\t\t\t\tRequestDispatcher.class, String.class);\n\n\t\t\tObject obj = constructor.newInstance(requestDispatcher, page);\n\n\t\t\tMethod method = classObj.getMethod(\n\t\t\t\t\"include\", ServletRequest.class, ServletResponse.class,\n\t\t\t\tboolean.class);\n\n\t\t\tmethod.invoke(obj, request, response, true);\n\t\t}\n\t}","commit_id":"ff6d94099150ac49cc52ec14823a89b4ac556a72","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addPermissionFields(long companyId, Document document) {\n\t\ttry {\n\t\t\tlong groupId = GetterUtil.getLong(document.get(Field.GROUP_ID));\n\t\t\tString className = document.get(Field.ENTRY_CLASS_NAME);\n\n\t\t\tString classPK = document.get(Field.ROOT_ENTRY_CLASS_PK);\n\n\t\t\tif (Validator.isNull(classPK)) {\n\t\t\t\tclassPK = document.get(Field.ENTRY_CLASS_PK);\n\t\t\t}\n\t\t\t\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(className);\n\n\t\t\tif (Validator.isNotNull(className) &&\n\t\t\t\tValidator.isNotNull(classPK) && indexer.isFilterSearch()) {\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\tdoAddPermissionFields_5(\n\t\t\t\t\t\tcompanyId, groupId, className, classPK, document);\n\t\t\t\t}\n\t\t\t\telse if (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 6) {\n\t\t\t\t\tdoAddPermissionFields_6(\n\t\t\t\t\t\tcompanyId, groupId, className, classPK, document);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourceException nsre) {\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":104594,"modified_method":"public void addPermissionFields(long companyId, Document document) {\n\t\ttry {\n\t\t\tlong groupId = GetterUtil.getLong(document.get(Field.GROUP_ID));\n\n\t\t\tString className = document.get(Field.ENTRY_CLASS_NAME);\n\n\t\t\tif (Validator.isNull(className)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString classPK = document.get(Field.ROOT_ENTRY_CLASS_PK);\n\n\t\t\tif (Validator.isNull(classPK)) {\n\t\t\t\tclassPK = document.get(Field.ENTRY_CLASS_PK);\n\t\t\t}\n\n\t\t\tif (Validator.isNull(classPK)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(className);\n\n\t\t\tif (!indexer.isFilterSearch()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\tdoAddPermissionFields_5(\n\t\t\t\t\tcompanyId, groupId, className, classPK, document);\n\t\t\t}\n\t\t\telse if (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 6) {\n\t\t\t\tdoAddPermissionFields_6(\n\t\t\t\t\tcompanyId, groupId, className, classPK, document);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourceException nsre) {\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"ccb4ddbfe0c6b5ca0bac4e612ae1c4fb36d4263d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        boolean cache = true;\n        CacheKeyFilter.Key cacheKey = null;\n        String fieldName = null;\n        BytesRef from = null;\n        BytesRef to = null;\n        boolean includeLower = true;\n        boolean includeUpper = true;\n\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                fieldName = currentFieldName;\n                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                    if (token == XContentParser.Token.FIELD_NAME) {\n                        currentFieldName = parser.currentName();\n                    } else {\n                        if (\"from\".equals(currentFieldName)) {\n                            from = parser.bytesOrNull();\n                        } else if (\"to\".equals(currentFieldName)) {\n                            to = parser.bytesOrNull();\n                        } else if (\"include_lower\".equals(currentFieldName) || \"includeLower\".equals(currentFieldName)) {\n                            includeLower = parser.booleanValue();\n                        } else if (\"include_upper\".equals(currentFieldName) || \"includeUpper\".equals(currentFieldName)) {\n                            includeUpper = parser.booleanValue();\n                        } else if (\"gt\".equals(currentFieldName)) {\n                            from = parser.bytesOrNull();\n                            includeLower = false;\n                        } else if (\"gte\".equals(currentFieldName) || \"ge\".equals(currentFieldName)) {\n                            from = parser.bytesOrNull();\n                            includeLower = true;\n                        } else if (\"lt\".equals(currentFieldName)) {\n                            to = parser.bytesOrNull();\n                            includeUpper = false;\n                        } else if (\"lte\".equals(currentFieldName) || \"le\".equals(currentFieldName)) {\n                            to = parser.bytesOrNull();\n                            includeUpper = true;\n                        } else {\n                            throw new QueryParsingException(parseContext.index(), \"[range] filter does not support [\" + currentFieldName + \"]\");\n                        }\n                    }\n                }\n            } else if (token.isValue()) {\n                if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"_cache\".equals(currentFieldName)) {\n                    cache = parser.booleanValue();\n                } else if (\"_cache_key\".equals(currentFieldName) || \"_cacheKey\".equals(currentFieldName)) {\n                    cacheKey = new CacheKeyFilter.Key(parser.text());\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[range] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n\n        if (fieldName == null) {\n            throw new QueryParsingException(parseContext.index(), \"No field specified for range filter\");\n        }\n\n        Filter filter = null;\n        MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(fieldName);\n        if (smartNameFieldMappers != null) {\n            if (smartNameFieldMappers.hasMapper()) {\n                //LUCENE 4 UPGRADE range filter should use bytesref too? \n                filter = smartNameFieldMappers.mapper().rangeFilter(from.utf8ToString(), to.utf8ToString(), includeLower, includeUpper, parseContext);\n            }\n        }\n        if (filter == null) {\n            filter = new TermRangeFilter(fieldName, from, to, includeLower, includeUpper);\n        }\n\n        if (cache) {\n            filter = parseContext.cacheFilter(filter, cacheKey);\n        }\n\n        filter = wrapSmartNameFilter(filter, smartNameFieldMappers, parseContext);\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, filter);\n        }\n        return filter;\n    }","id":104595,"modified_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        boolean cache = true;\n        CacheKeyFilter.Key cacheKey = null;\n        String fieldName = null;\n        BytesRef from = null;\n        BytesRef to = null;\n        boolean includeLower = true;\n        boolean includeUpper = true;\n\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                fieldName = currentFieldName;\n                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                    if (token == XContentParser.Token.FIELD_NAME) {\n                        currentFieldName = parser.currentName();\n                    } else {\n                        if (\"from\".equals(currentFieldName)) {\n                            from = parser.bytesOrNull();\n                        } else if (\"to\".equals(currentFieldName)) {\n                            to = parser.bytesOrNull();\n                        } else if (\"include_lower\".equals(currentFieldName) || \"includeLower\".equals(currentFieldName)) {\n                            includeLower = parser.booleanValue();\n                        } else if (\"include_upper\".equals(currentFieldName) || \"includeUpper\".equals(currentFieldName)) {\n                            includeUpper = parser.booleanValue();\n                        } else if (\"gt\".equals(currentFieldName)) {\n                            from = parser.bytesOrNull();\n                            includeLower = false;\n                        } else if (\"gte\".equals(currentFieldName) || \"ge\".equals(currentFieldName)) {\n                            from = parser.bytesOrNull();\n                            includeLower = true;\n                        } else if (\"lt\".equals(currentFieldName)) {\n                            to = parser.bytesOrNull();\n                            includeUpper = false;\n                        } else if (\"lte\".equals(currentFieldName) || \"le\".equals(currentFieldName)) {\n                            to = parser.bytesOrNull();\n                            includeUpper = true;\n                        } else {\n                            throw new QueryParsingException(parseContext.index(), \"[range] filter does not support [\" + currentFieldName + \"]\");\n                        }\n                    }\n                }\n            } else if (token.isValue()) {\n                if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"_cache\".equals(currentFieldName)) {\n                    cache = parser.booleanValue();\n                } else if (\"_cache_key\".equals(currentFieldName) || \"_cacheKey\".equals(currentFieldName)) {\n                    cacheKey = new CacheKeyFilter.Key(parser.text());\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[range] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n\n        if (fieldName == null) {\n            throw new QueryParsingException(parseContext.index(), \"No field specified for range filter\");\n        }\n\n        Filter filter = null;\n        MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(fieldName);\n        if (smartNameFieldMappers != null) {\n            if (smartNameFieldMappers.hasMapper()) {\n                //LUCENE 4 UPGRADE range filter should use bytesref too? \n                filter = smartNameFieldMappers.mapper().rangeFilter(from != null ? from.utf8ToString() : null, to != null ? to.utf8ToString() : null, includeLower, includeUpper, parseContext);\n            }\n        }\n        if (filter == null) {\n            filter = new TermRangeFilter(fieldName, from, to, includeLower, includeUpper);\n        }\n\n        if (cache) {\n            filter = parseContext.cacheFilter(filter, cacheKey);\n        }\n\n        filter = wrapSmartNameFilter(filter, smartNameFieldMappers, parseContext);\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, filter);\n        }\n        return filter;\n    }","commit_id":"74464f9f99ad4da88d41fb94c87eca5f8da8da22","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        XContentParser.Token token = parser.nextToken();\n        if (token != XContentParser.Token.FIELD_NAME) {\n            throw new QueryParsingException(parseContext.index(), \"[range] query malformed, no field to indicate field name\");\n        }\n        String fieldName = parser.currentName();\n        token = parser.nextToken();\n        if (token != XContentParser.Token.START_OBJECT) {\n            throw new QueryParsingException(parseContext.index(), \"[range] query malformed, after field missing start object\");\n        }\n\n        BytesRef from = null;\n        BytesRef to = null;\n        boolean includeLower = true;\n        boolean includeUpper = true;\n        float boost = 1.0f;\n\n        String currentFieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else {\n                if (\"from\".equals(currentFieldName)) {\n                    from = parser.bytesOrNull();\n                } else if (\"to\".equals(currentFieldName)) {\n                    to = parser.bytesOrNull();\n                } else if (\"include_lower\".equals(currentFieldName) || \"includeLower\".equals(currentFieldName)) {\n                    includeLower = parser.booleanValue();\n                } else if (\"include_upper\".equals(currentFieldName) || \"includeUpper\".equals(currentFieldName)) {\n                    includeUpper = parser.booleanValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"gt\".equals(currentFieldName)) {\n                    from = parser.bytesOrNull();\n                    includeLower = false;\n                } else if (\"gte\".equals(currentFieldName) || \"ge\".equals(currentFieldName)) {\n                    from = parser.bytesOrNull();\n                    includeLower = true;\n                } else if (\"lt\".equals(currentFieldName)) {\n                    to = parser.bytesOrNull();\n                    includeUpper = false;\n                } else if (\"lte\".equals(currentFieldName) || \"le\".equals(currentFieldName)) {\n                    to = parser.bytesOrNull();\n                    includeUpper = true;\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[range] query does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n\n        // move to the next end object, to close the field name\n        token = parser.nextToken();\n        if (token != XContentParser.Token.END_OBJECT) {\n            throw new QueryParsingException(parseContext.index(), \"[range] query malformed, does not end with an object\");\n        }\n\n        Query query = null;\n        MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(fieldName);\n        if (smartNameFieldMappers != null) {\n            if (smartNameFieldMappers.hasMapper()) {\n                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well? \n                query = smartNameFieldMappers.mapper().rangeQuery(from.utf8ToString(), to.utf8ToString(), includeLower, includeUpper, parseContext);\n            }\n        }\n        if (query == null) {\n            query = new TermRangeQuery(fieldName, from, to, includeLower, includeUpper);\n        }\n        query.setBoost(boost);\n        return wrapSmartNameQuery(query, smartNameFieldMappers, parseContext);\n    }","id":104596,"modified_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        XContentParser.Token token = parser.nextToken();\n        if (token != XContentParser.Token.FIELD_NAME) {\n            throw new QueryParsingException(parseContext.index(), \"[range] query malformed, no field to indicate field name\");\n        }\n        String fieldName = parser.currentName();\n        token = parser.nextToken();\n        if (token != XContentParser.Token.START_OBJECT) {\n            throw new QueryParsingException(parseContext.index(), \"[range] query malformed, after field missing start object\");\n        }\n\n        BytesRef from = null;\n        BytesRef to = null;\n        boolean includeLower = true;\n        boolean includeUpper = true;\n        float boost = 1.0f;\n\n        String currentFieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else {\n                if (\"from\".equals(currentFieldName)) {\n                    from = parser.bytesOrNull();\n                } else if (\"to\".equals(currentFieldName)) {\n                    to = parser.bytesOrNull();\n                } else if (\"include_lower\".equals(currentFieldName) || \"includeLower\".equals(currentFieldName)) {\n                    includeLower = parser.booleanValue();\n                } else if (\"include_upper\".equals(currentFieldName) || \"includeUpper\".equals(currentFieldName)) {\n                    includeUpper = parser.booleanValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"gt\".equals(currentFieldName)) {\n                    from = parser.bytesOrNull();\n                    includeLower = false;\n                } else if (\"gte\".equals(currentFieldName) || \"ge\".equals(currentFieldName)) {\n                    from = parser.bytesOrNull();\n                    includeLower = true;\n                } else if (\"lt\".equals(currentFieldName)) {\n                    to = parser.bytesOrNull();\n                    includeUpper = false;\n                } else if (\"lte\".equals(currentFieldName) || \"le\".equals(currentFieldName)) {\n                    to = parser.bytesOrNull();\n                    includeUpper = true;\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[range] query does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n\n        // move to the next end object, to close the field name\n        token = parser.nextToken();\n        if (token != XContentParser.Token.END_OBJECT) {\n            throw new QueryParsingException(parseContext.index(), \"[range] query malformed, does not end with an object\");\n        }\n\n        Query query = null;\n        MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(fieldName);\n        if (smartNameFieldMappers != null) {\n            if (smartNameFieldMappers.hasMapper()) {\n                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well? \n                query = smartNameFieldMappers.mapper().rangeQuery(from != null ? from.utf8ToString() : null, to != null ? to.utf8ToString() : null, includeLower, includeUpper, parseContext);\n            }\n        }\n        if (query == null) {\n            query = new TermRangeQuery(fieldName, from, to, includeLower, includeUpper);\n        }\n        query.setBoost(boost);\n        return wrapSmartNameQuery(query, smartNameFieldMappers, parseContext);\n    }","commit_id":"74464f9f99ad4da88d41fb94c87eca5f8da8da22","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception\n    {\n        // allow access to everything\n        System.setSecurityManager(null);\n\n        // optional: the name of another class with a main method\n        // that should be started in the same JVM:\n        String chainMain = System.getProperty(\"chain.main.class\");\n        if(chainMain != null)\n        {\n            // optional: a space-separated list of arguments to be passed\n            // to the chained main() method:\n            String chainArgs = System.getProperty(\"chain.main.args\");\n            if(chainArgs == null)\n            {\n                chainArgs = \"\";\n            }\n            final String[] _chainArgs = chainArgs.split(\"\\\\s\");\n            try\n            {\n                Class<?> c = Class.forName(chainMain);\n                final Method m = c.getMethod(\"main\", _chainArgs.getClass());\n                new Thread()\n                {\n                    public void run()\n                    {\n                        try\n                        {\n                            m.invoke(null, new Object[]{_chainArgs});\n                        }\n                        catch (Exception ex)\n                        {\n                            ex.printStackTrace();\n                            System.err.println(\"Exception running the \" +\n                               \"chained main class, will continue anyway.\");\n                        }\n                    }\n                }.start();\n            }\n            catch (Exception ex)\n            {\n                ex.printStackTrace();\n                System.err.println(\"Exception finding the chained main \" +\n                    \"class, will continue anyway.\");\n            }\n        }\n\n        // prepare the logger\n        // needed by the FileHandler-Logger\n        SIPCommunicator.setScHomeDir(System.getProperty(\"os.name\"));\n        LogManager.getLogManager()\n            .readConfiguration(\n                SIPCommunicatorJWS.class\n                    .getResourceAsStream(\"/logging.properties\"));\n\n        for (Handler h : LogManager.getLogManager().getLogger(\"\").getHandlers())\n            LogManager.getLogManager().getLogger(\"\").removeHandler(h);\n        LogManager.getLogManager().getLogger(\"\").addHandler(new FileHandler());\n        LogManager.getLogManager().getLogger(\"\")\n            .addHandler(new ConsoleHandler());\n        for (Handler h : LogManager.getLogManager().getLogger(\"\").getHandlers())\n            h.setFormatter(new ScLogFormatter());\n\n        // be evil :-)\n        // find the path of the nativelibs under webstart (findLibrary is\n        // protected and therefore at least documented api)\n        Method findLibrary =\n            SIPCommunicatorJWS.class.getClassLoader().getClass()\n                .getDeclaredMethod(\"findLibrary\", String.class);\n        findLibrary.setAccessible(true);\n        File path =\n            new File((String) findLibrary.invoke(\n                SIPCommunicatorJWS.class.getClassLoader(), \"hid\"))\n                .getParentFile();\n        System.setProperty(\n            \"java.library.path\",\n            System.getProperty(\"java.library.path\") + File.pathSeparator\n                + path.getAbsolutePath());\n\n        // reset sys_paths to re-read usr_paths (runtime-dependent and therefore\n        // very very ugly :()\n        Field sys_paths = ClassLoader.class.getDeclaredField(\"sys_paths\");\n        sys_paths.setAccessible(true);\n        sys_paths.set(null, null);\n\n        // prepare the felix-config with the absolute paths\n        Properties pIn = new Properties();\n        Properties pOut = new Properties();\n        pIn.load(SIPCommunicatorJWS.class.getResourceAsStream(System\n            .getProperty(\"felix.config.properties\")));\n\n        String baseServerUrl =\n            System.getProperty(\"net.java.sip.communicator.SC_JWS_BASEDIR\");\n        ClassLoader cl = SIPCommunicatorJWS.class.getClassLoader();\n        Method getJarFile =\n            cl.getClass().getDeclaredMethod(\"getJarFile\", URL.class);\n        getJarFile.setAccessible(true);\n        for (Map.Entry<Object, Object> e : pIn.entrySet())\n        {\n            if (((String) e.getKey()).startsWith(\"felix.auto.start.\"))\n            {\n                String[] refs = ((String) e.getValue()).split(\"\\\\s\");\n                StringBuilder sb = new StringBuilder();\n                for (String ref : refs)\n                {\n                    JarFile localFile =\n                        (JarFile) getJarFile.invoke(cl, new URL(baseServerUrl\n                            + ref.replace(\"@URL@\", \"\")));\n                    if (localFile != null)\n                    {\n                        String localFileName =\n                            new File(localFile.getName()).toURI().toString();\n                        sb.append(\"reference:\");\n                        sb.append(localFileName);\n                        sb.append(\" \");\n                    }\n                    else\n                    {\n                        throw new Exception(\"ref <\" + ref\n                            + \"> not found in cache\");\n                    }\n                }\n                pOut.put(e.getKey(), sb.toString());\n            }\n            else\n            {\n                pOut.put(e.getKey(), e.getValue());\n            }\n        }\n        File jwsFelixConfig = File.createTempFile(\"jws\", \".properties\");\n        jwsFelixConfig.deleteOnExit();\n        pOut.store(new FileOutputStream(jwsFelixConfig),\n            \"--- autogenerated, do not edit! ---\");\n        System.setProperty(\"felix.config.properties\", jwsFelixConfig.toURI()\n            .toString());\n\n        // Workaround broken desktop shortcut in ubuntu linux:\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6957030\n        try\n        {\n            if (System.getProperty(\"os.name\").equals(\"Linux\"))\n            {\n                File desktop =\n                    new File(System.getProperty(\"user.home\") + \"/Desktop\");\n                File[] files = desktop.listFiles();\n                for (File file : files)\n                {\n                    if (file.getName().contains(\"jws_app_shortcut_\"))\n                    {\n                        file.setExecutable(true, false);\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n        }\n\n        // Handle the \"-open\" argument from the javaws command line\n        Vector<String> _args = new Vector<String>();\n        for(int i = 0; i < args.length ; i++)\n        {\n            String arg = args[i];\n            if(arg.equalsIgnoreCase(\"-open\"))\n            {\n                // are we at the last argument or is the next value\n                // some other option flag?\n                if(i == (args.length - 1) ||\n                    (args[i+1].length() > 0 &&\n                        \"-/\".indexOf(args[i+1].charAt(0))>=0))\n                {\n                    // invalid, can't use \"-open\" as final argument\n                    System.err.println(\"Command line argument '-open'\"\n                        + \" requires a parameter, usually a URI\");\n                    System.exit(1);\n                }\n            }\n            else\n            {\n                _args.add(arg);\n            }\n        }\n\n        // launch the original app\n        SIPCommunicator.main(_args.toArray(new String[] {}));\n    }","id":104597,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        // allow access to everything\n        System.setSecurityManager(null);\n\n        // optional: the name of another class with a main method\n        // that should be started in the same JVM:\n        String chainMain = System.getProperty(\"chain.main.class\");\n        if(chainMain != null)\n        {\n            // optional: a space-separated list of arguments to be passed\n            // to the chained main() method:\n            String chainArgs = System.getProperty(\"chain.main.args\");\n            if(chainArgs == null)\n            {\n                chainArgs = \"\";\n            }\n            final String[] _chainArgs = chainArgs.split(\"\\\\s\");\n            try\n            {\n                Class c = Class.forName(chainMain);\n                final Method m = c.getMethod(\"main\", _chainArgs.getClass());\n                new Thread()\n                {\n                    public void run()\n                    {\n                        try\n                        {\n                            m.invoke(null, new Object[]{_chainArgs});\n                        }\n                        catch (Exception ex)\n                        {\n                            ex.printStackTrace();\n                            System.err.println(\"Exception running the \" +\n                               \"chained main class, will continue anyway.\");\n                        }\n                    }\n                }.start();\n            }\n            catch (Exception ex)\n            {\n                ex.printStackTrace();\n                System.err.println(\"Exception finding the chained main \" +\n                    \"class, will continue anyway.\");\n            }\n        }\n\n        // prepare the logger\n        // needed by the FileHandler-Logger\n        SIPCommunicator.setScHomeDir(System.getProperty(\"os.name\"));\n        LogManager.getLogManager()\n            .readConfiguration(\n                SIPCommunicatorJWS.class\n                    .getResourceAsStream(\"/logging.properties\"));\n\n        Handler[] hs = LogManager.getLogManager().getLogger(\"\").getHandlers();\n        for (int i = 0; i < hs.length; i++)\n            LogManager.getLogManager().getLogger(\"\").removeHandler(hs[i]);\n        LogManager.getLogManager().getLogger(\"\").addHandler(new FileHandler());\n        LogManager.getLogManager().getLogger(\"\")\n            .addHandler(new ConsoleHandler());\n        for (Handler h : LogManager.getLogManager().getLogger(\"\").getHandlers())\n            h.setFormatter(new ScLogFormatter());\n\n        // be evil :-)\n        // find the path of the nativelibs under webstart (findLibrary is\n        // protected and therefore at least documented api)\n        Method findLibrary =\n            SIPCommunicatorJWS.class.getClassLoader().getClass()\n                .getDeclaredMethod(\"findLibrary\", String.class);\n        findLibrary.setAccessible(true);\n        File path =\n            new File((String) findLibrary.invoke(\n                SIPCommunicatorJWS.class.getClassLoader(), \"hid\"))\n                .getParentFile();\n        System.setProperty(\n            \"java.library.path\",\n            System.getProperty(\"java.library.path\") + File.pathSeparator\n                + path.getAbsolutePath());\n\n        // reset sys_paths to re-read usr_paths (runtime-dependent and therefore\n        // very very ugly :()\n        Field sys_paths = ClassLoader.class.getDeclaredField(\"sys_paths\");\n        sys_paths.setAccessible(true);\n        sys_paths.set(null, null);\n\n        // prepare the felix-config with the absolute paths\n        Properties pIn = new Properties();\n        Properties pOut = new Properties();\n        pIn.load(SIPCommunicatorJWS.class.getResourceAsStream(System\n            .getProperty(\"felix.config.properties\")));\n\n        String baseServerUrl =\n            System.getProperty(\"net.java.sip.communicator.SC_JWS_BASEDIR\");\n        ClassLoader cl = SIPCommunicatorJWS.class.getClassLoader();\n        Method getJarFile =\n            cl.getClass().getDeclaredMethod(\"getJarFile\", URL.class);\n        getJarFile.setAccessible(true);\n        for (Map.Entry<Object, Object> e : pIn.entrySet())\n        {\n            if (((String) e.getKey()).startsWith(\"felix.auto.start.\"))\n            {\n                String[] refs = ((String) e.getValue()).split(\"\\\\s\");\n                StringBuilder sb = new StringBuilder();\n                for (String ref : refs)\n                {\n                    JarFile localFile =\n                        (JarFile) getJarFile.invoke(cl, new URL(baseServerUrl\n                            + ref.replace(\"@URL@\", \"\")));\n                    if (localFile != null)\n                    {\n                        String localFileName =\n                            new File(localFile.getName()).toURI().toString();\n                        sb.append(\"reference:\");\n                        sb.append(localFileName);\n                        sb.append(\" \");\n                    }\n                    else\n                    {\n                        throw new Exception(\"ref <\" + ref\n                            + \"> not found in cache\");\n                    }\n                }\n                pOut.put(e.getKey(), sb.toString());\n            }\n            else\n            {\n                pOut.put(e.getKey(), e.getValue());\n            }\n        }\n        File jwsFelixConfig = File.createTempFile(\"jws\", \".properties\");\n        jwsFelixConfig.deleteOnExit();\n        pOut.store(new FileOutputStream(jwsFelixConfig),\n            \"--- autogenerated, do not edit! ---\");\n        System.setProperty(\"felix.config.properties\", jwsFelixConfig.toURI()\n            .toString());\n\n        // Workaround broken desktop shortcut in ubuntu linux:\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6957030\n        try\n        {\n            if (System.getProperty(\"os.name\").equals(\"Linux\"))\n            {\n                File desktop =\n                    new File(System.getProperty(\"user.home\") + \"/Desktop\");\n                File[] files = desktop.listFiles();\n                for (File file : files)\n                {\n                    if (file.getName().contains(\"jws_app_shortcut_\"))\n                    {\n                        file.setExecutable(true, false);\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n        }\n\n        // Handle the \"-open\" argument from the javaws command line\n        Vector<String> _args = new Vector<String>();\n        for(int i = 0; i < args.length ; i++)\n        {\n            String arg = args[i];\n            if(arg.equalsIgnoreCase(\"-open\"))\n            {\n                // are we at the last argument or is the next value\n                // some other option flag?\n                if(i == (args.length - 1) ||\n                    (args[i+1].length() > 0 &&\n                        \"-/\".indexOf(args[i+1].charAt(0))>=0))\n                {\n                    // invalid, can't use \"-open\" as final argument\n                    System.err.println(\"Command line argument '-open'\"\n                        + \" requires a parameter, usually a URI\");\n                    System.exit(1);\n                }\n            }\n            else\n            {\n                _args.add(arg);\n            }\n        }\n\n        // launch the original app\n        SIPCommunicator.main(_args.toArray(new String[] {}));\n    }","commit_id":"3fd55e9c3bdcef6b25760e3dfe56ba1a2d6c4954","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructor\n     * @param inventoryPrinterManager The manager\n     */\n    AbstractWebConsolePlugin(final InventoryPrinterManager inventoryPrinterManager) {\n        this.inventoryPrinterManager = inventoryPrinterManager;\n    }","id":104598,"modified_method":"/**\n     * Constructor\n     * @param inventoryPrinterManager The manager\n     */\n    AbstractWebConsolePlugin(final InventoryPrinterManagerImpl inventoryPrinterManager) {\n        this.inventoryPrinterManager = inventoryPrinterManager;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"private void printConfigurationInventory( final ConfigurationWriter pw,\n            final PrinterMode mode,\n            final InventoryPrinterHandler handler )\n    throws IOException {\n        if ( handler == null ) {\n            for(final InventoryPrinterHandler sph : this.inventoryPrinterManager.getHandlers(mode)) {\n                pw.printInventory(mode, sph);\n            }\n        } else {\n            if ( handler.supports(mode) ) {\n                pw.printInventory(mode, handler);\n            }\n        }\n    }","id":104599,"modified_method":"private void printConfigurationInventory( final ConfigurationWriter pw,\n            final PrinterMode mode,\n            final InventoryPrinterHandler handler )\n    throws IOException {\n        if ( handler == null ) {\n            final InventoryPrinterHandler[] adapters = this.inventoryPrinterManager.getHandlers(mode);\n            for(int i = 0; i < adapters.length; i++) {\n                pw.printInventory(mode, adapters[i]);\n            }\n        } else {\n            if ( handler.supports(mode) ) {\n                pw.printInventory(mode, handler);\n            }\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)\n     */\n    public void start(final BundleContext context) throws Exception {\n        this.webAdapter = new WebConsoleAdapter(context);\n        this.printerManager = new InventoryPrinterManagerImpl(context);\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(Constants.SERVICE_DESCRIPTION, \"Apache Felix Inventory Printer Manager\");\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        this.managerRegistration = context.registerService(\n                InventoryPrinterManager.class.getName(),\n                this.printerManager, props);\n}","id":104600,"modified_method":"/**\n     * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)\n     */\n    public void start(final BundleContext context) throws Exception {\n        this.webAdapter = new WebConsoleAdapter(context);\n        this.printerManager = new InventoryPrinterManagerImpl(context);\n}","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n     */\n    public void stop(final BundleContext context) throws Exception {\n        if( this.managerRegistration != null ) {\n            this.managerRegistration.unregister();\n            this.managerRegistration = null;\n        }\n        if ( this.printerManager != null ) {\n            this.printerManager.dispose();\n            this.printerManager = null;\n        }\n        if ( this.webAdapter != null ) {\n            this.webAdapter.dispose();\n            this.webAdapter = null;\n        }\n    }","id":104601,"modified_method":"/**\n     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n     */\n    public void stop(final BundleContext context) throws Exception {\n        if ( this.printerManager != null ) {\n            this.printerManager.dispose();\n            this.printerManager = null;\n        }\n        if ( this.webAdapter != null ) {\n            this.webAdapter.dispose();\n            this.webAdapter = null;\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Search a method with the given name and signature.\n     * @return The method or <code>null<\/code> if not found.\n     */\n    public static Method searchMethod(final Class<?> clazz, final String mName, final Class<?>[] params) {\n        try {\n            final Method m = clazz.getMethod(mName, params);\n            m.setAccessible(true);\n            return m;\n        } catch (Throwable nsme) {\n            // ignore, we catch Throwable above to not only catch NoSuchMethodException\n            // but also other ones like ClassDefNotFoundError etc.\n        }\n        if ( clazz.getSuperclass() != null ) {\n            // try super class\n            return searchMethod(clazz.getSuperclass(), mName, params);\n        }\n        return null;\n    }","id":104602,"modified_method":"/**\n     * Search a method with the given name and signature.\n     * @return The method or <code>null<\/code> if not found.\n     */\n    public static Method searchMethod(final Class clazz, final String mName, final Class[] params) {\n        try {\n            final Method m = clazz.getMethod(mName, params);\n            m.setAccessible(true);\n            return m;\n        } catch (Throwable nsme) {\n            // ignore, we catch Throwable above to not only catch NoSuchMethodException\n            // but also other ones like ClassDefNotFoundError etc.\n        }\n        if ( clazz.getSuperclass() != null ) {\n            // try super class\n            return searchMethod(clazz.getSuperclass(), mName, params);\n        }\n        return null;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Map the modes to inventory printer modes\n     */\n    public String[] getPrinterModes() {\n        final Set<String> list = new HashSet<String>();\n        if ( this.match(ConsoleConstants.MODE_TXT) || this.match(ConsoleConstants.MODE_ZIP) ) {\n            list.add(PrinterMode.ZIP_FILE_TEXT.name());\n        }\n        if ( this.match(ConsoleConstants.MODE_WEB) ) {\n            if ( !escapeHtml ) {\n                list.add(PrinterMode.HTML_BODY.name());\n            } else {\n                list.add(PrinterMode.TEXT.name());\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }","id":104603,"modified_method":"/**\n     * Map the modes to inventory printer modes\n     */\n    public String[] getPrinterModes() {\n        final Set list = new HashSet();\n        if ( this.match(ConsoleConstants.MODE_TXT) || this.match(ConsoleConstants.MODE_ZIP) ) {\n            list.add(PrinterMode.ZIP_FILE_TEXT.name());\n        }\n        if ( this.match(ConsoleConstants.MODE_WEB) ) {\n            if ( !escapeHtml ) {\n                list.add(PrinterMode.HTML_BODY.name());\n            } else {\n                list.add(PrinterMode.TEXT.name());\n            }\n        }\n        return (String[]) list.toArray(new String[list.size()]);\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Check whether the class implements the configuration printer.\n     * This is done manually to avoid having the configuration printer class available.\n     */\n    private static boolean isConfigurationPrinter(final Class<?> clazz) {\n        for(final Class<?> i : clazz.getInterfaces() ) {\n            if ( i.getName().equals(ConsoleConstants.INTERFACE_CONFIGURATION_PRINTER) ) {\n                return true;\n            }\n        }\n        if ( clazz.getSuperclass() != null ) {\n            return isConfigurationPrinter(clazz.getSuperclass());\n        }\n        return false;\n    }","id":104604,"modified_method":"/**\n     * Check whether the class implements the configuration printer.\n     * This is done manually to avoid having the configuration printer class available.\n     */\n    private static boolean isConfigurationPrinter(final Class clazz) {\n        final Class[] interf = clazz.getInterfaces();\n        for(int i=0; i<interf.length; i++) {\n            if ( interf[i].getName().equals(ConsoleConstants.INTERFACE_CONFIGURATION_PRINTER) ) {\n                return true;\n            }\n        }\n        if ( clazz.getSuperclass() != null ) {\n            return isConfigurationPrinter(clazz.getSuperclass());\n        }\n        return false;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"public static ServiceRegistration register(final BundleContext context,\n            final InventoryPrinterManager manager) {\n        final DefaultWebConsolePlugin dwcp = new DefaultWebConsolePlugin(manager);\n\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(ConsoleConstants.PLUGIN_LABEL, dwcp.getName());\n        props.put(ConsoleConstants.PLUGIN_TITLE, dwcp.getTitle());\n        props.put(ConsoleConstants.PLUGIN_CATEGORY, dwcp.getCategory());\n        return context.registerService(ConsoleConstants.INTERFACE_SERVLET, new ServiceFactory() {\n\n            public void ungetService(final Bundle bundle, final ServiceRegistration registration,\n                    final Object service) {\n                // nothing to do\n            }\n\n            public Object getService(final Bundle bundle, final ServiceRegistration registration) {\n                return dwcp;\n            }\n\n        }, props);\n    }","id":104605,"modified_method":"public static ServiceRegistration register(final BundleContext context,\n            final InventoryPrinterManagerImpl manager) {\n        final DefaultWebConsolePlugin dwcp = new DefaultWebConsolePlugin(manager);\n\n        final Dictionary props = new Hashtable();\n        props.put(ConsoleConstants.PLUGIN_LABEL, dwcp.getName());\n        props.put(ConsoleConstants.PLUGIN_TITLE, dwcp.getTitle());\n        props.put(ConsoleConstants.PLUGIN_CATEGORY, ConsoleConstants.WEB_CONSOLE_CATEGORY);\n        return context.registerService(ConsoleConstants.INTERFACE_SERVLET, new ServiceFactory() {\n\n            public void ungetService(final Bundle bundle, final ServiceRegistration registration,\n                    final Object service) {\n                // nothing to do\n            }\n\n            public Object getService(final Bundle bundle, final ServiceRegistration registration) {\n                return dwcp;\n            }\n\n        }, props);\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#getTitle()\n     */\n    public String getTitle() {\n        return \"Overview\";\n    }","id":104606,"modified_method":"/**\n     * @see org.apache.felix.inventory.impl.InventoryPrinterHandler#getTitle()\n     */\n    public String getTitle() {\n        return \"Overview\";\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinter#print(org.apache.felix.inventory.PrinterMode, java.io.PrintWriter)\n     */\n    public void print(final PrinterMode mode, final PrintWriter printWriter) {\n        final InventoryPrinterHandler[] handlers = this.inventoryPrinterManager.getAllHandlers();\n        printWriter.print(\"Currently registered \");\n        printWriter.print(String.valueOf(handlers.length));\n        printWriter.println(\" inventory printer.\");\n        printWriter.println();\n        for(final InventoryPrinterHandler handler : handlers) {\n            printWriter.println(handler.getTitle());\n        }\n    }","id":104607,"modified_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinter#print(org.apache.felix.inventory.PrinterMode, java.io.PrintWriter)\n     */\n    public void print(final PrinterMode mode, final PrintWriter printWriter) {\n        final InventoryPrinterHandler[] handlers = this.inventoryPrinterManager.getAllHandlers();\n        printWriter.print(\"Currently registered \");\n        printWriter.print(String.valueOf(handlers.length));\n        printWriter.println(\" printer(s).\");\n        printWriter.println();\n        for(int i=0; i<handlers.length; i++) {\n            printWriter.println(handlers[i].getTitle());\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#getModes()\n     */\n    public PrinterMode[] getModes() {\n        return new PrinterMode[] {PrinterMode.TEXT};\n    }","id":104608,"modified_method":"/**\n     * @see org.apache.felix.inventory..implInventoryPrinterHandler#getModes()\n     */\n    public PrinterMode[] getModes() {\n        return new PrinterMode[] {PrinterMode.TEXT};\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Constructor\n     * @param inventoryPrinterAdapter The adapter\n     */\n    DefaultWebConsolePlugin(final InventoryPrinterManager inventoryPrinterManager) {\n        super(inventoryPrinterManager);\n    }","id":104609,"modified_method":"/**\n     * Constructor\n     * @param inventoryPrinterAdapter The adapter\n     */\n    DefaultWebConsolePlugin(final InventoryPrinterManagerImpl inventoryPrinterManager) {\n        super(inventoryPrinterManager);\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#getName()\n     */\n    public String getName() {\n        return \"config\";\n    }","id":104610,"modified_method":"/**\n     * @see org.apache.felix.inventory.impl.InventoryPrinterHandler#getName()\n     */\n    public String getName() {\n        return \"config\";\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#supports(org.apache.felix.inventory.PrinterMode)\n     */\n    public boolean supports(final PrinterMode mode) {\n        return mode == PrinterMode.TEXT;\n    }","id":104611,"modified_method":"/**\n     * @see org.apache.felix.inventory.impl.InventoryPrinterHandler#supports(org.apache.felix.inventory.PrinterMode)\n     */\n    public boolean supports(final PrinterMode mode) {\n        return mode == PrinterMode.TEXT;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#supports(org.apache.felix.inventory.PrinterMode)\n     */\n    public boolean supports(final PrinterMode mode) {\n        for(int i=0; i<this.description.getModes().length; i++) {\n            if ( this.description.getModes()[i] == mode ) {\n                return true;\n            }\n        }\n        return false;\n    }","id":104612,"modified_method":"/**\n     * Whether the printer supports this mode.\n     */\n    public boolean supports(final PrinterMode mode) {\n        for(int i=0; i<this.description.getModes().length; i++) {\n            if ( this.description.getModes()[i] == mode ) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#getName()\n     */\n    public String getName() {\n        return this.description.getName();\n    }","id":104613,"modified_method":"/**\n     * The unique name of the printer.\n     */\n    public String getName() {\n        return this.description.getName();\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"public void registerConsole(final BundleContext context, final InventoryPrinterManager manager) {\n        if ( this.registration == null &&\n             (supports(PrinterMode.HTML_BODY) || supports(PrinterMode.TEXT))) {\n            this.registration = WebConsolePlugin.register(context, manager, this.description);\n        }\n    }","id":104614,"modified_method":"public void registerConsole(final BundleContext context, final InventoryPrinterManagerImpl manager) {\n        if ( this.registration == null &&\n             (supports(PrinterMode.HTML_BODY) || supports(PrinterMode.TEXT))) {\n            this.registration = WebConsolePlugin.register(context, manager, this.description);\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#getModes()\n     */\n    public PrinterMode[] getModes() {\n        return this.description.getModes();\n    }","id":104615,"modified_method":"/**\n     * All supported modes.\n     */\n    public PrinterMode[] getModes() {\n        return this.description.getModes();\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterHandler#getTitle()\n     */\n    public String getTitle() {\n        return this.description.getTitle();\n    }","id":104616,"modified_method":"/**\n     * The human readable title for the inventory printer.\n     */\n    public String getTitle() {\n        return this.description.getTitle();\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public String toString() {\n        return \"InventoryPrinterDescription [title=\" + title + \", name=\" + name\n                + \", modes=\" + Arrays.toString(modes) + \", sortKey=\" + sortKey\n                + \", category=\" + category + \"]\";\n    }","id":104617,"modified_method":"public String toString() {\n        return \"InventoryPrinterDescription [title=\" + title + \", name=\" + name\n                + \", modes=\" + Arrays.toString(modes) + \", sortKey=\" + sortKey + \"]\";\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"public InventoryPrinterDescription(final ServiceReference ref) {\n        this.reference = ref;\n\n        // check modes\n        final Object modesCfg = ref.getProperty(InventoryPrinter.CONFIG_PRINTER_MODES);\n        if ( modesCfg instanceof String ) {\n            this.modes = new PrinterMode[] { PrinterMode.valueOf((String)modesCfg)};\n        } else if ( modesCfg instanceof String[] ) {\n            final String[] modesCfgArray = (String[])modesCfg;\n            this.modes = new PrinterMode[modesCfgArray.length];\n            for(int i=0; i<modesCfgArray.length;i++) {\n                this.modes[i] = PrinterMode.valueOf(modesCfgArray[i]);\n            }\n        } else {\n            this.modes = null;\n        }\n\n        // check name\n        if ( ref.getProperty(InventoryPrinter.CONFIG_NAME) != null ) {\n            this.name = ref.getProperty(InventoryPrinter.CONFIG_NAME).toString();\n        } else {\n            this.name = null;\n        }\n\n        // check title\n        if ( ref.getProperty(InventoryPrinter.CONFIG_TITLE) != null ) {\n            this.title = ref.getProperty(InventoryPrinter.CONFIG_TITLE).toString();\n            if ( this.title.startsWith(\"%\") ) {\n                this.sortKey = this.title.substring(1);\n            } else {\n                this.sortKey = this.title;\n            }\n        } else {\n            this.title = null;\n            this.sortKey = null;\n        }\n\n        // check category\n        if ( ref.getProperty(InventoryPrinter.CONFIG_CATEGORY) != null ) {\n            this.category = ref.getProperty(InventoryPrinter.CONFIG_CATEGORY).toString();\n        } else {\n            this.category = null;\n        }\n    }","id":104618,"modified_method":"public InventoryPrinterDescription(final ServiceReference ref) {\n        this.reference = ref;\n\n        // check modes\n        final Object modesCfg = ref.getProperty(InventoryPrinter.CONFIG_PRINTER_MODES);\n        if ( modesCfg instanceof String ) {\n            this.modes = new PrinterMode[] { PrinterMode.valueOf((String)modesCfg)};\n        } else if ( modesCfg instanceof String[] ) {\n            final String[] modesCfgArray = (String[])modesCfg;\n            this.modes = new PrinterMode[modesCfgArray.length];\n            for(int i=0; i<modesCfgArray.length;i++) {\n                this.modes[i] = PrinterMode.valueOf(modesCfgArray[i]);\n            }\n        } else {\n            this.modes = null;\n        }\n\n        // check name\n        if ( ref.getProperty(InventoryPrinter.CONFIG_NAME) != null ) {\n            this.name = ref.getProperty(InventoryPrinter.CONFIG_NAME).toString();\n        } else {\n            this.name = null;\n        }\n\n        // check title\n        if ( ref.getProperty(InventoryPrinter.CONFIG_TITLE) != null ) {\n            this.title = ref.getProperty(InventoryPrinter.CONFIG_TITLE).toString();\n            if ( this.title.startsWith(\"%\") ) {\n                this.sortKey = this.title.substring(1);\n            } else {\n                this.sortKey = this.title;\n            }\n        } else {\n            this.title = null;\n            this.sortKey = null;\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"private void removeService(final ServiceReference reference) {\n        synchronized ( this.allAdapters ) {\n            final Iterator<Map.Entry<String, List<InventoryPrinterAdapter>>> i = this.allAdapters.entrySet().iterator();\n            while ( i.hasNext() ) {\n                final Map.Entry<String, List<InventoryPrinterAdapter>> entry = i.next();\n                final Iterator<InventoryPrinterAdapter> iter = entry.getValue().iterator();\n                boolean removed = false;\n                while ( iter.hasNext() ) {\n                    final InventoryPrinterAdapter adapter = iter.next();\n                    if ( adapter.getDescription().getServiceReference().compareTo(reference) == 0 ) {\n                        iter.remove();\n                        removed = true;\n                        break;\n                    }\n                }\n                if ( removed ) {\n                    if ( entry.getValue().size() == 0 ) {\n                        i.remove();\n                    }\n                    break;\n                }\n            }\n        }\n        final Iterator<InventoryPrinterAdapter> iter = this.usedAdapters.iterator();\n        while ( iter.hasNext() ) {\n            final InventoryPrinterAdapter adapter = iter.next();\n            if ( adapter.getDescription().getServiceReference().compareTo(reference) == 0 ) {\n                iter.remove();\n                adapter.unregisterConsole();\n                break;\n            }\n        }\n    }","id":104619,"modified_method":"private void removeService(final ServiceReference reference) {\n        synchronized ( this.allAdapters ) {\n            final Iterator i = this.allAdapters.entrySet().iterator();\n            while ( i.hasNext() ) {\n                final Map.Entry entry = (Entry) i.next();\n                final Iterator iter = ((List) entry.getValue()).iterator();\n                boolean removed = false;\n                while ( iter.hasNext() ) {\n                    final InventoryPrinterAdapter adapter = (InventoryPrinterAdapter) iter.next();\n                    if ( adapter.getDescription().getServiceReference().compareTo(reference) == 0 ) {\n                        iter.remove();\n                        removed = true;\n                        break;\n                    }\n                }\n                if ( removed ) {\n                    if ( ((List)entry.getValue()).size() == 0 ) {\n                        i.remove();\n                    }\n                    break;\n                }\n            }\n        }\n        final Iterator iter = this.usedAdapters.iterator();\n        while ( iter.hasNext() ) {\n            final InventoryPrinterAdapter adapter = (InventoryPrinterAdapter) iter.next();\n            if ( adapter.getDescription().getServiceReference().compareTo(reference) == 0 ) {\n                iter.remove();\n                adapter.unregisterConsole();\n                break;\n            }\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterManager#getAllHandlers()\n     */\n    public InventoryPrinterHandler[] getAllHandlers() {\n        return this.usedAdapters.toArray(new InventoryPrinterHandler[this.usedAdapters.size()]);\n    }","id":104620,"modified_method":"/**\n     * Get all inventory printer handlers.\n     * @return A list of handlers - might be empty.\n     */\n    public InventoryPrinterHandler[] getAllHandlers() {\n        return (InventoryPrinterHandler[]) this.usedAdapters.toArray(new InventoryPrinterHandler[this.usedAdapters.size()]);\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterManager#getHandlers(org.apache.felix.inventory.PrinterMode)\n     */\n    public InventoryPrinterHandler[] getHandlers(final PrinterMode mode) {\n        final List<InventoryPrinterHandler> result = new ArrayList<InventoryPrinterHandler>();\n        for(final InventoryPrinterAdapter printer : this.usedAdapters) {\n            if ( printer.supports(mode) ) {\n                result.add(printer);\n            }\n        }\n        return result.toArray(new InventoryPrinterHandler[result.size()]);\n    }","id":104621,"modified_method":"/**\n     * Get all handlers supporting the mode.\n     * @return A list of handlers - might be empty.\n     */\n    public InventoryPrinterHandler[] getHandlers(final PrinterMode mode) {\n        final List result = new ArrayList();\n        final Iterator i = this.usedAdapters.iterator();\n        while ( i .hasNext() ) {\n            final InventoryPrinterAdapter printer = (InventoryPrinterAdapter) i.next();\n            if ( printer.supports(mode) ) {\n                result.add(printer);\n            }\n        }\n        return (InventoryPrinterHandler[]) result.toArray(new InventoryPrinterHandler[result.size()]);\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinterManager#getHandler(java.lang.String)\n     */\n    public InventoryPrinterHandler getHandler(final String name) {\n        for(final InventoryPrinterAdapter printer : this.usedAdapters) {\n            if ( name.equals(printer.getName()) ) {\n                return printer;\n            }\n        }\n        return null;\n    }","id":104622,"modified_method":"/**\n     * Return a handler for the unique name.\n     * @return The corresponding handler or <code>null<\/code>.\n     */\n    public InventoryPrinterHandler getHandler(final String name) {\n        final Iterator i = this.usedAdapters.iterator();\n        while ( i .hasNext() ) {\n            final InventoryPrinterAdapter printer = (InventoryPrinterAdapter) i.next();\n            if ( name.equals(printer.getName()) ) {\n                return printer;\n            }\n        }\n        return null;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"private void addAdapter(final InventoryPrinterAdapter adapter) {\n        InventoryPrinterAdapter removeAdapter = null;\n        InventoryPrinterAdapter addAdapter = null;\n\n        final String key = adapter.getName();\n        synchronized ( this.allAdapters ) {\n            List<InventoryPrinterAdapter> list = this.allAdapters.get(key);\n            final InventoryPrinterAdapter first;\n            if ( list == null ) {\n                list = new LinkedList<InventoryPrinterAdapter>();\n                this.allAdapters.put(key, list);\n                first = null;\n            } else {\n                first = list.get(0);\n            }\n            list.add(adapter);\n            Collections.sort(list, InventoryPrinterAdapter.RANKING_COMPARATOR);\n            if ( first != null ) {\n                if ( first != list.get(0) ) {\n                    // update\n                    removeAdapter = first;\n                    addAdapter = adapter;\n                }\n            } else {\n                // add\n                addAdapter = adapter;\n            }\n        }\n        if ( removeAdapter != null ) {\n            final Iterator<InventoryPrinterAdapter> i = this.usedAdapters.iterator();\n            while ( i.hasNext() ) {\n                if ( i.next() == removeAdapter ) {\n                    i.remove();\n                    break;\n                }\n            }\n            removeAdapter.unregisterConsole();\n        }\n        if ( addAdapter != null ) {\n            this.usedAdapters.add(addAdapter);\n            addAdapter.registerConsole(this.bundleContext, this);\n        }\n    }","id":104623,"modified_method":"private void addAdapter(final InventoryPrinterAdapter adapter) {\n        InventoryPrinterAdapter removeAdapter = null;\n        InventoryPrinterAdapter addAdapter = null;\n\n        final String key = adapter.getName();\n        synchronized ( this.allAdapters ) {\n            List list = (List) this.allAdapters.get(key);\n            final InventoryPrinterAdapter first;\n            if ( list == null ) {\n                list = new LinkedList();\n                this.allAdapters.put(key, list);\n                first = null;\n            } else {\n                first = (InventoryPrinterAdapter) list.get(0);\n            }\n            list.add(adapter);\n            Collections.sort(list, InventoryPrinterAdapter.RANKING_COMPARATOR);\n            if ( first != null ) {\n                if ( first != list.get(0) ) {\n                    // update\n                    removeAdapter = first;\n                    addAdapter = adapter;\n                }\n            } else {\n                // add\n                addAdapter = adapter;\n            }\n        }\n        if ( removeAdapter != null ) {\n            final Iterator i = this.usedAdapters.iterator();\n            while ( i.hasNext() ) {\n                if ( i.next() == removeAdapter ) {\n                    i.remove();\n                    break;\n                }\n            }\n            removeAdapter.unregisterConsole();\n        }\n        if ( addAdapter != null ) {\n            this.usedAdapters.add(addAdapter);\n            addAdapter.registerConsole(this.bundleContext, this);\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Creates a new object and adds self as a bundle listener\n     *\n     * @param bundleContext the bundle context of the Web Console.\n     */\n    public ResourceBundleManager( final BundleContext bundleContext )\n    {\n        this.bundleContext = bundleContext;\n        this.resourceBundleCaches = new HashMap<Long, ResourceBundle>();\n\n        bundleContext.addBundleListener( this );\n    }","id":104624,"modified_method":"/**\n     * Creates a new object and adds self as a bundle listener\n     *\n     * @param bundleContext the bundle context of the Web Console.\n     */\n    public ResourceBundleManager( final BundleContext bundleContext )\n    {\n        this.bundleContext = bundleContext;\n        this.resourceBundleCaches = new HashMap();\n\n        bundleContext.addBundleListener( this );\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * This method is used to retrieve a /cached/ instance of the i18n resource associated\n     * with a given bundle.\n     *\n     * @param provider the bundle, provider of the resources\n     * @param locale the requested locale.\n     */\n    public ResourceBundle getResourceBundle( final Bundle provider ) {\n        ResourceBundle cache;\n        final Long key = new Long( provider.getBundleId() );\n        synchronized ( resourceBundleCaches ) {\n            cache = resourceBundleCaches.get( key );\n            if ( cache == null && !resourceBundleCaches.containsKey(key)) {\n                cache = this.loadResourceBundle(provider);\n                resourceBundleCaches.put( key, cache );\n            }\n        }\n\n        return cache;\n    }","id":104625,"modified_method":"/**\n     * This method is used to retrieve a /cached/ instance of the i18n resource associated\n     * with a given bundle.\n     *\n     * @param provider the bundle, provider of the resources\n     * @param locale the requested locale.\n     */\n    public ResourceBundle getResourceBundle( final Bundle provider ) {\n        ResourceBundle cache;\n        final Long key = new Long( provider.getBundleId() );\n        synchronized ( resourceBundleCaches ) {\n            cache = (ResourceBundle) resourceBundleCaches.get( key );\n            if ( cache == null && !resourceBundleCaches.containsKey(key)) {\n                cache = this.loadResourceBundle(provider);\n                resourceBundleCaches.put( key, cache );\n            }\n        }\n\n        return cache;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"private final void remove(final ServiceReference reference) {\n        final ServiceRegistration reg;\n        synchronized ( this.registrations ) {\n            reg = this.registrations.remove(reference);\n        }\n        if ( reg != null ) {\n            reg.unregister();\n        }\n    }","id":104626,"modified_method":"private final void remove(final ServiceReference reference) {\n        final ServiceRegistration reg;\n        synchronized ( this.registrations ) {\n            reg = (ServiceRegistration) this.registrations.remove(reference);\n        }\n        if ( reg != null ) {\n            reg.unregister();\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"public void add(final ServiceReference reference, final Object service) {\n        final ConfigurationPrinterAdapter cpa = ConfigurationPrinterAdapter.createAdapter(service, reference);\n        if ( cpa != null && cpa.title != null ) {\n            if ( cpa.title.startsWith(\"%\") ) {\n                final String key = cpa.title.substring(1);\n                final ResourceBundle rb = this.rbManager.getResourceBundle(reference.getBundle());\n                if ( rb == null || !rb.containsKey(key) ) {\n                    cpa.title = key;\n                } else {\n                    cpa.title = rb.getString(key);\n                }\n            }\n            if ( cpa.label == null ) {\n                cpa.label = cpa.title;\n            }\n            final Dictionary<String, Object> props = new Hashtable<String, Object>();\n            props.put(InventoryPrinter.CONFIG_NAME, cpa.label);\n            props.put(InventoryPrinter.CONFIG_TITLE, cpa.title);\n            props.put(InventoryPrinter.CONFIG_PRINTER_MODES, cpa.getPrinterModes());\n\n            if ( reference.getProperty(ConsoleConstants.PLUGIN_CATEGORY) != null ) {\n                props.put(InventoryPrinter.CONFIG_CATEGORY, reference.getProperty(ConsoleConstants.PLUGIN_CATEGORY));\n            }\n            final ServiceRegistration reg = this.bundleContext.registerService(InventoryPrinter.class.getName(), new ZipAttachmentProvider() {\n\n                /**\n                 * @see org.apache.felix.inventory.InventoryPrinter#print(org.apache.felix.inventory.PrinterMode, java.io.PrintWriter)\n                 */\n                public void print(final PrinterMode mode, final PrintWriter printWriter) {\n                    final String m;\n                    if ( mode == PrinterMode.HTML_BODY ) {\n                        m = ConsoleConstants.MODE_WEB;\n                    } else if ( mode == PrinterMode.TEXT ) {\n                        m = ConsoleConstants.MODE_TXT;\n                    } else if ( mode == PrinterMode.ZIP_FILE_TEXT ) {\n                        m = ConsoleConstants.MODE_ZIP;\n                    } else {\n                        m = null;\n                    }\n                    if ( m != null ) {\n                        cpa.printConfiguration(printWriter, m);\n                    }\n                }\n\n                /**\n                 * @see org.apache.felix.inventory.ZipAttachmentProvider#addAttachments(java.lang.String, java.util.zip.ZipOutputStream)\n                 */\n                public void addAttachments(final String namePrefix, final ZipOutputStream zos)\n                throws IOException {\n                    final URL[] attachments = cpa.getAttachments();\n                    if ( attachments != null ) {\n                        for(final URL current : attachments) {\n                            final String path = current.getPath();\n                            final String name;\n                            if ( path == null || path.length() == 0 ) {\n                                // sanity code, we should have a path, but if not let's\n                                // just create some random name\n                                name = \"file\" + Double.doubleToLongBits( Math.random() );\n                            } else {\n                                final int pos = path.lastIndexOf('/');\n                                name = (pos == -1 ? path : path.substring(pos + 1));\n                            }\n                            final ZipEntry entry = new ZipEntry(namePrefix + name);\n                            zos.putNextEntry(entry);\n                            final InputStream is = current.openStream();\n                            try {\n                                byte[] buffer = new byte[4096];\n                                int n = 0;\n                                while (-1 != (n = is.read(buffer))) {\n                                    zos.write(buffer, 0, n);\n                                }\n                            } finally {\n                                if ( is != null ) {\n                                    try { is.close(); } catch (final IOException ignore) {}\n                                }\n                            }\n                            zos.closeEntry();\n                        }\n                    }\n                }\n\n            }, props);\n            synchronized ( this.registrations ) {\n                this.registrations.put(reference, reg);\n            }\n        }\n    }","id":104627,"modified_method":"private void add(final ServiceReference reference, final Object service) {\n        final ConfigurationPrinterAdapter cpa = ConfigurationPrinterAdapter.createAdapter(service, reference);\n        if ( cpa != null && cpa.title != null ) {\n            if ( cpa.title.startsWith(\"%\") ) {\n                final String key = cpa.title.substring(1);\n                final ResourceBundle rb = this.rbManager.getResourceBundle(reference.getBundle());\n                if ( rb == null || !rb.containsKey(key) ) {\n                    cpa.title = key;\n                } else {\n                    cpa.title = rb.getString(key);\n                }\n            }\n            if ( cpa.label == null ) {\n                cpa.label = cpa.title;\n            }\n            final Dictionary props = new Hashtable();\n            props.put(InventoryPrinter.CONFIG_NAME, cpa.label);\n            props.put(InventoryPrinter.CONFIG_TITLE, cpa.title);\n            props.put(InventoryPrinter.CONFIG_PRINTER_MODES, cpa.getPrinterModes());\n\n            final ServiceRegistration reg = this.bundleContext.registerService(InventoryPrinter.class.getName(), new WebConsolePrinter(cpa), props);\n            synchronized ( this.registrations ) {\n                this.registrations.put(reference, reg);\n            }\n        }\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Dispose this service\n     */\n    public void dispose() {\n        this.cfgPrinterTracker.close();\n        synchronized ( this.registrations ) {\n            for(final ServiceRegistration reg : this.registrations.values()) {\n                reg.unregister();\n            }\n            this.registrations.clear();\n        }\n        this.rbManager.dispose();\n    }","id":104628,"modified_method":"/**\n     * Dispose this service\n     */\n    public void dispose() {\n        this.cfgPrinterTracker.close();\n        final List regs = new ArrayList();\n        synchronized ( this.registrations ) {\n            regs.addAll( this.registrations.values() );\n            this.registrations.clear();\n        }\n        final Iterator i = regs.iterator();\n        while (i.hasNext()) {\n            final ServiceRegistration reg = (ServiceRegistration) i.next();\n            reg.unregister();\n        }\n        this.rbManager.dispose();\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Constructor\n     * @param inventoryPrinterManager The inventory printer manager.\n     * @param printerName The name of the printer this plugin is displaying.\n     */\n    WebConsolePlugin(final InventoryPrinterManager inventoryPrinterManager,\n            final String printerName) {\n        super(inventoryPrinterManager);\n        this.printerName = printerName;\n    }","id":104629,"modified_method":"/**\n     * Constructor\n     * @param inventoryPrinterManager The inventory printer manager.\n     * @param printerName The name of the printer this plugin is displaying.\n     */\n    WebConsolePlugin(final InventoryPrinterManagerImpl inventoryPrinterManager,\n            final String printerName) {\n        super(inventoryPrinterManager);\n        this.printerName = printerName;\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"public static ServiceRegistration register(\n            final BundleContext context,\n            final InventoryPrinterManager manager,\n            final InventoryPrinterDescription desc) {\n        final Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(ConsoleConstants.PLUGIN_LABEL, \"inventory-\" + desc.getName());\n        props.put(ConsoleConstants.PLUGIN_TITLE, desc.getTitle());\n        props.put(ConsoleConstants.PLUGIN_CATEGORY, desc.getCategory() == null ? \"Inventory\" : desc.getCategory());\n        return context.registerService(ConsoleConstants.INTERFACE_SERVLET, new ServiceFactory() {\n\n            public void ungetService(final Bundle bundle, final ServiceRegistration registration,\n                    final Object service) {\n                // nothing to do\n            }\n\n            public Object getService(final Bundle bundle, final ServiceRegistration registration) {\n                return new WebConsolePlugin(manager, desc.getName());\n            }\n\n        }, props);\n\n    }","id":104630,"modified_method":"public static ServiceRegistration register(\n            final BundleContext context,\n            final InventoryPrinterManagerImpl manager,\n            final InventoryPrinterDescription desc) {\n        final Dictionary props = new Hashtable();\n        props.put(ConsoleConstants.PLUGIN_LABEL, \"status-\" + desc.getName());\n        props.put(ConsoleConstants.PLUGIN_TITLE, desc.getTitle());\n        props.put(ConsoleConstants.PLUGIN_CATEGORY, ConsoleConstants.WEB_CONSOLE_CATEGORY);\n        return context.registerService(ConsoleConstants.INTERFACE_SERVLET, new ServiceFactory() {\n\n            public void ungetService(final Bundle bundle, final ServiceRegistration registration,\n                    final Object service) {\n                // nothing to do\n            }\n\n            public Object getService(final Bundle bundle, final ServiceRegistration registration) {\n                return new WebConsolePlugin(manager, desc.getName());\n            }\n\n        }, props);\n\n    }","commit_id":"3f44fc0b5e03fcbdf684f7cc3e9cb007e58ce6b6","url":"https://github.com/apache/felix"},{"original_method":"public static void main(String[] args) throws Exception\n    {\n        // allow access to everything\n        System.setSecurityManager(null);\n\n        // optional: the name of another class with a main method\n        // that should be started in the same JVM:\n        String chainMain = System.getProperty(\"chain.main.class\");\n        if(chainMain != null)\n        {\n            // optional: a space-separated list of arguments to be passed\n            // to the chained main() method:\n            String chainArgs = System.getProperty(\"chain.main.args\");\n            if(chainArgs == null)\n            {\n                chainArgs = \"\";\n            }\n            final String[] _chainArgs = chainArgs.split(\"\\\\s\");\n            try\n            {\n                Class c = Class.forName(chainMain);\n                final Method m = c.getMethod(\"main\", _chainArgs.getClass());\n                new Thread()\n                {\n                    public void run()\n                    {\n                        try\n                        {\n                            m.invoke(null, new Object[]{_chainArgs});\n                        }\n                        catch (Exception ex)\n                        {\n                            ex.printStackTrace();\n                            System.err.println(\"Exception running the \" +\n                               \"chained main class, will continue anyway.\");\n                        }\n                    }\n                }.start();\n            }\n            catch (Exception ex)\n            {\n                ex.printStackTrace();\n                System.err.println(\"Exception finding the chained main \" +\n                    \"class, will continue anyway.\");\n            }\n        }\n\n        // prepare the logger\n        // needed by the FileHandler-Logger\n        SIPCommunicator.setScHomeDir(System.getProperty(\"os.name\"));\n        LogManager.getLogManager()\n            .readConfiguration(\n                SIPCommunicatorJWS.class\n                    .getResourceAsStream(\"/logging.properties\"));\n\n        Handler[] hs = LogManager.getLogManager().getLogger(\"\").getHandlers();\n        for (int i = 0; i < hs.length; i++)\n            LogManager.getLogManager().getLogger(\"\").removeHandler(hs[i]);\n        LogManager.getLogManager().getLogger(\"\").addHandler(new FileHandler());\n        LogManager.getLogManager().getLogger(\"\")\n            .addHandler(new ConsoleHandler());\n        for (Handler h : LogManager.getLogManager().getLogger(\"\").getHandlers())\n            h.setFormatter(new ScLogFormatter());\n\n        // be evil :-)\n        // find the path of the nativelibs under webstart (findLibrary is\n        // protected and therefore at least documented api)\n        Method findLibrary =\n            SIPCommunicatorJWS.class.getClassLoader().getClass()\n                .getDeclaredMethod(\"findLibrary\", String.class);\n        findLibrary.setAccessible(true);\n        File path =\n            new File((String) findLibrary.invoke(\n                SIPCommunicatorJWS.class.getClassLoader(), \"hid\"))\n                .getParentFile();\n        System.setProperty(\n            \"java.library.path\",\n            System.getProperty(\"java.library.path\") + File.pathSeparator\n                + path.getAbsolutePath());\n\n        // reset sys_paths to re-read usr_paths (runtime-dependent and therefore\n        // very very ugly :()\n        Field sys_paths = ClassLoader.class.getDeclaredField(\"sys_paths\");\n        sys_paths.setAccessible(true);\n        sys_paths.set(null, null);\n\n        // prepare the felix-config with the absolute paths\n        Properties pIn = new Properties();\n        Properties pOut = new Properties();\n        pIn.load(SIPCommunicatorJWS.class.getResourceAsStream(System\n            .getProperty(\"felix.config.properties\")));\n\n        String baseServerUrl =\n            System.getProperty(\"net.java.sip.communicator.SC_JWS_BASEDIR\");\n        ClassLoader cl = SIPCommunicatorJWS.class.getClassLoader();\n        Method getJarFile =\n            cl.getClass().getDeclaredMethod(\"getJarFile\", URL.class);\n        getJarFile.setAccessible(true);\n        for (Map.Entry<Object, Object> e : pIn.entrySet())\n        {\n            if (((String) e.getKey()).startsWith(\"felix.auto.start.\"))\n            {\n                String[] refs = ((String) e.getValue()).split(\"\\\\s\");\n                StringBuilder sb = new StringBuilder();\n                for (String ref : refs)\n                {\n                    JarFile localFile =\n                        (JarFile) getJarFile.invoke(cl, new URL(baseServerUrl\n                            + ref.replace(\"@URL@\", \"\")));\n                    if (localFile != null)\n                    {\n                        String localFileName =\n                            new File(localFile.getName()).toURI().toString();\n                        sb.append(\"reference:\");\n                        sb.append(localFileName);\n                        sb.append(\" \");\n                    }\n                    else\n                    {\n                        throw new Exception(\"ref <\" + ref\n                            + \"> not found in cache\");\n                    }\n                }\n                pOut.put(e.getKey(), sb.toString());\n            }\n            else\n            {\n                pOut.put(e.getKey(), e.getValue());\n            }\n        }\n        File jwsFelixConfig = File.createTempFile(\"jws\", \".properties\");\n        jwsFelixConfig.deleteOnExit();\n        pOut.store(new FileOutputStream(jwsFelixConfig),\n            \"--- autogenerated, do not edit! ---\");\n        System.setProperty(\"felix.config.properties\", jwsFelixConfig.toURI()\n            .toString());\n\n        // Workaround broken desktop shortcut in ubuntu linux:\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6957030\n        try\n        {\n            if (System.getProperty(\"os.name\").equals(\"Linux\"))\n            {\n                File desktop =\n                    new File(System.getProperty(\"user.home\") + \"/Desktop\");\n                File[] files = desktop.listFiles();\n                for (File file : files)\n                {\n                    if (file.getName().contains(\"jws_app_shortcut_\"))\n                    {\n                        file.setExecutable(true, false);\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n        }\n\n        // Handle the \"-open\" argument from the javaws command line\n        Vector<String> _args = new Vector<String>();\n        for(int i = 0; i < args.length ; i++)\n        {\n            String arg = args[i];\n            if(arg.equalsIgnoreCase(\"-open\"))\n            {\n                // are we at the last argument or is the next value\n                // some other option flag?\n                if(i == (args.length - 1) ||\n                    (args[i+1].length() > 0 &&\n                        \"-/\".indexOf(args[i+1].charAt(0))>=0))\n                {\n                    // invalid, can't use \"-open\" as final argument\n                    System.err.println(\"Command line argument '-open'\"\n                        + \" requires a parameter, usually a URI\");\n                    System.exit(1);\n                }\n            }\n            else\n            {\n                _args.add(arg);\n            }\n        }\n\n        // launch the original app\n        SIPCommunicator.main(_args.toArray(new String[] {}));\n    }","id":104631,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        // allow access to everything\n        System.setSecurityManager(null);\n\n        // optional: the name of another class with a main method\n        // that should be started in the same JVM:\n        String chainMain = System.getProperty(\"chain.main.class\");\n        if(chainMain != null)\n        {\n            // optional: a space-separated list of arguments to be passed\n            // to the chained main() method:\n            String chainArgs = System.getProperty(\"chain.main.args\");\n            if(chainArgs == null)\n            {\n                chainArgs = \"\";\n            }\n            final String[] _chainArgs = chainArgs.split(\"\\\\s\");\n            try\n            {\n                Class c = Class.forName(chainMain);\n                final Method m = c.getMethod(\"main\",\n                    new Class[] {_chainArgs.getClass()});\n                new Thread()\n                {\n                    public void run()\n                    {\n                        try\n                        {\n                            m.invoke(null, new Object[]{_chainArgs});\n                        }\n                        catch (Exception ex)\n                        {\n                            ex.printStackTrace();\n                            System.err.println(\"Exception running the \" +\n                               \"chained main class, will continue anyway.\");\n                        }\n                    }\n                }.start();\n            }\n            catch (Exception ex)\n            {\n                ex.printStackTrace();\n                System.err.println(\"Exception finding the chained main \" +\n                    \"class, will continue anyway.\");\n            }\n        }\n\n        // prepare the logger\n        // needed by the FileHandler-Logger\n        SIPCommunicator.setScHomeDir(System.getProperty(\"os.name\"));\n        LogManager.getLogManager()\n            .readConfiguration(\n                SIPCommunicatorJWS.class\n                    .getResourceAsStream(\"/logging.properties\"));\n\n        Handler[] hs = LogManager.getLogManager().getLogger(\"\").getHandlers();\n        for (int i = 0; i < hs.length; i++)\n            LogManager.getLogManager().getLogger(\"\").removeHandler(hs[i]);\n        LogManager.getLogManager().getLogger(\"\").addHandler(new FileHandler());\n        LogManager.getLogManager().getLogger(\"\")\n            .addHandler(new ConsoleHandler());\n\n        Handler[] h = LogManager.getLogManager().getLogger(\"\").getHandlers();\n        for (int i = 0; i < h.length; i++)\n            h[i].setFormatter(new ScLogFormatter());\n\n        // be evil :-)\n        // find the path of the nativelibs under webstart (findLibrary is\n        // protected and therefore at least documented api)\n        Method findLibrary =\n            SIPCommunicatorJWS.class.getClassLoader().getClass()\n                .getDeclaredMethod(\"findLibrary\", new Class[] {String.class});\n        findLibrary.setAccessible(true);\n        File path =\n            new File((String) findLibrary.invoke(\n                SIPCommunicatorJWS.class.getClassLoader(),\n                new Object[] {\"hid\"})).getParentFile();\n        System.setProperty(\n            \"java.library.path\",\n            System.getProperty(\"java.library.path\") + File.pathSeparator\n                + path.getAbsolutePath());\n\n        // reset sys_paths to re-read usr_paths (runtime-dependent and therefore\n        // very very ugly :()\n        Field sys_paths = ClassLoader.class.getDeclaredField(\"sys_paths\");\n        sys_paths.setAccessible(true);\n        sys_paths.set(null, null);\n\n        // prepare the felix-config with the absolute paths\n        Properties pIn = new Properties();\n        Properties pOut = new Properties();\n        pIn.load(SIPCommunicatorJWS.class.getResourceAsStream(System\n            .getProperty(\"felix.config.properties\")));\n\n        String baseServerUrl =\n            System.getProperty(\"net.java.sip.communicator.SC_JWS_BASEDIR\");\n        ClassLoader cl = SIPCommunicatorJWS.class.getClassLoader();\n        Method getJarFile =\n            cl.getClass().getDeclaredMethod(\"getJarFile\",\n                new Class[] {URL.class});\n        getJarFile.setAccessible(true);\n\n        Iterator propIt = pIn.entrySet().iterator();\n        while (propIt.hasNext())\n        {\n            Map.Entry e = (Map.Entry) propIt.next();\n            if (((String) e.getKey()).startsWith(\"felix.auto.start.\"))\n            {\n                String[] refs = ((String) e.getValue()).split(\"\\\\s\");\n                StringBuilder sb = new StringBuilder();\n                for (int i = 0; i < refs.length; i++)\n                {\n                    String ref = refs[i];\n                    JarFile localFile =\n                        (JarFile) getJarFile.invoke(cl, new Object[] {\n                            new URL(baseServerUrl + ref.replace(\"@URL@\", \"\"))});\n                    if (localFile != null)\n                    {\n                        String localFileName =\n                            new File(localFile.getName()).toURI().toString();\n                        sb.append(\"reference:\");\n                        sb.append(localFileName);\n                        sb.append(\" \");\n                    }\n                    else\n                    {\n                        throw new Exception(\"ref <\" + ref\n                            + \"> not found in cache\");\n                    }\n                }\n                pOut.put(e.getKey(), sb.toString());\n            }\n            else\n            {\n                pOut.put(e.getKey(), e.getValue());\n            }\n        }\n        File jwsFelixConfig = File.createTempFile(\"jws\", \".properties\");\n        jwsFelixConfig.deleteOnExit();\n        pOut.store(new FileOutputStream(jwsFelixConfig),\n            \"--- autogenerated, do not edit! ---\");\n        System.setProperty(\"felix.config.properties\", jwsFelixConfig.toURI()\n            .toString());\n\n        // Workaround broken desktop shortcut in ubuntu linux:\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6957030\n        try\n        {\n            if (System.getProperty(\"os.name\").equals(\"Linux\"))\n            {\n                File desktop =\n                    new File(System.getProperty(\"user.home\") + \"/Desktop\");\n                File[] files = desktop.listFiles();\n                for (int i = 0; i < files.length; i++)\n                {\n                    File file = files[i];\n                    if (file.getName().contains(\"jws_app_shortcut_\"))\n                    {\n                        file.setExecutable(true, false);\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n        }\n\n        // Handle the \"-open\" argument from the javaws command line\n        Vector _args = new Vector();\n        for(int i = 0; i < args.length ; i++)\n        {\n            String arg = args[i];\n            if(arg.equalsIgnoreCase(\"-open\"))\n            {\n                // are we at the last argument or is the next value\n                // some other option flag?\n                if(i == (args.length - 1) ||\n                    (args[i+1].length() > 0 &&\n                        \"-/\".indexOf(args[i+1].charAt(0))>=0))\n                {\n                    // invalid, can't use \"-open\" as final argument\n                    System.err.println(\"Command line argument '-open'\"\n                        + \" requires a parameter, usually a URI\");\n                    System.exit(1);\n                }\n            }\n            else\n            {\n                _args.add(arg);\n            }\n        }\n\n        // launch the original app\n        SIPCommunicator.main((String[])_args.toArray(new String[_args.size()]));\n    }","commit_id":"e0887ceb8e9ecb8e4318b02c610e27a5cf57f251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        log.debugf(\"Starting Mod_cluster Extension\");\n\n        config = new ModClusterConfig();\n        // Set the configuration.\n        final ModelNode proxyconf = modelconf.get(CommonAttributes.PROXY_CONF);\n        final ModelNode httpdconf = proxyconf.get(CommonAttributes.HTTPD_CONF);\n        final ModelNode nodeconf = proxyconf.get(CommonAttributes.NODES_CONF);\n\n        // Check that Advertise could work.\n        boolean defaultavert = false;\n        try {\n            for (Enumeration<NetworkInterface> ni = NetworkInterface.getNetworkInterfaces(); ni.hasMoreElements();) {\n                NetworkInterface intf = ni.nextElement();\n                if (intf.isUp() && intf.supportsMulticast())\n                    defaultavert = true;\n             }\n        } catch (SocketException e) {\n            // Ignore it.\n        }\n\n\n        // Set some defaults...\n        if (!httpdconf.hasDefined(CommonAttributes.PROXY_LIST)) {\n            config.setAdvertise(defaultavert);\n        }\n        config.setAdvertisePort(23364);\n        config.setAdvertiseGroupAddress(\"224.0.1.105\");\n        config.setAutoEnableContexts(true);\n        config.setStopContextTimeout(10);\n        config.setSocketTimeout(20000);\n\n        // Read node to set configuration.\n        if (httpdconf.hasDefined(CommonAttributes.ADVERTISE_SOCKET)) {\n            // TODO: That should be a socket-binding....\n            config.setAdvertisePort(23364);\n            config.setAdvertiseGroupAddress(\"224.0.1.105\");\n            if (!defaultavert)\n                log.error(\"Mod_cluster requires Advertise but Multicast interface is not available\");\n            config.setAdvertise(true);\n        }\n        if (httpdconf.hasDefined(CommonAttributes.SSL)) {\n            // Add SSL configuration.\n            config.setSsl(true);\n            final ModelNode ssl = httpdconf.get(CommonAttributes.SSL);\n            if (ssl.has(CommonAttributes.KEY_ALIAS))\n                config.setSslKeyAlias(ssl.get(CommonAttributes.KEY_ALIAS).asString());\n            if (ssl.has(CommonAttributes.PASSWORD)) {\n                config.setSslTrustStorePassword(ssl.get(CommonAttributes.PASSWORD).asString());\n                config.setSslKeyStorePassword(ssl.get(CommonAttributes.PASSWORD).asString());\n            }\n            if (ssl.has(CommonAttributes.CERTIFICATE_KEY_FILE))\n                config.setSslKeyStore(ssl.get(CommonAttributes.CERTIFICATE_KEY_FILE).asString());\n            if (ssl.has(CommonAttributes.CIPHER_SUITE))\n                config.setSslCiphers(ssl.get(CommonAttributes.CIPHER_SUITE).asString());\n            if (ssl.has(CommonAttributes.PROTOCOL))\n                config.setSslKeyAlias(ssl.get(CommonAttributes.PROTOCOL).asString());\n            if (ssl.has(CommonAttributes.CA_CERTIFICATE_FILE))\n                config.setSslTrustStore(ssl.get(CommonAttributes.CA_CERTIFICATE_FILE).asString());\n            if (ssl.has(CommonAttributes.CA_REVOCATION_URL))\n                config.setSslCrlFile(ssl.get(CommonAttributes.CA_REVOCATION_URL).asString());\n        }\n        if (httpdconf.hasDefined(CommonAttributes.ADVERTISE))\n            config.setAdvertise(httpdconf.get(CommonAttributes.ADVERTISE).asBoolean());\n        if (httpdconf.hasDefined(CommonAttributes.PROXY_LIST)) {\n            config.setProxyList(httpdconf.get(CommonAttributes.PROXY_LIST).asString());\n        }\n        if (httpdconf.hasDefined(CommonAttributes.PROXY_URL))\n            config.setProxyList(httpdconf.get(CommonAttributes.PROXY_URL).asString());\n        if (httpdconf.has(CommonAttributes.ADVERTISE_SECURITY_KEY))\n            config.setProxyList(httpdconf.get(CommonAttributes.ADVERTISE_SECURITY_KEY).asString());\n\n        if (nodeconf.hasDefined(CommonAttributes.EXCLUDED_CONTEXTS))\n            config.setExcludedContexts(nodeconf.get(CommonAttributes.EXCLUDED_CONTEXTS).asString());\n        if (nodeconf.hasDefined(CommonAttributes.AUTO_ENABLE_CONTEXTS))\n            config.setAutoEnableContexts(nodeconf.get(CommonAttributes.AUTO_ENABLE_CONTEXTS).asBoolean());\n        if (nodeconf.hasDefined(CommonAttributes.STOP_CONTEXT_TIMEOUT)) {\n            config.setStopContextTimeout(nodeconf.get(CommonAttributes.SOCKET_TIMEOUT).asInt());\n            config.setStopContextTimeoutUnit(TimeUnit.SECONDS);\n        }\n        if (nodeconf.hasDefined(CommonAttributes.SOCKET_TIMEOUT))\n            config.setSocketTimeout(nodeconf.get(CommonAttributes.SOCKET_TIMEOUT).asInt());\n\n        // Read the metrics configuration.\n        final ModelNode loadmetric = modelconf.get(CommonAttributes.LOAD_METRIC);\n\n        if (loadmetric.hasDefined(CommonAttributes.SIMPLE_LOAD_PROVIDER)) {\n            // TODO it seems we don't support that stuff.\n            // LoadBalanceFactorProvider implementation, org.jboss.modcluster.load.impl.SimpleLoadBalanceFactorProvider.\n            final ModelNode node = loadmetric.get(CommonAttributes.SIMPLE_LOAD_PROVIDER);\n            SimpleLoadBalanceFactorProvider myload = new SimpleLoadBalanceFactorProvider();\n            myload.setLoadBalanceFactor(node.get(CommonAttributes.FACTOR).asInt(1));\n            load = myload;\n        }\n\n        Set<LoadMetric<LoadContext>> metrics = new HashSet<LoadMetric<LoadContext>>();\n        if (loadmetric.hasDefined(CommonAttributes.DYNAMIC_LOAD_PROVIDER)) {\n            final ModelNode node = loadmetric.get(CommonAttributes.DYNAMIC_LOAD_PROVIDER);\n            int decayFactor = node.get(CommonAttributes.DECAY).asInt(512);\n            int history = node.get(CommonAttributes.HISTORY).asInt(512);\n            // We should have bunch of load-metric and/or custom-load-metric here.\n            // TODO read the child nodes or what ....String nodes = node.\n            if (node.hasDefined(CommonAttributes.LOAD_METRIC)) {\n                final ModelNode nodemetric = node.get(CommonAttributes.LOAD_METRIC);\n                final List<ModelNode> array = nodemetric.asList();\n                addLoadMetrics(metrics, array);\n             }\n            if (node.hasDefined(CommonAttributes.CUSTOM_LOAD_METRIC)) {\n                final ModelNode nodemetric = node.get(CommonAttributes.CUSTOM_LOAD_METRIC);\n                final List<ModelNode> array = nodemetric.asList();\n                addCustomLoadMetrics(metrics, array);\n\n            }\n            if (!metrics.isEmpty()) {\n                DynamicLoadBalanceFactorProvider loader = new DynamicLoadBalanceFactorProvider(metrics);\n                loader.setDecayFactor(decayFactor);\n                loader.setHistory(history);\n                load = loader;\n            }\n        }\n\n        if (load == null) {\n            // Use a default one...\n            log.info(\"Mod_cluster uses default load balancer provider\");\n            SimpleLoadBalanceFactorProvider myload = new SimpleLoadBalanceFactorProvider();\n            myload.setLoadBalanceFactor(1);\n            load = myload;\n        }\n        service = new org.jboss.modcluster.ModClusterService(config, load);\n        adapter = new CatalinaEventHandlerAdapter(service, webServer.getValue().getServer(), webServer.getValue().getService());\n        try {\n            adapter.start();\n        } catch (JMException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","id":104632,"modified_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        log.debugf(\"Starting Mod_cluster Extension\");\n\n        config = new ModClusterConfig();\n        // Set the configuration.\n\n        // Check that Advertise could work.\n        boolean defaultavert = false;\n        try {\n            for (Enumeration<NetworkInterface> ni = NetworkInterface.getNetworkInterfaces(); ni.hasMoreElements();) {\n                NetworkInterface intf = ni.nextElement();\n                if (intf.isUp() && intf.supportsMulticast())\n                    defaultavert = true;\n             }\n        } catch (SocketException e) {\n            // Ignore it.\n        }\n\n\n        // Set some defaults...\n        if (!modelconf.hasDefined(CommonAttributes.PROXY_LIST)) {\n            config.setAdvertise(defaultavert);\n        }\n        config.setAdvertisePort(23364);\n        config.setAdvertiseGroupAddress(\"224.0.1.105\");\n        config.setAutoEnableContexts(true);\n        config.setStopContextTimeout(10);\n        config.setSocketTimeout(20000);\n\n        // Read node to set configuration.\n        if (modelconf.hasDefined(CommonAttributes.ADVERTISE_SOCKET)) {\n            // There should be a socket-binding....\n            final SocketBinding binding = this.binding.getValue();\n            if (binding != null) {\n                config.setAdvertisePort(binding.getMulticastPort());\n                config.setAdvertiseGroupAddress(binding.getMulticastSocketAddress().getHostName());\n                if (!defaultavert)\n                    log.error(\"Mod_cluster requires Advertise but Multicast interface is not available\");\n                config.setAdvertise(true);\n            }\n        }\n        if (modelconf.hasDefined(CommonAttributes.SSL)) {\n            // Add SSL configuration.\n            config.setSsl(true);\n            final ModelNode ssl = modelconf.get(CommonAttributes.SSL);\n            if (ssl.has(CommonAttributes.KEY_ALIAS))\n                config.setSslKeyAlias(ssl.get(CommonAttributes.KEY_ALIAS).asString());\n            if (ssl.has(CommonAttributes.PASSWORD)) {\n                config.setSslTrustStorePassword(ssl.get(CommonAttributes.PASSWORD).asString());\n                config.setSslKeyStorePassword(ssl.get(CommonAttributes.PASSWORD).asString());\n            }\n            if (ssl.has(CommonAttributes.CERTIFICATE_KEY_FILE))\n                config.setSslKeyStore(ssl.get(CommonAttributes.CERTIFICATE_KEY_FILE).asString());\n            if (ssl.has(CommonAttributes.CIPHER_SUITE))\n                config.setSslCiphers(ssl.get(CommonAttributes.CIPHER_SUITE).asString());\n            if (ssl.has(CommonAttributes.PROTOCOL))\n                config.setSslKeyAlias(ssl.get(CommonAttributes.PROTOCOL).asString());\n            if (ssl.has(CommonAttributes.CA_CERTIFICATE_FILE))\n                config.setSslTrustStore(ssl.get(CommonAttributes.CA_CERTIFICATE_FILE).asString());\n            if (ssl.has(CommonAttributes.CA_REVOCATION_URL))\n                config.setSslCrlFile(ssl.get(CommonAttributes.CA_REVOCATION_URL).asString());\n        }\n        if (modelconf.hasDefined(CommonAttributes.ADVERTISE))\n            config.setAdvertise(modelconf.get(CommonAttributes.ADVERTISE).asBoolean());\n        if (modelconf.hasDefined(CommonAttributes.PROXY_LIST)) {\n            config.setProxyList(modelconf.get(CommonAttributes.PROXY_LIST).asString());\n        }\n        if (modelconf.hasDefined(CommonAttributes.PROXY_URL))\n            config.setProxyList(modelconf.get(CommonAttributes.PROXY_URL).asString());\n        if (modelconf.has(CommonAttributes.ADVERTISE_SECURITY_KEY))\n            config.setProxyList(modelconf.get(CommonAttributes.ADVERTISE_SECURITY_KEY).asString());\n\n        if (modelconf.hasDefined(CommonAttributes.EXCLUDED_CONTEXTS))\n            config.setExcludedContexts(modelconf.get(CommonAttributes.EXCLUDED_CONTEXTS).asString());\n        if (modelconf.hasDefined(CommonAttributes.AUTO_ENABLE_CONTEXTS))\n            config.setAutoEnableContexts(modelconf.get(CommonAttributes.AUTO_ENABLE_CONTEXTS).asBoolean());\n        if (modelconf.hasDefined(CommonAttributes.STOP_CONTEXT_TIMEOUT)) {\n            config.setStopContextTimeout(modelconf.get(CommonAttributes.SOCKET_TIMEOUT).asInt());\n            config.setStopContextTimeoutUnit(TimeUnit.SECONDS);\n        }\n        if (modelconf.hasDefined(CommonAttributes.SOCKET_TIMEOUT))\n            config.setSocketTimeout(modelconf.get(CommonAttributes.SOCKET_TIMEOUT).asInt());\n\n        // Read the metrics configuration.\n        final ModelNode loadmetric = modelconf.get(CommonAttributes.LOAD_METRIC);\n\n        if (loadmetric.hasDefined(CommonAttributes.SIMPLE_LOAD_PROVIDER)) {\n            // TODO it seems we don't support that stuff.\n            // LoadBalanceFactorProvider implementation, org.jboss.modcluster.load.impl.SimpleLoadBalanceFactorProvider.\n            final ModelNode node = loadmetric.get(CommonAttributes.SIMPLE_LOAD_PROVIDER);\n            SimpleLoadBalanceFactorProvider myload = new SimpleLoadBalanceFactorProvider();\n            myload.setLoadBalanceFactor(node.get(CommonAttributes.FACTOR).asInt(1));\n            load = myload;\n        }\n\n        Set<LoadMetric<LoadContext>> metrics = new HashSet<LoadMetric<LoadContext>>();\n        if (loadmetric.hasDefined(CommonAttributes.DYNAMIC_LOAD_PROVIDER)) {\n            final ModelNode node = loadmetric.get(CommonAttributes.DYNAMIC_LOAD_PROVIDER);\n            int decayFactor = node.get(CommonAttributes.DECAY).asInt(512);\n            int history = node.get(CommonAttributes.HISTORY).asInt(512);\n            // We should have bunch of load-metric and/or custom-load-metric here.\n            // TODO read the child nodes or what ....String nodes = node.\n            if (node.hasDefined(CommonAttributes.LOAD_METRIC)) {\n                final ModelNode nodemetric = node.get(CommonAttributes.LOAD_METRIC);\n                final List<ModelNode> array = nodemetric.asList();\n                addLoadMetrics(metrics, array);\n             }\n            if (node.hasDefined(CommonAttributes.CUSTOM_LOAD_METRIC)) {\n                final ModelNode nodemetric = node.get(CommonAttributes.CUSTOM_LOAD_METRIC);\n                final List<ModelNode> array = nodemetric.asList();\n                addCustomLoadMetrics(metrics, array);\n\n            }\n            if (!metrics.isEmpty()) {\n                DynamicLoadBalanceFactorProvider loader = new DynamicLoadBalanceFactorProvider(metrics);\n                loader.setDecayFactor(decayFactor);\n                loader.setHistory(history);\n                load = loader;\n            }\n        }\n\n        if (load == null) {\n            // Use a default one...\n            log.info(\"Mod_cluster uses default load balancer provider\");\n            SimpleLoadBalanceFactorProvider myload = new SimpleLoadBalanceFactorProvider();\n            myload.setLoadBalanceFactor(1);\n            load = myload;\n        }\n        service = new org.jboss.modcluster.ModClusterService(config, load);\n        adapter = new CatalinaEventHandlerAdapter(service, webServer.getValue().getServer(), webServer.getValue().getService());\n        try {\n            adapter.start();\n        } catch (JMException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","commit_id":"845b0c583e4f31be40c1d477534722fe6c65130f","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        try {\n            // Add mod_cluster service\n            final ModClusterService service = new ModClusterService(operation.get(CommonAttributes.MOD_CLUSTER_CONFIG).clone());\n            newControllers.add(context.getServiceTarget().addService(ModClusterService.NAME, service)\n                    // .addListener(new ResultHandler.ServiceStartListener(resultHandler))\n                    .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer())\n                    .addListener(verificationHandler)\n                    .setInitialMode(Mode.ACTIVE)\n                    .install());\n        } catch (Throwable t) {\n            log.error(\"Error: \" + t);\n            throw new OperationFailedException(new ModelNode().set(t.getLocalizedMessage()));\n        }\n    }","id":104633,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        String bindingRef = null;\n        if (operation.hasDefined(CommonAttributes.MOD_CLUSTER_CONFIG)) {\n            final ModelNode node = operation.get(CommonAttributes.MOD_CLUSTER_CONFIG);\n            if (node.hasDefined(CommonAttributes.ADVERTISE_SOCKET)) {\n                bindingRef = node.get(CommonAttributes.ADVERTISE_SOCKET).asString();\n            }\n        }\n        try {\n            // Add mod_cluster service\n            final ModClusterService service = new ModClusterService(operation.get(CommonAttributes.MOD_CLUSTER_CONFIG).clone());\n            final ServiceBuilder<ModCluster> serviceBuilder = context.getServiceTarget().addService(ModClusterService.NAME, service)\n                    // .addListener(new ResultHandler.ServiceStartListener(resultHandler))\n                    .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer())\n                    .addListener(verificationHandler)\n                    .setInitialMode(Mode.ACTIVE);\n             if (bindingRef != null)\n                serviceBuilder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding());\n\n            newControllers.add(serviceBuilder.install());\n        } catch (Throwable t) {\n            log.error(\"Error: \" + t);\n            throw new OperationFailedException(new ModelNode().set(t.getLocalizedMessage()));\n        }\n    }","commit_id":"845b0c583e4f31be40c1d477534722fe6c65130f","url":"https://github.com/wildfly/wildfly"},{"original_method":"private EJB3RemoteResourceDefinition() {\n        super(EJB3SubsystemModel.REMOTE_SERVICE_PATH,\n                EJB3Extension.getResourceDescriptionResolver(EJB3SubsystemModel.REMOTE),\n                EJB3RemoteServiceAdd.INSTANCE, EJB3RemoteServiceRemove.INSTANCE);\n    }","id":104634,"modified_method":"private EJB3RemoteResourceDefinition() {\n        super(EJB3SubsystemModel.REMOTE_SERVICE_PATH,\n                EJB3Extension.getResourceDescriptionResolver(EJB3SubsystemModel.REMOTE),\n                EJB3RemoteServiceAdd.INSTANCE, EJB3RemoteServiceRemove.INSTANCE,\n                // WFLY-3438\n                OperationEntry.Flag.RESTART_ALL_SERVICES, OperationEntry.Flag.RESTART_ALL_SERVICES);\n    }","commit_id":"3c8d9404cf4719d7b8db50a1012cf7e0144903f7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        newControllers.addAll(installRuntimeServices(context, model, verificationHandler));\n        // add ejb remote transactions repository service\n        final EJBRemoteTransactionsRepository transactionsRepository = new EJBRemoteTransactionsRepository();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceController<?> transactionRepositoryServiceController = serviceTarget.addService(EJBRemoteTransactionsRepository.SERVICE_NAME, transactionsRepository)\n                .addDependency(TransactionManagerService.SERVICE_NAME, TransactionManager.class, transactionsRepository.getTransactionManagerInjector())\n                .addDependency(UserTransactionService.SERVICE_NAME, UserTransaction.class, transactionsRepository.getUserTransactionInjector())\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER, RecoveryManagerService.class, transactionsRepository.getRecoveryManagerInjector())\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        newControllers.add(transactionRepositoryServiceController);\n\n        // Service responsible for tracking cancel() invocations on remote async method calls\n        final RemoteAsyncInvocationCancelStatusService asyncInvocationCancelStatusService = new RemoteAsyncInvocationCancelStatusService();\n        final ServiceController<?> asyncCancelTrackerServiceController = serviceTarget.addService(RemoteAsyncInvocationCancelStatusService.SERVICE_NAME, asyncInvocationCancelStatusService)\n                .install();\n        newControllers.add(asyncCancelTrackerServiceController);\n\n    }","id":104635,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        newControllers.addAll(installRuntimeServices(context, model, verificationHandler));\n        // add ejb remote transactions repository service\n        final EJBRemoteTransactionsRepository transactionsRepository = new EJBRemoteTransactionsRepository();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceController<?> transactionRepositoryServiceController = serviceTarget.addService(EJBRemoteTransactionsRepository.SERVICE_NAME, transactionsRepository)\n                .addDependency(TransactionManagerService.SERVICE_NAME, TransactionManager.class, transactionsRepository.getTransactionManagerInjector())\n                .addDependency(UserTransactionService.SERVICE_NAME, UserTransaction.class, transactionsRepository.getUserTransactionInjector())\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER, RecoveryManagerService.class, transactionsRepository.getRecoveryManagerInjector())\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        newControllers.add(transactionRepositoryServiceController);\n\n        // Service responsible for tracking cancel() invocations on remote async method calls\n        final RemoteAsyncInvocationCancelStatusService asyncInvocationCancelStatusService = new RemoteAsyncInvocationCancelStatusService();\n        final ServiceController<?> asyncCancelTrackerServiceController = serviceTarget.addService(RemoteAsyncInvocationCancelStatusService.SERVICE_NAME, asyncInvocationCancelStatusService)\n                .install();\n        newControllers.add(asyncCancelTrackerServiceController);\n\n    }","commit_id":"3c8d9404cf4719d7b8db50a1012cf7e0144903f7","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers,\n                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // Add the tccl based client context selector\n        final TCCLEJBClientContextSelectorService tcclBasedClientContextSelector = new TCCLEJBClientContextSelectorService();\n        context.getServiceTarget().addService(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        // EJB client context selector will be locked on the server if it's not application client container\n        final boolean lockEJBClientContextSelector = appclient ? false : true;\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService(lockEJBClientContextSelector);\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLEJBClientContextSelectorService.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        // add the EJB remote tx recovery service\n        newControllers.add(\n                Services.addServerExecutorDependency(\n                    serviceTarget.addService(EJBTransactionRecoveryService.SERVICE_NAME, EJBTransactionRecoveryService.INSTANCE),\n                        EJBTransactionRecoveryService.INSTANCE.getExecutorInjector(), false)\n                .addDependency(ArjunaRecoveryManagerService.SERVICE_NAME, RecoveryManagerService.class, EJBTransactionRecoveryService.INSTANCE.getRecoveryManagerServiceInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, CoreEnvironmentBean.class, EJBTransactionRecoveryService.INSTANCE.getCoreEnvironmentBeanInjector())\n                .install());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = WildFlySecurityManager.getPropertyPrivileged(ServerEnvironment.NODE_NAME, null);\n\n            //the default spec compliant EJB receiver\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byValueLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .addDependency(DependencyType.OPTIONAL, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byValueLocalEjbReceiver.getEndpointInjector())\n                    .addDependency(DependencyType.OPTIONAL, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byValueLocalEjbReceiver.getRemoteConnectorServiceInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND)\n                    .install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byReferenceLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .addDependency(DependencyType.OPTIONAL, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byReferenceLocalEjbReceiver.getEndpointInjector())\n                    .addDependency(DependencyType.OPTIONAL, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byReferenceLocalEjbReceiver.getRemoteConnectorServiceInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND)\n                    .install());\n\n            // setup the default local ejb receiver service\n            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel, newControllers);\n            // add the default local ejb receiver to the client context\n            clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n        }\n        // install the default EJB client context service\n        newControllers.add(clientContextServiceBuilder.install());\n    }","id":104636,"modified_method":"private static void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers,\n                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // Add the tccl based client context selector\n        final TCCLEJBClientContextSelectorService tcclBasedClientContextSelector = new TCCLEJBClientContextSelectorService();\n        context.getServiceTarget().addService(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        // EJB client context selector will be locked on the server if it's not application client container\n        final boolean lockEJBClientContextSelector = appclient ? false : true;\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService(lockEJBClientContextSelector);\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLEJBClientContextSelectorService.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        // add the EJB remote tx recovery service\n        newControllers.add(\n                Services.addServerExecutorDependency(\n                    serviceTarget.addService(EJBTransactionRecoveryService.SERVICE_NAME, EJBTransactionRecoveryService.INSTANCE),\n                        EJBTransactionRecoveryService.INSTANCE.getExecutorInjector(), false)\n                .addDependency(ArjunaRecoveryManagerService.SERVICE_NAME, RecoveryManagerService.class, EJBTransactionRecoveryService.INSTANCE.getRecoveryManagerServiceInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, CoreEnvironmentBean.class, EJBTransactionRecoveryService.INSTANCE.getCoreEnvironmentBeanInjector())\n                .install());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = WildFlySecurityManager.getPropertyPrivileged(ServerEnvironment.NODE_NAME, null);\n            // check if dependencies are available for for remote invocations (WFLY-3438)\n            final boolean installRemoteInvocationDependencies = isEJBRemoteConnectorInstalled(context) ;\n\n            //the default spec compliant EJB receiver\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            ServiceBuilder<LocalEjbReceiver> byValueServiceBuilder = serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byValueLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND);\n            if (installRemoteInvocationDependencies)\n                byValueServiceBuilder.addDependency(DependencyType.REQUIRED, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byValueLocalEjbReceiver.getEndpointInjector())\n                                     .addDependency(DependencyType.REQUIRED, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byValueLocalEjbReceiver.getRemoteConnectorServiceInjector());\n            newControllers.add(byValueServiceBuilder.install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            ServiceBuilder byReferenceServiceBuilder = serviceTarget.addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byReferenceLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND);\n            if (installRemoteInvocationDependencies)\n                byReferenceServiceBuilder.addDependency(DependencyType.REQUIRED, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byReferenceLocalEjbReceiver.getEndpointInjector())\n                                         .addDependency(DependencyType.REQUIRED, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byReferenceLocalEjbReceiver.getRemoteConnectorServiceInjector());\n            newControllers.add(byReferenceServiceBuilder.install());\n\n            // setup the default local ejb receiver service\n            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel, newControllers);\n            // add the default local ejb receiver to the client context\n            clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n        }\n        // install the default EJB client context service\n        newControllers.add(clientContextServiceBuilder.install());\n    }","commit_id":"3c8d9404cf4719d7b8db50a1012cf7e0144903f7","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public ChildrenAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalChildren.TYPE, ValuesSourceType.BYTES, ValueType.STRING);\n        childType = in.readString();\n    }","id":104637,"modified_method":"/**\n     * Read from a stream.\n     */\n    public ChildrenAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE, ValuesSourceType.BYTES, ValueType.STRING);\n        childType = in.readString();\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * @param name\n     *            the name of this aggregation\n     * @param childType\n     *            the type of children documents\n     */\n    public ChildrenAggregationBuilder(String name, String childType) {\n        super(name, InternalChildren.TYPE, ValuesSourceType.BYTES, ValueType.STRING);\n        if (childType == null) {\n            throw new IllegalArgumentException(\"[childType] must not be null: [\" + name + \"]\");\n        }\n        this.childType = childType;\n    }","id":104638,"modified_method":"/**\n     * @param name\n     *            the name of this aggregation\n     * @param childType\n     *            the type of children documents\n     */\n    public ChildrenAggregationBuilder(String name, String childType) {\n        super(name, TYPE, ValuesSourceType.BYTES, ValueType.STRING);\n        if (childType == null) {\n            throw new IllegalArgumentException(\"[childType] must not be null: [\" + name + \"]\");\n        }\n        this.childType = childType;\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public InternalChildren() {\n    }","id":104639,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalChildren(StreamInput in) throws IOException {\n        super(in);\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public InternalNested() {\n    }","id":104640,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalNested(StreamInput in) throws IOException {\n        super(in);\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public InternalReverseNested() {\n    }","id":104641,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalReverseNested(StreamInput in) throws IOException {\n        super(in);\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public NestedAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalNested.TYPE);\n        path = in.readString();\n    }","id":104642,"modified_method":"/**\n     * Read from a stream.\n     */\n    public NestedAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE);\n        path = in.readString();\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * @param name\n     *            the name of this aggregation\n     * @param path\n     *            the path to use for this nested aggregation. The path must\n     *            match the path to a nested object in the mappings.\n     */\n    public NestedAggregationBuilder(String name, String path) {\n        super(name, InternalNested.TYPE);\n        if (path == null) {\n            throw new IllegalArgumentException(\"[path] must not be null: [\" + name + \"]\");\n        }\n        this.path = path;\n    }","id":104643,"modified_method":"/**\n     * @param name\n     *            the name of this aggregation\n     * @param path\n     *            the path to use for this nested aggregation. The path must\n     *            match the path to a nested object in the mappings.\n     */\n    public NestedAggregationBuilder(String name, String path) {\n        super(name, TYPE);\n        if (path == null) {\n            throw new IllegalArgumentException(\"[path] must not be null: [\" + name + \"]\");\n        }\n        this.path = path;\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public ReverseNestedAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalReverseNested.TYPE);\n        path = in.readOptionalString();\n    }","id":104644,"modified_method":"/**\n     * Read from a stream.\n     */\n    public ReverseNestedAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE);\n        path = in.readOptionalString();\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ReverseNestedAggregationBuilder(String name) {\n        super(name, InternalReverseNested.TYPE);\n    }","id":104645,"modified_method":"public ReverseNestedAggregationBuilder(String name) {\n        super(name, TYPE);\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void registerBuiltinAggregations() {\n        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalAvg::new));\n        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalSum::new));\n        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMin::new));\n        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMax::new));\n        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),\n                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));\n        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),\n                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));\n        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),\n                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));\n        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),\n                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));\n        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),\n                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));\n        registerAggregation(new AggregationSpec(CardinalityAggregationBuilder::new, new CardinalityParser(),\n                CardinalityAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalCardinality::new));\n        registerAggregation(new AggregationSpec(GlobalAggregationBuilder::new, GlobalAggregationBuilder::parse,\n                GlobalAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGlobal::new));\n        registerAggregation(\n                new AggregationSpec(MissingAggregationBuilder::new, new MissingParser(), MissingAggregationBuilder.AGGREGATION_NAME_FIELD)\n                        .addResultReader(InternalMissing::new));\n        registerAggregation(new AggregationSpec(FilterAggregationBuilder::new, FilterAggregationBuilder::parse,\n                FilterAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilter::new));\n        registerAggregation(new AggregationSpec(FiltersAggregationBuilder::new, FiltersAggregationBuilder::parse,\n                FiltersAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilters::new));\n        registerAggregation(new AggregationSpec(SamplerAggregationBuilder::new, SamplerAggregationBuilder::parse,\n                SamplerAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalSampler.NAME, InternalSampler::new)\n                        .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new));\n        registerAggregation(DiversifiedAggregationBuilder::new, new DiversifiedSamplerParser(),\n                DiversifiedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(\n                new AggregationSpec(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(StringTerms.NAME, StringTerms::new)\n                    .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new)\n                    .addResultReader(LongTerms.NAME, LongTerms::new)\n                    .addResultReader(DoubleTerms.NAME, DoubleTerms::new));\n        registerAggregation(new AggregationSpec(SignificantTermsAggregationBuilder::new,\n                new SignificantTermsParser(significanceHeuristicParserRegistry, queryParserRegistry),\n                SignificantTermsAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(SignificantStringTerms.NAME, SignificantStringTerms::new)\n                    .addResultReader(SignificantLongTerms.NAME, SignificantLongTerms::new)\n                    .addResultReader(UnmappedSignificantTerms.NAME, UnmappedSignificantTerms::new));\n        registerAggregation(new AggregationSpec(RangeAggregationBuilder::new, new RangeParser(),\n                RangeAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalRange::new));\n        registerAggregation(new AggregationSpec(DateRangeAggregationBuilder::new, new DateRangeParser(),\n                DateRangeAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalDateRange::new));\n        registerAggregation(IpRangeAggregationBuilder::new, new IpRangeParser(), IpRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(HistogramAggregationBuilder::new, new HistogramParser(), HistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateHistogramAggregationBuilder::new, new DateHistogramParser(),\n                DateHistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(new AggregationSpec(GeoDistanceAggregationBuilder::new, new GeoDistanceParser(),\n                GeoDistanceAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoDistance::new));\n        registerAggregation(new AggregationSpec(GeoGridAggregationBuilder::new, new GeoHashGridParser(),\n                GeoGridAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoHashGrid::new));\n        registerAggregation(NestedAggregationBuilder::new, NestedAggregationBuilder::parse,\n                NestedAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerAggregation(ReverseNestedAggregationBuilder::new, ReverseNestedAggregationBuilder::parse,\n                ReverseNestedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TopHitsAggregationBuilder::new, TopHitsAggregationBuilder::parse,\n                TopHitsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(new AggregationSpec(GeoBoundsAggregationBuilder::new, new GeoBoundsParser(),\n                GeoBoundsAggregationBuilder.AGGREGATION_NAME_FIED).addResultReader(InternalGeoBounds::new));\n        registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder::new, new GeoCentroidParser(),\n                GeoCentroidAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoCentroid::new));\n        registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder::new, ScriptedMetricAggregationBuilder::parse,\n                ScriptedMetricAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalScriptedMetric::new));\n        registerAggregation(ChildrenAggregationBuilder::new, ChildrenAggregationBuilder::parse,\n                ChildrenAggregationBuilder.AGGREGATION_NAME_FIELD);\n\n        registerPipelineAggregation(DerivativePipelineAggregationBuilder::new, DerivativePipelineAggregationBuilder::parse,\n                DerivativePipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MaxBucketPipelineAggregationBuilder::new, MaxBucketPipelineAggregationBuilder.PARSER,\n                MaxBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MinBucketPipelineAggregationBuilder::new, MinBucketPipelineAggregationBuilder.PARSER,\n                MinBucketPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(AvgBucketPipelineAggregationBuilder::new, AvgBucketPipelineAggregationBuilder.PARSER,\n                AvgBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SumBucketPipelineAggregationBuilder::new, SumBucketPipelineAggregationBuilder.PARSER,\n                SumBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(StatsBucketPipelineAggregationBuilder::new, StatsBucketPipelineAggregator::new,\n                InternalStatsBucket::new, StatsBucketPipelineAggregationBuilder.PARSER,\n                StatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(ExtendedStatsBucketPipelineAggregationBuilder::new, ExtendedStatsBucketPipelineAggregator::new,\n                InternalExtendedStatsBucket::new, new ExtendedStatsBucketParser(),\n                ExtendedStatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(PercentilesBucketPipelineAggregationBuilder::new, PercentilesBucketPipelineAggregationBuilder.PARSER,\n                PercentilesBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MovAvgPipelineAggregationBuilder::new,\n                (n, c) -> MovAvgPipelineAggregationBuilder.parse(movingAverageModelParserRegistry, n, c),\n                MovAvgPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(CumulativeSumPipelineAggregationBuilder::new, CumulativeSumPipelineAggregationBuilder::parse,\n                CumulativeSumPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketScriptPipelineAggregationBuilder::new, BucketScriptPipelineAggregationBuilder::parse,\n                BucketScriptPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketSelectorPipelineAggregationBuilder::new, BucketSelectorPipelineAggregationBuilder::parse,\n                BucketSelectorPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SerialDiffPipelineAggregationBuilder::new, SerialDiffPipelineAggregationBuilder::parse,\n                SerialDiffPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n    }","id":104646,"modified_method":"private void registerBuiltinAggregations() {\n        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalAvg::new));\n        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalSum::new));\n        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMin::new));\n        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMax::new));\n        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),\n                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));\n        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),\n                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));\n        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),\n                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));\n        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),\n                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));\n        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),\n                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));\n        registerAggregation(new AggregationSpec(CardinalityAggregationBuilder::new, new CardinalityParser(),\n                CardinalityAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalCardinality::new));\n        registerAggregation(new AggregationSpec(GlobalAggregationBuilder::new, GlobalAggregationBuilder::parse,\n                GlobalAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGlobal::new));\n        registerAggregation(\n                new AggregationSpec(MissingAggregationBuilder::new, new MissingParser(), MissingAggregationBuilder.AGGREGATION_NAME_FIELD)\n                        .addResultReader(InternalMissing::new));\n        registerAggregation(new AggregationSpec(FilterAggregationBuilder::new, FilterAggregationBuilder::parse,\n                FilterAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilter::new));\n        registerAggregation(new AggregationSpec(FiltersAggregationBuilder::new, FiltersAggregationBuilder::parse,\n                FiltersAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilters::new));\n        registerAggregation(new AggregationSpec(SamplerAggregationBuilder::new, SamplerAggregationBuilder::parse,\n                SamplerAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalSampler.NAME, InternalSampler::new)\n                        .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new));\n        registerAggregation(DiversifiedAggregationBuilder::new, new DiversifiedSamplerParser(),\n                DiversifiedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(\n                new AggregationSpec(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(StringTerms.NAME, StringTerms::new)\n                    .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new)\n                    .addResultReader(LongTerms.NAME, LongTerms::new)\n                    .addResultReader(DoubleTerms.NAME, DoubleTerms::new));\n        registerAggregation(new AggregationSpec(SignificantTermsAggregationBuilder::new,\n                new SignificantTermsParser(significanceHeuristicParserRegistry, queryParserRegistry),\n                SignificantTermsAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(SignificantStringTerms.NAME, SignificantStringTerms::new)\n                    .addResultReader(SignificantLongTerms.NAME, SignificantLongTerms::new)\n                    .addResultReader(UnmappedSignificantTerms.NAME, UnmappedSignificantTerms::new));\n        registerAggregation(new AggregationSpec(RangeAggregationBuilder::new, new RangeParser(),\n                RangeAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalRange::new));\n        registerAggregation(new AggregationSpec(DateRangeAggregationBuilder::new, new DateRangeParser(),\n                DateRangeAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalDateRange::new));\n        registerAggregation(IpRangeAggregationBuilder::new, new IpRangeParser(), IpRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(HistogramAggregationBuilder::new, new HistogramParser(), HistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateHistogramAggregationBuilder::new, new DateHistogramParser(),\n                DateHistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(new AggregationSpec(GeoDistanceAggregationBuilder::new, new GeoDistanceParser(),\n                GeoDistanceAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoDistance::new));\n        registerAggregation(new AggregationSpec(GeoGridAggregationBuilder::new, new GeoHashGridParser(),\n                GeoGridAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoHashGrid::new));\n        registerAggregation(new AggregationSpec(NestedAggregationBuilder::new, NestedAggregationBuilder::parse,\n                NestedAggregationBuilder.AGGREGATION_FIELD_NAME).addResultReader(InternalNested::new));\n        registerAggregation(new AggregationSpec(ReverseNestedAggregationBuilder::new, ReverseNestedAggregationBuilder::parse,\n                ReverseNestedAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalReverseNested::new));\n        registerAggregation(TopHitsAggregationBuilder::new, TopHitsAggregationBuilder::parse,\n                TopHitsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(new AggregationSpec(GeoBoundsAggregationBuilder::new, new GeoBoundsParser(),\n                GeoBoundsAggregationBuilder.AGGREGATION_NAME_FIED).addResultReader(InternalGeoBounds::new));\n        registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder::new, new GeoCentroidParser(),\n                GeoCentroidAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoCentroid::new));\n        registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder::new, ScriptedMetricAggregationBuilder::parse,\n                ScriptedMetricAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalScriptedMetric::new));\n        registerAggregation(new AggregationSpec(ChildrenAggregationBuilder::new, ChildrenAggregationBuilder::parse,\n                ChildrenAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalChildren::new));\n\n        registerPipelineAggregation(DerivativePipelineAggregationBuilder::new, DerivativePipelineAggregationBuilder::parse,\n                DerivativePipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MaxBucketPipelineAggregationBuilder::new, MaxBucketPipelineAggregationBuilder.PARSER,\n                MaxBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MinBucketPipelineAggregationBuilder::new, MinBucketPipelineAggregationBuilder.PARSER,\n                MinBucketPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(AvgBucketPipelineAggregationBuilder::new, AvgBucketPipelineAggregationBuilder.PARSER,\n                AvgBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SumBucketPipelineAggregationBuilder::new, SumBucketPipelineAggregationBuilder.PARSER,\n                SumBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(StatsBucketPipelineAggregationBuilder::new, StatsBucketPipelineAggregator::new,\n                InternalStatsBucket::new, StatsBucketPipelineAggregationBuilder.PARSER,\n                StatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(ExtendedStatsBucketPipelineAggregationBuilder::new, ExtendedStatsBucketPipelineAggregator::new,\n                InternalExtendedStatsBucket::new, new ExtendedStatsBucketParser(),\n                ExtendedStatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(PercentilesBucketPipelineAggregationBuilder::new, PercentilesBucketPipelineAggregationBuilder.PARSER,\n                PercentilesBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MovAvgPipelineAggregationBuilder::new,\n                (n, c) -> MovAvgPipelineAggregationBuilder.parse(movingAverageModelParserRegistry, n, c),\n                MovAvgPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(CumulativeSumPipelineAggregationBuilder::new, CumulativeSumPipelineAggregationBuilder::parse,\n                CumulativeSumPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketScriptPipelineAggregationBuilder::new, BucketScriptPipelineAggregationBuilder::parse,\n                BucketScriptPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketSelectorPipelineAggregationBuilder::new, BucketSelectorPipelineAggregationBuilder::parse,\n                BucketSelectorPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SerialDiffPipelineAggregationBuilder::new, SerialDiffPipelineAggregationBuilder::parse,\n                SerialDiffPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n    }","commit_id":"f2978f41b9ffa5f1eddb03f3bcb52f516cf64405","url":"https://github.com/elastic/elasticsearch"},{"original_method":"InternalMissing() {\n    }","id":104647,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalMissing(StreamInput in) throws IOException {\n        super(in);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"InternalSampler() {\n    }","id":104648,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalSampler(StreamInput in) throws IOException {\n        super(in);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public MissingAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalMissing.TYPE, ValuesSourceType.ANY);\n    }","id":104649,"modified_method":"/**\n     * Read from a stream.\n     */\n    public MissingAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE, ValuesSourceType.ANY);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MissingAggregationBuilder(String name, ValueType targetValueType) {\n        super(name, InternalMissing.TYPE, ValuesSourceType.ANY, targetValueType);\n    }","id":104650,"modified_method":"public MissingAggregationBuilder(String name, ValueType targetValueType) {\n        super(name, TYPE, ValuesSourceType.ANY, targetValueType);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SamplerAggregationBuilder(String name) {\n        super(name, InternalSampler.TYPE);\n    }","id":104651,"modified_method":"public SamplerAggregationBuilder(String name) {\n        super(name, TYPE);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public SamplerAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalSampler.TYPE);\n        shardSize = in.readVInt();\n    }","id":104652,"modified_method":"/**\n     * Read from a stream.\n     */\n    public SamplerAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE);\n        shardSize = in.readVInt();\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void registerBuiltinAggregations() {\n        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalAvg::new));\n        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalSum::new));\n        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMin::new));\n        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMax::new));\n        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),\n                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));\n        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),\n                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));\n        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),\n                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));\n        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),\n                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));\n        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),\n                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));\n        registerAggregation(new AggregationSpec(CardinalityAggregationBuilder::new, new CardinalityParser(),\n                CardinalityAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalCardinality::new));\n        registerAggregation(new AggregationSpec(GlobalAggregationBuilder::new, GlobalAggregationBuilder::parse,\n                GlobalAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGlobal::new));\n        registerAggregation(MissingAggregationBuilder::new, new MissingParser(), MissingAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(new AggregationSpec(FilterAggregationBuilder::new, FilterAggregationBuilder::parse,\n                FilterAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilter::new));\n        registerAggregation(new AggregationSpec(FiltersAggregationBuilder::new, FiltersAggregationBuilder::parse,\n                FiltersAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilters::new));\n        registerAggregation(SamplerAggregationBuilder::new, SamplerAggregationBuilder::parse,\n                SamplerAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DiversifiedAggregationBuilder::new, new DiversifiedSamplerParser(),\n                DiversifiedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(SignificantTermsAggregationBuilder::new,\n                new SignificantTermsParser(significanceHeuristicParserRegistry, queryParserRegistry),\n                SignificantTermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(RangeAggregationBuilder::new, new RangeParser(), RangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateRangeAggregationBuilder::new, new DateRangeParser(), DateRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(IpRangeAggregationBuilder::new, new IpRangeParser(), IpRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(HistogramAggregationBuilder::new, new HistogramParser(), HistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateHistogramAggregationBuilder::new, new DateHistogramParser(),\n                DateHistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoDistanceAggregationBuilder::new, new GeoDistanceParser(),\n                GeoDistanceAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoGridAggregationBuilder::new, new GeoHashGridParser(), GeoGridAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(NestedAggregationBuilder::new, NestedAggregationBuilder::parse,\n                NestedAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerAggregation(ReverseNestedAggregationBuilder::new, ReverseNestedAggregationBuilder::parse,\n                ReverseNestedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TopHitsAggregationBuilder::new, TopHitsAggregationBuilder::parse,\n                TopHitsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoBoundsAggregationBuilder::new, new GeoBoundsParser(), GeoBoundsAggregationBuilder.AGGREGATION_NAME_FIED);\n        registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder::new, new GeoCentroidParser(),\n                GeoCentroidAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoCentroid::new));\n        registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder::new, ScriptedMetricAggregationBuilder::parse,\n                ScriptedMetricAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalScriptedMetric::new));\n        registerAggregation(ChildrenAggregationBuilder::new, ChildrenAggregationBuilder::parse,\n                ChildrenAggregationBuilder.AGGREGATION_NAME_FIELD);\n\n        registerPipelineAggregation(DerivativePipelineAggregationBuilder::new, DerivativePipelineAggregationBuilder::parse,\n                DerivativePipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MaxBucketPipelineAggregationBuilder::new, MaxBucketPipelineAggregationBuilder.PARSER,\n                MaxBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MinBucketPipelineAggregationBuilder::new, MinBucketPipelineAggregationBuilder.PARSER,\n                MinBucketPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(AvgBucketPipelineAggregationBuilder::new, AvgBucketPipelineAggregationBuilder.PARSER,\n                AvgBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SumBucketPipelineAggregationBuilder::new, SumBucketPipelineAggregationBuilder.PARSER,\n                SumBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(StatsBucketPipelineAggregationBuilder::new, StatsBucketPipelineAggregator::new,\n                InternalStatsBucket::new, StatsBucketPipelineAggregationBuilder.PARSER,\n                StatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(ExtendedStatsBucketPipelineAggregationBuilder::new, ExtendedStatsBucketPipelineAggregator::new,\n                InternalExtendedStatsBucket::new, new ExtendedStatsBucketParser(),\n                ExtendedStatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(PercentilesBucketPipelineAggregationBuilder::new, PercentilesBucketPipelineAggregationBuilder.PARSER,\n                PercentilesBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MovAvgPipelineAggregationBuilder::new,\n                (n, c) -> MovAvgPipelineAggregationBuilder.parse(movingAverageModelParserRegistry, n, c),\n                MovAvgPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(CumulativeSumPipelineAggregationBuilder::new, CumulativeSumPipelineAggregationBuilder::parse,\n                CumulativeSumPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketScriptPipelineAggregationBuilder::new, BucketScriptPipelineAggregationBuilder::parse,\n                BucketScriptPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketSelectorPipelineAggregationBuilder::new, BucketSelectorPipelineAggregationBuilder::parse,\n                BucketSelectorPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SerialDiffPipelineAggregationBuilder::new, SerialDiffPipelineAggregationBuilder::parse,\n                SerialDiffPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n    }","id":104653,"modified_method":"private void registerBuiltinAggregations() {\n        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalAvg::new));\n        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalSum::new));\n        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMin::new));\n        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMax::new));\n        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),\n                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));\n        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),\n                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));\n        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),\n                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));\n        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),\n                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));\n        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),\n                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));\n        registerAggregation(new AggregationSpec(CardinalityAggregationBuilder::new, new CardinalityParser(),\n                CardinalityAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalCardinality::new));\n        registerAggregation(new AggregationSpec(GlobalAggregationBuilder::new, GlobalAggregationBuilder::parse,\n                GlobalAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGlobal::new));\n        registerAggregation(\n                new AggregationSpec(MissingAggregationBuilder::new, new MissingParser(), MissingAggregationBuilder.AGGREGATION_NAME_FIELD)\n                        .addResultReader(InternalMissing::new));\n        registerAggregation(new AggregationSpec(FilterAggregationBuilder::new, FilterAggregationBuilder::parse,\n                FilterAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilter::new));\n        registerAggregation(new AggregationSpec(FiltersAggregationBuilder::new, FiltersAggregationBuilder::parse,\n                FiltersAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalFilters::new));\n        registerAggregation(new AggregationSpec(SamplerAggregationBuilder::new, SamplerAggregationBuilder::parse,\n                SamplerAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalSampler.NAME, InternalSampler::new)\n                        .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new));\n        registerAggregation(DiversifiedAggregationBuilder::new, new DiversifiedSamplerParser(),\n                DiversifiedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(SignificantTermsAggregationBuilder::new,\n                new SignificantTermsParser(significanceHeuristicParserRegistry, queryParserRegistry),\n                SignificantTermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(RangeAggregationBuilder::new, new RangeParser(), RangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateRangeAggregationBuilder::new, new DateRangeParser(), DateRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(IpRangeAggregationBuilder::new, new IpRangeParser(), IpRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(HistogramAggregationBuilder::new, new HistogramParser(), HistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateHistogramAggregationBuilder::new, new DateHistogramParser(),\n                DateHistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoDistanceAggregationBuilder::new, new GeoDistanceParser(),\n                GeoDistanceAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoGridAggregationBuilder::new, new GeoHashGridParser(), GeoGridAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(NestedAggregationBuilder::new, NestedAggregationBuilder::parse,\n                NestedAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerAggregation(ReverseNestedAggregationBuilder::new, ReverseNestedAggregationBuilder::parse,\n                ReverseNestedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TopHitsAggregationBuilder::new, TopHitsAggregationBuilder::parse,\n                TopHitsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoBoundsAggregationBuilder::new, new GeoBoundsParser(), GeoBoundsAggregationBuilder.AGGREGATION_NAME_FIED);\n        registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder::new, new GeoCentroidParser(),\n                GeoCentroidAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoCentroid::new));\n        registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder::new, ScriptedMetricAggregationBuilder::parse,\n                ScriptedMetricAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalScriptedMetric::new));\n        registerAggregation(ChildrenAggregationBuilder::new, ChildrenAggregationBuilder::parse,\n                ChildrenAggregationBuilder.AGGREGATION_NAME_FIELD);\n\n        registerPipelineAggregation(DerivativePipelineAggregationBuilder::new, DerivativePipelineAggregationBuilder::parse,\n                DerivativePipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MaxBucketPipelineAggregationBuilder::new, MaxBucketPipelineAggregationBuilder.PARSER,\n                MaxBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MinBucketPipelineAggregationBuilder::new, MinBucketPipelineAggregationBuilder.PARSER,\n                MinBucketPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(AvgBucketPipelineAggregationBuilder::new, AvgBucketPipelineAggregationBuilder.PARSER,\n                AvgBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SumBucketPipelineAggregationBuilder::new, SumBucketPipelineAggregationBuilder.PARSER,\n                SumBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(StatsBucketPipelineAggregationBuilder::new, StatsBucketPipelineAggregator::new,\n                InternalStatsBucket::new, StatsBucketPipelineAggregationBuilder.PARSER,\n                StatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(ExtendedStatsBucketPipelineAggregationBuilder::new, ExtendedStatsBucketPipelineAggregator::new,\n                InternalExtendedStatsBucket::new, new ExtendedStatsBucketParser(),\n                ExtendedStatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(PercentilesBucketPipelineAggregationBuilder::new, PercentilesBucketPipelineAggregationBuilder.PARSER,\n                PercentilesBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MovAvgPipelineAggregationBuilder::new,\n                (n, c) -> MovAvgPipelineAggregationBuilder.parse(movingAverageModelParserRegistry, n, c),\n                MovAvgPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(CumulativeSumPipelineAggregationBuilder::new, CumulativeSumPipelineAggregationBuilder::parse,\n                CumulativeSumPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketScriptPipelineAggregationBuilder::new, BucketScriptPipelineAggregationBuilder::parse,\n                BucketScriptPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketSelectorPipelineAggregationBuilder::new, BucketSelectorPipelineAggregationBuilder::parse,\n                BucketSelectorPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SerialDiffPipelineAggregationBuilder::new, SerialDiffPipelineAggregationBuilder::parse,\n                SerialDiffPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"UnmappedSampler() {\n    }","id":104654,"modified_method":"/**\n     * Read from a stream.\n     */\n    public UnmappedSampler(StreamInput in) throws IOException {\n        super(in);\n    }","commit_id":"7da753a4d78bcfd682d96065d185f574b9b5d7a5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public CardinalityAggregationBuilder(String name, ValueType targetValueType) {\n        super(name, InternalCardinality.TYPE, ValuesSourceType.ANY, targetValueType);\n    }","id":104655,"modified_method":"public CardinalityAggregationBuilder(String name, ValueType targetValueType) {\n        super(name, TYPE, ValuesSourceType.ANY, targetValueType);\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public CardinalityAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalCardinality.TYPE, ValuesSourceType.ANY);\n        if (in.readBoolean()) {\n            precisionThreshold = in.readLong();\n        }\n    }","id":104656,"modified_method":"/**\n     * Read from a stream.\n     */\n    public CardinalityAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE, ValuesSourceType.ANY);\n        if (in.readBoolean()) {\n            precisionThreshold = in.readLong();\n        }\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public GeoCentroidAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalGeoCentroid.TYPE, ValuesSourceType.GEOPOINT, ValueType.GEOPOINT);\n    }","id":104657,"modified_method":"/**\n     * Read from a stream.\n     */\n    public GeoCentroidAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE, ValuesSourceType.GEOPOINT, ValueType.GEOPOINT);\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GeoCentroidAggregationBuilder(String name) {\n        super(name, InternalGeoCentroid.TYPE, ValuesSourceType.GEOPOINT, ValueType.GEOPOINT);\n    }","id":104658,"modified_method":"public GeoCentroidAggregationBuilder(String name) {\n        super(name, TYPE, ValuesSourceType.GEOPOINT, ValueType.GEOPOINT);\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private InternalCardinality() {\n    }","id":104659,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalCardinality(StreamInput in) throws IOException {\n        super(in);\n        format = in.readNamedWriteable(DocValueFormat.class);\n        if (in.readBoolean()) {\n            counts = HyperLogLogPlusPlus.readFrom(in, BigArrays.NON_RECYCLING_INSTANCE);\n        } else {\n            counts = null;\n        }\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected InternalGeoCentroid() {\n    }","id":104660,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalGeoCentroid(StreamInput in) throws IOException {\n        super(in);\n        count = in.readVLong();\n        if (in.readBoolean()) {\n            final long hash = in.readLong();\n            centroid = new GeoPoint(GeoPointField.decodeLatitude(hash), GeoPointField.decodeLongitude(hash));\n        } else {\n            centroid = null;\n        }\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private InternalScriptedMetric() {\n    }","id":104661,"modified_method":"/**\n     * Read from a stream.\n     */\n    public InternalScriptedMetric(StreamInput in) throws IOException {\n        super(in);\n        reduceScript = in.readOptionalWriteable(Script::new);\n        aggregation = in.readGenericValue();\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public InternalScriptedMetric(String name, Object aggregation, Script reduceScript, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {\n        this(name, pipelineAggregators, metaData);\n        this.aggregation = aggregation;\n        this.reduceScript = reduceScript;\n    }","id":104662,"modified_method":"public InternalScriptedMetric(String name, Object aggregation, Script reduceScript, List<PipelineAggregator> pipelineAggregators,\n            Map<String, Object> metaData) {\n        super(name, pipelineAggregators, metaData);\n        this.aggregation = aggregation;\n        this.reduceScript = reduceScript;\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doWriteTo(StreamOutput out) throws IOException {\n        boolean hasScript = reduceScript != null;\n        out.writeBoolean(hasScript);\n        if (hasScript) {\n            reduceScript.writeTo(out);\n        }\n        out.writeGenericValue(aggregation);\n    }","id":104663,"modified_method":"@Override\n    protected void doWriteTo(StreamOutput out) throws IOException {\n        out.writeOptionalWriteable(reduceScript);\n        out.writeGenericValue(aggregation);\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ScriptedMetricAggregationBuilder(String name) {\n        super(name, InternalScriptedMetric.TYPE);\n    }","id":104664,"modified_method":"public ScriptedMetricAggregationBuilder(String name) {\n        super(name, TYPE);\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Read from a stream.\n     */\n    public ScriptedMetricAggregationBuilder(StreamInput in) throws IOException {\n        super(in, InternalScriptedMetric.TYPE);\n        initScript = in.readOptionalWriteable(Script::new);\n        mapScript = in.readOptionalWriteable(Script::new);\n        combineScript = in.readOptionalWriteable(Script::new);\n        reduceScript = in.readOptionalWriteable(Script::new);\n        if (in.readBoolean()) {\n            params = in.readMap();\n        }\n    }","id":104665,"modified_method":"/**\n     * Read from a stream.\n     */\n    public ScriptedMetricAggregationBuilder(StreamInput in) throws IOException {\n        super(in, TYPE);\n        initScript = in.readOptionalWriteable(Script::new);\n        mapScript = in.readOptionalWriteable(Script::new);\n        combineScript = in.readOptionalWriteable(Script::new);\n        reduceScript = in.readOptionalWriteable(Script::new);\n        if (in.readBoolean()) {\n            params = in.readMap();\n        }\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void registerBuiltinAggregations() {\n        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalAvg::new));\n        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalSum::new));\n        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMin::new));\n        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMax::new));\n        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),\n                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));\n        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),\n                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));\n        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),\n                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));\n        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),\n                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));\n        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),\n                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));\n        registerAggregation(CardinalityAggregationBuilder::new, new CardinalityParser(),\n                CardinalityAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GlobalAggregationBuilder::new, GlobalAggregationBuilder::parse,\n                GlobalAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(MissingAggregationBuilder::new, new MissingParser(), MissingAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(FilterAggregationBuilder::new, FilterAggregationBuilder::parse,\n                FilterAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(FiltersAggregationBuilder::new, FiltersAggregationBuilder::parse,\n                FiltersAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(SamplerAggregationBuilder::new, SamplerAggregationBuilder::parse,\n                SamplerAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DiversifiedAggregationBuilder::new, new DiversifiedSamplerParser(),\n                DiversifiedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(SignificantTermsAggregationBuilder::new,\n                new SignificantTermsParser(significanceHeuristicParserRegistry, queryParserRegistry),\n                SignificantTermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(RangeAggregationBuilder::new, new RangeParser(), RangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateRangeAggregationBuilder::new, new DateRangeParser(), DateRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(IpRangeAggregationBuilder::new, new IpRangeParser(), IpRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(HistogramAggregationBuilder::new, new HistogramParser(), HistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateHistogramAggregationBuilder::new, new DateHistogramParser(),\n                DateHistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoDistanceAggregationBuilder::new, new GeoDistanceParser(),\n                GeoDistanceAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoGridAggregationBuilder::new, new GeoHashGridParser(), GeoGridAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(NestedAggregationBuilder::new, NestedAggregationBuilder::parse,\n                NestedAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerAggregation(ReverseNestedAggregationBuilder::new, ReverseNestedAggregationBuilder::parse,\n                ReverseNestedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TopHitsAggregationBuilder::new, TopHitsAggregationBuilder::parse,\n                TopHitsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoBoundsAggregationBuilder::new, new GeoBoundsParser(), GeoBoundsAggregationBuilder.AGGREGATION_NAME_FIED);\n        registerAggregation(GeoCentroidAggregationBuilder::new, new GeoCentroidParser(),\n                GeoCentroidAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(ScriptedMetricAggregationBuilder::new, ScriptedMetricAggregationBuilder::parse,\n                ScriptedMetricAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(ChildrenAggregationBuilder::new, ChildrenAggregationBuilder::parse,\n                ChildrenAggregationBuilder.AGGREGATION_NAME_FIELD);\n\n        registerPipelineAggregation(DerivativePipelineAggregationBuilder::new, DerivativePipelineAggregationBuilder::parse,\n                DerivativePipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MaxBucketPipelineAggregationBuilder::new, MaxBucketPipelineAggregationBuilder.PARSER,\n                MaxBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MinBucketPipelineAggregationBuilder::new, MinBucketPipelineAggregationBuilder.PARSER,\n                MinBucketPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(AvgBucketPipelineAggregationBuilder::new, AvgBucketPipelineAggregationBuilder.PARSER,\n                AvgBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SumBucketPipelineAggregationBuilder::new, SumBucketPipelineAggregationBuilder.PARSER,\n                SumBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(StatsBucketPipelineAggregationBuilder::new, StatsBucketPipelineAggregator::new,\n                InternalStatsBucket::new, StatsBucketPipelineAggregationBuilder.PARSER,\n                StatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(ExtendedStatsBucketPipelineAggregationBuilder::new, ExtendedStatsBucketPipelineAggregator::new,\n                InternalExtendedStatsBucket::new, new ExtendedStatsBucketParser(),\n                ExtendedStatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(PercentilesBucketPipelineAggregationBuilder::new, PercentilesBucketPipelineAggregationBuilder.PARSER,\n                PercentilesBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MovAvgPipelineAggregationBuilder::new,\n                (n, c) -> MovAvgPipelineAggregationBuilder.parse(movingAverageModelParserRegistry, n, c),\n                MovAvgPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(CumulativeSumPipelineAggregationBuilder::new, CumulativeSumPipelineAggregationBuilder::parse,\n                CumulativeSumPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketScriptPipelineAggregationBuilder::new, BucketScriptPipelineAggregationBuilder::parse,\n                BucketScriptPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketSelectorPipelineAggregationBuilder::new, BucketSelectorPipelineAggregationBuilder::parse,\n                BucketSelectorPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SerialDiffPipelineAggregationBuilder::new, SerialDiffPipelineAggregationBuilder::parse,\n                SerialDiffPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n    }","id":104666,"modified_method":"private void registerBuiltinAggregations() {\n        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalAvg::new));\n        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalSum::new));\n        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMin::new));\n        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD)\n                .addResultReader(InternalMax::new));\n        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),\n                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));\n        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),\n                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));\n        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),\n                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));\n        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),\n                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));\n        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),\n                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD)\n                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));\n        registerAggregation(new AggregationSpec(CardinalityAggregationBuilder::new, new CardinalityParser(),\n                CardinalityAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalCardinality::new));\n        registerAggregation(GlobalAggregationBuilder::new, GlobalAggregationBuilder::parse,\n                GlobalAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(MissingAggregationBuilder::new, new MissingParser(), MissingAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(FilterAggregationBuilder::new, FilterAggregationBuilder::parse,\n                FilterAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(FiltersAggregationBuilder::new, FiltersAggregationBuilder::parse,\n                FiltersAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(SamplerAggregationBuilder::new, SamplerAggregationBuilder::parse,\n                SamplerAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DiversifiedAggregationBuilder::new, new DiversifiedSamplerParser(),\n                DiversifiedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(SignificantTermsAggregationBuilder::new,\n                new SignificantTermsParser(significanceHeuristicParserRegistry, queryParserRegistry),\n                SignificantTermsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(RangeAggregationBuilder::new, new RangeParser(), RangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateRangeAggregationBuilder::new, new DateRangeParser(), DateRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(IpRangeAggregationBuilder::new, new IpRangeParser(), IpRangeAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(HistogramAggregationBuilder::new, new HistogramParser(), HistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(DateHistogramAggregationBuilder::new, new DateHistogramParser(),\n                DateHistogramAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoDistanceAggregationBuilder::new, new GeoDistanceParser(),\n                GeoDistanceAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoGridAggregationBuilder::new, new GeoHashGridParser(), GeoGridAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(NestedAggregationBuilder::new, NestedAggregationBuilder::parse,\n                NestedAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerAggregation(ReverseNestedAggregationBuilder::new, ReverseNestedAggregationBuilder::parse,\n                ReverseNestedAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(TopHitsAggregationBuilder::new, TopHitsAggregationBuilder::parse,\n                TopHitsAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerAggregation(GeoBoundsAggregationBuilder::new, new GeoBoundsParser(), GeoBoundsAggregationBuilder.AGGREGATION_NAME_FIED);\n        registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder::new, new GeoCentroidParser(),\n                GeoCentroidAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalGeoCentroid::new));\n        registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder::new, ScriptedMetricAggregationBuilder::parse,\n                ScriptedMetricAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalScriptedMetric::new));\n        registerAggregation(ChildrenAggregationBuilder::new, ChildrenAggregationBuilder::parse,\n                ChildrenAggregationBuilder.AGGREGATION_NAME_FIELD);\n\n        registerPipelineAggregation(DerivativePipelineAggregationBuilder::new, DerivativePipelineAggregationBuilder::parse,\n                DerivativePipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MaxBucketPipelineAggregationBuilder::new, MaxBucketPipelineAggregationBuilder.PARSER,\n                MaxBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MinBucketPipelineAggregationBuilder::new, MinBucketPipelineAggregationBuilder.PARSER,\n                MinBucketPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(AvgBucketPipelineAggregationBuilder::new, AvgBucketPipelineAggregationBuilder.PARSER,\n                AvgBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SumBucketPipelineAggregationBuilder::new, SumBucketPipelineAggregationBuilder.PARSER,\n                SumBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(StatsBucketPipelineAggregationBuilder::new, StatsBucketPipelineAggregator::new,\n                InternalStatsBucket::new, StatsBucketPipelineAggregationBuilder.PARSER,\n                StatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(ExtendedStatsBucketPipelineAggregationBuilder::new, ExtendedStatsBucketPipelineAggregator::new,\n                InternalExtendedStatsBucket::new, new ExtendedStatsBucketParser(),\n                ExtendedStatsBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(PercentilesBucketPipelineAggregationBuilder::new, PercentilesBucketPipelineAggregationBuilder.PARSER,\n                PercentilesBucketPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(MovAvgPipelineAggregationBuilder::new,\n                (n, c) -> MovAvgPipelineAggregationBuilder.parse(movingAverageModelParserRegistry, n, c),\n                MovAvgPipelineAggregationBuilder.AGGREGATION_FIELD_NAME);\n        registerPipelineAggregation(CumulativeSumPipelineAggregationBuilder::new, CumulativeSumPipelineAggregationBuilder::parse,\n                CumulativeSumPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketScriptPipelineAggregationBuilder::new, BucketScriptPipelineAggregationBuilder::parse,\n                BucketScriptPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(BucketSelectorPipelineAggregationBuilder::new, BucketSelectorPipelineAggregationBuilder::parse,\n                BucketSelectorPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n        registerPipelineAggregation(SerialDiffPipelineAggregationBuilder::new, SerialDiffPipelineAggregationBuilder::parse,\n                SerialDiffPipelineAggregationBuilder.AGGREGATION_NAME_FIELD);\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n         * Add a reader for the shard level results of the aggregation.\n         */\n        public AggregationSpec addResultReader(String writeableName, Writeable.Reader<? extends InternalAggregation> resultReader) {\n            internalReaders.put(writeableName, resultReader);\n            return this;\n        }","id":104667,"modified_method":"/**\n         * Add a reader for the shard level results of the aggregation.\n         */\n        public AggregationSpec addResultReader(String writeableName, Writeable.Reader<? extends InternalAggregation> resultReader) {\n            resultReaders.put(writeableName, resultReader);\n            return this;\n        }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Register an aggregation.\n     */\n    public void registerAggregation(AggregationSpec spec) {\n        if (false == transportClient) {\n            namedWriteableRegistry.register(AggregationBuilder.class, spec.aggregationName.getPreferredName(), spec.builderReader);\n            aggregationParserRegistry.register(spec.aggregationParser, spec.aggregationName);\n        }\n        for (Map.Entry<String, Writeable.Reader<? extends InternalAggregation>> t : spec.internalReaders.entrySet()) {\n            String writeableName = t.getKey();\n            Writeable.Reader<? extends InternalAggregation> internalReader = t.getValue();\n            namedWriteableRegistry.register(InternalAggregation.class, writeableName, internalReader);\n        }\n    }","id":104668,"modified_method":"/**\n     * Register an aggregation.\n     */\n    public void registerAggregation(AggregationSpec spec) {\n        if (false == transportClient) {\n            namedWriteableRegistry.register(AggregationBuilder.class, spec.aggregationName.getPreferredName(), spec.builderReader);\n            aggregationParserRegistry.register(spec.aggregationParser, spec.aggregationName);\n        }\n        for (Map.Entry<String, Writeable.Reader<? extends InternalAggregation>> t : spec.resultReaders.entrySet()) {\n            String writeableName = t.getKey();\n            Writeable.Reader<? extends InternalAggregation> internalReader = t.getValue();\n            namedWriteableRegistry.register(InternalAggregation.class, writeableName, internalReader);\n        }\n    }","commit_id":"c02de9227cafbdda69578519a9f07d5ff65ef890","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@ManagedOperation(description = \"Get message body from queue by index\")\n    public String browseMessageBody(Integer index) {\n        List<Exchange> exchanges = getExchanges();\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        Object body;\n        if (exchange.hasOut()) {\n            body = exchange.getOut().getBody();\n        } else {\n            body = exchange.getIn().getBody();\n        }\n\n        // must use java type with JMX such as java.lang.String\n        return body != null ? body.toString() : null;\n    }","id":104669,"modified_method":"@ManagedOperation(description = \"Get message body from queue by index\")\n    public String browseMessageBody(Integer index) {\n        List<Exchange> exchanges = getExchanges();\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        // must use java type with JMX such as java.lang.String\n        String body;\n        if (exchange.hasOut()) {\n            body = exchange.getOut().getBody(String.class);\n        } else {\n            body = exchange.getIn().getBody(String.class);\n        }\n\n        return body;\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"@ManagedOperation(description = \"Get message as XML from queue by index\")\n    public String browseMessageAsXml(Integer index) {\n        List<Exchange> exchanges = getExchanges();\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n        String xml = MessageHelper.dumpAsXml(msg);\n\n        return xml;\n    }","id":104670,"modified_method":"@ManagedOperation(description = \"Get message as XML from queue by index\")\n    public String browseMessageAsXml(Integer index, Boolean includeBody) {\n        List<Exchange> exchanges = getExchanges();\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n        String xml = MessageHelper.dumpAsXml(msg, includeBody);\n\n        return xml;\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"@ManagedOperation(description = \"Get message body from queue by index\")\n    public String browseMessageBody(Integer index) {\n        if (index >= endpoint.getExchanges().size()) {\n            return null;\n        }\n        Exchange exchange = endpoint.getExchanges().get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        Object body;\n        if (exchange.hasOut()) {\n            body = exchange.getOut().getBody();\n        } else {\n            body = exchange.getIn().getBody();\n        }\n\n        // must use java type with JMX such as java.lang.String\n        return body != null ? body.toString() : null;\n    }","id":104671,"modified_method":"@ManagedOperation(description = \"Get message body from queue by index\")\n    public String browseMessageBody(Integer index) {\n        List<Exchange> exchanges = endpoint.getExchanges();\n\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        // must use java type with JMX such as java.lang.String\n        String body;\n        if (exchange.hasOut()) {\n            body = exchange.getOut().getBody(String.class);\n        } else {\n            body = exchange.getIn().getBody(String.class);\n        }\n\n        return body;\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"@ManagedOperation(description = \"Get message as XML from queue by index\")\n    public String browseMessageAsXml(Integer index) {\n        if (index >= endpoint.getExchanges().size()) {\n            return null;\n        }\n        Exchange exchange = endpoint.getExchanges().get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n        String xml = MessageHelper.dumpAsXml(msg);\n\n        return xml;\n    }","id":104672,"modified_method":"@ManagedOperation(description = \"Get message as XML from queue by index\")\n    public String browseMessageAsXml(Integer index, Boolean includeBody) {\n        List<Exchange> exchanges = endpoint.getExchanges();\n\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n\n        Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n        String xml = MessageHelper.dumpAsXml(msg, includeBody);\n\n        return xml;\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"@ManagedOperation(description = \"Get Exchange from queue by index\")\n    public String browseExchange(Integer index) {\n        if (index >= endpoint.getExchanges().size()) {\n            return null;\n        }\n        Exchange exchange = endpoint.getExchanges().get(index);\n        if (exchange == null) {\n            return null;\n        }\n        // must use java type with JMX such as java.lang.String\n        return exchange.toString();\n    }","id":104673,"modified_method":"@ManagedOperation(description = \"Get Exchange from queue by index\")\n    public String browseExchange(Integer index) {\n        List<Exchange> exchanges = endpoint.getExchanges();\n\n        if (index >= exchanges.size()) {\n            return null;\n        }\n        Exchange exchange = exchanges.get(index);\n        if (exchange == null) {\n            return null;\n        }\n        // must use java type with JMX such as java.lang.String\n        return exchange.toString();\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"public void testBrowseableEndpointAsXml() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedMessageCount(7);\n\n        template.sendBody(\"direct:start\", \"<foo>Camel &gt; Donkey<\/foo>\");\n        template.sendBody(\"direct:start\", \"Camel > Donkey\");\n        template.sendBodyAndHeader(\"direct:start\", \"<foo>Camel &gt; Donkey<\/foo>\", \"name\", \"Me & You\");\n        template.sendBodyAndHeader(\"direct:start\", \"<foo>Camel &gt; Donkey<\/foo>\", \"title\", \"<title>Me &amp; You<\/title>\");\n        template.sendBodyAndHeader(\"direct:start\", \"Camel > Donkey\", \"name\", \"Me & You\");\n        template.sendBodyAndHeader(\"direct:start\", 123, \"user\", true);\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"user\", false);\n        headers.put(\"uid\", 123);\n        headers.put(\"title\", \"Camel rocks\");\n        template.sendBodyAndHeaders(\"direct:start\", \"<animal><name>Donkey<\/name><age>17<\/age><\/animal>\", headers);\n\n        assertMockEndpointsSatisfied();\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        ObjectName name = ObjectName.getInstance(\"org.apache.camel:context=localhost/camel-1,type=endpoints,name=\\\"mock://result\\\"\");\n\n        String out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{0}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n\n        assertEquals(\"<message>\\n<body type=\\\"java.lang.String\\\">&lt;foo&gt;Camel &amp;gt; Donkey&lt;/foo&gt;<\/body>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{1}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<body type=\\\"java.lang.String\\\">Camel &gt; Donkey<\/body>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{2}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"name\\\" type=\\\"java.lang.String\\\">Me &amp; You<\/header>\\n<\/headers>\\n\"\n                + \"<body type=\\\"java.lang.String\\\">&lt;foo&gt;Camel &amp;gt; Donkey&lt;/foo&gt;<\/body>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{3}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"title\\\" type=\\\"java.lang.String\\\">&lt;title&gt;Me &amp;amp; You&lt;/title&gt;<\/header>\\n<\/headers>\\n\"\n                + \"<body type=\\\"java.lang.String\\\">&lt;foo&gt;Camel &amp;gt; Donkey&lt;/foo&gt;<\/body>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{4}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"name\\\" type=\\\"java.lang.String\\\">Me &amp; You<\/header>\\n<\/headers>\\n\"\n                + \"<body type=\\\"java.lang.String\\\">Camel &gt; Donkey<\/body>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{5}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"user\\\" type=\\\"java.lang.Boolean\\\">true<\/header>\\n<\/headers>\\n\"\n                + \"<body type=\\\"java.lang.Integer\\\">123<\/body>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{6}, new String[]{\"java.lang.Integer\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"title\\\" type=\\\"java.lang.String\\\">Camel rocks<\/header>\\n\"\n                + \"<header key=\\\"uid\\\" type=\\\"java.lang.Integer\\\">123<\/header>\\n\"\n                + \"<header key=\\\"user\\\" type=\\\"java.lang.Boolean\\\">false<\/header>\\n<\/headers>\\n\"\n                + \"<body type=\\\"java.lang.String\\\">&lt;animal&gt;&lt;name&gt;Donkey&lt;/name&gt;&lt;age&gt;17&lt;/age&gt;&lt;/animal&gt;<\/body>\\n<\/message>\", out);\n    }","id":104674,"modified_method":"public void testBrowseableEndpointAsXml() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedMessageCount(2);\n\n        template.sendBodyAndHeader(\"direct:start\", \"Hello World\", \"foo\", 123);\n        template.sendBodyAndHeader(\"direct:start\", \"Bye World\", \"foo\", 456);\n\n        assertMockEndpointsSatisfied();\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        ObjectName name = ObjectName.getInstance(\"org.apache.camel:context=localhost/camel-1,type=endpoints,name=\\\"mock://result\\\"\");\n\n        String out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{0, false}, new String[]{\"java.lang.Integer\", \"java.lang.Boolean\"});\n        assertNotNull(out);\n        log.info(out);\n\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"foo\\\" type=\\\"java.lang.Integer\\\">123<\/header>\\n<\/headers>\\n<\/message>\", out);\n\n        out = (String) mbeanServer.invoke(name, \"browseMessageAsXml\", new Object[]{1, false}, new String[]{\"java.lang.Integer\", \"java.lang.Boolean\"});\n        assertNotNull(out);\n        log.info(out);\n        assertEquals(\"<message>\\n<headers>\\n<header key=\\\"foo\\\" type=\\\"java.lang.Integer\\\">456<\/header>\\n<\/headers>\\n<\/message>\", out);\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Dumps the message as a generic XML structure.\n     *\n     * @param message  the message\n     * @return the XML\n     */\n    public static String dumpAsXml(Message message) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<message>\\n\");\n\n        // headers\n        if (message.hasHeaders()) {\n            sb.append(\"<headers>\\n\");\n            // sort the headers so they are listed A..Z\n            Map<String, Object> headers = new TreeMap<String, Object>(message.getHeaders());\n            for (Map.Entry<String, Object> entry : headers.entrySet()) {\n                Object value = entry.getValue();\n                String type = ObjectHelper.classCanonicalName(value);\n                sb.append(\"<header key=\\\"\" + entry.getKey() + \"\\\"\");\n                if (type != null) {\n                    sb.append(\" type=\\\"\" + type + \"\\\"\");\n                }\n                sb.append(\">\");\n\n                // dump header value as XML, use Camel type converter to convert to String\n                if (value != null) {\n                    String xml = message.getExchange().getContext().getTypeConverter().convertTo(String.class, value);\n                    if (xml != null) {\n                        // must always xml encode\n                        sb.append(StringHelper.xmlEncode(xml));\n                    }\n                }\n\n                sb.append(\"<\/header>\\n\");\n            }\n            sb.append(\"<\/headers>\\n\");\n        }\n\n        sb.append(\"<body\");\n        String type = ObjectHelper.classCanonicalName(message.getBody());\n        if (type != null) {\n            sb.append(\" type=\\\"\" + type + \"\\\"\");\n        }\n        sb.append(\">\");\n\n        // dump body value as XML, use Camel type converter to convert to String\n        // do not allow streams, but allow files, and clip very big message bodies (128kb)\n        String xml = extractBodyForLogging(message, \"\", false, true, 128 * 1024);\n        if (xml != null) {\n            // must always xml encode\n            sb.append(StringHelper.xmlEncode(xml));\n        }\n\n        sb.append(\"<\/body>\\n\");\n\n        sb.append(\"<\/message>\");\n        return sb.toString();\n    }","id":104675,"modified_method":"/**\n     * Dumps the message as a generic XML structure.\n     *\n     * @param message  the message\n     * @return the XML\n     */\n    public static String dumpAsXml(Message message) {\n        return dumpAsXml(message, true);\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"public void testDumpAsXmlXmlBody() throws Exception {\n        CamelContext context = new DefaultCamelContext();\n        context.start();\n\n        message = new DefaultExchange(context).getIn();\n\n        // xml message body\n        message.setBody(\"<?xml version=\\\"1.0\\\"?><hi>Hello World<\/hi>\");\n        message.setHeader(\"foo\", 123);\n\n        String out = MessageHelper.dumpAsXml(message);\n        assertTrue(\"Should contain body\", out.contains(\"<body type=\\\"java.lang.String\\\">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;hi&gt;Hello World&lt;/hi&gt;<\/body>\"));\n\n        context.stop();\n    }","id":104676,"modified_method":"public void testDumpAsXmlBody() throws Exception {\n        CamelContext context = new DefaultCamelContext();\n        context.start();\n\n        message = new DefaultExchange(context).getIn();\n\n        // xml message body\n        message.setBody(\"<?xml version=\\\"1.0\\\"?><hi>Hello World<\/hi>\");\n        message.setHeader(\"foo\", 123);\n\n        String out = MessageHelper.dumpAsXml(message);\n        assertTrue(\"Should contain body\", out.contains(\"<body type=\\\"java.lang.String\\\">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;hi&gt;Hello World&lt;/hi&gt;<\/body>\"));\n\n        context.stop();\n    }","commit_id":"4d466eb7c66bc06c7bf02f02a84840c50797cfeb","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * @param config path to config file.\n     * @return Cluster configuration.\n     */\n    public static ClusterProperties from(String config) {\n        try {\n            Properties props = null;\n\n            if (config != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(config));\n            }\n\n            ClusterProperties prop = new ClusterProperties();\n\n            prop.mesosUrl = getStringProperty(MESOS_MASTER_URL, props, DEFAULT_MESOS_MASTER_URL);\n\n            prop.httpServerHost = getStringProperty(IGNITE_HTTP_SERVER_HOST, props, getNonLoopbackAddress());\n            prop.httpServerPort = Integer.valueOf(getStringProperty(IGNITE_HTTP_SERVER_PORT, props,\n                DEFAULT_HTTP_SERVER_PORT));\n\n            prop.cpu = getDoubleProperty(IGNITE_RESOURCE_CPU_CORES, props, UNLIMITED);\n            prop.cpuPerNode = getDoubleProperty(IGNITE_RESOURCE_CPU_CORES_PER_NODE, props, UNLIMITED);\n            prop.mem = getDoubleProperty(IGNITE_RESOURCE_MEM_MB, props, UNLIMITED);\n            prop.memPerNode = getDoubleProperty(IGNITE_RESOURCE_MEM_MB_PER_NODE, props, UNLIMITED);\n            prop.disk = getDoubleProperty(IGNITE_RESOURCE_DISK_MB, props, UNLIMITED);\n            prop.diskPerNode = getDoubleProperty(IGNITE_RESOURCE_DISK_MB_PER_NODE, props, 1024.0);\n            prop.nodeCnt = getDoubleProperty(IGNITE_RESOURCE_NODE_CNT, props, UNLIMITED);\n            prop.minCpu = getDoubleProperty(IGNITE_RESOURCE_MIN_CPU_CNT_PER_NODE, props, DEFAULT_RESOURCE_MIN_CPU);\n            prop.minMemory = getDoubleProperty(IGNITE_RESOURCE_MIN_MEMORY_PER_NODE, props, DEFAULT_RESOURCE_MIN_MEM);\n\n            prop.igniteVer = getStringProperty(IGNITE_VERSION, props, DEFAULT_IGNITE_VERSION);\n            prop.igniteWorkDir = getStringProperty(IGNITE_WORK_DIR, props, DEFAULT_IGNITE_WORK_DIR);\n            prop.igniteCfg = getStringProperty(IGNITE_CONFIG_XML, props, null);\n            prop.userLibs = getStringProperty(IGNITE_USERS_LIBS, props, null);\n\n            return prop;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":104677,"modified_method":"/**\n     * @param config path to config file.\n     * @return Cluster configuration.\n     */\n    public static ClusterProperties from(String config) {\n        try {\n            Properties props = null;\n\n            if (config != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(config));\n            }\n\n            ClusterProperties prop = new ClusterProperties();\n\n            prop.mesosUrl = getStringProperty(MESOS_MASTER_URL, props, DEFAULT_MESOS_MASTER_URL);\n\n            prop.httpServerHost = getStringProperty(IGNITE_HTTP_SERVER_HOST, props, getNonLoopbackAddress());\n            prop.httpServerPort = Integer.valueOf(getStringProperty(IGNITE_HTTP_SERVER_PORT, props,\n                DEFAULT_HTTP_SERVER_PORT));\n\n            prop.userLibsUrl = getStringProperty(IGNITE_USERS_LIBS_URL, props, null);\n            prop.ignitePackageUrl = getStringProperty(IGNITE_PACKAGE_URL, props, null);\n            prop.igniteCfgUrl = getStringProperty(IGNITE_CONFIG_XML_URL, props, null);\n\n            prop.cpu = getDoubleProperty(IGNITE_TOTAL_CPU, props, UNLIMITED);\n            prop.cpuPerNode = getDoubleProperty(IGNITE_RUN_CPU_PER_NODE, props, UNLIMITED);\n            prop.mem = getDoubleProperty(IGNITE_TOTAL_MEMORY, props, UNLIMITED);\n            prop.memPerNode = getDoubleProperty(IGNITE_MEMORY_PER_NODE, props, UNLIMITED);\n            prop.disk = getDoubleProperty(IGNITE_TOTAL_DISK_SPACE, props, UNLIMITED);\n            prop.diskPerNode = getDoubleProperty(IGNITE_DISK_SPACE_PER_NODE, props, 1024.0);\n            prop.nodeCnt = getDoubleProperty(IGNITE_NODE_COUNT, props, UNLIMITED);\n            prop.minCpu = getDoubleProperty(IGNITE_MIN_CPU_PER_NODE, props, DEFAULT_RESOURCE_MIN_CPU);\n            prop.minMemory = getDoubleProperty(IGNITE_MIN_MEMORY_PER_NODE, props, DEFAULT_RESOURCE_MIN_MEM);\n\n            prop.igniteVer = getStringProperty(IGNITE_VERSION, props, DEFAULT_IGNITE_VERSION);\n            prop.igniteWorkDir = getStringProperty(IGNITE_WORK_DIR, props, DEFAULT_IGNITE_WORK_DIR);\n            prop.igniteCfg = getStringProperty(IGNITE_CONFIG_XML, props, null);\n            prop.userLibs = getStringProperty(IGNITE_USERS_LIBS, props, null);\n\n            return prop;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"29710de2bb1d09357b502f2dda16387c89c1bacc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Create Task.\n     *\n     * @param offer Offer.\n     * @param igniteTask Task description.\n     * @param taskId Task id.\n     * @return Task.\n     */\n    protected Protos.TaskInfo createTask(Protos.Offer offer, IgniteTask igniteTask, Protos.TaskID taskId) {\n        Protos.CommandInfo.Builder builder = Protos.CommandInfo.newBuilder()\n            .setEnvironment(Protos.Environment.newBuilder().addVariables(Protos.Environment.Variable.newBuilder()\n                .setName(\"IGNITE_TCP_DISCOVERY_ADDRESSES\")\n                .setValue(getAddress(offer.getHostname()))))\n            .addUris(Protos.CommandInfo.URI.newBuilder()\n                .setValue(resourceProvider.igniteUrl())\n                .setExtract(true))\n            .addUris(Protos.CommandInfo.URI.newBuilder().setValue(resourceProvider.igniteConfigUrl()));\n\n        if (resourceProvider.resourceUrl() != null) {\n            for (String url : resourceProvider.resourceUrl())\n                builder.addUris(Protos.CommandInfo.URI.newBuilder().setValue(url));\n\n            builder.setValue(\"cp *.jar ./gridgain-community-*/libs/ \"\n                + \"&& ./gridgain-community-*/bin/ignite.sh \"\n                + resourceProvider.configName()\n                + \" -J-Xmx\" + String.valueOf((int)igniteTask.mem() + \"m\")\n                + \" -J-Xms\" + String.valueOf((int)igniteTask.mem()) + \"m\");\n        }\n        else\n            builder.setValue(\"./gridgain-community-*/bin/ignite.sh \"\n                + resourceProvider.configName()\n                + \" -J-Xmx\" + String.valueOf((int)igniteTask.mem() + \"m\")\n                + \" -J-Xms\" + String.valueOf((int)igniteTask.mem()) + \"m\");\n\n        return Protos.TaskInfo.newBuilder()\n            .setName(\"Ignite node \" + taskId.getValue())\n            .setTaskId(taskId)\n            .setSlaveId(offer.getSlaveId())\n            .setCommand(builder)\n            .addResources(Protos.Resource.newBuilder()\n                .setName(CPUS)\n                .setType(Protos.Value.Type.SCALAR)\n                .setScalar(Protos.Value.Scalar.newBuilder().setValue(igniteTask.cpuCores())))\n            .addResources(Protos.Resource.newBuilder()\n                .setName(MEM)\n                .setType(Protos.Value.Type.SCALAR)\n                .setScalar(Protos.Value.Scalar.newBuilder().setValue(igniteTask.mem())))\n            .addResources(Protos.Resource.newBuilder()\n                .setName(DISK)\n                .setType(Protos.Value.Type.SCALAR)\n                .setScalar(Protos.Value.Scalar.newBuilder().setValue(igniteTask.disk())))\n                .build();\n    }","id":104678,"modified_method":"/**\n     * Create Task.\n     *\n     * @param offer Offer.\n     * @param igniteTask Task description.\n     * @param taskId Task id.\n     * @return Task.\n     */\n    protected Protos.TaskInfo createTask(Protos.Offer offer, IgniteTask igniteTask, Protos.TaskID taskId) {\n        Protos.CommandInfo.Builder builder = Protos.CommandInfo.newBuilder()\n            .setEnvironment(Protos.Environment.newBuilder().addVariables(Protos.Environment.Variable.newBuilder()\n                .setName(\"IGNITE_TCP_DISCOVERY_ADDRESSES\")\n                .setValue(getAddress(offer.getHostname()))))\n            .addUris(Protos.CommandInfo.URI.newBuilder()\n                .setValue(clusterProps.ignitePackageUrl() != null ?\n                    clusterProps.ignitePackageUrl() : resourceProvider.igniteUrl())\n                .setExtract(true))\n            .addUris(Protos.CommandInfo.URI.newBuilder()\n                .setValue(clusterProps.igniteConfigUrl() != null ?\n                    clusterProps.igniteConfigUrl() : resourceProvider.igniteConfigUrl()));\n\n        if (resourceProvider.resourceUrl() != null || clusterProps.usersLibsUrl() != null) {\n            if (clusterProps.igniteConfigUrl() != null) {\n                builder.addUris(Protos.CommandInfo.URI.newBuilder()\n                    .setValue(clusterProps.igniteConfigUrl())\n                    .setExtract(true));\n\n                String[] split = clusterProps.igniteConfigUrl().split(\"/\");\n\n                builder.setValue(\"cp *.jar ./gridgain-community-*/libs/ \"\n                    + \"&& ./gridgain-community-*/bin/ignite.sh \"\n                    + split[split.length - 1]\n                    + \" -J-Xmx\" + String.valueOf((int)igniteTask.mem() + \"m\")\n                    + \" -J-Xms\" + String.valueOf((int)igniteTask.mem()) + \"m\");\n            }\n            else {\n                for (String url : resourceProvider.resourceUrl())\n                    builder.addUris(Protos.CommandInfo.URI.newBuilder().setValue(url));\n\n                builder.setValue(\"cp *.jar ./gridgain-community-*/libs/ \"\n                        + \"&& ./gridgain-community-*/bin/ignite.sh \"\n                        + resourceProvider.configName()\n                        + \" -J-Xmx\" + String.valueOf((int)igniteTask.mem() + \"m\")\n                        + \" -J-Xms\" + String.valueOf((int)igniteTask.mem()) + \"m\");\n            }\n        }\n        else\n            builder.setValue(\"./gridgain-community-*/bin/ignite.sh \"\n                + resourceProvider.configName()\n                + \" -J-Xmx\" + String.valueOf((int)igniteTask.mem() + \"m\")\n                + \" -J-Xms\" + String.valueOf((int)igniteTask.mem()) + \"m\");\n\n        return Protos.TaskInfo.newBuilder()\n            .setName(\"Ignite node \" + taskId.getValue())\n            .setTaskId(taskId)\n            .setSlaveId(offer.getSlaveId())\n            .setCommand(builder)\n            .addResources(Protos.Resource.newBuilder()\n                .setName(CPUS)\n                .setType(Protos.Value.Type.SCALAR)\n                .setScalar(Protos.Value.Scalar.newBuilder().setValue(igniteTask.cpuCores())))\n            .addResources(Protos.Resource.newBuilder()\n                .setName(MEM)\n                .setType(Protos.Value.Type.SCALAR)\n                .setScalar(Protos.Value.Scalar.newBuilder().setValue(igniteTask.mem())))\n            .addResources(Protos.Resource.newBuilder()\n                .setName(DISK)\n                .setType(Protos.Value.Type.SCALAR)\n                .setScalar(Protos.Value.Scalar.newBuilder().setValue(igniteTask.disk())))\n                .build();\n    }","commit_id":"29710de2bb1d09357b502f2dda16387c89c1bacc","url":"https://github.com/apache/ignite"},{"original_method":"public PopupMenu getMainMenu() {\n        PopupMenu popup = new PopupMenu();\n        \n        MenuItem browserLauncher = new MenuItem(_t(\"Launch I2P Browser\"));\n        browserLauncher.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        return null;\n                    }\n                    \n                    @Override\n                    protected void done() {\n                        try {\n                            I2PDesktop.browse(\"http://localhost:7657\");\n                        } catch (BrowseException e1) {\n                            log.log(Log.WARN, \"Failed to open browser!\", e1);\n                        }    \n                    }\n                }.execute();\n            }\n        });\n\n        PopupMenu desktopguiConfigurationLauncher = new PopupMenu(_t(\"Configure I2P System Tray\"));\n        MenuItem configSubmenu = new MenuItem(_t(\"Disable\"));\n        configSubmenu.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        configureDesktopgui(false);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final MenuItem restartItem;\n        if (_context.hasWrapper()) {\n            restartItem = new MenuItem(_t(\"Restart I2P\"));\n            restartItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restartGracefully(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem = null;\n        }\n\n        final MenuItem stopItem = new MenuItem(_t(\"Stop I2P\"));\n        stopItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDownGracefully(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final MenuItem restartItem2;\n        if (_context.hasWrapper()) {\n            restartItem2 = new MenuItem(_t(\"Restart I2P Immediately\"));\n            restartItem2.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restart(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem2 = null;\n        }\n\n        final MenuItem stopItem2 = new MenuItem(_t(\"Stop I2P Immediately\"));\n        stopItem2.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final MenuItem cancelItem = new MenuItem(_t(\"Cancel I2P Shutdown\"));\n        cancelItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.cancelShutdown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        popup.add(browserLauncher);\n        popup.addSeparator();\n        desktopguiConfigurationLauncher.add(configSubmenu);\n        popup.add(desktopguiConfigurationLauncher);\n        popup.addSeparator();\n        if (_context.hasWrapper())\n            popup.add(restartItem);\n        popup.add(stopItem);\n        if (_context.hasWrapper())\n            popup.add(restartItem2);\n        popup.add(stopItem2);\n        popup.add(cancelItem);\n        \n        _restartItem = restartItem;\n        _stopItem = stopItem;\n        _cancelItem = cancelItem;\n\n        return popup;\n    }","id":104679,"modified_method":"public PopupMenu getMainMenu() {\n        PopupMenu popup = new PopupMenu();\n        \n        MenuItem browserLauncher;\n        if (CONSOLE_ENABLED) {\n            browserLauncher = new MenuItem(_t(\"Launch I2P Browser\"));\n            browserLauncher.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            return null;\n                        }\n                        \n                        @Override\n                        protected void done() {\n                            launchBrowser();\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            browserLauncher = null;\n        }\n\n        PopupMenu desktopguiConfigurationLauncher = new PopupMenu(_t(\"Configure I2P System Tray\"));\n        MenuItem configSubmenu = new MenuItem(_t(\"Disable\"));\n        configSubmenu.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        configureDesktopgui(false);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final MenuItem restartItem;\n        if (_context.hasWrapper()) {\n            restartItem = new MenuItem(_t(\"Restart I2P\"));\n            restartItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restartGracefully(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem = null;\n        }\n\n        final MenuItem stopItem = new MenuItem(_t(\"Stop I2P\"));\n        stopItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDownGracefully(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final MenuItem restartItem2;\n        if (_context.hasWrapper()) {\n            restartItem2 = new MenuItem(_t(\"Restart I2P Immediately\"));\n            restartItem2.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restart(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem2 = null;\n        }\n\n        final MenuItem stopItem2 = new MenuItem(_t(\"Stop I2P Immediately\"));\n        stopItem2.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final MenuItem cancelItem = new MenuItem(_t(\"Cancel I2P Shutdown\"));\n        cancelItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.cancelShutdown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        if (CONSOLE_ENABLED) {\n            popup.add(browserLauncher);\n            popup.addSeparator();\n        }\n        desktopguiConfigurationLauncher.add(configSubmenu);\n        popup.add(desktopguiConfigurationLauncher);\n        popup.addSeparator();\n        if (_context.hasWrapper())\n            popup.add(restartItem);\n        popup.add(stopItem);\n        if (_context.hasWrapper())\n            popup.add(restartItem2);\n        popup.add(stopItem2);\n        popup.add(cancelItem);\n        \n        _restartItem = restartItem;\n        _stopItem = stopItem;\n        _cancelItem = cancelItem;\n\n        return popup;\n    }","commit_id":"bf1fa061e3868d96c5035b34896b03e479549727","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public JPopupMenu getSwingMainMenu() {\n        JPopupMenu popup = new JPopupMenu();\n        \n        JMenuItem browserLauncher = new JMenuItem(_t(\"Launch I2P Browser\"));\n        browserLauncher.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        return null;\n                    }\n                    \n                    @Override\n                    protected void done() {\n                        try {\n                            I2PDesktop.browse(\"http://localhost:7657\");\n                        } catch (BrowseException e1) {\n                            log.log(Log.WARN, \"Failed to open browser!\", e1);\n                        }    \n                    }\n                }.execute();\n            }\n        });\n\n        JMenu desktopguiConfigurationLauncher = new JMenu(_t(\"Configure I2P System Tray\"));\n        JMenuItem configSubmenu = new JMenuItem(_t(\"Disable\"));\n        configSubmenu.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        configureDesktopgui(false);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final JMenuItem restartItem;\n        if (_context.hasWrapper()) {\n            restartItem = new JMenuItem(_t(\"Restart I2P\"));\n            restartItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restartGracefully(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem = null;\n        }\n\n        final JMenuItem stopItem = new JMenuItem(_t(\"Stop I2P\"));\n        stopItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDownGracefully(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final JMenuItem restartItem2;\n        if (_context.hasWrapper()) {\n            restartItem2 = new JMenuItem(_t(\"Restart I2P Immediately\"));\n            restartItem2.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restart(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem2 = null;\n        }\n\n        final JMenuItem stopItem2 = new JMenuItem(_t(\"Stop I2P Immediately\"));\n        stopItem2.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final JMenuItem cancelItem = new JMenuItem(_t(\"Cancel I2P Shutdown\"));\n        cancelItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.cancelShutdown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        popup.add(browserLauncher);\n        popup.addSeparator();\n        desktopguiConfigurationLauncher.add(configSubmenu);\n        popup.add(desktopguiConfigurationLauncher);\n        popup.addSeparator();\n        if (_context.hasWrapper())\n            popup.add(restartItem);\n        popup.add(stopItem);\n        if (_context.hasWrapper())\n            popup.add(restartItem2);\n        popup.add(stopItem2);\n        popup.add(cancelItem);\n        \n        _jrestartItem = restartItem;\n        _jstopItem = stopItem;\n        _jcancelItem = cancelItem;\n\n        return popup;\n    }","id":104680,"modified_method":"public JPopupMenu getSwingMainMenu() {\n        JPopupMenu popup = new JPopupMenu();\n        \n        JMenuItem browserLauncher;\n        if (CONSOLE_ENABLED) {\n            browserLauncher = new JMenuItem(_t(\"Launch I2P Browser\"));\n            browserLauncher.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            return null;\n                        }\n                        \n                        @Override\n                        protected void done() {\n                            launchBrowser();\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            browserLauncher = null;\n        }\n\n        JMenu desktopguiConfigurationLauncher = new JMenu(_t(\"Configure I2P System Tray\"));\n        JMenuItem configSubmenu = new JMenuItem(_t(\"Disable\"));\n        configSubmenu.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        configureDesktopgui(false);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final JMenuItem restartItem;\n        if (_context.hasWrapper()) {\n            restartItem = new JMenuItem(_t(\"Restart I2P\"));\n            restartItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restartGracefully(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem = null;\n        }\n\n        final JMenuItem stopItem = new JMenuItem(_t(\"Stop I2P\"));\n        stopItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDownGracefully(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final JMenuItem restartItem2;\n        if (_context.hasWrapper()) {\n            restartItem2 = new JMenuItem(_t(\"Restart I2P Immediately\"));\n            restartItem2.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    new SwingWorker<Object, Object>() {\n                        @Override\n                        protected Object doInBackground() throws Exception {\n                            RouterManager.restart(_context);\n                            return null;\n                        }\n                    }.execute();\n                }\n            });\n        } else {\n            restartItem2 = null;\n        }\n\n        final JMenuItem stopItem2 = new JMenuItem(_t(\"Stop I2P Immediately\"));\n        stopItem2.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.shutDown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        final JMenuItem cancelItem = new JMenuItem(_t(\"Cancel I2P Shutdown\"));\n        cancelItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n                new SwingWorker<Object, Object>() {\n                    @Override\n                    protected Object doInBackground() throws Exception {\n                        RouterManager.cancelShutdown(_context);\n                        return null;\n                    }\n                }.execute();\n            }\n        });\n\n        if (CONSOLE_ENABLED) {\n            popup.add(browserLauncher);\n            popup.addSeparator();\n        }\n        desktopguiConfigurationLauncher.add(configSubmenu);\n        popup.add(desktopguiConfigurationLauncher);\n        popup.addSeparator();\n        if (_context.hasWrapper())\n            popup.add(restartItem);\n        popup.add(stopItem);\n        if (_context.hasWrapper())\n            popup.add(restartItem2);\n        popup.add(stopItem2);\n        popup.add(cancelItem);\n        \n        _jrestartItem = restartItem;\n        _jstopItem = stopItem;\n        _jcancelItem = cancelItem;\n\n        return popup;\n    }","commit_id":"bf1fa061e3868d96c5035b34896b03e479549727","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public File getJavadocExecutable() throws JavaHomeException {\n        return findExecutable(\"javadoc\");\n    }","id":104681,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public File getJavadocExecutable() throws JavaHomeException {\n        if (javadocExecutable != null) {\n            return javadocExecutable;\n        }\n        javadocExecutable = findExecutable(\"javadoc\");\n        return javadocExecutable;\n    }","commit_id":"0200b98d124b651993c986444a265acf1e52acc6","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public File getJavacExecutable() throws JavaHomeException {\n        return findExecutable(\"javac\");\n    }","id":104682,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public File getJavacExecutable() throws JavaHomeException {\n        if (javacExecutable != null) {\n            return javacExecutable;\n        }\n        javacExecutable = findExecutable(\"javac\");\n        return javacExecutable;\n    }","commit_id":"0200b98d124b651993c986444a265acf1e52acc6","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public File getJavaExecutable() throws JavaHomeException {\n        return findExecutable(\"java\");\n    }","id":104683,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public File getJavaExecutable() throws JavaHomeException {\n        if (javaExecutable != null) {\n            return javaExecutable;\n        }\n        javaExecutable = findExecutable(\"java\");\n        return javaExecutable;\n    }","commit_id":"0200b98d124b651993c986444a265acf1e52acc6","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public File getToolsJar() {\n        return findToolsJar(javaBase);\n    }","id":104684,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public File getToolsJar() {\n        if (toolsJar != null) {\n            return toolsJar;\n        }\n        toolsJar = findToolsJar(javaBase);\n        return toolsJar;\n    }","commit_id":"0200b98d124b651993c986444a265acf1e52acc6","url":"https://github.com/gradle/gradle"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"PsiFieldStub[\");\n\n    if (isDeprecated() || hasDeprecatedAnnotation()) {\n      builder.append(\"deprecated \");\n    }\n\n    if (isEnumConstant()) {\n      builder.append(\"enumconst \");\n    }\n\n    TypeInfo type = getType(false); // this can be called from low-level code and we don't want resolve to mess with indexing\n    builder.append(getName()).append(':').append(TypeInfo.createTypeText(type));\n\n    if (myInitializer != null) {\n      builder.append('=').append(myInitializer);\n    }\n\n    builder.append(\"]\");\n    return builder.toString();\n  }","id":104685,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"PsiFieldStub[\");\n\n    if (isDeprecated() || hasDeprecatedAnnotation()) {\n      builder.append(\"deprecated \");\n    }\n    if (isEnumConstant()) {\n      builder.append(\"enumconst \");\n    }\n\n    builder.append(myName).append(':').append(myType);\n\n    if (myInitializer != null) {\n      builder.append('=').append(myInitializer);\n    }\n\n    builder.append(\"]\");\n    return builder.toString();\n  }","commit_id":"d0f37b3c7a3d4fbb863815d8d1cca53a69ca5662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public TypeInfo getType(boolean doResolve) {\n    if (!doResolve) return myType;\n\n    return addApplicableTypeAnnotationsFromChildModifierList(this, myType);\n  }","id":104686,"modified_method":"@Override\n  @NotNull\n  public TypeInfo getType(boolean doResolve) {\n    return doResolve ? addApplicableTypeAnnotationsFromChildModifierList(this, myType) : myType;\n  }","commit_id":"d0f37b3c7a3d4fbb863815d8d1cca53a69ca5662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public TypeInfo getReturnTypeText(boolean doResolve) {\n    if (!doResolve) return myReturnType;\n    return PsiFieldStubImpl.addApplicableTypeAnnotationsFromChildModifierList(this, myReturnType);\n  }","id":104687,"modified_method":"@Override\n  @NotNull\n  public TypeInfo getReturnTypeText(boolean doResolve) {\n    return doResolve ? PsiFieldStubImpl.addApplicableTypeAnnotationsFromChildModifierList(this, myReturnType) : myReturnType;\n  }","commit_id":"d0f37b3c7a3d4fbb863815d8d1cca53a69ca5662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"PsiMethodStub[\");\n    if (isConstructor()) {\n      builder.append(\"cons \");\n    }\n    if (isAnnotationMethod()) {\n      builder.append(\"annotation \");\n    }\n    if (isVarArgs()) {\n      builder.append(\"varargs \");\n    }\n    if (isDeprecated() || hasDeprecatedAnnotation()) {\n      builder.append(\"deprecated \");\n    }\n\n    builder.append(getName()).append(\":\").append(TypeInfo.createTypeText(getReturnTypeText(false)));\n\n    final String defaultValue = getDefaultValueText();\n    if (defaultValue != null) {\n      builder.append(\" default=\").append(defaultValue);\n    }\n\n    builder.append(\"]\");\n    return builder.toString();\n  }","id":104688,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"PsiMethodStub[\");\n\n    if (isConstructor()) {\n      builder.append(\"cons \");\n    }\n    if (isAnnotationMethod()) {\n      builder.append(\"annotation \");\n    }\n    if (isVarArgs()) {\n      builder.append(\"varargs \");\n    }\n    if (isDeprecated() || hasDeprecatedAnnotation()) {\n      builder.append(\"deprecated \");\n    }\n\n    builder.append(myName).append(\":\").append(myReturnType);\n\n    String defaultValue = getDefaultValueText();\n    if (defaultValue != null) {\n      builder.append(\" default=\").append(defaultValue);\n    }\n\n    builder.append(\"]\");\n    return builder.toString();\n  }","commit_id":"d0f37b3c7a3d4fbb863815d8d1cca53a69ca5662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return \"PsiParameterStub[\" + myName + ':' + TypeInfo.createTypeText(getType(false)) + ']';\n  }","id":104689,"modified_method":"@Override\n  public String toString() {\n    return \"PsiParameterStub[\" + myName + ':' + myType + ']';\n  }","commit_id":"d0f37b3c7a3d4fbb863815d8d1cca53a69ca5662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiParameter createPsi(@NotNull PsiParameterStub stub) {\n    return getPsiFactory(stub).createParameter(stub);\n  }","id":104690,"modified_method":"public JavaParameterElementType(@NotNull String id) {\n    super(id);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiParameterStub deserialize(final StubInputStream dataStream, final StubElement parentStub) throws IOException {\n    StringRef name = dataStream.readName();\n    TypeInfo type = TypeInfo.readTYPE(dataStream, parentStub);\n    boolean isEll = dataStream.readBoolean();\n    return new PsiParameterStubImpl(parentStub, name, type, isEll);\n  }","id":104691,"modified_method":"@Override\n  public PsiParameterStub deserialize(StubInputStream dataStream, StubElement parentStub) throws IOException {\n    StringRef name = dataStream.readName();\n    TypeInfo type = TypeInfo.readTYPE(dataStream, parentStub);\n    boolean isEllipsis = dataStream.readBoolean();\n    return new PsiParameterStubImpl(parentStub, name, type, isEllipsis);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiParameter createPsi(@NotNull final ASTNode node) {\n    return new PsiParameterImpl(node);\n  }","id":104692,"modified_method":"@Override\n  public PsiParameter createPsi(@NotNull ASTNode node) {\n    boolean receiver = node.getElementType() == JavaElementType.RECEIVER_PARAMETER;\n    return receiver ? new PsiReceiverParameterImpl(node) : new PsiParameterImpl(node);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiParameterStub createStub(final LighterAST tree,\n                                     final LighterASTNode node,\n                                     final StubElement parentStub) {\n    final TypeInfo typeInfo = TypeInfo.create(tree, node, parentStub);\n    final LighterASTNode id = LightTreeUtil.requiredChildOfType(tree, node, JavaTokenType.IDENTIFIER);\n    final String name = RecordUtil.intern(tree.getCharTable(), id);\n    return new PsiParameterStubImpl(parentStub, name, typeInfo, typeInfo.isEllipsis);\n  }","id":104693,"modified_method":"@Override\n  public PsiParameterStub createStub(LighterAST tree, LighterASTNode node, StubElement parentStub) {\n    TypeInfo typeInfo = TypeInfo.create(tree, node, parentStub);\n    LighterASTNode id = LightTreeUtil.requiredChildOfType(tree, node, ID_TYPES);\n    String name = RecordUtil.intern(tree.getCharTable(), id);\n    return new PsiParameterStubImpl(parentStub, name, typeInfo, typeInfo.isEllipsis);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ASTNode findChildByRole(int role){\n    LOG.assertTrue(ChildRole.isUnique(role));\n    switch(role){\n      default:\n        return null;\n\n      case ChildRole.MODIFIER_LIST:\n        return findChildByType(JavaElementType.MODIFIER_LIST);\n\n      case ChildRole.NAME:\n        return findChildByType(JavaTokenType.IDENTIFIER);\n\n      case ChildRole.TYPE:\n        return findChildByType(JavaElementType.TYPE);\n\n    }\n  }","id":104694,"modified_method":"@Override\n  public ASTNode findChildByRole(int role) {\n    LOG.assertTrue(ChildRole.isUnique(role));\n\n    if (role == ChildRole.MODIFIER_LIST) {\n      return findChildByType(JavaElementType.MODIFIER_LIST);\n    }\n    else if (role == ChildRole.NAME) {\n      return findChildByType(JavaTokenType.IDENTIFIER);\n    }\n    else if (role == ChildRole.TYPE) {\n      return findChildByType(JavaElementType.TYPE);\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ParameterElement(IElementType type) {\n    super(type);\n  }","id":104695,"modified_method":"public ParameterElement(@NotNull IElementType type) {\n    super(type);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getTextOffset() {\n    return findChildByRole(ChildRole.NAME).getStartOffset();\n  }","id":104696,"modified_method":"@Override\n  public int getTextOffset() {\n    ASTNode node = findChildByType(JavaParameterElementType.ID_TYPES);\n    return node != null ? node.getStartOffset() : getStartOffset();\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiTypeElement getTypeElement() {\n    return (PsiTypeElement)getNode().findChildByRoleAsPsiElement(ChildRole.TYPE);\n  }","id":104697,"modified_method":"@Override\n  public PsiTypeElement getTypeElement() {\n    return PsiTreeUtil.getChildOfType(this, PsiTypeElement.class);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiType getTypeNoResolve() {\n    final PsiParameterStub stub = getStub();\n    if (stub != null) {\n      String typeText = TypeInfo.createTypeText(stub.getType(false));\n      try {\n        return JavaPsiFacade.getInstance(getProject()).getParserFacade().createTypeFromText(typeText, this);\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n        return null;\n      }\n    }\n\n    final PsiTypeElement typeElement = getTypeElement();\n    if (typeElement == null && isLambdaParameter()) {\n      return new PsiLambdaParameterType(this);\n    }\n\n    return JavaSharedImplUtil.getTypeNoResolve(typeElement, getNameIdentifier(), this);\n  }","id":104698,"modified_method":"@Override\n  public PsiType getTypeNoResolve() {\n    PsiParameterStub stub = getStub();\n    if (stub != null) {\n      String typeText = TypeInfo.createTypeText(stub.getType(false));\n      assert typeText != null : stub;\n      try {\n        return JavaPsiFacade.getInstance(getProject()).getParserFacade().createTypeFromText(typeText, this);\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n        return null;\n      }\n    }\n\n    final PsiTypeElement typeElement = getTypeElement();\n    if (typeElement == null) {\n      assert isLambdaParameter() : this;\n      return new PsiLambdaParameterType(this);\n    }\n    else {\n      return JavaSharedImplUtil.getTypeNoResolve(typeElement, getParameterIdentifier(), this);\n    }\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement setName(@NotNull String name) throws IncorrectOperationException {\n    PsiImplUtil.setName(getNameIdentifier(), name);\n    return this;\n  }","id":104699,"modified_method":"@Override\n  public final PsiElement setName(@NotNull String name) throws IncorrectOperationException {\n    if (this instanceof PsiReceiverParameter) {\n      throw new IncorrectOperationException(\"Cannot rename receiver parameter\");\n    }\n\n    PsiImplUtil.setName(getParameterIdentifier(), name);\n    return this;\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public PsiModifierList getModifierList() {\n    return getStubOrPsiChild(JavaStubElementTypes.MODIFIER_LIST);\n  }","id":104700,"modified_method":"@Override\n  @NotNull\n  public PsiModifierList getModifierList() {\n    PsiModifierList modifierList = getStubOrPsiChild(JavaStubElementTypes.MODIFIER_LIST);\n    assert modifierList != null : this;\n    return modifierList;\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public final String getName() {\n    final PsiParameterStub stub = getStub();\n    if (stub != null) {\n      return stub.getName();\n    }\n    return getNameIdentifier().getText();\n  }","id":104701,"modified_method":"@Override\n  @NotNull\n  public final String getName() {\n    PsiParameterStub stub = getStub();\n    if (stub != null) {\n      return stub.getName();\n    }\n\n    return getParameterIdentifier().getText();\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiParameterImpl(@NotNull PsiParameterStub stub) {\n    super(stub, JavaStubElementTypes.PARAMETER);\n  }","id":104702,"modified_method":"public PsiParameterImpl(@NotNull PsiParameterStub stub) {\n    this(stub, JavaStubElementTypes.PARAMETER);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public PsiType getType() {\n    final PsiParameterStub stub = getStub();\n    if (stub != null) {\n      PatchedSoftReference<PsiType> cachedType = myCachedType;\n      if (cachedType != null) {\n        PsiType type = cachedType.get();\n        if (type != null) return type;\n      }\n\n      String typeText = TypeInfo.createTypeText(stub.getType(true));\n      try {\n        final PsiType type = JavaPsiFacade.getInstance(getProject()).getParserFacade().createTypeFromText(typeText, this);\n        myCachedType = new PatchedSoftReference<PsiType>(type);\n        return type;\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n        return null;\n      }\n    }\n\n    myCachedType = null;\n\n    final PsiTypeElement typeElement = getTypeElement();\n    if (typeElement == null && isLambdaParameter()) {\n      return LambdaUtil.getLambdaParameterType(this);\n    }\n\n    return JavaSharedImplUtil.getType(typeElement, getNameIdentifier(), this);\n  }","id":104703,"modified_method":"@Override\n  @NotNull\n  public PsiType getType() {\n    PsiParameterStub stub = getStub();\n    if (stub != null) {\n      PatchedSoftReference<PsiType> cachedType = myCachedType;\n      if (cachedType != null) {\n        PsiType type = cachedType.get();\n        if (type != null) return type;\n      }\n\n      String typeText = TypeInfo.createTypeText(stub.getType(true));\n      assert typeText != null : stub;\n      try {\n        PsiType type = JavaPsiFacade.getInstance(getProject()).getParserFacade().createTypeFromText(typeText, this);\n        myCachedType = new PatchedSoftReference<PsiType>(type);\n        return type;\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n        return null;\n      }\n    }\n\n    myCachedType = null;\n\n    PsiTypeElement typeElement = getTypeElement();\n    if (typeElement == null) {\n      assert isLambdaParameter() : this;\n      return LambdaUtil.getLambdaParameterType(this);\n    }\n    else {\n      return JavaSharedImplUtil.getType(typeElement, getParameterIdentifier(), this);\n    }\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public final PsiIdentifier getNameIdentifier() {\n    return (PsiIdentifier)getNode().findChildByRoleAsPsiElement(ChildRole.NAME);\n  }","id":104704,"modified_method":"@Override\n  public final PsiIdentifier getNameIdentifier() {\n    return PsiTreeUtil.getChildOfType(this, PsiIdentifier.class);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public TypeInfo getType(boolean doResolve) {\n    if (!doResolve) return myType;\n    return PsiFieldStubImpl.addApplicableTypeAnnotationsFromChildModifierList(this, myType);\n  }","id":104705,"modified_method":"@Override\n  @NotNull\n  public TypeInfo getType(boolean doResolve) {\n    return doResolve ? PsiFieldStubImpl.addApplicableTypeAnnotationsFromChildModifierList(this, myType) : myType;\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    builder.\n      append(\"PsiParameterStub[\").\n      append(myName).append(':').append(TypeInfo.createTypeText(getType(false))).\n      append(']');\n    return builder.toString();\n  }","id":104706,"modified_method":"@Override\n  public String toString() {\n    return \"PsiParameterStub[\" + myName + ':' + TypeInfo.createTypeText(getType(false)) + ']';\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiParameter createParameter(PsiParameterStub stub) {\n    return new PsiParameterImpl(stub);\n  }","id":104707,"modified_method":"@Override\n  public PsiParameter createParameter(PsiParameterStub stub) {\n    return stub.isReceiver() ? new PsiReceiverParameterImpl(stub) : new PsiParameterImpl(stub);\n  }","commit_id":"caf9bd61ffc8109bd6778e9cc3f58253e9a045c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public long doWork(SQLStmt delete, SQLStmt deletecp, long cid) {\n\n        voltQueueSQL(delete, cid);\n        VoltTable[] results = voltExecuteSQL();\n        if (results[0].asScalarLong() != 1) {\n            throw new VoltAbortException(\"Failed to delete cid that should exist: cid=\" + cid);\n        }\n        voltQueueSQL(deletecp, cid);\n        results = voltExecuteSQL();\n        if (results[0].asScalarLong() != 1) {\n            throw new VoltAbortException(\"Failed to delete cpcid that should exist: cpcid=\" + cid);\n        }\n        return 2;\n    }","id":104708,"modified_method":"public long doWork(SQLStmt delete, SQLStmt deletecp, long cid) {\n\n        voltQueueSQL(delete, cid);\n        VoltTable[] results = voltExecuteSQL();\n        long r = results[0].asScalarLong();\n        if (r != 1) {\n            throw new VoltAbortException(\"Failed to delete cid that should exist: deleted=\" + r + \" cid=\" + cid);\n        }\n        voltQueueSQL(deletecp, cid);\n        results = voltExecuteSQL();\n        r = results[0].asScalarLong();\n        if (r != 1) {\n            throw new VoltAbortException(\"Failed to delete cpcid that should exist: deleted=\" + r + \" cpcid=\" + cid);\n        }\n        return 2;\n    }","commit_id":"f0bb9fd6bba0cb6eac7aa5c43ff93d9d86c511a3","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n\n        CopyAndDeleteDataTask cdtask = new CopyAndDeleteDataTask();\n        cdtask.start();\n        try {\n            while (m_shouldContinue.get()) {\n                //1 in 3 gets copied and then deleted after leaving some data\n                byte shouldCopy = (byte) (m_random.nextInt(3) == 0 ? 1 : 0);\n                CountDownLatch latch = new CountDownLatch(batchSize);\n                final ArrayList<Long> lcpDelQueue = new ArrayList<Long>();\n\n                // try to insert batchSize random rows\n                for (int i = 0; i < batchSize; i++) {\n                    m_table.clearRowData();\n                    m_permits.acquire();\n                    long p = Math.abs(r.nextLong());\n                    m_table.addRow(p, p, Calendar.getInstance().getTimeInMillis());\n                    boolean success = false;\n                    if (!m_isMP) {\n                        Object rpartitionParam\n                                = TheHashinator.valueToBytes(m_table.fetchRow(0).get(\n                                                m_partitionedColumnIndex, VoltType.BIGINT));\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, rpartitionParam, m_tableName, m_table);\n                    } else {\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, m_tableName, m_table);\n                    }\n                    //Ad if successfully queued but remove if proc fails.\n                    if (success) {\n                        if (shouldCopy != 0) {\n                            lcpDelQueue.add(p);\n                        } else {\n                            onlyDelQueue.add(p);\n                        }\n                    }\n                }\n                //Wait for all @Load{SP|MP}Done\n                latch.await();\n                cpDelQueue.addAll(lcpDelQueue);\n                long nextRowCount = getRowCount();\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount.get()) {\n                    Thread.sleep(1000);\n                }\n                if (onlyDelQueue.size() > 100 && m_shouldContinue.get()) {\n                    List<Long> workList = new ArrayList<Long>();\n                    onlyDelQueue.drainTo(workList, 100);\n                    CountDownLatch odlatch = new CountDownLatch(workList.size());\n                    for (Long lcid : workList) {\n                        client.callProcedure(new DeleteCallback(odlatch, 1), m_onlydelprocName, lcid);\n                    }\n                    odlatch.await();\n                }\n            }\n            //Any accumulated in p/mp tables are left behind.\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"LoadTableLoader failed a procedure call for table \" + m_tableName\n                    + \" and the thread will now stop.\", e);\n        } finally {\n            cdtask.shutdown();\n            try {\n                cdtask.join();\n            } catch (InterruptedException ex) {\n                log.error(\"CopyDelete Task was stopped.\", ex);\n            }\n        }\n    }","id":104709,"modified_method":"@Override\n    public void run() {\n\n        CopyAndDeleteDataTask cdtask = new CopyAndDeleteDataTask();\n        cdtask.start();\n        try {\n            while (m_shouldContinue.get()) {\n                //1 in 3 gets copied and then deleted after leaving some data\n                byte shouldCopy = (byte) (m_random.nextInt(3) == 0 ? 1 : 0);\n                CountDownLatch latch = new CountDownLatch(batchSize);\n                final ArrayList<Long> lcpDelQueue = new ArrayList<Long>();\n\n                // try to insert batchSize random rows\n                for (int i = 0; i < batchSize; i++) {\n                    m_table.clearRowData();\n                    m_permits.acquire();\n                    long p = Math.abs(r.nextLong());\n                    m_table.addRow(p, p, Calendar.getInstance().getTimeInMillis());\n                    boolean success = false;\n                    if (!m_isMP) {\n                        Object rpartitionParam\n                                = TheHashinator.valueToBytes(m_table.fetchRow(0).get(\n                                                m_partitionedColumnIndex, VoltType.BIGINT));\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, rpartitionParam, m_tableName, m_table);\n                    } else {\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, m_tableName, m_table);\n                    }\n                    //Ad if successfully queued but remove if proc fails.\n                    if (success) {\n                        if (shouldCopy != 0) {\n                            lcpDelQueue.add(p);\n                        } else {\n                            onlyDelQueue.add(p);\n                        }\n                    }\n                }\n                //Wait for all @Load{SP|MP}Done\n                latch.await();\n                cpDelQueue.addAll(lcpDelQueue);\n                long nextRowCount = getRowCount();\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount.get()) {\n                    Thread.sleep(1000);\n                }\n                if (onlyDelQueue.size() > 0 && m_shouldContinue.get()) {\n                    List<Long> workList = new ArrayList<Long>();\n                    onlyDelQueue.drainTo(workList);\n                    CountDownLatch odlatch = new CountDownLatch(workList.size());\n                    for (Long lcid : workList) {\n                        client.callProcedure(new DeleteCallback(odlatch, 1), m_onlydelprocName, lcid);\n                    }\n                    odlatch.await();\n                }\n            }\n            //Any accumulated in p/mp tables are left behind.\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"LoadTableLoader failed a procedure call for table \" + m_tableName\n                    + \" and the thread will now stop.\", e);\n        } finally {\n            cdtask.shutdown();\n            try {\n                cdtask.join();\n            } catch (InterruptedException ex) {\n                log.error(\"CopyDelete Task was stopped.\", ex);\n            }\n        }\n    }","commit_id":"f0bb9fd6bba0cb6eac7aa5c43ff93d9d86c511a3","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public long doWork(SQLStmt delete, SQLStmt deletecp, long cid) {\n\n        voltQueueSQL(delete, cid);\n        VoltTable[] results = voltExecuteSQL();\n        if (results[0].asScalarLong() != 1) {\n            throw new VoltAbortException(\"Failed to delete cid that should exist: cid=\" + cid);\n        }\n        voltQueueSQL(deletecp, cid);\n        results = voltExecuteSQL();\n        if (results[0].asScalarLong() != 1) {\n            throw new VoltAbortException(\"Failed to delete cpcid that should exist: cpcid=\" + cid);\n        }\n        return 2;\n    }","id":104710,"modified_method":"public long doWork(SQLStmt delete, SQLStmt deletecp, long cid) {\n\n        voltQueueSQL(delete, cid);\n        VoltTable[] results = voltExecuteSQL();\n        long r = results[0].asScalarLong();\n        if (r != 1) {\n            throw new VoltAbortException(\"Failed to delete cid that should exist: deleted=\" + r + \" cid=\" + cid);\n        }\n        voltQueueSQL(deletecp, cid);\n        results = voltExecuteSQL();\n        r = results[0].asScalarLong();\n        if (r != 1) {\n            throw new VoltAbortException(\"Failed to delete cpcid that should exist: deleted=\" + r + \" cpcid=\" + cid);\n        }\n        return 2;\n    }","commit_id":"8cc14a6372cbaeccddbf176f7b87481282d59679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n\n        CopyAndDeleteDataTask cdtask = new CopyAndDeleteDataTask();\n        cdtask.start();\n        try {\n            while (m_shouldContinue.get()) {\n                //1 in 3 gets copied and then deleted after leaving some data\n                byte shouldCopy = (byte) (m_random.nextInt(3) == 0 ? 1 : 0);\n                CountDownLatch latch = new CountDownLatch(batchSize);\n                final ArrayList<Long> lcpDelQueue = new ArrayList<Long>();\n\n                // try to insert batchSize random rows\n                for (int i = 0; i < batchSize; i++) {\n                    m_table.clearRowData();\n                    m_permits.acquire();\n                    long p = Math.abs(r.nextLong());\n                    m_table.addRow(p, p, Calendar.getInstance().getTimeInMillis());\n                    boolean success = false;\n                    if (!m_isMP) {\n                        Object rpartitionParam\n                                = TheHashinator.valueToBytes(m_table.fetchRow(0).get(\n                                                m_partitionedColumnIndex, VoltType.BIGINT));\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, rpartitionParam, m_tableName, m_table);\n                    } else {\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, m_tableName, m_table);\n                    }\n                    //Ad if successfully queued but remove if proc fails.\n                    if (success) {\n                        if (shouldCopy != 0) {\n                            lcpDelQueue.add(p);\n                        } else {\n                            onlyDelQueue.add(p);\n                        }\n                    }\n                }\n                //Wait for all @Load{SP|MP}Done\n                latch.await();\n                cpDelQueue.addAll(lcpDelQueue);\n                long nextRowCount = getRowCount();\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount.get()) {\n                    Thread.sleep(1000);\n                }\n                if (onlyDelQueue.size() > 100 && m_shouldContinue.get()) {\n                    List<Long> workList = new ArrayList<Long>();\n                    onlyDelQueue.drainTo(workList, 100);\n                    CountDownLatch odlatch = new CountDownLatch(workList.size());\n                    for (Long lcid : workList) {\n                        client.callProcedure(new DeleteCallback(odlatch, 1), m_onlydelprocName, lcid);\n                    }\n                    odlatch.await();\n                }\n            }\n            //Any accumulated in p/mp tables are left behind.\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"LoadTableLoader failed a procedure call for table \" + m_tableName\n                    + \" and the thread will now stop.\", e);\n        } finally {\n            cdtask.shutdown();\n            try {\n                cdtask.join();\n            } catch (InterruptedException ex) {\n                log.error(\"CopyDelete Task was stopped.\", ex);\n            }\n        }\n    }","id":104711,"modified_method":"@Override\n    public void run() {\n\n        CopyAndDeleteDataTask cdtask = new CopyAndDeleteDataTask();\n        cdtask.start();\n        try {\n            while (m_shouldContinue.get()) {\n                //1 in 3 gets copied and then deleted after leaving some data\n                byte shouldCopy = (byte) (m_random.nextInt(3) == 0 ? 1 : 0);\n                CountDownLatch latch = new CountDownLatch(batchSize);\n                final ArrayList<Long> lcpDelQueue = new ArrayList<Long>();\n\n                // try to insert batchSize random rows\n                for (int i = 0; i < batchSize; i++) {\n                    m_table.clearRowData();\n                    m_permits.acquire();\n                    long p = Math.abs(r.nextLong());\n                    m_table.addRow(p, p, Calendar.getInstance().getTimeInMillis());\n                    boolean success = false;\n                    if (!m_isMP) {\n                        Object rpartitionParam\n                                = TheHashinator.valueToBytes(m_table.fetchRow(0).get(\n                                                m_partitionedColumnIndex, VoltType.BIGINT));\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, rpartitionParam, m_tableName, m_table);\n                    } else {\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, m_tableName, m_table);\n                    }\n                    //Ad if successfully queued but remove if proc fails.\n                    if (success) {\n                        if (shouldCopy != 0) {\n                            lcpDelQueue.add(p);\n                        } else {\n                            onlyDelQueue.add(p);\n                        }\n                    }\n                }\n                //Wait for all @Load{SP|MP}Done\n                latch.await();\n                cpDelQueue.addAll(lcpDelQueue);\n                long nextRowCount = getRowCount();\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount.get()) {\n                    Thread.sleep(1000);\n                }\n                if (onlyDelQueue.size() > 0 && m_shouldContinue.get()) {\n                    List<Long> workList = new ArrayList<Long>();\n                    onlyDelQueue.drainTo(workList);\n                    CountDownLatch odlatch = new CountDownLatch(workList.size());\n                    for (Long lcid : workList) {\n                        client.callProcedure(new DeleteCallback(odlatch, 1), m_onlydelprocName, lcid);\n                    }\n                    odlatch.await();\n                }\n            }\n            //Any accumulated in p/mp tables are left behind.\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"LoadTableLoader failed a procedure call for table \" + m_tableName\n                    + \" and the thread will now stop.\", e);\n        } finally {\n            cdtask.shutdown();\n            try {\n                cdtask.join();\n            } catch (InterruptedException ex) {\n                log.error(\"CopyDelete Task was stopped.\", ex);\n            }\n        }\n    }","commit_id":"8cc14a6372cbaeccddbf176f7b87481282d59679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private FileViewProvider createFileViewProvider(final VirtualFile file) {\n    FileViewProvider viewProvider = null;\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof LanguageFileType) {\n      final LanguageFileType languageFileType = (LanguageFileType)fileType;\n      viewProvider = languageFileType.getLanguage().createViewProvider(file, myManager, true);\n    }\n    if (viewProvider == null) viewProvider = new SingleRootFileViewProvider(myManager, file);\n    return viewProvider;\n  }","id":104712,"modified_method":"private FileViewProvider createFileViewProvider(final VirtualFile file) {\n    FileViewProvider viewProvider = null;\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof LanguageFileType) {\n      final LanguageFileType languageFileType = (LanguageFileType)fileType;\n      final FileViewProviderFactory factory = LanguageFileViewProviders.INSTANCE.forLanguage(languageFileType.getLanguage());\n      viewProvider = factory != null ? factory.createFileViewProvider(file, languageFileType.getLanguage(), myManager, true) : null;\n    }\n    if (viewProvider == null) viewProvider = new SingleRootFileViewProvider(myManager, file);\n    return viewProvider;\n  }","commit_id":"69842cb5e5bba38ca201f2a8e50b1270ee67058c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiFile createFileFromText(@NotNull String name,\n                                    @NotNull FileType fileType,\n                                    @NotNull Language targetLanguage,\n                                    LanguageDialect dialect, @NotNull CharSequence text,\n                                    long modificationStamp,\n                                    final boolean physical,\n                                    boolean markAsCopy) {\n    final LightVirtualFile virtualFile = new LightVirtualFile(name, fileType, text, modificationStamp);\n\n    if(fileType instanceof LanguageFileType){\n      final Language language = ((LanguageFileType)fileType).getLanguage();\n      final ParserDefinition parserDefinition = LanguageParserDefinitions.INSTANCE.forLanguage(language);\n      FileViewProvider viewProvider = language.createViewProvider(virtualFile, myManager, physical);\n      if (viewProvider == null) viewProvider = new SingleRootFileViewProvider(myManager, virtualFile, physical);\n      if (parserDefinition != null){\n        final PsiFile psiFile = viewProvider.getPsi(targetLanguage);\n        if (psiFile != null) {\n          if (dialect != null) {\n            psiFile.putUserData(PsiManagerImpl.LANGUAGE_DIALECT, dialect);\n          }\n          if(markAsCopy) {\n            final TreeElement node = (TreeElement)psiFile.getNode();\n            assert node != null;\n            node.acceptTree(new GeneratedMarkerVisitor());\n          }\n          return psiFile;\n        }\n      }\n    }\n    final SingleRootFileViewProvider singleRootFileViewProvider =\n      new SingleRootFileViewProvider(myManager, virtualFile, physical);\n    final PsiPlainTextFileImpl plainTextFile = new PsiPlainTextFileImpl(singleRootFileViewProvider);\n    if(markAsCopy) CodeEditUtil.setNodeGenerated(plainTextFile.getNode(), true);\n    return plainTextFile;\n  }","id":104713,"modified_method":"@NotNull\n  public PsiFile createFileFromText(@NotNull String name,\n                                    @NotNull FileType fileType,\n                                    @NotNull Language targetLanguage,\n                                    LanguageDialect dialect, @NotNull CharSequence text,\n                                    long modificationStamp,\n                                    final boolean physical,\n                                    boolean markAsCopy) {\n    final LightVirtualFile virtualFile = new LightVirtualFile(name, fileType, text, modificationStamp);\n\n    if(fileType instanceof LanguageFileType){\n      final Language language = ((LanguageFileType)fileType).getLanguage();\n      final ParserDefinition parserDefinition = LanguageParserDefinitions.INSTANCE.forLanguage(language);\n      final FileViewProviderFactory factory = LanguageFileViewProviders.INSTANCE.forLanguage(language);\n      FileViewProvider viewProvider = factory != null ? factory.createFileViewProvider(virtualFile, language, myManager, physical) : null;\n      if (viewProvider == null) viewProvider = new SingleRootFileViewProvider(myManager, virtualFile, physical);\n      if (parserDefinition != null){\n        final PsiFile psiFile = viewProvider.getPsi(targetLanguage);\n        if (psiFile != null) {\n          if (dialect != null) {\n            psiFile.putUserData(PsiManagerImpl.LANGUAGE_DIALECT, dialect);\n          }\n          if(markAsCopy) {\n            final TreeElement node = (TreeElement)psiFile.getNode();\n            assert node != null;\n            node.acceptTree(new GeneratedMarkerVisitor());\n          }\n          return psiFile;\n        }\n      }\n    }\n    final SingleRootFileViewProvider singleRootFileViewProvider =\n      new SingleRootFileViewProvider(myManager, virtualFile, physical);\n    final PsiPlainTextFileImpl plainTextFile = new PsiPlainTextFileImpl(singleRootFileViewProvider);\n    if(markAsCopy) CodeEditUtil.setNodeGenerated(plainTextFile.getNode(), true);\n    return plainTextFile;\n  }","commit_id":"69842cb5e5bba38ca201f2a8e50b1270ee67058c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiFile createFileFromText(@NotNull String name,\n                                    @NotNull FileType fileType,\n                                    @NotNull CharSequence text,\n                                    long modificationStamp,\n                                    final boolean physical,\n                                    boolean markAsCopy) {\n    final LightVirtualFile virtualFile = new LightVirtualFile(name, fileType, text, modificationStamp);\n\n    if(fileType instanceof LanguageFileType){\n      final Language language = ((LanguageFileType)fileType).getLanguage();\n      final ParserDefinition parserDefinition = LanguageParserDefinitions.INSTANCE.forLanguage(language);\n      FileViewProvider viewProvider = language.createViewProvider(virtualFile, myManager, physical);\n      if (viewProvider == null) viewProvider = new SingleRootFileViewProvider(myManager, virtualFile, physical);\n      if (parserDefinition != null){\n        final PsiFile psiFile = viewProvider.getPsi(language);\n        if (psiFile != null) {\n          if (language instanceof LanguageDialect) {\n            psiFile.putUserData(PsiManagerImpl.LANGUAGE_DIALECT, (LanguageDialect)language);\n          }\n          if(markAsCopy) {\n            final TreeElement node = (TreeElement)psiFile.getNode();\n            assert node != null;\n            node.acceptTree(new GeneratedMarkerVisitor());\n          }\n          return psiFile;\n        }\n      }\n    }\n    final SingleRootFileViewProvider singleRootFileViewProvider =\n      new SingleRootFileViewProvider(myManager, virtualFile, physical);\n    final PsiPlainTextFileImpl plainTextFile = new PsiPlainTextFileImpl(singleRootFileViewProvider);\n    if(markAsCopy) CodeEditUtil.setNodeGenerated(plainTextFile.getNode(), true);\n    return plainTextFile;\n  }","id":104714,"modified_method":"@NotNull\n  public PsiFile createFileFromText(@NotNull String name,\n                                    @NotNull FileType fileType,\n                                    @NotNull CharSequence text,\n                                    long modificationStamp,\n                                    final boolean physical,\n                                    boolean markAsCopy) {\n    final LightVirtualFile virtualFile = new LightVirtualFile(name, fileType, text, modificationStamp);\n\n    if(fileType instanceof LanguageFileType){\n      final Language language = ((LanguageFileType)fileType).getLanguage();\n      final ParserDefinition parserDefinition = LanguageParserDefinitions.INSTANCE.forLanguage(language);\n      final FileViewProviderFactory factory = LanguageFileViewProviders.INSTANCE.forLanguage(language);\n      FileViewProvider viewProvider = factory != null ? factory.createFileViewProvider(virtualFile, language, myManager, physical) : null;\n      if (viewProvider == null) viewProvider = new SingleRootFileViewProvider(myManager, virtualFile, physical);\n      if (parserDefinition != null){\n        final PsiFile psiFile = viewProvider.getPsi(language);\n        if (psiFile != null) {\n          if (language instanceof LanguageDialect) {\n            psiFile.putUserData(PsiManagerImpl.LANGUAGE_DIALECT, (LanguageDialect)language);\n          }\n          if(markAsCopy) {\n            final TreeElement node = (TreeElement)psiFile.getNode();\n            assert node != null;\n            node.acceptTree(new GeneratedMarkerVisitor());\n          }\n          return psiFile;\n        }\n      }\n    }\n    final SingleRootFileViewProvider singleRootFileViewProvider =\n      new SingleRootFileViewProvider(myManager, virtualFile, physical);\n    final PsiPlainTextFileImpl plainTextFile = new PsiPlainTextFileImpl(singleRootFileViewProvider);\n    if(markAsCopy) CodeEditUtil.setNodeGenerated(plainTextFile.getNode(), true);\n    return plainTextFile;\n  }","commit_id":"69842cb5e5bba38ca201f2a8e50b1270ee67058c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getPagePath(\n\t\t\tPortletDataContext context, WikiPage page) {\n\t\treturn context.getPortletPath(PortletKeys.WIKI) +\n\t\t\t\"/pages/\" + page.getPageId() + \".xml\";\n\t}","id":104715,"modified_method":"protected String getPagePath(PortletDataContext context, WikiPage page) {\n\t\tStringMaker sm = new StringMaker();\n\n\t\tsm.append(context.getPortletPath(PortletKeys.WIKI));\n\t\tsm.append(\"/pages/\");\n\t\tsm.append(page.getPageId());\n\t\tsm.append(\".xml\");\n\n\t\treturn sm.toString();\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getNodePath(\n\t\t\tPortletDataContext context, WikiNode node) {\n\t\treturn context.getPortletPath(PortletKeys.WIKI) +\n\t\t\t\"/nodes/\" + node.getNodeId() + \".xml\";\n\t}","id":104716,"modified_method":"protected String getNodePath(PortletDataContext context, WikiNode node) {\n\t\tStringMaker sm = new StringMaker();\n\n\t\tsm.append(context.getPortletPath(PortletKeys.WIKI));\n\t\tsm.append(\"/nodes/\");\n\t\tsm.append(node.getNodeId());\n\t\tsm.append(\".xml\");\n\n\t\treturn sm.toString();\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportNode(\n\t\t\tPortletDataContext context, Element nodesEl, long nodeId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (context.hasDateRange()) {\n\t\t\tWikiNode node = WikiNodeUtil.findByPrimaryKey(nodeId);\n\n\t\t\tString path = getNodePath(context, node);\n\n\t\t\tnodesEl.addElement(\"node\").addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tnode.setUserUuid(node.getUserUuid());\n\n\t\t\t\tcontext.addZipEntry(path, node);\n\t\t\t}\n\t\t}\n\t}","id":104717,"modified_method":"protected void exportNode(\n\t\t\tPortletDataContext context, Element nodesEl, long nodeId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.hasDateRange()) {\n\t\t\treturn;\n\t\t}\n\n\t\tWikiNode node = WikiNodeUtil.findByPrimaryKey(nodeId);\n\n\t\tString path = getNodePath(context, node);\n\n\t\tElement nodeEl = nodesEl.addElement(\"node\");\n\n\t\tnodeEl.addAttribute(\"path\", path);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tnode.setUserUuid(node.getUserUuid());\n\n\t\t\tcontext.addZipEntry(path, node);\n\t\t}\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importPage(\n\t\t\tPortletDataContext context, Map<Long, Long> nodePKs, Element pageEl,\n\t\t\tWikiPage page)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(page.getUserUuid());\n\t\tlong nodeId = MapUtil.getLong(\n\t\t\tnodePKs, page.getNodeId(), page.getNodeId());\n\n\t\tString[] tagsEntries = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\ttagsEntries = context.getTagsEntries(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t}\n\n\t\tPortletPreferences prefs = null;\n\n\t\tThemeDisplay themeDisplay = null;\n\n\t\tWikiPage existingPage = null;\n\n\t\ttry {\n\t\t\tWikiNodeUtil.findByPrimaryKey(nodeId);\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingPage = WikiPageFinderUtil.findByUuid_G(\n\t\t\t\t\t\tpage.getUuid(), context.getGroupId());\n\n\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.updatePage(\n\t\t\t\t\t\tuserId, nodeId, existingPage.getTitle(), 0,\n\t\t\t\t\t\tpage.getContent(), page.getFormat(),\n\t\t\t\t\t\tpage.getParentTitle(), page.getRedirectTitle(),\n\t\t\t\t\t\ttagsEntries, prefs, themeDisplay);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchPageException nspe) {\n\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\t\tpage.getUuid(), userId, nodeId, page.getTitle(),\n\t\t\t\t\t\tpage.getVersion(), page.getContent(), page.getFormat(),\n\t\t\t\t\t\tpage.getHead(), page.getParentTitle(),\n\t\t\t\t\t\tpage.getRedirectTitle(), tagsEntries, prefs,\n\t\t\t\t\t\tthemeDisplay);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\tnull, userId, nodeId, page.getTitle(), page.getVersion(),\n\t\t\t\t\tpage.getContent(), page.getFormat(), page.getHead(),\n\t\t\t\t\tpage.getParentTitle(), page.getRedirectTitle(), tagsEntries,\n\t\t\t\t\tprefs, themeDisplay);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tList<Element> attachementEls = pageEl.elements(\"attachement\");\n\n\t\t\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\n\t\t\t\tfor (Element attachementEl : attachementEls) {\n\t\t\t\t\tString name = attachementEl.attributeValue(\"name\");\n\t\t\t\t\tString attachementPath = attachementEl.attributeValue(\n\t\t\t\t\t\t\"bin-path\");\n\n\t\t\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(\n\t\t\t\t\t\tattachementPath);\n\n\t\t\t\t\tfiles.add(new ObjectValuePair<String, byte[]>(name, bytes));\n\t\t\t\t}\n\n\t\t\t\tif (files.size() > 0) {\n\t\t\t\t\tWikiPageLocalServiceUtil.addPageAttachments(\n\t\t\t\t\t\tnodeId, page.getTitle(), files);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tWikiPage.class, new Long(page.getResourcePrimKey()),\n\t\t\t\t\tnew Long(existingPage.getResourcePrimKey()),\n\t\t\t\t\tcontext.getGroupId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tWikiPage.class, new Long(page.getResourcePrimKey()),\n\t\t\t\t\tnew Long(existingPage.getResourcePrimKey()));\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the node for page \" +\n\t\t\t\t\tpage.getPageId());\n\t\t}\n\t}","id":104718,"modified_method":"protected void importPage(\n\t\t\tPortletDataContext context, Map<Long, Long> nodePKs, Element pageEl,\n\t\t\tWikiPage page)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(page.getUserUuid());\n\t\tlong nodeId = MapUtil.getLong(\n\t\t\tnodePKs, page.getNodeId(), page.getNodeId());\n\n\t\tString[] tagsEntries = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\ttagsEntries = context.getTagsEntries(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t}\n\n\t\tPortletPreferences prefs = null;\n\n\t\tThemeDisplay themeDisplay = null;\n\n\t\tWikiPage existingPage = null;\n\n\t\ttry {\n\t\t\tWikiNodeUtil.findByPrimaryKey(nodeId);\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingPage = WikiPageFinderUtil.findByUuid_G(\n\t\t\t\t\t\tpage.getUuid(), context.getGroupId());\n\n\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.updatePage(\n\t\t\t\t\t\tuserId, nodeId, existingPage.getTitle(), 0,\n\t\t\t\t\t\tpage.getContent(), page.getFormat(),\n\t\t\t\t\t\tpage.getParentTitle(), page.getRedirectTitle(),\n\t\t\t\t\t\ttagsEntries, prefs, themeDisplay);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchPageException nspe) {\n\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\t\tpage.getUuid(), userId, nodeId, page.getTitle(),\n\t\t\t\t\t\tpage.getVersion(), page.getContent(), page.getFormat(),\n\t\t\t\t\t\tpage.getHead(), page.getParentTitle(),\n\t\t\t\t\t\tpage.getRedirectTitle(), tagsEntries, prefs,\n\t\t\t\t\t\tthemeDisplay);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\tnull, userId, nodeId, page.getTitle(), page.getVersion(),\n\t\t\t\t\tpage.getContent(), page.getFormat(), page.getHead(),\n\t\t\t\t\tpage.getParentTitle(), page.getRedirectTitle(), tagsEntries,\n\t\t\t\t\tprefs, themeDisplay);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tList<Element> attachmentEls = pageEl.elements(\"attachment\");\n\n\t\t\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\n\t\t\t\tfor (Element attachmentEl : attachmentEls) {\n\t\t\t\t\tString name = attachmentEl.attributeValue(\"name\");\n\t\t\t\t\tString binPath = attachmentEl.attributeValue(\"bin-path\");\n\n\t\t\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\t\t\t\tfiles.add(new ObjectValuePair<String, byte[]>(name, bytes));\n\t\t\t\t}\n\n\t\t\t\tif (files.size() > 0) {\n\t\t\t\t\tWikiPageLocalServiceUtil.addPageAttachments(\n\t\t\t\t\t\tnodeId, page.getTitle(), files);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\t\texistingPage.getResourcePrimKey(), context.getGroupId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\t\texistingPage.getResourcePrimKey());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t_log.error(\"Could not find the node for page \" + page.getPageId());\n\t\t}\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getPageAttachementBinPath(\n\t\t\tPortletDataContext context, String attachment, WikiPage page) {\n\t\treturn context.getPortletPath(PortletKeys.WIKI) +\n\t\t\t\"/bin/\" + page.getPageId() + CharPool.FORWARD_SLASH +\n\t\t\t\tattachment;\n\t}","id":104719,"modified_method":"protected String getPageAttachementBinPath(\n\t\tPortletDataContext context, WikiPage page, String attachment) {\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tsm.append(context.getPortletPath(PortletKeys.WIKI));\n\t\tsm.append(\"/bin/\");\n\t\tsm.append(page.getPageId());\n\t\tsm.append(StringPool.SLASH);\n\t\tsm.append(attachment);\n\n\t\treturn sm.toString();\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportPage(\n\t\t\tPortletDataContext context, Element nodesEl, Element pagesEl,\n\t\t\tWikiPage page)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (context.isWithinDateRange(page.getModifiedDate())) {\n\t\t\tString path = getPagePath(context, page);\n\n\t\t\tElement pageEl = pagesEl.addElement(\"page\");\n\t\t\tpageEl.addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tpage.setUserUuid(page.getUserUuid());\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\t\tcontext.addComments(\n\t\t\t\t\t\tWikiPage.class,\n\t\t\t\t\t\tnew Long(page.getResourcePrimKey()));\n\t\t\t\t}\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\t\tWikiPage.class,\n\t\t\t\t\t\tnew Long(page.getResourcePrimKey()));\n\t\t\t\t}\n\n\t\t\t\t// Attachments\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\t\t\tpage.isHead()) {\n\n\t\t\t\t\tfor (String attachment : page.getAttachmentsFiles()) {\n\t\t\t\t\t\tint lf = attachment.lastIndexOf(CharPool.FORWARD_SLASH);\n\n\t\t\t\t\t\tString attachementName = attachment.substring(\n\t\t\t\t\t\t\t(lf+1), attachment.length());\n\n\t\t\t\t\t\tString attachementPath = getPageAttachementBinPath(\n\t\t\t\t\t\t\tcontext, attachementName, page);\n\n\t\t\t\t\t\tElement attachementEl = pageEl.addElement(\"attachement\");\n\t\t\t\t\t\tattachementEl.addAttribute(\"name\", attachementName);\n\t\t\t\t\t\tattachementEl.addAttribute(\"bin-path\", attachementPath);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tbyte[] byteArray = DLServiceUtil.getFile(\n\t\t\t\t\t\t\t\tcontext.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\t\t\t\t\tattachment);\n\n\t\t\t\t\t\t\tcontext.addZipEntry(\n\t\t\t\t\t\t\t\tattachementPath, byteArray);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (RemoteException re) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpage.setAttachmentsDir(page.getAttachmentsDir());\n\t\t\t\t}\n\n\t\t\t\tcontext.addZipEntry(path, page);\n\t\t\t}\n\n\t\t\texportNode(context, nodesEl, page.getNodeId());\n\t\t}\n\t}","id":104720,"modified_method":"protected void exportPage(\n\t\t\tPortletDataContext context, Element nodesEl, Element pagesEl,\n\t\t\tWikiPage page)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(page.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getPagePath(context, page);\n\n\t\tElement pageEl = pagesEl.addElement(\"page\");\n\n\t\tpageEl.addAttribute(\"path\", path);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tpage.setUserUuid(page.getUserUuid());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.addComments(WikiPage.class, page.getResourcePrimKey());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tfor (String attachment : page.getAttachmentsFiles()) {\n\t\t\t\t\tint pos = attachment.lastIndexOf(StringPool.SLASH);\n\n\t\t\t\t\tString name = attachment.substring(pos + 1);\n\t\t\t\t\tString binPath = getPageAttachementBinPath(\n\t\t\t\t\t\tcontext, page, name);\n\n\t\t\t\t\tElement attachmentEl = pageEl.addElement(\"attachment\");\n\n\t\t\t\t\tattachmentEl.addAttribute(\"name\", name);\n\t\t\t\t\tattachmentEl.addAttribute(\"bin-path\", binPath);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbyte[] byteArray = DLServiceUtil.getFile(\n\t\t\t\t\t\t\tcontext.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\t\t\t\tattachment);\n\n\t\t\t\t\t\tcontext.addZipEntry(binPath, byteArray);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RemoteException re) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpage.setAttachmentsDir(page.getAttachmentsDir());\n\t\t\t}\n\n\t\t\tcontext.addZipEntry(path, page);\n\t\t}\n\n\t\texportNode(context, nodesEl, page.getNodeId());\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportNode(\n\t\t\tPortletDataContext context, Element nodesEl, Element pagesEl,\n\t\t\tWikiNode node)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (context.isWithinDateRange(node.getModifiedDate())) {\n\t\t\tString path = getNodePath(context, node);\n\n\t\t\tnodesEl.addElement(\"node\").addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tnode.setUserUuid(node.getUserUuid());\n\n\t\t\t\tcontext.addZipEntry(path, node);\n\t\t\t}\n\t\t}\n\n\t\tList<WikiPage> nodePages = WikiPageUtil.findByNodeId(\n\t\t\tnode.getNodeId());\n\n\t\tfor (WikiPage page : nodePages) {\n\t\t\texportPage(context, nodesEl, pagesEl, page);\n\t\t}\n\t}","id":104721,"modified_method":"protected void exportNode(\n\t\t\tPortletDataContext context, Element nodesEl, Element pagesEl,\n\t\t\tWikiNode node)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (context.isWithinDateRange(node.getModifiedDate())) {\n\t\t\tString path = getNodePath(context, node);\n\n\t\t\tElement nodeEl = nodesEl.addElement(\"node\");\n\n\t\t\tnodeEl.addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tnode.setUserUuid(node.getUserUuid());\n\n\t\t\t\tcontext.addZipEntry(path, node);\n\t\t\t}\n\t\t}\n\n\t\tList<WikiPage> nodePages = WikiPageUtil.findByNodeId(node.getNodeId());\n\n\t\tfor (WikiPage page : nodePages) {\n\t\t\texportPage(context, nodesEl, pagesEl, page);\n\t\t}\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = DocumentUtil.readDocumentFromXML(data);\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Nodes\n\n\t\t\tList<Element> nodeEls =\n\t\t\t\troot.element(\"nodes\").elements(\"node\");\n\n\t\t\tMap<Long, Long> nodePKs = context.getNewPrimaryKeysMap(\n\t\t\t\tWikiNode.class);\n\n\t\t\tfor (Element el : nodeEls) {\n\t\t\t\tString path = el.attributeValue(\"path\");\n\n\t\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\t\tWikiNode node =\n\t\t\t\t\t\t(WikiNode)context.getZipEntryAsObject(path);\n\n\t\t\t\t\timportNode(context, nodePKs, node);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Pages\n\n\t\t\tList<Element> pageEls =\n\t\t\t\troot.element(\"pages\").elements(\"page\");\n\n\t\t\tfor (Element el : pageEls) {\n\t\t\t\tString path = el.attributeValue(\"path\");\n\n\t\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\t\tWikiPage page =\n\t\t\t\t\t\t(WikiPage)context.getZipEntryAsObject(path);\n\n\t\t\t\t\timportPage(context, nodePKs, el, page);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":104722,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = DocumentUtil.readDocumentFromXML(data);\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\tList<Element> nodeEls = root.element(\"nodes\").elements(\"node\");\n\n\t\t\tMap<Long, Long> nodePKs = context.getNewPrimaryKeysMap(\n\t\t\t\tWikiNode.class);\n\n\t\t\tfor (Element nodeEl : nodeEls) {\n\t\t\t\tString path = nodeEl.attributeValue(\"path\");\n\n\t\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\t\tWikiNode node = (WikiNode)context.getZipEntryAsObject(path);\n\n\t\t\t\t\timportNode(context, nodePKs, node);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Element> pageEls = root.element(\"pages\").elements(\"page\");\n\n\t\t\tfor (Element pageEl : pageEls) {\n\t\t\t\tString path = pageEl.attributeValue(\"path\");\n\n\t\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\t\tWikiPage page = (WikiPage)context.getZipEntryAsObject(path);\n\n\t\t\t\t\timportPage(context, nodePKs, pageEl, page);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"003a3c5f06ddd762017ea678cd26c9df86019bcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String extractText(String html) {\n\t\tif (html == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSource source = new Source(html);\n\n\t\treturn source.getTextExtractor().toString();\n\t}","id":104723,"modified_method":"public String extractText(String html) {\n\t\tif (html == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSource source = new Source(html);\n\n\t\tTextExtractor textExtractor = source.getTextExtractor();\n\n\t\treturn textExtractor.toString();\n\t}","commit_id":"a46a2a55ae400b16da702cc413c34965507d266c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Document doGetDocument(Object obj) throws Exception {\n\t\tPluginPackage pluginPackage = (PluginPackage)obj;\n\n\t\tString moduleId = pluginPackage.getModuleId();\n\t\tString name = pluginPackage.getName();\n\t\tString version = pluginPackage.getVersion();\n\t\tDate modifiedDate = pluginPackage.getModifiedDate();\n\t\tString author = pluginPackage.getAuthor();\n\t\tList<String> types = pluginPackage.getTypes();\n\t\tList<String> tags = pluginPackage.getTags();\n\t\tList<License> licenses = pluginPackage.getLicenses();\n\t\t//List<String> liferayVersions = pluginPackage.getLiferayVersions();\n\t\tString shortDescription = HtmlUtil.extractText(\n\t\t\tpluginPackage.getShortDescription());\n\t\tString longDescription = HtmlUtil.extractText(\n\t\t\tpluginPackage.getLongDescription());\n\t\tString changeLog = pluginPackage.getChangeLog();\n\t\tString pageURL = pluginPackage.getPageURL();\n\t\tString repositoryURL = pluginPackage.getRepositoryURL();\n\n\t\tString[] statusAndInstalledVersion =\n\t\t\tPluginPackageUtil.getStatusAndInstalledVersion(pluginPackage);\n\n\t\tString status = statusAndInstalledVersion[0];\n\t\tString installedVersion = statusAndInstalledVersion[1];\n\n\t\tModuleId moduleIdObj = ModuleId.getInstance(moduleId);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(name);\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(author);\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(shortDescription);\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(longDescription);\n\n\t\tString content = sb.toString();\n\n\t\tDocument document = new DocumentImpl();\n\n\t\tdocument.addUID(PORTLET_ID, moduleId);\n\n\t\tdocument.addModifiedDate(modifiedDate);\n\n\t\tdocument.addKeyword(Field.COMPANY_ID, CompanyConstants.SYSTEM);\n\t\tdocument.addKeyword(Field.PORTLET_ID, PORTLET_ID);\n\t\tdocument.addKeyword(Field.GROUP_ID, moduleIdObj.getGroupId());\n\n\t\tdocument.addText(Field.TITLE, name);\n\t\tdocument.addText(Field.CONTENT, content);\n\n\t\tdocument.addKeyword(\"moduleId\", moduleId);\n\t\tdocument.addKeyword(\"artifactId\", moduleIdObj.getArtifactId());\n\t\tdocument.addKeyword(\"version\", version);\n\t\tdocument.addText(\"author\", author);\n\t\tdocument.addKeyword(\"type\", types.toArray(new String[0]));\n\t\tdocument.addKeyword(\"tag\", tags.toArray(new String[0]));\n\n\t\tString[] licenseNames = new String[licenses.size()];\n\n\t\tboolean osiLicense = false;\n\n\t\tfor (int i = 0; i < licenses.size(); i++) {\n\t\t\tLicense license = licenses.get(i);\n\n\t\t\tlicenseNames[i] = license.getName();\n\n\t\t\tif (license.isOsiApproved()) {\n\t\t\t\tosiLicense = true;\n\t\t\t}\n\t\t}\n\n\t\tdocument.addKeyword(\"license\", licenseNames);\n\t\tdocument.addKeyword(\"osi-approved-license\", String.valueOf(osiLicense));\n\t\tdocument.addText(\"shortDescription\", shortDescription);\n\t\tdocument.addText(\"longDescription\", longDescription);\n\t\tdocument.addText(\"changeLog\", changeLog);\n\t\tdocument.addText(\"pageURL\", pageURL);\n\t\tdocument.addKeyword(\"repositoryURL\", repositoryURL);\n\t\tdocument.addKeyword(Field.STATUS, status);\n\t\tdocument.addKeyword(\"installedVersion\", installedVersion);\n\n\t\treturn document;\n\t}","id":104724,"modified_method":"protected Document doGetDocument(Object obj) throws Exception {\n\t\tPluginPackage pluginPackage = (PluginPackage)obj;\n\n\t\tDocument document = new DocumentImpl();\n\n\t\tdocument.addUID(PORTLET_ID, pluginPackage.getModuleId());\n\n\t\tdocument.addKeyword(Field.COMPANY_ID, CompanyConstants.SYSTEM);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(pluginPackage.getAuthor());\n\t\tsb.append(StringPool.SPACE);\n\n\t\tString longDescription = HtmlUtil.extractText(\n\t\t\tpluginPackage.getLongDescription());\n\n\t\tsb.append(longDescription);\n\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(pluginPackage.getName());\n\t\tsb.append(StringPool.SPACE);\n\n\t\tString shortDescription = HtmlUtil.extractText(\n\t\t\tpluginPackage.getShortDescription());\n\n\t\tsb.append(shortDescription);\n\n\t\tdocument.addText(Field.CONTENT, sb.toString());\n\n\t\tdocument.addKeyword(Field.PORTLET_ID, PORTLET_ID);\n\n\t\tModuleId moduleIdObj = ModuleId.getInstance(\n\t\t\tpluginPackage.getModuleId());\n\n\t\tdocument.addKeyword(Field.GROUP_ID, moduleIdObj.getGroupId());\n\n\t\tdocument.addDate(Field.MODIFIED_DATE, pluginPackage.getModifiedDate());\n\n\t\tString[] statusAndInstalledVersion =\n\t\t\tPluginPackageUtil.getStatusAndInstalledVersion(pluginPackage);\n\n\t\tdocument.addKeyword(Field.STATUS, statusAndInstalledVersion[0]);\n\n\t\tdocument.addText(Field.TITLE, pluginPackage.getName());\n\n\t\tdocument.addKeyword(\"artifactId\", moduleIdObj.getArtifactId());\n\t\tdocument.addText(\"author\", pluginPackage.getAuthor());\n\t\tdocument.addText(\"changeLog\", pluginPackage.getChangeLog());\n\t\tdocument.addKeyword(\"installedVersion\", statusAndInstalledVersion[1]);\n\n\t\tList<License> licenses = pluginPackage.getLicenses();\n\n\t\tdocument.addKeyword(\n\t\t\t\"license\", StringUtil.split(ListUtil.toString(licenses, \"name\")));\n\n\t\tdocument.addText(\"longDescription\", longDescription);\n\t\tdocument.addKeyword(\"moduleId\", pluginPackage.getModuleId());\n\n\t\tboolean osiLicense = false;\n\n\t\tfor (int i = 0; i < licenses.size(); i++) {\n\t\t\tLicense license = licenses.get(i);\n\n\t\t\tif (license.isOsiApproved()) {\n\t\t\t\tosiLicense = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdocument.addKeyword(\"osi-approved-license\", osiLicense);\n\t\tdocument.addText(\"pageURL\", pluginPackage.getPageURL());\n\t\tdocument.addKeyword(\"repositoryURL\", pluginPackage.getRepositoryURL());\n\t\tdocument.addText(\"shortDescription\", shortDescription);\n\n\t\tList<String> tags = pluginPackage.getTags();\n\n\t\tdocument.addKeyword(\"tag\", tags.toArray(new String[0]));\n\n\t\tList<String> types = pluginPackage.getTypes();\n\n\t\tdocument.addKeyword(\"type\", types.toArray(new String[0]));\n\n\t\tdocument.addKeyword(\"version\", pluginPackage.getVersion());\n\n\t\treturn document;\n\t}","commit_id":"a46a2a55ae400b16da702cc413c34965507d266c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void attach(View parent, View child) {\n    View oldParent = child.parent();\n    if (oldParent != null) {\n      oldParent.children().remove(oldParent.children().indexOf(child));\n    }\n    parent.children().add(child);\n  }","id":104725,"modified_method":"protected void attach(View parent, View child) {\n    View oldParent = child.parent().get();\n    if (oldParent != null) {\n      oldParent.children().remove(oldParent.children().indexOf(child));\n    }\n    parent.children().add(child);\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void createViewForChildNode(SNode childNode, GenericViewCell parentCell, View parentView, EditorContext editorContext) {\n    GenericViewCell childCell = (GenericViewCell) editorContext.createNodeCell(childNode);\n    parentCell.addEditorCell(childCell);\n\n    View childView = childCell.getView();\n    View oldParent = childView.parent();\n    if (oldParent != null) {\n      oldParent.children().remove(oldParent.children().indexOf(childView));\n    }\n    parentView.children().add(childView);\n  }","id":104726,"modified_method":"public static void createViewForChildNode(SNode childNode, GenericViewCell parentCell, View parentView, EditorContext editorContext) {\n    GenericViewCell childCell = (GenericViewCell) editorContext.createNodeCell(childNode);\n    parentCell.addEditorCell(childCell);\n\n    View childView = childCell.getView();\n    View oldParent = childView.parent().get();\n    if (oldParent != null) {\n      oldParent.children().remove(oldParent.children().indexOf(childView));\n    }\n    parentView.children().add(childView);\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean updateConnectionEnds(DiagramViewCell rootCell) {\n    View connectorView = getView();\n    View fromView = getInputView(rootCell);\n    View toView = getOutputView(rootCell);\n    if (fromView != null && toView != null) {\n      if (connectorView.parent() != null) {\n        connectorView.parent().children().remove(connectorView.parent().children().indexOf(connectorView));\n      }\n      connectorView.invalidate();\n      myConnection.toView().set(toView);\n      myConnection.fromView().set(fromView);\n      return true;\n    }\n    return false;\n\n  }","id":104727,"modified_method":"public boolean updateConnectionEnds(DiagramViewCell rootCell) {\n    View connectorView = getView();\n    View fromView = getInputView(rootCell);\n    View toView = getOutputView(rootCell);\n    if (fromView != null && toView != null) {\n      if (connectorView.parent().get() != null) {\n        connectorView.parent().get().children().remove(connectorView.parent().get().children().indexOf(connectorView));\n      }\n      connectorView.invalidate();\n      myConnection.toView().set(toView);\n      myConnection.fromView().set(fromView);\n      return true;\n    }\n    return false;\n\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void createConnection(EditorCell_Collection linesCell, ConnectorViewCell connectorCell, View connectorView, View fromView, View toView, EditorContext editorContext, SNode diagramNode) {\n    PolylineConnection connection = connectorCell.getConnection();\n    if (connectorView.parent() != null) {\n      connectorView.parent().children().remove(connectorView.parent().children().indexOf(connectorView));\n    }\n    connection.view().invalidate();\n    connection.toView().set(toView);\n    connection.fromView().set(fromView);\n\n    myView.connections.add(connection);\n    myView.validate();\n\n    for (LineView line : ListSequence.fromList(connection.getLines())) {\n      connectorCell.addEditorCell(GenericViewCell.createViewCell(editorContext, diagramNode, line));\n    }\n    linesCell.addEditorCell(connectorCell);\n  }","id":104728,"modified_method":"private void createConnection(EditorCell_Collection linesCell, ConnectorViewCell connectorCell, View connectorView, View fromView, View toView, EditorContext editorContext, SNode diagramNode) {\n    PolylineConnection connection = connectorCell.getConnection();\n    if (connectorView.parent().get() != null) {\n      connectorView.parent().get().children().remove(connectorView.parent().get().children().indexOf(connectorView));\n    }\n    connection.view().invalidate();\n    connection.toView().set(toView);\n    connection.fromView().set(fromView);\n\n    myView.connections.add(connection);\n    myView.validate();\n\n    for (LineView line : ListSequence.fromList(connection.getLines())) {\n      connectorCell.addEditorCell(GenericViewCell.createViewCell(editorContext, diagramNode, line));\n    }\n    linesCell.addEditorCell(connectorCell);\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void createDiagram_tb7paq_c0_0(List<SNode> nlist, EditorContext editorContext, List<ConnectorViewCell> connectorCellList, jetbrains.mps.openapi.editor.cells.EditorCell_Collection blockCollection, DiagramView view) {\n    for (SNode contentNode : ListSequence.fromList(nlist)) {\n      EditorCell contentCell = editorContext.createNodeCell(contentNode);\n      if (!(contentCell instanceof GenericViewCell)) {\n        continue;\n      }\n      GenericViewCell genericContentCell = (GenericViewCell) contentCell;\n      if (genericContentCell instanceof ConnectorViewCell) {\n        final ConnectorViewCell connectorCell = (ConnectorViewCell) (genericContentCell);\n        connectorCell.removeAllCells();\n        ListSequence.fromList(connectorCellList).addElement(connectorCell);\n      } else {\n        View blockView = genericContentCell.getView();\n        blockCollection.addEditorCell(genericContentCell);\n        View oldParent = blockView.parent();\n        if (oldParent != null) {\n          oldParent.children().remove(oldParent.children().indexOf(blockView));\n        }\n        view.itemsView.children().add(blockView);\n      }\n    }\n  }","id":104729,"modified_method":"public static void createDiagram_tb7paq_c0_0(List<SNode> nlist, EditorContext editorContext, List<ConnectorViewCell> connectorCellList, jetbrains.mps.openapi.editor.cells.EditorCell_Collection blockCollection, DiagramView view) {\n    for (SNode contentNode : ListSequence.fromList(nlist)) {\n      EditorCell contentCell = editorContext.createNodeCell(contentNode);\n      if (!(contentCell instanceof GenericViewCell)) {\n        continue;\n      }\n      GenericViewCell genericContentCell = (GenericViewCell) contentCell;\n      if (genericContentCell instanceof ConnectorViewCell) {\n        final ConnectorViewCell connectorCell = (ConnectorViewCell) (genericContentCell);\n        connectorCell.removeAllCells();\n        ListSequence.fromList(connectorCellList).addElement(connectorCell);\n      } else {\n        View blockView = genericContentCell.getView();\n        blockCollection.addEditorCell(genericContentCell);\n        View oldParent = blockView.parent().get();\n        if (oldParent != null) {\n          oldParent.children().remove(oldParent.children().indexOf(blockView));\n        }\n        view.itemsView.children().add(blockView);\n      }\n    }\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void createDiagram_tb7paq_e0_0(List<SNode> nlist, EditorContext editorContext, List<ConnectorViewCell> connectorCellList, jetbrains.mps.openapi.editor.cells.EditorCell_Collection blockCollection, DiagramView view) {\n    for (SNode contentNode : ListSequence.fromList(nlist)) {\n      EditorCell contentCell = editorContext.createNodeCell(contentNode);\n      if (!(contentCell instanceof GenericViewCell)) {\n        continue;\n      }\n      GenericViewCell genericContentCell = (GenericViewCell) contentCell;\n      if (genericContentCell instanceof ConnectorViewCell) {\n        final ConnectorViewCell connectorCell = (ConnectorViewCell) (genericContentCell);\n        connectorCell.removeAllCells();\n        ListSequence.fromList(connectorCellList).addElement(connectorCell);\n      } else {\n        View blockView = genericContentCell.getView();\n        blockCollection.addEditorCell(genericContentCell);\n        View oldParent = blockView.parent();\n        if (oldParent != null) {\n          oldParent.children().remove(oldParent.children().indexOf(blockView));\n        }\n        view.itemsView.children().add(blockView);\n      }\n    }\n  }","id":104730,"modified_method":"public static void createDiagram_tb7paq_e0_0(List<SNode> nlist, EditorContext editorContext, List<ConnectorViewCell> connectorCellList, jetbrains.mps.openapi.editor.cells.EditorCell_Collection blockCollection, DiagramView view) {\n    for (SNode contentNode : ListSequence.fromList(nlist)) {\n      EditorCell contentCell = editorContext.createNodeCell(contentNode);\n      if (!(contentCell instanceof GenericViewCell)) {\n        continue;\n      }\n      GenericViewCell genericContentCell = (GenericViewCell) contentCell;\n      if (genericContentCell instanceof ConnectorViewCell) {\n        final ConnectorViewCell connectorCell = (ConnectorViewCell) (genericContentCell);\n        connectorCell.removeAllCells();\n        ListSequence.fromList(connectorCellList).addElement(connectorCell);\n      } else {\n        View blockView = genericContentCell.getView();\n        blockCollection.addEditorCell(genericContentCell);\n        View oldParent = blockView.parent().get();\n        if (oldParent != null) {\n          oldParent.children().remove(oldParent.children().indexOf(blockView));\n        }\n        view.itemsView.children().add(blockView);\n      }\n    }\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void attach(View parent, View inputPortView) {\n    if (inputPortView.parent() != null) {\n      inputPortView.parent().children().remove(inputPortView.parent().children().indexOf(inputPortView));\n    }\n    parent.children().add(inputPortView);\n  }","id":104731,"modified_method":"private void attach(View parent, View inputPortView) {\n    if (inputPortView.parent() != null) {\n      inputPortView.parent().get().children().remove(inputPortView.parent().get().children().indexOf(inputPortView));\n    }\n    parent.children().add(inputPortView);\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void attach(View parent, View inputPortView) {\n    if (inputPortView.parent() != null) {\n      inputPortView.parent().children().remove(inputPortView.parent().children().indexOf(inputPortView));\n    }\n    parent.children().add(inputPortView);\n  }","id":104732,"modified_method":"private void attach(View parent, View inputPortView) {\n    if (inputPortView.parent().get() != null) {\n      inputPortView.parent().get().children().remove(inputPortView.parent().get().children().indexOf(inputPortView));\n    }\n    parent.children().add(inputPortView);\n  }","commit_id":"128e264cd04dfcb217acab638ebf8f27a9d07508","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void run() {\n        try {\n            client.callProcedure(\"SetupAdHocTables\");\n        } catch (Exception e) {\n            log.error(\"SetupAdHocTables failed in AdHocMayhemThread. Will exit.\", e);\n            Benchmark.printJStack();\n            System.exit(-1);\n        }\n\n        while (m_shouldContinue.get()) {\n\n            // if a transaction callback has failed, sleep for 3 seconds\n            // if not, connected, continue to sleep\n            if (m_needsBlock.get()) {\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (client.getConnectedHostList().size() == 0);\n                m_needsBlock.set(false);\n            }\n\n            // get a permit to send a transaction\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"AdHocMayhemThread interrupted while waiting for permit. Will end AdHoc work.\", e);\n                return;\n            }\n\n            // call a transaction\n            String sql = nextAdHoc();\n            try {\n                m_permits.acquire();\n                client.callProcedure(new AdHocCallback(), \"@AdHoc\", sql);\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"AdHocMayhemThread got NoConnectionsException on proc call. Will sleep.\");\n                m_needsBlock.set(true);\n            }\n            catch (Exception e) {\n                log.error(\"AdHocMayhemThread failed to run an AdHoc statement. Will exit.\", e);\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n        }\n    }","id":104733,"modified_method":"@Override\n    public void run() {\n        try {\n            client.callProcedure(\"SetupAdHocTables\");\n        } catch (Exception e) {\n            hardStop(\"SetupAdHocTables failed in AdHocMayhemThread. Will exit.\", e);\n        }\n\n        while (m_shouldContinue.get()) {\n\n            // if a transaction callback has failed, sleep for 3 seconds\n            // if not, connected, continue to sleep\n            if (m_needsBlock.get()) {\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (client.getConnectedHostList().size() == 0);\n                m_needsBlock.set(false);\n            }\n\n            // get a permit to send a transaction\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"AdHocMayhemThread interrupted while waiting for permit. Will end AdHoc work.\", e);\n                return;\n            }\n\n            // call a transaction\n            String sql = nextAdHoc();\n            try {\n                m_permits.acquire();\n                client.callProcedure(new AdHocCallback(), \"@AdHoc\", sql);\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"AdHocMayhemThread got NoConnectionsException on proc call. Will sleep.\");\n                m_needsBlock.set(true);\n            }\n            catch (Exception e) {\n                hardStop(\"AdHocMayhemThread failed to run an AdHoc statement. Will exit.\", e);\n            }\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            if (shutdown.get()) {\n                return;\n            }\n\n            activeConnections.decrementAndGet();\n\n            // reset the connection id so the client will connect to a recovered cluster\n            // this is a bit of a hack\n            if (connectionsLeft == 0) {\n                ((ClientImpl) client).resetInstanceId();\n            }\n\n            // if the benchmark is still active\n            if ((System.currentTimeMillis() - benchmarkStartTS) < (config.duration * 1000)) {\n                log.warn(String.format(\"Connection to %s:%d was lost.\", hostname, port));\n            }\n\n            // setup for retry\n            final String server = MiscUtils.getHostnameColonPortString(hostname, port);\n            es.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                }\n            });\n        }","id":104734,"modified_method":"/**\n         * Remove the client from the list if connection is broken.\n         */\n        @Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            if (shutdown.get()) {\n                return;\n            }\n\n            activeConnections.decrementAndGet();\n\n            // reset the connection id so the client will connect to a recovered cluster\n            // this is a bit of a hack\n            if (connectionsLeft == 0) {\n                ((ClientImpl) client).resetInstanceId();\n            }\n\n            // if the benchmark is still active\n            if ((System.currentTimeMillis() - benchmarkStartTS) < (config.duration * 1000)) {\n                log.warn(String.format(\"Connection to %s:%d was lost.\", hostname, port));\n            }\n\n            // setup for retry\n            final String server = MiscUtils.getHostnameColonPortString(hostname, port);\n            es.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                }\n            });\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE ||\n                    status == ClientResponse.USER_ABORT) {\n                // log what happened\n                log.error(\"BigTableLoader gracefully failed to insert into table \" + tableName + \" and this shoudn't happen. Exiting.\");\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                Benchmark.printJStack();\n                // stop the world\n                System.exit(-1);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"BigTableLoader ungracefully failed to insert into table \" + tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n            }\n            else {\n                Benchmark.txnCount.incrementAndGet();\n                rowsLoaded++;\n            }\n            latch.countDown();\n        }","id":104735,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE ||\n                    status == ClientResponse.USER_ABORT) {\n                // log what happened\n                hardStop(\"BigTableLoader gracefully failed to insert into table \" + tableName + \" and this shoudn't happen. Exiting.\");\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"BigTableLoader ungracefully failed to insert into table \" + tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n            }\n            else {\n                Benchmark.txnCount.incrementAndGet();\n                rowsLoaded++;\n            }\n            latch.countDown();\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void handleException(ClientResponseImpl cri, Exception e) {\n        // this is not an error\n        if ((cri.getStatus() == ClientResponse.USER_ABORT) &&\n                cri.getStatusString().contains(\"EXPECTED ROLLBACK\")) {\n            return;\n        }\n        // this implies bad data and is fatal\n        if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                (cri.getStatus() == ClientResponse.USER_ABORT)) {\n            log.error(\"ClientThread had a proc-call exception that indicated bad data\", e);\n            log.error(cri.toJSONString(), e);\n            Benchmark.printJStack();\n            System.exit(-1);\n        }\n        // other proc call exceptions are logged, but don't stop the thread\n        else {\n            log.warn(\"ClientThread had a proc-call exception that didn't indicate bad data: \" + e.getMessage());\n            log.warn(cri.toJSONString());\n\n            // take a breather to avoid slamming the log (stay paused if no connections)\n            do {\n                try { Thread.sleep(3000); } catch (Exception e2) {} // sleep for 3s\n                // bail on wakeup if we're supposed to bail\n                if (!m_shouldContinue.get()) {\n                    return;\n                }\n            }\n            while (m_client.getConnectedHostList().size() == 0);\n\n        }\n    }","id":104736,"modified_method":"void handleException(ClientResponseImpl cri, Exception e) {\n        // this is not an error\n        if ((cri.getStatus() == ClientResponse.USER_ABORT) &&\n                cri.getStatusString().contains(\"EXPECTED ROLLBACK\")) {\n            return;\n        }\n        // this implies bad data and is fatal\n        if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                (cri.getStatus() == ClientResponse.USER_ABORT)) {\n            hardStop(\"ClientThread had a proc-call exception that indicated bad data\", cri);\n        }\n        // other proc call exceptions are logged, but don't stop the thread\n        else {\n            log.warn(\"ClientThread had a proc-call exception that didn't indicate bad data: \" + e.getMessage());\n            log.warn(cri.toJSONString());\n\n            // take a breather to avoid slamming the log (stay paused if no connections)\n            do {\n                try { Thread.sleep(3000); } catch (Exception e2) {} // sleep for 3s\n                // bail on wakeup if we're supposed to bail\n                if (!m_shouldContinue.get()) {\n                    return;\n                }\n            }\n            while (m_client.getConnectedHostList().size() == 0);\n\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            try {\n                m_permits.acquire();\n                runOne();\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"ClientThread got NoConnectionsException on proc call. Will sleep.\");\n                // take a breather to avoid slamming the log (stay paused if no connections)\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e2) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (m_client.getConnectedHostList().size() == 0);\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                handleException(cri, e);\n            }\n            catch (UserProcCallException e) {\n                ClientResponseImpl cri = e.cri;\n                handleException(cri, e);\n            }\n            catch (InterruptedException e) {\n                // just need to fall through and get out\n            }\n            catch (InterruptedIOException e) {\n                // just need to fall through and get out\n            }\n            catch (Exception e) {\n                log.error(\"ClientThread had a non proc-call exception\", e);\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n        }\n    }","id":104737,"modified_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            try {\n                m_permits.acquire();\n                runOne();\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"ClientThread got NoConnectionsException on proc call. Will sleep.\");\n                // take a breather to avoid slamming the log (stay paused if no connections)\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e2) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (m_client.getConnectedHostList().size() == 0);\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                handleException(cri, e);\n            }\n            catch (UserProcCallException e) {\n                ClientResponseImpl cri = e.cri;\n                handleException(cri, e);\n            }\n            catch (InterruptedException e) {\n                // just need to fall through and get out\n            }\n            catch (InterruptedIOException e) {\n                // just need to fall through and get out\n            }\n            catch (Exception e) {\n                hardStop(\"ClientThread had a non proc-call exception\", e);\n            }\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void runOne() throws Exception {\n        // 1/10th of txns roll back\n        byte shouldRollback = (byte) (m_random.nextInt(10) == 0 ? 1 : 0);\n\n        try {\n            String procName = null;\n            int expectedTables = 4;\n            switch (m_type) {\n            case PARTITIONED_SP:\n                procName = \"UpdatePartitionedSP\";\n                break;\n            case PARTITIONED_MP:\n                procName = \"UpdatePartitionedMP\";\n                expectedTables = 5;\n                break;\n            case REPLICATED:\n                procName = \"UpdateReplicatedMP\";\n                expectedTables = 5;\n                break;\n            case HYBRID:\n                procName = \"UpdateBothMP\";\n                expectedTables = 5;\n                break;\n            case ADHOC_MP:\n                procName = \"UpdateReplicatedMPInProcAdHoc\";\n                expectedTables = 5;\n                break;\n            }\n\n            byte[] payload = m_processor.generateForStore().getStoreValue();\n\n            ClientResponse response;\n            try {\n                response = m_client.callProcedure(procName,\n                        m_cid,\n                        m_nextRid,\n                        payload,\n                        shouldRollback);\n            } catch (Exception e) {\n                if (shouldRollback == 0) {\n                    log.warn(\"ClientThread threw after \" + m_txnsRun.get() +\n                            \" calls while calling procedure: \" + procName +\n                            \" with args: cid: \" + m_cid + \", nextRid: \" + m_nextRid +\n                            \", payload: \" + payload +\n                            \", shouldRollback: \" + shouldRollback);\n                }\n                throw e;\n            }\n\n            // fake a proc call exception if we think one should be thrown\n            if (response.getStatus() != ClientResponse.SUCCESS) {\n                throw new UserProcCallException(response);\n            }\n\n            VoltTable[] results = response.getResults();\n\n            m_txnsRun.incrementAndGet();\n\n            if (results.length != expectedTables) {\n                log.error(String.format(\n                        \"Client cid %d procedure %s returned %d results instead of %d\",\n                        m_cid, procName, results.length, expectedTables));\n                log.error(((ClientResponseImpl) response).toJSONString());\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n            VoltTable data = results[3];\n            try {\n                UpdateBaseProc.validateCIDData(data, \"ClientThread:\" + m_cid);\n            }\n            catch (VoltAbortException vae) {\n                log.error(\"validateCIDData failed on: \" + procName + \", shouldRollback: \" +\n                        shouldRollback + \" data: \" + data);\n                throw vae;\n            }\n        }\n        finally {\n            // ensure rid is incremented (if not rolled back intentionally)\n            if (shouldRollback == 0) {\n                m_nextRid++;\n            }\n        }\n    }","id":104738,"modified_method":"void runOne() throws Exception {\n        // 1/10th of txns roll back\n        byte shouldRollback = (byte) (m_random.nextInt(10) == 0 ? 1 : 0);\n\n        try {\n            String procName = null;\n            int expectedTables = 4;\n            switch (m_type) {\n            case PARTITIONED_SP:\n                procName = \"UpdatePartitionedSP\";\n                break;\n            case PARTITIONED_MP:\n                procName = \"UpdatePartitionedMP\";\n                expectedTables = 5;\n                break;\n            case REPLICATED:\n                procName = \"UpdateReplicatedMP\";\n                expectedTables = 5;\n                break;\n            case HYBRID:\n                procName = \"UpdateBothMP\";\n                expectedTables = 5;\n                break;\n            case ADHOC_MP:\n                procName = \"UpdateReplicatedMPInProcAdHoc\";\n                expectedTables = 5;\n                break;\n            }\n\n            byte[] payload = m_processor.generateForStore().getStoreValue();\n\n            ClientResponse response;\n            try {\n                response = m_client.callProcedure(procName,\n                        m_cid,\n                        m_nextRid,\n                        payload,\n                        shouldRollback);\n            } catch (Exception e) {\n                if (shouldRollback == 0) {\n                    log.warn(\"ClientThread threw after \" + m_txnsRun.get() +\n                            \" calls while calling procedure: \" + procName +\n                            \" with args: cid: \" + m_cid + \", nextRid: \" + m_nextRid +\n                            \", payload: \" + payload +\n                            \", shouldRollback: \" + shouldRollback);\n                }\n                throw e;\n            }\n\n            // fake a proc call exception if we think one should be thrown\n            if (response.getStatus() != ClientResponse.SUCCESS) {\n                throw new UserProcCallException(response);\n            }\n\n            VoltTable[] results = response.getResults();\n\n            m_txnsRun.incrementAndGet();\n\n            if (results.length != expectedTables) {\n                hardStop(String.format(\n                        \"Client cid %d procedure %s returned %d results instead of %d\",\n                        m_cid, procName, results.length, expectedTables), response);\n            }\n            VoltTable data = results[3];\n            try {\n                UpdateBaseProc.validateCIDData(data, \"ClientThread:\" + m_cid);\n            }\n            catch (VoltAbortException vae) {\n                log.error(\"validateCIDData failed on: \" + procName + \", shouldRollback: \" +\n                        shouldRollback + \" data: \" + data);\n                throw vae;\n            }\n        }\n        finally {\n            // ensure rid is incremented (if not rolled back intentionally)\n            if (shouldRollback == 0) {\n                m_nextRid++;\n            }\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        int count = 0;\n        int errcnt = 0;\n        while (m_shouldContinue.get()) {\n            // call a ddl transaction\n            log.info (createOrDrop[count]);\n            try {\n                ClientResponse cr = TxnId2Utils.doAdHoc(client, createOrDrop[count]);\n                if (cr.getStatus() != ClientResponse.SUCCESS) {\n                    log.error(\"Catalog update failed: \" + cr.getStatusString());\n                    throw new RuntimeException(\"stop the world\");\n                } else {\n                    log.info(\"Catalog update success #\" + Long.toString(progressInd.get()) + \" : \" + createOrDrop[count]);\n                    progressInd.getAndIncrement();\n                    Benchmark.txnCount.incrementAndGet();\n                    errcnt = 0;\n                }\n            }\n            catch (ProcCallException e) {\n                ClientResponse cr = e.getClientResponse();\n                if (cr.getStatusString().matches(\"Unexpected exception applying DDL statements to original catalog: DDL Error: \\\"object name already exists:.*\")) {\n                    if (errcnt > 1) {\n                        log.error(\"too many catalog update errors\");\n                        throw new RuntimeException(\"stop the world\");\n                    } else\n                        errcnt++;\n                }\n            }\n            catch (Exception e) {\n                log.error(\"DdlThread threw an error:\", e);\n                throw new RuntimeException(e);\n            }\n            count = ++count & 1;\n            try { Thread.sleep(10000); }\n            catch (Exception e) {}\n        }\n        log.info(getName() + \" thread has stopped\");\n    }","id":104739,"modified_method":"@Override\n    public void run() {\n        int count = 0;\n        int errcnt = 0;\n        while (m_shouldContinue.get()) {\n            // call a ddl transaction\n            log.info (createOrDrop[count]);\n            try {\n                ClientResponse cr = TxnId2Utils.doAdHoc(client, createOrDrop[count]);\n                if (cr.getStatus() != ClientResponse.SUCCESS) {\n                    hardStop(\"DDL failed: \" + cr.getStatusString());\n                } else {\n                    log.info(\"Catalog update success #\" + Long.toString(progressInd.get()) + \" : \" + createOrDrop[count]);\n                    progressInd.getAndIncrement();\n                    Benchmark.txnCount.incrementAndGet();\n                    errcnt = 0;\n                }\n            }\n            catch (ProcCallException e) {\n                ClientResponse cr = e.getClientResponse();\n                if (cr.getStatusString().matches(\"Unexpected exception applying DDL statements to original catalog: DDL Error: \\\"object name already exists:.*\")) {\n                    if (errcnt > 1) {\n                        hardStop(\"too many ddl errors\", e);\n                    } else\n                        errcnt++;\n                }\n            }\n            catch (Exception e) {\n                hardStop(\"DdlThread threw an error:\", e);\n            }\n            count = ++count & 1;\n            try { Thread.sleep(10000); }\n            catch (Exception e) {}\n        }\n        log.info(getName() + \" thread has stopped\");\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            // if not, connected, sleep\n            if (m_needsBlock.get()) {\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (client.getConnectedHostList().size() == 0);\n                m_needsBlock.set(false);\n            } else {\n                try { Thread.sleep(1); } catch (Exception e) {}\n            }\n\n\n            // get a permit to send a transaction\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"InvokeDroppedProcedureThread interrupted while waiting for permit. Will end.\", e);\n                return;\n            }\n\n            // call a transaction\n            try {\n                boolean write = r.nextInt() % 2 == 0;\n                if (write) {\n                    client.callProcedure(new InvokeDroppedCallback(), \"droppedRead\", r.nextInt());\n                } else {\n                    client.callProcedure(new InvokeDroppedCallback(), \"droppedWrite\", r.nextInt());\n                }\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"InvokeDroppedProcedureThread got NoConnectionsException on proc call. Will sleep.\");\n                m_needsBlock.set(true);\n            }\n            catch (Exception e) {\n                log.error(\"InvokeDroppedProcedureThread failed to run client. Will exit.\", e);\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n        }\n    }","id":104740,"modified_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            // if not, connected, sleep\n            if (m_needsBlock.get()) {\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (client.getConnectedHostList().size() == 0);\n                m_needsBlock.set(false);\n            } else {\n                try { Thread.sleep(1); } catch (Exception e) {}\n            }\n\n\n            // get a permit to send a transaction\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"InvokeDroppedProcedureThread interrupted while waiting for permit. Will end.\", e);\n                return;\n            }\n\n            // call a transaction\n            try {\n                boolean write = r.nextInt() % 2 == 0;\n                if (write) {\n                    client.callProcedure(new InvokeDroppedCallback(), \"droppedRead\", r.nextInt());\n                } else {\n                    client.callProcedure(new InvokeDroppedCallback(), \"droppedWrite\", r.nextInt());\n                }\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"InvokeDroppedProcedureThread got NoConnectionsException on proc call. Will sleep.\");\n                m_needsBlock.set(true);\n            }\n            catch (Exception e) {\n                hardStop(\"InvokeDroppedProcedureThread failed to run client. Will exit.\", e);\n            }\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            latch.countDown();\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE) {\n                // log what happened\n                log.error(\"LoadTableLoader gracefully failed to delete from table \" + m_tableName + \" and this shoudn't happen. Exiting.\");\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the world\n                System.exit(-1);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"LoadTableLoader ungracefully failed to copy from table \" + m_tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n            Benchmark.txnCount.incrementAndGet();\n            long cnt = clientResponse.getResults()[0].asScalarLong();\n            if (cnt != expected_delete) {\n                log.error(\"LoadTableLoader ungracefully failed to delete: \" + m_tableName + \" count=\" + cnt);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n        }","id":104741,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            latch.countDown();\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE) {\n                // log what happened\n                hardStop(\"LoadTableLoader gracefully failed to delete from table \" + m_tableName + \" and this shoudn't happen. Exiting.\", clientResponse);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"LoadTableLoader ungracefully failed to copy from table \" + m_tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n            Benchmark.txnCount.incrementAndGet();\n            long cnt = clientResponse.getResults()[0].asScalarLong();\n            if (cnt != expected_delete) {\n                log.error(\"LoadTableLoader ungracefully failed to delete: \" + m_tableName + \" count=\" + cnt);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n\n        CopyAndDeleteDataTask cdtask = new CopyAndDeleteDataTask();\n        cdtask.start();\n        try {\n            while (m_shouldContinue.get()) {\n                //1 in 3 gets copied and then deleted after leaving some data\n                byte shouldCopy = (byte) (m_random.nextInt(3) == 0 ? 1 : 0);\n                CountDownLatch latch = new CountDownLatch(batchSize);\n                final ArrayList<Long> lcpDelQueue = new ArrayList<Long>();\n\n                // try to insert batchSize random rows\n                for (int i = 0; i < batchSize; i++) {\n                    m_table.clearRowData();\n                    m_permits.acquire();\n                    long p = Math.abs(r.nextLong());\n                    m_table.addRow(p, p, Calendar.getInstance().getTimeInMillis());\n                    boolean success = false;\n                    if (!m_isMP) {\n                        Object rpartitionParam\n                                = TheHashinator.valueToBytes(m_table.fetchRow(0).get(\n                                                m_partitionedColumnIndex, VoltType.BIGINT));\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, rpartitionParam, m_tableName, m_table);\n                    } else {\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, m_tableName, m_table);\n                    }\n                    //Ad if successfully queued but remove if proc fails.\n                    if (success) {\n                        if (shouldCopy != 0) {\n                            lcpDelQueue.add(p);\n                        } else {\n                            onlyDelQueue.add(p);\n                        }\n                    }\n                }\n                //Wait for all @Load{SP|MP}Done\n                latch.await();\n                cpDelQueue.addAll(lcpDelQueue);\n                long nextRowCount = 0;\n                try { nextRowCount = TxnId2Utils.getRowCount(client, m_tableName);\n                } catch (Exception e) {\n                    log.error(\"getrowcount exception\", e);\n                    System.exit(-1);\n                }\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount.get()) {\n                    Thread.sleep(1000);\n                }\n                if (onlyDelQueue.size() > 0 && m_shouldContinue.get()) {\n                    List<Long> workList = new ArrayList<Long>();\n                    onlyDelQueue.drainTo(workList);\n                    CountDownLatch odlatch = new CountDownLatch(workList.size());\n                    for (Long lcid : workList) {\n                        client.callProcedure(new DeleteCallback(odlatch, 1), m_onlydelprocName, lcid);\n                    }\n                    odlatch.await();\n                }\n            }\n            //Any accumulated in p/mp tables are left behind.\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"LoadTableLoader failed a procedure call for table \" + m_tableName\n                    + \" and the thread will now stop.\", e);\n        } finally {\n            cdtask.shutdown();\n            try {\n                cdtask.join();\n            } catch (InterruptedException ex) {\n                log.error(\"CopyDelete Task was stopped.\", ex);\n            }\n        }\n    }","id":104742,"modified_method":"@Override\n    public void run() {\n\n        CopyAndDeleteDataTask cdtask = new CopyAndDeleteDataTask();\n        cdtask.start();\n        try {\n            while (m_shouldContinue.get()) {\n                //1 in 3 gets copied and then deleted after leaving some data\n                byte shouldCopy = (byte) (m_random.nextInt(3) == 0 ? 1 : 0);\n                CountDownLatch latch = new CountDownLatch(batchSize);\n                final ArrayList<Long> lcpDelQueue = new ArrayList<Long>();\n\n                // try to insert batchSize random rows\n                for (int i = 0; i < batchSize; i++) {\n                    m_table.clearRowData();\n                    m_permits.acquire();\n                    long p = Math.abs(r.nextLong());\n                    m_table.addRow(p, p, Calendar.getInstance().getTimeInMillis());\n                    boolean success = false;\n                    if (!m_isMP) {\n                        Object rpartitionParam\n                                = TheHashinator.valueToBytes(m_table.fetchRow(0).get(\n                                                m_partitionedColumnIndex, VoltType.BIGINT));\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, rpartitionParam, m_tableName, m_table);\n                    } else {\n                        success = client.callProcedure(new InsertCallback(latch, p, shouldCopy), m_procName, m_tableName, m_table);\n                    }\n                    //Ad if successfully queued but remove if proc fails.\n                    if (success) {\n                        if (shouldCopy != 0) {\n                            lcpDelQueue.add(p);\n                        } else {\n                            onlyDelQueue.add(p);\n                        }\n                    }\n                }\n                //Wait for all @Load{SP|MP}Done\n                latch.await();\n                cpDelQueue.addAll(lcpDelQueue);\n                long nextRowCount = 0;\n                try { nextRowCount = TxnId2Utils.getRowCount(client, m_tableName);\n                } catch (Exception e) {\n                    hardStop(\"getrowcount exception\", e);\n                }\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount.get()) {\n                    Thread.sleep(1000);\n                }\n                if (onlyDelQueue.size() > 0 && m_shouldContinue.get()) {\n                    List<Long> workList = new ArrayList<Long>();\n                    onlyDelQueue.drainTo(workList);\n                    CountDownLatch odlatch = new CountDownLatch(workList.size());\n                    for (Long lcid : workList) {\n                        client.callProcedure(new DeleteCallback(odlatch, 1), m_onlydelprocName, lcid);\n                    }\n                    odlatch.await();\n                }\n            }\n            //Any accumulated in p/mp tables are left behind.\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"LoadTableLoader failed a procedure call for table \" + m_tableName\n                    + \" and the thread will now stop.\", e);\n        } finally {\n            cdtask.shutdown();\n            try {\n                cdtask.join();\n            } catch (InterruptedException ex) {\n                log.error(\"CopyDelete Task was stopped.\", ex);\n            }\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            latch.countDown();\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE || status == ClientResponse.UNEXPECTED_FAILURE) {\n                // log what happened status will be logged in json error log.\n                log.error(\"LoadTableLoader failed to insert into table \" + m_tableName + \" and this shoudn't happen. Exiting.\");\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the world\n                System.exit(-1);\n            }\n            //Connection loss node failure will come down here along with user aborts from procedure.\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"LoadTableLoader ungracefully failed to insert into table \" + m_tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n            Benchmark.txnCount.incrementAndGet();\n        }","id":104743,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            latch.countDown();\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE || status == ClientResponse.UNEXPECTED_FAILURE) {\n                // log what happened status will be logged in json error log.\n                hardStop(\"LoadTableLoader failed to insert into table \" + m_tableName + \" and this shoudn't happen. Exiting.\", clientResponse);\n            }\n            //Connection loss node failure will come down here along with user aborts from procedure.\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"LoadTableLoader ungracefully failed to insert into table \" + m_tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n            Benchmark.txnCount.incrementAndGet();\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            currentRowCount.incrementAndGet();\n            latch.countDown();\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE) {\n                // log what happened\n                log.error(\"LoadTableLoader gracefully failed to copy from table \" + m_tableName + \" and this shoudn't happen. Exiting.\");\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the world\n                System.exit(-1);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"LoadTableLoader ungracefully failed to copy from table \" + m_tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n            Benchmark.txnCount.incrementAndGet();\n        }","id":104744,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            currentRowCount.incrementAndGet();\n            latch.countDown();\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE) {\n                // log what happened\n                hardStop(\"LoadTableLoader gracefully failed to copy from table \" + m_tableName + \" and this shoudn't happen. Exiting.\", clientResponse);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"LoadTableLoader ungracefully failed to copy from table \" + m_tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the loader\n                m_shouldContinue.set(false);\n            }\n            Benchmark.txnCount.incrementAndGet();\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n\n            // if a transaction callback has failed, sleep for 3 seconds\n            // if not, connected, continue to sleep\n            if (m_needsBlock.get()) {\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (client.getConnectedHostList().size() == 0);\n                m_needsBlock.set(false);\n            }\n\n            // get a permit to send a transaction\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"ReadThread interrupted while waiting for permit\", e);\n                return;\n            }\n\n            // 1/5 of all reads are MP\n            boolean replicated = (counter % 100) < (this.mpRatio * 100.);\n            // 1/23th of all SP reads are in-proc adhoc\n            boolean inprocAdhoc = (counter % 23) == 0;\n            counter++;\n            String procName = replicated ? \"ReadMP\" : \"ReadSP\";\n            if (inprocAdhoc && allowInProcAdhoc) procName += \"InProcAdHoc\";\n            byte cid = (byte) (r.nextInt(threadCount) + threadOffset);\n\n            // call a transaction\n            try {\n                m_permits.acquire();\n                client.callProcedure(new ReadCallback(), procName, cid);\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"ReadThread got NoConnectionsException on proc call. Will sleep.\");\n                m_needsBlock.set(true);\n            }\n            catch (Exception e) {\n                log.error(\"ReadThread failed to run a procedure. Will exit.\", e);\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n        }\n    }","id":104745,"modified_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n\n            // if a transaction callback has failed, sleep for 3 seconds\n            // if not, connected, continue to sleep\n            if (m_needsBlock.get()) {\n                do {\n                    try { Thread.sleep(3000); } catch (Exception e) {} // sleep for 3s\n                    // bail on wakeup if we're supposed to bail\n                    if (!m_shouldContinue.get()) {\n                        return;\n                    }\n                }\n                while (client.getConnectedHostList().size() == 0);\n                m_needsBlock.set(false);\n            }\n\n            // get a permit to send a transaction\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"ReadThread interrupted while waiting for permit\", e);\n                return;\n            }\n\n            // 1/5 of all reads are MP\n            boolean replicated = (counter % 100) < (this.mpRatio * 100.);\n            // 1/23th of all SP reads are in-proc adhoc\n            boolean inprocAdhoc = (counter % 23) == 0;\n            counter++;\n            String procName = replicated ? \"ReadMP\" : \"ReadSP\";\n            if (inprocAdhoc && allowInProcAdhoc) procName += \"InProcAdHoc\";\n            byte cid = (byte) (r.nextInt(threadCount) + threadOffset);\n\n            // call a transaction\n            try {\n                m_permits.acquire();\n                client.callProcedure(new ReadCallback(), procName, cid);\n            }\n            catch (NoConnectionsException e) {\n                log.error(\"ReadThread got NoConnectionsException on proc call. Will sleep.\");\n                m_needsBlock.set(true);\n            }\n            catch (Exception e) {\n                hardStop(\"ReadThread failed to run a procedure. Will exit.\", e);\n            }\n        }\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            txnsOutstanding.release();\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                log.error(\"Non success in ProcCallback for ReadThread\");\n                log.error(((ClientResponseImpl)clientResponse).toJSONString());\n                m_needsBlock.set(true);\n                return;\n            }\n            Benchmark.txnCount.incrementAndGet();\n            // validate the data\n            try {\n                VoltTable data = clientResponse.getResults()[0];\n                UpdateBaseProc.validateCIDData(data, ReadThread.class.getName());\n            }\n            catch (Exception e) {\n                log.error(\"ReadThread got a bad response\", e);\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n        }","id":104746,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            txnsOutstanding.release();\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                log.error(\"Non success in ProcCallback for ReadThread\");\n                log.error(((ClientResponseImpl)clientResponse).toJSONString());\n                m_needsBlock.set(true);\n                return;\n            }\n            Benchmark.txnCount.incrementAndGet();\n            // validate the data\n            try {\n                VoltTable data = clientResponse.getResults()[0];\n                UpdateBaseProc.validateCIDData(data, ReadThread.class.getName());\n            }\n            catch (Exception e) {\n                hardStop(\"ReadThread got a bad response\", e);\n            }\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        byte[] data = new byte[rowSize];\n        byte shouldRollback = 0;\n        long currentRowCount = 0;\n        while (m_shouldContinue.get()) {\n            r.nextBytes(data);\n\n            try {\n                currentRowCount = TxnId2Utils.getRowCount(client, tableName);\n            } catch (Exception e) {\n                log.error(\"getrowcount exception\", e);\n                System.exit(-1);\n            }\n\n            try {\n                // insert some batches...\n                int tc = batchSize * r.nextInt(99);\n                while ((currentRowCount < tc) && (m_shouldContinue.get())) {\n                    CountDownLatch latch = new CountDownLatch(batchSize);\n                    // try to insert batchSize random rows\n                    for (int i = 0; i < batchSize; i++) {\n                        long p = Math.abs(r.nextLong());\n                        m_permits.acquire();\n                        insertsTried++;\n                        client.callProcedure(new InsertCallback(latch), tableName.toUpperCase() + \"TableInsert\", p, data);\n                    }\n                    latch.await(10, TimeUnit.SECONDS);\n                    long nextRowCount = -1;\n                    try {\n                        nextRowCount = TxnId2Utils.getRowCount(client, tableName);\n                    } catch (Exception e) {\n                        log.error(\"getrowcount exception\", e);\n                        System.exit(-1);\n                    }\n                    // if no progress, throttle a bit\n                    if (nextRowCount == currentRowCount) {\n                        try { Thread.sleep(1000); } catch (Exception e2) {}\n                    }\n                    currentRowCount = nextRowCount;\n                }\n            }\n            catch (Exception e) {\n                // on exception, log and end the thread, but don't kill the process\n                log.error(\"TruncateTableLoader failed a TableInsert procedure call for table '\" + tableName + \"' \" + e.getMessage());\n                try { Thread.sleep(3000); } catch (Exception e2) {}\n            }\n\n\n            // truncate the table, check for zero rows\n            try {\n                currentRowCount = TxnId2Utils.getRowCount(client, tableName);\n            } catch (Exception e) {\n                log.error(\"getrowcount exception\", e);\n                System.exit(-1);\n            }\n\n            try {\n                log.debug(\"TruncateTableLoader truncate table...\" + tableName + \" current row count is \" + currentRowCount);\n                shouldRollback = (byte) (r.nextInt(10) == 0 ? 1 : 0);\n                long p = Math.abs(r.nextLong());\n                String tp = this.truncateProcedure;\n                if (tableName == \"trup\")\n                    tp += r.nextInt(100) < mpRatio * 100. ? \"MP\" : \"SP\";\n                ClientResponse clientResponse = client.callProcedure(tableName.toUpperCase() + tp, p, shouldRollback);\n                byte status = clientResponse.getStatus();\n                if (status == ClientResponse.GRACEFUL_FAILURE ||\n                        (shouldRollback == 0 && status == ClientResponse.USER_ABORT)) {\n                    log.error(\"TruncateTableLoader gracefully failed to truncate table \" + tableName + \" and this shoudn't happen. Exiting.\");\n                    log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                    Benchmark.printJStack();\n                    // stop the world\n                    System.exit(-1);\n                }\n                if (status != ClientResponse.SUCCESS) {\n                    // log what happened\n                    log.error(\"TruncateTableLoader ungracefully failed to truncate table \" + tableName);\n                    log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                }\n                else {\n                    Benchmark.txnCount.incrementAndGet();\n                    nTruncates++;\n                }\n                shouldRollback = 0;\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                if (shouldRollback == 0) {\n                    // this implies bad data and is fatal\n                    if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                            (cri.getStatus() == ClientResponse.USER_ABORT)) {\n                        // on exception, log and end the thread, but don't kill the process\n                        log.error(\"TruncateTableLoader failed a TruncateTable ProcCallException call for table '\" + tableName + \"' \" + e.getMessage());\n                        Benchmark.printJStack();\n                        System.exit(-1);\n                    }\n                }\n            }\n            catch (InterruptedIOException e) {\n                // just need to fall through and get out\n            }\n            catch (Exception e) {\n                // on exception, log and end the thread, but don't kill the process\n                log.error(\"TruncateTableLoader failed a non-proc call exception for table '\" + tableName + \"' \" + e.getMessage());\n                try { Thread.sleep(3000); } catch (Exception e2) {}\n            }\n\n            // scan-agg table\n            try {\n                currentRowCount = TxnId2Utils.getRowCount(client, tableName);\n            } catch (Exception e) {\n                log.error(\"getrowcount exception\", e);\n                System.exit(-1);\n            }\n\n            try {\n                log.debug(\"TruncateTableLoader scan agg table...\" + tableName + \" current row count is \" + currentRowCount);\n                shouldRollback = (byte) (r.nextInt(10) == 0 ? 1 : 0);\n                long p = Math.abs(r.nextLong());\n                String sp = this.scanAggProcedure;\n                if (tableName == \"trup\")\n                    sp += r.nextInt(100) < mpRatio * 100. ? \"MP\" : \"SP\";\n                ClientResponse clientResponse = client.callProcedure(tableName.toUpperCase() + sp, p, shouldRollback);\n                byte status = clientResponse.getStatus();\n                if (status == ClientResponse.GRACEFUL_FAILURE ||\n                        (shouldRollback == 0 && status == ClientResponse.USER_ABORT)) {\n                    log.error(\"TruncateTableLoader gracefully failed to scan-agg table \" + tableName + \" and this shoudn't happen. Exiting.\");\n                    log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                    Benchmark.printJStack();\n                    // stop the world\n                    System.exit(-1);\n                }\n                if (status != ClientResponse.SUCCESS) {\n                    // log what happened\n                    log.error(\"TruncateTableLoader ungracefully failed to scan-agg table \" + tableName);\n                    log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                }\n                else\n                    Benchmark.txnCount.incrementAndGet();\n                shouldRollback = 0;\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                if (shouldRollback == 0) {\n                    // this implies bad data and is fatal\n                    if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                            (cri.getStatus() == ClientResponse.USER_ABORT)) {\n                        // on exception, log and end the thread, but don't kill the process\n                        log.error(\"TruncateTableLoader failed a ScanAgg ProcCallException call for table '\" + tableName + \"' \" + e.getMessage());\n                        Benchmark.printJStack();\n                        System.exit(-1);\n                    }\n                }\n            }\n            catch (InterruptedIOException e) {\n                // just need to fall through and get out\n            }\n            catch (Exception e) {\n                // on exception, log and end the thread, but don't kill the process\n                log.error(\"TruncateTableLoader failed a non-proc call exception for table '\" + tableName + \"' \" + e.getMessage());\n                try { Thread.sleep(3000); } catch (Exception e2) {}\n            }\n        }\n        log.info(\"TruncateTableLoader normal exit for table \" + tableName + \" rows sent: \" + insertsTried + \" inserted: \" + rowsLoaded + \" truncates: \" + nTruncates);\n    }","id":104747,"modified_method":"@Override\n    public void run() {\n        byte[] data = new byte[rowSize];\n        byte shouldRollback = 0;\n        long currentRowCount = 0;\n        while (m_shouldContinue.get()) {\n            r.nextBytes(data);\n\n            try {\n                currentRowCount = TxnId2Utils.getRowCount(client, tableName);\n            } catch (Exception e) {\n                hardStop(\"getrowcount exception\", e);\n            }\n\n            try {\n                // insert some batches...\n                int tc = batchSize * r.nextInt(99);\n                while ((currentRowCount < tc) && (m_shouldContinue.get())) {\n                    CountDownLatch latch = new CountDownLatch(batchSize);\n                    // try to insert batchSize random rows\n                    for (int i = 0; i < batchSize; i++) {\n                        long p = Math.abs(r.nextLong());\n                        m_permits.acquire();\n                        insertsTried++;\n                        client.callProcedure(new InsertCallback(latch), tableName.toUpperCase() + \"TableInsert\", p, data);\n                    }\n                    latch.await(10, TimeUnit.SECONDS);\n                    long nextRowCount = -1;\n                    try {\n                        nextRowCount = TxnId2Utils.getRowCount(client, tableName);\n                    } catch (Exception e) {\n                        hardStop(\"getrowcount exception\", e);\n                    }\n                    // if no progress, throttle a bit\n                    if (nextRowCount == currentRowCount) {\n                        try { Thread.sleep(1000); } catch (Exception e2) {}\n                    }\n                    currentRowCount = nextRowCount;\n                }\n            }\n            catch (Exception e) {\n                // on exception, log and end the thread, but don't kill the process\n                log.error(\"TruncateTableLoader failed a TableInsert procedure call for table '\" + tableName + \"' \" + e.getMessage());\n                try { Thread.sleep(3000); } catch (Exception e2) {}\n            }\n\n\n            // truncate the table, check for zero rows\n            try {\n                currentRowCount = TxnId2Utils.getRowCount(client, tableName);\n            } catch (Exception e) {\n                hardStop(\"getrowcount exception\", e);\n            }\n\n            try {\n                log.debug(\"TruncateTableLoader truncate table...\" + tableName + \" current row count is \" + currentRowCount);\n                shouldRollback = (byte) (r.nextInt(10) == 0 ? 1 : 0);\n                long p = Math.abs(r.nextLong());\n                String tp = this.truncateProcedure;\n                if (tableName == \"trup\")\n                    tp += r.nextInt(100) < mpRatio * 100. ? \"MP\" : \"SP\";\n                ClientResponse clientResponse = client.callProcedure(tableName.toUpperCase() + tp, p, shouldRollback);\n                byte status = clientResponse.getStatus();\n                if (status == ClientResponse.GRACEFUL_FAILURE ||\n                        (shouldRollback == 0 && status == ClientResponse.USER_ABORT)) {\n                    hardStop(\"TruncateTableLoader gracefully failed to truncate table \" + tableName + \" and this shoudn't happen. Exiting.\", clientResponse);\n                }\n                if (status != ClientResponse.SUCCESS) {\n                    // log what happened\n                    log.error(\"TruncateTableLoader ungracefully failed to truncate table \" + tableName);\n                    log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                }\n                else {\n                    Benchmark.txnCount.incrementAndGet();\n                    nTruncates++;\n                }\n                shouldRollback = 0;\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                if (shouldRollback == 0) {\n                    // this implies bad data and is fatal\n                    if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                            (cri.getStatus() == ClientResponse.USER_ABORT)) {\n                        // on exception, log and end the thread, but don't kill the process\n                        hardStop(\"TruncateTableLoader failed a TruncateTable ProcCallException call for table '\" + tableName + \"' \" + e.getMessage());\n                    }\n                }\n            }\n            catch (NoConnectionsException e) {\n                // on exception, log and end the thread, but don't kill the process\n                log.error(\"TruncateTableLoader failed a non-proc call exception for table '\" + tableName + \"' \" + e.getMessage());\n                try { Thread.sleep(3000); } catch (Exception e2) {}\n            }\n            catch (IOException e) {\n                // just need to fall through and get out\n                throw new RuntimeException(e);\n            }\n\n            // scan-agg table\n            try {\n                currentRowCount = TxnId2Utils.getRowCount(client, tableName);\n            } catch (Exception e) {\n                hardStop(\"getrowcount exception\", e);\n            }\n\n            try {\n                log.debug(\"TruncateTableLoader scan agg table...\" + tableName + \" current row count is \" + currentRowCount);\n                shouldRollback = (byte) (r.nextInt(10) == 0 ? 1 : 0);\n                long p = Math.abs(r.nextLong());\n                String sp = this.scanAggProcedure;\n                if (tableName == \"trup\")\n                    sp += r.nextInt(100) < mpRatio * 100. ? \"MP\" : \"SP\";\n                ClientResponse clientResponse = client.callProcedure(tableName.toUpperCase() + sp, p, shouldRollback);\n                byte status = clientResponse.getStatus();\n                if (status == ClientResponse.GRACEFUL_FAILURE ||\n                        (shouldRollback == 0 && status == ClientResponse.USER_ABORT)) {\n                    hardStop(\"TruncateTableLoader gracefully failed to scan-agg table \" + tableName + \" and this shoudn't happen. Exiting.\", clientResponse);\n                }\n                if (status != ClientResponse.SUCCESS) {\n                    // log what happened\n                    log.error(\"TruncateTableLoader ungracefully failed to scan-agg table \" + tableName);\n                    log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                }\n                else\n                    Benchmark.txnCount.incrementAndGet();\n                shouldRollback = 0;\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                if (shouldRollback == 0) {\n                    // this implies bad data and is fatal\n                    if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                            (cri.getStatus() == ClientResponse.USER_ABORT)) {\n                        // on exception, log and end the thread, but don't kill the process\n                        hardStop(\"TruncateTableLoader failed a ScanAgg ProcCallException call for table '\" + tableName + \"' \" + e.getMessage());\n                    }\n                }\n            }\n            catch (NoConnectionsException e) {\n                // on exception, log and end the thread, but don't kill the process\n                log.error(\"TruncateTableLoader failed a non-proc call exception for table '\" + tableName + \"' \" + e.getMessage());\n                try { Thread.sleep(3000); } catch (Exception e2) {}\n            }\n            catch (IOException e) {\n                // just need to fall through and get out\n                throw new RuntimeException(e);\n            }\n        }\n        log.info(\"TruncateTableLoader normal exit for table \" + tableName + \" rows sent: \" + insertsTried + \" inserted: \" + rowsLoaded + \" truncates: \" + nTruncates);\n    }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE ||\n                    status == ClientResponse.USER_ABORT) {\n                // log what happened\n                log.error(\"TruncateTableLoader gracefully failed to insert into table \" + tableName + \" and this shoudn't happen. Exiting.\");\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                Benchmark.printJStack();\n                // stop the world\n                System.exit(-1);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"TruncateTableLoader ungracefully failed to insert into table \" + tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n            }\n            else {\n                Benchmark.txnCount.incrementAndGet();\n                rowsLoaded++;\n            }\n            latch.countDown();\n        }","id":104748,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            byte status = clientResponse.getStatus();\n            if (status == ClientResponse.GRACEFUL_FAILURE ||\n                    status == ClientResponse.USER_ABORT) {\n                // log what happened\n                hardStop(\"TruncateTableLoader gracefully failed to insert into table \" + tableName + \" and this shoudn't happen. Exiting.\", clientResponse);\n            }\n            if (status != ClientResponse.SUCCESS) {\n                // log what happened\n                log.error(\"TruncateTableLoader ungracefully failed to insert into table \" + tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n            }\n            else {\n                Benchmark.txnCount.incrementAndGet();\n                rowsLoaded++;\n            }\n            latch.countDown();\n        }","commit_id":"7c073c11ac4716879686badd632e2709e5d190c1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private static boolean arrayContentsAreWritten(PsiVariable variable,\n                                                   PsiElement context){\n        if(VariableAccessUtils.arrayContentsAreAssigned(variable, context)){\n            return true;\n        }\n        final PsiExpression initializer = variable.getInitializer();\n        if(initializer != null && !isDefaultArrayInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                                                                    context);\n    }","id":104749,"modified_method":"private static boolean arrayContentsAreWritten(PsiVariable variable,\n                                                   PsiElement context){\n        if(VariableAccessUtils.arrayContentsAreAssigned(variable, context)){\n            return true;\n        }\n        final PsiExpression initializer = variable.getInitializer();\n        if(initializer != null && !isDefaultArrayInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                                                                context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsUsedInArrayInitializer(variable,\n                                                                    context);\n    }","commit_id":"eaa81fe44a8f54e6ece36423b3dd2fca73a9588b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean arrayContentsAreRead(PsiVariable variable,\n                                                PsiElement context){\n        if(VariableAccessUtils.arrayContentsAreAccessed(variable, context)){\n            return true;\n        }\n        final PsiExpression initializer = variable.getInitializer();\n        if(initializer != null && !isDefaultArrayInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                                                                    context);\n    }","id":104750,"modified_method":"private static boolean arrayContentsAreRead(PsiVariable variable,\n                                                PsiElement context){\n        if(VariableAccessUtils.arrayContentsAreAccessed(variable, context)){\n            return true;\n        }\n        final PsiExpression initializer = variable.getInitializer();\n        if(initializer != null && !isDefaultArrayInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                                                                context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsUsedInArrayInitializer(variable,\n                                                                    context);\n    }","commit_id":"eaa81fe44a8f54e6ece36423b3dd2fca73a9588b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean collectionContentsAreQueried(PsiVariable variable,\n                                                        PsiElement context){\n        final PsiExpression initializer = variable.getInitializer();\n        if(collectionQueryCalled(variable, context)){\n            return true;\n        }\n        if(initializer != null && !isEmptyCollectionInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsPassedAsMethodArgument(variable, context);\n    }","id":104751,"modified_method":"private static boolean collectionContentsAreQueried(PsiVariable variable,\n                                                        PsiElement context){\n        final PsiExpression initializer = variable.getInitializer();\n        if(collectionQueryCalled(variable, context)){\n            return true;\n        }\n        if(initializer != null && !isEmptyCollectionInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                                                                context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsUsedInArrayInitializer(variable,\n                                                                    context);\n    }","commit_id":"eaa81fe44a8f54e6ece36423b3dd2fca73a9588b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean collectionContentsAreUpdated(PsiVariable variable,\n                                                        PsiElement context){\n        if(collectionUpdateCalled(variable, context)){\n            return true;\n        }\n        final PsiExpression initializer = variable.getInitializer();\n        if(initializer != null && !isEmptyCollectionInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsPassedAsMethodArgument(variable, context);\n    }","id":104752,"modified_method":"private static boolean collectionContentsAreUpdated(PsiVariable variable,\n                                                        PsiElement context){\n        if(collectionUpdateCalled(variable, context)){\n            return true;\n        }\n        final PsiExpression initializer = variable.getInitializer();\n        if(initializer != null && !isEmptyCollectionInitializer(initializer)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssigned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsAssignedFrom(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsReturned(variable, context)){\n            return true;\n        }\n        if(VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                                                                context)){\n            return true;\n        }\n        return VariableAccessUtils.variableIsUsedInArrayInitializer(variable,\n                                                                    context);\n    }","commit_id":"eaa81fe44a8f54e6ece36423b3dd2fca73a9588b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerBuiltinIndexSettings() {\n        registerIndexDynamicSetting(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_READ_ONLY, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_READ, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_WRITE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_METADATA, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_PRIORITY, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(PrimaryShardAllocator.INDEX_RECOVERY_INITIAL_SHARDS, Validator.EMPTY);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, Validator.INTEGER_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, Validator.DOUBLE_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, Validator.NON_NEGATIVE_DOUBLE);\n    }","id":104753,"modified_method":"private void registerBuiltinIndexSettings() {\n        registerIndexDynamicSetting(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_READ_ONLY, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_READ, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_WRITE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_METADATA, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_PRIORITY, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(PrimaryShardAllocator.INDEX_RECOVERY_INITIAL_SHARDS, Validator.EMPTY);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, Validator.DOUBLE_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, Validator.NON_NEGATIVE_DOUBLE);\n    }","commit_id":"7e5e93c73a2c7c831a12fcea680538bc9e87d4a2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"void onRefreshSettings(Settings settings) {\n        final double oldSegmentsPerTier = mergePolicy.getSegmentsPerTier();\n        final double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, oldSegmentsPerTier);\n        if (segmentsPerTier != oldSegmentsPerTier) {\n            logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", oldSegmentsPerTier, segmentsPerTier);\n            mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        }\n\n        final int oldMaxMergeAtOnceExplicit = mergePolicy.getMaxMergeAtOnceExplicit();\n        final int maxMergeAtOnceExplicit = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, oldMaxMergeAtOnceExplicit);\n        if (maxMergeAtOnceExplicit != oldMaxMergeAtOnceExplicit) {\n            logger.info(\"updating [max_merge_at_once_explicit] from [{}] to [{}]\", oldMaxMergeAtOnceExplicit, maxMergeAtOnceExplicit);\n            mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        }\n\n        final double oldMaxMergedSegmentMB = mergePolicy.getMaxMergedSegmentMB();\n        final ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, null);\n        if (maxMergedSegment != null && maxMergedSegment.mbFrac() != oldMaxMergedSegmentMB) {\n            logger.info(\"updating [max_merged_segment] from [{}mb] to [{}]\", oldMaxMergedSegmentMB, maxMergedSegment);\n            mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        }\n\n        final double oldReclaimDeletesWeight = mergePolicy.getReclaimDeletesWeight();\n        final double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, oldReclaimDeletesWeight);\n        if (reclaimDeletesWeight != oldReclaimDeletesWeight) {\n            logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", oldReclaimDeletesWeight, reclaimDeletesWeight);\n            mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        }\n    }","id":104754,"modified_method":"void onRefreshSettings(Settings settings) {\n        final double oldSegmentsPerTier = mergePolicy.getSegmentsPerTier();\n        final double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, oldSegmentsPerTier);\n        if (segmentsPerTier != oldSegmentsPerTier) {\n            logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", oldSegmentsPerTier, segmentsPerTier);\n            mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        }\n\n        final double oldMaxMergedSegmentMB = mergePolicy.getMaxMergedSegmentMB();\n        final ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, null);\n        if (maxMergedSegment != null && maxMergedSegment.mbFrac() != oldMaxMergedSegmentMB) {\n            logger.info(\"updating [max_merged_segment] from [{}mb] to [{}]\", oldMaxMergedSegmentMB, maxMergedSegment);\n            mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        }\n\n        final double oldReclaimDeletesWeight = mergePolicy.getReclaimDeletesWeight();\n        final double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, oldReclaimDeletesWeight);\n        if (reclaimDeletesWeight != oldReclaimDeletesWeight) {\n            logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", oldReclaimDeletesWeight, reclaimDeletesWeight);\n            mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        }\n    }","commit_id":"7e5e93c73a2c7c831a12fcea680538bc9e87d4a2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING, this::floorSegmentSetting);\n         indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING, this::maxMergesAtOnce);\n        double forceMergeDeletesPctAllowed = indexSettings.getValue(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING); // percentage\n        ByteSizeValue floorSegment = indexSettings.getValue(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING);\n        int maxMergeAtOnce = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING);\n        int maxMergeAtOnceExplicit = indexSettings.getSettings().getAsInt(\"index.merge.policy.max_merge_at_once_explicit\", DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.max_merged_segment\", DEFAULT_MAX_MERGED_SEGMENT);\n        double segmentsPerTier = indexSettings.getSettings().getAsDouble(\"index.merge.policy.segments_per_tier\", DEFAULT_SEGMENTS_PER_TIER);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","id":104755,"modified_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING, this::floorSegmentSetting);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING, this::maxMergesAtOnce);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING, this::maxMergesAtOnceExplicit);\n        double forceMergeDeletesPctAllowed = indexSettings.getValue(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING); // percentage\n        ByteSizeValue floorSegment = indexSettings.getValue(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING);\n        int maxMergeAtOnce = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING);\n        int maxMergeAtOnceExplicit = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.max_merged_segment\", DEFAULT_MAX_MERGED_SEGMENT);\n        double segmentsPerTier = indexSettings.getSettings().getAsDouble(\"index.merge.policy.segments_per_tier\", DEFAULT_SEGMENTS_PER_TIER);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","commit_id":"7e5e93c73a2c7c831a12fcea680538bc9e87d4a2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb(), ByteSizeUnit.MB).mbFrac(), 0.00);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n    }","id":104756,"modified_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb(), ByteSizeUnit.MB).mbFrac(), 0.00);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n    }","commit_id":"7e5e93c73a2c7c831a12fcea680538bc9e87d4a2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ClusterModule(Settings settings) {\n        this.settings = settings;\n\n        registerBuiltinIndexSettings();\n\n        for (Class<? extends AllocationDecider> decider : ClusterModule.DEFAULT_ALLOCATION_DECIDERS) {\n            registerAllocationDecider(decider);\n        }\n        registerShardsAllocator(ClusterModule.BALANCED_ALLOCATOR, BalancedShardsAllocator.class);\n        registerShardsAllocator(ClusterModule.EVEN_SHARD_COUNT_ALLOCATOR, BalancedShardsAllocator.class);\n    }","id":104757,"modified_method":"public ClusterModule(Settings settings) {\n        this.settings = settings;\n        for (Class<? extends AllocationDecider> decider : ClusterModule.DEFAULT_ALLOCATION_DECIDERS) {\n            registerAllocationDecider(decider);\n        }\n        registerShardsAllocator(ClusterModule.BALANCED_ALLOCATOR, BalancedShardsAllocator.class);\n        registerShardsAllocator(ClusterModule.EVEN_SHARD_COUNT_ALLOCATOR, BalancedShardsAllocator.class);\n    }","commit_id":"0b59b12801246c54a5fc97c3511934e1b9c3b08c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Updates the settings and index metadata and notifies all registered settings consumers with the new settings iff at least one setting has changed.\n     *\n     * @return <code>true<\/code> iff any setting has been updated otherwise <code>false<\/code>.\n     */\n    synchronized boolean updateIndexMetaData(IndexMetaData indexMetaData) {\n        final Settings newSettings = indexMetaData.getSettings();\n        if (Version.indexCreated(newSettings) != version) {\n            throw new IllegalArgumentException(\"version mismatch on settings update expected: \" + version + \" but was: \" + Version.indexCreated(newSettings));\n        }\n        final String newUUID = newSettings.get(IndexMetaData.SETTING_INDEX_UUID, IndexMetaData.INDEX_UUID_NA_VALUE);\n        if (newUUID.equals(getUUID()) == false) {\n            throw new IllegalArgumentException(\"uuid mismatch on settings update expected: \" + uuid + \" but was: \" + newUUID);\n        }\n        this.indexMetaData = indexMetaData;\n        final Settings existingSettings = this.settings;\n        if (existingSettings.getByPrefix(IndexMetaData.INDEX_SETTING_PREFIX).getAsMap().equals(newSettings.getByPrefix(IndexMetaData.INDEX_SETTING_PREFIX).getAsMap())) {\n            // nothing to update, same settings\n            return false;\n        }\n        scopedSettings.applySettings(newSettings);\n\n        // nocommit\n        final Settings mergedSettings = this.settings = Settings.builder().put(nodeSettings).put(newSettings).build();\n        try {\n            updateSettings(mergedSettings);\n        } catch (Exception e) {\n            logger.warn(\"failed to refresh index settings for [{}]\", e, mergedSettings);\n        }\n        return true;\n    }","id":104758,"modified_method":"/**\n     * Updates the settings and index metadata and notifies all registered settings consumers with the new settings iff at least one setting has changed.\n     *\n     * @return <code>true<\/code> iff any setting has been updated otherwise <code>false<\/code>.\n     */\n    synchronized boolean updateIndexMetaData(IndexMetaData indexMetaData) {\n        final Settings newSettings = indexMetaData.getSettings();\n        if (Version.indexCreated(newSettings) != version) {\n            throw new IllegalArgumentException(\"version mismatch on settings update expected: \" + version + \" but was: \" + Version.indexCreated(newSettings));\n        }\n        final String newUUID = newSettings.get(IndexMetaData.SETTING_INDEX_UUID, IndexMetaData.INDEX_UUID_NA_VALUE);\n        if (newUUID.equals(getUUID()) == false) {\n            throw new IllegalArgumentException(\"uuid mismatch on settings update expected: \" + uuid + \" but was: \" + newUUID);\n        }\n        this.indexMetaData = indexMetaData;\n        final Settings existingSettings = this.settings;\n        if (existingSettings.getByPrefix(IndexMetaData.INDEX_SETTING_PREFIX).getAsMap().equals(newSettings.getByPrefix(IndexMetaData.INDEX_SETTING_PREFIX).getAsMap())) {\n            // nothing to update, same settings\n            return false;\n        }\n        scopedSettings.applySettings(newSettings);\n        this.settings = Settings.builder().put(nodeSettings).put(newSettings).build();\n        return true;\n    }","commit_id":"0b59b12801246c54a5fc97c3511934e1b9c3b08c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING, this::floorSegmentSetting);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING, this::maxMergesAtOnce);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING, this::maxMergesAtOnceExplicit);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING, this::maxMergedSegment);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER_SETTING, this::segmentsPerTier);\n        double forceMergeDeletesPctAllowed = indexSettings.getValue(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING); // percentage\n        ByteSizeValue floorSegment = indexSettings.getValue(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING);\n        int maxMergeAtOnce = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING);\n        int maxMergeAtOnceExplicit = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING);\n        double segmentsPerTier = indexSettings.getValue(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER_SETTING);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","id":104759,"modified_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING, this::floorSegmentSetting);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING, this::maxMergesAtOnce);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING, this::maxMergesAtOnceExplicit);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING, this::maxMergedSegment);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER_SETTING, this::segmentsPerTier);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT_SETTING, this::reclaimDeletesWeight);\n        double forceMergeDeletesPctAllowed = indexSettings.getValue(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING); // percentage\n        ByteSizeValue floorSegment = indexSettings.getValue(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING);\n        int maxMergeAtOnce = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING);\n        int maxMergeAtOnceExplicit = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING);\n        double segmentsPerTier = indexSettings.getValue(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER_SETTING);\n        double reclaimDeletesWeight = indexSettings.getValue(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT_SETTING);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","commit_id":"0b59b12801246c54a5fc97c3511934e1b9c3b08c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER_SETTING.getKey(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb(), ByteSizeUnit.MB).mbFrac(), 0.00);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        assertEquals(((TieredMergePolicy)indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n    }","id":104760,"modified_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT_SETTING.getKey(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER_SETTING.getKey(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS)); // see if defaults are restored\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb(), ByteSizeUnit.MB).mbFrac(), 0.00);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n    }","commit_id":"0b59b12801246c54a5fc97c3511934e1b9c3b08c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void registerBuiltinIndexSettings() {\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, Validator.DOUBLE_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, Validator.NON_NEGATIVE_DOUBLE);\n    }","id":104761,"modified_method":"private void registerBuiltinIndexSettings() {\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, Validator.DOUBLE_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, Validator.NON_NEGATIVE_DOUBLE);\n    }","commit_id":"1f0ab587900ed90ce2ed484b6af454e2a665c132","url":"https://github.com/elastic/elasticsearch"},{"original_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING, this::floorSegmentSetting);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING, this::maxMergesAtOnce);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING, this::maxMergesAtOnceExplicit);\n        double forceMergeDeletesPctAllowed = indexSettings.getValue(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING); // percentage\n        ByteSizeValue floorSegment = indexSettings.getValue(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING);\n        int maxMergeAtOnce = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING);\n        int maxMergeAtOnceExplicit = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.max_merged_segment\", DEFAULT_MAX_MERGED_SEGMENT);\n        double segmentsPerTier = indexSettings.getSettings().getAsDouble(\"index.merge.policy.segments_per_tier\", DEFAULT_SEGMENTS_PER_TIER);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","id":104762,"modified_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING, this::floorSegmentSetting);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING, this::maxMergesAtOnce);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING, this::maxMergesAtOnceExplicit);\n        indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING, this::maxMergedSegment);\n        double forceMergeDeletesPctAllowed = indexSettings.getValue(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING); // percentage\n        ByteSizeValue floorSegment = indexSettings.getValue(INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING);\n        int maxMergeAtOnce = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING);\n        int maxMergeAtOnceExplicit = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getValue(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING);\n        double segmentsPerTier = indexSettings.getSettings().getAsDouble(\"index.merge.policy.segments_per_tier\", DEFAULT_SEGMENTS_PER_TIER);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","commit_id":"1f0ab587900ed90ce2ed484b6af454e2a665c132","url":"https://github.com/elastic/elasticsearch"},{"original_method":"void onRefreshSettings(Settings settings) {\n        final double oldSegmentsPerTier = mergePolicy.getSegmentsPerTier();\n        final double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, oldSegmentsPerTier);\n        if (segmentsPerTier != oldSegmentsPerTier) {\n            logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", oldSegmentsPerTier, segmentsPerTier);\n            mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        }\n\n        final double oldMaxMergedSegmentMB = mergePolicy.getMaxMergedSegmentMB();\n        final ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, null);\n        if (maxMergedSegment != null && maxMergedSegment.mbFrac() != oldMaxMergedSegmentMB) {\n            logger.info(\"updating [max_merged_segment] from [{}mb] to [{}]\", oldMaxMergedSegmentMB, maxMergedSegment);\n            mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        }\n\n        final double oldReclaimDeletesWeight = mergePolicy.getReclaimDeletesWeight();\n        final double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, oldReclaimDeletesWeight);\n        if (reclaimDeletesWeight != oldReclaimDeletesWeight) {\n            logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", oldReclaimDeletesWeight, reclaimDeletesWeight);\n            mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        }\n    }","id":104763,"modified_method":"void onRefreshSettings(Settings settings) {\n        final double oldSegmentsPerTier = mergePolicy.getSegmentsPerTier();\n        final double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, oldSegmentsPerTier);\n        if (segmentsPerTier != oldSegmentsPerTier) {\n            logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", oldSegmentsPerTier, segmentsPerTier);\n            mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        }\n\n        final double oldReclaimDeletesWeight = mergePolicy.getReclaimDeletesWeight();\n        final double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, oldReclaimDeletesWeight);\n        if (reclaimDeletesWeight != oldReclaimDeletesWeight) {\n            logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", oldReclaimDeletesWeight, reclaimDeletesWeight);\n            mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        }\n    }","commit_id":"1f0ab587900ed90ce2ed484b6af454e2a665c132","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb(), ByteSizeUnit.MB).mbFrac(), 0.00);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n    }","id":104764,"modified_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT_SETTING.getKey(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT_SETTING.getKey(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb(), ByteSizeUnit.MB).mbFrac(), 0.00);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        assertEquals(((TieredMergePolicy)indexSettings.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n    }","commit_id":"1f0ab587900ed90ce2ed484b6af454e2a665c132","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void registerBuiltinIndexSettings() {\n        registerIndexDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_REQUIRE_GROUP + \"*\", Validator.EMPTY);\n        registerIndexDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + \"*\", Validator.EMPTY);\n        registerIndexDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_EXCLUDE_GROUP + \"*\", Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_READ_ONLY, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_READ, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_WRITE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_METADATA, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_PRIORITY, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(PrimaryShardAllocator.INDEX_RECOVERY_INITIAL_SHARDS, Validator.EMPTY);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED, Validator.DOUBLE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, Validator.INTEGER_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, Validator.INTEGER_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, Validator.DOUBLE_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, Validator.NON_NEGATIVE_DOUBLE);\n    }","id":104765,"modified_method":"private void registerBuiltinIndexSettings() {\n        registerIndexDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_REQUIRE_GROUP + \"*\", Validator.EMPTY);\n        registerIndexDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + \"*\", Validator.EMPTY);\n        registerIndexDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_EXCLUDE_GROUP + \"*\", Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_READ_ONLY, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_READ, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_WRITE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_BLOCKS_METADATA, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, Validator.EMPTY);\n        registerIndexDynamicSetting(IndexMetaData.SETTING_PRIORITY, Validator.NON_NEGATIVE_INTEGER);\n        registerIndexDynamicSetting(PrimaryShardAllocator.INDEX_RECOVERY_INITIAL_SHARDS, Validator.EMPTY);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, Validator.INTEGER_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, Validator.INTEGER_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, Validator.BYTES_SIZE);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, Validator.DOUBLE_GTE_2);\n        registerIndexDynamicSetting(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, Validator.NON_NEGATIVE_DOUBLE);\n    }","commit_id":"f7785dceb880f00df764405b0213644f215a4ad8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n        double forceMergeDeletesPctAllowed = indexSettings.getSettings().getAsDouble(\"index.merge.policy.expunge_deletes_allowed\", DEFAULT_EXPUNGE_DELETES_ALLOWED); // percentage\n        ByteSizeValue floorSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.floor_segment\", DEFAULT_FLOOR_SEGMENT);\n        int maxMergeAtOnce = indexSettings.getSettings().getAsInt(\"index.merge.policy.max_merge_at_once\", DEFAULT_MAX_MERGE_AT_ONCE);\n        int maxMergeAtOnceExplicit = indexSettings.getSettings().getAsInt(\"index.merge.policy.max_merge_at_once_explicit\", DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.max_merged_segment\", DEFAULT_MAX_MERGED_SEGMENT);\n        double segmentsPerTier = indexSettings.getSettings().getAsDouble(\"index.merge.policy.segments_per_tier\", DEFAULT_SEGMENTS_PER_TIER);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","id":104766,"modified_method":"MergePolicyConfig(ESLogger logger, IndexSettings indexSettings) {\n        this.logger = logger;\n        indexSettings.addSettingsUpdateConsumer(INDEX_COMPOUND_FORMAT_SETTING, this::setNoCFSRatio);\n         indexSettings.addSettingsUpdateConsumer(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING, this::expungeDeletesAllowed);\n        double forceMergeDeletesPctAllowed = indexSettings.getSettings().getAsDouble(\"index.merge.policy.expunge_deletes_allowed\", DEFAULT_EXPUNGE_DELETES_ALLOWED); // percentage\n        ByteSizeValue floorSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.floor_segment\", DEFAULT_FLOOR_SEGMENT);\n        int maxMergeAtOnce = indexSettings.getSettings().getAsInt(\"index.merge.policy.max_merge_at_once\", DEFAULT_MAX_MERGE_AT_ONCE);\n        int maxMergeAtOnceExplicit = indexSettings.getSettings().getAsInt(\"index.merge.policy.max_merge_at_once_explicit\", DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        ByteSizeValue maxMergedSegment = indexSettings.getSettings().getAsBytesSize(\"index.merge.policy.max_merged_segment\", DEFAULT_MAX_MERGED_SEGMENT);\n        double segmentsPerTier = indexSettings.getSettings().getAsDouble(\"index.merge.policy.segments_per_tier\", DEFAULT_SEGMENTS_PER_TIER);\n        double reclaimDeletesWeight = indexSettings.getSettings().getAsDouble(\"index.merge.policy.reclaim_deletes_weight\", DEFAULT_RECLAIM_DELETES_WEIGHT);\n        this.mergesEnabled = indexSettings.getSettings().getAsBoolean(INDEX_MERGE_ENABLED, true);\n        if (mergesEnabled == false) {\n            logger.warn(\"[{}] is set to false, this should only be used in tests and can cause serious problems in production environments\", INDEX_MERGE_ENABLED);\n        }\n        maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n        mergePolicy.setNoCFSRatio(indexSettings.getValue(INDEX_COMPOUND_FORMAT_SETTING));\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        logger.debug(\"using [tiered] merge mergePolicy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);\n    }","commit_id":"f7785dceb880f00df764405b0213644f215a4ad8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"void onRefreshSettings(Settings settings) {\n        final double oldExpungeDeletesPctAllowed = mergePolicy.getForceMergeDeletesPctAllowed();\n        final double expungeDeletesPctAllowed = settings.getAsDouble(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED, oldExpungeDeletesPctAllowed);\n        if (expungeDeletesPctAllowed != oldExpungeDeletesPctAllowed) {\n            logger.info(\"updating [expunge_deletes_allowed] from [{}] to [{}]\", oldExpungeDeletesPctAllowed, expungeDeletesPctAllowed);\n            mergePolicy.setForceMergeDeletesPctAllowed(expungeDeletesPctAllowed);\n        }\n\n        final double oldFloorSegmentMB = mergePolicy.getFloorSegmentMB();\n        final ByteSizeValue floorSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_FLOOR_SEGMENT, null);\n        if (floorSegment != null && floorSegment.mbFrac() != oldFloorSegmentMB) {\n            logger.info(\"updating [floor_segment] from [{}mb] to [{}]\", oldFloorSegmentMB, floorSegment);\n            mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        }\n\n        final double oldSegmentsPerTier = mergePolicy.getSegmentsPerTier();\n        final double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, oldSegmentsPerTier);\n        if (segmentsPerTier != oldSegmentsPerTier) {\n            logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", oldSegmentsPerTier, segmentsPerTier);\n            mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        }\n\n        final int oldMaxMergeAtOnce = mergePolicy.getMaxMergeAtOnce();\n        int maxMergeAtOnce = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, oldMaxMergeAtOnce);\n        if (maxMergeAtOnce != oldMaxMergeAtOnce) {\n            logger.info(\"updating [max_merge_at_once] from [{}] to [{}]\", oldMaxMergeAtOnce, maxMergeAtOnce);\n            maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n            mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        }\n\n        final int oldMaxMergeAtOnceExplicit = mergePolicy.getMaxMergeAtOnceExplicit();\n        final int maxMergeAtOnceExplicit = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, oldMaxMergeAtOnceExplicit);\n        if (maxMergeAtOnceExplicit != oldMaxMergeAtOnceExplicit) {\n            logger.info(\"updating [max_merge_at_once_explicit] from [{}] to [{}]\", oldMaxMergeAtOnceExplicit, maxMergeAtOnceExplicit);\n            mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        }\n\n        final double oldMaxMergedSegmentMB = mergePolicy.getMaxMergedSegmentMB();\n        final ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, null);\n        if (maxMergedSegment != null && maxMergedSegment.mbFrac() != oldMaxMergedSegmentMB) {\n            logger.info(\"updating [max_merged_segment] from [{}mb] to [{}]\", oldMaxMergedSegmentMB, maxMergedSegment);\n            mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        }\n\n        final double oldReclaimDeletesWeight = mergePolicy.getReclaimDeletesWeight();\n        final double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, oldReclaimDeletesWeight);\n        if (reclaimDeletesWeight != oldReclaimDeletesWeight) {\n            logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", oldReclaimDeletesWeight, reclaimDeletesWeight);\n            mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        }\n    }","id":104767,"modified_method":"void onRefreshSettings(Settings settings) {\n        final double oldFloorSegmentMB = mergePolicy.getFloorSegmentMB();\n        final ByteSizeValue floorSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_FLOOR_SEGMENT, null);\n        if (floorSegment != null && floorSegment.mbFrac() != oldFloorSegmentMB) {\n            logger.info(\"updating [floor_segment] from [{}mb] to [{}]\", oldFloorSegmentMB, floorSegment);\n            mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        }\n\n        final double oldSegmentsPerTier = mergePolicy.getSegmentsPerTier();\n        final double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, oldSegmentsPerTier);\n        if (segmentsPerTier != oldSegmentsPerTier) {\n            logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", oldSegmentsPerTier, segmentsPerTier);\n            mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        }\n\n        final int oldMaxMergeAtOnce = mergePolicy.getMaxMergeAtOnce();\n        int maxMergeAtOnce = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, oldMaxMergeAtOnce);\n        if (maxMergeAtOnce != oldMaxMergeAtOnce) {\n            logger.info(\"updating [max_merge_at_once] from [{}] to [{}]\", oldMaxMergeAtOnce, maxMergeAtOnce);\n            maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded(maxMergeAtOnce, segmentsPerTier);\n            mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        }\n\n        final int oldMaxMergeAtOnceExplicit = mergePolicy.getMaxMergeAtOnceExplicit();\n        final int maxMergeAtOnceExplicit = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, oldMaxMergeAtOnceExplicit);\n        if (maxMergeAtOnceExplicit != oldMaxMergeAtOnceExplicit) {\n            logger.info(\"updating [max_merge_at_once_explicit] from [{}] to [{}]\", oldMaxMergeAtOnceExplicit, maxMergeAtOnceExplicit);\n            mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        }\n\n        final double oldMaxMergedSegmentMB = mergePolicy.getMaxMergedSegmentMB();\n        final ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, null);\n        if (maxMergedSegment != null && maxMergedSegment.mbFrac() != oldMaxMergedSegmentMB) {\n            logger.info(\"updating [max_merged_segment] from [{}mb] to [{}]\", oldMaxMergedSegmentMB, maxMergedSegment);\n            mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        }\n\n        final double oldReclaimDeletesWeight = mergePolicy.getReclaimDeletesWeight();\n        final double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, oldReclaimDeletesWeight);\n        if (reclaimDeletesWeight != oldReclaimDeletesWeight) {\n            logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", oldReclaimDeletesWeight, reclaimDeletesWeight);\n            mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        }\n    }","commit_id":"f7785dceb880f00df764405b0213644f215a4ad8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED, MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE-1);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n    }","id":104768,"modified_method":"public void testTieredMergePolicySettingsUpdate() throws IOException {\n        MergePolicyConfig mp = new MergePolicyConfig(logger, indexSettings(EMPTY_SETTINGS));\n        assertThat(mp.getMergePolicy().getNoCFSRatio(), equalTo(0.1));\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED, 0.0d);\n\n        IndexSettings indexSettings = indexSettings(Settings.EMPTY);\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING.getKey(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d).build()));\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getFloorSegmentMB(), MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mbFrac(), 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_FLOOR_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE - 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT - 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.mbFrac(), 0.0001);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1)).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER, 0);\n        mp.onRefreshSettings(Settings.builder().put(MergePolicyConfig.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1).build());\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n\n        mp.onRefreshSettings(EMPTY_SETTINGS); // update without the settings and see if we stick to the values\n        indexSettings.updateIndexMetaData(newIndexMeta(\"index\", EMPTY_SETTINGS));\n        // this will fail because we now reset each setting which is not passed with the sttings update. are we sure this is the desired behavior?\n        assertEquals(((TieredMergePolicy) indexSettings.getMergePolicy()).getForceMergeDeletesPctAllowed(), MergePolicyConfig.DEFAULT_EXPUNGE_DELETES_ALLOWED + 1.0d, 0.0d);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getFloorSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_FLOOR_SEGMENT.mb() + 1, ByteSizeUnit.MB).mbFrac(), 0.001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnce(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE-1);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergeAtOnceExplicit(), MergePolicyConfig.DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT-1);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getMaxMergedSegmentMB(), new ByteSizeValue(MergePolicyConfig.DEFAULT_MAX_MERGED_SEGMENT.bytes() + 1).mbFrac(), 0.0001);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getReclaimDeletesWeight(), MergePolicyConfig.DEFAULT_RECLAIM_DELETES_WEIGHT + 1, 0);\n        assertEquals(((TieredMergePolicy) mp.getMergePolicy()).getSegmentsPerTier(), MergePolicyConfig.DEFAULT_SEGMENTS_PER_TIER + 1, 0);\n    }","commit_id":"f7785dceb880f00df764405b0213644f215a4ad8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        \n        helper.createRelationship(\"KNOWS\", thomasAnderson, trinity);\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties(thomasAndersonLovesTrinity, Collections.singletonMap(\"strength\", (Object) 100));\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n    }","id":104769,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        long knowsRelationshipId = helper.createRelationship( \"KNOWS\", thomasAnderson, trinity );\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties( thomasAndersonLovesTrinity, Collections.singletonMap( \"strength\", (Object) 100 ) );\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n        // index a relationship\n        helper.createRelationshipIndex( \"relationships\" );\n        helper.addRelationshipToIndex( \"relationships\", \"key\", \"value\", knowsRelationshipId );\n\n    }","commit_id":"86ecc3cfb6b8108ecb665b5414ea6f8d3c91e7c2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","id":104770,"modified_method":"@Test\n    public void shouldGetNodeIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexNodeUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","commit_id":"86ecc3cfb6b8108ecb665b5414ea6f8d3c91e7c2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<?, ?> serialized = (Map<?, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String objectType : new String[]{\"node\", \"relationship\"} )\n        {\n            List<?> list = (List<?>)serialized.get( objectType );\n            if ( list == null )\n            {\n                continue;\n            }\n            builder.append( \"<ul>\" );\n            for ( Object indexMapObject : list )\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","id":104771,"modified_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<String, ?> serialized = (Map<String, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String indexName : serialized.keySet() )\n        {\n            Map<?,?> indexMapObject = (Map<?,?>)serialized.get( indexName );\n            builder.append( \"<ul>\" );\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","commit_id":"86ecc3cfb6b8108ecb665b5414ea6f8d3c91e7c2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        \n        helper.createRelationship(\"KNOWS\", thomasAnderson, trinity);\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties(thomasAndersonLovesTrinity, Collections.singletonMap(\"strength\", (Object) 100));\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n    }","id":104772,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        long knowsRelationshipId = helper.createRelationship( \"KNOWS\", thomasAnderson, trinity );\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties( thomasAndersonLovesTrinity, Collections.singletonMap( \"strength\", (Object) 100 ) );\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n        // index a relationship\n        helper.createRelationshipIndex( \"relationships\" );\n        helper.addRelationshipToIndex( \"relationships\", \"key\", \"value\", knowsRelationshipId );\n\n    }","commit_id":"5d50ff6114e22195c0d7e184ed6c2ef94b952344","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","id":104773,"modified_method":"@Test\n    public void shouldGetNodeIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexNodeUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","commit_id":"5d50ff6114e22195c0d7e184ed6c2ef94b952344","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<?, ?> serialized = (Map<?, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String objectType : new String[]{\"node\", \"relationship\"} )\n        {\n            List<?> list = (List<?>)serialized.get( objectType );\n            if ( list == null )\n            {\n                continue;\n            }\n            builder.append( \"<ul>\" );\n            for ( Object indexMapObject : list )\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","id":104774,"modified_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<String, ?> serialized = (Map<String, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String indexName : serialized.keySet() )\n        {\n            Map<?,?> indexMapObject = (Map<?,?>)serialized.get( indexName );\n            builder.append( \"<ul>\" );\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","commit_id":"5d50ff6114e22195c0d7e184ed6c2ef94b952344","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        \n        helper.createRelationship(\"KNOWS\", thomasAnderson, trinity);\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties(thomasAndersonLovesTrinity, Collections.singletonMap(\"strength\", (Object) 100));\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n    }","id":104775,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        long knowsRelationshipId = helper.createRelationship( \"KNOWS\", thomasAnderson, trinity );\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties( thomasAndersonLovesTrinity, Collections.singletonMap( \"strength\", (Object) 100 ) );\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n        // index a relationship\n        helper.createRelationshipIndex( \"relationships\" );\n        helper.addRelationshipToIndex( \"relationships\", \"key\", \"value\", knowsRelationshipId );\n\n    }","commit_id":"12696dadcbd0ed583c054f475417b0c942b06260","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","id":104776,"modified_method":"@Test\n    public void shouldGetNodeIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexNodeUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","commit_id":"12696dadcbd0ed583c054f475417b0c942b06260","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<?, ?> serialized = (Map<?, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String objectType : new String[]{\"node\", \"relationship\"} )\n        {\n            List<?> list = (List<?>)serialized.get( objectType );\n            if ( list == null )\n            {\n                continue;\n            }\n            builder.append( \"<ul>\" );\n            for ( Object indexMapObject : list )\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","id":104777,"modified_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<String, ?> serialized = (Map<String, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String indexName : serialized.keySet() )\n        {\n            Map<?,?> indexMapObject = (Map<?,?>)serialized.get( indexName );\n            builder.append( \"<ul>\" );\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","commit_id":"12696dadcbd0ed583c054f475417b0c942b06260","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","id":104778,"modified_method":"@Test\n    public void shouldGetNodeIndexRoot() {\n        ClientResponse response = Client.create().resource(functionalTestHelper.indexNodeUri()).accept(MediaType.TEXT_HTML_TYPE).get(ClientResponse.class);\n        assertEquals(Status.OK.getStatusCode(), response.getStatus());\n        assertValidHtml(response.getEntity(String.class));\n    }","commit_id":"67194105a735bb691e8dd422cd4b2f4d64cc7e00","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        \n        helper.createRelationship(\"KNOWS\", thomasAnderson, trinity);\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties(thomasAndersonLovesTrinity, Collections.singletonMap(\"strength\", (Object) 100));\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n    }","id":104779,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n        helper = functionalTestHelper.getGraphDbHelper();\n\n        // Create the matrix example\n        thomasAnderson = createAndIndexNode(\"Thomas Anderson\");\n        trinity = createAndIndexNode(\"Trinity\");\n        long tank = createAndIndexNode(\"Tank\");\n\n        long knowsRelationshipId = helper.createRelationship( \"KNOWS\", thomasAnderson, trinity );\n        thomasAndersonLovesTrinity = helper.createRelationship(\"LOVES\", thomasAnderson, trinity);\n        helper.setRelationshipProperties( thomasAndersonLovesTrinity, Collections.singletonMap( \"strength\", (Object) 100 ) );\n        helper.createRelationship(\"KNOWS\", thomasAnderson, tank);\n        helper.createRelationship(\"KNOWS\", trinity, tank);\n\n        // index a relationship\n        helper.createRelationshipIndex( \"relationships\" );\n        helper.addRelationshipToIndex( \"relationships\", \"key\", \"value\", knowsRelationshipId );\n\n    }","commit_id":"67194105a735bb691e8dd422cd4b2f4d64cc7e00","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<?, ?> serialized = (Map<?, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String objectType : new String[]{\"node\", \"relationship\"} )\n        {\n            List<?> list = (List<?>)serialized.get( objectType );\n            if ( list == null )\n            {\n                continue;\n            }\n            builder.append( \"<ul>\" );\n            for ( Object indexMapObject : list )\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","id":104780,"modified_method":"public String render(\n            Representation... oneOrManyRepresentations )\n    {\n        Map<String, ?> serialized = (Map<String, ?>)oneOrManyRepresentations[ 0 ].serialize();\n        String javascript = \"\";\n        StringBuilder builder = HtmlHelper.start( HtmlHelper.ObjectType.INDEX_ROOT,\n                javascript );\n        int counter = 0;\n        for ( String indexName : serialized.keySet() )\n        {\n            Map<?,?> indexMapObject = (Map<?,?>)serialized.get( indexName );\n            builder.append( \"<ul>\" );\n            {\n                builder.append( \"<li>\" );\n                Map<?, ?> indexMap = (Map<?, ?>)indexMapObject;\n                String keyId = \"key_\" + counter;\n                String valueId = \"value_\" + counter;\n                builder.append( \"<form action='javascript:neo4jHtmlBrowse.search(\\\"\" ).append( indexMap.get( \"template\" ) ).append( \"\\\",\\\"\" ).append( keyId ).append( \"\\\",\\\"\" ).append( valueId ).append( \"\\\");'><fieldset><legend>\" ).append( indexMap.get( \"type\" ) ).append( \"<\/legend>\\n\" );\n                builder.append( \"<label for='\" ).append( keyId ).append( \"'>Key<\/label><input id='\" ).append( keyId ).append( \"'>\\n\" );\n                builder.append( \"<label for='\" ).append( valueId ).append( \"'>Value<\/label><input id='\" ).append( valueId ).append( \"'>\\n\" );\n                builder.append( \"<button>Search<\/button>\\n\" );\n                builder.append( \"<\/fieldset><\/form>\\n\" );\n                builder.append( \"<\/li>\\n\" );\n                counter++;\n            }\n            builder.append( \"<\/ul>\" );\n        }\n        return HtmlHelper.end( builder );\n    }","commit_id":"67194105a735bb691e8dd422cd4b2f4d64cc7e00","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n\t * Throw an exception if not all components rendered.\n\t * \n\t * @param renderedContainer\n\t *            The page itself if it was a full page render or the container\n\t *            that was rendered standalone\n\t */\n\tprivate final void checkRendering(final MarkupContainer renderedContainer)\n\t{\n\t\t// If the application wants component uses checked and\n\t\t// the response is not a redirect\n\t\tfinal IDebugSettings debugSettings = Application.get().getDebugSettings();\n\t\tif (debugSettings.getComponentUseCheck() && !getResponse().isRedirect())\n\t\t{\n\t\t\tfinal Count unrenderedComponents = new Count();\n\t\t\tfinal List unrenderedAutoComponents = new ArrayList();\n\t\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\t\trenderedContainer.visitChildren(new IVisitor()\n\t\t\t{\n\t\t\t\tpublic Object component(final Component component)\n\t\t\t\t{\n\t\t\t\t\t// If component never rendered\n\t\t\t\t\tif (renderedComponents == null || !renderedComponents.contains(component))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If auto component ...\n\t\t\t\t\t\tif (component.isAuto())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Add to list of unrendered auto components to\n\t\t\t\t\t\t\t// delete below\n\t\t\t\t\t\t\tunrenderedAutoComponents.add(component);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (component.isVisibleInHierarchy())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Increase number of unrendered components\n\t\t\t\t\t\t\tunrenderedComponents.increment();\n\n\t\t\t\t\t\t\t// Add to explanatory string to buffer\n\t\t\t\t\t\t\tbuffer.append(Integer.toString(unrenderedComponents.getCount()) + \". \"\n\t\t\t\t\t\t\t\t\t+ component + \"\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn CONTINUE_TRAVERSAL;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Remove any unrendered auto components since versioning couldn't\n\t\t\t// do it. We can't remove the component in the above visitChildren\n\t\t\t// callback because we're traversing the list at that time.\n\t\t\tfor (int i = 0; i < unrenderedAutoComponents.size(); i++)\n\t\t\t{\n\t\t\t\t((Component)unrenderedAutoComponents.get(i)).remove();\n\t\t\t}\n\n\t\t\t// Throw exception if any errors were found\n\t\t\tif (unrenderedComponents.getCount() > 0)\n\t\t\t{\n\t\t\t\t// Get rid of set\n\t\t\t\trenderedComponents = null;\n\n\t\t\t\t// Throw exception\n\t\t\t\tthrow new WicketRuntimeException(\"The component(s) below failed to render:\\n\\n\"\n\t\t\t\t\t\t+ buffer.toString());\n\t\t\t}\n\t\t}\n\n\t\t// Get rid of set\n\t\trenderedComponents = null;\n\t}","id":104781,"modified_method":"/**\n\t * Throw an exception if not all components rendered.\n\t * \n\t * @param renderedContainer\n\t *            The page itself if it was a full page render or the container\n\t *            that was rendered standalone\n\t */\n\tprivate final void checkRendering(final MarkupContainer renderedContainer)\n\t{\n\t\t// If the application wants component uses checked and\n\t\t// the response is not a redirect\n\t\tfinal IDebugSettings debugSettings = Application.get().getDebugSettings();\n\t\tif (debugSettings.getComponentUseCheck() && !getResponse().isRedirect())\n\t\t{\n\t\t\tfinal Count unrenderedComponents = new Count();\n\t\t\tfinal List unrenderedAutoComponents = new ArrayList();\n\t\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\t\trenderedContainer.visitChildren(new IVisitor()\n\t\t\t{\n\t\t\t\tpublic Object component(final Component component)\n\t\t\t\t{\n\t\t\t\t\t// If auto component ...\n\t\t\t\t\tif (component.isAuto())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Add to list of unrendered auto components to\n\t\t\t\t\t\t// delete below\n\t\t\t\t\t\tunrenderedAutoComponents.add(component);\n\t\t\t\t\t}\n\t\t\t\t\t// If component never rendered\n\t\t\t\t\telse if (renderedComponents == null || !renderedComponents.contains(component))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (component.isVisibleInHierarchy())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Increase number of unrendered components\n\t\t\t\t\t\t\tunrenderedComponents.increment();\n\n\t\t\t\t\t\t\t// Add to explanatory string to buffer\n\t\t\t\t\t\t\tbuffer.append(Integer.toString(unrenderedComponents.getCount()) + \". \"\n\t\t\t\t\t\t\t\t\t+ component + \"\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn CONTINUE_TRAVERSAL;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Remove any unrendered auto components since versioning couldn't\n\t\t\t// do it. We can't remove the component in the above visitChildren\n\t\t\t// callback because we're traversing the list at that time.\n\t\t\tfor (int i = 0; i < unrenderedAutoComponents.size(); i++)\n\t\t\t{\n\t\t\t\t((Component)unrenderedAutoComponents.get(i)).remove();\n\t\t\t}\n\n\t\t\t// Throw exception if any errors were found\n\t\t\tif (unrenderedComponents.getCount() > 0)\n\t\t\t{\n\t\t\t\t// Get rid of set\n\t\t\t\trenderedComponents = null;\n\n\t\t\t\t// Throw exception\n\t\t\t\tthrow new WicketRuntimeException(\"The component(s) below failed to render:\\n\\n\"\n\t\t\t\t\t\t+ buffer.toString());\n\t\t\t}\n\t\t}\n\n\t\t// Get rid of set\n\t\trenderedComponents = null;\n\t}","commit_id":"1c544237313023d622f7872d7dbdd3bb1a9f37da","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test Tree put on a plain page with a html head section, but without a\n\t * wicket:head tag. Tests first render, and render after a node click.\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageNoWicketHeadTag_1() throws Exception\n\t{\n\t\texecuteTest(TreePageNoWicketHeadTag.class, \"TreePageNoWicketHeadTagExpectedResult_1.html\");\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\n\t\t\t\t'?' + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME\n\t\t\t\t\t\t+ \"=:0:tree:tree:3:node:junctionLink::ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tString document = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(),\n\t\t\t\t\"TreePageNoWicketHeadTagExpectedResult_1-1.html\"));\n\t}","id":104782,"modified_method":"/**\n\t * Test Tree put on a plain page with a html head section, but without a\n\t * wicket:head tag. Tests first render, and render after a node click.\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageNoWicketHeadTag_1() throws Exception\n\t{\n\t\texecuteTest(TreePageNoWicketHeadTag.class, \"TreePageNoWicketHeadTagExpectedResult_1.html\");\n\n\t\texecutedListener(TreePageNoWicketHeadTag.class, \n\t\t\t\tapplication.getLastRenderedPage().get(\"tree:tree:3:node:junctionLink\"), \n\t\t\t\tILinkListener.INTERFACE, \"TreePageNoWicketHeadTagExpectedResult_1-1.html\");\n\t}","commit_id":"1c544237313023d622f7872d7dbdd3bb1a9f37da","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test Tree put on a page with a border. Tests first render, and render\n\t * after a node click.\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageWithBorder_1() throws Exception\n\t{\n\t\texecuteTest(TreePageWithBorder.class, \"TreePageWithBorderExpectedResult_1.html\");\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\n\t\t\t\t'?' + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME\n\t\t\t\t\t\t+ \"=:0:tree:tree:3:node:junctionLink::ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tString document = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(),\n\t\t\t\t\"TreePageWithBorderExpectedResult_1-1.html\"));\n\t}","id":104783,"modified_method":"/**\n\t * Test Tree put on a page with a border. Tests first render, and render\n\t * after a node click.\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageWithBorder_1() throws Exception\n\t{\n\t\texecuteTest(TreePageWithBorder.class, \"TreePageWithBorderExpectedResult_1.html\");\n\n\t\texecutedListener(TreePageWithBorder.class, \n\t\t\t\tapplication.getLastRenderedPage().get(\"tree:tree:3:node:junctionLink\"), \n\t\t\t\tILinkListener.INTERFACE, \"TreePageWithBorderExpectedResult_1-1.html\");\n\t}","commit_id":"1c544237313023d622f7872d7dbdd3bb1a9f37da","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test Tree put on a plain page. Tests first render, and render after a\n\t * node click.\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePage_1() throws Exception\n\t{\n\t\texecuteTest(TreePage.class, \"TreePageExpectedResult_1.html\");\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\n\t\t\t\t'?' + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME\n\t\t\t\t\t\t+ \"=:0:tree:tree:3:node:junctionLink::ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tString document = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(),\n\t\t\t\t\"TreePageExpectedResult_1-1.html\"));\n\t}","id":104784,"modified_method":"/**\n\t * Test Tree put on a plain page. Tests first render, and render after a\n\t * node click.\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePage_1() throws Exception\n\t{\n\t\texecuteTest(TreePage.class, \"TreePageExpectedResult_1.html\");\n\n\t\texecutedListener(TreePage.class, \n\t\t\t\tapplication.getLastRenderedPage().get(\"tree:tree:3:node:junctionLink\"), \n\t\t\t\tILinkListener.INTERFACE, \"TreePageExpectedResult_1-1.html\");\n\t}","commit_id":"1c544237313023d622f7872d7dbdd3bb1a9f37da","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected StagedModel addStagedModel(\n\t\t\tGroup group,\n\t\t\tMap<String, List<StagedModel>> dependentStagedModelsMap)\n\t\tthrows Exception {\n\n\t\tClass<?> ddmStructureClass =\n\t\t\tDDMStructureManagerUtil.getDDMStructureModelClass();\n\n\t\tList<StagedModel> dependentStagedModels = dependentStagedModelsMap.get(\n\t\t\tddmStructureClass.getSimpleName());\n\n\t\tDDMStructure ddmStructure = (DDMStructure)dependentStagedModels.get(0);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroup.getGroupId(), TestPropsValues.getUserId());\n\n\t\treturn DLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(),\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\tnew long[] {ddmStructure.getStructureId()}, serviceContext);\n\t}","id":104785,"modified_method":"@Override\n\tprotected StagedModel addStagedModel(\n\t\t\tGroup group,\n\t\t\tMap<String, List<StagedModel>> dependentStagedModelsMap)\n\t\tthrows Exception {\n\n\t\tClass<?> ddmStructureClass =\n\t\t\tDDMStructureManagerUtil.getDDMStructureModelClass();\n\n\t\tList<StagedModel> dependentStagedModels = dependentStagedModelsMap.get(\n\t\t\tddmStructureClass.getSimpleName());\n\n\t\tDDMStructure ddmStructure = (DDMStructure)dependentStagedModels.get(0);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroup.getGroupId(), TestPropsValues.getUserId());\n\n\t\tDLFileEntryType fileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\tTestPropsValues.getUserId(), group.getGroupId(),\n\t\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\t\tnew long[] {ddmStructure.getStructureId()}, serviceContext);\n\n\t\tDDMStructureManagerUtil.updateStructureKey(\n\t\t\tddmStructure.getStructureId(),\n\t\t\tDLUtil.getDDMStructureKey(fileEntryType));\n\n\t\treturn fileEntryType;\n\t}","commit_id":"1b4bd5e4d5ee8009e38c87aa0af302004f9d8b17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DLFileEntryType addDLFileEntryType(\n\t\t\tlong groupId, long ddmStructureId)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroupId, TestPropsValues.getUserId());\n\n\t\treturn DLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\tTestPropsValues.getUserId(), groupId, RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), new long[] {ddmStructureId},\n\t\t\tserviceContext);\n\t}","id":104786,"modified_method":"protected DLFileEntryType addDLFileEntryType(\n\t\t\tlong groupId, long ddmStructureId)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroupId, TestPropsValues.getUserId());\n\n\t\tDLFileEntryType fileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\tTestPropsValues.getUserId(), groupId,\n\t\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\t\tnew long[] {ddmStructureId}, serviceContext);\n\n\t\tDDMStructureManagerUtil.updateStructureKey(\n\t\t\tddmStructureId, DLUtil.getDDMStructureKey(fileEntryType));\n\n\t\treturn fileEntryType;\n\t}","commit_id":"1b4bd5e4d5ee8009e38c87aa0af302004f9d8b17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DLFileEntryType addDLFileEntryType(\n\t\t\tlong groupId, long ddmStructureId)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroupId, TestPropsValues.getUserId());\n\n\t\treturn DLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\tTestPropsValues.getUserId(), groupId, RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), new long[] {ddmStructureId},\n\t\t\tserviceContext);\n\t}","id":104787,"modified_method":"protected DLFileEntryType addDLFileEntryType(\n\t\t\tlong groupId, long ddmStructureId)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\tgroupId, TestPropsValues.getUserId());\n\n\t\tDLFileEntryType fileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\tTestPropsValues.getUserId(), groupId,\n\t\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\t\tnew long[] {ddmStructureId}, serviceContext);\n\n\t\tDDMStructureManagerUtil.updateStructureKey(\n\t\t\tddmStructureId, DLUtil.getDDMStructureKey(fileEntryType));\n\n\t\treturn fileEntryType;\n\t}","commit_id":"1b4bd5e4d5ee8009e38c87aa0af302004f9d8b17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void deleteStagedModel(\n\t\t\tStagedModel stagedModel,\n\t\t\tMap<String, List<StagedModel>> dependentStagedModelsMap,\n\t\t\tGroup group)\n\t\tthrows Exception {\n\n\t\tLayoutSetPrototypeLocalServiceUtil.deleteLayoutSetPrototype(\n\t\t\t(LayoutSetPrototype)stagedModel);\n\n\t\tList<StagedModel> dependentStagedModels = dependentStagedModelsMap.get(\n\t\t\tLayoutPrototype.class.getSimpleName());\n\n\t\tLayoutPrototype layoutPrototype =\n\t\t\t(LayoutPrototype)dependentStagedModels.get(0);\n\n\t\tLayoutPrototypeLocalServiceUtil.deleteLayoutPrototype(layoutPrototype);\n\t}","id":104788,"modified_method":"@Override\n\tprotected void deleteStagedModel(\n\t\t\tStagedModel stagedModel,\n\t\t\tMap<String, List<StagedModel>> dependentStagedModelsMap,\n\t\t\tGroup group)\n\t\tthrows Exception {\n\n\t\tLayoutSetPrototypeLocalServiceUtil.deleteLayoutSetPrototype(\n\t\t\t(LayoutSetPrototype)stagedModel);\n\t}","commit_id":"1b4bd5e4d5ee8009e38c87aa0af302004f9d8b17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static PasswordPolicy addPasswordPolicy(\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn PasswordPolicyLocalServiceUtil.addPasswordPolicy(\n\t\t\tserviceContext.getUserId(), RandomTestUtil.randomBoolean(),\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomBoolean(), RandomTestUtil.randomBoolean(),\n\t\t\tRandomTestUtil.randomLong(), RandomTestUtil.randomBoolean(),\n\t\t\tRandomTestUtil.randomBoolean(), RandomTestUtil.nextInt(),\n\t\t\tRandomTestUtil.nextInt(), RandomTestUtil.nextInt(),\n\t\t\tRandomTestUtil.nextInt(), RandomTestUtil.nextInt(),\n\t\t\tRandomTestUtil.nextInt(), \"(?=.{4})(?:[a-zA-Z0-9]*)\",\n\t\t\tRandomTestUtil.randomBoolean(), RandomTestUtil.nextInt(),\n\t\t\tRandomTestUtil.randomBoolean(), RandomTestUtil.randomLong(),\n\t\t\tRandomTestUtil.randomLong(), RandomTestUtil.nextInt(),\n\t\t\tRandomTestUtil.randomBoolean(), RandomTestUtil.nextInt(),\n\t\t\tRandomTestUtil.randomLong(), RandomTestUtil.randomLong(),\n\t\t\tRandomTestUtil.randomLong(), serviceContext);\n\t}","id":104789,"modified_method":"public static PasswordPolicy addPasswordPolicy(\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn addPasswordPolicy(serviceContext, false);\n\t}","commit_id":"1b4bd5e4d5ee8009e38c87aa0af302004f9d8b17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportAssetObjects(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tLayout layout = _layoutLocalService.getLayout(\n\t\t\tportletDataContext.getPlid());\n\n\t\tlong[] groupIds = AssetPublisherUtil.getGroupIds(\n\t\t\tportletPreferences, portletDataContext.getScopeGroupId(), layout);\n\n\t\tList<AssetEntry> assetEntries = AssetPublisherUtil.getAssetEntries(\n\t\t\tnull, portletPreferences,\n\t\t\tPermissionThreadLocal.getPermissionChecker(), groupIds, false,\n\t\t\tfalse);\n\n\t\tfor (AssetEntry assetEntry : assetEntries) {\n\t\t\tAssetRenderer<?> assetRenderer = assetEntry.getAssetRenderer();\n\n\t\t\tif ((assetRenderer == null) ||\n\t\t\t\t!(assetRenderer.getAssetObject() instanceof StagedModel)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletDataContext.getPortletId(),\n\t\t\t\t(StagedModel)assetRenderer.getAssetObject());\n\t\t}\n\t}","id":104790,"modified_method":"protected void exportAssetObjects(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tList<AssetEntry> assetEntries = null;\n\n\t\tLayout layout = _layoutLocalService.getLayout(\n\t\t\tportletDataContext.getPlid());\n\n\t\tlong[] groupIds = AssetPublisherUtil.getGroupIds(\n\t\t\tportletPreferences, portletDataContext.getScopeGroupId(), layout);\n\n\t\tString selectionStyle = portletPreferences.getValue(\n\t\t\t\"selectionStyle\", \"dynamic\");\n\n\t\tif (selectionStyle.equals(\"dynamic\")) {\n\t\t\tif (!AssetPublisherWebConfigurationValues.DYNAMIC_EXPORT_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAssetEntryQuery assetEntryQuery = getAssetEntryQuery(\n\t\t\t\tlayout, portletDataContext.getCompanyGroupId(), groupIds,\n\t\t\t\tportletPreferences);\n\n\t\t\tlong assetVocabularyId = GetterUtil.getLong(\n\t\t\t\tportletPreferences.getValue(\"assetVocabularyId\", null));\n\n\t\t\tif (assetVocabularyId > 0) {\n\t\t\t\tmergeAnyCategoryIds(assetEntryQuery, assetVocabularyId);\n\n\t\t\t\tif (ArrayUtil.isEmpty(assetEntryQuery.getAnyCategoryIds())) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBaseModelSearchResult<AssetEntry> baseModelSearchResult =\n\t\t\t\tAssetPublisherUtil.getAssetEntries(\n\t\t\t\t\tassetEntryQuery, layout, portletPreferences,\n\t\t\t\t\tAssetPublisherPortletKeys.ASSET_PUBLISHER,\n\t\t\t\t\tLocaleUtil.getDefault(), TimeZoneUtil.getDefault(),\n\t\t\t\t\tportletDataContext.getCompanyId(),\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tUserConstants.USER_ID_DEFAULT,\n\t\t\t\t\tnew HashMap<String, Serializable>(),\n\t\t\t\t\tassetEntryQuery.getStart(), assetEntryQuery.getEnd());\n\n\t\t\tassetEntries = baseModelSearchResult.getBaseModels();\n\t\t}\n\t\telse {\n\t\t\tif (!AssetPublisherWebConfigurationValues.DYNAMIC_EXPORT_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tassetEntries = AssetPublisherUtil.getAssetEntries(\n\t\t\t\tnull, portletPreferences,\n\t\t\t\tPermissionThreadLocal.getPermissionChecker(), groupIds, false,\n\t\t\t\tfalse);\n\t\t}\n\n\t\tfor (AssetEntry assetEntry : assetEntries) {\n\t\t\tAssetRenderer<?> assetRenderer = assetEntry.getAssetRenderer();\n\n\t\t\tif ((assetRenderer == null) ||\n\t\t\t\t!(assetRenderer.getAssetObject() instanceof StagedModel)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletDataContext.getPortletId(),\n\t\t\t\t(StagedModel)assetRenderer.getAssetObject());\n\t\t}\n\t}","commit_id":"981bb9d5f9695bda8944d45a155fba12c42c35aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportAssetObjects(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tLayout layout = _layoutLocalService.getLayout(\n\t\t\tportletDataContext.getPlid());\n\n\t\tlong[] groupIds = AssetPublisherUtil.getGroupIds(\n\t\t\tportletPreferences, portletDataContext.getScopeGroupId(), layout);\n\n\t\tList<AssetEntry> assetEntries = AssetPublisherUtil.getAssetEntries(\n\t\t\tnull, portletPreferences,\n\t\t\tPermissionThreadLocal.getPermissionChecker(), groupIds, false,\n\t\t\tfalse);\n\n\t\tfor (AssetEntry assetEntry : assetEntries) {\n\t\t\tAssetRenderer<?> assetRenderer = assetEntry.getAssetRenderer();\n\n\t\t\tif ((assetRenderer == null) ||\n\t\t\t\t!(assetRenderer.getAssetObject() instanceof StagedModel)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletDataContext.getPortletId(),\n\t\t\t\t(StagedModel)assetRenderer.getAssetObject());\n\t\t}\n\t}","id":104791,"modified_method":"protected void exportAssetObjects(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tList<AssetEntry> assetEntries = null;\n\n\t\tLayout layout = _layoutLocalService.getLayout(\n\t\t\tportletDataContext.getPlid());\n\n\t\tlong[] groupIds = AssetPublisherUtil.getGroupIds(\n\t\t\tportletPreferences, portletDataContext.getScopeGroupId(), layout);\n\n\t\tString selectionStyle = portletPreferences.getValue(\n\t\t\t\"selectionStyle\", \"dynamic\");\n\n\t\tif (selectionStyle.equals(\"dynamic\")) {\n\t\t\tif (!AssetPublisherWebConfigurationValues.DYNAMIC_EXPORT_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAssetEntryQuery assetEntryQuery = getAssetEntryQuery(\n\t\t\t\tlayout, portletDataContext.getCompanyGroupId(), groupIds,\n\t\t\t\tportletPreferences);\n\n\t\t\tlong assetVocabularyId = GetterUtil.getLong(\n\t\t\t\tportletPreferences.getValue(\"assetVocabularyId\", null));\n\n\t\t\tif (assetVocabularyId > 0) {\n\t\t\t\tmergeAnyCategoryIds(assetEntryQuery, assetVocabularyId);\n\n\t\t\t\tif (ArrayUtil.isEmpty(assetEntryQuery.getAnyCategoryIds())) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBaseModelSearchResult<AssetEntry> baseModelSearchResult =\n\t\t\t\tAssetPublisherUtil.getAssetEntries(\n\t\t\t\t\tassetEntryQuery, layout, portletPreferences,\n\t\t\t\t\tAssetPublisherPortletKeys.ASSET_PUBLISHER,\n\t\t\t\t\tLocaleUtil.getDefault(), TimeZoneUtil.getDefault(),\n\t\t\t\t\tportletDataContext.getCompanyId(),\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tUserConstants.USER_ID_DEFAULT,\n\t\t\t\t\tnew HashMap<String, Serializable>(),\n\t\t\t\t\tassetEntryQuery.getStart(), assetEntryQuery.getEnd());\n\n\t\t\tassetEntries = baseModelSearchResult.getBaseModels();\n\t\t}\n\t\telse {\n\t\t\tif (!AssetPublisherWebConfigurationValues.DYNAMIC_EXPORT_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tassetEntries = AssetPublisherUtil.getAssetEntries(\n\t\t\t\tnull, portletPreferences,\n\t\t\t\tPermissionThreadLocal.getPermissionChecker(), groupIds, false,\n\t\t\t\tfalse);\n\t\t}\n\n\t\tfor (AssetEntry assetEntry : assetEntries) {\n\t\t\tAssetRenderer<?> assetRenderer = assetEntry.getAssetRenderer();\n\n\t\t\tif ((assetRenderer == null) ||\n\t\t\t\t!(assetRenderer.getAssetObject() instanceof StagedModel)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletDataContext.getPortletId(),\n\t\t\t\t(StagedModel)assetRenderer.getAssetObject());\n\t\t}\n\t}","commit_id":"13374b2026ae7521141d988bc7bd3320a09956a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] getRSS(\n\t\t\tResourceRequest portletRequest, ResourceResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tPortletPreferences portletPreferences = portletRequest.getPreferences();\n\n\t\tString selectionStyle = portletPreferences.getValue(\n\t\t\t\"selectionStyle\", \"dynamic\");\n\n\t\tif (!selectionStyle.equals(\"dynamic\")) {\n\t\t\treturn new byte[0];\n\t\t}\n\n\t\tString assetLinkBehavior = portletPreferences.getValue(\n\t\t\t\"assetLinkBehavior\", \"showFullContent\");\n\t\tString rssDisplayStyle = portletPreferences.getValue(\n\t\t\t\"rssDisplayStyle\", RSSUtil.DISPLAY_STYLE_ABSTRACT);\n\t\tString rssFeedType = portletPreferences.getValue(\n\t\t\t\"rssFeedType\", RSSUtil.FEED_TYPE_DEFAULT);\n\t\tString rssName = portletPreferences.getValue(\"rssName\", null);\n\n\t\tString format = RSSUtil.getFeedTypeFormat(rssFeedType);\n\t\tdouble version = RSSUtil.getFeedTypeVersion(rssFeedType);\n\n\t\tString rss = exportToRSS(\n\t\t\tportletRequest, portletResponse, rssName, null, format, version,\n\t\t\trssDisplayStyle, assetLinkBehavior,\n\t\t\tgetAssetEntries(portletRequest, portletPreferences));\n\n\t\treturn rss.getBytes(StringPool.UTF8);\n\t}","id":104792,"modified_method":"public static byte[] getRSS(\n\t\t\tResourceRequest portletRequest, ResourceResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tPortletPreferences portletPreferences = portletRequest.getPreferences();\n\n\t\tString selectionStyle = portletPreferences.getValue(\n\t\t\t\"selectionStyle\", \"dynamic\");\n\n\t\tif (!selectionStyle.equals(\"dynamic\")) {\n\t\t\treturn new byte[0];\n\t\t}\n\n\t\tString assetLinkBehavior = portletPreferences.getValue(\n\t\t\t\"assetLinkBehavior\", \"showFullContent\");\n\t\tString rssDisplayStyle = portletPreferences.getValue(\n\t\t\t\"rssDisplayStyle\", RSSUtil.DISPLAY_STYLE_ABSTRACT);\n\t\tString rssFeedType = portletPreferences.getValue(\n\t\t\t\"rssFeedType\", RSSUtil.FEED_TYPE_DEFAULT);\n\t\tString rssName = portletPreferences.getValue(\"rssName\", null);\n\n\t\tString format = RSSUtil.getFeedTypeFormat(rssFeedType);\n\t\tdouble version = RSSUtil.getFeedTypeVersion(rssFeedType);\n\n\t\tList<AssetEntry> assetEntries = new ArrayList<>();\n\n\t\tif (selectionStyle.equals(\"dynamic\")) {\n\t\t\tint rssDelta = GetterUtil.getInteger(\n\t\t\t\tportletPreferences.getValue(\"rssDelta\", \"20\"));\n\n\t\t\tSearchContainer<Object> searchContainer =\n\t\t\t\tnew SearchContainer<Object>(\n\t\t\t\t\tportletRequest, null, null,\n\t\t\t\t\tSearchContainer.DEFAULT_CUR_PARAM,\n\t\t\t\t0, rssDelta, portletResponse.createRenderURL(), null, null);\n\n\t\t\tHttpServletRequest httpServletRequest =\n\t\t\t\tPortalUtil.getHttpServletRequest(portletRequest);\n\n\t\t\tAssetPublisherDisplayContext displayContext =\n\t\t\t\tnew AssetPublisherDisplayContext(\n\t\t\t\t\thttpServletRequest, portletPreferences);\n\n\t\t\tList<AssetEntryResult> assetEntryResults =\n\t\t\t\tdisplayContext.getAssetEntryResults(searchContainer);\n\n\t\t\tfor (AssetEntryResult assetEntryResult : assetEntryResults) {\n\t\t\t\tassetEntries.addAll(assetEntryResult.getAssetEntries());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassetEntries = getAssetEntries(portletRequest, portletPreferences);\n\t\t}\n\n\t\tString rss = exportToRSS(\n\t\t\tportletRequest, portletResponse, rssName, null, format, version,\n\t\t\trssDisplayStyle, assetLinkBehavior, assetEntries);\n\n\t\treturn rss.getBytes(StringPool.UTF8);\n\t}","commit_id":"82b3021ee2ce01eceeba33bb72e2f984c914a4d7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** Creates an copy of the current field with given field name and boost */\n    private static void parseCopy(String field, ParseContext context) throws IOException {\n        FieldMapper fieldMapper = context.docMapper().mappers().getMapper(field);\n        if (fieldMapper != null) {\n            fieldMapper.parse(context);\n        } else {\n            // The path of the dest field might be completely different from the current one so we need to reset it\n            context = context.overridePath(new ContentPath(0));\n\n            // TODO: why Strings.splitStringToArray instead of String.split?\n            final String[] paths = Strings.splitStringToArray(field, '.');\n            final String fieldName = paths[paths.length-1];\n            ObjectMapper mapper = context.root();\n            ObjectMapper[] mappers = new ObjectMapper[paths.length-1];\n            if (paths.length > 1) {\n                ObjectMapper parent = context.root();\n                for (int i = 0; i < paths.length-1; i++) {\n                    mapper = context.docMapper().objectMappers().get(context.path().pathAsText(paths[i]));\n                    if (mapper == null) {\n                        // One mapping is missing, check if we are allowed to create a dynamic one.\n                        ObjectMapper.Dynamic dynamic = parent.dynamic();\n                        if (dynamic == null) {\n                            dynamic = dynamicOrDefault(context.root().dynamic());\n                        }\n\n                        switch (dynamic) {\n                            case STRICT:\n                                throw new StrictDynamicMappingException(parent.fullPath(), paths[i]);\n                            case TRUE:\n                                Mapper.Builder builder = context.root().findTemplateBuilder(context, paths[i], \"object\");\n                                if (builder == null) {\n                                    // if this is a non root object, then explicitly set the dynamic behavior if set\n                                    if (!(parent instanceof RootObjectMapper) && parent.dynamic() != ObjectMapper.Defaults.DYNAMIC) {\n                                        ((ObjectMapper.Builder) builder).dynamic(parent.dynamic());\n                                    }\n                                    builder = new ObjectMapper.Builder(paths[i]).enabled(true);\n                                }\n                                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n                                mapper = (ObjectMapper) builder.build(builderContext);\n                                if (mapper.nested() != ObjectMapper.Nested.NO) {\n                                    throw new MapperParsingException(\"It is forbidden to create dynamic nested objects ([\" + context.path().pathAsText(paths[i]) + \"]) through `copy_to`\");\n                                }\n                                context.addDynamicMapper(mapper);\n                                break;\n                            case FALSE:\n                              // Maybe we should log something to tell the user that the copy_to is ignored in this case.\n                              break;\n                            default:\n                                throw new AssertionError(\"Unexpected dynamic type \" + dynamic);\n\n                        }\n                    }\n                    context.path().add(paths[i]);\n                    mappers[i] = mapper;\n                    parent = mapper;\n                }\n            }\n            parseDynamicValue(context, mapper, fieldName, context.parser().currentToken());\n        }\n    }","id":104793,"modified_method":"/** Creates an copy of the current field with given field name and boost */\n    private static void parseCopy(String field, ParseContext context) throws IOException {\n        FieldMapper fieldMapper = context.docMapper().mappers().getMapper(field);\n        if (fieldMapper != null) {\n            fieldMapper.parse(context);\n        } else {\n            // The path of the dest field might be completely different from the current one so we need to reset it\n            context = context.overridePath(new ContentPath(0));\n\n            // TODO: why Strings.splitStringToArray instead of String.split?\n            final String[] paths = Strings.splitStringToArray(field, '.');\n            final String fieldName = paths[paths.length-1];\n            ObjectMapper mapper = context.root();\n            ObjectMapper[] mappers = new ObjectMapper[paths.length-1];\n            if (paths.length > 1) {\n                ObjectMapper parent = context.root();\n                for (int i = 0; i < paths.length-1; i++) {\n                    mapper = context.docMapper().objectMappers().get(context.path().pathAsText(paths[i]));\n                    if (mapper == null) {\n                        // One mapping is missing, check if we are allowed to create a dynamic one.\n                        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parent, context.root().dynamic());\n\n                        switch (dynamic) {\n                            case STRICT:\n                                throw new StrictDynamicMappingException(parent.fullPath(), paths[i]);\n                            case TRUE:\n                                Mapper.Builder builder = context.root().findTemplateBuilder(context, paths[i], \"object\");\n                                if (builder == null) {\n                                    builder = new ObjectMapper.Builder(paths[i]).enabled(true);\n                                }\n                                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n                                mapper = (ObjectMapper) builder.build(builderContext);\n                                if (mapper.nested() != ObjectMapper.Nested.NO) {\n                                    throw new MapperParsingException(\"It is forbidden to create dynamic nested objects ([\" + context.path().pathAsText(paths[i]) + \"]) through `copy_to`\");\n                                }\n                                context.addDynamicMapper(mapper);\n                                break;\n                            case FALSE:\n                              // Maybe we should log something to tell the user that the copy_to is ignored in this case.\n                              break;\n\n                        }\n                    }\n                    context.path().add(paths[i]);\n                    mappers[i] = mapper;\n                    parent = mapper;\n                }\n            }\n            parseDynamicValue(context, mapper, fieldName, context.parser().currentToken());\n        }\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void parseObjectOrField(ParseContext context, Mapper mapper) throws IOException {\n        if (mapper instanceof ObjectMapper) {\n            parseObjectOrNested(context, (ObjectMapper) mapper, false);\n        } else {\n            FieldMapper fieldMapper = (FieldMapper)mapper;\n            Mapper update = fieldMapper.parse(context);\n            if (update != null) {\n                context.addDynamicMapper(update);\n            }\n            if (fieldMapper.copyTo() != null) {\n                parseCopyFields(context, fieldMapper, fieldMapper.copyTo().copyToFields());\n            }\n        }\n    }","id":104794,"modified_method":"private static void parseObjectOrField(ParseContext context, Mapper mapper) throws IOException {\n        if (mapper instanceof ObjectMapper) {\n            parseObjectOrNested(context, (ObjectMapper) mapper, false);\n        } else {\n            FieldMapper fieldMapper = (FieldMapper)mapper;\n            Mapper update = fieldMapper.parse(context);\n            if (update != null) {\n                context.addDynamicMapper(update);\n            }\n            if (fieldMapper.copyTo() != null) {\n                parseCopyFields(context, fieldMapper.copyTo().copyToFields());\n            }\n        }\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static ObjectMapper.Dynamic dynamicOrDefault(ObjectMapper.Dynamic dynamic) {\n        return dynamic == null ? ObjectMapper.Dynamic.TRUE : dynamic;\n    }","id":104795,"modified_method":"private static ObjectMapper.Dynamic dynamicOrDefault(ObjectMapper parentMapper, ObjectMapper.Dynamic dynamicDefault) {\n        ObjectMapper.Dynamic dynamic = parentMapper.dynamic();\n        if (dynamic == null) {\n            return dynamicDefault == null ? ObjectMapper.Dynamic.TRUE : dynamicDefault;\n        }\n        return dynamic;\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Creates instances of the fields that the current field should be copied to */\n    private static void parseCopyFields(ParseContext context, FieldMapper fieldMapper, List<String> copyToFields) throws IOException {\n        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {\n            context = context.createCopyToContext();\n            for (String field : copyToFields) {\n                // In case of a hierarchy of nested documents, we need to figure out\n                // which document the field should go to\n                ParseContext.Document targetDoc = null;\n                for (ParseContext.Document doc = context.doc(); doc != null; doc = doc.getParent()) {\n                    if (field.startsWith(doc.getPrefix())) {\n                        targetDoc = doc;\n                        break;\n                    }\n                }\n                assert targetDoc != null;\n                final ParseContext copyToContext;\n                if (targetDoc == context.doc()) {\n                    copyToContext = context;\n                } else {\n                    copyToContext = context.switchDoc(targetDoc);\n                }\n                parseCopy(field, copyToContext);\n            }\n        }\n    }","id":104796,"modified_method":"/** Creates instances of the fields that the current field should be copied to */\n    private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {\n        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {\n            context = context.createCopyToContext();\n            for (String field : copyToFields) {\n                // In case of a hierarchy of nested documents, we need to figure out\n                // which document the field should go to\n                ParseContext.Document targetDoc = null;\n                for (ParseContext.Document doc = context.doc(); doc != null; doc = doc.getParent()) {\n                    if (field.startsWith(doc.getPrefix())) {\n                        targetDoc = doc;\n                        break;\n                    }\n                }\n                assert targetDoc != null;\n                final ParseContext copyToContext;\n                if (targetDoc == context.doc()) {\n                    copyToContext = context;\n                } else {\n                    copyToContext = context.switchDoc(targetDoc);\n                }\n                parseCopy(field, copyToContext);\n            }\n        }\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void parseDynamicValue(final ParseContext context, ObjectMapper parentMapper, String currentFieldName, XContentParser.Token token) throws IOException {\n        ObjectMapper.Dynamic dynamic = parentMapper.dynamic();\n        if (dynamic == null) {\n            dynamic = dynamicOrDefault(context.root().dynamic());\n        }\n        if (dynamic == ObjectMapper.Dynamic.STRICT) {\n            throw new StrictDynamicMappingException(parentMapper.fullPath(), currentFieldName);\n        }\n        if (dynamic == ObjectMapper.Dynamic.FALSE) {\n            return;\n        }\n        final String path = context.path().pathAsText(currentFieldName);\n        final Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n        final MappedFieldType existingFieldType = context.mapperService().fullName(path);\n        Mapper.Builder builder = null;\n        if (existingFieldType != null) {\n            // create a builder of the same type\n            builder = createBuilderFromFieldType(context, existingFieldType, currentFieldName);\n        }\n        if (builder == null) {\n            builder = createBuilderFromDynamicValue(context, token, currentFieldName);\n        }\n        Mapper mapper = builder.build(builderContext);\n        if (existingFieldType != null) {\n            // try to not introduce a conflict\n            mapper = mapper.updateFieldType(Collections.singletonMap(path, existingFieldType));\n        }\n        context.addDynamicMapper(mapper);\n\n        parseObjectOrField(context, mapper);\n    }","id":104797,"modified_method":"private static void parseDynamicValue(final ParseContext context, ObjectMapper parentMapper, String currentFieldName, XContentParser.Token token) throws IOException {\n        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());\n        if (dynamic == ObjectMapper.Dynamic.STRICT) {\n            throw new StrictDynamicMappingException(parentMapper.fullPath(), currentFieldName);\n        }\n        if (dynamic == ObjectMapper.Dynamic.FALSE) {\n            return;\n        }\n        final String path = context.path().pathAsText(currentFieldName);\n        final Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n        final MappedFieldType existingFieldType = context.mapperService().fullName(path);\n        final Mapper.Builder builder;\n        if (existingFieldType != null) {\n            // create a builder of the same type\n            builder = createBuilderFromFieldType(context, existingFieldType, currentFieldName);\n        } else {\n            builder = createBuilderFromDynamicValue(context, token, currentFieldName);\n        }\n        Mapper mapper = builder.build(builderContext);\n        if (existingFieldType != null) {\n            // try to not introduce a conflict\n            mapper = mapper.updateFieldType(Collections.singletonMap(path, existingFieldType));\n        }\n        context.addDynamicMapper(mapper);\n\n        parseObjectOrField(context, mapper);\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void parseValue(final ParseContext context, ObjectMapper parentMapper, String currentFieldName, XContentParser.Token token) throws IOException {\n        if (currentFieldName == null) {\n            throw new MapperParsingException(\"object mapping [\" + parentMapper.name() + \"] trying to serialize a value with no field associated with it, current value [\" + context.parser().textOrNull() + \"]\");\n        }\n        Mapper mapper = parentMapper.getMapper(currentFieldName);\n        if (mapper != null) {\n            parseObjectOrField(context, mapper);\n        } else {\n            parseDynamicValue(context, parentMapper, currentFieldName, token);\n        }\n    }","id":104798,"modified_method":"private static void parseValue(final ParseContext context, ObjectMapper parentMapper, String currentFieldName, XContentParser.Token token) throws IOException {\n        if (currentFieldName == null) {\n            throw new MapperParsingException(\"object mapping [\" + parentMapper.name() + \"] trying to serialize a value with no field associated with it, current value [\" + context.parser().textOrNull() + \"]\");\n        }\n        Mapper mapper = getMapper(parentMapper, currentFieldName);\n        if (mapper != null) {\n            parseObjectOrField(context, mapper);\n        } else {\n            parseDynamicValue(context, parentMapper, currentFieldName, token);\n        }\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void parseArray(ParseContext context, ObjectMapper parentMapper, String lastFieldName) throws IOException {\n        String arrayFieldName = lastFieldName;\n        Mapper mapper = parentMapper.getMapper(lastFieldName);\n        if (mapper != null) {\n            // There is a concrete mapper for this field already. Need to check if the mapper\n            // expects an array, if so we pass the context straight to the mapper and if not\n            // we serialize the array components\n            if (mapper instanceof ArrayValueMapperParser) {\n                parseObjectOrField(context, mapper);\n            } else {\n                parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n            }\n        } else {\n\n            ObjectMapper.Dynamic dynamic = parentMapper.dynamic();\n            if (dynamic == null) {\n                dynamic = dynamicOrDefault(context.root().dynamic());\n            }\n            if (dynamic == ObjectMapper.Dynamic.STRICT) {\n                throw new StrictDynamicMappingException(parentMapper.fullPath(), arrayFieldName);\n            } else if (dynamic == ObjectMapper.Dynamic.TRUE) {\n                Mapper.Builder builder = context.root().findTemplateBuilder(context, arrayFieldName, \"object\");\n                if (builder == null) {\n                    parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n                    return;\n                }\n                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n                mapper = builder.build(builderContext);\n                assert mapper != null;\n                if (mapper instanceof ArrayValueMapperParser) {\n                    context.addDynamicMapper(mapper);\n                    context.path().add(arrayFieldName);\n                    parseObjectOrField(context, mapper);\n                } else {\n                    parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n                }\n            } else {\n                // TODO: shouldn't this skip, not parse?\n                parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n            }\n        }\n    }","id":104799,"modified_method":"private static void parseArray(ParseContext context, ObjectMapper parentMapper, String lastFieldName) throws IOException {\n        String arrayFieldName = lastFieldName;\n        Mapper mapper = getMapper(parentMapper, lastFieldName);\n        if (mapper != null) {\n            // There is a concrete mapper for this field already. Need to check if the mapper\n            // expects an array, if so we pass the context straight to the mapper and if not\n            // we serialize the array components\n            if (mapper instanceof ArrayValueMapperParser) {\n                parseObjectOrField(context, mapper);\n            } else {\n                parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n            }\n        } else {\n\n            ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());\n            if (dynamic == ObjectMapper.Dynamic.STRICT) {\n                throw new StrictDynamicMappingException(parentMapper.fullPath(), arrayFieldName);\n            } else if (dynamic == ObjectMapper.Dynamic.TRUE) {\n                Mapper.Builder builder = context.root().findTemplateBuilder(context, arrayFieldName, \"object\");\n                if (builder == null) {\n                    parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n                    return;\n                }\n                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n                mapper = builder.build(builderContext);\n                assert mapper != null;\n                if (mapper instanceof ArrayValueMapperParser) {\n                    context.addDynamicMapper(mapper);\n                    context.path().add(arrayFieldName);\n                    parseObjectOrField(context, mapper);\n                } else {\n                    parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n                }\n            } else {\n                // TODO: shouldn't this skip, not parse?\n                parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);\n            }\n        }\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static ObjectMapper parseObject(final ParseContext context, ObjectMapper mapper, String currentFieldName) throws IOException {\n        assert currentFieldName != null;\n        context.path().add(currentFieldName);\n\n        ObjectMapper update = null;\n        Mapper objectMapper = mapper.getMapper(currentFieldName);\n        if (objectMapper != null) {\n            parseObjectOrField(context, objectMapper);\n        } else {\n            ObjectMapper.Dynamic dynamic = mapper.dynamic();\n            if (dynamic == null) {\n                dynamic = dynamicOrDefault(context.root().dynamic());\n            }\n            if (dynamic == ObjectMapper.Dynamic.STRICT) {\n                throw new StrictDynamicMappingException(mapper.fullPath(), currentFieldName);\n            } else if (dynamic == ObjectMapper.Dynamic.TRUE) {\n                // remove the current field name from path, since template search and the object builder add it as well...\n                context.path().remove();\n                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, \"object\");\n                if (builder == null) {\n                    builder = new ObjectMapper.Builder(currentFieldName).enabled(true);\n                    // if this is a non root object, then explicitly set the dynamic behavior if set\n                    if (!(mapper instanceof RootObjectMapper) && mapper.dynamic() != ObjectMapper.Defaults.DYNAMIC) {\n                        ((ObjectMapper.Builder) builder).dynamic(mapper.dynamic());\n                    }\n                }\n                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n                objectMapper = builder.build(builderContext);\n                context.addDynamicMapper(objectMapper);\n                context.path().add(currentFieldName);\n                parseObjectOrField(context, objectMapper);\n            } else {\n                // not dynamic, read everything up to end object\n                context.parser().skipChildren();\n            }\n        }\n\n        context.path().remove();\n        return update;\n    }","id":104800,"modified_method":"private static ObjectMapper parseObject(final ParseContext context, ObjectMapper mapper, String currentFieldName) throws IOException {\n        assert currentFieldName != null;\n        context.path().add(currentFieldName);\n\n        ObjectMapper update = null;\n        Mapper objectMapper = getMapper(mapper, currentFieldName);\n        if (objectMapper != null) {\n            parseObjectOrField(context, objectMapper);\n        } else {\n            ObjectMapper.Dynamic dynamic = dynamicOrDefault(mapper, context.root().dynamic());\n            if (dynamic == ObjectMapper.Dynamic.STRICT) {\n                throw new StrictDynamicMappingException(mapper.fullPath(), currentFieldName);\n            } else if (dynamic == ObjectMapper.Dynamic.TRUE) {\n                // remove the current field name from path, since template search and the object builder add it as well...\n                context.path().remove();\n                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, \"object\");\n                if (builder == null) {\n                    builder = new ObjectMapper.Builder(currentFieldName).enabled(true);\n                }\n                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());\n                objectMapper = builder.build(builderContext);\n                context.addDynamicMapper(objectMapper);\n                context.path().add(currentFieldName);\n                parseObjectOrField(context, objectMapper);\n            } else {\n                // not dynamic, read everything up to end object\n                context.parser().skipChildren();\n            }\n        }\n\n        context.path().remove();\n        return update;\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void parseNullValue(ParseContext context, ObjectMapper parentMapper, String lastFieldName) throws IOException {\n        // we can only handle null values if we have mappings for them\n        Mapper mapper = parentMapper.getMapper(lastFieldName);\n        if (mapper != null) {\n            // TODO: passing null to an object seems bogus?\n            parseObjectOrField(context, mapper);\n        } else if (parentMapper.dynamic() == ObjectMapper.Dynamic.STRICT) {\n            throw new StrictDynamicMappingException(parentMapper.fullPath(), lastFieldName);\n        }\n    }","id":104801,"modified_method":"private static void parseNullValue(ParseContext context, ObjectMapper parentMapper, String lastFieldName) throws IOException {\n        // we can only handle null values if we have mappings for them\n        Mapper mapper = getMapper(parentMapper, lastFieldName);\n        if (mapper != null) {\n            // TODO: passing null to an object seems bogus?\n            parseObjectOrField(context, mapper);\n        } else if (parentMapper.dynamic() == ObjectMapper.Dynamic.STRICT) {\n            throw new StrictDynamicMappingException(parentMapper.fullPath(), lastFieldName);\n        }\n    }","commit_id":"125473dc9f492d07e24968f089b5e8ea6e836da6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public int getJunctionNodeSize() {\n        return junctionNodeSize;\n    }","id":104802,"modified_method":"public int getConnectionNodeSize() {\n        return connectionNodeSize;\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void load() {\n        showDirectionArrow = Main.pref.getBoolean(\"draw.segment.direction\", true);\n        showRelevantDirectionsOnly = Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true);\n        useRealWidth = Main.pref.getBoolean(\"mappaint.useRealWidth\", false);\n        defaultSegmentWidth = Main.pref.getInteger(\"mappaint.segment.default-width\", 2);\n\n        selectedColor = PaintColors.SELECTED.get();\n        highlightColor = PaintColors.HIGHLIGHT.get();\n        inactiveColor = PaintColors.INACTIVE.get();\n        nodeColor = PaintColors.NODE.get();\n        taggedColor = PaintColors.TAGGED.get();\n\n        showOrderNumber = Main.pref.getBoolean(\"draw.segment.order_number\", false);\n        showHeadArrowOnly = Main.pref.getBoolean(\"draw.segment.head_only\", false);\n\n        showNamesDistance = Main.pref.getInteger(\"mappaint.shownames\", 10000000);\n        useStrokesDistance = Main.pref.getInteger(\"mappaint.strokes\", 10000000);\n        showIconsDistance = Main.pref.getInteger(\"mappaint.showicons\", 10000000);\n\n        selectedNodeSize = Main.pref.getInteger(\"mappaint.node.selected-size\", 5);\n        unselectedNodeSize = Main.pref.getInteger(\"mappaint.node.unselected-size\", 3);\n        junctionNodeSize = Main.pref.getInteger(\"mappaint.node.junction-size\", 5);\n        fillSelectedNode = Main.pref.getBoolean(\"mappaint.node.fill-selected\", true);\n        fillUnselectedNode = Main.pref.getBoolean(\"mappaint.node.fill-unselected\", false);\n        fillTaggedNode = Main.pref.getBoolean(\"mappaint.node.fill-tagged\", true);\n    }","id":104803,"modified_method":"private void load() {\n        showDirectionArrow = Main.pref.getBoolean(\"draw.segment.direction\", true);\n        showRelevantDirectionsOnly = Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true);\n        useRealWidth = Main.pref.getBoolean(\"mappaint.useRealWidth\", false);\n        defaultSegmentWidth = Main.pref.getInteger(\"mappaint.segment.default-width\", 2);\n\n        selectedColor = PaintColors.SELECTED.get();\n        highlightColor = PaintColors.HIGHLIGHT.get();\n        inactiveColor = PaintColors.INACTIVE.get();\n        nodeColor = PaintColors.NODE.get();\n        taggedColor = PaintColors.TAGGED.get();\n        connectionColor = PaintColors.CONNECTION.get();\n        if (taggedColor != nodeColor) {\n            taggedConnectionColor = taggedColor;\n        } else {\n            taggedConnectionColor = connectionColor;\n        }\n\n\n        showOrderNumber = Main.pref.getBoolean(\"draw.segment.order_number\", false);\n        showHeadArrowOnly = Main.pref.getBoolean(\"draw.segment.head_only\", false);\n\n        showNamesDistance = Main.pref.getInteger(\"mappaint.shownames\", 10000000);\n        useStrokesDistance = Main.pref.getInteger(\"mappaint.strokes\", 10000000);\n        showIconsDistance = Main.pref.getInteger(\"mappaint.showicons\", 10000000);\n\n        selectedNodeSize = Main.pref.getInteger(\"mappaint.node.selected-size\", 5);\n        unselectedNodeSize = Main.pref.getInteger(\"mappaint.node.unselected-size\", 3);\n        connectionNodeSize = Main.pref.getInteger(\"mappaint.node.onnection-size\", 5);\n        taggedNodeSize = Main.pref.getInteger(\"mappaint.node.tagged-size\", 3);\n        fillSelectedNode = Main.pref.getBoolean(\"mappaint.node.fill-selected\", true);\n        fillUnselectedNode = Main.pref.getBoolean(\"mappaint.node.fill-unselected\", false);\n        fillTaggedNode = Main.pref.getBoolean(\"mappaint.node.fill-tagged\", true);\n        fillConnectionNode = Main.pref.getBoolean(\"mappaint.node.fill-onnection\", false);\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public boolean isJunctionNode() {\n        return (OsmPrimitive.getFilteredList(getReferrers(), Way.class)).size() > 1;\n    }","id":104804,"modified_method":"public boolean isConnectionNode() {\n        return (OsmPrimitive.getFilteredList(getReferrers(), Way.class)).size() > 1;\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void paintPrimitive(OsmPrimitive primitive, MapPaintSettings settings, MapPainter painter,\n            boolean selected) {\n        Node n = (Node)primitive;\n        String name = painter.isShowNames()?painter.getNodeName(n):null;\n        if (n.isHighlighted()) {\n            painter.drawNode(n, settings.getHighlightColor(), settings.getSelectedNodeSize(), settings.isFillSelectedNode(), name);\n        } else if (selected) {\n            painter.drawNode(n, settings.getSelectedColor(), settings.getSelectedNodeSize(), settings.isFillSelectedNode(), name);\n        } else {\n            painter.drawNode(\n                n,\n                (painter.isInactive() || n.isDisabled()) ? settings.getInactiveColor() : settings.getNodeColor(),\n                n.isJunctionNode() ? settings.getJunctionNodeSize() : settings.getUnselectedNodeSize(),\n                n.isTagged() ? settings.isFillTaggedNode() : settings.isFillUnselectedNode(),\n                name);\n        }\n    }","id":104805,"modified_method":"@Override\n    public void paintPrimitive(OsmPrimitive primitive, MapPaintSettings settings, MapPainter painter,\n            boolean selected) {\n        Node n = (Node)primitive;\n        String name = painter.isShowNames()?painter.getNodeName(n):null;\n\n\n        if (n.isHighlighted()) {\n            painter.drawNode(n, settings.getHighlightColor(), settings.getSelectedNodeSize(), settings.isFillSelectedNode(), name);\n        } else {\n\n            Color color;\n\n            if (painter.isInactive() || n.isDisabled()) {\n                color = settings.getInactiveColor();\n            } else if (selected) {\n                color = settings.getSelectedColor();\n            } else if (n.isConnectionNode()) {\n                if (n.isTagged()) {\n                    color = settings.getTaggedConnectionColor();\n                } else {\n                    color = settings.getConnectionColor();\n                }\n            } else {\n                if (n.isTagged()) {\n                    color = settings.getTaggedColor();\n                } else {\n                    color = settings.getNodeColor();\n                }\n            }\n\n            final int size = max((selected ? settings.getSelectedNodeSize() : 0),\n                                    (n.isTagged() ? settings.getTaggedNodeSize() : 0),\n                                    (n.isConnectionNode() ? settings.getConnectionNodeSize() : 0),\n                                    settings.getUnselectedNodeSize());\n\n            final boolean fill = (selected && settings.isFillSelectedNode()) ||\n                                    (n.isTagged() && settings.isFillTaggedNode()) ||\n                                    (n.isConnectionNode() && settings.isFillConnectionNode()) ||\n                                    settings.isFillUnselectedNode();\n\n            painter.drawNode(n, color, size, fill, name);\n        }\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Draw a small rectangle.\n     * White if selected (as always) or red otherwise.\n     *\n     * @param n The node to draw.\n     */\n    public void visit(Node n) {\n        if (n.isIncomplete()) return;\n\n        if (n.isHighlighted()) {\n            drawNode(n, highlightColor, selectedNodeSize, unselectedNodeRadius, fillSelectedNode);\n        } else if (ds.isSelected(n)) {\n            drawNode(n, selectedColor, selectedNodeSize, selectedNodeRadius, fillSelectedNode);\n        } else {\n            boolean junction = n.isJunctionNode();\n            drawNode(\n                n,\n                (inactive || n.isDisabled()) ? inactiveColor : \n                    (n.isTagged() ? taggedColor : nodeColor),\n                junction ? junctionNodeSize : unselectedNodeSize,\n                junction ? junctionNodeRadius : unselectedNodeRadius,\n                n.isTagged() ? fillTaggedNode : fillUnselectedNode);\n        }\n    }","id":104806,"modified_method":"/**\n     * Draw a small rectangle.\n     * White if selected (as always) or red otherwise.\n     *\n     * @param n The node to draw.\n     */\n    public void visit(Node n) {\n        if (n.isIncomplete()) return;\n\n        if (n.isHighlighted()) {\n            drawNode(n, highlightColor, selectedNodeSize, fillSelectedNode);\n        } else {\n            Color color;\n\n            if (inactive || n.isDisabled()) {\n                color = inactiveColor;\n            } else if (ds.isSelected(n)) {\n                color = selectedColor;\n            } else if (n.isConnectionNode()) {\n                if (n.isTagged()) {\n                    color = taggedConnectionColor;\n                } else {\n                    color = connectionColor;\n                }\n            } else {\n                if (n.isTagged()) {\n                    color = taggedColor;\n                } else {\n                    color = nodeColor;\n                }\n            }\n\n            final int size = max((ds.isSelected(n) ? selectedNodeSize : 0),\n                                    (n.isTagged() ? taggedNodeSize : 0),\n                                    (n.isConnectionNode() ? connectionNodeSize : 0),\n                                    unselectedNodeSize);\n\n            final boolean fill = (ds.isSelected(n) && fillSelectedNode) ||\n                                    (n.isTagged() && fillTaggedNode) ||\n                                    (n.isConnectionNode() && fillConnectionNode) ||\n                                    fillUnselectedNode;\n\n            drawNode(n, color, size, fill);\n        }\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Draw the node as small rectangle with the given color.\n     *\n     * @param n     The node to draw.\n     * @param color The color of the node.\n     */\n    public void drawNode(Node n, Color color, int size, int radius, boolean fill) {\n        if (size > 1) {\n            Point p = nc.getPoint(n);\n            if ((p.x < 0) || (p.y < 0) || (p.x > nc.getWidth())\n                    || (p.y > nc.getHeight()))\n                return;\n            g.setColor(color);\n            if (fill) {\n                g.fillRect(p.x - radius, p.y - radius, size, size);\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            } else {\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            }\n        }\n    }","id":104807,"modified_method":"/**\n     * Draw the node as small rectangle with the given color.\n     *\n     * @param n     The node to draw.\n     * @param color The color of the node.\n     */\n    public void drawNode(Node n, Color color, int size, boolean fill) {\n        if (size > 1) {\n            int radius = size / 2;\n            Point p = nc.getPoint(n);\n            if ((p.x < 0) || (p.y < 0) || (p.x > nc.getWidth())\n                    || (p.y > nc.getHeight()))\n                return;\n            g.setColor(color);\n            if (fill) {\n                g.fillRect(p.x - radius, p.y - radius, size, size);\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            } else {\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            }\n        }\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void getSettings(boolean virtual) {\n        MapPaintSettings settings = MapPaintSettings.INSTANCE;\n        showDirectionArrow = settings.isShowDirectionArrow();\n        showRelevantDirectionsOnly = settings.isShowRelevantDirectionsOnly();\n        showHeadArrowOnly = settings.isShowHeadArrowOnly();\n        showOrderNumber = settings.isShowOrderNumber();\n        selectedNodeSize = settings.getSelectedNodeSize();\n        selectedNodeRadius = selectedNodeSize / 2;\n        unselectedNodeSize = settings.getUnselectedNodeSize();\n        unselectedNodeRadius = unselectedNodeSize / 2;\n        junctionNodeSize = settings.getJunctionNodeSize();\n        junctionNodeRadius = junctionNodeSize / 2;\n        defaultSegmentWidth = settings.getDefaultSegmentWidth();\n        fillSelectedNode = settings.isFillSelectedNode();\n        fillUnselectedNode = settings.isFillUnselectedNode();\n        fillTaggedNode = settings.isFillTaggedNode();\n        virtualNodeSize = virtual ? Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) / 2 : 0;\n        virtualNodeSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        segmentNumberSpace = Main.pref.getInteger(\"mappaint.segmentnumber.space\", 40);\n        getColors();\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                Main.pref.getBoolean(\"mappaint.use-antialiasing\", false) ?\n                        RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\n    }","id":104808,"modified_method":"protected void getSettings(boolean virtual) {\n        MapPaintSettings settings = MapPaintSettings.INSTANCE;\n        showDirectionArrow = settings.isShowDirectionArrow();\n        showRelevantDirectionsOnly = settings.isShowRelevantDirectionsOnly();\n        showHeadArrowOnly = settings.isShowHeadArrowOnly();\n        showOrderNumber = settings.isShowOrderNumber();\n        selectedNodeSize = settings.getSelectedNodeSize();\n        unselectedNodeSize = settings.getUnselectedNodeSize();\n        connectionNodeSize = settings.getConnectionNodeSize();\n        taggedNodeSize = settings.getTaggedNodeSize();\n        defaultSegmentWidth = settings.getDefaultSegmentWidth();\n        fillSelectedNode = settings.isFillSelectedNode();\n        fillUnselectedNode = settings.isFillUnselectedNode();\n        fillConnectionNode = settings.isFillConnectionNode();\n        fillTaggedNode = settings.isFillTaggedNode();\n        virtualNodeSize = virtual ? Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) / 2 : 0;\n        virtualNodeSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        segmentNumberSpace = Main.pref.getInteger(\"mappaint.segmentnumber.space\", 40);\n        getColors();\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                Main.pref.getBoolean(\"mappaint.use-antialiasing\", false) ?\n                        RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void getColors()\n    {\n        inactiveColor = PaintColors.INACTIVE.get();\n        selectedColor = PaintColors.SELECTED.get();\n        nodeColor = PaintColors.NODE.get();\n        dfltWayColor = PaintColors.DEFAULT_WAY.get();\n        relationColor = PaintColors.RELATION.get();\n        untaggedWayColor = PaintColors.UNTAGGED_WAY.get();\n        incompleteColor = PaintColors.INCOMPLETE_WAY.get();\n        backgroundColor = PaintColors.BACKGROUND.get();\n        highlightColor = PaintColors.HIGHLIGHT.get();\n        taggedColor = PaintColors.TAGGED.get();\n    }","id":104809,"modified_method":"public void getColors()\n    {\n        inactiveColor = PaintColors.INACTIVE.get();\n        selectedColor = PaintColors.SELECTED.get();\n        nodeColor = PaintColors.NODE.get();\n        dfltWayColor = PaintColors.DEFAULT_WAY.get();\n        relationColor = PaintColors.RELATION.get();\n        untaggedWayColor = PaintColors.UNTAGGED_WAY.get();\n        incompleteColor = PaintColors.INCOMPLETE_WAY.get();\n        backgroundColor = PaintColors.BACKGROUND.get();\n        highlightColor = PaintColors.HIGHLIGHT.get();\n        taggedColor = PaintColors.TAGGED.get();\n        connectionColor = PaintColors.CONNECTION.get();\n\n        if (taggedColor != nodeColor) {\n            taggedConnectionColor = taggedColor;\n        } else {\n            taggedConnectionColor = connectionColor;\n        }\n    }","commit_id":"b254b59efabe482f93bc747fa96eea05b74ded6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * This tests forwarding of 7 alarms, one for each OpenNMS severity to\n\t * verify the LOG_LEVEL agrees with the Severity based on our algorithm.\n\t * \n\t * @throws InterruptedException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testForwardAlarms() throws InterruptedException, IOException {\n\t\t\n\t\tString xml = generateConfigXml();\n\t\t\n\t\tResource resource = new ByteArrayResource(xml.getBytes());\n\t\t\n\t\tSyslogNorthbounderConfigDao dao = new SyslogNorthbounderConfigDao();\n\t\tdao.setConfigResource(resource);\n\t\tdao.afterPropertiesSet();\n\n\t\tSyslogNorthbounder nb = new SyslogNorthbounder();\n\t\tSyslogNorthbounderConfig config = dao.getConfig();\n\t\t\n\t\tnb.setNodeDao(new TestNodeDao());\n\t\tnb.setConfig(config);\n\t\t\n\n\t\tint j = 7;\n\t\tList<NorthboundAlarm> alarms = new LinkedList<NorthboundAlarm>();\n\t\t\n\t\tOnmsDistPoller distpoller = new OnmsDistPoller(\"barbrady\", \"172.20.1.11\");\n\t\tOnmsNode node = new OnmsNode(distpoller, \"p-brane\");\n\t\tnode.setForeignSource(\"TestGroup\");\n\t\tnode.setForeignId(\"1\");\n\t\tnode.setId(TEST_NODE_ID);\n\t\t\n\t\tOnmsSnmpInterface snmpInterface = new OnmsSnmpInterface(node, 1);\n\t\tsnmpInterface.setId(1);\n\t\tsnmpInterface.setIfAlias(\"Connection to OpenNMS Wifi\");\n\t\tsnmpInterface.setIfDescr(\"en1\");\n\t\tsnmpInterface.setIfName(\"en1/0\");\n\t\tsnmpInterface.setPhysAddr(\"00:00:00:00:00:01\");\n\t\t\n\t\tSet<OnmsIpInterface> ipInterfaces = new LinkedHashSet<OnmsIpInterface>(j);\n\t\tInetAddress address = InetAddress.getByName(\"10.0.1.1\");\n\t\tOnmsIpInterface onmsIf = new OnmsIpInterface(address, node);\n\t\tonmsIf.setSnmpInterface(snmpInterface);\n\t\tonmsIf.setId(1);\n\t\tonmsIf.setIfIndex(1);\n\t\tonmsIf.setIpHostName(\"p-brane\");\n\t\tonmsIf.setIsSnmpPrimary(PrimaryType.PRIMARY);\n\t\t\n\t\t\n\t\tipInterfaces.add(onmsIf);\n\t\t\n\t\tnode.setIpInterfaces(ipInterfaces);\n\n\t\t\n\t\tfor (int i = 1; i <=j; ++i) {\n\t\t\tOnmsAlarm onmsAlarm = new OnmsAlarm();\n\t\t\tonmsAlarm.setId(i);\n\t\t\tonmsAlarm.setUei(\"uei.opennms.org/test/syslogNorthBounder\");\n\t\t\tonmsAlarm.setNode(node);\n\t\t\tonmsAlarm.setSeverityId(i);\n\t\t\tonmsAlarm.setIpAddr(InetAddress.getByName(\"127.0.0.1\"));\n\t\t\tonmsAlarm.setCounter(i);\n\t\t\tonmsAlarm.setLogMsg(\"Node Down\");\n\t\t\tonmsAlarm.setX733AlarmType(NorthboundAlarm.x733AlarmType.get(i).name());\n\t\t\tonmsAlarm.setX733ProbableCause(NorthboundAlarm.x733ProbableCause.get(i).getId());\n\t\t\tString eventparms = \"foreignSource=fabric(string,text);foreignId=space-0256012012000038(string,text);reason=Aborting node scan : Agent timed out while scanning the system table(string,text);\" +\n\t\t\t\t\t\".1.3.6.1.4.1.2636.3.18.1.7.1.2.732=207795895(TimeTicks,text)\";\n\t\t\tonmsAlarm.setEventParms(eventparms );\n\t\t\tNorthboundAlarm a = new NorthboundAlarm(onmsAlarm);\n\n\t\t\tAssert.assertFalse(nb.accepts(a));\n\t\t\tonmsAlarm.setUei(\"uei.opennms.org/nodes/nodeDown\");\n\t\t\ta = new NorthboundAlarm(onmsAlarm);\n\t\t\tAssert.assertTrue(nb.accepts(a));\n\t\t\t\n\t\t\talarms.add(a);\n\t\t}\n\t\t\n\n\t\tnb.forwardAlarms(alarms);\n\t\tThread.sleep(1000);\n\n\t\tBufferedReader r = new BufferedReader(new StringReader(m_logStream.readStream()));\n\n\t\tList<String> messages = new LinkedList<String>();\n\t\tString line = null;\n\n\t\twhile ((line = r.readLine()) != null) {\n\t\t\tmessages.add(line);\n\t\t\tThread.sleep(10);\n\t\t}\n\n\t\tAssert.assertTrue(\"Log messages sent: 7, Log messages received: \" + messages.size(), 7 == messages.size());\n\t\t\n\t\tfor (String message : messages) {\n\t\t\tSystem.out.println(message);\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\tfor (String message : messages) {\n\t\t\tif (i == 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 1:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_INFO.\", message.contains(\"INFO\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_CRITICAL.\", message.contains(\"CRITICAL\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t// TODO: Verify facility and level of each log message\n\n\t}","id":104810,"modified_method":"/**\n\t * This tests forwarding of 7 alarms, one for each OpenNMS severity to\n\t * verify the LOG_LEVEL agrees with the Severity based on our algorithm.\n\t * @throws Exception \n\t */\n\t@Test\n\tpublic void testForwardAlarms() throws Exception {\n\t\t\n\t\tString xml = generateConfigXml();\n\t\t\n\t\tResource resource = new ByteArrayResource(xml.getBytes());\n\t\t\n\t\tSyslogNorthbounderConfigDao dao = new SyslogNorthbounderConfigDao();\n\t\tdao.setConfigResource(resource);\n\t\tdao.afterPropertiesSet();\n\n\t\tSyslogNorthbounderConfig config = dao.getConfig();\n\t\t\n\t\tList<SyslogDestination> destinations = config.getDestinations();\n\n\t\tList<SyslogNorthbounder> nbis = new LinkedList<SyslogNorthbounder>();\n\t\t\n\t\tfor (SyslogDestination syslogDestination : destinations) {\n\t\t\tSyslogNorthbounder nbi = new SyslogNorthbounder(config, syslogDestination);\n\t\t\tnbi.setNodeDao(new TestNodeDao());\n\t\t\tnbi.afterPropertiesSet();\n\t\t\tnbis.add(nbi);\n\t\t}\n\n\t\tint j = 7;\n\t\tList<NorthboundAlarm> alarms = new LinkedList<NorthboundAlarm>();\n\t\t\n\t\tOnmsDistPoller distpoller = new OnmsDistPoller(\"barbrady\", \"172.20.1.11\");\n\t\tOnmsNode node = new OnmsNode(distpoller, \"p-brane\");\n\t\tnode.setForeignSource(\"TestGroup\");\n\t\tnode.setForeignId(\"1\");\n\t\tnode.setId(TEST_NODE_ID);\n\t\t\n\t\tOnmsSnmpInterface snmpInterface = new OnmsSnmpInterface(node, 1);\n\t\tsnmpInterface.setId(1);\n\t\tsnmpInterface.setIfAlias(\"Connection to OpenNMS Wifi\");\n\t\tsnmpInterface.setIfDescr(\"en1\");\n\t\tsnmpInterface.setIfName(\"en1/0\");\n\t\tsnmpInterface.setPhysAddr(\"00:00:00:00:00:01\");\n\t\t\n\t\tSet<OnmsIpInterface> ipInterfaces = new LinkedHashSet<OnmsIpInterface>(j);\n\t\tInetAddress address = InetAddress.getByName(\"10.0.1.1\");\n\t\tOnmsIpInterface onmsIf = new OnmsIpInterface(address, node);\n\t\tonmsIf.setSnmpInterface(snmpInterface);\n\t\tonmsIf.setId(1);\n\t\tonmsIf.setIfIndex(1);\n\t\tonmsIf.setIpHostName(\"p-brane\");\n\t\tonmsIf.setIsSnmpPrimary(PrimaryType.PRIMARY);\n\t\t\n\t\tipInterfaces.add(onmsIf);\n\t\t\n\t\tnode.setIpInterfaces(ipInterfaces);\n\n\t\tfor (SyslogNorthbounder nbi : nbis) {\n\n\t\t\tfor (int i = 1; i <=j; ++i) {\n\t\t\t\tOnmsAlarm onmsAlarm = new OnmsAlarm();\n\t\t\t\tonmsAlarm.setId(i);\n\t\t\t\tonmsAlarm.setUei(\"uei.opennms.org/test/syslogNorthBounder\");\n\t\t\t\tonmsAlarm.setNode(node);\n\t\t\t\tonmsAlarm.setSeverityId(i);\n\t\t\t\tonmsAlarm.setIpAddr(InetAddress.getByName(\"127.0.0.1\"));\n\t\t\t\tonmsAlarm.setCounter(i);\n\t\t\t\tonmsAlarm.setLogMsg(\"Node Down\");\n\t\t\t\tonmsAlarm.setX733AlarmType(NorthboundAlarm.x733AlarmType.get(i).name());\n\t\t\t\tonmsAlarm.setX733ProbableCause(NorthboundAlarm.x733ProbableCause.get(i).getId());\n\t\t\t\tString eventparms = \"foreignSource=fabric(string,text);foreignId=space-0256012012000038(string,text);reason=Aborting node scan : Agent timed out while scanning the system table(string,text);\" +\n\t\t\t\t\t\t\".1.3.6.1.4.1.2636.3.18.1.7.1.2.732=207795895(TimeTicks,text)\";\n\t\t\t\tonmsAlarm.setEventParms(eventparms );\n\t\t\t\tNorthboundAlarm a = new NorthboundAlarm(onmsAlarm);\n\n\t\t\t\tAssert.assertFalse(nbi.accepts(a));\n\t\t\t\tonmsAlarm.setUei(\"uei.opennms.org/nodes/nodeDown\");\n\t\t\t\ta = new NorthboundAlarm(onmsAlarm);\n\t\t\t\tAssert.assertTrue(nbi.accepts(a));\n\n\t\t\t\talarms.add(a);\n\t\t\t}\n\t\t\tnbi.forwardAlarms(alarms);\n\t\t}\t\t\n\n\t\tThread.sleep(100);\n\n\t\tBufferedReader r = new BufferedReader(new StringReader(m_logStream.readStream()));\n\n\t\tList<String> messages = new LinkedList<String>();\n\t\tString line = null;\n\n\t\twhile ((line = r.readLine()) != null) {\n\t\t\tmessages.add(line);\n\t\t\tThread.sleep(10);\n\t\t}\n\n\t\tAssert.assertTrue(\"Log messages sent: 7, Log messages received: \" + messages.size(), 7 == messages.size());\n\t\t\n\t\tfor (String message : messages) {\n\t\t\tSystem.out.println(message);\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\tfor (String message : messages) {\n\t\t\tif (i == 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 1:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_INFO.\", message.contains(\"INFO\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_CRITICAL.\", message.contains(\"CRITICAL\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Each implementation of the AbstractNorthbounder has a nice queue (Nagle's algorithmic) and the worker\n\t * thread that processes the queue calls this method to send alarms to the northern NMS.\n\t * \n\t */\n    @Override\n    public void forwardAlarms(List<NorthboundAlarm> alarms) throws NorthbounderException {\n        \n        List<SyslogDestination> dests = getDestinations();\n        \n        if (dests == null) {\n        \tString errorMsg = \"No Syslog destinations are defined.\";\n\t\t\tIllegalStateException e = new IllegalStateException(errorMsg);\n        \tLogUtils.errorf(this, e, errorMsg);\n\t\t\tthrow e;\n        }\n        \n        if (alarms == null) {\n        \tString errorMsg = \"No alarms in alarms list for syslog forwarding.\";\n\t\t\tIllegalStateException e = new IllegalStateException(errorMsg);\n        \tLogUtils.errorf(this, e, errorMsg);\n\t\t\tthrow e;\n        }\n        \n        LogUtils.infof(this, \"Forwarding %d alarms to %d destinations...\", alarms.size(), dests.size());\n\n    \tMap<Integer, Map<String, String>> alarmMappings = new HashMap<Integer, Map<String, String>>();    \t\n        \n        for (SyslogDestination dest : dests) {\n        \t\n        \tSyslogIF instance;\n\t\t\ttry {\n\t\t\t\tinstance = Syslog.getInstance(dest.getName());\n\t\t\t} catch (SyslogRuntimeException e) {\n\t\t\t\tLogUtils.errorf(this, e, \"Could not find Syslog instance for destination: %s.\", dest.getName());\n\t\t\t\tcontinue;\n\t\t\t}\n        \t\n        \tLogUtils.debugf(this, \"Forwarding alarms to destination %s.\", dest.getName());\n        \t\n        \t/*\n        \t * Iterate over the list of alarms to be forwarded N.\n        \t */\n        \tfor (NorthboundAlarm alarm : alarms) {\n        \t\t\n        \t\tInteger count = alarm.getCount();\n\t\t\t\tif (count > 1 && dest.isFirstOccurrenceOnly()) {\n        \t\t\tLogUtils.debugf(this, \"Destination %s is configured for new alarm instances only.  Alarm has count of %d.\", dest.getName(), count);\n        \t\t\tcontinue;\n        \t\t}\n\n        \t\tLogUtils.debugf(this, \"Creating formatted log message for alarm: %d.\", alarm.getId());\n        \t\t\n        \t\tMap<String, String> mapping = null;\n        \t\t\n        \t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tString syslogMessage;\n\t\t\t\tint level;\n\t\t\t\ttry {\n\t\t\t\t\tif (alarmMappings != null) {\n\t\t\t\t\t\tmapping = alarmMappings.get(alarm.getId());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (mapping == null) {\n\t\t\t\t\t\tmapping = createMapping(alarmMappings, alarm);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tLogUtils.debugf(this, \"Making substitutions for tokens in message format for alarm: %d.\", alarm.getId());\n\t\t\t\t\tsyslogMessage = PropertiesUtils.substitute(m_config.getMessageFormat(), mapping);\n\n\t\t\t\t\tLogUtils.debugf(this, \"Determining LOG_LEVEL for alarm: %d\", alarm.getId());\n\t\t\t\t\tlevel = determineLogLevel(alarm.getSeverity());\n\t        \t\t//Send the Syslog message...\n\t\t\t\t\tLogUtils.debugf(this, \"Forwarding alarm: %d via syslog to destination: %s\", alarm.getId(), dest.getName());\n\t\t\t\t\tinstance.log(level, syslogMessage);\n\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\tLogUtils.errorf(this, e1, \"Caught exception sending to destination: %s\", dest.getName());\n\t\t\t\t}\n\n        \t}\n        }\n\n    }","id":104811,"modified_method":"/**\n\t * Each implementation of the AbstractNorthbounder has a nice queue (Nagle's algorithmic) and the worker\n\t * thread that processes the queue calls this method to send alarms to the northern NMS.\n\t * \n\t */\n    @Override\n    public void forwardAlarms(List<NorthboundAlarm> alarms) throws NorthbounderException {\n        \n        if (alarms == null) {\n        \tString errorMsg = \"No alarms in alarms list for syslog forwarding.\";\n\t\t\tIllegalStateException e = new IllegalStateException(errorMsg);\n        \tLogUtils.errorf(this, e, errorMsg);\n\t\t\tthrow e;\n        }\n        \n        LogUtils.infof(this, \"Forwarding %d alarms to destination:\"+m_destination.getName(), alarms.size());\n\n    \tMap<Integer, Map<String, String>> alarmMappings = new HashMap<Integer, Map<String, String>>();    \t\n        \n    \tSyslogIF instance;\n    \ttry {\n    \t\tinstance = Syslog.getInstance(m_destination.getName());\n    \t} catch (SyslogRuntimeException e) {\n    \t\tLogUtils.errorf(this, e, \"Could not find Syslog instance for destination: %s.\", m_destination.getName());\n    \t\tthrow e;\n    \t}\n\n    \t/*\n    \t * Iterate over the list of alarms to be forwarded N.\n    \t */\n    \tfor (NorthboundAlarm alarm : alarms) {\n\n    \t\tInteger count = alarm.getCount();\n    \t\tif (count > 1 && m_destination.isFirstOccurrenceOnly()) {\n    \t\t\tLogUtils.debugf(this, \"Destination %s is configured for new alarm instances only.  Alarm has count of %d.\", m_destination.getName(), count);\n    \t\t\tcontinue;\n    \t\t}\n\n    \t\tLogUtils.debugf(this, \"Creating formatted log message for alarm: %d.\", alarm.getId());\n\n    \t\tMap<String, String> mapping = null;\n\n    \t\tString syslogMessage;\n    \t\tint level;\n    \t\ttry {\n    \t\t\tif (alarmMappings != null) {\n    \t\t\t\tmapping = alarmMappings.get(alarm.getId());\n    \t\t\t}\n\n    \t\t\tif (mapping == null) {\n    \t\t\t\tmapping = createMapping(alarmMappings, alarm);\n    \t\t\t}\n\n    \t\t\tLogUtils.debugf(this, \"Making substitutions for tokens in message format for alarm: %d.\", alarm.getId());\n    \t\t\tsyslogMessage = PropertiesUtils.substitute(m_config.getMessageFormat(), mapping);\n\n    \t\t\tLogUtils.debugf(this, \"Determining LOG_LEVEL for alarm: %d\", alarm.getId());\n    \t\t\tlevel = determineLogLevel(alarm.getSeverity());\n    \t\t\t\n    \t\t\tLogUtils.debugf(this, \"Forwarding alarm: %d via syslog to destination: %s\", alarm.getId(), m_destination.getName());\n    \t\t\tinstance.log(level, syslogMessage);\n    \t\t\t\n    \t\t} catch (Exception e1) {\n    \t\t\tLogUtils.errorf(this, e1, \"Caught exception sending to destination: %s\", m_destination.getName());\n    \t\t}\n    \t}\n    }","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tif (m_config == null) {\n\t\t\t\n\t\t\tLogUtils.infof(this, \"Syslog Northbounder is currently disabled, rejecting alarm.\");\n\t\t\t\n\t\t\tString msg = \"Syslog forwarding configuration is not initialized.\";\n\t\t\tIllegalStateException e = new IllegalStateException(msg);\n\t\t\tLogUtils.errorf(this, e, msg);\n\t\t\tthrow e;\n\t\t}\n\t\t\n\t\t\n\t\tcreateNorthboundInstances();\n\t\tsetNaglesDelay(m_config.getNaglesDelay());\n\t\tsetMaxBatchSize(m_config.getBatchSize());\n\t\tsetMaxPreservedAlarms(m_config.getQueueSize());\n\t}","id":104812,"modified_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tif (m_config == null) {\n\t\t\t\n\t\t\tLogUtils.infof(this, \"Syslog Northbounder is currently disabled, rejecting alarm.\");\n\t\t\t\n\t\t\tString msg = \"Syslog forwarding configuration is not initialized.\";\n\t\t\tIllegalStateException e = new IllegalStateException(msg);\n\t\t\tLogUtils.errorf(this, e, msg);\n\t\t\tthrow e;\n\t\t}\n\t\t\n\t\tcreateNorthboundInstance();\n\t\tsetNaglesDelay(m_config.getNaglesDelay());\n\t\tsetMaxBatchSize(m_config.getBatchSize());\n\t\tsetMaxPreservedAlarms(m_config.getQueueSize());\n\t}","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyslogNorthbounderConfig getConfig() {\n    \t\n    \tif (m_config == null) {\n//    \t\tLogUtils.errorf(this, \"Syslog Northbounder configuration is not set.\", null);\n    \t\tthrow new IllegalStateException(\"Syslog Northbound configuration not set.\");\n    \t}\n        return m_config;\n    }","id":104813,"modified_method":"public SyslogNorthbounderConfig getConfig() {\n    \t\n    \tif (m_config == null) {\n    \t\tLogUtils.errorf(this, \"Syslog Northbounder configuration is not set.\");\n    \t\tthrow new IllegalStateException(\"Syslog Northbound configuration not set.\");\n    \t}\n        return m_config;\n    }","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setConfig(SyslogNorthbounderConfig config) {\n    \tif (config == null) {\n    \t\tthrow new IllegalStateException(\"Configuration cannot be set to null!\");\n    \t}\n    \t\n\t\tsynchronized (m_configLock) {\n\t\t\tm_config = config;\n    \t\tSyslog.shutdown();\n    \t\tSyslog.initialize();\n    \t\tcreateNorthboundInstances();\n\t\t}\n    }","id":104814,"modified_method":"public void setConfig(final SyslogNorthbounderConfig config) {\n    \t\n    \tif (config == null) {\n    \t\tString string = \"Syslog Northbounder configuration cannot be set null\";\n\t\t\tLogUtils.errorf(this, string);\n    \t\tthrow new IllegalStateException(string);\n    \t}\n    \t\n    }","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyslogNorthbounder(SyslogNorthbounderConfig config) {\n    \tsuper(\"SyslogNorthbounder\");\n    \tm_config = config;\n    }","id":104815,"modified_method":"public SyslogNorthbounder(SyslogNorthbounderConfig config, SyslogDestination destination) {\n\t\tsuper(NBI_NAME+\":\"+destination);\n\t\tm_config = config;\n\t\tm_destination = destination;\n\t}","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is here, for now, until it can be properly wired and proper configuration can be created.\n     * This allows generic 127.0.0.1:UDP/514 to work with OpenNMS having no configuration.  This is\n     * trickery in its finest hour.\n     */\n    private void createNorthboundInstances() throws SyslogRuntimeException {\n    \t\n    \tLogUtils.infof(this, \"Creating Syslog Northbound Instances...\");\n    \t\n    \tLogUtils.debugf(this, \"Acquiring configuration lock...\");\n    \tsynchronized (m_configLock) {\n    \t\t\n    \t\tLogUtils.debugf(this, \"Lock acquired.\");\n\t\t\t\n\t\t\tList<SyslogDestination> destinations = m_config.getDestinations();\n\t\t\tfor (SyslogDestination dest : destinations) {\n\n\t\t\t\tString instName = dest.getName();\n\t\t\t\tint facility = convertFacility(dest.getFacility());\n\t\t\t\tSyslogProtocol protocol = dest.getProtocol();\n\t\t\t\tSyslogConfigIF instanceConfiguration = createConfig(dest, protocol, facility);\n\t\t\t\tinstanceConfiguration.setIdent(\"OpenNMS\");\n\t\t\t\tinstanceConfiguration.setCharSet(dest.getCharSet());\n\t\t\t\tinstanceConfiguration.setMaxMessageLength(dest.getMaxMessageLength());\n\t\t\t\tinstanceConfiguration.setSendLocalName(dest.isSendLocalName());\n\t\t\t\tinstanceConfiguration.setSendLocalTimestamp(dest.isSendLocalTime());\n\t\t\t\tinstanceConfiguration.setTruncateMessage(dest.isTruncateMessage());\n\t\t\t\tinstanceConfiguration.setUseStructuredData(SyslogConstants.USE_STRUCTURED_DATA_DEFAULT);\n\n\t\t\t\tLogUtils.debugf(this, \"Creating northbound syslog instance: %s\", instName);\n\t\t\t\ttry {\n\t\t\t\t\tSyslog.createInstance(instName, instanceConfiguration);\n\t\t\t\t} catch (SyslogRuntimeException e) {\n\t\t\t\t\tString msg = \"Could not create northbound instance, %s\";\n\t\t\t\t\tLogUtils.errorf(this, e, msg, instName);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n    \t\n\t}","id":104816,"modified_method":"/**\n     * This is here, for now, until it can be properly wired and proper configuration can be created.\n     * This allows generic 127.0.0.1:UDP/514 to work with OpenNMS having no configuration.  This is\n     * trickery in its finest hour.\n     */\n    private void createNorthboundInstance() throws SyslogRuntimeException {\n    \t\n    \tLogUtils.infof(this, \"Creating Syslog Northbound Instance:%s\", m_destination.getName());\n    \t\n    \tString instName = m_destination.getName();\n    \tint facility = convertFacility(m_destination.getFacility());\n    \tSyslogProtocol protocol = m_destination.getProtocol();\n    \tSyslogConfigIF instanceConfiguration = createConfig(m_destination, protocol, facility);\n    \tinstanceConfiguration.setIdent(\"OpenNMS\");\n    \tinstanceConfiguration.setCharSet(m_destination.getCharSet());\n    \tinstanceConfiguration.setMaxMessageLength(m_destination.getMaxMessageLength());\n    \tinstanceConfiguration.setSendLocalName(m_destination.isSendLocalName());\n    \tinstanceConfiguration.setSendLocalTimestamp(m_destination.isSendLocalTime());\n    \tinstanceConfiguration.setTruncateMessage(m_destination.isTruncateMessage());\n    \tinstanceConfiguration.setUseStructuredData(SyslogConstants.USE_STRUCTURED_DATA_DEFAULT);\n\n    \ttry {\n    \t\tSyslog.createInstance(instName, instanceConfiguration);\n    \t} catch (SyslogRuntimeException e) {\n    \t\tString msg = \"Could not create northbound instance, %s\";\n    \t\tLogUtils.errorf(this, e, msg, instName);\n    \t\tthrow e;\n    \t}\n\n\t}","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tAssert.notNull(m_nodeDao);\n\t\tAssert.notNull(m_configDao);\n\t\tAssert.notNull(m_serviceRegistry);\n\t\t\n\t\tSyslogNorthbounderConfig config = m_configDao.getConfig();\n\n\t\tSyslogNorthbounder northbounder = new SyslogNorthbounder(config);\n\t\tnorthbounder.setNodeDao(m_nodeDao);\n\t\t\n\t\tnorthbounder.afterPropertiesSet();\n\t\t\n\t\tm_registration = m_serviceRegistry.register(northbounder, Northbounder.class);\n\t\t\n\n\t}","id":104817,"modified_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tAssert.notNull(m_nodeDao);\n\t\tAssert.notNull(m_configDao);\n\t\tAssert.notNull(m_serviceRegistry);\n\t\t\n\t\tSyslogNorthbounderConfig config = m_configDao.getConfig();\n\t\t\n\t\tList<SyslogDestination> destinations = config.getDestinations();\n\t\tfor (SyslogDestination syslogDestination : destinations) {\n\t\t\tSyslogNorthbounder nbi = new SyslogNorthbounder(config, syslogDestination);\n\t\t\tnbi.setNodeDao(m_nodeDao);\n\t\t\tnbi.afterPropertiesSet();\n\t\t\tm_registration = m_serviceRegistry.register(nbi, Northbounder.class);\n\t\t}\n\n\t}","commit_id":"a445e217e5981b293c79f07e968beeaf6d31be3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * This tests forwarding of 7 alarms, one for each OpenNMS severity to\n\t * verify the LOG_LEVEL agrees with the Severity based on our algorithm.\n\t * \n\t * @throws InterruptedException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testForwardAlarms() throws InterruptedException, IOException {\n\t\t\n\t\tString xml = generateConfigXml();\n\t\t\n\t\tResource resource = new ByteArrayResource(xml.getBytes());\n\t\t\n\t\tSyslogNorthbounderConfigDao dao = new SyslogNorthbounderConfigDao();\n\t\tdao.setConfigResource(resource);\n\t\tdao.afterPropertiesSet();\n\n\t\tSyslogNorthbounder nb = new SyslogNorthbounder();\n\t\tSyslogNorthbounderConfig config = dao.getConfig();\n\t\t\n\t\tnb.setNodeDao(new TestNodeDao());\n\t\tnb.setConfig(config);\n\t\t\n\n\t\tint j = 7;\n\t\tList<NorthboundAlarm> alarms = new LinkedList<NorthboundAlarm>();\n\t\t\n\t\tOnmsDistPoller distpoller = new OnmsDistPoller(\"barbrady\", \"172.20.1.11\");\n\t\tOnmsNode node = new OnmsNode(distpoller, \"p-brane\");\n\t\tnode.setForeignSource(\"TestGroup\");\n\t\tnode.setForeignId(\"1\");\n\t\tnode.setId(TEST_NODE_ID);\n\t\t\n\t\tOnmsSnmpInterface snmpInterface = new OnmsSnmpInterface(node, 1);\n\t\tsnmpInterface.setId(1);\n\t\tsnmpInterface.setIfAlias(\"Connection to OpenNMS Wifi\");\n\t\tsnmpInterface.setIfDescr(\"en1\");\n\t\tsnmpInterface.setIfName(\"en1/0\");\n\t\tsnmpInterface.setPhysAddr(\"00:00:00:00:00:01\");\n\t\t\n\t\tSet<OnmsIpInterface> ipInterfaces = new LinkedHashSet<OnmsIpInterface>(j);\n\t\tInetAddress address = InetAddress.getByName(\"10.0.1.1\");\n\t\tOnmsIpInterface onmsIf = new OnmsIpInterface(address, node);\n\t\tonmsIf.setSnmpInterface(snmpInterface);\n\t\tonmsIf.setId(1);\n\t\tonmsIf.setIfIndex(1);\n\t\tonmsIf.setIpHostName(\"p-brane\");\n\t\tonmsIf.setIsSnmpPrimary(PrimaryType.PRIMARY);\n\t\t\n\t\t\n\t\tipInterfaces.add(onmsIf);\n\t\t\n\t\tnode.setIpInterfaces(ipInterfaces);\n\n\t\t\n\t\tfor (int i = 1; i <=j; ++i) {\n\t\t\tOnmsAlarm onmsAlarm = new OnmsAlarm();\n\t\t\tonmsAlarm.setId(i);\n\t\t\tonmsAlarm.setUei(\"uei.opennms.org/test/syslogNorthBounder\");\n\t\t\tonmsAlarm.setNode(node);\n\t\t\tonmsAlarm.setSeverityId(i);\n\t\t\tonmsAlarm.setIpAddr(InetAddress.getByName(\"127.0.0.1\"));\n\t\t\tonmsAlarm.setCounter(i);\n\t\t\tonmsAlarm.setLogMsg(\"Node Down\");\n\t\t\tonmsAlarm.setX733AlarmType(NorthboundAlarm.x733AlarmType.get(i).name());\n\t\t\tonmsAlarm.setX733ProbableCause(NorthboundAlarm.x733ProbableCause.get(i).getId());\n\t\t\tString eventparms = \"foreignSource=fabric(string,text);foreignId=space-0256012012000038(string,text);reason=Aborting node scan : Agent timed out while scanning the system table(string,text);\" +\n\t\t\t\t\t\".1.3.6.1.4.1.2636.3.18.1.7.1.2.732=207795895(TimeTicks,text)\";\n\t\t\tonmsAlarm.setEventParms(eventparms );\n\t\t\tNorthboundAlarm a = new NorthboundAlarm(onmsAlarm);\n\n\t\t\tAssert.assertFalse(nb.accepts(a));\n\t\t\tonmsAlarm.setUei(\"uei.opennms.org/nodes/nodeDown\");\n\t\t\ta = new NorthboundAlarm(onmsAlarm);\n\t\t\tAssert.assertTrue(nb.accepts(a));\n\t\t\t\n\t\t\talarms.add(a);\n\t\t}\n\t\t\n\n\t\tnb.forwardAlarms(alarms);\n\t\tThread.sleep(1000);\n\n\t\tBufferedReader r = new BufferedReader(new StringReader(m_logStream.readStream()));\n\n\t\tList<String> messages = new LinkedList<String>();\n\t\tString line = null;\n\n\t\twhile ((line = r.readLine()) != null) {\n\t\t\tmessages.add(line);\n\t\t\tThread.sleep(10);\n\t\t}\n\n\t\tAssert.assertTrue(\"Log messages sent: 7, Log messages received: \" + messages.size(), 7 == messages.size());\n\t\t\n\t\tfor (String message : messages) {\n\t\t\tSystem.out.println(message);\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\tfor (String message : messages) {\n\t\t\tif (i == 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 1:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_INFO.\", message.contains(\"INFO\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_CRITICAL.\", message.contains(\"CRITICAL\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t// TODO: Verify facility and level of each log message\n\n\t}","id":104818,"modified_method":"/**\n\t * This tests forwarding of 7 alarms, one for each OpenNMS severity to\n\t * verify the LOG_LEVEL agrees with the Severity based on our algorithm.\n\t * @throws Exception \n\t */\n\t@Test\n\tpublic void testForwardAlarms() throws Exception {\n\t\t\n\t\tString xml = generateConfigXml();\n\t\t\n\t\tResource resource = new ByteArrayResource(xml.getBytes());\n\t\t\n\t\tSyslogNorthbounderConfigDao dao = new SyslogNorthbounderConfigDao();\n\t\tdao.setConfigResource(resource);\n\t\tdao.afterPropertiesSet();\n\n\t\tSyslogNorthbounderConfig config = dao.getConfig();\n\t\t\n\t\tList<SyslogDestination> destinations = config.getDestinations();\n\n\t\tList<SyslogNorthbounder> nbis = new LinkedList<SyslogNorthbounder>();\n\t\t\n\t\tfor (SyslogDestination syslogDestination : destinations) {\n\t\t\tSyslogNorthbounder nbi = new SyslogNorthbounder(config, syslogDestination);\n\t\t\tnbi.setNodeDao(new TestNodeDao());\n\t\t\tnbi.afterPropertiesSet();\n\t\t\tnbis.add(nbi);\n\t\t}\n\n\t\tint j = 7;\n\t\tList<NorthboundAlarm> alarms = new LinkedList<NorthboundAlarm>();\n\t\t\n\t\tOnmsDistPoller distpoller = new OnmsDistPoller(\"barbrady\", \"172.20.1.11\");\n\t\tOnmsNode node = new OnmsNode(distpoller, \"p-brane\");\n\t\tnode.setForeignSource(\"TestGroup\");\n\t\tnode.setForeignId(\"1\");\n\t\tnode.setId(TEST_NODE_ID);\n\t\t\n\t\tOnmsSnmpInterface snmpInterface = new OnmsSnmpInterface(node, 1);\n\t\tsnmpInterface.setId(1);\n\t\tsnmpInterface.setIfAlias(\"Connection to OpenNMS Wifi\");\n\t\tsnmpInterface.setIfDescr(\"en1\");\n\t\tsnmpInterface.setIfName(\"en1/0\");\n\t\tsnmpInterface.setPhysAddr(\"00:00:00:00:00:01\");\n\t\t\n\t\tSet<OnmsIpInterface> ipInterfaces = new LinkedHashSet<OnmsIpInterface>(j);\n\t\tInetAddress address = InetAddress.getByName(\"10.0.1.1\");\n\t\tOnmsIpInterface onmsIf = new OnmsIpInterface(address, node);\n\t\tonmsIf.setSnmpInterface(snmpInterface);\n\t\tonmsIf.setId(1);\n\t\tonmsIf.setIfIndex(1);\n\t\tonmsIf.setIpHostName(\"p-brane\");\n\t\tonmsIf.setIsSnmpPrimary(PrimaryType.PRIMARY);\n\t\t\n\t\tipInterfaces.add(onmsIf);\n\t\t\n\t\tnode.setIpInterfaces(ipInterfaces);\n\n\t\tfor (SyslogNorthbounder nbi : nbis) {\n\n\t\t\tfor (int i = 1; i <=j; ++i) {\n\t\t\t\tOnmsAlarm onmsAlarm = new OnmsAlarm();\n\t\t\t\tonmsAlarm.setId(i);\n\t\t\t\tonmsAlarm.setUei(\"uei.opennms.org/test/syslogNorthBounder\");\n\t\t\t\tonmsAlarm.setNode(node);\n\t\t\t\tonmsAlarm.setSeverityId(i);\n\t\t\t\tonmsAlarm.setIpAddr(InetAddress.getByName(\"127.0.0.1\"));\n\t\t\t\tonmsAlarm.setCounter(i);\n\t\t\t\tonmsAlarm.setLogMsg(\"Node Down\");\n\t\t\t\tonmsAlarm.setX733AlarmType(NorthboundAlarm.x733AlarmType.get(i).name());\n\t\t\t\tonmsAlarm.setX733ProbableCause(NorthboundAlarm.x733ProbableCause.get(i).getId());\n\t\t\t\tString eventparms = \"foreignSource=fabric(string,text);foreignId=space-0256012012000038(string,text);reason=Aborting node scan : Agent timed out while scanning the system table(string,text);\" +\n\t\t\t\t\t\t\".1.3.6.1.4.1.2636.3.18.1.7.1.2.732=207795895(TimeTicks,text)\";\n\t\t\t\tonmsAlarm.setEventParms(eventparms );\n\t\t\t\tNorthboundAlarm a = new NorthboundAlarm(onmsAlarm);\n\n\t\t\t\tAssert.assertFalse(nbi.accepts(a));\n\t\t\t\tonmsAlarm.setUei(\"uei.opennms.org/nodes/nodeDown\");\n\t\t\t\ta = new NorthboundAlarm(onmsAlarm);\n\t\t\t\tAssert.assertTrue(nbi.accepts(a));\n\n\t\t\t\talarms.add(a);\n\t\t\t}\n\t\t\tnbi.forwardAlarms(alarms);\n\t\t}\t\t\n\n\t\tThread.sleep(100);\n\n\t\tBufferedReader r = new BufferedReader(new StringReader(m_logStream.readStream()));\n\n\t\tList<String> messages = new LinkedList<String>();\n\t\tString line = null;\n\n\t\twhile ((line = r.readLine()) != null) {\n\t\t\tmessages.add(line);\n\t\t\tThread.sleep(10);\n\t\t}\n\n\t\tAssert.assertTrue(\"Log messages sent: 7, Log messages received: \" + messages.size(), 7 == messages.size());\n\t\t\n\t\tfor (String message : messages) {\n\t\t\tSystem.out.println(message);\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\tfor (String message : messages) {\n\t\t\tif (i == 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 1:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_INFO.\", message.contains(\"INFO\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_NOTICE.\", message.contains(\"NOTICE\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_ERROR.\", message.contains(\"ERROR\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tAssert.assertTrue(\"Alarm (OnmsSeverity: \"+OnmsSeverity.get(i)+\") = LEVEL_CRITICAL.\", message.contains(\"CRITICAL\"));\n\t\t\t\tAssert.assertTrue(message.contains(\"NODE:p-brane\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyslogNorthbounderConfig getConfig() {\n    \t\n    \tif (m_config == null) {\n//    \t\tLogUtils.errorf(this, \"Syslog Northbounder configuration is not set.\", null);\n    \t\tthrow new IllegalStateException(\"Syslog Northbound configuration not set.\");\n    \t}\n        return m_config;\n    }","id":104819,"modified_method":"public SyslogNorthbounderConfig getConfig() {\n    \t\n    \tif (m_config == null) {\n    \t\tLogUtils.errorf(this, \"Syslog Northbounder configuration is not set.\");\n    \t\tthrow new IllegalStateException(\"Syslog Northbound configuration not set.\");\n    \t}\n        return m_config;\n    }","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tif (m_config == null) {\n\t\t\t\n\t\t\tLogUtils.infof(this, \"Syslog Northbounder is currently disabled, rejecting alarm.\");\n\t\t\t\n\t\t\tString msg = \"Syslog forwarding configuration is not initialized.\";\n\t\t\tIllegalStateException e = new IllegalStateException(msg);\n\t\t\tLogUtils.errorf(this, e, msg);\n\t\t\tthrow e;\n\t\t}\n\t\t\n\t\t\n\t\tcreateNorthboundInstances();\n\t\tsetNaglesDelay(m_config.getNaglesDelay());\n\t\tsetMaxBatchSize(m_config.getBatchSize());\n\t\tsetMaxPreservedAlarms(m_config.getQueueSize());\n\t}","id":104820,"modified_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tif (m_config == null) {\n\t\t\t\n\t\t\tLogUtils.infof(this, \"Syslog Northbounder is currently disabled, rejecting alarm.\");\n\t\t\t\n\t\t\tString msg = \"Syslog forwarding configuration is not initialized.\";\n\t\t\tIllegalStateException e = new IllegalStateException(msg);\n\t\t\tLogUtils.errorf(this, e, msg);\n\t\t\tthrow e;\n\t\t}\n\t\t\n\t\tcreateNorthboundInstance();\n\t\tsetNaglesDelay(m_config.getNaglesDelay());\n\t\tsetMaxBatchSize(m_config.getBatchSize());\n\t\tsetMaxPreservedAlarms(m_config.getQueueSize());\n\t}","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyslogNorthbounder(SyslogNorthbounderConfig config) {\n    \tsuper(\"SyslogNorthbounder\");\n    \tm_config = config;\n    }","id":104821,"modified_method":"public SyslogNorthbounder(SyslogNorthbounderConfig config, SyslogDestination destination) {\n\t\tsuper(NBI_NAME+\":\"+destination);\n\t\tm_config = config;\n\t\tm_destination = destination;\n\t}","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setConfig(SyslogNorthbounderConfig config) {\n    \tif (config == null) {\n    \t\tthrow new IllegalStateException(\"Configuration cannot be set to null!\");\n    \t}\n    \t\n\t\tsynchronized (m_configLock) {\n\t\t\tm_config = config;\n    \t\tSyslog.shutdown();\n    \t\tSyslog.initialize();\n    \t\tcreateNorthboundInstances();\n\t\t}\n    }","id":104822,"modified_method":"public void setConfig(final SyslogNorthbounderConfig config) {\n    \t\n    \tif (config == null) {\n    \t\tString string = \"Syslog Northbounder configuration cannot be set null\";\n\t\t\tLogUtils.errorf(this, string);\n    \t\tthrow new IllegalStateException(string);\n    \t}\n    \t\n    }","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is here, for now, until it can be properly wired and proper configuration can be created.\n     * This allows generic 127.0.0.1:UDP/514 to work with OpenNMS having no configuration.  This is\n     * trickery in its finest hour.\n     */\n    private void createNorthboundInstances() throws SyslogRuntimeException {\n    \t\n    \tLogUtils.infof(this, \"Creating Syslog Northbound Instances...\");\n    \t\n    \tLogUtils.debugf(this, \"Acquiring configuration lock...\");\n    \tsynchronized (m_configLock) {\n    \t\t\n    \t\tLogUtils.debugf(this, \"Lock acquired.\");\n\t\t\t\n\t\t\tList<SyslogDestination> destinations = m_config.getDestinations();\n\t\t\tfor (SyslogDestination dest : destinations) {\n\n\t\t\t\tString instName = dest.getName();\n\t\t\t\tint facility = convertFacility(dest.getFacility());\n\t\t\t\tSyslogProtocol protocol = dest.getProtocol();\n\t\t\t\tSyslogConfigIF instanceConfiguration = createConfig(dest, protocol, facility);\n\t\t\t\tinstanceConfiguration.setIdent(\"OpenNMS\");\n\t\t\t\tinstanceConfiguration.setCharSet(dest.getCharSet());\n\t\t\t\tinstanceConfiguration.setMaxMessageLength(dest.getMaxMessageLength());\n\t\t\t\tinstanceConfiguration.setSendLocalName(dest.isSendLocalName());\n\t\t\t\tinstanceConfiguration.setSendLocalTimestamp(dest.isSendLocalTime());\n\t\t\t\tinstanceConfiguration.setTruncateMessage(dest.isTruncateMessage());\n\t\t\t\tinstanceConfiguration.setUseStructuredData(SyslogConstants.USE_STRUCTURED_DATA_DEFAULT);\n\n\t\t\t\tLogUtils.debugf(this, \"Creating northbound syslog instance: %s\", instName);\n\t\t\t\ttry {\n\t\t\t\t\tSyslog.createInstance(instName, instanceConfiguration);\n\t\t\t\t} catch (SyslogRuntimeException e) {\n\t\t\t\t\tString msg = \"Could not create northbound instance, %s\";\n\t\t\t\t\tLogUtils.errorf(this, e, msg, instName);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n    \t\n\t}","id":104823,"modified_method":"/**\n     * This is here, for now, until it can be properly wired and proper configuration can be created.\n     * This allows generic 127.0.0.1:UDP/514 to work with OpenNMS having no configuration.  This is\n     * trickery in its finest hour.\n     */\n    private void createNorthboundInstance() throws SyslogRuntimeException {\n    \t\n    \tLogUtils.infof(this, \"Creating Syslog Northbound Instance:%s\", m_destination.getName());\n    \t\n    \tString instName = m_destination.getName();\n    \tint facility = convertFacility(m_destination.getFacility());\n    \tSyslogProtocol protocol = m_destination.getProtocol();\n    \tSyslogConfigIF instanceConfiguration = createConfig(m_destination, protocol, facility);\n    \tinstanceConfiguration.setIdent(\"OpenNMS\");\n    \tinstanceConfiguration.setCharSet(m_destination.getCharSet());\n    \tinstanceConfiguration.setMaxMessageLength(m_destination.getMaxMessageLength());\n    \tinstanceConfiguration.setSendLocalName(m_destination.isSendLocalName());\n    \tinstanceConfiguration.setSendLocalTimestamp(m_destination.isSendLocalTime());\n    \tinstanceConfiguration.setTruncateMessage(m_destination.isTruncateMessage());\n    \tinstanceConfiguration.setUseStructuredData(SyslogConstants.USE_STRUCTURED_DATA_DEFAULT);\n\n    \ttry {\n    \t\tSyslog.createInstance(instName, instanceConfiguration);\n    \t} catch (SyslogRuntimeException e) {\n    \t\tString msg = \"Could not create northbound instance, %s\";\n    \t\tLogUtils.errorf(this, e, msg, instName);\n    \t\tthrow e;\n    \t}\n\n\t}","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Each implementation of the AbstractNorthbounder has a nice queue (Nagle's algorithmic) and the worker\n\t * thread that processes the queue calls this method to send alarms to the northern NMS.\n\t * \n\t */\n    @Override\n    public void forwardAlarms(List<NorthboundAlarm> alarms) throws NorthbounderException {\n        \n        List<SyslogDestination> dests = getDestinations();\n        \n        if (dests == null) {\n        \tString errorMsg = \"No Syslog destinations are defined.\";\n\t\t\tIllegalStateException e = new IllegalStateException(errorMsg);\n        \tLogUtils.errorf(this, e, errorMsg);\n\t\t\tthrow e;\n        }\n        \n        if (alarms == null) {\n        \tString errorMsg = \"No alarms in alarms list for syslog forwarding.\";\n\t\t\tIllegalStateException e = new IllegalStateException(errorMsg);\n        \tLogUtils.errorf(this, e, errorMsg);\n\t\t\tthrow e;\n        }\n        \n        LogUtils.infof(this, \"Forwarding %d alarms to %d destinations...\", alarms.size(), dests.size());\n\n    \tMap<Integer, Map<String, String>> alarmMappings = new HashMap<Integer, Map<String, String>>();    \t\n        \n        for (SyslogDestination dest : dests) {\n        \t\n        \tSyslogIF instance;\n\t\t\ttry {\n\t\t\t\tinstance = Syslog.getInstance(dest.getName());\n\t\t\t} catch (SyslogRuntimeException e) {\n\t\t\t\tLogUtils.errorf(this, e, \"Could not find Syslog instance for destination: %s.\", dest.getName());\n\t\t\t\tcontinue;\n\t\t\t}\n        \t\n        \tLogUtils.debugf(this, \"Forwarding alarms to destination %s.\", dest.getName());\n        \t\n        \t/*\n        \t * Iterate over the list of alarms to be forwarded N.\n        \t */\n        \tfor (NorthboundAlarm alarm : alarms) {\n        \t\t\n        \t\tInteger count = alarm.getCount();\n\t\t\t\tif (count > 1 && dest.isFirstOccurrenceOnly()) {\n        \t\t\tLogUtils.debugf(this, \"Destination %s is configured for new alarm instances only.  Alarm has count of %d.\", dest.getName(), count);\n        \t\t\tcontinue;\n        \t\t}\n\n        \t\tLogUtils.debugf(this, \"Creating formatted log message for alarm: %d.\", alarm.getId());\n        \t\t\n        \t\tMap<String, String> mapping = null;\n        \t\t\n        \t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tString syslogMessage;\n\t\t\t\tint level;\n\t\t\t\ttry {\n\t\t\t\t\tif (alarmMappings != null) {\n\t\t\t\t\t\tmapping = alarmMappings.get(alarm.getId());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (mapping == null) {\n\t\t\t\t\t\tmapping = createMapping(alarmMappings, alarm);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tLogUtils.debugf(this, \"Making substitutions for tokens in message format for alarm: %d.\", alarm.getId());\n\t\t\t\t\tsyslogMessage = PropertiesUtils.substitute(m_config.getMessageFormat(), mapping);\n\n\t\t\t\t\tLogUtils.debugf(this, \"Determining LOG_LEVEL for alarm: %d\", alarm.getId());\n\t\t\t\t\tlevel = determineLogLevel(alarm.getSeverity());\n\t        \t\t//Send the Syslog message...\n\t\t\t\t\tLogUtils.debugf(this, \"Forwarding alarm: %d via syslog to destination: %s\", alarm.getId(), dest.getName());\n\t\t\t\t\tinstance.log(level, syslogMessage);\n\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\tLogUtils.errorf(this, e1, \"Caught exception sending to destination: %s\", dest.getName());\n\t\t\t\t}\n\n        \t}\n        }\n\n    }","id":104824,"modified_method":"/**\n\t * Each implementation of the AbstractNorthbounder has a nice queue (Nagle's algorithmic) and the worker\n\t * thread that processes the queue calls this method to send alarms to the northern NMS.\n\t * \n\t */\n    @Override\n    public void forwardAlarms(List<NorthboundAlarm> alarms) throws NorthbounderException {\n        \n        if (alarms == null) {\n        \tString errorMsg = \"No alarms in alarms list for syslog forwarding.\";\n\t\t\tIllegalStateException e = new IllegalStateException(errorMsg);\n        \tLogUtils.errorf(this, e, errorMsg);\n\t\t\tthrow e;\n        }\n        \n        LogUtils.infof(this, \"Forwarding %d alarms to destination:\"+m_destination.getName(), alarms.size());\n\n    \tMap<Integer, Map<String, String>> alarmMappings = new HashMap<Integer, Map<String, String>>();    \t\n        \n    \tSyslogIF instance;\n    \ttry {\n    \t\tinstance = Syslog.getInstance(m_destination.getName());\n    \t} catch (SyslogRuntimeException e) {\n    \t\tLogUtils.errorf(this, e, \"Could not find Syslog instance for destination: %s.\", m_destination.getName());\n    \t\tthrow e;\n    \t}\n\n    \t/*\n    \t * Iterate over the list of alarms to be forwarded N.\n    \t */\n    \tfor (NorthboundAlarm alarm : alarms) {\n\n    \t\tInteger count = alarm.getCount();\n    \t\tif (count > 1 && m_destination.isFirstOccurrenceOnly()) {\n    \t\t\tLogUtils.debugf(this, \"Destination %s is configured for new alarm instances only.  Alarm has count of %d.\", m_destination.getName(), count);\n    \t\t\tcontinue;\n    \t\t}\n\n    \t\tLogUtils.debugf(this, \"Creating formatted log message for alarm: %d.\", alarm.getId());\n\n    \t\tMap<String, String> mapping = null;\n\n    \t\tString syslogMessage;\n    \t\tint level;\n    \t\ttry {\n    \t\t\tif (alarmMappings != null) {\n    \t\t\t\tmapping = alarmMappings.get(alarm.getId());\n    \t\t\t}\n\n    \t\t\tif (mapping == null) {\n    \t\t\t\tmapping = createMapping(alarmMappings, alarm);\n    \t\t\t}\n\n    \t\t\tLogUtils.debugf(this, \"Making substitutions for tokens in message format for alarm: %d.\", alarm.getId());\n    \t\t\tsyslogMessage = PropertiesUtils.substitute(m_config.getMessageFormat(), mapping);\n\n    \t\t\tLogUtils.debugf(this, \"Determining LOG_LEVEL for alarm: %d\", alarm.getId());\n    \t\t\tlevel = determineLogLevel(alarm.getSeverity());\n    \t\t\t\n    \t\t\tLogUtils.debugf(this, \"Forwarding alarm: %d via syslog to destination: %s\", alarm.getId(), m_destination.getName());\n    \t\t\tinstance.log(level, syslogMessage);\n    \t\t\t\n    \t\t} catch (Exception e1) {\n    \t\t\tLogUtils.errorf(this, e1, \"Caught exception sending to destination: %s\", m_destination.getName());\n    \t\t}\n    \t}\n    }","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tAssert.notNull(m_nodeDao);\n\t\tAssert.notNull(m_configDao);\n\t\tAssert.notNull(m_serviceRegistry);\n\t\t\n\t\tSyslogNorthbounderConfig config = m_configDao.getConfig();\n\n\t\tSyslogNorthbounder northbounder = new SyslogNorthbounder(config);\n\t\tnorthbounder.setNodeDao(m_nodeDao);\n\t\t\n\t\tnorthbounder.afterPropertiesSet();\n\t\t\n\t\tm_registration = m_serviceRegistry.register(northbounder, Northbounder.class);\n\t\t\n\n\t}","id":104825,"modified_method":"@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t\n\t\tAssert.notNull(m_nodeDao);\n\t\tAssert.notNull(m_configDao);\n\t\tAssert.notNull(m_serviceRegistry);\n\t\t\n\t\tSyslogNorthbounderConfig config = m_configDao.getConfig();\n\t\t\n\t\tList<SyslogDestination> destinations = config.getDestinations();\n\t\tfor (SyslogDestination syslogDestination : destinations) {\n\t\t\tSyslogNorthbounder nbi = new SyslogNorthbounder(config, syslogDestination);\n\t\t\tnbi.setNodeDao(m_nodeDao);\n\t\t\tnbi.afterPropertiesSet();\n\t\t\tm_registration = m_serviceRegistry.register(nbi, Northbounder.class);\n\t\t}\n\n\t}","commit_id":"f947010924ce5cff2213bc87032b1a20bd12108e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static String getLine(File sourcePath, String classname, int line) {\n        // find class\n        String classPath = classname.replace('.', '/') + \".java\";\n        File file = new File(sourcePath, classPath);\n        if (!file.exists()) return \"\";\n        try {\n            String lineString = nxTools.line(serverFileUtils.read(file), line);\n            if (lineString == null) return \"@ERROR\";\n            return lineString;\n        } catch (IOException e) {\n            return \"@EXCEPTION: \" + e.getMessage();\n        }\n    }","id":104826,"modified_method":"private static String getLine(File file, int line) {\n        // find class\n        if (!file.exists()) return \"\";\n        try {\n            String lineString = nxTools.line(serverFileUtils.read(file), line);\n            if (lineString == null) return \"@ERROR\";\n            return lineString;\n        } catch (IOException e) {\n            return \"@EXCEPTION: \" + e.getMessage();\n        }\n    }","commit_id":"d0e2830e0138e9f71166ea87e341e912f295d808","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\n\n    \tprop = new serverObjects();\n    \tsb = (plasmaSwitchboard) env;\n    \tStringBuffer buffer = new StringBuffer(1000);\n    \t\n    \tif (post != null && post.containsKey(\"createThreaddump\")) {\n    \t    prop.put(\"dump\", \"1\");\n        \t// Thread dump\n        \tMap<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n        \tDate dt = new Date();\n        \tString versionstring = yacyVersion.combined2prettyVersion(sb.getConfig(\"version\",\"0.1\"));\n        \t\n        \tbuffer.append(\"************* Start Thread Dump \" + dt + \" *******************\").append(\"<br />\");\n            buffer.append(\"<br /> YaCy Version: \" + versionstring + \"<br />\");\n        \tbuffer.append(\"Total Memory = \" + (Runtime.getRuntime().totalMemory())).append(\"<br />\");\n        \tbuffer.append(\"Used&nbsp;&nbsp;Memory = \" + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())).append(\"<br />\");\n        \tbuffer.append(\"Free&nbsp;&nbsp;Memory = \" + (Runtime.getRuntime().freeMemory())).append(\"<br />\");\n        \tbuffer.append(\" --- --- --- --- <br /><br />\");\n        \t\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, Thread.State.BLOCKED);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, Thread.State.RUNNABLE);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, Thread.State.TIMED_WAITING);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, Thread.State.WAITING);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, Thread.State.NEW);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, Thread.State.TERMINATED);\n            \n        \tbuffer.append(\"************* End Thread Dump \" + dt + \" *******************\").append(\"<br />\");       \t\n        \n        \tprop.put(\"dump_content\", buffer.toString());\n    \t} else {\n    \t    prop.put(\"dump\", \"0\");\n    \t}\n    \t\n       \treturn prop;    // return from serverObjects respond()\n    }","id":104827,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\n\n    \tprop = new serverObjects();\n    \tsb = (plasmaSwitchboard) env;\n    \tStringBuffer buffer = new StringBuffer(1000);\n    \t\n    \tif (post != null && post.containsKey(\"createThreaddump\")) {\n    \t    boolean plain = post.get(\"plain\", \"false\").equals(\"true\");\n    \t    int sleep = post.getInt(\"sleep\", 0); // a sleep before creation of a thread dump can be used for profiling\n    \t    if (sleep > 0) try {Thread.sleep(sleep);} catch (InterruptedException e) {}\n    \t    prop.put(\"dump\", \"1\");\n        \t// Thread dump\n        \tMap<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n        \tDate dt = new Date();\n        \tString versionstring = yacyVersion.combined2prettyVersion(sb.getConfig(\"version\",\"0.1\"));\n        \t\n        \tbufferappend(buffer, plain, \"************* Start Thread Dump \" + dt + \" *******************\");\n        \tbufferappend(buffer, plain, \"\");\n        \tbufferappend(buffer, plain, \"YaCy Version: \" + versionstring);\n        \tbufferappend(buffer, plain, \"Total Memory = \" + (Runtime.getRuntime().totalMemory()));\n        \tbufferappend(buffer, plain, \"Used&nbsp;&nbsp;Memory = \" + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));\n        \tbufferappend(buffer, plain, \"Free&nbsp;&nbsp;Memory = \" + (Runtime.getRuntime().freeMemory()));\n        \tbufferappend(buffer, plain, \"\");\n        \tbufferappend(buffer, plain, \"\");\n            \n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, plain, Thread.State.BLOCKED);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, plain, Thread.State.RUNNABLE);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, plain, Thread.State.TIMED_WAITING);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, plain, Thread.State.WAITING);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, plain, Thread.State.NEW);\n        \tappendStackTraces(sb.getRootPath(), buffer, stackTraces, plain, Thread.State.TERMINATED);\n            \n        \tbufferappend(buffer, plain, \"************* End Thread Dump \" + dt + \" *******************\");\n        \n        \tprop.put(\"plain_content\", buffer.toString());\n        \tprop.put(\"plain\", (plain) ? 1 : 0);\n    \t}\n    \t\n       \treturn prop;    // return from serverObjects respond()\n    }","commit_id":"d0e2830e0138e9f71166ea87e341e912f295d808","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void appendStackTraces(File rootPath, StringBuffer buffer, Map<Thread,StackTraceElement[]> stackTraces, Thread.State stateIn) {\n        buffer.append(\"THREADS WITH STATES: \" + stateIn.toString()).append(\"<br />\").append(\"<br />\");\n        File classPath = new File(rootPath, \"source\");\n        \n        for (Thread thread: stackTraces.keySet()) {\n            StackTraceElement[] stackTraceElements = stackTraces.get(thread);\n            StackTraceElement ste;\n            String line;\n            if (stateIn.equals(thread.getState())) {\n                buffer.append(\"Thread= \" + thread.getName() + \" \" + (thread.isDaemon()?\"daemon\":\"\") + \" id=\" + thread.getId() + \" \" + thread.getState().toString()).append(\"<br />\");\n                for (int i = 0; i < stackTraceElements.length; i++) {\n                    ste = stackTraceElements[i];\n                    if (i == 0) {\n                        line = getLine(classPath, ste.getClassName(), ste.getLineNumber());\n                    } else {\n                        line = null;\n                    }\n                    if ((line != null) && (line.length() > 0)) {\n                        buffer.append(\"at \" + htmlTools.encodeUnicode2html(ste.toString(), true)).append(\" [\").append(line).append(\"]<br />\");\n                    } else {\n                        buffer.append(\"at \" + htmlTools.encodeUnicode2html(ste.toString(), true)).append(\"<br />\");\n                    }\n                }\n                buffer.append(\"<br />\");\n            }\n        }\n        buffer.append(\"<br />\");\n    }","id":104828,"modified_method":"private static void appendStackTraces(File rootPath, StringBuffer buffer, Map<Thread,StackTraceElement[]> stackTraces, boolean plain, Thread.State stateIn) {\n        bufferappend(buffer, plain, \"THREADS WITH STATES: \" + stateIn.toString());\n        bufferappend(buffer, plain, \"\");\n        \n        File classPath = new File(rootPath, \"source\");\n  \n        for (Thread thread: stackTraces.keySet()) {\n            StackTraceElement[] stackTraceElements = stackTraces.get(thread);\n            StackTraceElement ste;\n            String line;\n            String tracename = \"\";\n            File classFile;\n            if ((stateIn.equals(thread.getState()))  && (stackTraceElements.length > 0)) {\n                if (plain) {\n                    classFile = getClassFile(classPath, stackTraceElements[stackTraceElements.length - 1].getClassName());\n                    tracename = classFile.getName();\n                    if (tracename.endsWith(\".java\")) tracename = tracename.substring(0, tracename.length() - 5);\n                    if (tracename.length() > 20) tracename = tracename.substring(0, 20);\n                    while (tracename.length() < 20) tracename = tracename + \"_\";\n                    tracename = \"[\" + tracename + \"] \";                \n                }                \n                bufferappend(buffer, plain, tracename + \"Thread= \" + thread.getName() + \" \" + (thread.isDaemon()?\"daemon\":\"\") + \" id=\" + thread.getId() + \" \" + thread.getState().toString());\n                for (int i = 0; i < stackTraceElements.length; i++) {\n                    ste = stackTraceElements[i];\n                    if (i == 0) {\n                        line = getLine(getClassFile(classPath, ste.getClassName()), ste.getLineNumber());\n                    } else {\n                        line = null;\n                    }\n                    if ((line != null) && (line.length() > 0)) {\n                        bufferappend(buffer, plain, tracename + \"at \" + htmlTools.encodeUnicode2html(ste.toString(), true) + \" [\" + line.trim() + \"]\");\n                    } else {\n                        bufferappend(buffer, plain, tracename + \"at \" + htmlTools.encodeUnicode2html(ste.toString(), true));\n                    }\n                }\n                bufferappend(buffer, plain, \"\");\n            }\n        }\n        bufferappend(buffer, plain, \"\");\n    }","commit_id":"d0e2830e0138e9f71166ea87e341e912f295d808","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Retrieves the type for the given destination path.<p>\n     * \n     * @param destination the destination path\n     * \n     * @return the type for the given destination path\n     */\n    private String getType(String destination) {\n\n        if (destination.endsWith(\".jpg\") || destination.endsWith(\".gif\") || destination.endsWith(\".png\")) {\n            return \"image\";\n        }\n        if (destination.endsWith(\".jar\") || destination.endsWith(\".class\")) {\n            return \"binary\";\n        }\n        if (destination.endsWith(\".jsp\")) {\n            return \"jsp\";\n        }\n        if (destination.endsWith(\".properties\")\n            || destination.endsWith(\".xsd\")\n            || destination.endsWith(\".txt\")\n            || destination.endsWith(\".java\")\n            || destination.endsWith(\".html\")\n            || destination.endsWith(\".js\")\n            || destination.endsWith(\".xml\")\n            || destination.endsWith(\".rpc\")\n            || destination.endsWith(\".css\")) {\n            return \"plain\";\n        }\n        return \"folder\";\n    }","id":104829,"modified_method":"/**\n     * Retrieves the type for the given destination path.<p>\n     * \n     * @param destination the destination path\n     * \n     * @return the type for the given destination path\n     */\n    private String getType(String destination) {\n\n        if (destination.endsWith(\".jpg\") || destination.endsWith(\".gif\") || destination.endsWith(\".png\")) {\n            return \"image\";\n        }\n        // use binary type for GWT specific files (*.cache.html, hosted.html, *.nocache.js, *.rpc) to avoid their content being indexed or editable\n        if (destination.endsWith(\".jar\")\n            || destination.endsWith(\".class\")\n            || destination.endsWith(\".cache.html\")\n            || destination.endsWith(\"hosted.html\")\n            || destination.endsWith(\".nocache.js\")\n            || destination.endsWith(\".rpc\")) {\n            return \"binary\";\n        }\n        if (destination.endsWith(\".jsp\")) {\n            return \"jsp\";\n        }\n        if (destination.endsWith(\".properties\")\n            || destination.endsWith(\".xsd\")\n            || destination.endsWith(\".txt\")\n            || destination.endsWith(\".java\")\n            || destination.endsWith(\".html\")\n            || destination.endsWith(\".js\")\n            || destination.endsWith(\".xml\")\n            || destination.endsWith(\".css\")) {\n            return \"plain\";\n        }\n        return \"folder\";\n    }","commit_id":"73d8efde70ac85a1ef2acd201d00b656c95cd110","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Retrieves the type for the given destination path.<p>\n     * \n     * @param destination the destination path\n     * \n     * @return the type for the given destination path\n     */\n    private String getType(String destination) {\n\n        if (destination.endsWith(\".jpg\") || destination.endsWith(\".gif\") || destination.endsWith(\".png\")) {\n            return \"image\";\n        }\n        if (destination.endsWith(\".jar\") || destination.endsWith(\".class\")) {\n            return \"binary\";\n        }\n        if (destination.endsWith(\".jsp\")) {\n            return \"jsp\";\n        }\n        if (destination.endsWith(\".properties\")\n            || destination.endsWith(\".xsd\")\n            || destination.endsWith(\".txt\")\n            || destination.endsWith(\".java\")\n            || destination.endsWith(\".html\")\n            || destination.endsWith(\".js\")\n            || destination.endsWith(\".xml\")\n            || destination.endsWith(\".rpc\")\n            || destination.endsWith(\".css\")) {\n            return \"plain\";\n        }\n        return \"folder\";\n    }","id":104830,"modified_method":"/**\n     * Retrieves the type for the given destination path.<p>\n     * \n     * @param destination the destination path\n     * \n     * @return the type for the given destination path\n     */\n    private String getType(String destination) {\n\n        if (destination.endsWith(\".jpg\") || destination.endsWith(\".gif\") || destination.endsWith(\".png\")) {\n            return \"image\";\n        }\n        // use binary type for GWT specific files (*.cache.html, hosted.html, *.nocache.js, *.rpc) to avoid their content being indexed or editable\n        if (destination.endsWith(\".jar\")\n            || destination.endsWith(\".class\")\n            || destination.endsWith(\".cache.html\")\n            || destination.endsWith(\"hosted.html\")\n            || destination.endsWith(\".nocache.js\")\n            || destination.endsWith(\".rpc\")) {\n            return \"binary\";\n        }\n        if (destination.endsWith(\".jsp\")) {\n            return \"jsp\";\n        }\n        if (destination.endsWith(\".properties\")\n            || destination.endsWith(\".xsd\")\n            || destination.endsWith(\".txt\")\n            || destination.endsWith(\".java\")\n            || destination.endsWith(\".html\")\n            || destination.endsWith(\".js\")\n            || destination.endsWith(\".xml\")\n            || destination.endsWith(\".css\")) {\n            return \"plain\";\n        }\n        return \"folder\";\n    }","commit_id":"7199c23efb68a8dc8e9510e455e8ce5c9ca5bbd5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static boolean isWellEndedString(PsiElement element) {\n    final String text = element.getText();\n\n    if (!text.endsWith(\"'''\") && !text.endsWith(\"\\\"\\\"\\\"\") && !text.endsWith(\"/\") && !text.endsWith(\"/$\")) return false;\n\n\n    final IElementType type = element.getNode().getElementType();\n    if (TokenSets.STRING_LITERAL_SET.contains(type)) return true;\n\n    final PsiElement lastChild = element.getLastChild();\n    if (lastChild == null) return false;\n\n    final IElementType lastType = lastChild.getNode().getElementType();\n    if (type == GroovyElementTypes.GSTRING) return lastType == mGSTRING_END;\n    if (type == GroovyElementTypes.REGEX) return lastType == mREGEX_END || lastType == mDOLLAR_SLASH_REGEX_END;\n\n    return false;\n  }","id":104831,"modified_method":"public static boolean isWellEndedString(PsiElement element) {\n    final String text = element.getText();\n\n    if (!(text.endsWith(\"'\") ||\n          text.endsWith(\"\\\"\") ||\n          text.endsWith(\"'''\") ||\n          text.endsWith(\"\\\"\\\"\\\"\") ||\n          text.endsWith(\"/\") ||\n          text.endsWith(\"/$\"))) {\n      return false;\n    }\n\n\n    final IElementType type = element.getNode().getElementType();\n    if (TokenSets.STRING_LITERAL_SET.contains(type)) return true;\n\n    final PsiElement lastChild = element.getLastChild();\n    if (lastChild == null) return false;\n\n    final IElementType lastType = lastChild.getNode().getElementType();\n    if (type == GroovyElementTypes.GSTRING) return lastType == mGSTRING_END;\n    if (type == GroovyElementTypes.REGEX) return lastType == mREGEX_END || lastType == mDOLLAR_SLASH_REGEX_END;\n\n    return false;\n  }","commit_id":"c3c496f4a66a87428ac6df814991b6a7238f31dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPlaceholderText(@NotNull ASTNode node) {\n    final IElementType elemType = node.getElementType();\n    if (BLOCK_SET.contains(elemType) || elemType == CLOSABLE_BLOCK) {\n      return \"{...}\";\n    }\n    if (elemType.equals(mML_COMMENT)) {\n      return \"/*...*/\";\n    }\n    if (elemType.equals(GROOVY_DOC_COMMENT)) {\n      return \"/**...*/\";\n    }\n    if (IMPORT_STATEMENT.equals(elemType)) {\n      return \"...\";\n    }\n    if (isMultiLineStringLiteral(node)) {\n      final String quote = GrStringUtil.getStartQuote(node.getText());\n      return quote +\"...\"+ quote;\n    }\n    return null;\n  }","id":104832,"modified_method":"public String getPlaceholderText(@NotNull ASTNode node) {\n    final IElementType elemType = node.getElementType();\n    if (BLOCK_SET.contains(elemType) || elemType == CLOSABLE_BLOCK) {\n      return \"{...}\";\n    }\n    if (elemType.equals(mML_COMMENT)) {\n      return \"/*...*/\";\n    }\n    if (elemType.equals(GROOVY_DOC_COMMENT)) {\n      return \"/**...*/\";\n    }\n    if (IMPORT_STATEMENT.equals(elemType)) {\n      return \"...\";\n    }\n    if (isMultiLineStringLiteral(node)) {\n      final String start_quote = GrStringUtil.getStartQuote(node.getText());\n      final String end_quote = GrStringUtil.getEndQuote(node.getText());\n      return start_quote + \"...\" + end_quote;\n    }\n    return null;\n  }","commit_id":"5bdca08d4e0569805f434768987ff22b24c5be38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWellEndedString(PsiElement element) {\n    final String text = element.getText();\n    return text.endsWith(\"'''\") || text.endsWith(\"\\\"\\\"\\\"\");\n  }","id":104833,"modified_method":"private static boolean isWellEndedString(PsiElement element) {\n    final String text = element.getText();\n\n    if (!text.endsWith(\"'''\") && !text.endsWith(\"\\\"\\\"\\\"\") && !text.endsWith(\"/\") && !text.endsWith(\"/$\")) return false;\n\n\n    final IElementType type = element.getNode().getElementType();\n    if (TokenSets.STRING_LITERAL_SET.contains(type)) return true;\n\n    final PsiElement lastChild = element.getLastChild();\n    if (lastChild == null) return false;\n\n    final IElementType lastType = lastChild.getNode().getElementType();\n    if (type == GSTRING) return lastType == mGSTRING_END;\n    if (type == REGEX) return lastType == mREGEX_END || lastChild == mDOLLAR_SLASH_REGEX_END;\n\n    return false;\n  }","commit_id":"5bdca08d4e0569805f434768987ff22b24c5be38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isMultiLineStringLiteral(ASTNode node) {\n    return (TokenSets.STRING_LITERAL_SET.contains(node.getElementType()) || node.getElementType().equals(GSTRING)) &&\n     isMultiline(node.getPsi()) &&\n     isWellEndedString(node.getPsi());\n  }","id":104834,"modified_method":"private static boolean isMultiLineStringLiteral(ASTNode node) {\n    return (TokenSets.STRING_LITERAL_SET.contains(node.getElementType()) ||\n            node.getElementType().equals(GSTRING) ||\n            node.getElementType().equals(REGEX)) &&\n           isMultiline(node.getPsi()) &&\n           isWellEndedString(node.getPsi());\n  }","commit_id":"5bdca08d4e0569805f434768987ff22b24c5be38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addFoldingForStrings(List<FoldingDescriptor> descriptors, ASTNode node) {\n    if (!isMultiLineStringLiteral(node)) return;\n\n    if (!node.getElementType().equals(GSTRING)) {\n      descriptors.add(new FoldingDescriptor(node, node.getTextRange()));\n      return;\n    }\n\n    final GrString grString = (GrString)node.getPsi();\n    if (grString == null) return;\n\n    final GrStringInjection[] injections = grString.getInjections();\n    if (injections.length == 0) {\n      descriptors.add(new FoldingDescriptor(node, node.getTextRange()));\n      return;\n    }\n    final String quote = GrStringUtil.getStartQuote(node.getText());\n    final FoldingGroup group = FoldingGroup.newGroup(\"GString\");\n    final TextRange nodeRange = node.getTextRange();\n    int startOffset = nodeRange.getStartOffset();\n\n\n    GrStringInjection injection = injections[0];\n    boolean hasClosableBlock = injection.getClosableBlock() != null;\n    final String holderText = quote + \"...\" + (hasClosableBlock ? \"${\" : \"$\");\n    TextRange injectionRange = injection.getTextRange();\n    descriptors.add(new FoldingDescriptor(node, new TextRange(startOffset, injectionRange.getStartOffset() + (hasClosableBlock ? 2 : 1)), group) {\n      @Override\n      public String getPlaceholderText() {\n        return holderText;\n      }\n    });\n    startOffset = injectionRange.getEndOffset() - (hasClosableBlock ? 1 : 0);\n    for (int i = 1; i < injections.length; i++) {\n      injection = injections[i];\n      boolean hasClosableBlockNew = injection.getClosableBlock() != null;\n      injectionRange = injection.getTextRange();\n      final String text = (hasClosableBlock ? \"}\" : \"\") + \"...\" + (hasClosableBlockNew ? \"${\" : \"$\");\n      final int endOffset = injectionRange.getStartOffset() + (hasClosableBlockNew ? 2 : 1);\n      if (endOffset - startOffset >= 2) {\n        descriptors.add(new FoldingDescriptor(injection.getNode().getTreePrev(),\n                                              new TextRange(startOffset, endOffset), group) {\n          @Override\n          public String getPlaceholderText() {\n            return text;\n          }\n        });\n      }\n      hasClosableBlock = hasClosableBlockNew;\n      startOffset = injectionRange.getEndOffset() - (hasClosableBlock ? 1 : 0);\n    }\n    final String text = (hasClosableBlock ? \"}\" : \"\") + \"...\" + quote;\n    descriptors.add(new FoldingDescriptor(node.getLastChildNode(), new TextRange(startOffset, nodeRange.getEndOffset()), group) {\n      @Override\n      public String getPlaceholderText() {\n        return text;\n      }\n    });\n  }","id":104835,"modified_method":"private static void addFoldingForStrings(List<FoldingDescriptor> descriptors, ASTNode node) {\n    if (!isMultiLineStringLiteral(node)) return;\n\n    if (!node.getElementType().equals(GSTRING) && !node.getElementType().equals(REGEX)) {\n      descriptors.add(new FoldingDescriptor(node, node.getTextRange()));\n      return;\n    }\n\n    final GrString grString = (GrString)node.getPsi();\n    if (grString == null) return;\n\n    final GrStringInjection[] injections = grString.getInjections();\n    if (injections.length == 0) {\n      descriptors.add(new FoldingDescriptor(node, node.getTextRange()));\n      return;\n    }\n    final String start_quote = GrStringUtil.getStartQuote(node.getText());\n    final String end_quote = GrStringUtil.getEndQuote(node.getText());\n    final FoldingGroup group = FoldingGroup.newGroup(\"GString\");\n    final TextRange nodeRange = node.getTextRange();\n    int startOffset = nodeRange.getStartOffset();\n\n    GrStringInjection injection = injections[0];\n    TextRange injectionRange = injection.getTextRange();\n    if (startOffset + 1 < injectionRange.getStartOffset()) {\n      descriptors.add(new GStringFoldingDescriptor(node, startOffset, injectionRange.getStartOffset(), group, start_quote));\n    }\n\n    final String placeholder = \" \";\n    startOffset = injectionRange.getEndOffset();\n    for (int i = 1; i < injections.length; i++) {\n      injection = injections[i];\n      injectionRange = injection.getTextRange();\n      final int endOffset = injectionRange.getStartOffset();\n      if (endOffset - startOffset >= 2) {\n        descriptors.add(new GStringFoldingDescriptor(injection.getNode().getTreePrev(), startOffset, endOffset, group, placeholder));\n      }\n      startOffset = injectionRange.getEndOffset();\n    }\n    if (startOffset + 1 < nodeRange.getEndOffset()) {\n      descriptors.add(new GStringFoldingDescriptor(node.getLastChildNode(), startOffset, nodeRange.getEndOffset(), group, end_quote));\n    }\n  }","commit_id":"5bdca08d4e0569805f434768987ff22b24c5be38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Get a value source given its configuration. A return value of null indicates that\n     *  no value source could be built. */\n    @Nullable\n    public <VS extends ValuesSource> VS valuesSource(ValuesSourceConfig<VS> config, SearchContext context) throws IOException {\n        assert config.valid() : \"value source config is invalid - must have either a field context or a script or marked as unmapped\";\n\n        final VS vs;\n        if (config.unmapped) {\n            if (config.missing == null) {\n                // otherwise we will have values because of the missing value\n                vs = null;\n            } else if (config.valueSourceType == ValuesSourceType.NUMERIC) {\n                vs = (VS) ValuesSource.Numeric.EMPTY;\n            } else if (config.valueSourceType == ValuesSourceType.GEOPOINT) {\n                vs = (VS) ValuesSource.GeoPoint.EMPTY;\n            } else if (config.valueSourceType == ValuesSourceType.ANY || config.valueSourceType == ValuesSourceType.BYTES) {\n                vs = (VS) ValuesSource.Bytes.EMPTY;\n            } else {\n                throw new SearchParseException(searchContext, \"Can't deal with unmapped ValuesSource type \" + config.valueSourceType, null);\n            }\n        } else {\n            vs = originalValuesSource(config);\n        }\n\n        if (config.missing == null) {\n            return vs;\n        }\n\n        if (vs instanceof ValuesSource.Bytes) {\n            final BytesRef missing = new BytesRef(config.missing.toString());\n            if (vs instanceof ValuesSource.Bytes.WithOrdinals) {\n                return (VS) MissingValues.replaceMissing((ValuesSource.Bytes.WithOrdinals) vs, missing);\n            } else {\n                return (VS) MissingValues.replaceMissing((ValuesSource.Bytes) vs, missing);\n            }\n        } else if (vs instanceof ValuesSource.Numeric) {\n            Number missing = null;\n            if (config.missing instanceof Number) {\n                missing = (Number) config.missing;\n            } else {\n                if (config.fieldContext != null && config.fieldContext.fieldType() != null) {\n                    missing = config.fieldContext.fieldType().docValueFormat(null, DateTimeZone.UTC)\n                            .parseDouble(config.missing.toString(), false, context.nowCallable());\n                } else {\n                    missing = Double.parseDouble(config.missing.toString());\n                }\n            }\n            return (VS) MissingValues.replaceMissing((ValuesSource.Numeric) vs, missing);\n        } else if (vs instanceof ValuesSource.GeoPoint) {\n            // TODO: also support the structured formats of geo points\n            final GeoPoint missing = GeoUtils.parseGeoPoint(config.missing.toString(), new GeoPoint());\n            return (VS) MissingValues.replaceMissing((ValuesSource.GeoPoint) vs, missing);\n        } else {\n            // Should not happen\n            throw new SearchParseException(searchContext, \"Can't apply missing values on a \" + vs.getClass(), null);\n        }\n    }","id":104836,"modified_method":"/** Get a value source given its configuration. A return value of null indicates that\n     *  no value source could be built. */\n    @Nullable\n    public <VS extends ValuesSource> VS valuesSource(ValuesSourceConfig<VS> config, SearchContext context) throws IOException {\n        assert config.valid() : \"value source config is invalid - must have either a field context or a script or marked as unmapped\";\n\n        final VS vs;\n        if (config.unmapped()) {\n            if (config.missing() == null) {\n                // otherwise we will have values because of the missing value\n                vs = null;\n            } else if (config.valueSourceType() == ValuesSourceType.NUMERIC) {\n                vs = (VS) ValuesSource.Numeric.EMPTY;\n            } else if (config.valueSourceType() == ValuesSourceType.GEOPOINT) {\n                vs = (VS) ValuesSource.GeoPoint.EMPTY;\n            } else if (config.valueSourceType() == ValuesSourceType.ANY || config.valueSourceType() == ValuesSourceType.BYTES) {\n                vs = (VS) ValuesSource.Bytes.EMPTY;\n            } else {\n                throw new SearchParseException(searchContext, \"Can't deal with unmapped ValuesSource type \"\n                    + config.valueSourceType(), null);\n            }\n        } else {\n            vs = originalValuesSource(config);\n        }\n\n        if (config.missing() == null) {\n            return vs;\n        }\n\n        if (vs instanceof ValuesSource.Bytes) {\n            final BytesRef missing = new BytesRef(config.missing().toString());\n            if (vs instanceof ValuesSource.Bytes.WithOrdinals) {\n                return (VS) MissingValues.replaceMissing((ValuesSource.Bytes.WithOrdinals) vs, missing);\n            } else {\n                return (VS) MissingValues.replaceMissing((ValuesSource.Bytes) vs, missing);\n            }\n        } else if (vs instanceof ValuesSource.Numeric) {\n            Number missing = null;\n            if (config.missing() instanceof Number) {\n                missing = (Number) config.missing();\n            } else {\n                if (config.fieldContext() != null && config.fieldContext().fieldType() != null) {\n                    missing = config.fieldContext().fieldType().docValueFormat(null, DateTimeZone.UTC)\n                            .parseDouble(config.missing().toString(), false, context.nowCallable());\n                } else {\n                    missing = Double.parseDouble(config.missing().toString());\n                }\n            }\n            return (VS) MissingValues.replaceMissing((ValuesSource.Numeric) vs, missing);\n        } else if (vs instanceof ValuesSource.GeoPoint) {\n            // TODO: also support the structured formats of geo points\n            final GeoPoint missing = GeoUtils.parseGeoPoint(config.missing().toString(), new GeoPoint());\n            return (VS) MissingValues.replaceMissing((ValuesSource.GeoPoint) vs, missing);\n        } else {\n            // Should not happen\n            throw new SearchParseException(searchContext, \"Can't apply missing values on a \" + vs.getClass(), null);\n        }\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ValuesSource bytesField(ValuesSourceConfig<?> config) throws IOException {\n        final IndexFieldData<?> indexFieldData = config.fieldContext.indexFieldData();\n        ValuesSource dataSource;\n        if (indexFieldData instanceof ParentChildIndexFieldData) {\n            dataSource = new ValuesSource.Bytes.WithOrdinals.ParentChild((ParentChildIndexFieldData) indexFieldData);\n        } else if (indexFieldData instanceof IndexOrdinalsFieldData) {\n            dataSource = new ValuesSource.Bytes.WithOrdinals.FieldData((IndexOrdinalsFieldData) indexFieldData);\n        } else {\n            dataSource = new ValuesSource.Bytes.FieldData(indexFieldData);\n        }\n        if (config.script != null) {\n            dataSource = new ValuesSource.WithScript(dataSource, config.script);\n        }\n        return dataSource;\n    }","id":104837,"modified_method":"private ValuesSource bytesField(ValuesSourceConfig<?> config) throws IOException {\n        final IndexFieldData<?> indexFieldData = config.fieldContext().indexFieldData();\n        ValuesSource dataSource;\n        if (indexFieldData instanceof ParentChildIndexFieldData) {\n            dataSource = new ValuesSource.Bytes.WithOrdinals.ParentChild((ParentChildIndexFieldData) indexFieldData);\n        } else if (indexFieldData instanceof IndexOrdinalsFieldData) {\n            dataSource = new ValuesSource.Bytes.WithOrdinals.FieldData((IndexOrdinalsFieldData) indexFieldData);\n        } else {\n            dataSource = new ValuesSource.Bytes.FieldData(indexFieldData);\n        }\n        if (config.script() != null) {\n            dataSource = new ValuesSource.WithScript(dataSource, config.script());\n        }\n        return dataSource;\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ValuesSource.Bytes bytesScript(ValuesSourceConfig<?> config) throws IOException {\n        return new ValuesSource.Bytes.Script(config.script);\n    }","id":104838,"modified_method":"private ValuesSource.Bytes bytesScript(ValuesSourceConfig<?> config) throws IOException {\n        return new ValuesSource.Bytes.Script(config.script());\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ValuesSource.Numeric numericField(ValuesSourceConfig<?> config) throws IOException {\n\n        if (!(config.fieldContext.indexFieldData() instanceof IndexNumericFieldData)) {\n            throw new IllegalArgumentException(\"Expected numeric type on field [\" + config.fieldContext.field() +\n                    \"], but got [\" + config.fieldContext.fieldType().typeName() + \"]\");\n        }\n\n        ValuesSource.Numeric dataSource = new ValuesSource.Numeric.FieldData((IndexNumericFieldData) config.fieldContext.indexFieldData());\n        if (config.script != null) {\n            dataSource = new ValuesSource.Numeric.WithScript(dataSource, config.script);\n        }\n        return dataSource;\n    }","id":104839,"modified_method":"private ValuesSource.Numeric numericField(ValuesSourceConfig<?> config) throws IOException {\n\n        if (!(config.fieldContext().indexFieldData() instanceof IndexNumericFieldData)) {\n            throw new IllegalArgumentException(\"Expected numeric type on field [\" + config.fieldContext().field() +\n                    \"], but got [\" + config.fieldContext().fieldType().typeName() + \"]\");\n        }\n\n        ValuesSource.Numeric dataSource = new ValuesSource.Numeric.FieldData((IndexNumericFieldData)config.fieldContext().indexFieldData());\n        if (config.script() != null) {\n            dataSource = new ValuesSource.Numeric.WithScript(dataSource, config.script());\n        }\n        return dataSource;\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Return the original values source, before we apply `missing`.\n     */\n    private <VS extends ValuesSource> VS originalValuesSource(ValuesSourceConfig<VS> config) throws IOException {\n        if (config.fieldContext == null) {\n            if (config.valueSourceType == ValuesSourceType.NUMERIC) {\n                return (VS) numericScript(config);\n            }\n            if (config.valueSourceType == ValuesSourceType.BYTES) {\n                return (VS) bytesScript(config);\n            }\n            throw new AggregationExecutionException(\"value source of type [\" + config.valueSourceType.name()\n                    + \"] is not supported by scripts\");\n        }\n\n        if (config.valueSourceType == ValuesSourceType.NUMERIC) {\n            return (VS) numericField(config);\n        }\n        if (config.valueSourceType == ValuesSourceType.GEOPOINT) {\n            return (VS) geoPointField(config);\n        }\n        // falling back to bytes values\n        return (VS) bytesField(config);\n    }","id":104840,"modified_method":"/**\n     * Return the original values source, before we apply `missing`.\n     */\n    private <VS extends ValuesSource> VS originalValuesSource(ValuesSourceConfig<VS> config) throws IOException {\n        if (config.fieldContext() == null) {\n            if (config.valueSourceType() == ValuesSourceType.NUMERIC) {\n                return (VS) numericScript(config);\n            }\n            if (config.valueSourceType() == ValuesSourceType.BYTES) {\n                return (VS) bytesScript(config);\n            }\n            throw new AggregationExecutionException(\"value source of type [\" + config.valueSourceType().name()\n                    + \"] is not supported by scripts\");\n        }\n\n        if (config.valueSourceType() == ValuesSourceType.NUMERIC) {\n            return (VS) numericField(config);\n        }\n        if (config.valueSourceType() == ValuesSourceType.GEOPOINT) {\n            return (VS) geoPointField(config);\n        }\n        // falling back to bytes values\n        return (VS) bytesField(config);\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ValuesSource.Numeric numericScript(ValuesSourceConfig<?> config) throws IOException {\n        return new ValuesSource.Numeric.Script(config.script, config.scriptValueType);\n    }","id":104841,"modified_method":"private ValuesSource.Numeric numericScript(ValuesSourceConfig<?> config) throws IOException {\n        return new ValuesSource.Numeric.Script(config.script(), config.scriptValueType());\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ValuesSource.GeoPoint geoPointField(ValuesSourceConfig<?> config) throws IOException {\n\n        if (!(config.fieldContext.indexFieldData() instanceof IndexGeoPointFieldData)) {\n            throw new IllegalArgumentException(\"Expected geo_point type on field [\" + config.fieldContext.field() +\n                    \"], but got [\" + config.fieldContext.fieldType().typeName() + \"]\");\n        }\n\n        return new ValuesSource.GeoPoint.Fielddata((IndexGeoPointFieldData) config.fieldContext.indexFieldData());\n    }","id":104842,"modified_method":"private ValuesSource.GeoPoint geoPointField(ValuesSourceConfig<?> config) throws IOException {\n\n        if (!(config.fieldContext().indexFieldData() instanceof IndexGeoPointFieldData)) {\n            throw new IllegalArgumentException(\"Expected geo_point type on field [\" + config.fieldContext().field() +\n                    \"], but got [\" + config.fieldContext().fieldType().typeName() + \"]\");\n        }\n\n        return new ValuesSource.GeoPoint.Fielddata((IndexGeoPointFieldData) config.fieldContext().indexFieldData());\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ValuesSourceConfig<VS> config(AggregationContext context) {\n\n        ValueType valueType = this.valueType != null ? this.valueType : targetValueType;\n\n        if (field == null) {\n            if (script == null) {\n                @SuppressWarnings(\"unchecked\")\n                ValuesSourceConfig<VS> config = new ValuesSourceConfig(ValuesSourceType.ANY);\n                config.format = resolveFormat(null, valueType);\n                return config;\n            }\n            ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : this.valuesSourceType;\n            if (valuesSourceType == null || valuesSourceType == ValuesSourceType.ANY) {\n                // the specific value source type is undefined, but for scripts,\n                // we need to have a specific value source\n                // type to know how to handle the script values, so we fallback\n                // on Bytes\n                valuesSourceType = ValuesSourceType.BYTES;\n            }\n            ValuesSourceConfig<VS> config = new ValuesSourceConfig<VS>(valuesSourceType);\n            config.missing = missing;\n            config.timeZone = timeZone;\n            config.format = resolveFormat(format, valueType);\n            config.script = createScript(script, context.searchContext());\n            config.scriptValueType = valueType;\n            return config;\n        }\n\n        MappedFieldType fieldType = context.searchContext().smartNameFieldType(field);\n        if (fieldType == null) {\n            ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : this.valuesSourceType;\n            ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(valuesSourceType);\n            config.missing = missing;\n            config.timeZone = timeZone;\n            config.format = resolveFormat(format, valueType);\n            config.unmapped = true;\n            if (valueType != null) {\n                // todo do we really need this for unmapped?\n                config.scriptValueType = valueType;\n            }\n            return config;\n        }\n\n        IndexFieldData<?> indexFieldData = context.searchContext().fieldData().getForField(fieldType);\n\n        ValuesSourceConfig<VS> config;\n        if (valuesSourceType == ValuesSourceType.ANY) {\n            if (indexFieldData instanceof IndexNumericFieldData) {\n                config = new ValuesSourceConfig<>(ValuesSourceType.NUMERIC);\n            } else if (indexFieldData instanceof IndexGeoPointFieldData) {\n                config = new ValuesSourceConfig<>(ValuesSourceType.GEOPOINT);\n            } else {\n                config = new ValuesSourceConfig<>(ValuesSourceType.BYTES);\n            }\n        } else {\n            config = new ValuesSourceConfig(valuesSourceType);\n        }\n\n        config.fieldContext = new FieldContext(field, indexFieldData, fieldType);\n        config.missing = missing;\n        config.timeZone = timeZone;\n        config.script = createScript(script, context.searchContext());\n        config.format = fieldType.docValueFormat(format, timeZone);\n        return config;\n    }","id":104843,"modified_method":"public ValuesSourceConfig<VS> config(AggregationContext context) {\n\n        ValueType valueType = this.valueType != null ? this.valueType : targetValueType;\n\n        if (field == null) {\n            if (script == null) {\n                @SuppressWarnings(\"unchecked\")\n                ValuesSourceConfig<VS> config = new ValuesSourceConfig(ValuesSourceType.ANY);\n                config.format(resolveFormat(null, valueType));\n                return config;\n            }\n            ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : this.valuesSourceType;\n            if (valuesSourceType == null || valuesSourceType == ValuesSourceType.ANY) {\n                // the specific value source type is undefined, but for scripts,\n                // we need to have a specific value source\n                // type to know how to handle the script values, so we fallback\n                // on Bytes\n                valuesSourceType = ValuesSourceType.BYTES;\n            }\n            ValuesSourceConfig<VS> config = new ValuesSourceConfig<VS>(valuesSourceType);\n            config.missing(missing);\n            config.timezone(timeZone);\n            config.format(resolveFormat(format, valueType));\n            config.script(createScript(script, context.searchContext()));\n            config.scriptValueType(valueType);\n            return config;\n        }\n\n        MappedFieldType fieldType = context.searchContext().smartNameFieldType(field);\n        if (fieldType == null) {\n            ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : this.valuesSourceType;\n            ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(valuesSourceType);\n            config.missing(missing);\n            config.timezone(timeZone);\n            config.format(resolveFormat(format, valueType));\n            config.unmapped(true);\n            if (valueType != null) {\n                // todo do we really need this for unmapped?\n                config.scriptValueType(valueType);\n            }\n            return config;\n        }\n\n        IndexFieldData<?> indexFieldData = context.searchContext().fieldData().getForField(fieldType);\n\n        ValuesSourceConfig<VS> config;\n        if (valuesSourceType == ValuesSourceType.ANY) {\n            if (indexFieldData instanceof IndexNumericFieldData) {\n                config = new ValuesSourceConfig<>(ValuesSourceType.NUMERIC);\n            } else if (indexFieldData instanceof IndexGeoPointFieldData) {\n                config = new ValuesSourceConfig<>(ValuesSourceType.GEOPOINT);\n            } else {\n                config = new ValuesSourceConfig<>(ValuesSourceType.BYTES);\n            }\n        } else {\n            config = new ValuesSourceConfig(valuesSourceType);\n        }\n\n        config.fieldContext(new FieldContext(field, indexFieldData, fieldType));\n        config.missing(missing);\n        config.timezone(timeZone);\n        config.script(createScript(script, context.searchContext()));\n        config.format(fieldType.docValueFormat(format, timeZone));\n        return config;\n    }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public DateTimeZone timeZone() {\n        return config.timeZone;\n        }","id":104844,"modified_method":"public DateTimeZone timeZone() {\n        return config.timezone();\n        }","commit_id":"54575e55caf9a7781d95e0d2e5f41d163eac3ce2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void runLayoutListener() {\n\t\tViewTreeObserver vto = view.getViewTreeObserver();\n\t\tvto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onGlobalLayout() {\n\n\t\t\t\tint maxHeight = (int) (getScreenHeight() * menu.getHalfScreenMaxHeightKoef());\n\t\t\t\tint height = view.findViewById(R.id.main_view).getHeight();\n\n\t\t\t\tViewTreeObserver obs = view.getViewTreeObserver();\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n\t\t\t\t\tobs.removeOnGlobalLayoutListener(this);\n\t\t\t\t} else {\n\t\t\t\t\tobs.removeGlobalOnLayoutListener(this);\n\t\t\t\t}\n\n\t\t\t\tif (height > maxHeight) {\n\t\t\t\t\tViewGroup.LayoutParams lp = view.getLayoutParams();\n\t\t\t\t\tlp.height = maxHeight;\n\t\t\t\t\tview.setLayoutParams(lp);\n\t\t\t\t\tview.requestLayout();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":104845,"modified_method":"private void runLayoutListener() {\n\t\tViewTreeObserver vto = view.getViewTreeObserver();\n\t\tvto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onGlobalLayout() {\n\n\t\t\t\tint maxHeight = (int) (getScreenHeight() * menu.getHalfScreenMaxHeightKoef());\n\t\t\t\tint height = view.findViewById(R.id.main_view).getHeight();\n\n\t\t\t\tViewTreeObserver obs = view.getViewTreeObserver();\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n\t\t\t\t\tobs.removeOnGlobalLayoutListener(this);\n\t\t\t\t} else {\n\t\t\t\t\tobs.removeGlobalOnLayoutListener(this);\n\t\t\t\t}\n\n\t\t\t\tif (!menu.isLandscapeLayout() && height > maxHeight) {\n\t\t\t\t\tViewGroup.LayoutParams lp = view.getLayoutParams();\n\t\t\t\t\tlp.height = maxHeight;\n\t\t\t\t\tview.setLayoutParams(lp);\n\t\t\t\t\tview.requestLayout();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"41e6706c9438d43a1adda66224fc2e045dfc1fe6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void buildHeader(View view, MenuObject item, MapActivity mapActivity) {\n\n\t\tIconsCache iconsCache = mapActivity.getMyApplication().getIconsCache();\n\t\tfinal View iconLayout = view.findViewById(R.id.context_menu_icon_layout);\n\t\tfinal ImageView iconView = (ImageView) view.findViewById(R.id.context_menu_icon_view);\n\t\tDrawable icon = item.getLeftIcon();\n\t\tint iconId = item.getLeftIconId();\n\t\tif (icon != null) {\n\t\t\ticonView.setImageDrawable(icon);\n\t\t\ticonLayout.setVisibility(View.VISIBLE);\n\t\t} else if (iconId != 0) {\n\t\t\ticonView.setImageDrawable(iconsCache.getIcon(iconId,\n\t\t\t\t\tmenu.isLight() ? R.color.osmand_orange : R.color.osmand_orange_dark, 0.75f));\n\t\t\ticonLayout.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\ticonLayout.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Text line 1\n\t\tTextView line1 = (TextView) view.findViewById(R.id.context_menu_line1);\n\t\tline1.setText(item.getTitleStr());\n\n\t\t// Text line 2\n\t\tTextView line2 = (TextView) view.findViewById(R.id.context_menu_line2);\n\t\tline2.setText(item.getLocationStr());\n\t\tDrawable slIcon = item.getSecondLineIcon();\n\t\tif (slIcon != null) {\n\t\t\tline2.setCompoundDrawablesWithIntrinsicBounds(slIcon, null, null, null);\n\t\t\tline2.setCompoundDrawablePadding(dpToPx(5f));\n\t\t}\n\t}","id":104846,"modified_method":"private void buildHeader(View view, MenuObject item, MapActivity mapActivity) {\n\n\t\tIconsCache iconsCache = mapActivity.getMyApplication().getIconsCache();\n\t\tfinal View iconLayout = view.findViewById(R.id.context_menu_icon_layout);\n\t\tfinal ImageView iconView = (ImageView) view.findViewById(R.id.context_menu_icon_view);\n\t\tDrawable icon = item.getLeftIcon();\n\t\tint iconId = item.getLeftIconId();\n\t\tif (icon != null) {\n\t\t\ticonView.setImageDrawable(icon);\n\t\t\ticonLayout.setVisibility(View.VISIBLE);\n\t\t} else if (iconId != 0) {\n\t\t\ticonView.setImageDrawable(iconsCache.getIcon(iconId,\n\t\t\t\t\tmenu.isLight() ? R.color.osmand_orange : R.color.osmand_orange_dark, 0.75f));\n\t\t\ticonLayout.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\ticonLayout.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Text line 1\n\t\tTextView line1 = (TextView) view.findViewById(R.id.context_menu_line1);\n\t\tline1.setText(item.getTitleStr());\n\n\t\t// Text line 2\n\t\tTextView line2 = (TextView) view.findViewById(R.id.context_menu_line2);\n\t\tline2.setText(item.getLocationStr());\n\t\tDrawable slIcon = item.getSecondLineIcon();\n\t\tline2.setCompoundDrawablesWithIntrinsicBounds(slIcon, null, null, null);\n\t\tline2.setCompoundDrawablePadding(dpToPx(5f));\n\t}","commit_id":"41e6706c9438d43a1adda66224fc2e045dfc1fe6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updateButtonsAndProgress() {\n\t\t// Title buttons\n\t\tboolean showButtonsContainer = (leftTitleButtonController != null || rightTitleButtonController != null)\n\t\t\t\t&& (titleProgressController == null || !titleProgressController.visible);\n\t\tfinal View titleButtonsContainer = view.findViewById(R.id.title_button_container);\n\t\ttitleButtonsContainer.setVisibility(showButtonsContainer ? View.VISIBLE : View.GONE);\n\n\t\t// Left title button\n\t\tfinal Button leftTitleButton = (Button) view.findViewById(R.id.title_button);\n\t\tfinal TextView titleButtonRightText = (TextView) view.findViewById(R.id.title_button_right_text);\n\t\tif (leftTitleButtonController != null) {\n\t\t\tleftTitleButton.setText(leftTitleButtonController.caption);\n\t\t\tleftTitleButton.setVisibility(leftTitleButtonController.visible ? View.VISIBLE : View.INVISIBLE);\n\n\t\t\tDrawable leftIcon = leftTitleButtonController.getLeftIcon();\n\t\t\tif (leftIcon != null) {\n\t\t\t\tleftTitleButton.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null);\n\t\t\t\tleftTitleButton.setCompoundDrawablePadding(dpToPx(4f));\n\t\t\t}\n\n\t\t\tif (leftTitleButtonController.needRightText) {\n\t\t\t\ttitleButtonRightText.setText(leftTitleButtonController.rightTextCaption);\n\t\t\t\ttitleButtonRightText.setVisibility(View.VISIBLE);\n\t\t\t} else {\n\t\t\t\ttitleButtonRightText.setVisibility(View.GONE);\n\t\t\t}\n\t\t} else {\n\t\t\tleftTitleButton.setVisibility(View.GONE);\n\t\t\ttitleButtonRightText.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Right title button\n\t\tfinal Button rightTitleButton = (Button) view.findViewById(R.id.title_button_right);\n\t\tif (rightTitleButtonController != null) {\n\t\t\trightTitleButton.setText(rightTitleButtonController.caption);\n\t\t\trightTitleButton.setVisibility(rightTitleButtonController.visible ? View.VISIBLE : View.INVISIBLE);\n\n\t\t\tDrawable leftIcon = rightTitleButtonController.getLeftIcon();\n\t\t\tif (leftIcon != null) {\n\t\t\t\trightTitleButton.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null);\n\t\t\t\trightTitleButton.setCompoundDrawablePadding(dpToPx(4f));\n\t\t\t}\n\t\t} else {\n\t\t\trightTitleButton.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Top Right title button\n\t\tfinal Button topRightTitleButton = (Button) view.findViewById(R.id.title_button_top_right);\n\t\tif (topRightTitleButtonController != null) {\n\t\t\ttopRightTitleButton.setText(topRightTitleButtonController.caption);\n\t\t\ttopRightTitleButton.setVisibility(topRightTitleButtonController.visible ? View.VISIBLE : View.INVISIBLE);\n\n\t\t\tDrawable leftIcon = topRightTitleButtonController.getLeftIcon();\n\t\t\tif (leftIcon != null) {\n\t\t\t\ttopRightTitleButton.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null);\n\t\t\t\ttopRightTitleButton.setCompoundDrawablePadding(dpToPx(4f));\n\t\t\t}\n\t\t} else {\n\t\t\ttopRightTitleButton.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Progress bar\n\t\tfinal View titleProgressContainer = view.findViewById(R.id.title_progress_container);\n\t\tif (titleProgressController != null) {\n\t\t\ttitleProgressContainer.setVisibility(titleProgressController.visible ? View.VISIBLE : View.GONE);\n\n\t\t\tfinal ProgressBar progressBar = (ProgressBar) view.findViewById(R.id.progressBar);\n\t\t\tfinal TextView progressTitle = (TextView) view.findViewById(R.id.progressTitle);\n\t\t\tprogressTitle.setText(titleProgressController.caption);\n\t\t\tprogressBar.setIndeterminate(titleProgressController.indeterminate);\n\t\t\tprogressBar.setProgress(titleProgressController.progress);\n\n\t\t\tfinal ImageView progressButton = (ImageView) view.findViewById(R.id.progressButton);\n\t\t\tprogressButton.setVisibility(titleProgressController.buttonVisible ? View.VISIBLE : View.GONE);\n\t\t} else {\n\t\t\ttitleProgressContainer.setVisibility(View.GONE);\n\t\t}\n\t}","id":104847,"modified_method":"private void updateButtonsAndProgress() {\n\t\t// Title buttons\n\t\tboolean showButtonsContainer = (leftTitleButtonController != null || rightTitleButtonController != null)\n\t\t\t\t&& (titleProgressController == null || !titleProgressController.visible);\n\t\tfinal View titleButtonsContainer = view.findViewById(R.id.title_button_container);\n\t\ttitleButtonsContainer.setVisibility(showButtonsContainer ? View.VISIBLE : View.GONE);\n\n\t\t// Left title button\n\t\tfinal Button leftTitleButton = (Button) view.findViewById(R.id.title_button);\n\t\tfinal TextView titleButtonRightText = (TextView) view.findViewById(R.id.title_button_right_text);\n\t\tif (leftTitleButtonController != null) {\n\t\t\tleftTitleButton.setText(leftTitleButtonController.caption);\n\t\t\tleftTitleButton.setVisibility(leftTitleButtonController.visible ? View.VISIBLE : View.INVISIBLE);\n\n\t\t\tDrawable leftIcon = leftTitleButtonController.getLeftIcon();\n\t\t\tif (leftIcon != null) {\n\t\t\t\tleftTitleButton.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null);\n\t\t\t\tleftTitleButton.setCompoundDrawablePadding(dpToPx(4f));\n\t\t\t}\n\n\t\t\tif (leftTitleButtonController.needRightText) {\n\t\t\t\ttitleButtonRightText.setText(leftTitleButtonController.rightTextCaption);\n\t\t\t\ttitleButtonRightText.setVisibility(View.VISIBLE);\n\t\t\t} else {\n\t\t\t\ttitleButtonRightText.setVisibility(View.GONE);\n\t\t\t}\n\t\t} else {\n\t\t\tleftTitleButton.setVisibility(View.GONE);\n\t\t\ttitleButtonRightText.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Right title button\n\t\tfinal Button rightTitleButton = (Button) view.findViewById(R.id.title_button_right);\n\t\tif (rightTitleButtonController != null) {\n\t\t\trightTitleButton.setText(rightTitleButtonController.caption);\n\t\t\trightTitleButton.setVisibility(rightTitleButtonController.visible ? View.VISIBLE : View.INVISIBLE);\n\n\t\t\tDrawable leftIcon = rightTitleButtonController.getLeftIcon();\n\t\t\trightTitleButton.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null);\n\t\t\trightTitleButton.setCompoundDrawablePadding(dpToPx(4f));\n\t\t} else {\n\t\t\trightTitleButton.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Top Right title button\n\t\tfinal Button topRightTitleButton = (Button) view.findViewById(R.id.title_button_top_right);\n\t\tif (topRightTitleButtonController != null) {\n\t\t\ttopRightTitleButton.setText(topRightTitleButtonController.caption);\n\t\t\ttopRightTitleButton.setVisibility(topRightTitleButtonController.visible ? View.VISIBLE : View.INVISIBLE);\n\n\t\t\tDrawable leftIcon = topRightTitleButtonController.getLeftIcon();\n\t\t\ttopRightTitleButton.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null);\n\t\t\ttopRightTitleButton.setCompoundDrawablePadding(dpToPx(4f));\n\t\t} else {\n\t\t\ttopRightTitleButton.setVisibility(View.GONE);\n\t\t}\n\n\t\t// Progress bar\n\t\tfinal View titleProgressContainer = view.findViewById(R.id.title_progress_container);\n\t\tif (titleProgressController != null) {\n\t\t\ttitleProgressContainer.setVisibility(titleProgressController.visible ? View.VISIBLE : View.GONE);\n\n\t\t\tfinal ProgressBar progressBar = (ProgressBar) view.findViewById(R.id.progressBar);\n\t\t\tfinal TextView progressTitle = (TextView) view.findViewById(R.id.progressTitle);\n\t\t\tprogressTitle.setText(titleProgressController.caption);\n\t\t\tprogressBar.setIndeterminate(titleProgressController.indeterminate);\n\t\t\tprogressBar.setProgress(titleProgressController.progress);\n\n\t\t\tfinal ImageView progressButton = (ImageView) view.findViewById(R.id.progressButton);\n\t\t\tprogressButton.setVisibility(titleProgressController.buttonVisible ? View.VISIBLE : View.GONE);\n\t\t} else {\n\t\t\ttitleProgressContainer.setVisibility(View.GONE);\n\t\t}\n\t}","commit_id":"032e764032e1308752a29c7e343ce3de2e8d2313","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Switchboard(final File dataPath, final File appPath, final String initPath, final String configPath) {\n        super(dataPath, appPath, initPath, configPath);\n        sb = this;\n        // check if port is already occupied\n        final int port = getConfigInt(\"port\", 8090);\n        try {\n            if ( TimeoutRequest.ping(Domains.LOCALHOST, port, 500) ) {\n                throw new RuntimeException(\n                    \"a server is already running on the YaCy port \"\n                        + port\n                        + \"; possibly another YaCy process has not terminated yet. Please stop YaCy before running a new instance.\");\n            }\n        } catch ( final ExecutionException e1 ) {\n        }\n\n        MemoryTracker.startSystemProfiling();\n\n        // set loglevel and log\n        setLog(new Log(\"SWITCHBOARD\"));\n        AccessTracker.setDumpFile(new File(\"DATA/LOG/queries.log\"));\n\n        // set default peer name\n        Seed.ANON_PREFIX = getConfig(\"peernameprefix\", \"_anon\");\n\n        // UPnP port mapping\n        if ( getConfigBool(SwitchboardConstants.UPNP_ENABLED, false) ) {\n            InstantBusyThread.oneTimeJob(UPnP.class, \"addPortMapping\", 0);\n        }\n\n        // init TrayIcon if possible\n        this.tray = new Tray(this);\n\n        // remote proxy configuration\n        initRemoteProxy();\n\n        // memory configuration\n        long tableCachingLimit = getConfigLong(\"tableCachingLimit\", 419430400L);\n        if ( MemoryControl.available() > tableCachingLimit ) {\n            this.useTailCache = true;\n        }\n        this.exceed134217727 = getConfigBool(\"exceed134217727\", true);\n        if ( MemoryControl.available() > 1024L * 1024L * 1024L * 2L ) {\n            this.exceed134217727 = true;\n        }\n\n        // load values from configs\n        final File indexPath =\n            getDataPath(SwitchboardConstants.INDEX_PRIMARY_PATH, SwitchboardConstants.INDEX_PATH_DEFAULT);\n        this.log.logConfig(\"Index Primary Path: \" + indexPath.toString());\n        this.listsPath =\n            getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\n        this.log.logConfig(\"Lists Path:     \" + this.listsPath.toString());\n        this.htDocsPath =\n            getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT);\n        this.log.logConfig(\"HTDOCS Path:    \" + this.htDocsPath.toString());\n        this.workPath = getDataPath(SwitchboardConstants.WORK_PATH, SwitchboardConstants.WORK_PATH_DEFAULT);\n        this.workPath.mkdirs();\n        // if default work files exist, copy them (don't overwrite existing!)\n        File defaultWorkPath = new File(\"defaults/data/work\");\n        if (defaultWorkPath.list() != null) {\n            for (String fs : defaultWorkPath.list()) {\n                File wf = new File(this.workPath, fs);\n                if (!wf.exists()) {\n                    try {\n                        Files.copy(new File(defaultWorkPath, fs), wf);\n                    } catch (IOException e) {\n                        Log.logException(e);\n                    }\n                }\n            }\n        }\n        \n        this.log.logConfig(\"Work Path:    \" + this.workPath.toString());\n        this.dictionariesPath =\n            getDataPath(\n                SwitchboardConstants.DICTIONARY_SOURCE_PATH,\n                SwitchboardConstants.DICTIONARY_SOURCE_PATH_DEFAULT);\n        this.log.logConfig(\"Dictionaries Path:\" + this.dictionariesPath.toString());\n\n        // init libraries\n        this.log.logConfig(\"initializing libraries\");\n        new Thread() {\n            @Override\n            public void run() {\n                Thread.currentThread().setName(\"LibraryProvider.initialize\");\n                LibraryProvider.initialize(Switchboard.this.dictionariesPath);\n            }\n        }.start();\n\n        // init global host name cache\n        Domains.init(new File(this.workPath, \"globalhosts.list\"));\n\n        // init sessionid name file\n        final String sessionidNamesFile = getConfig(\"sessionidNamesFile\", \"defaults/sessionid.names\");\n        this.log.logConfig(\"Loading sessionid file \" + sessionidNamesFile);\n        MultiProtocolURI.initSessionIDNames(FileUtils.loadList(new File(getAppPath(), sessionidNamesFile)));\n\n        // init tables\n        this.tables = new WorkTables(this.workPath);\n\n        // set a high maximum cache size to current size; this is adopted later automatically\n        final int wordCacheMaxCount = (int) getConfigLong(SwitchboardConstants.WORDCACHE_MAX_COUNT, 20000);\n        setConfig(SwitchboardConstants.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\n\n        // load the network definition\n        try {\n            overwriteNetworkDefinition();\n        } catch (FileNotFoundException e) {\n            Log.logException(e);\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // start indexing management\n        this.log.logConfig(\"Starting Indexing Management\");\n        final String networkName = getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n        final long fileSizeMax = (OS.isWindows) ? this.getConfigLong(\"filesize.max.win\", Integer.MAX_VALUE) : this.getConfigLong( \"filesize.max.other\", Integer.MAX_VALUE);\n        final int redundancy = (int) this.getConfigLong(\"network.unit.dhtredundancy.senior\", 1);\n        final int partitionExponent = (int) this.getConfigLong(\"network.unit.dht.partitionExponent\", 0);\n        this.networkRoot = new File(new File(indexPath, networkName), \"NETWORK\");\n        this.queuesRoot = new File(new File(indexPath, networkName), \"QUEUES\");\n        this.networkRoot.mkdirs();\n        this.queuesRoot.mkdirs();\n\n        // prepare a solr index profile switch list\n        final File solrCollectionConfigurationInitFile = new File(getAppPath(),  \"defaults/\" + SOLR_COLLECTION_CONFIGURATION_NAME);\n        final File solrCollectionConfigurationWorkFile = new File(getDataPath(), \"DATA/SETTINGS/\" + SOLR_COLLECTION_CONFIGURATION_NAME);\n        final File solrWebgraphConfigurationInitFile   = new File(getAppPath(),  \"defaults/\" + SOLR_WEBGRAPH_CONFIGURATION_NAME);\n        final File solrWebgraphConfigurationWorkFile   = new File(getDataPath(), \"DATA/SETTINGS/\" + SOLR_WEBGRAPH_CONFIGURATION_NAME);\n        CollectionConfiguration solrCollectionConfigurationWork = null;\n        WebgraphConfiguration solrWebgraphConfigurationWork = null;\n\n        // migrate the old Schema file path to a new one\n        final File solrCollectionConfigurationWorkOldFile = new File(getDataPath(), \"DATA/SETTINGS/\" + SOLR_COLLECTION_CONFIGURATION_NAME_OLD);\n        if (solrCollectionConfigurationWorkOldFile.exists() && !solrCollectionConfigurationWorkFile.exists()) solrCollectionConfigurationWorkOldFile.renameTo(solrCollectionConfigurationWorkFile);\n\n        // initialize the collection schema if it does not yet exist\n        if (!solrCollectionConfigurationWorkFile.exists()) try {\n            Files.copy(solrCollectionConfigurationInitFile, solrCollectionConfigurationWorkFile);\n        } catch (IOException e) {Log.logException(e);}\n\n        // lazy definition of schema: do not write empty fields\n        final boolean solrlazy = getConfigBool(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_LAZY, true);\n\n        // define collection schema\n        try {\n            final CollectionConfiguration solrCollectionConfigurationInit = new CollectionConfiguration(solrCollectionConfigurationInitFile, solrlazy);\n            solrCollectionConfigurationWork = new CollectionConfiguration(solrCollectionConfigurationWorkFile, solrlazy);\n            // update the working scheme with the backup scheme. This is necessary to include new features.\n            // new features are always activated by default (if activated in input-backupScheme)\n            solrCollectionConfigurationWork.fill(solrCollectionConfigurationInit, true);\n            // switch on some fields which are necessary for ranking and faceting\n            for (CollectionSchema field: new CollectionSchema[]{\n                    CollectionSchema.host_s, CollectionSchema.load_date_dt,\n                    CollectionSchema.url_file_ext_s, CollectionSchema.last_modified,                      // needed for media search and /date operator\n                    /*YaCySchema.url_paths_sxt,*/ CollectionSchema.host_organization_s,                   // needed to search in the url\n                    /*YaCySchema.inboundlinks_protocol_sxt,*/ CollectionSchema.inboundlinks_urlstub_txt,  // needed for HostBrowser\n                    /*YaCySchema.outboundlinks_protocol_sxt,*/ CollectionSchema.outboundlinks_urlstub_txt // needed to enhance the crawler\n                }) {\n                SchemaConfiguration.Entry entry = solrCollectionConfigurationWork.get(field.name()); entry.setEnable(true); solrCollectionConfigurationWork.put(field.name(), entry);\n            }\n            solrCollectionConfigurationWork.commit();\n        } catch (IOException e) {Log.logException(e);}\n        \n        // initialize the webgraph schema if it does not yet exist\n        if (!solrWebgraphConfigurationWorkFile.exists()) try {\n            Files.copy(solrWebgraphConfigurationInitFile, solrWebgraphConfigurationWorkFile);\n        } catch (IOException e) {Log.logException(e);}\n        \n        // define webgraph schema\n        try {\n            final WebgraphConfiguration solrWebgraphConfigurationInit = new WebgraphConfiguration(solrWebgraphConfigurationInitFile, solrlazy);\n            solrWebgraphConfigurationWork = new WebgraphConfiguration(solrWebgraphConfigurationWorkFile, solrlazy);\n            solrWebgraphConfigurationWork.fill(solrWebgraphConfigurationInit, true);\n            solrWebgraphConfigurationWork.commit();\n        } catch (IOException e) {Log.logException(e);}\n\n        // define boosts\n        Ranking.setMinTokenLen(this.getConfigInt(SwitchboardConstants.SEARCH_RANKING_SOLR_DOUBLEDETECTION_MINLENGTH, 3));\n        Ranking.setQuantRate(this.getConfigFloat(SwitchboardConstants.SEARCH_RANKING_SOLR_DOUBLEDETECTION_QUANTRATE, 0.5f));\n        for (int i = 0; i <= 3; i++) {\n            // must be done every time the boosts change\n            Ranking r = solrCollectionConfigurationWork.getRanking(i);\n            r.setName(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTNAME_ + i, \"_dummy\" + i));\n            r.updateBoosts(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTFIELDS_ + i, \"text_t^1.0\"));\n            r.setBoostQuery(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTQUERY_ + i, \"\"));\n            r.setBoostFunction(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTFUNCTION_ + i, \"\"));\n            r.setMode(Ranking.BoostFunctionMode.valueOf(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTFUNCTIONMODE_ + i, \"add\")));\n        }\n\n        // initialize index\n        ReferenceContainer.maxReferences = getConfigInt(\"index.maxReferences\", 0);\n        final File segmentsPath = new File(new File(indexPath, networkName), \"SEGMENTS\");\n        this.index = new Segment(this.log, segmentsPath, solrCollectionConfigurationWork, solrWebgraphConfigurationWork);\n        if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_RWI, true)) try {\n            this.index.connectRWI(wordCacheMaxCount, fileSizeMax);\n        } catch (IOException e) {Log.logException(e);}\n        if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_CITATION, true)) try {\n            this.index.connectCitation(wordCacheMaxCount, fileSizeMax);\n        } catch (IOException e) {Log.logException(e);}\n        if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_FULLTEXT, true)) {\n            this.index.connectUrlDb(this.useTailCache, this.exceed134217727);\n            try {this.index.fulltext().connectLocalSolr();} catch (IOException e) {Log.logException(e);}\n        }\n        this.index.writeWebgraph(this.getConfigBool(SwitchboardConstants.CORE_SERVICE_WEBGRAPH, false));\n\n        // set up the solr interface\n        final String solrurls = getConfig(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_URL, \"http://127.0.0.1:8983/solr\");\n        final boolean usesolr = getConfigBool(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_ENABLED, false) & solrurls.length() > 0;\n\n        if (usesolr && solrurls != null && solrurls.length() > 0) {\n            try {\n                ArrayList<RemoteInstance> instances = RemoteInstance.getShardInstances(solrurls, null, null);\n                this.index.fulltext().connectRemoteSolr(instances);\n            } catch ( final IOException e ) {\n                Log.logException(e);\n            }\n        }\n\n        // initialize network database\n        final File mySeedFile = new File(this.networkRoot, SeedDB.DBFILE_OWN_SEED);\n        this.peers =\n            new SeedDB(\n                this.networkRoot,\n                \"seed.new.heap\",\n                \"seed.old.heap\",\n                \"seed.pot.heap\",\n                mySeedFile,\n                redundancy,\n                partitionExponent,\n                false,\n                this.exceed134217727);\n\n        // load domainList\n        try {\n            this.domainList = null;\n            if ( !getConfig(\"network.unit.domainlist\", \"\").equals(\"\") ) {\n                final Reader r =\n                    getConfigFileFromWebOrLocally(getConfig(\"network.unit.domainlist\", \"\"), getAppPath()\n                        .getAbsolutePath(), new File(this.networkRoot, \"domainlist.txt\"));\n                this.domainList = new FilterEngine();\n                this.domainList.loadList(new BufferedReader(r), null);\n            }\n        } catch ( final FileNotFoundException e ) {\n            this.log.logSevere(\"CONFIG: domainlist not found: \" + e.getMessage());\n        } catch ( final IOException e ) {\n            this.log.logSevere(\"CONFIG: error while retrieving domainlist: \" + e.getMessage());\n        }\n\n        // create a crawler\n        this.crawler = new CrawlSwitchboard(networkName, this.log, this.queuesRoot);\n\n        // start yacy core\n        this.log.logConfig(\"Starting YaCy Protocol Core\");\n        this.yc = new Network(this);\n        InstantBusyThread.oneTimeJob(this, \"loadSeedLists\", 0);\n        //final long startedSeedListAquisition = System.currentTimeMillis();\n\n        // init a DHT transmission dispatcher\n        this.dhtDispatcher =\n            (this.peers.sizeConnected() == 0) ? null : new Dispatcher(\n                this.index,\n                this.peers,\n                true,\n                10000);\n\n        // set up local robots.txt\n        this.robotstxtConfig = RobotsTxtConfig.init(this);\n\n        // setting timestamp of last proxy access\n        this.proxyLastAccess = System.currentTimeMillis() - 10000;\n        this.localSearchLastAccess = System.currentTimeMillis() - 10000;\n        this.remoteSearchLastAccess = System.currentTimeMillis() - 10000;\n        this.webStructure = new WebStructureGraph(new File(this.queuesRoot, \"webStructure.map\"));\n\n        // configuring list path\n        if ( !(this.listsPath.exists()) ) {\n            this.listsPath.mkdirs();\n        }\n\n        // load coloured lists\n        if ( blueList == null ) {\n            // read only once upon first instantiation of this class\n            final String f =\n                getConfig(SwitchboardConstants.LIST_BLUE, SwitchboardConstants.LIST_BLUE_DEFAULT);\n            final File plasmaBlueListFile = new File(f);\n            if ( f != null ) {\n                blueList = SetTools.loadList(plasmaBlueListFile, NaturalOrder.naturalComparator);\n            } else {\n                blueList = new TreeSet<String>();\n            }\n            blueListHashes = Word.words2hashesHandles(blueList);\n            this.log.logConfig(\"loaded blue-list from file \"\n                + plasmaBlueListFile.getName()\n                + \", \"\n                + blueList.size()\n                + \" entries, \"\n                + ppRamString(plasmaBlueListFile.length() / 1024));\n        }\n\n        // load blacklist\n        this.log.logConfig(\"Loading blacklist ...\");\n        final File blacklistsPath =\n            getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\n        urlBlacklist = new Blacklist(blacklistsPath);\n        ListManager.switchboard = this;\n        ListManager.listsPath = blacklistsPath;\n        ListManager.reloadBlacklists();\n\n        // load badwords (to filter the topwords)\n        if ( badwords == null || badwords.isEmpty() ) {\n            final File badwordsFile = new File(appPath, SwitchboardConstants.LIST_BADWORDS_DEFAULT);\n            badwords = SetTools.loadList(badwordsFile, NaturalOrder.naturalComparator);\n            badwordHashes = Word.words2hashesHandles(badwords);\n            this.log.logConfig(\"loaded badwords from file \"\n                + badwordsFile.getName()\n                + \", \"\n                + badwords.size()\n                + \" entries, \"\n                + ppRamString(badwordsFile.length() / 1024));\n        }\n\n        // load stopwords\n        if ( stopwords == null || stopwords.isEmpty() ) {\n            final File stopwordsFile = new File(appPath, SwitchboardConstants.LIST_STOPWORDS_DEFAULT);\n            stopwords = SetTools.loadList(stopwordsFile, NaturalOrder.naturalComparator);\n            stopwordHashes = Word.words2hashesHandles(stopwords);\n            this.log.logConfig(\"loaded stopwords from file \"\n                + stopwordsFile.getName()\n                + \", \"\n                + stopwords.size()\n                + \" entries, \"\n                + ppRamString(stopwordsFile.length() / 1024));\n        }\n\n        // load ranking from distribution\n        final File rankingPath = new File(this.appPath, \"ranking/YBR\".replace('/', File.separatorChar));\n        BlockRank.loadBlockRankTable(rankingPath, 16);\n\n        // start a cache manager\n        this.log.logConfig(\"Starting HT Cache Manager\");\n\n        // create the cache directory\n        this.htCachePath =\n            getDataPath(SwitchboardConstants.HTCACHE_PATH, SwitchboardConstants.HTCACHE_PATH_DEFAULT);\n        this.log.logInfo(\"HTCACHE Path = \" + this.htCachePath.getAbsolutePath());\n        final long maxCacheSize =\n            1024L * 1024L * Long.parseLong(getConfig(SwitchboardConstants.PROXY_CACHE_SIZE, \"2\")); // this is megabyte\n        Cache.init(this.htCachePath, this.peers.mySeed().hash, maxCacheSize);\n\n        // create the surrogates directories\n        this.surrogatesInPath =\n            getDataPath(\n                SwitchboardConstants.SURROGATES_IN_PATH,\n                SwitchboardConstants.SURROGATES_IN_PATH_DEFAULT);\n        this.log.logInfo(\"surrogates.in Path = \" + this.surrogatesInPath.getAbsolutePath());\n        this.surrogatesInPath.mkdirs();\n        this.surrogatesOutPath =\n            getDataPath(\n                SwitchboardConstants.SURROGATES_OUT_PATH,\n                SwitchboardConstants.SURROGATES_OUT_PATH_DEFAULT);\n        this.log.logInfo(\"surrogates.out Path = \" + this.surrogatesOutPath.getAbsolutePath());\n        this.surrogatesOutPath.mkdirs();\n\n        // create the release download directory\n        this.releasePath =\n            getDataPath(SwitchboardConstants.RELEASE_PATH, SwitchboardConstants.RELEASE_PATH_DEFAULT);\n        this.releasePath.mkdirs();\n        this.log.logInfo(\"RELEASE Path = \" + this.releasePath.getAbsolutePath());\n\n        // starting message board\n        try {\n            initMessages();\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // starting wiki\n        try {\n            initWiki();\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        //starting blog\n        try {\n            initBlog();\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // init User DB\n        this.log.logConfig(\"Loading User DB\");\n        final File userDbFile = new File(getDataPath(), \"DATA/SETTINGS/user.heap\");\n        try {\n            this.userDB = new UserDB(userDbFile);\n            this.log.logConfig(\"Loaded User DB from file \"\n                    + userDbFile.getName()\n                    + \", \"\n                    + this.userDB.size()\n                    + \" entries\"\n                    + \", \"\n                    + ppRamString(userDbFile.length() / 1024));\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // init user triplestores\n        JenaTripleStore.initPrivateStores();\n\n        // init html parser evaluation scheme\n        File parserPropertiesPath = new File(\"defaults/\");\n        String[] settingsList = parserPropertiesPath.list();\n        for ( final String l : settingsList ) {\n            if ( l.startsWith(\"parser.\") && l.endsWith(\".properties\") ) {\n                try {\n                    Evaluation.add(new File(parserPropertiesPath, l));\n                } catch (IOException e) {\n                    Log.logException(e);\n                }\n            }\n        }\n        parserPropertiesPath = new File(getDataPath(), \"DATA/SETTINGS/\");\n        settingsList = parserPropertiesPath.list();\n        for ( final String l : settingsList ) {\n            if ( l.startsWith(\"parser.\") && l.endsWith(\".properties\") ) {\n                try {\n                    Evaluation.add(new File(parserPropertiesPath, l));\n                } catch (IOException e) {\n                    Log.logException(e);\n                }\n            }\n        }\n\n        // init bookmarks DB: needs more time since this does a DNS lookup for each Bookmark.\n        // Can be started concurrently\n        new Thread() {\n            @Override\n            public void run() {\n                Thread.currentThread().setName(\"Switchboard.initBookmarks\");\n                try {\n                    initBookmarks();\n                } catch ( final IOException e ) {\n                    Log.logException(e);\n                }\n            }\n        }.start();\n\n        // define a realtime parsable mimetype list\n        this.log.logConfig(\"Parser: Initializing Mime Type deny list\");\n        \n    \tfinal boolean enableAudioTags = getConfigBool(\"parser.enableAudioTags\", false);\n        log.logConfig(\"Parser: parser.enableAudioTags= \"+enableAudioTags);\n    \tfinal StringBuilder denyExt = new StringBuilder(256);\n    \tfinal StringBuilder denyMime = new StringBuilder(256);\n    \tdenyExt.append(getConfig(SwitchboardConstants.PARSER_MIME_DENY, \"\"));\n    \tdenyMime.append(getConfig(SwitchboardConstants.PARSER_EXTENSIONS_DENY, \"\"));\n    \t\n    \tif (!enableAudioTags) {\n    \t\tif(denyExt.length()>0) {\n    \t\t\tdenyExt.append(audioTagParser.SEPERATOR);\n    \t\t}\n    \t\tdenyExt.append(audioTagParser.EXTENSIONS);\n    \t\t\n    \t\tif(denyMime.length()>0) {\n    \t\t\tdenyMime.append(audioTagParser.SEPERATOR);\n    \t\t}\n    \t\tdenyMime.append(audioTagParser.MIME_TYPES);\n        \t\n        \tsetConfig(SwitchboardConstants.PARSER_EXTENSIONS_DENY, denyExt.toString());\n        \tsetConfig(SwitchboardConstants.PARSER_MIME_DENY, denyMime.toString());\n        \tsetConfig(\"parser.enableAudioTags\", true);\n        }\n                \n    \tTextParser.setDenyMime(getConfig(SwitchboardConstants.PARSER_MIME_DENY, \"\"));\n        TextParser.setDenyExtension(getConfig(SwitchboardConstants.PARSER_EXTENSIONS_DENY, \"\"));\n\n        // start a loader\n        this.log.logConfig(\"Starting Crawl Loader\");\n        this.loader = new LoaderDispatcher(this);\n        \n        // load the robots.txt db\n        this.log.logConfig(\"Initializing robots.txt DB\");\n        this.robots = new RobotsTxt(this.tables, this.loader);\n        try {\n            this.log.logConfig(\"Loaded robots.txt DB: \" + this.robots.size() + \" entries\");\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // load oai tables\n        final Map<String, File> oaiFriends =\n            OAIListFriendsLoader.loadListFriendsSources(\n                new File(\"defaults/oaiListFriendsSource.xml\"),\n                getDataPath());\n        OAIListFriendsLoader.init(this.loader, oaiFriends);\n        this.crawlQueues = new CrawlQueues(this, this.queuesRoot);\n        this.crawlQueues.noticeURL.setMinimumDelta(\n            getConfigInt(\"minimumLocalDelta\", this.crawlQueues.noticeURL.getMinimumLocalDelta()),\n            getConfigInt(\"minimumGlobalDelta\", this.crawlQueues.noticeURL.getMinimumGlobalDelta()));\n\n        /*\n         * Creating sync objects and loading status for the crawl jobs\n         * a) local crawl\n         * b) remote triggered crawl\n         * c) global crawl trigger\n         */\n        this.crawlJobsStatus.put(\n            SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL,\n            new Object[] {\n                new Object(),\n                Boolean.valueOf(getConfig(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL + \"_isPaused\", \"false\"))\n            });\n        this.crawlJobsStatus.put(\n            SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL,\n            new Object[] {\n                new Object(),\n                Boolean.valueOf(getConfig(\n                    SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL + \"_isPaused\",\n                    \"false\"))\n            });\n        this.crawlJobsStatus.put(\n            SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER,\n            new Object[] {\n                new Object(),\n                Boolean.valueOf(getConfig(\n                    SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER + \"_isPaused\",\n                    \"false\"))\n            });\n\n        // init cookie-Monitor\n        this.log.logConfig(\"Starting Cookie Monitor\");\n        this.outgoingCookies = new ConcurrentHashMap<String, Object[]>();\n        this.incomingCookies = new ConcurrentHashMap<String, Object[]>();\n\n        // init search history trackers\n        this.localSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>(); // String:TreeSet - IP:set of Long(accessTime)\n        this.remoteSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>();\n\n        // init messages: clean up message symbol\n        final File notifierSource =\n            new File(getAppPath(), getConfig(\n                SwitchboardConstants.HTROOT_PATH,\n                SwitchboardConstants.HTROOT_PATH_DEFAULT) + \"/env/grafics/empty.gif\");\n        final File notifierDest =\n            new File(\n                getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT),\n                \"notifier.gif\");\n        try {\n            Files.copy(notifierSource, notifierDest);\n        } catch ( final IOException e ) {\n        }\n\n        // init nameCacheNoCachingList\n        try {\n            Domains.setNoCachingPatterns(getConfig(SwitchboardConstants.HTTPC_NAME_CACHE_CACHING_PATTERNS_NO, \"\"));\n        } catch (PatternSyntaxException pse) {\n            Log.logSevere(\"Switchboard\", \"Invalid regular expression in \"\n                            + SwitchboardConstants.HTTPC_NAME_CACHE_CACHING_PATTERNS_NO\n                            + \" property: \" + pse.getMessage());\n            System.exit(-1);\n        }\n\n        // generate snippets cache\n        this.log.logConfig(\"Initializing Snippet Cache\");\n\n        // init the wiki\n        wikiParser = new WikiCode();\n\n        // initializing the resourceObserver\n        InstantBusyThread.oneTimeJob(ResourceObserver.class, \"initThread\", 0);\n\n        // initializing the stackCrawlThread\n        this.crawlStacker =\n            new CrawlStacker(\n                this.robots,\n                this.crawlQueues,\n                this.crawler,\n                this.index,\n                this.peers,\n                isIntranetMode(),\n                isGlobalMode(),\n                this.domainList); // Intranet and Global mode may be both true!\n\n        // possibly switch off localIP check\n        Domains.setNoLocalCheck(isAllIPMode());\n\n        // check status of account configuration: when local url crawling is allowed, it is not allowed\n        // that an automatic authorization of localhost is done, because in this case crawls from local\n        // addresses are blocked to prevent attack szenarios where remote pages contain links to localhost\n        // addresses that can steer a YaCy peer\n        if ( !getConfigBool(\"adminAccountForLocalhost\", false) ) {\n            if ( getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").startsWith(\"0000\") ) {\n                // the password was set automatically with a random value.\n                // We must remove that here to prevent that a user cannot log in any more\n                setConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n                // after this a message must be generated to alert the user to set a new password\n                this.log.logInfo(\"RANDOM PASSWORD REMOVED! User must set a new password\");\n            }\n        }\n\n        // initializing dht chunk generation\n        this.dhtMaxReferenceCount = (int) getConfigLong(SwitchboardConstants.INDEX_DIST_CHUNK_SIZE_START, 50);\n\n        // init robinson cluster\n        // before we do that, we wait some time until the seed list is loaded.\n        this.clusterhashes = this.peers.clusterHashes(getConfig(\"cluster.peers.yacydomain\", \"\"));\n\n        // deploy blocking threads\n        this.indexingStorageProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"storeDocumentIndex\",\n                \"This is the sequencing step of the indexing queue. Files are written as streams, too much councurrency would destroy IO performance. In this process the words are written to the RWI cache, which flushes if it is full.\",\n                new String[] {\n                    \"RWI/Cache/Collections\"\n                },\n                this,\n                \"storeDocumentIndex\",\n                2,\n                null,\n                1 /*Math.max(1, WorkflowProcessor.availableCPU / 2)*/);\n        this.indexingAnalysisProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"webStructureAnalysis\",\n                \"This just stores the link structure of the document into a web structure database.\",\n                new String[] {\n                    \"storeDocumentIndex\"\n                },\n                this,\n                \"webStructureAnalysis\",\n                WorkflowProcessor.availableCPU + 1,\n                this.indexingStorageProcessor,\n                WorkflowProcessor.availableCPU);\n        this.indexingCondensementProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"condenseDocument\",\n                \"This does a structural analysis of plain texts: markup of headlines, slicing into phrases (i.e. sentences), markup with position, counting of words, calculation of term frequency.\",\n                new String[] {\n                    \"webStructureAnalysis\"\n                },\n                this,\n                \"condenseDocument\",\n                WorkflowProcessor.availableCPU + 1,\n                this.indexingAnalysisProcessor,\n                WorkflowProcessor.availableCPU);\n        this.indexingDocumentProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"parseDocument\",\n                \"This does the parsing of the newly loaded documents from the web. The result is not only a plain text document, but also a list of URLs that are embedded into the document. The urls are handed over to the CrawlStacker. This process has two child process queues!\",\n                new String[] {\n                    \"condenseDocument\", \"CrawlStacker\"\n                },\n                this,\n                \"parseDocument\",\n                Math.max(20, WorkflowProcessor.availableCPU * 2), // it may happen that this is filled with new files from the search process. That means there should be enough place for two result pages\n                this.indexingCondensementProcessor,\n                WorkflowProcessor.availableCPU);\n\n        // deploy busy threads\n        this.log.logConfig(\"Starting Threads\");\n        MemoryControl.gc(10000, \"plasmaSwitchboard, help for profiler\"); // help for profiler - thq\n\n        deployThread(\n            SwitchboardConstants.CLEANUP,\n            \"Cleanup\",\n            \"simple cleaning process for monitoring information\",\n            null,\n            new InstantBusyThread(\n                this,\n                SwitchboardConstants.CLEANUP_METHOD_START,\n                SwitchboardConstants.CLEANUP_METHOD_JOBCOUNT,\n                SwitchboardConstants.CLEANUP_METHOD_FREEMEM,\n                60000,\n                Long.MAX_VALUE,\n                10000,\n                Long.MAX_VALUE),\n            60000); // all 5 Minutes, wait 1 minute until first run\n        deployThread(\n                SwitchboardConstants.SEARCHRESULT,\n                \"Search Result Flush\",\n                \"A thread that stores search results from other peers into the own index.\",\n                null,\n                new InstantBusyThread(\n                    this,\n                    SwitchboardConstants.SEARCHRESULT_METHOD_START,\n                    SwitchboardConstants.SEARCHRESULT_METHOD_JOBCOUNT,\n                    SwitchboardConstants.SEARCHRESULT_METHOD_FREEMEM,\n                    20000,\n                    Long.MAX_VALUE,\n                    0,\n                    Long.MAX_VALUE),\n                30000);\n        deployThread(\n            SwitchboardConstants.SURROGATES,\n            \"Surrogates\",\n            \"A thread that polls the SURROGATES path and puts all Documents in one surroagte file into the indexing queue.\",\n            null,\n            new InstantBusyThread(\n                this,\n                SwitchboardConstants.SURROGATES_METHOD_START,\n                SwitchboardConstants.SURROGATES_METHOD_JOBCOUNT,\n                SwitchboardConstants.SURROGATES_METHOD_FREEMEM,\n                20000,\n                Long.MAX_VALUE,\n                0,\n                Long.MAX_VALUE),\n            10000);\n        deployThread(\n            SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL,\n            \"Remote Crawl Job\",\n            \"thread that performes a single crawl/indexing step triggered by a remote peer\",\n            \"/IndexCreateWWWRemoteQueue_p.html\",\n            new InstantBusyThread(\n                this.crawlQueues,\n                SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_START,\n                SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_JOBCOUNT,\n                SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_FREEMEM,\n                0,\n                Long.MAX_VALUE,\n                0,\n                Long.MAX_VALUE),\n            10000);\n        deployThread(\n            SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER,\n            \"Remote Crawl URL Loader\",\n            \"thread that loads remote crawl lists from other peers\",\n            null,\n            new InstantBusyThread(\n                this.crawlQueues,\n                SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_START,\n                SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_JOBCOUNT,\n                SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_FREEMEM,\n                10000,\n                Long.MAX_VALUE,\n                10000,\n                Long.MAX_VALUE),\n            10000); // error here?\n        deployThread(\n            SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL,\n            \"Local Crawl\",\n            \"thread that performes a single crawl step from the local crawl queue\",\n            \"/IndexCreateWWWLocalQueue_p.html\",\n            new InstantBusyThread(\n                this.crawlQueues,\n                SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_START,\n                SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_JOBCOUNT,\n                SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_FREEMEM,\n                0,\n                Long.MAX_VALUE,\n                0,\n                Long.MAX_VALUE),\n            10000);\n        deployThread(\n            SwitchboardConstants.SEED_UPLOAD,\n            \"Seed-List Upload\",\n            \"task that a principal peer performes to generate and upload a seed-list to a ftp account\",\n            null,\n            new InstantBusyThread(\n                this.yc,\n                SwitchboardConstants.SEED_UPLOAD_METHOD_START,\n                SwitchboardConstants.SEED_UPLOAD_METHOD_JOBCOUNT,\n                SwitchboardConstants.SEED_UPLOAD_METHOD_FREEMEM,\n                600000,\n                Long.MAX_VALUE,\n                300000,\n                Long.MAX_VALUE),\n            180000);\n        deployThread(\n            SwitchboardConstants.PEER_PING,\n            \"YaCy Core\",\n            \"this is the p2p-control and peer-ping task\",\n            null,\n            new InstantBusyThread(\n                this.yc,\n                SwitchboardConstants.PEER_PING_METHOD_START,\n                SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\n                SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\n                30000,\n                Long.MAX_VALUE,\n                30000,\n                Long.MAX_VALUE),\n            2000);\n        deployThread(\n            SwitchboardConstants.INDEX_DIST,\n            \"DHT Distribution\",\n            \"selection, transfer and deletion of index entries that are not searched on your peer, but on others\",\n            null,\n            new InstantBusyThread(\n                this,\n                SwitchboardConstants.INDEX_DIST_METHOD_START,\n                SwitchboardConstants.INDEX_DIST_METHOD_JOBCOUNT,\n                SwitchboardConstants.INDEX_DIST_METHOD_FREEMEM,\n                10000,\n                Long.MAX_VALUE,\n                1000,\n                Long.MAX_VALUE),\n            5000,\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_IDLESLEEP, \"5000\")),\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_BUSYSLEEP, \"0\")),\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_MEMPREREQ, \"1000000\")));\n\n        // content control: initialize list sync thread\n        deployThread(\n                \"720_ccimport\",\n                \"Content Control Import\",\n                \"this is the content control import thread\",\n                null,\n                new InstantBusyThread(\n                    new SMWListSyncThread(this, sb.getConfig(\"contentcontrol.bookmarklist\", \"contentcontrol\"), \"Category:Content Source\", \"/?Url/?Filter/?Category/?Modification date\", sb.getConfigBool(\n            \t\t\t\t\"contentcontrol.smwimport.purgelistoninit\", false)),\n                    \"run\",\n                    SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\n                    SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\n                    3000,\n                    10000,\n                    3000,\n                    10000),\n                2000);\n        deployThread(\n                \"730_ccfilter\",\n                \"Content Control Filter\",\n                \"this is the content control filter update thread\",\n                null,\n                new InstantBusyThread(\n                    new ContentControlFilterUpdateThread(this),\n                    \"run\",\n                    SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\n                    SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\n                    3000,\n                    10000,\n                    3000,\n                    10000),\n                2000);\n\n        // set network-specific performance attributes\n        if ( this.firstInit ) {\n            setRemotecrawlPPM(Math.max(1, (int) getConfigLong(\"network.unit.remotecrawl.speed\", 60)));\n        }\n\n        // test routine for snippet fetch\n        //Set query = new HashSet();\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Weitergabe\"));\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Zahl\"));\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/mobil/newsticker/meldung/mail/54980\"), query, true);\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/security/news/foren/go.shtml?read=1&msg_id=7301419&forum_id=72721\"), query, true);\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/kiosk/archiv/ct/2003/4/20\"), query, true, 260);\n\n        this.trail = new LinkedBlockingQueue<String>();\n        \n        // finally start jobs which shall be started after start-up\n        new Thread() {\n            public void run() {\n                try {Thread.sleep(10000);} catch (InterruptedException e) {} // we must wait until the httpd comes up\n                execAPIActions(); // trigger startup actions\n            }\n        }.start();\n\n        this.log.logConfig(\"Finished Switchboard Initialization\");\n    }","id":104848,"modified_method":"public Switchboard(final File dataPath, final File appPath, final String initPath, final String configPath) {\n        super(dataPath, appPath, initPath, configPath);\n        sb = this;\n        // check if port is already occupied\n        final int port = getConfigInt(\"port\", 8090);\n        try {\n            if ( TimeoutRequest.ping(Domains.LOCALHOST, port, 500) ) {\n                throw new RuntimeException(\n                    \"a server is already running on the YaCy port \"\n                        + port\n                        + \"; possibly another YaCy process has not terminated yet. Please stop YaCy before running a new instance.\");\n            }\n        } catch ( final ExecutionException e1 ) {\n        }\n\n        MemoryTracker.startSystemProfiling();\n\n        // set loglevel and log\n        setLog(new Log(\"SWITCHBOARD\"));\n        AccessTracker.setDumpFile(new File(\"DATA/LOG/queries.log\"));\n\n        // set default peer name\n        Seed.ANON_PREFIX = getConfig(\"peernameprefix\", \"_anon\");\n\n        // UPnP port mapping\n        if ( getConfigBool(SwitchboardConstants.UPNP_ENABLED, false) ) {\n            InstantBusyThread.oneTimeJob(UPnP.class, \"addPortMapping\", 0);\n        }\n\n        // init TrayIcon if possible\n        this.tray = new Tray(this);\n\n        // remote proxy configuration\n        initRemoteProxy();\n\n        // memory configuration\n        long tableCachingLimit = getConfigLong(\"tableCachingLimit\", 419430400L);\n        if ( MemoryControl.available() > tableCachingLimit ) {\n            this.useTailCache = true;\n        }\n        this.exceed134217727 = getConfigBool(\"exceed134217727\", true);\n        if ( MemoryControl.available() > 1024L * 1024L * 1024L * 2L ) {\n            this.exceed134217727 = true;\n        }\n\n        // load values from configs\n        final File indexPath =\n            getDataPath(SwitchboardConstants.INDEX_PRIMARY_PATH, SwitchboardConstants.INDEX_PATH_DEFAULT);\n        this.log.logConfig(\"Index Primary Path: \" + indexPath.toString());\n        this.listsPath =\n            getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\n        this.log.logConfig(\"Lists Path:     \" + this.listsPath.toString());\n        this.htDocsPath =\n            getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT);\n        this.log.logConfig(\"HTDOCS Path:    \" + this.htDocsPath.toString());\n        this.workPath = getDataPath(SwitchboardConstants.WORK_PATH, SwitchboardConstants.WORK_PATH_DEFAULT);\n        this.workPath.mkdirs();\n        // if default work files exist, copy them (don't overwrite existing!)\n        File defaultWorkPath = new File(\"defaults/data/work\");\n        if (defaultWorkPath.list() != null) {\n            for (String fs : defaultWorkPath.list()) {\n                File wf = new File(this.workPath, fs);\n                if (!wf.exists()) {\n                    try {\n                        Files.copy(new File(defaultWorkPath, fs), wf);\n                    } catch (IOException e) {\n                        Log.logException(e);\n                    }\n                }\n            }\n        }\n        \n        this.log.logConfig(\"Work Path:    \" + this.workPath.toString());\n        this.dictionariesPath =\n            getDataPath(\n                SwitchboardConstants.DICTIONARY_SOURCE_PATH,\n                SwitchboardConstants.DICTIONARY_SOURCE_PATH_DEFAULT);\n        this.log.logConfig(\"Dictionaries Path:\" + this.dictionariesPath.toString());\n\n        // init libraries\n        this.log.logConfig(\"initializing libraries\");\n        new Thread() {\n            @Override\n            public void run() {\n                Thread.currentThread().setName(\"LibraryProvider.initialize\");\n                LibraryProvider.initialize(Switchboard.this.dictionariesPath);\n            }\n        }.start();\n\n        // init global host name cache\n        Domains.init(new File(this.workPath, \"globalhosts.list\"));\n\n        // init sessionid name file\n        final String sessionidNamesFile = getConfig(\"sessionidNamesFile\", \"defaults/sessionid.names\");\n        this.log.logConfig(\"Loading sessionid file \" + sessionidNamesFile);\n        MultiProtocolURI.initSessionIDNames(FileUtils.loadList(new File(getAppPath(), sessionidNamesFile)));\n\n        // init tables\n        this.tables = new WorkTables(this.workPath);\n\n        // set a high maximum cache size to current size; this is adopted later automatically\n        final int wordCacheMaxCount = (int) getConfigLong(SwitchboardConstants.WORDCACHE_MAX_COUNT, 20000);\n        setConfig(SwitchboardConstants.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\n\n        // load the network definition\n        try {\n            overwriteNetworkDefinition();\n        } catch (FileNotFoundException e) {\n            Log.logException(e);\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // start indexing management\n        this.log.logConfig(\"Starting Indexing Management\");\n        final String networkName = getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n        final long fileSizeMax = (OS.isWindows) ? this.getConfigLong(\"filesize.max.win\", Integer.MAX_VALUE) : this.getConfigLong( \"filesize.max.other\", Integer.MAX_VALUE);\n        final int redundancy = (int) this.getConfigLong(\"network.unit.dhtredundancy.senior\", 1);\n        final int partitionExponent = (int) this.getConfigLong(\"network.unit.dht.partitionExponent\", 0);\n        this.networkRoot = new File(new File(indexPath, networkName), \"NETWORK\");\n        this.queuesRoot = new File(new File(indexPath, networkName), \"QUEUES\");\n        this.networkRoot.mkdirs();\n        this.queuesRoot.mkdirs();\n\n        // prepare a solr index profile switch list\n        final File solrCollectionConfigurationInitFile = new File(getAppPath(),  \"defaults/\" + SOLR_COLLECTION_CONFIGURATION_NAME);\n        final File solrCollectionConfigurationWorkFile = new File(getDataPath(), \"DATA/SETTINGS/\" + SOLR_COLLECTION_CONFIGURATION_NAME);\n        final File solrWebgraphConfigurationInitFile   = new File(getAppPath(),  \"defaults/\" + SOLR_WEBGRAPH_CONFIGURATION_NAME);\n        final File solrWebgraphConfigurationWorkFile   = new File(getDataPath(), \"DATA/SETTINGS/\" + SOLR_WEBGRAPH_CONFIGURATION_NAME);\n        CollectionConfiguration solrCollectionConfigurationWork = null;\n        WebgraphConfiguration solrWebgraphConfigurationWork = null;\n\n        // migrate the old Schema file path to a new one\n        final File solrCollectionConfigurationWorkOldFile = new File(getDataPath(), \"DATA/SETTINGS/\" + SOLR_COLLECTION_CONFIGURATION_NAME_OLD);\n        if (solrCollectionConfigurationWorkOldFile.exists() && !solrCollectionConfigurationWorkFile.exists()) solrCollectionConfigurationWorkOldFile.renameTo(solrCollectionConfigurationWorkFile);\n\n        // initialize the collection schema if it does not yet exist\n        if (!solrCollectionConfigurationWorkFile.exists()) try {\n            Files.copy(solrCollectionConfigurationInitFile, solrCollectionConfigurationWorkFile);\n        } catch (IOException e) {Log.logException(e);}\n\n        // lazy definition of schema: do not write empty fields\n        final boolean solrlazy = getConfigBool(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_LAZY, true);\n\n        // define collection schema\n        try {\n            final CollectionConfiguration solrCollectionConfigurationInit = new CollectionConfiguration(solrCollectionConfigurationInitFile, solrlazy);\n            solrCollectionConfigurationWork = new CollectionConfiguration(solrCollectionConfigurationWorkFile, solrlazy);\n            // update the working scheme with the backup scheme. This is necessary to include new features.\n            // new features are always activated by default (if activated in input-backupScheme)\n            solrCollectionConfigurationWork.fill(solrCollectionConfigurationInit, true);\n            // switch on some fields which are necessary for ranking and faceting\n            for (CollectionSchema field: new CollectionSchema[]{\n                    CollectionSchema.host_s, CollectionSchema.load_date_dt,\n                    CollectionSchema.url_file_ext_s, CollectionSchema.last_modified,                      // needed for media search and /date operator\n                    /*YaCySchema.url_paths_sxt,*/ CollectionSchema.host_organization_s,                   // needed to search in the url\n                    /*YaCySchema.inboundlinks_protocol_sxt,*/ CollectionSchema.inboundlinks_urlstub_txt,  // needed for HostBrowser\n                    /*YaCySchema.outboundlinks_protocol_sxt,*/ CollectionSchema.outboundlinks_urlstub_txt // needed to enhance the crawler\n                }) {\n                SchemaConfiguration.Entry entry = solrCollectionConfigurationWork.get(field.name()); entry.setEnable(true); solrCollectionConfigurationWork.put(field.name(), entry);\n            }\n            solrCollectionConfigurationWork.commit();\n        } catch (IOException e) {Log.logException(e);}\n        \n        // initialize the webgraph schema if it does not yet exist\n        if (!solrWebgraphConfigurationWorkFile.exists()) try {\n            Files.copy(solrWebgraphConfigurationInitFile, solrWebgraphConfigurationWorkFile);\n        } catch (IOException e) {Log.logException(e);}\n        \n        // define webgraph schema\n        try {\n            final WebgraphConfiguration solrWebgraphConfigurationInit = new WebgraphConfiguration(solrWebgraphConfigurationInitFile, solrlazy);\n            solrWebgraphConfigurationWork = new WebgraphConfiguration(solrWebgraphConfigurationWorkFile, solrlazy);\n            solrWebgraphConfigurationWork.fill(solrWebgraphConfigurationInit, true);\n            solrWebgraphConfigurationWork.commit();\n        } catch (IOException e) {Log.logException(e);}\n\n        // define boosts\n        Ranking.setMinTokenLen(this.getConfigInt(SwitchboardConstants.SEARCH_RANKING_SOLR_DOUBLEDETECTION_MINLENGTH, 3));\n        Ranking.setQuantRate(this.getConfigFloat(SwitchboardConstants.SEARCH_RANKING_SOLR_DOUBLEDETECTION_QUANTRATE, 0.5f));\n        for (int i = 0; i <= 3; i++) {\n            // must be done every time the boosts change\n            Ranking r = solrCollectionConfigurationWork.getRanking(i);\n            r.setName(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTNAME_ + i, \"_dummy\" + i));\n            r.updateBoosts(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTFIELDS_ + i, \"text_t^1.0\"));\n            r.setBoostQuery(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTQUERY_ + i, \"\"));\n            r.setBoostFunction(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTFUNCTION_ + i, \"\"));\n            r.setMode(Ranking.BoostFunctionMode.valueOf(this.getConfig(SwitchboardConstants.SEARCH_RANKING_SOLR_COLLECTION_BOOSTFUNCTIONMODE_ + i, \"add\")));\n        }\n\n        // initialize index\n        ReferenceContainer.maxReferences = getConfigInt(\"index.maxReferences\", 0);\n        final File segmentsPath = new File(new File(indexPath, networkName), \"SEGMENTS\");\n        this.index = new Segment(this.log, segmentsPath, solrCollectionConfigurationWork, solrWebgraphConfigurationWork);\n        if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_RWI, true)) try {\n            this.index.connectRWI(wordCacheMaxCount, fileSizeMax);\n        } catch (IOException e) {Log.logException(e);}\n        if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_CITATION, true)) try {\n            this.index.connectCitation(wordCacheMaxCount, fileSizeMax);\n        } catch (IOException e) {Log.logException(e);}\n        if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_FULLTEXT, true)) {\n            this.index.connectUrlDb(this.useTailCache, this.exceed134217727);\n            try {this.index.fulltext().connectLocalSolr();} catch (IOException e) {Log.logException(e);}\n        }\n        this.index.writeWebgraph(this.getConfigBool(SwitchboardConstants.CORE_SERVICE_WEBGRAPH, false));\n\n        // set up the solr interface\n        final String solrurls = getConfig(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_URL, \"http://127.0.0.1:8983/solr\");\n        final boolean usesolr = getConfigBool(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_ENABLED, false) & solrurls.length() > 0;\n\n        if (usesolr && solrurls != null && solrurls.length() > 0) {\n            try {\n                ArrayList<RemoteInstance> instances = RemoteInstance.getShardInstances(solrurls, null, null);\n                this.index.fulltext().connectRemoteSolr(instances);\n            } catch ( final IOException e ) {\n                Log.logException(e);\n            }\n        }\n\n        // initialize network database\n        final File mySeedFile = new File(this.networkRoot, SeedDB.DBFILE_OWN_SEED);\n        this.peers =\n            new SeedDB(\n                this.networkRoot,\n                \"seed.new.heap\",\n                \"seed.old.heap\",\n                \"seed.pot.heap\",\n                mySeedFile,\n                redundancy,\n                partitionExponent,\n                false,\n                this.exceed134217727);\n\n        // load domainList\n        try {\n            this.domainList = null;\n            if ( !getConfig(\"network.unit.domainlist\", \"\").equals(\"\") ) {\n                final Reader r =\n                    getConfigFileFromWebOrLocally(getConfig(\"network.unit.domainlist\", \"\"), getAppPath()\n                        .getAbsolutePath(), new File(this.networkRoot, \"domainlist.txt\"));\n                this.domainList = new FilterEngine();\n                this.domainList.loadList(new BufferedReader(r), null);\n            }\n        } catch ( final FileNotFoundException e ) {\n            this.log.logSevere(\"CONFIG: domainlist not found: \" + e.getMessage());\n        } catch ( final IOException e ) {\n            this.log.logSevere(\"CONFIG: error while retrieving domainlist: \" + e.getMessage());\n        }\n\n        // create a crawler\n        this.crawler = new CrawlSwitchboard(networkName, this.log, this.queuesRoot);\n\n        // start yacy core\n        this.log.logConfig(\"Starting YaCy Protocol Core\");\n        this.yc = new Network(this);\n        InstantBusyThread.oneTimeJob(this, \"loadSeedLists\", 0);\n        //final long startedSeedListAquisition = System.currentTimeMillis();\n\n        // init a DHT transmission dispatcher\n        this.dhtDispatcher =\n            (this.peers.sizeConnected() == 0) ? null : new Dispatcher(\n                this.index,\n                this.peers,\n                true,\n                10000);\n\n        // set up local robots.txt\n        this.robotstxtConfig = RobotsTxtConfig.init(this);\n\n        // setting timestamp of last proxy access\n        this.proxyLastAccess = System.currentTimeMillis() - 10000;\n        this.localSearchLastAccess = System.currentTimeMillis() - 10000;\n        this.remoteSearchLastAccess = System.currentTimeMillis() - 10000;\n        this.webStructure = new WebStructureGraph(new File(this.queuesRoot, \"webStructure.map\"));\n\n        // configuring list path\n        if ( !(this.listsPath.exists()) ) {\n            this.listsPath.mkdirs();\n        }\n\n        // load coloured lists\n        if ( blueList == null ) {\n            // read only once upon first instantiation of this class\n            final String f =\n                getConfig(SwitchboardConstants.LIST_BLUE, SwitchboardConstants.LIST_BLUE_DEFAULT);\n            final File plasmaBlueListFile = new File(f);\n            if ( f != null ) {\n                blueList = SetTools.loadList(plasmaBlueListFile, NaturalOrder.naturalComparator);\n            } else {\n                blueList = new TreeSet<String>();\n            }\n            blueListHashes = Word.words2hashesHandles(blueList);\n            this.log.logConfig(\"loaded blue-list from file \"\n                + plasmaBlueListFile.getName()\n                + \", \"\n                + blueList.size()\n                + \" entries, \"\n                + ppRamString(plasmaBlueListFile.length() / 1024));\n        }\n\n        // load blacklist\n        this.log.logConfig(\"Loading blacklist ...\");\n        final File blacklistsPath =\n            getDataPath(SwitchboardConstants.LISTS_PATH, SwitchboardConstants.LISTS_PATH_DEFAULT);\n        urlBlacklist = new Blacklist(blacklistsPath);\n        ListManager.switchboard = this;\n        ListManager.listsPath = blacklistsPath;\n        ListManager.reloadBlacklists();\n\n        // load badwords (to filter the topwords)\n        if ( badwords == null || badwords.isEmpty() ) {\n            final File badwordsFile = new File(appPath, SwitchboardConstants.LIST_BADWORDS_DEFAULT);\n            badwords = SetTools.loadList(badwordsFile, NaturalOrder.naturalComparator);\n            badwordHashes = Word.words2hashesHandles(badwords);\n            this.log.logConfig(\"loaded badwords from file \"\n                + badwordsFile.getName()\n                + \", \"\n                + badwords.size()\n                + \" entries, \"\n                + ppRamString(badwordsFile.length() / 1024));\n        }\n\n        // load stopwords\n        if ( stopwords == null || stopwords.isEmpty() ) {\n            final File stopwordsFile = new File(appPath, SwitchboardConstants.LIST_STOPWORDS_DEFAULT);\n            stopwords = SetTools.loadList(stopwordsFile, NaturalOrder.naturalComparator);\n            stopwordHashes = Word.words2hashesHandles(stopwords);\n            this.log.logConfig(\"loaded stopwords from file \"\n                + stopwordsFile.getName()\n                + \", \"\n                + stopwords.size()\n                + \" entries, \"\n                + ppRamString(stopwordsFile.length() / 1024));\n        }\n\n        // load ranking from distribution\n        final File rankingPath = new File(this.appPath, \"ranking/YBR\".replace('/', File.separatorChar));\n        BlockRank.loadBlockRankTable(rankingPath, 16);\n\n        // start a cache manager\n        this.log.logConfig(\"Starting HT Cache Manager\");\n\n        // create the cache directory\n        this.htCachePath =\n            getDataPath(SwitchboardConstants.HTCACHE_PATH, SwitchboardConstants.HTCACHE_PATH_DEFAULT);\n        this.log.logInfo(\"HTCACHE Path = \" + this.htCachePath.getAbsolutePath());\n        final long maxCacheSize =\n            1024L * 1024L * Long.parseLong(getConfig(SwitchboardConstants.PROXY_CACHE_SIZE, \"2\")); // this is megabyte\n        Cache.init(this.htCachePath, this.peers.mySeed().hash, maxCacheSize);\n\n        // create the surrogates directories\n        this.surrogatesInPath =\n            getDataPath(\n                SwitchboardConstants.SURROGATES_IN_PATH,\n                SwitchboardConstants.SURROGATES_IN_PATH_DEFAULT);\n        this.log.logInfo(\"surrogates.in Path = \" + this.surrogatesInPath.getAbsolutePath());\n        this.surrogatesInPath.mkdirs();\n        this.surrogatesOutPath =\n            getDataPath(\n                SwitchboardConstants.SURROGATES_OUT_PATH,\n                SwitchboardConstants.SURROGATES_OUT_PATH_DEFAULT);\n        this.log.logInfo(\"surrogates.out Path = \" + this.surrogatesOutPath.getAbsolutePath());\n        this.surrogatesOutPath.mkdirs();\n\n        // create the release download directory\n        this.releasePath =\n            getDataPath(SwitchboardConstants.RELEASE_PATH, SwitchboardConstants.RELEASE_PATH_DEFAULT);\n        this.releasePath.mkdirs();\n        this.log.logInfo(\"RELEASE Path = \" + this.releasePath.getAbsolutePath());\n\n        // starting message board\n        try {\n            initMessages();\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // starting wiki\n        try {\n            initWiki();\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        //starting blog\n        try {\n            initBlog();\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // init User DB\n        this.log.logConfig(\"Loading User DB\");\n        final File userDbFile = new File(getDataPath(), \"DATA/SETTINGS/user.heap\");\n        try {\n            this.userDB = new UserDB(userDbFile);\n            this.log.logConfig(\"Loaded User DB from file \"\n                    + userDbFile.getName()\n                    + \", \"\n                    + this.userDB.size()\n                    + \" entries\"\n                    + \", \"\n                    + ppRamString(userDbFile.length() / 1024));\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // init user triplestores\n        JenaTripleStore.initPrivateStores();\n\n        // init html parser evaluation scheme\n        File parserPropertiesPath = new File(\"defaults/\");\n        String[] settingsList = parserPropertiesPath.list();\n        for ( final String l : settingsList ) {\n            if ( l.startsWith(\"parser.\") && l.endsWith(\".properties\") ) {\n                try {\n                    Evaluation.add(new File(parserPropertiesPath, l));\n                } catch (IOException e) {\n                    Log.logException(e);\n                }\n            }\n        }\n        parserPropertiesPath = new File(getDataPath(), \"DATA/SETTINGS/\");\n        settingsList = parserPropertiesPath.list();\n        for ( final String l : settingsList ) {\n            if ( l.startsWith(\"parser.\") && l.endsWith(\".properties\") ) {\n                try {\n                    Evaluation.add(new File(parserPropertiesPath, l));\n                } catch (IOException e) {\n                    Log.logException(e);\n                }\n            }\n        }\n\n        // init bookmarks DB: needs more time since this does a DNS lookup for each Bookmark.\n        // Can be started concurrently\n        new Thread() {\n            @Override\n            public void run() {\n                Thread.currentThread().setName(\"Switchboard.initBookmarks\");\n                try {\n                    initBookmarks();\n                } catch ( final IOException e ) {\n                    Log.logException(e);\n                }\n            }\n        }.start();\n\n        // define a realtime parsable mimetype list\n        this.log.logConfig(\"Parser: Initializing Mime Type deny list\");\n        \n    \tfinal boolean enableAudioTags = getConfigBool(\"parser.enableAudioTags\", false);\n        log.logConfig(\"Parser: parser.enableAudioTags= \"+enableAudioTags);\n    \tfinal StringBuilder denyExt = new StringBuilder(256);\n    \tfinal StringBuilder denyMime = new StringBuilder(256);\n    \tdenyExt.append(getConfig(SwitchboardConstants.PARSER_MIME_DENY, \"\"));\n    \tdenyMime.append(getConfig(SwitchboardConstants.PARSER_EXTENSIONS_DENY, \"\"));\n    \t\n    \tif (!enableAudioTags) {\n    \t\tif(denyExt.length()>0) {\n    \t\t\tdenyExt.append(audioTagParser.SEPERATOR);\n    \t\t}\n    \t\tdenyExt.append(audioTagParser.EXTENSIONS);\n    \t\t\n    \t\tif(denyMime.length()>0) {\n    \t\t\tdenyMime.append(audioTagParser.SEPERATOR);\n    \t\t}\n    \t\tdenyMime.append(audioTagParser.MIME_TYPES);\n        \t\n        \tsetConfig(SwitchboardConstants.PARSER_EXTENSIONS_DENY, denyExt.toString());\n        \tsetConfig(SwitchboardConstants.PARSER_MIME_DENY, denyMime.toString());\n        \tsetConfig(\"parser.enableAudioTags\", true);\n        }\n                \n    \tTextParser.setDenyMime(getConfig(SwitchboardConstants.PARSER_MIME_DENY, \"\"));\n        TextParser.setDenyExtension(getConfig(SwitchboardConstants.PARSER_EXTENSIONS_DENY, \"\"));\n\n        // start a loader\n        this.log.logConfig(\"Starting Crawl Loader\");\n        this.loader = new LoaderDispatcher(this);\n        \n        // load the robots.txt db\n        this.log.logConfig(\"Initializing robots.txt DB\");\n        this.robots = new RobotsTxt(this.tables, this.loader);\n        try {\n            this.log.logConfig(\"Loaded robots.txt DB: \" + this.robots.size() + \" entries\");\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n\n        // load oai tables\n        final Map<String, File> oaiFriends =\n            OAIListFriendsLoader.loadListFriendsSources(\n                new File(\"defaults/oaiListFriendsSource.xml\"),\n                getDataPath());\n        OAIListFriendsLoader.init(this.loader, oaiFriends);\n        this.crawlQueues = new CrawlQueues(this, this.queuesRoot);\n        this.crawlQueues.noticeURL.setMinimumDelta(\n            getConfigInt(\"minimumLocalDelta\", this.crawlQueues.noticeURL.getMinimumLocalDelta()),\n            getConfigInt(\"minimumGlobalDelta\", this.crawlQueues.noticeURL.getMinimumGlobalDelta()));\n\n        // on startup, resume all crawls\n        setConfig(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL + \"_isPaused\", \"false\");\n        setConfig(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL + \"_isPaused_cause\", \"\");\n        setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL + \"_isPaused\", \"false\");\n        setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL + \"_isPaused_cause\", \"\");\n        setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER + \"_isPaused\", \"false\");\n        setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER + \"_isPaused_cause\", \"\");\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, new Object[] {new Object(), false});\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, new Object[] {new Object(), false});\n        this.crawlJobsStatus.put(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER, new Object[] {new Object(), false});\n\n        // init cookie-Monitor\n        this.log.logConfig(\"Starting Cookie Monitor\");\n        this.outgoingCookies = new ConcurrentHashMap<String, Object[]>();\n        this.incomingCookies = new ConcurrentHashMap<String, Object[]>();\n\n        // init search history trackers\n        this.localSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>(); // String:TreeSet - IP:set of Long(accessTime)\n        this.remoteSearchTracker = new ConcurrentHashMap<String, TreeSet<Long>>();\n\n        // init messages: clean up message symbol\n        final File notifierSource =\n            new File(getAppPath(), getConfig(\n                SwitchboardConstants.HTROOT_PATH,\n                SwitchboardConstants.HTROOT_PATH_DEFAULT) + \"/env/grafics/empty.gif\");\n        final File notifierDest =\n            new File(\n                getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT),\n                \"notifier.gif\");\n        try {\n            Files.copy(notifierSource, notifierDest);\n        } catch ( final IOException e ) {\n        }\n\n        // init nameCacheNoCachingList\n        try {\n            Domains.setNoCachingPatterns(getConfig(SwitchboardConstants.HTTPC_NAME_CACHE_CACHING_PATTERNS_NO, \"\"));\n        } catch (PatternSyntaxException pse) {\n            Log.logSevere(\"Switchboard\", \"Invalid regular expression in \"\n                            + SwitchboardConstants.HTTPC_NAME_CACHE_CACHING_PATTERNS_NO\n                            + \" property: \" + pse.getMessage());\n            System.exit(-1);\n        }\n\n        // generate snippets cache\n        this.log.logConfig(\"Initializing Snippet Cache\");\n\n        // init the wiki\n        wikiParser = new WikiCode();\n\n        // initializing the resourceObserver\n        InstantBusyThread.oneTimeJob(ResourceObserver.class, \"initThread\", 0);\n\n        // initializing the stackCrawlThread\n        this.crawlStacker =\n            new CrawlStacker(\n                this.robots,\n                this.crawlQueues,\n                this.crawler,\n                this.index,\n                this.peers,\n                isIntranetMode(),\n                isGlobalMode(),\n                this.domainList); // Intranet and Global mode may be both true!\n\n        // possibly switch off localIP check\n        Domains.setNoLocalCheck(isAllIPMode());\n\n        // check status of account configuration: when local url crawling is allowed, it is not allowed\n        // that an automatic authorization of localhost is done, because in this case crawls from local\n        // addresses are blocked to prevent attack szenarios where remote pages contain links to localhost\n        // addresses that can steer a YaCy peer\n        if ( !getConfigBool(\"adminAccountForLocalhost\", false) ) {\n            if ( getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").startsWith(\"0000\") ) {\n                // the password was set automatically with a random value.\n                // We must remove that here to prevent that a user cannot log in any more\n                setConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n                // after this a message must be generated to alert the user to set a new password\n                this.log.logInfo(\"RANDOM PASSWORD REMOVED! User must set a new password\");\n            }\n        }\n\n        // initializing dht chunk generation\n        this.dhtMaxReferenceCount = (int) getConfigLong(SwitchboardConstants.INDEX_DIST_CHUNK_SIZE_START, 50);\n\n        // init robinson cluster\n        // before we do that, we wait some time until the seed list is loaded.\n        this.clusterhashes = this.peers.clusterHashes(getConfig(\"cluster.peers.yacydomain\", \"\"));\n\n        // deploy blocking threads\n        this.indexingStorageProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"storeDocumentIndex\",\n                \"This is the sequencing step of the indexing queue. Files are written as streams, too much councurrency would destroy IO performance. In this process the words are written to the RWI cache, which flushes if it is full.\",\n                new String[] {\n                    \"RWI/Cache/Collections\"\n                },\n                this,\n                \"storeDocumentIndex\",\n                2,\n                null,\n                1 /*Math.max(1, WorkflowProcessor.availableCPU / 2)*/);\n        this.indexingAnalysisProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"webStructureAnalysis\",\n                \"This just stores the link structure of the document into a web structure database.\",\n                new String[] {\n                    \"storeDocumentIndex\"\n                },\n                this,\n                \"webStructureAnalysis\",\n                WorkflowProcessor.availableCPU + 1,\n                this.indexingStorageProcessor,\n                WorkflowProcessor.availableCPU);\n        this.indexingCondensementProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"condenseDocument\",\n                \"This does a structural analysis of plain texts: markup of headlines, slicing into phrases (i.e. sentences), markup with position, counting of words, calculation of term frequency.\",\n                new String[] {\n                    \"webStructureAnalysis\"\n                },\n                this,\n                \"condenseDocument\",\n                WorkflowProcessor.availableCPU + 1,\n                this.indexingAnalysisProcessor,\n                WorkflowProcessor.availableCPU);\n        this.indexingDocumentProcessor =\n            new WorkflowProcessor<IndexingQueueEntry>(\n                \"parseDocument\",\n                \"This does the parsing of the newly loaded documents from the web. The result is not only a plain text document, but also a list of URLs that are embedded into the document. The urls are handed over to the CrawlStacker. This process has two child process queues!\",\n                new String[] {\n                    \"condenseDocument\", \"CrawlStacker\"\n                },\n                this,\n                \"parseDocument\",\n                Math.max(20, WorkflowProcessor.availableCPU * 2), // it may happen that this is filled with new files from the search process. That means there should be enough place for two result pages\n                this.indexingCondensementProcessor,\n                WorkflowProcessor.availableCPU);\n\n        // deploy busy threads\n        this.log.logConfig(\"Starting Threads\");\n        MemoryControl.gc(10000, \"plasmaSwitchboard, help for profiler\"); // help for profiler - thq\n\n        deployThread(\n            SwitchboardConstants.CLEANUP,\n            \"Cleanup\",\n            \"simple cleaning process for monitoring information\",\n            null,\n            new InstantBusyThread(\n                this,\n                SwitchboardConstants.CLEANUP_METHOD_START,\n                SwitchboardConstants.CLEANUP_METHOD_JOBCOUNT,\n                SwitchboardConstants.CLEANUP_METHOD_FREEMEM,\n                60000,\n                Long.MAX_VALUE,\n                10000,\n                Long.MAX_VALUE),\n            60000); // all 5 Minutes, wait 1 minute until first run\n        deployThread(\n                SwitchboardConstants.SEARCHRESULT,\n                \"Search Result Flush\",\n                \"A thread that stores search results from other peers into the own index.\",\n                null,\n                new InstantBusyThread(\n                    this,\n                    SwitchboardConstants.SEARCHRESULT_METHOD_START,\n                    SwitchboardConstants.SEARCHRESULT_METHOD_JOBCOUNT,\n                    SwitchboardConstants.SEARCHRESULT_METHOD_FREEMEM,\n                    20000,\n                    Long.MAX_VALUE,\n                    0,\n                    Long.MAX_VALUE),\n                30000);\n        deployThread(\n            SwitchboardConstants.SURROGATES,\n            \"Surrogates\",\n            \"A thread that polls the SURROGATES path and puts all Documents in one surroagte file into the indexing queue.\",\n            null,\n            new InstantBusyThread(\n                this,\n                SwitchboardConstants.SURROGATES_METHOD_START,\n                SwitchboardConstants.SURROGATES_METHOD_JOBCOUNT,\n                SwitchboardConstants.SURROGATES_METHOD_FREEMEM,\n                20000,\n                Long.MAX_VALUE,\n                0,\n                Long.MAX_VALUE),\n            10000);\n        deployThread(\n            SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL,\n            \"Remote Crawl Job\",\n            \"thread that performes a single crawl/indexing step triggered by a remote peer\",\n            \"/IndexCreateWWWRemoteQueue_p.html\",\n            new InstantBusyThread(\n                this.crawlQueues,\n                SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_START,\n                SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_JOBCOUNT,\n                SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_METHOD_FREEMEM,\n                0,\n                Long.MAX_VALUE,\n                0,\n                Long.MAX_VALUE),\n            10000);\n        deployThread(\n            SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER,\n            \"Remote Crawl URL Loader\",\n            \"thread that loads remote crawl lists from other peers\",\n            null,\n            new InstantBusyThread(\n                this.crawlQueues,\n                SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_START,\n                SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_JOBCOUNT,\n                SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_METHOD_FREEMEM,\n                10000,\n                Long.MAX_VALUE,\n                10000,\n                Long.MAX_VALUE),\n            10000); // error here?\n        deployThread(\n            SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL,\n            \"Local Crawl\",\n            \"thread that performes a single crawl step from the local crawl queue\",\n            \"/IndexCreateWWWLocalQueue_p.html\",\n            new InstantBusyThread(\n                this.crawlQueues,\n                SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_START,\n                SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_JOBCOUNT,\n                SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL_METHOD_FREEMEM,\n                0,\n                Long.MAX_VALUE,\n                0,\n                Long.MAX_VALUE),\n            10000);\n        deployThread(\n            SwitchboardConstants.SEED_UPLOAD,\n            \"Seed-List Upload\",\n            \"task that a principal peer performes to generate and upload a seed-list to a ftp account\",\n            null,\n            new InstantBusyThread(\n                this.yc,\n                SwitchboardConstants.SEED_UPLOAD_METHOD_START,\n                SwitchboardConstants.SEED_UPLOAD_METHOD_JOBCOUNT,\n                SwitchboardConstants.SEED_UPLOAD_METHOD_FREEMEM,\n                600000,\n                Long.MAX_VALUE,\n                300000,\n                Long.MAX_VALUE),\n            180000);\n        deployThread(\n            SwitchboardConstants.PEER_PING,\n            \"YaCy Core\",\n            \"this is the p2p-control and peer-ping task\",\n            null,\n            new InstantBusyThread(\n                this.yc,\n                SwitchboardConstants.PEER_PING_METHOD_START,\n                SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\n                SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\n                30000,\n                Long.MAX_VALUE,\n                30000,\n                Long.MAX_VALUE),\n            2000);\n        deployThread(\n            SwitchboardConstants.INDEX_DIST,\n            \"DHT Distribution\",\n            \"selection, transfer and deletion of index entries that are not searched on your peer, but on others\",\n            null,\n            new InstantBusyThread(\n                this,\n                SwitchboardConstants.INDEX_DIST_METHOD_START,\n                SwitchboardConstants.INDEX_DIST_METHOD_JOBCOUNT,\n                SwitchboardConstants.INDEX_DIST_METHOD_FREEMEM,\n                10000,\n                Long.MAX_VALUE,\n                1000,\n                Long.MAX_VALUE),\n            5000,\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_IDLESLEEP, \"5000\")),\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_BUSYSLEEP, \"0\")),\n            Long.parseLong(getConfig(SwitchboardConstants.INDEX_DIST_MEMPREREQ, \"1000000\")));\n\n        // content control: initialize list sync thread\n        deployThread(\n                \"720_ccimport\",\n                \"Content Control Import\",\n                \"this is the content control import thread\",\n                null,\n                new InstantBusyThread(\n                    new SMWListSyncThread(this, sb.getConfig(\"contentcontrol.bookmarklist\", \"contentcontrol\"), \"Category:Content Source\", \"/?Url/?Filter/?Category/?Modification date\", sb.getConfigBool(\n            \t\t\t\t\"contentcontrol.smwimport.purgelistoninit\", false)),\n                    \"run\",\n                    SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\n                    SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\n                    3000,\n                    10000,\n                    3000,\n                    10000),\n                2000);\n        deployThread(\n                \"730_ccfilter\",\n                \"Content Control Filter\",\n                \"this is the content control filter update thread\",\n                null,\n                new InstantBusyThread(\n                    new ContentControlFilterUpdateThread(this),\n                    \"run\",\n                    SwitchboardConstants.PEER_PING_METHOD_JOBCOUNT,\n                    SwitchboardConstants.PEER_PING_METHOD_FREEMEM,\n                    3000,\n                    10000,\n                    3000,\n                    10000),\n                2000);\n\n        // set network-specific performance attributes\n        if ( this.firstInit ) {\n            setRemotecrawlPPM(Math.max(1, (int) getConfigLong(\"network.unit.remotecrawl.speed\", 60)));\n        }\n\n        // test routine for snippet fetch\n        //Set query = new HashSet();\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Weitergabe\"));\n        //query.add(CrawlSwitchboardEntry.word2hash(\"Zahl\"));\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/mobil/newsticker/meldung/mail/54980\"), query, true);\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/security/news/foren/go.shtml?read=1&msg_id=7301419&forum_id=72721\"), query, true);\n        //plasmaSnippetCache.result scr = snippetCache.retrieve(new URL(\"http://www.heise.de/kiosk/archiv/ct/2003/4/20\"), query, true, 260);\n\n        this.trail = new LinkedBlockingQueue<String>();\n        \n        // finally start jobs which shall be started after start-up\n        new Thread() {\n            public void run() {\n                try {Thread.sleep(10000);} catch (InterruptedException e) {} // we must wait until the httpd comes up\n                execAPIActions(); // trigger startup actions\n            }\n        }.start();\n\n        this.log.logConfig(\"Finished Switchboard Initialization\");\n    }","commit_id":"a20941c067f8b64acab9a3aa16ffb0b49bb9d82a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n   * Register an Annotator that can be created by the pool.\n   *\n   * Note that factories are used here so that many possible annotators can\n   * be defined within the AnnotatorPool, but an Annotator is only created\n   * when one is actually needed.\n   *\n   * @param name    The name to be associated with the Annotator.\n   * @param factory A factory that creates an instance of the desired Annotator.\n   * @return true if a new annotator was created; false if we reuse an existing one\n   */\n  public boolean register(String name, AnnotatorFactory factory) {\n    boolean newAnnotator = false;\n    if (this.factories.containsKey(name)) {\n      AnnotatorFactory oldFactory = this.factories.get(name);\n      String oldSig = oldFactory.signature();\n      String newSig = factory.signature();\n      if(! oldSig.equals(newSig)) {\n        // the new annotator uses different properties so we need to update!\n        // TODO: this printout should be logged instead of going to stderr. we need to standardize logging\n        System.err.println(\"Replacing old annotator \\\"\" + name + \"\\\" with signature [\"\n                + oldSig + \"] with new annotator with signature [\" + newSig + \"]\");\n        this.factories.put(name, factory);\n        newAnnotator = true;\n\n        // delete the existing annotator; we'll create one with the new props on demand\n        annotators.remove(name);\n      }\n      // nothing to do if an annotator with same name and signature already exists\n    } else {\n      this.factories.put(name, factory);\n    }\n    return newAnnotator;\n  }","id":104849,"modified_method":"/**\n   * Register an Annotator that can be created by the pool.\n   *\n   * Note that factories are used here so that many possible annotators can\n   * be defined within the AnnotatorPool, but an Annotator is only created\n   * when one is actually needed.\n   *\n   * @param name    The name to be associated with the Annotator.\n   * @param factory A factory that creates an instance of the desired Annotator.\n   * @return true if a new annotator was created; false if we reuse an existing one\n   */\n  public boolean register(String name, AnnotatorFactory factory) {\n    boolean newAnnotator = false;\n    if (this.factories.containsKey(name)) {\n      AnnotatorFactory oldFactory = this.factories.get(name);\n      String oldSig = oldFactory.signature();\n      String newSig = factory.signature();\n      if(! oldSig.equals(newSig)) {\n        // the new annotator uses different properties so we need to update!\n        // TODO: this printout should be logged instead of going to stderr. we need to standardize logging\n        // System.err.println(\"Replacing old annotator \\\"\" + name + \"\\\" with signature [\"\n        //         + oldSig + \"] with new annotator with signature [\" + newSig + \"]\");\n        this.factories.put(name, factory);\n        newAnnotator = true;\n\n        // delete the existing annotator; we'll create one with the new props on demand\n        // removing the annotator like this will not affect any\n        // existing pipelines which use the old annotator, but if\n        // those are all gone, then the old annotator will be garbage\n        // collected and memory will be freed up\n        annotators.remove(name);\n      }\n      // nothing to do if an annotator with same name and signature already exists\n    } else {\n      this.factories.put(name, factory);\n    }\n    return newAnnotator;\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    os.append(annotatorName + \".binaryTrees:\" + \n              props.getProperty(annotatorName + \".binaryTrees\", \"false\"));\n    return os.toString();\n  }","id":104850,"modified_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    boolean usesBinary = StanfordCoreNLP.usesBinaryTrees(props);\n    boolean saveBinaryTrees = PropertiesUtils.getBool(props, annotatorName + \".binaryTrees\", usesBinary);\n    os.append(annotatorName + \".binaryTrees:\" + saveBinaryTrees);\n\n    return os.toString();\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void annotate(Annotation annotation) {\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // TODO: parallelize\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      for (CoreMap sentence : sentences) {\n        Tree binarized = sentence.get(TreeCoreAnnotations.BinarizedTreeAnnotation.class);\n        Tree collapsedUnary = transformer.transformTree(binarized);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(model, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.AnnotatedTree.class, collapsedUnary);\n        int sentiment = RNNCoreAnnotations.getPredictedClass(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.ClassName.class, SentimentUtils.sentimentString(model, sentiment));\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","id":104851,"modified_method":"public void annotate(Annotation annotation) {\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // TODO: parallelize\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      for (CoreMap sentence : sentences) {\n        Tree binarized = sentence.get(TreeCoreAnnotations.BinarizedTreeAnnotation.class);\n        if (binarized == null) {\n          throw new AssertionError(\"Binarized sentences not built by parser\");\n        }\n        Tree collapsedUnary = transformer.transformTree(binarized);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(model, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.AnnotatedTree.class, collapsedUnary);\n        int sentiment = RNNCoreAnnotations.getPredictedClass(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.ClassName.class, SentimentUtils.sentimentString(model, sentiment));\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static Annotation getAnnotation(Input inputFormat, String filename, boolean filterUnknown) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      return annotation;\n    }\n    case TREES: {\n      List<Tree> trees = SentimentUtils.readTreesWithGoldLabels(filename);\n      if (filterUnknown) {\n        trees = SentimentUtils.filterUnknownRoots(trees);\n      }\n      List<CoreMap> sentences = Generics.newArrayList();\n      \n      for (Tree tree : trees) {\n        CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n        sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n        sentences.add(sentence);\n      }\n      Annotation annotation = new Annotation(\"\");\n      annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n      return annotation;\n    }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","id":104852,"modified_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static List<Annotation> getAnnotations(StanfordCoreNLP tokenizer, Input inputFormat, String filename, boolean filterUnknown) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      tokenizer.annotate(annotation);\n      List<Annotation> annotations = Generics.newArrayList();\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Annotation nextAnnotation = new Annotation(sentence.get(CoreAnnotations.TextAnnotation.class));\n        nextAnnotation.set(CoreAnnotations.SentencesAnnotation.class, Collections.singletonList(sentence));\n        annotations.add(nextAnnotation);\n      }\n      return annotations;\n    }\n    case TREES: {\n      List<Tree> trees;\n      if (filterUnknown) {\n        trees = SentimentUtils.readTreesWithGoldLabels(filename);\n        trees = SentimentUtils.filterUnknownRoots(trees);\n      } else {\n        trees = Generics.newArrayList();\n        MemoryTreebank treebank = new MemoryTreebank(\"utf-8\");\n        treebank.loadPath(filename, null);\n        for (Tree tree : treebank) {\n          trees.add(tree);\n        }\n      }\n      \n      List<Annotation> annotations = Generics.newArrayList();\n      for (Tree tree : trees) {\n        CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n        sentence.set(TreeCoreAnnotations.TreeAnnotation.class, tree);\n        List<CoreMap> sentences = Collections.singletonList(sentence);\n        Annotation annotation = new Annotation(\"\");\n        annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n        annotations.add(annotation);\n      }\n      return annotations;\n    }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    boolean filterUnknown = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-filterUnknown\")) {\n        filterUnknown = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      props.setProperty(\"annotators\", \"sentiment\");\n      props.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      Annotation annotation = getAnnotation(inputFormat, filename, filterUnknown);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        System.out.println(sentence);\n        outputTree(System.out, sentence, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        Annotation annotation = getAnnotation(inputFormat, file, filterUnknown);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          pout.println(sentence);\n          outputTree(pout, sentence, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            outputTree(System.out, sentence, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","id":104853,"modified_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    boolean filterUnknown = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    String tlppClass = DEFAULT_TLPP_CLASS;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-filterUnknown\")) {\n        filterUnknown = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-tlppClass\")) {\n        tlppClass = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        help();\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    // We construct two pipelines.  One handles tokenization, if\n    // necessary.  The other takes tokenized sentences and converts\n    // them to sentiment trees.\n    Properties pipelineProps = new Properties();\n    Properties tokenizerProps = null;\n    if (sentimentModel != null) {\n      pipelineProps.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      pipelineProps.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      pipelineProps.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      pipelineProps.setProperty(\"annotators\", \"binarizer, sentiment\");\n      pipelineProps.setProperty(\"customAnnotatorClass.binarizer\", \"edu.stanford.nlp.pipeline.BinarizerAnnotator\");\n      pipelineProps.setProperty(\"binarizer.tlppClass\", tlppClass);\n      pipelineProps.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      pipelineProps.setProperty(\"annotators\", \"parse, sentiment\");\n      pipelineProps.setProperty(\"enforceRequirements\", \"false\");\n      tokenizerProps = new Properties();\n      tokenizerProps.setProperty(\"annotators\", \"tokenize, ssplit\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP tokenizer = (tokenizerProps == null) ? null : new StanfordCoreNLP(tokenizerProps);\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(pipelineProps);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      List<Annotation> annotations = getAnnotations(tokenizer, inputFormat, filename, filterUnknown);\n      for (Annotation annotation : annotations) {\n        pipeline.annotate(annotation);\n\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          System.out.println(sentence);\n          outputTree(System.out, sentence, outputFormats);\n        }\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        List<Annotation> annotations = getAnnotations(tokenizer, inputFormat, file, filterUnknown);\n        for (Annotation annotation : annotations) {\n          pipeline.annotate(annotation);\n\n          FileOutputStream fout = new FileOutputStream(file + \".out\");\n          PrintStream pout = new PrintStream(fout);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            pout.println(sentence);\n            outputTree(pout, sentence, outputFormats);\n          }\n          pout.flush();\n          fout.close();\n        }\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = tokenizer.process(line);\n          pipeline.annotate(annotation);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            outputTree(System.out, sentence, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void help() {\n    System.err.println(\"Known command line arguments:\");\n    System.err.println(\"  -sentimentModel <model>: Which model to use\");\n    System.err.println(\"  -parserModel <model>: Which parser to use\");\n    System.err.println(\"  -file <filename>: Which file to process\");\n    System.err.println(\"  -fileList <file>,<file>,...: Comma separated list of files to process.  Output goes to file.out\");\n    System.err.println(\"  -stdin: Process stdin instead of a file\");\n    System.err.println(\"  -input <format>: Which format to input, TEXT or TREES.  Will not process stdin as trees.  Trees need to be binarized\");\n    System.err.println(\"  -output <format>: Which format to output, PENNTREES, VECTORS, PROBABILITIES, or ROOT.  Multiple formats can be specified as a comma separated list.\");\n    System.err.println(\"  -filterUnknown: remove neutral and unknown trees from the input.  Only applies to TREES input\");\n  }","id":104854,"modified_method":"public static void help() {\n    System.err.println(\"Known command line arguments:\");\n    System.err.println(\"  -sentimentModel <model>: Which model to use\");\n    System.err.println(\"  -parserModel <model>: Which parser to use\");\n    System.err.println(\"  -file <filename>: Which file to process\");\n    System.err.println(\"  -fileList <file>,<file>,...: Comma separated list of files to process.  Output goes to file.out\");\n    System.err.println(\"  -stdin: Process stdin instead of a file\");\n    System.err.println(\"  -input <format>: Which format to input, TEXT or TREES.  Will not process stdin as trees.  If trees are not already binarized, they will be binarized with -tlppClass's headfinder, which means they must have labels in that treebank's tagset.\");\n    System.err.println(\"  -output <format>: Which format to output, PENNTREES, VECTORS, PROBABILITIES, or ROOT.  Multiple formats can be specified as a comma separated list.\");\n    System.err.println(\"  -filterUnknown: remove unknown trees from the input.  Only applies to TREES input, in which case the trees must be binarized with sentiment labels\");\n    System.err.println(\"  -tlppClass: a class to use for building the binarizer if using non-binarized TREES as input.  Defaults to \" + DEFAULT_TLPP_CLASS);\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\", PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n          // If they\n          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {\n            keepNewline = true;\n          }\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n\n    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new SentimentAnnotator(STANFORD_SENTIMENT, properties);\n      }\n\n      @Override\n      public String signature() {\n        return \"model=\" + inputProps.get(\"model\");\n      }\n    });\n\n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":104855,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\", PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n          // If they\n          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {\n            keepNewline = true;\n          }\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parse\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n\n    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new SentimentAnnotator(STANFORD_SENTIMENT, properties);\n      }\n\n      @Override\n      public String signature() {\n        return \"model=\" + inputProps.get(\"model\");\n      }\n    });\n\n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"43c8c7a27e375d7ab671c0575f7c1491f56e376b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Register an Annotator that can be created by the pool.\n   *\n   * Note that factories are used here so that many possible annotators can\n   * be defined within the AnnotatorPool, but an Annotator is only created\n   * when one is actually needed.\n   *\n   * @param name    The name to be associated with the Annotator.\n   * @param factory A factory that creates an instance of the desired Annotator.\n   * @return true if a new annotator was created; false if we reuse an existing one\n   */\n  public boolean register(String name, AnnotatorFactory factory) {\n    boolean newAnnotator = false;\n    if (this.factories.containsKey(name)) {\n      AnnotatorFactory oldFactory = this.factories.get(name);\n      String oldSig = oldFactory.signature();\n      String newSig = factory.signature();\n      if(! oldSig.equals(newSig)) {\n        // the new annotator uses different properties so we need to update!\n        // TODO: this printout should be logged instead of going to stderr. we need to standardize logging\n        System.err.println(\"Replacing old annotator \\\"\" + name + \"\\\" with signature [\"\n                + oldSig + \"] with new annotator with signature [\" + newSig + \"]\");\n        this.factories.put(name, factory);\n        newAnnotator = true;\n\n        // delete the existing annotator; we'll create one with the new props on demand\n        annotators.remove(name);\n      }\n      // nothing to do if an annotator with same name and signature already exists\n    } else {\n      this.factories.put(name, factory);\n    }\n    return newAnnotator;\n  }","id":104856,"modified_method":"/**\n   * Register an Annotator that can be created by the pool.\n   *\n   * Note that factories are used here so that many possible annotators can\n   * be defined within the AnnotatorPool, but an Annotator is only created\n   * when one is actually needed.\n   *\n   * @param name    The name to be associated with the Annotator.\n   * @param factory A factory that creates an instance of the desired Annotator.\n   * @return true if a new annotator was created; false if we reuse an existing one\n   */\n  public boolean register(String name, AnnotatorFactory factory) {\n    boolean newAnnotator = false;\n    if (this.factories.containsKey(name)) {\n      AnnotatorFactory oldFactory = this.factories.get(name);\n      String oldSig = oldFactory.signature();\n      String newSig = factory.signature();\n      if(! oldSig.equals(newSig)) {\n        // the new annotator uses different properties so we need to update!\n        // TODO: this printout should be logged instead of going to stderr. we need to standardize logging\n        // System.err.println(\"Replacing old annotator \\\"\" + name + \"\\\" with signature [\"\n        //         + oldSig + \"] with new annotator with signature [\" + newSig + \"]\");\n        this.factories.put(name, factory);\n        newAnnotator = true;\n\n        // delete the existing annotator; we'll create one with the new props on demand\n        // removing the annotator like this will not affect any\n        // existing pipelines which use the old annotator, but if\n        // those are all gone, then the old annotator will be garbage\n        // collected and memory will be freed up\n        annotators.remove(name);\n      }\n      // nothing to do if an annotator with same name and signature already exists\n    } else {\n      this.factories.put(name, factory);\n    }\n    return newAnnotator;\n  }","commit_id":"55037be2db48af18d01b52e297abd30fd41c6e94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    os.append(annotatorName + \".binaryTrees:\" + \n              props.getProperty(annotatorName + \".binaryTrees\", \"false\"));\n    return os.toString();\n  }","id":104857,"modified_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    boolean usesBinary = StanfordCoreNLP.usesBinaryTrees(props);\n    boolean saveBinaryTrees = PropertiesUtils.getBool(props, annotatorName + \".binaryTrees\", usesBinary);\n    os.append(annotatorName + \".binaryTrees:\" + saveBinaryTrees);\n\n    return os.toString();\n  }","commit_id":"55037be2db48af18d01b52e297abd30fd41c6e94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void annotate(Annotation annotation) {\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // TODO: parallelize\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      for (CoreMap sentence : sentences) {\n        Tree binarized = sentence.get(TreeCoreAnnotations.BinarizedTreeAnnotation.class);\n        Tree collapsedUnary = transformer.transformTree(binarized);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(model, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.AnnotatedTree.class, collapsedUnary);\n        int sentiment = RNNCoreAnnotations.getPredictedClass(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.ClassName.class, SentimentUtils.sentimentString(model, sentiment));\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","id":104858,"modified_method":"public void annotate(Annotation annotation) {\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // TODO: parallelize\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      for (CoreMap sentence : sentences) {\n        Tree binarized = sentence.get(TreeCoreAnnotations.BinarizedTreeAnnotation.class);\n        if (binarized == null) {\n          throw new AssertionError(\"Binarized sentences not built by parser\");\n        }\n        Tree collapsedUnary = transformer.transformTree(binarized);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(model, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.AnnotatedTree.class, collapsedUnary);\n        int sentiment = RNNCoreAnnotations.getPredictedClass(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.ClassName.class, SentimentUtils.sentimentString(model, sentiment));\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","commit_id":"55037be2db48af18d01b52e297abd30fd41c6e94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static Annotation getAnnotation(Input inputFormat, String filename, boolean filterUnknown) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      return annotation;\n    }\n    case TREES: {\n      List<Tree> trees = SentimentUtils.readTreesWithGoldLabels(filename);\n      if (filterUnknown) {\n        trees = SentimentUtils.filterUnknownRoots(trees);\n      }\n      List<CoreMap> sentences = Generics.newArrayList();\n      \n      for (Tree tree : trees) {\n        CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n        sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n        sentences.add(sentence);\n      }\n      Annotation annotation = new Annotation(\"\");\n      annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n      return annotation;\n    }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","id":104859,"modified_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static List<Annotation> getAnnotations(StanfordCoreNLP tokenizer, Input inputFormat, String filename, boolean filterUnknown) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      tokenizer.annotate(annotation);\n      List<Annotation> annotations = Generics.newArrayList();\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Annotation nextAnnotation = new Annotation(sentence.get(CoreAnnotations.TextAnnotation.class));\n        nextAnnotation.set(CoreAnnotations.SentencesAnnotation.class, Collections.singletonList(sentence));\n        annotations.add(nextAnnotation);\n      }\n      return annotations;\n    }\n    case TREES: {\n      List<Tree> trees = SentimentUtils.readTreesWithGoldLabels(filename);\n      if (filterUnknown) {\n        trees = SentimentUtils.filterUnknownRoots(trees);\n      }\n      \n      List<Annotation> annotations = Generics.newArrayList();\n      for (Tree tree : trees) {\n        CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n        sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n        List<CoreMap> sentences = Collections.singletonList(sentence);\n        Annotation annotation = new Annotation(\"\");\n        annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n        annotations.add(annotation);\n      }\n      return annotations;\n    }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","commit_id":"55037be2db48af18d01b52e297abd30fd41c6e94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    boolean filterUnknown = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-filterUnknown\")) {\n        filterUnknown = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      props.setProperty(\"annotators\", \"sentiment\");\n      props.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      Annotation annotation = getAnnotation(inputFormat, filename, filterUnknown);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        System.out.println(sentence);\n        outputTree(System.out, sentence, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        Annotation annotation = getAnnotation(inputFormat, file, filterUnknown);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          pout.println(sentence);\n          outputTree(pout, sentence, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            outputTree(System.out, sentence, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","id":104860,"modified_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    boolean filterUnknown = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-filterUnknown\")) {\n        filterUnknown = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        help();\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    // We construct two pipelines.  One handles tokenization, if\n    // necessary.  The other takes tokenized sentences and converts\n    // them to sentiment trees.\n    Properties pipelineProps = new Properties();\n    Properties tokenizerProps = null;\n    if (sentimentModel != null) {\n      pipelineProps.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      pipelineProps.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      pipelineProps.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      pipelineProps.setProperty(\"annotators\", \"sentiment\");\n      pipelineProps.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      pipelineProps.setProperty(\"annotators\", \"parse, sentiment\");\n      pipelineProps.setProperty(\"enforceRequirements\", \"false\");\n      tokenizerProps = new Properties();\n      tokenizerProps.setProperty(\"annotators\", \"tokenize, ssplit\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP tokenizer = (tokenizerProps == null) ? null : new StanfordCoreNLP(tokenizerProps);\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(pipelineProps);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      List<Annotation> annotations = getAnnotations(tokenizer, inputFormat, filename, filterUnknown);\n      for (Annotation annotation : annotations) {\n        pipeline.annotate(annotation);\n\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          System.out.println(sentence);\n          outputTree(System.out, sentence, outputFormats);\n        }\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        List<Annotation> annotations = getAnnotations(tokenizer, inputFormat, file, filterUnknown);\n        for (Annotation annotation : annotations) {\n          pipeline.annotate(annotation);\n\n          FileOutputStream fout = new FileOutputStream(file + \".out\");\n          PrintStream pout = new PrintStream(fout);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            pout.println(sentence);\n            outputTree(pout, sentence, outputFormats);\n          }\n          pout.flush();\n          fout.close();\n        }\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = tokenizer.process(line);\n          pipeline.annotate(annotation);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            outputTree(System.out, sentence, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","commit_id":"55037be2db48af18d01b52e297abd30fd41c6e94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\", PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n          // If they\n          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {\n            keepNewline = true;\n          }\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n\n    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new SentimentAnnotator(STANFORD_SENTIMENT, properties);\n      }\n\n      @Override\n      public String signature() {\n        return \"model=\" + inputProps.get(\"model\");\n      }\n    });\n\n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":104861,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\", PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n          // If they\n          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {\n            keepNewline = true;\n          }\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parse\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n\n    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new SentimentAnnotator(STANFORD_SENTIMENT, properties);\n      }\n\n      @Override\n      public String signature() {\n        return \"model=\" + inputProps.get(\"model\");\n      }\n    });\n\n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"55037be2db48af18d01b52e297abd30fd41c6e94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Register an Annotator that can be created by the pool.\n   *\n   * Note that factories are used here so that many possible annotators can\n   * be defined within the AnnotatorPool, but an Annotator is only created\n   * when one is actually needed.\n   *\n   * @param name    The name to be associated with the Annotator.\n   * @param factory A factory that creates an instance of the desired Annotator.\n   * @return true if a new annotator was created; false if we reuse an existing one\n   */\n  public boolean register(String name, AnnotatorFactory factory) {\n    boolean newAnnotator = false;\n    if (this.factories.containsKey(name)) {\n      AnnotatorFactory oldFactory = this.factories.get(name);\n      String oldSig = oldFactory.signature();\n      String newSig = factory.signature();\n      if(! oldSig.equals(newSig)) {\n        // the new annotator uses different properties so we need to update!\n        // TODO: this printout should be logged instead of going to stderr. we need to standardize logging\n        System.err.println(\"Replacing old annotator \\\"\" + name + \"\\\" with signature [\"\n                + oldSig + \"] with new annotator with signature [\" + newSig + \"]\");\n        this.factories.put(name, factory);\n        newAnnotator = true;\n\n        // delete the existing annotator; we'll create one with the new props on demand\n        annotators.remove(name);\n      }\n      // nothing to do if an annotator with same name and signature already exists\n    } else {\n      this.factories.put(name, factory);\n    }\n    return newAnnotator;\n  }","id":104862,"modified_method":"/**\n   * Register an Annotator that can be created by the pool.\n   *\n   * Note that factories are used here so that many possible annotators can\n   * be defined within the AnnotatorPool, but an Annotator is only created\n   * when one is actually needed.\n   *\n   * @param name    The name to be associated with the Annotator.\n   * @param factory A factory that creates an instance of the desired Annotator.\n   * @return true if a new annotator was created; false if we reuse an existing one\n   */\n  public boolean register(String name, AnnotatorFactory factory) {\n    boolean newAnnotator = false;\n    if (this.factories.containsKey(name)) {\n      AnnotatorFactory oldFactory = this.factories.get(name);\n      String oldSig = oldFactory.signature();\n      String newSig = factory.signature();\n      if(! oldSig.equals(newSig)) {\n        // the new annotator uses different properties so we need to update!\n        // TODO: this printout should be logged instead of going to stderr. we need to standardize logging\n        // System.err.println(\"Replacing old annotator \\\"\" + name + \"\\\" with signature [\"\n        //         + oldSig + \"] with new annotator with signature [\" + newSig + \"]\");\n        this.factories.put(name, factory);\n        newAnnotator = true;\n\n        // delete the existing annotator; we'll create one with the new props on demand\n        // removing the annotator like this will not affect any\n        // existing pipelines which use the old annotator, but if\n        // those are all gone, then the old annotator will be garbage\n        // collected and memory will be freed up\n        annotators.remove(name);\n      }\n      // nothing to do if an annotator with same name and signature already exists\n    } else {\n      this.factories.put(name, factory);\n    }\n    return newAnnotator;\n  }","commit_id":"643dcce1a361a9be175ab36589cab268c2fa8c15","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    os.append(annotatorName + \".binaryTrees:\" + \n              props.getProperty(annotatorName + \".binaryTrees\", \"false\"));\n    return os.toString();\n  }","id":104863,"modified_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    boolean usesBinary = StanfordCoreNLP.usesBinaryTrees(props);\n    boolean saveBinaryTrees = PropertiesUtils.getBool(props, annotatorName + \".binaryTrees\", usesBinary);\n    os.append(annotatorName + \".binaryTrees:\" + saveBinaryTrees);\n\n    return os.toString();\n  }","commit_id":"643dcce1a361a9be175ab36589cab268c2fa8c15","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void annotate(Annotation annotation) {\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // TODO: parallelize\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      for (CoreMap sentence : sentences) {\n        Tree binarized = sentence.get(TreeCoreAnnotations.BinarizedTreeAnnotation.class);\n        Tree collapsedUnary = transformer.transformTree(binarized);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(model, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.AnnotatedTree.class, collapsedUnary);\n        int sentiment = RNNCoreAnnotations.getPredictedClass(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.ClassName.class, SentimentUtils.sentimentString(model, sentiment));\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","id":104864,"modified_method":"public void annotate(Annotation annotation) {\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // TODO: parallelize\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      for (CoreMap sentence : sentences) {\n        Tree binarized = sentence.get(TreeCoreAnnotations.BinarizedTreeAnnotation.class);\n        if (binarized == null) {\n          throw new AssertionError(\"Binarized sentences not built by parser\");\n        }\n        Tree collapsedUnary = transformer.transformTree(binarized);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(model, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.AnnotatedTree.class, collapsedUnary);\n        int sentiment = RNNCoreAnnotations.getPredictedClass(collapsedUnary);\n        sentence.set(SentimentCoreAnnotations.ClassName.class, SentimentUtils.sentimentString(model, sentiment));\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","commit_id":"643dcce1a361a9be175ab36589cab268c2fa8c15","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    boolean filterUnknown = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-filterUnknown\")) {\n        filterUnknown = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    Properties props = new Properties();\n    if (sentimentModel != null) {\n      props.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      props.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      props.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      props.setProperty(\"annotators\", \"sentiment\");\n      props.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      Annotation annotation = getAnnotation(inputFormat, filename, filterUnknown);\n      pipeline.annotate(annotation);\n\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        System.out.println(sentence);\n        outputTree(System.out, sentence, outputFormats);\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        Annotation annotation = getAnnotation(inputFormat, file, filterUnknown);\n        pipeline.annotate(annotation);\n\n        FileOutputStream fout = new FileOutputStream(file + \".out\");\n        PrintStream pout = new PrintStream(fout);\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          pout.println(sentence);\n          outputTree(pout, sentence, outputFormats);\n        }\n        pout.flush();\n        fout.close();\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = pipeline.process(line);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            outputTree(System.out, sentence, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","id":104865,"modified_method":"public static void main(String[] args) throws IOException {\n    String parserModel = null;\n    String sentimentModel = null;\n\n    String filename = null;\n    String fileList = null;\n    boolean stdin = false;\n\n    boolean filterUnknown = false;\n\n    List<Output> outputFormats = Arrays.asList(new Output[] { Output.ROOT });\n    Input inputFormat = Input.TEXT;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-file\")) {\n        filename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-fileList\")) {\n        fileList = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-stdin\")) {\n        stdin = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputFormat = Input.valueOf(args[argIndex + 1].toUpperCase());\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        String[] formats = args[argIndex + 1].split(\",\");\n        outputFormats = new ArrayList<Output>();\n        for (String format : formats) {\n          outputFormats.add(Output.valueOf(format.toUpperCase()));\n        }\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-filterUnknown\")) {\n        filterUnknown = true;\n        argIndex++;\n      } else if (args[argIndex].equalsIgnoreCase(\"-help\")) {\n        help();\n        System.exit(0);\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex + 1]);\n        help();\n        throw new IllegalArgumentException(\"Unknown argument \" + args[argIndex + 1]);\n      }\n    }\n\n    // We construct two pipelines.  One handles tokenization, if\n    // necessary.  The other takes tokenized sentences and converts\n    // them to sentiment trees.\n    Properties pipelineProps = new Properties();\n    Properties tokenizerProps = null;\n    if (sentimentModel != null) {\n      pipelineProps.setProperty(\"sentiment.model\", sentimentModel);\n    }\n    if (parserModel != null) {\n      pipelineProps.setProperty(\"parse.model\", parserModel);\n    }\n    if (stdin) {\n      pipelineProps.setProperty(\"ssplit.eolonly\", \"true\");\n    }\n    if (inputFormat == Input.TREES) {\n      pipelineProps.setProperty(\"annotators\", \"sentiment\");\n      pipelineProps.setProperty(\"enforceRequirements\", \"false\");\n    } else {\n      pipelineProps.setProperty(\"annotators\", \"parse, sentiment\");\n      pipelineProps.setProperty(\"enforceRequirements\", \"false\");\n      tokenizerProps = new Properties();\n      tokenizerProps.setProperty(\"annotators\", \"tokenize, ssplit\");\n    }\n\n    int count = 0;\n    if (filename != null) count++;\n    if (fileList != null) count++;\n    if (stdin) count++;\n    if (count > 1) {\n      throw new IllegalArgumentException(\"Please only specify one of -file, -fileList or -stdin\");\n    }\n    if (count == 0) {\n      throw new IllegalArgumentException(\"Please specify either -file, -fileList or -stdin\");\n    }\n\n    StanfordCoreNLP tokenizer = (tokenizerProps == null) ? null : new StanfordCoreNLP(tokenizerProps);\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(pipelineProps);\n\n    if (filename != null) {\n      // Process a file.  The pipeline will do tokenization, which\n      // means it will split it into sentences as best as possible\n      // with the tokenizer.\n      List<Annotation> annotations = getAnnotations(tokenizer, inputFormat, filename, filterUnknown);\n      for (Annotation annotation : annotations) {\n        pipeline.annotate(annotation);\n\n        for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n          System.out.println(sentence);\n          outputTree(System.out, sentence, outputFormats);\n        }\n      }\n    } else if (fileList != null) {\n      // Process multiple files.  The pipeline will do tokenization,\n      // which means it will split it into sentences as best as\n      // possible with the tokenizer.  Output will go to filename.out\n      // for each file.\n      for (String file : fileList.split(\",\")) {\n        List<Annotation> annotations = getAnnotations(tokenizer, inputFormat, file, filterUnknown);\n        for (Annotation annotation : annotations) {\n          pipeline.annotate(annotation);\n\n          FileOutputStream fout = new FileOutputStream(file + \".out\");\n          PrintStream pout = new PrintStream(fout);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            pout.println(sentence);\n            outputTree(pout, sentence, outputFormats);\n          }\n          pout.flush();\n          fout.close();\n        }\n      }\n    } else {\n      // Process stdin.  Each line will be treated as a single sentence.\n      System.err.println(\"Reading in text from stdin.\");\n      System.err.println(\"Please enter one sentence per line.\");\n      System.err.println(\"Processing will end when EOF is reached.\");\n      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, \"utf-8\"));\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        line = line.trim();\n        if (line.length() > 0) {\n          Annotation annotation = tokenizer.process(line);\n          pipeline.annotate(annotation);\n          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n            outputTree(System.out, sentence, outputFormats);\n          }\n        } else {\n          // Output blank lines for blank lines so the tool can be\n          // used for line-by-line text processing\n          System.out.println(\"\");\n        }\n      }\n      \n    }\n  }","commit_id":"643dcce1a361a9be175ab36589cab268c2fa8c15","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static Annotation getAnnotation(Input inputFormat, String filename, boolean filterUnknown) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      return annotation;\n    }\n    case TREES: {\n      List<Tree> trees = SentimentUtils.readTreesWithGoldLabels(filename);\n      if (filterUnknown) {\n        trees = SentimentUtils.filterUnknownRoots(trees);\n      }\n      List<CoreMap> sentences = Generics.newArrayList();\n      \n      for (Tree tree : trees) {\n        CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n        sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n        sentences.add(sentence);\n      }\n      Annotation annotation = new Annotation(\"\");\n      annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n      return annotation;\n    }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","id":104866,"modified_method":"/**\n   * Reads an annotation from the given filename using the requested input.\n   */\n  public static List<Annotation> getAnnotations(StanfordCoreNLP tokenizer, Input inputFormat, String filename, boolean filterUnknown) {\n    switch (inputFormat) {\n    case TEXT: {\n      String text = IOUtils.slurpFileNoExceptions(filename);\n      Annotation annotation = new Annotation(text);\n      tokenizer.annotate(annotation);\n      List<Annotation> annotations = Generics.newArrayList();\n      for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Annotation nextAnnotation = new Annotation(sentence.get(CoreAnnotations.TextAnnotation.class));\n        nextAnnotation.set(CoreAnnotations.SentencesAnnotation.class, Collections.singletonList(sentence));\n        annotations.add(nextAnnotation);\n      }\n      return annotations;\n    }\n    case TREES: {\n      List<Tree> trees = SentimentUtils.readTreesWithGoldLabels(filename);\n      if (filterUnknown) {\n        trees = SentimentUtils.filterUnknownRoots(trees);\n      }\n      \n      List<Annotation> annotations = Generics.newArrayList();\n      for (Tree tree : trees) {\n        CoreMap sentence = new Annotation(Sentence.listToString(tree.yield()));\n        sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, tree);\n        List<CoreMap> sentences = Collections.singletonList(sentence);\n        Annotation annotation = new Annotation(\"\");\n        annotation.set(CoreAnnotations.SentencesAnnotation.class, sentences);\n        annotations.add(annotation);\n      }\n      return annotations;\n    }\n    default:\n      throw new IllegalArgumentException(\"Unknown format \" + inputFormat);\n    }\n  }","commit_id":"643dcce1a361a9be175ab36589cab268c2fa8c15","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\", PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n          // If they\n          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {\n            keepNewline = true;\n          }\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n\n    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new SentimentAnnotator(STANFORD_SENTIMENT, properties);\n      }\n\n      @Override\n      public String signature() {\n        return \"model=\" + inputProps.get(\"model\");\n      }\n    });\n\n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":104867,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\", PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n          // If they\n          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {\n            keepNewline = true;\n          }\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + \":\" +\n                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parse\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n\n    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new SentimentAnnotator(STANFORD_SENTIMENT, properties);\n      }\n\n      @Override\n      public String signature() {\n        return \"model=\" + inputProps.get(\"model\");\n      }\n    });\n\n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"643dcce1a361a9be175ab36589cab268c2fa8c15","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    os.append(annotatorName + \".binaryTrees:\" + \n              props.getProperty(annotatorName + \".binaryTrees\", \"false\"));\n    return os.toString();\n  }","id":104868,"modified_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    boolean usesBinary = StanfordCoreNLP.usesBinaryTrees(props);\n    boolean saveBinaryTrees = PropertiesUtils.getBool(props, annotatorName + \".binaryTrees\", usesBinary);\n    os.append(annotatorName + \".binaryTrees:\" + saveBinaryTrees);\n\n    return os.toString();\n  }","commit_id":"468331369717d921f8d076e351c1a2bbfa7059f7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    os.append(annotatorName + \".binaryTrees:\" + \n              props.getProperty(annotatorName + \".binaryTrees\", \"false\"));\n    return os.toString();\n  }","id":104869,"modified_method":"public static String signature(String annotatorName, Properties props) {\n    StringBuilder os = new StringBuilder();\n    os.append(annotatorName + \".model:\" +\n            props.getProperty(annotatorName + \".model\",\n                    LexicalizedParser.DEFAULT_PARSER_LOC));\n    os.append(annotatorName + \".debug:\" +\n            props.getProperty(annotatorName + \".debug\", \"false\"));\n    os.append(annotatorName + \".flags:\" +\n            props.getProperty(annotatorName + \".flags\", \"\"));\n    os.append(annotatorName + \".maxlen:\" +\n            props.getProperty(annotatorName + \".maxlen\", \"-1\"));\n    os.append(annotatorName + \".treemap:\" +\n            props.getProperty(annotatorName + \".treemap\", \"\"));\n    os.append(annotatorName + \".maxtime:\" +\n            props.getProperty(annotatorName + \".maxtime\", \"0\"));\n    os.append(annotatorName + \".buildgraphs:\" +\n            props.getProperty(annotatorName + \".buildgraphs\", \"true\"));\n    os.append(annotatorName + \".nthreads:\" + \n              props.getProperty(annotatorName + \".nthreads\", props.getProperty(\"nthreads\", \"\")));\n    boolean usesBinary = StanfordCoreNLP.usesBinaryTrees(props);\n    boolean saveBinaryTrees = PropertiesUtils.getBool(props, annotatorName + \".binaryTrees\", usesBinary);\n    os.append(annotatorName + \".binaryTrees:\" + saveBinaryTrees);\n\n    return os.toString();\n  }","commit_id":"24936170c42582b9356b65b8533c0e9d3e8bb8c8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private ProjectAndSnapshot getProjectThenSnapshot(DbSession dbSession, ProjectStatusWsRequest request) {\n    ComponentDto projectDto = componentFinder.getByUuidOrKey(dbSession, request.getProjectId(), request.getProjectKey(), ParamNames.PROJECT_ID_AND_KEY);\n    SnapshotDto snapshotDto = dbClient.snapshotDao().selectLastSnapshotByComponentId(dbSession, projectDto.getId());\n    checkState(snapshotDto != null, \"Last analysis of project '%s' not found\", projectDto.getKey());\n    return new ProjectAndSnapshot(projectDto, snapshotDto);\n  }","id":104870,"modified_method":"private ProjectAndSnapshot getProjectThenSnapshot(DbSession dbSession, ProjectStatusWsRequest request) {\n    ComponentDto projectDto = componentFinder.getByUuidOrKey(dbSession, request.getProjectId(), request.getProjectKey(), ParamNames.PROJECT_ID_AND_KEY);\n    SnapshotDto snapshotDto = dbClient.snapshotDao().selectLastSnapshotByComponentId(dbSession, projectDto.getId());\n    return new ProjectAndSnapshot(projectDto, snapshotDto);\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_no_snapshot_id_found() {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    expectedException.expect(NotFoundException.class);\n    expectedException.expectMessage(\"Analysis with id 'task-uuid' is not found\");\n\n    newRequest(ANALYSIS_ID);\n  }","id":104871,"modified_method":"@Test\n  public void fail_if_no_snapshot_id_found() {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    expectedException.expect(NotFoundException.class);\n    expectedException.expectMessage(\"Analysis with id 'task-uuid' is not found\");\n\n    call(ANALYSIS_ID);\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_fail_with_global_scan_permission() {\n    userSession.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    newRequest(snapshot.getId().toString());\n  }","id":104872,"modified_method":"@Test\n  public void not_fail_with_global_scan_permission() {\n    userSession.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    call(snapshot.getId().toString());\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_status_by_project_id() throws IOException {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project)\n      .setPeriodMode(1, \"last_period\")\n      .setPeriodDate(1, 956789123456L)\n      .setPeriodMode(2, \"last_version\")\n      .setPeriodParam(2, \"2015-12-07\")\n      .setPeriodDate(2, 956789123987L)\n      .setPeriodMode(3, \"last_analysis\")\n      .setPeriodMode(5, \"last_30_days\")\n      .setPeriodParam(5, \"2015-11-07\"));\n    MetricDto metric = dbClient.metricDao().insert(dbSession, newMetricDto()\n      .setEnabled(true)\n      .setKey(CoreMetrics.QUALITY_GATE_DETAILS_KEY));\n    dbClient.measureDao().insert(dbSession,\n      newMeasureDto(metric, snapshot.getId())\n        .setData(IOUtils.toString(getClass().getResource(\"ProjectStatusActionTest/measure_data.json\"))));\n    dbSession.commit();\n\n    String response = ws.newRequest()\n      .setParam(PARAM_PROJECT_ID, \"project-uuid\")\n      .execute().getInput();\n\n    assertJson(response).isSimilarTo(getClass().getResource(\"project_status-example.json\"));\n  }","id":104873,"modified_method":"@Test\n  public void return_status_by_project_id() throws IOException {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project)\n      .setPeriodMode(1, \"last_period\")\n      .setPeriodDate(1, 956789123456L)\n      .setPeriodMode(2, \"last_version\")\n      .setPeriodParam(2, \"2015-12-07\")\n      .setPeriodDate(2, 956789123987L)\n      .setPeriodMode(3, \"last_analysis\")\n      .setPeriodMode(5, \"last_30_days\")\n      .setPeriodParam(5, \"2015-11-07\"));\n    MetricDto metric = dbClient.metricDao().insert(dbSession, newMetricDto()\n      .setEnabled(true)\n      .setKey(CoreMetrics.QUALITY_GATE_DETAILS_KEY));\n    dbClient.measureDao().insert(dbSession,\n      newMeasureDto(metric, snapshot.getId())\n        .setData(IOUtils.toString(getClass().getResource(\"ProjectStatusActionTest/measure_data.json\"))));\n    dbSession.commit();\n\n    String response = ws.newRequest()\n      .setParam(PARAM_PROJECT_ID, \"project-uuid\")\n      .execute().getInput();\n\n    assertJson(response).isSimilarTo(getClass().getResource(\"project_status-example.json\"));\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void json_example() throws IOException {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project)\n      .setPeriodMode(1, \"last_period\")\n      .setPeriodDate(1, 956789123456L)\n      .setPeriodMode(2, \"last_version\")\n      .setPeriodParam(2, \"2015-12-07\")\n      .setPeriodDate(2, 956789123987L)\n      .setPeriodMode(3, \"last_analysis\")\n      .setPeriodMode(5, \"last_30_days\")\n      .setPeriodParam(5, \"2015-11-07\"));\n    MetricDto metric = dbClient.metricDao().insert(dbSession, newMetricDto()\n      .setEnabled(true)\n      .setKey(CoreMetrics.QUALITY_GATE_DETAILS_KEY));\n    dbClient.measureDao().insert(dbSession,\n      newMeasureDto(metric, snapshot.getId())\n        .setData(IOUtils.toString(getClass().getResource(\"ProjectStatusActionTest/measure_data.json\"))));\n    dbSession.commit();\n\n    String response = ws.newRequest()\n      .setParam(\"analysisId\", snapshot.getId().toString())\n      .execute().getInput();\n\n    assertJson(response).isSimilarTo(getClass().getResource(\"project_status-example.json\"));\n  }","id":104874,"modified_method":"@Test\n  public void json_example() throws IOException {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project)\n      .setPeriodMode(1, \"last_period\")\n      .setPeriodDate(1, 956789123456L)\n      .setPeriodMode(2, \"last_version\")\n      .setPeriodParam(2, \"2015-12-07\")\n      .setPeriodDate(2, 956789123987L)\n      .setPeriodMode(3, \"last_analysis\")\n      .setPeriodMode(5, \"last_30_days\")\n      .setPeriodParam(5, \"2015-11-07\"));\n    MetricDto metric = dbClient.metricDao().insert(dbSession, newMetricDto()\n      .setEnabled(true)\n      .setKey(CoreMetrics.QUALITY_GATE_DETAILS_KEY));\n    dbClient.measureDao().insert(dbSession,\n      newMeasureDto(metric, snapshot.getId())\n        .setData(IOUtils.toString(getClass().getResource(\"ProjectStatusActionTest/measure_data.json\"))));\n    dbSession.commit();\n\n    String response = ws.newRequest()\n      .setParam(\"analysisId\", snapshot.getId().toString())\n      .execute().getInput();\n\n    assertJson(response).isSimilarTo(getClass().getResource(\"project_status-example.json\"));\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_fail_with_project_scan_permission() {\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    userSession.login(\"john\").addProjectUuidPermissions(SCAN_EXECUTION, project.uuid());\n\n    newRequest(snapshot.getId().toString());\n  }","id":104875,"modified_method":"@Test\n  public void not_fail_with_project_scan_permission() {\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    userSession.login(\"john\").addProjectUuidPermissions(SCAN_EXECUTION, project.uuid());\n\n    call(snapshot.getId().toString());\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_status_by_project_key() throws IOException {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = newProjectDto(\"project-uuid\")\n      .setKey(\"project-key\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project)\n      .setPeriodMode(1, \"last_period\")\n      .setPeriodDate(1, 956789123456L)\n      .setPeriodMode(2, \"last_version\")\n      .setPeriodParam(2, \"2015-12-07\")\n      .setPeriodDate(2, 956789123987L)\n      .setPeriodMode(3, \"last_analysis\")\n      .setPeriodMode(5, \"last_30_days\")\n      .setPeriodParam(5, \"2015-11-07\"));\n    MetricDto metric = dbClient.metricDao().insert(dbSession, newMetricDto()\n      .setEnabled(true)\n      .setKey(CoreMetrics.QUALITY_GATE_DETAILS_KEY));\n    dbClient.measureDao().insert(dbSession,\n      newMeasureDto(metric, snapshot.getId())\n        .setData(IOUtils.toString(getClass().getResource(\"ProjectStatusActionTest/measure_data.json\"))));\n    dbSession.commit();\n\n    String response = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, \"project-key\")\n      .execute().getInput();\n\n    assertJson(response).isSimilarTo(getClass().getResource(\"project_status-example.json\"));\n  }","id":104876,"modified_method":"@Test\n  public void return_status_by_project_key() throws IOException {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\").setKey(\"project-key\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project)\n      .setPeriodMode(1, \"last_period\")\n      .setPeriodDate(1, 956789123456L)\n      .setPeriodMode(2, \"last_version\")\n      .setPeriodParam(2, \"2015-12-07\")\n      .setPeriodDate(2, 956789123987L)\n      .setPeriodMode(3, \"last_analysis\")\n      .setPeriodMode(5, \"last_30_days\")\n      .setPeriodParam(5, \"2015-11-07\"));\n    MetricDto metric = dbClient.metricDao().insert(dbSession, newMetricDto()\n      .setEnabled(true)\n      .setKey(CoreMetrics.QUALITY_GATE_DETAILS_KEY));\n    dbClient.measureDao().insert(dbSession,\n      newMeasureDto(metric, snapshot.getId())\n        .setData(IOUtils.toString(getClass().getResource(\"ProjectStatusActionTest/measure_data.json\"))));\n    dbSession.commit();\n\n    String response = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, \"project-key\")\n      .execute().getInput();\n\n    assertJson(response).isSimilarTo(getClass().getResource(\"project_status-example.json\"));\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_fail_with_system_admin_permission() {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    newRequest(snapshot.getId().toString());\n  }","id":104877,"modified_method":"@Test\n  public void not_fail_with_system_admin_permission() {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    call(snapshot.getId().toString());\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_undefined_status_if_measure_is_not_found() {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    ProjectStatusWsResponse result = newRequest(snapshot.getId().toString());\n\n    assertThat(result.getProjectStatus().getStatus()).isEqualTo(Status.NONE);\n    assertThat(result.getProjectStatus().getConditionsCount()).isEqualTo(0);\n  }","id":104878,"modified_method":"@Test\n  public void return_undefined_status_if_measure_is_not_found() {\n    userSession.login(\"john\").setGlobalPermissions(SYSTEM_ADMIN);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    ProjectStatusWsResponse result = call(snapshot.getId().toString());\n\n    assertThat(result.getProjectStatus().getStatus()).isEqualTo(Status.NONE);\n    assertThat(result.getProjectStatus().getConditionsCount()).isEqualTo(0);\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_insufficient_privileges() {\n    userSession.login(\"john\").setGlobalPermissions(PROVISIONING);\n\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    expectedException.expect(ForbiddenException.class);\n    newRequest(snapshot.getId().toString());\n  }","id":104879,"modified_method":"@Test\n  public void fail_if_insufficient_privileges() {\n    userSession.login(\"john\").setGlobalPermissions(PROVISIONING);\n\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n    SnapshotDto snapshot = dbClient.snapshotDao().insert(dbSession, newSnapshotForProject(project));\n    dbSession.commit();\n\n    expectedException.expect(ForbiddenException.class);\n    call(snapshot.getId().toString());\n  }","commit_id":"2fcad2e70a89b783aea8b81bd8eb59355be9285c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static QProfile from(QualityProfileDto dto) {\n    return new QProfile()\n      .setId(dto.getId())\n      .setKey(dto.getKey())\n      .setName(dto.getName())\n      .setLanguage(dto.getLanguage())\n      .setParent(dto.getParentKee())\n      .setDefault(dto.isDefault())\n      .setRulesUpdatedAt(dto.getRulesUpdatedAt());\n  }","id":104880,"modified_method":"public static QProfile from(QualityProfileDto dto) {\n    return new QProfile()\n      .setId(dto.getId())\n      .setKey(dto.getKey())\n      .setName(dto.getName())\n      .setLanguage(dto.getLanguage())\n      .setParent(dto.getParentKee())\n      .setDefault(dto.isDefault())\n      .setRulesUpdatedAt(dto.getRulesUpdatedAt())\n      .setLastUsed(dto.getLastUsed());\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void to_string() {\n    assertThat(new QProfile().setId(1).setName(\"Default\").setLanguage(\"java\").setParent(\"Parent\").toString())\n      .contains(\"[id=1,key=<null>,name=Default,language=java,parent=Parent,isDefault=false,rulesUpdatedAt=<null>]\");\n  }","id":104881,"modified_method":"@Test\n  public void to_string() {\n    assertThat(new QProfile().setId(1).setName(\"Default\").setLanguage(\"java\").setParent(\"Parent\").toString())\n      .contains(\"[id=1,key=<null>,name=Default,language=java,parent=Parent,isDefault=false,rulesUpdatedAt=<null>,lastUsed=<null>]\");\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private SearchWsResponse buildResponse(SearchData data) {\n    List<QProfile> profiles = data.getProfiles();\n    Map<String, QProfile> profilesByKey = uniqueIndex(profiles, QProfileToKey.INSTANCE);\n\n    QualityProfiles.SearchWsResponse.Builder response = QualityProfiles.SearchWsResponse.newBuilder();\n    QualityProfile.Builder profileBuilder = QualityProfile.newBuilder();\n\n    for (QProfile profile : profiles) {\n      profileBuilder.clear();\n\n      String profileKey = profile.key();\n      profileBuilder.setKey(profileKey);\n      if (profile.name() != null) {\n        profileBuilder.setName(profile.name());\n      }\n      if (profile.getRulesUpdatedAt() != null) {\n        profileBuilder.setRulesUpdatedAt(profile.getRulesUpdatedAt());\n      }\n      profileBuilder.setActiveRuleCount(data.getActiveRuleCount(profileKey));\n      profileBuilder.setActiveDeprecatedRuleCount(data.getActiveDeprecatedRuleCount(profileKey));\n      if (!profile.isDefault()) {\n        profileBuilder.setProjectCount(data.getProjectCount(profileKey));\n      }\n\n      writeLanguageFields(profileBuilder, profile);\n      writeParentFields(profileBuilder, profile, profilesByKey);\n      profileBuilder.setIsInherited(profile.isInherited());\n      profileBuilder.setIsDefault(profile.isDefault());\n      response.addProfiles(profileBuilder);\n    }\n\n    return response.build();\n  }","id":104882,"modified_method":"private SearchWsResponse buildResponse(SearchData data) {\n    List<QProfile> profiles = data.getProfiles();\n    Map<String, QProfile> profilesByKey = profiles.stream().collect(Collectors.toMap(QProfile::key, identity()));\n\n    SearchWsResponse.Builder response = SearchWsResponse.newBuilder();\n\n    for (QProfile profile : profiles) {\n      QualityProfile.Builder profileBuilder = response.addProfilesBuilder();\n\n      String profileKey = profile.key();\n      profileBuilder.setKey(profileKey);\n      if (profile.name() != null) {\n        profileBuilder.setName(profile.name());\n      }\n      if (profile.getRulesUpdatedAt() != null) {\n        profileBuilder.setRulesUpdatedAt(profile.getRulesUpdatedAt());\n      }\n      if (profile.getLastUsed() != null) {\n        profileBuilder.setLastUsed(formatDateTime(profile.getLastUsed()));\n      }\n      profileBuilder.setActiveRuleCount(data.getActiveRuleCount(profileKey));\n      profileBuilder.setActiveDeprecatedRuleCount(data.getActiveDeprecatedRuleCount(profileKey));\n      if (!profile.isDefault()) {\n        profileBuilder.setProjectCount(data.getProjectCount(profileKey));\n      }\n\n      writeLanguageFields(profileBuilder, profile);\n      writeParentFields(profileBuilder, profile, profilesByKey);\n      profileBuilder.setIsInherited(profile.isInherited());\n      profileBuilder.setIsDefault(profile.isDefault());\n    }\n\n    return response.build();\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_for_default_qp_with_profile_name() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setName(\"Sonar way\")\n      .setDefault(false);\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setName(\"Sonar way\")\n      .setDefault(true);\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setName(\"Another way\")\n      .setDefault(true);\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    commit();\n\n    String result = ws.newRequest()\n      .setParam(PARAM_DEFAULTS, Boolean.TRUE.toString())\n      .setParam(PARAM_PROFILE_NAME, \"Sonar way\")\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n  }","id":104883,"modified_method":"@Test\n  public void search_for_default_qp_with_profile_name() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setName(\"Sonar way\")\n      .setDefault(false);\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setName(\"Sonar way\")\n      .setDefault(true);\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setName(\"Another way\")\n      .setDefault(true);\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n\n    String result = ws.newRequest()\n      .setParam(PARAM_DEFAULTS, Boolean.TRUE.toString())\n      .setParam(PARAM_PROFILE_NAME, \"Sonar way\")\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_for_project_qp() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Another way\");\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    qualityProfileDb.insertProjectWithQualityProfileAssociations(project, qualityProfileOnXoo1, qualityProfileOnXoo2);\n    commit();\n\n    String result = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, project.key())\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n  }","id":104884,"modified_method":"@Test\n  public void search_for_project_qp() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Another way\");\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    qualityProfileDb.insertProjectWithQualityProfileAssociations(project, qualityProfileOnXoo1, qualityProfileOnXoo2);\n\n    String result = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, project.key())\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_nominal() throws Exception {\n    when(activeRuleIndex.countAllByQualityProfileKey()).thenReturn(ImmutableMap.of(\n      \"sonar-way-xoo1-12345\", 11L,\n      \"my-sonar-way-xoo2-34567\", 33L));\n    when(activeRuleIndex.countAllDeprecatedByQualityProfileKey()).thenReturn(ImmutableMap.of(\n      \"sonar-way-xoo1-12345\", 1L,\n      \"my-sonar-way-xoo2-34567\", 2L));\n\n    qualityProfileDao.insert(dbSession,\n      QualityProfileDto.createFor(\"sonar-way-xoo1-12345\").setLanguage(xoo1.getKey()).setName(\"Sonar way\").setDefault(true),\n      QualityProfileDto.createFor(\"sonar-way-xoo2-23456\").setLanguage(xoo2.getKey()).setName(\"Sonar way\"),\n      QualityProfileDto.createFor(\"my-sonar-way-xoo2-34567\").setLanguage(xoo2.getKey()).setName(\"My Sonar way\").setParentKee(\"sonar-way-xoo2-23456\"),\n      QualityProfileDto.createFor(\"sonar-way-other-666\").setLanguage(\"other\").setName(\"Sonar way\").setDefault(true));\n    new ComponentDao().insert(dbSession,\n      newProjectDto(\"project-uuid1\"),\n      newProjectDto(\"project-uuid2\"));\n    qualityProfileDao.insertProjectProfileAssociation(\"project-uuid1\", \"sonar-way-xoo2-23456\", dbSession);\n    qualityProfileDao.insertProjectProfileAssociation(\"project-uuid2\", \"sonar-way-xoo2-23456\", dbSession);\n    commit();\n\n    String result = ws.newRequest().execute().getInput();\n\n    assertJson(result).isSimilarTo(getClass().getResource(\"SearchActionTest/search.json\"));\n  }","id":104885,"modified_method":"@Test\n  public void search_nominal() throws Exception {\n    when(activeRuleIndex.countAllByQualityProfileKey()).thenReturn(ImmutableMap.of(\n      \"sonar-way-xoo1-12345\", 11L,\n      \"my-sonar-way-xoo2-34567\", 33L));\n    when(activeRuleIndex.countAllDeprecatedByQualityProfileKey()).thenReturn(ImmutableMap.of(\n      \"sonar-way-xoo1-12345\", 1L,\n      \"my-sonar-way-xoo2-34567\", 2L));\n\n    qualityProfileDao.insert(dbSession,\n      QualityProfileDto.createFor(\"sonar-way-xoo1-12345\").setLanguage(xoo1.getKey()).setName(\"Sonar way\").setDefault(true),\n      QualityProfileDto.createFor(\"sonar-way-xoo2-23456\").setLanguage(xoo2.getKey()).setName(\"Sonar way\"),\n      QualityProfileDto.createFor(\"my-sonar-way-xoo2-34567\").setLanguage(xoo2.getKey()).setName(\"My Sonar way\").setParentKee(\"sonar-way-xoo2-23456\"),\n      QualityProfileDto.createFor(\"sonar-way-other-666\").setLanguage(\"other\").setName(\"Sonar way\").setDefault(true));\n    new ComponentDao().insert(dbSession,\n      newProjectDto(\"project-uuid1\"),\n      newProjectDto(\"project-uuid2\"));\n    qualityProfileDao.insertProjectProfileAssociation(\"project-uuid1\", \"sonar-way-xoo2-23456\", dbSession);\n    qualityProfileDao.insertProjectProfileAssociation(\"project-uuid2\", \"sonar-way-xoo2-23456\", dbSession);\n    db.commit();\n\n    String result = ws.newRequest().execute().getInput();\n\n    assertJson(result).isSimilarTo(getClass().getResource(\"SearchActionTest/search.json\"));\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    qualityProfileDb = new QualityProfileDbTester(db);\n\n    xoo1 = LanguageTesting.newLanguage(\"xoo1\");\n    xoo2 = LanguageTesting.newLanguage(\"xoo2\");\n\n    Languages languages = new Languages(xoo1, xoo2);\n    ws = new WsActionTester(new SearchAction(\n      new SearchDataLoader(\n        languages,\n        new QProfileLookup(dbClient),\n        new QProfileFactory(dbClient),\n        dbClient,\n        new ComponentFinder(dbClient), activeRuleIndex),\n      languages));\n  }","id":104886,"modified_method":"@Before\n  public void setUp() {\n    xoo1 = LanguageTesting.newLanguage(\"xoo1\");\n    xoo2 = LanguageTesting.newLanguage(\"xoo2\");\n\n    Languages languages = new Languages(xoo1, xoo2);\n    ws = new WsActionTester(new SearchAction(\n      new SearchDataLoader(\n        languages,\n        new QProfileLookup(dbClient),\n        new QProfileFactory(dbClient),\n        dbClient,\n        new ComponentFinder(dbClient), activeRuleIndex),\n      languages));\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_for_language() throws Exception {\n    qualityProfileDao.insert(dbSession,\n      QualityProfileDto.createFor(\"sonar-way-xoo1-12345\").setLanguage(xoo1.getKey()).setName(\"Sonar way\"));\n    commit();\n\n    String result = ws.newRequest().setParam(\"language\", xoo1.getKey()).execute().getInput();\n\n    assertJson(result).isSimilarTo(getClass().getResource(\"SearchActionTest/search_xoo1.json\"));\n  }","id":104887,"modified_method":"@Test\n  public void search_for_language() throws Exception {\n    qualityProfileDb.insertQualityProfiles(QualityProfileDto.createFor(\"sonar-way-xoo1-12345\").setLanguage(xoo1.getKey()).setName(\"Sonar way\"));\n\n    String result = ws.newRequest().setParam(\"language\", xoo1.getKey()).execute().getInput();\n\n    assertJson(result).isSimilarTo(getClass().getResource(\"SearchActionTest/search_xoo1.json\"));\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_by_profile_name() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Another way\");\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    dbClient.componentDao().insert(dbSession, project);\n    commit();\n\n    String result = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, project.key())\n      .setParam(PARAM_PROFILE_NAME, \"Sonar way\")\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n\n  }","id":104888,"modified_method":"@Test\n  public void search_by_profile_name() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Another way\");\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    ComponentDto project = componentDb.insertComponent(newProjectDto(\"project-uuid\"));\n\n    String result = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, project.key())\n      .setParam(PARAM_PROFILE_NAME, \"Sonar way\")\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n  }","commit_id":"c467e84eed1a60bbe8c0fe800e2cada2bb26bb4c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void visitPyReferenceExpression(PyReferenceExpression node) {\n      final PyExceptPart exceptPart = PsiTreeUtil.getParentOfType(node, PyExceptPart.class);\n      if (exceptPart != null) {\n        final PyExpression exceptClass = exceptPart.getExceptClass();\n        if (exceptClass != null && \"ImportError\".equals(exceptClass.getText())) return;\n      }\n      PsiElement resolveResult = node.getReference(getResolveContext()).resolve();\n      String deprecationMessage = null;\n      if (resolveResult instanceof PyFunction) {\n        deprecationMessage = ((PyFunction) resolveResult).getDeprecationMessage();\n      }\n      else if (resolveResult instanceof PyFile) {\n        deprecationMessage = ((PyFile)resolveResult).getDeprecationMessage();\n      }\n      if (deprecationMessage != null) {\n        ASTNode nameElement = node.getNameElement();\n        registerProblem(nameElement == null ? node : nameElement.getPsi(), deprecationMessage, ProblemHighlightType.LIKE_DEPRECATED);\n      }\n    }","id":104889,"modified_method":"@Override\n    public void visitPyReferenceExpression(PyReferenceExpression node) {\n      final PyExceptPart exceptPart = PsiTreeUtil.getParentOfType(node, PyExceptPart.class);\n      if (exceptPart != null) {\n        final PyExpression exceptClass = exceptPart.getExceptClass();\n        if (exceptClass != null && \"ImportError\".equals(exceptClass.getText())) return;\n      }\n      final PsiPolyVariantReference reference = node.getReference(getResolveContext());\n      if (reference == null) return;\n      final PsiElement resolveResult = reference.resolve();\n      final PyFromImportStatement importStatement = PsiTreeUtil.getParentOfType(node, PyFromImportStatement.class);\n      if (importStatement != null) {\n        final PsiElement element = importStatement.resolveImportSource();\n        if (resolveResult != null && element != resolveResult.getContainingFile()) return;\n      }\n      String deprecationMessage = null;\n      if (resolveResult instanceof PyFunction) {\n        deprecationMessage = ((PyFunction) resolveResult).getDeprecationMessage();\n      }\n      else if (resolveResult instanceof PyFile) {\n        deprecationMessage = ((PyFile)resolveResult).getDeprecationMessage();\n      }\n      if (deprecationMessage != null) {\n        ASTNode nameElement = node.getNameElement();\n        registerProblem(nameElement == null ? node : nameElement.getPsi(), deprecationMessage, ProblemHighlightType.LIKE_DEPRECATED);\n      }\n    }","commit_id":"c0ea251be6365669c57b4ed8a60b187728e9360c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDeprecatedAsFallback() {\n    myFixture.enableInspections(PyDeprecationInspection.class);\n    myFixture.configureByFile(\"deprecation/deprecatedAsFallback.py\");\n    myFixture.checkHighlighting(true, false, false);\n  }","id":104890,"modified_method":"public void testDeprecatedAsFallback() {\n    myFixture.enableInspections(PyDeprecationInspection.class);\n    myFixture.configureByFiles(\"deprecation/deprecatedAsFallback.py\", \"deprecation/tmp.py\");\n    myFixture.checkHighlighting(true, false, false);\n  }","commit_id":"c0ea251be6365669c57b4ed8a60b187728e9360c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyReferenceExpression(final PyReferenceExpression node) {\n      if (node.getContainingFile() instanceof PyExpressionCodeFragment) {\n        return;\n      }\n      // Ignore global statements arguments\n      if (PyGlobalStatementNavigator.getByArgument(node) != null) {\n        return;\n      }\n      // Ignore qualifier inspections\n      if (node.getQualifier() != null) {\n        return;\n      }\n      // Ignore import subelements\n      if (PsiTreeUtil.getParentOfType(node, PyImportStatementBase.class) != null) {\n        return;\n      }\n      final String name = node.getReferencedName();\n      if (name == null) {\n        return;\n      }\n      final ScopeOwner owner = ScopeUtil.getDeclarationScopeOwner(node, name);\n      final Set<ScopeOwner> largeFunctions = getSession().getUserData(LARGE_FUNCTIONS_KEY);\n      assert largeFunctions != null;\n      if (owner == null || largeFunctions.contains(owner)) {\n        return;\n      }\n      // Ignore references declared in outer scopes\n      if (owner != ScopeUtil.getScopeOwner(node)) {\n        return;\n      }\n      final Scope scope = ControlFlowCache.getScope(owner);\n      // Ignore globals and if scope even doesn't contain such a declaration\n      if (scope.isGlobal(name) || (!scope.containsDeclaration(name))){\n        return;\n      }\n      // Start DFA from the assignment statement in case of augmented assignments\n      final PsiElement anchor;\n      final PyAugAssignmentStatement augAssignment = PsiTreeUtil.getParentOfType(node, PyAugAssignmentStatement.class);\n      if (augAssignment != null && name.equals(augAssignment.getTarget().getName())) {\n        anchor = augAssignment;\n      }\n      else {\n        anchor = node;\n      }\n      final ScopeVariable variable;\n      try {\n        variable = scope.getDeclaredVariable(anchor, name);\n      }\n      catch (DFALimitExceededException e) {\n        largeFunctions.add(owner);\n        registerLargeFunction(owner);\n        return;\n      }\n      if (variable == null) {\n        if (!isFirstUnboundRead(node, owner)) {\n          return;\n        }\n        final PsiElement resolved = node.getReference(resolveWithoutImplicits()).resolve();\n        final boolean isBuiltin = PyBuiltinCache.getInstance(node).hasInBuiltins(resolved);\n        if (owner instanceof PyClass) {\n          if (isBuiltin || ScopeUtil.getDeclarationScopeOwner(owner, name) != null) {\n            return;\n          }\n        }\n        if (owner instanceof PyFile) {\n          if (isBuiltin) {\n            return;\n          }\n          if (resolved != null && !PyUtil.inSameFile(node, resolved)) {\n            return;\n          }\n          registerProblem(node, PyBundle.message(\"INSP.unbound.name.not.defined\", name));\n        }\n        else {\n          registerProblem(node, PyBundle.message(\"INSP.unbound.local.variable\", node.getName()),\n                          ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                          null,\n                          new AddGlobalQuickFix());\n        }\n      }\n    }","id":104891,"modified_method":"@Override\n    public void visitPyReferenceExpression(final PyReferenceExpression node) {\n      if (node.getContainingFile() instanceof PyExpressionCodeFragment) {\n        return;\n      }\n      // Ignore global statements arguments\n      if (PyGlobalStatementNavigator.getByArgument(node) != null) {\n        return;\n      }\n      // Ignore qualifier inspections\n      if (node.getQualifier() != null) {\n        return;\n      }\n      // Ignore import subelements\n      if (PsiTreeUtil.getParentOfType(node, PyImportStatementBase.class) != null) {\n        return;\n      }\n      final String name = node.getReferencedName();\n      if (name == null) {\n        return;\n      }\n      final ScopeOwner owner = ScopeUtil.getDeclarationScopeOwner(node, name);\n      final Set<ScopeOwner> largeFunctions = getSession().getUserData(LARGE_FUNCTIONS_KEY);\n      assert largeFunctions != null;\n      if (owner == null || largeFunctions.contains(owner)) {\n        return;\n      }\n      // Ignore references declared in outer scopes\n      if (owner != ScopeUtil.getScopeOwner(node)) {\n        return;\n      }\n      final Scope scope = ControlFlowCache.getScope(owner);\n      // Ignore globals and if scope even doesn't contain such a declaration\n      if (scope.isGlobal(name) || (!scope.containsDeclaration(name))){\n        return;\n      }\n      // Start DFA from the assignment statement in case of augmented assignments\n      final PsiElement anchor;\n      final PyAugAssignmentStatement augAssignment = PsiTreeUtil.getParentOfType(node, PyAugAssignmentStatement.class);\n      if (augAssignment != null && name.equals(augAssignment.getTarget().getName())) {\n        anchor = augAssignment;\n      }\n      else {\n        anchor = node;\n      }\n      final ScopeVariable variable;\n      try {\n        variable = scope.getDeclaredVariable(anchor, name);\n      }\n      catch (DFALimitExceededException e) {\n        largeFunctions.add(owner);\n        registerLargeFunction(owner);\n        return;\n      }\n      if (variable == null) {\n        if (!isFirstUnboundRead(node, owner)) {\n          return;\n        }\n        final PsiPolyVariantReference ref = node.getReference(resolveWithoutImplicits());\n        if (ref == null) {\n          return;\n        }\n        final PsiElement resolved = ref.resolve();\n        final boolean isBuiltin = PyBuiltinCache.getInstance(node).hasInBuiltins(resolved);\n        if (owner instanceof PyClass) {\n          if (isBuiltin || ScopeUtil.getDeclarationScopeOwner(owner, name) != null) {\n            return;\n          }\n        }\n        if (owner instanceof PyFile) {\n          if (isBuiltin) {\n            return;\n          }\n          if (resolved != null && !PyUtil.inSameFile(node, resolved)) {\n            return;\n          }\n          registerProblem(node, PyBundle.message(\"INSP.unbound.name.not.defined\", name));\n        }\n        else {\n          registerProblem(node, PyBundle.message(\"INSP.unbound.local.variable\", node.getName()),\n                          ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                          null,\n                          new AddGlobalQuickFix());\n        }\n      }\n    }","commit_id":"fade29fb8ab3d753c3f391410f90f7ca63be1be1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyRaiseStatement(PyRaiseStatement node) {\n      PyExpression[] expressions = node.getExpressions();\n      if (expressions.length == 0) {\n        return;\n      }\n      PyExpression expression = expressions[0];\n      if (expression instanceof PyCallExpression) {\n        PyExpression callee = ((PyCallExpression)expression).getCallee();\n        if (callee instanceof PyReferenceExpression) {\n          PsiElement psiElement = ((PyReferenceExpression)callee).getReference(getResolveContext()).resolve();\n          if (psiElement instanceof PyClass) {\n            PyClass aClass = (PyClass) psiElement;\n            for (PyClassLikeType type : aClass.getAncestorTypes(myTypeEvalContext)) {\n              if (type == null) {\n                return;\n              }\n              final String name = type.getName();\n              if (name == null || \"BaseException\".equals(name) || \"Exception\".equals(name)) {\n                return;\n              }\n            }\n            registerProblem(expression, \"Exception doesn't inherit from base \\'Exception\\' class\");\n          }\n        }\n      }\n    }","id":104892,"modified_method":"@Override\n    public void visitPyRaiseStatement(PyRaiseStatement node) {\n      PyExpression[] expressions = node.getExpressions();\n      if (expressions.length == 0) {\n        return;\n      }\n      PyExpression expression = expressions[0];\n      if (expression instanceof PyCallExpression) {\n        PyExpression callee = ((PyCallExpression)expression).getCallee();\n        if (callee instanceof PyReferenceExpression) {\n          final PsiPolyVariantReference reference = ((PyReferenceExpression)callee).getReference(getResolveContext());\n          if (reference == null) return;\n          PsiElement psiElement = reference.resolve();\n          if (psiElement instanceof PyClass) {\n            PyClass aClass = (PyClass) psiElement;\n            for (PyClassLikeType type : aClass.getAncestorTypes(myTypeEvalContext)) {\n              if (type == null) {\n                return;\n              }\n              final String name = type.getName();\n              if (name == null || \"BaseException\".equals(name) || \"Exception\".equals(name)) {\n                return;\n              }\n            }\n            registerProblem(expression, \"Exception doesn't inherit from base \\'Exception\\' class\", new PyAddExceptionSuperClassQuickFix());\n          }\n        }\n      }\n    }","commit_id":"ee5f16edd6424941ab243fa02cddf81cd063da87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SNode classConcept = GenerateGettersAndSetters_Action.this.getClassConcept(_params);\n      SNodeReference[] fields;\n      fields = Sequence.fromIterable(GenerateGettersAndSetters_Action.this.getFieldDeclarationsWithoutGetterOrSetter(classConcept, _params)).select(new ISelector<SNode, SNodePointer>() {\n        public SNodePointer select(SNode it) {\n          return new SNodePointer(it);\n        }\n      }).toGenericArray(SNodePointer.class);\n\n      SelectFieldsDialog selectFieldsDialog = new SelectFieldsDialog(fields, false, ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject());\n      selectFieldsDialog.setTitle(\"Select Fields to Generate Getters and Setters\");\n      selectFieldsDialog.show();\n\n      if (!(selectFieldsDialog.isOK())) {\n        return;\n      }\n\n      SNodeReference[] selectedFields = Sequence.fromIterable(((Iterable<SNodeReference>) selectFieldsDialog.getSelectedElements())).toGenericArray(SNodeReference.class);\n\n      SNode lastAdded = null;\n      Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n      for (SNodeReference fieldPtr : selectedFields) {\n        final SNode field = SNodeOperations.cast(((SNodePointer) fieldPtr).resolve(MPSModuleRepository.getInstance()), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"));\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        SNode fieldReference = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), null);\n        SLinkOperations.setTarget(fieldReference, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), field);\n        ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_5trf1k_a0a4a41a0(SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), fieldReference, getterName));\n\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        String parameterName = GenerateGettersAndSettersUtil.getParameterNameForField(field, project);\n        lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_5trf1k_a0a0i0o0a(SNodeOperations.copyNode(fieldReference), SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), parameterName, setterName));\n      }\n      if (lastAdded != null) {\n        ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(lastAdded);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"GenerateGettersAndSetters\", t);\n      }\n    }\n  }","id":104893,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SNode classConcept = GenerateGettersAndSetters_Action.this.getClassConcept(_params);\n      final SNodeReference[] fields = Sequence.fromIterable(GenerateGettersAndSetters_Action.this.getFieldDeclarationsWithoutGetterOrSetter(classConcept, _params)).select(new ISelector<SNode, SNodePointer>() {\n        public SNodePointer select(SNode it) {\n          return new SNodePointer(it);\n        }\n      }).toGenericArray(SNodePointer.class);\n\n      SelectFieldsDialog selectFieldsDialog = new SelectFieldsDialog(fields, false, ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject());\n      selectFieldsDialog.setTitle(\"Select Fields to Generate Getters and Setters\");\n      selectFieldsDialog.show();\n\n      if (!(selectFieldsDialog.isOK())) {\n        return;\n      }\n\n      SNodeReference[] selectedFields = Sequence.fromIterable(((Iterable<SNodeReference>) selectFieldsDialog.getSelectedElements())).toGenericArray(SNodeReference.class);\n\n      SNode lastAdded = null;\n      Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n      for (SNodeReference fieldPtr : selectedFields) {\n        final SNode field = SNodeOperations.cast(((SNodePointer) fieldPtr).resolve(MPSModuleRepository.getInstance()), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\"));\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        SNode fieldReference = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), null);\n        SLinkOperations.setTarget(fieldReference, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), field);\n        if (SNodeOperations.isInstanceOf(field, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"))) {\n          ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_5trf1k_a0a0a4a31a0(SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), fieldReference, getterName));\n        } else {\n          ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_5trf1k_a0a0a0e0n0a(fieldReference, SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), getterName));\n        }\n\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        String parameterName = GenerateGettersAndSettersUtil.getParameterNameForField(field, project);\n        if (SNodeOperations.isInstanceOf(field, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"))) {\n          lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_5trf1k_a0a0a0i0n0a(SNodeOperations.copyNode(fieldReference), SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), parameterName, setterName));\n        } else {\n          lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_5trf1k_a0a0a0a8a31a0(SNodeOperations.copyNode(fieldReference), SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), parameterName, setterName));\n        }\n      }\n      if (lastAdded != null) {\n        ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(lastAdded);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"GenerateGettersAndSetters\", t);\n      }\n    }\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_5trf1k_a0a0i0o0a(Object parameter_1, Object parameter_2, Object parameter_3, Object parameter_4) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    SNode quotedNode_11 = null;\n    SNode quotedNode_12 = null;\n    SNode quotedNode_13 = null;\n    SNode quotedNode_14 = null;\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_5, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_4);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_7);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_12 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.AssignmentExpression\", null, null, false);\n    quotedNode_13 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", null, null, false);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886297l, \"rValue\"), quotedNode_13);\n    quotedNode_14 = (SNode) parameter_1;\n    if (quotedNode_14 != null) {\n      quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886295l, \"lValue\"), HUtil.copyIfNecessary(quotedNode_14));\n    }\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), quotedNode_12);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_10);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_8);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_9, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_11 = (SNode) parameter_2;\n    if (quotedNode_11 != null) {\n      quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\"), HUtil.copyIfNecessary(quotedNode_11));\n    }\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"), quotedNode_9);\n    quotedNode_13.setReferenceTarget(MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), quotedNode_9);\n    return quotedNode_5;\n  }","id":104894,"modified_method":"private static SNode _quotation_createNode_5trf1k_a0a0a0i0n0a(Object parameter_1, Object parameter_2, Object parameter_3, Object parameter_4) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    SNode quotedNode_11 = null;\n    SNode quotedNode_12 = null;\n    SNode quotedNode_13 = null;\n    SNode quotedNode_14 = null;\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_5, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_4);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_7);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_12 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.AssignmentExpression\", null, null, false);\n    quotedNode_13 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", null, null, false);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886297l, \"rValue\"), quotedNode_13);\n    quotedNode_14 = (SNode) parameter_1;\n    if (quotedNode_14 != null) {\n      quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886295l, \"lValue\"), HUtil.copyIfNecessary(quotedNode_14));\n    }\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), quotedNode_12);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_10);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_8);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_9, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_11 = (SNode) parameter_2;\n    if (quotedNode_11 != null) {\n      quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\"), HUtil.copyIfNecessary(quotedNode_11));\n    }\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"), quotedNode_9);\n    quotedNode_13.setReferenceTarget(MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), quotedNode_9);\n    return quotedNode_5;\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SNode> getFieldDeclarationsWithoutGetterOrSetter(final SNode classConcept, final Map<String, Object> _params) {\n    final Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n    return Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_fields_5292274854859383272\", new Object[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode field) {\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        return !(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{})).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return getterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).isEmpty();\n          }\n        })) && !(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{})).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return setterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).count() == 1;\n          }\n        }));\n      }\n    });\n  }","id":104895,"modified_method":"private Iterable<SNode> getFieldDeclarationsWithoutGetterOrSetter(final SNode classConcept, final Map<String, Object> _params) {\n    final Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n    Iterable<SNode> staticFields = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_staticFields_5292274854859223538\", new Object[]{});\n    Iterable<SNode> fields = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_fields_5292274854859383272\", new Object[]{});\n    return Sequence.fromIterable(fields).union(Sequence.fromIterable(staticFields)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode field) {\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        Iterable<SNode> methods = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{});\n        Iterable<SNode> staticMethods = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_staticMethods_5292274854859435867\", new Object[]{});\n        return !(Sequence.fromIterable(methods).union(Sequence.fromIterable(staticMethods)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return getterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).isEmpty();\n          }\n        })) && !(Sequence.fromIterable(methods).union(Sequence.fromIterable(staticMethods)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return setterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).count() == 1;\n          }\n        }));\n      }\n    });\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_5trf1k_a0a4a41a0(Object parameter_1, Object parameter_2, Object parameter_3) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_5 = (SNode) parameter_1;\n    if (quotedNode_5 != null) {\n      quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), HUtil.copyIfNecessary(quotedNode_5));\n    }\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_9 = (SNode) parameter_2;\n    if (quotedNode_9 != null) {\n      quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), HUtil.copyIfNecessary(quotedNode_9));\n    }\n    quotedNode_7.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_8);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_7);\n    return quotedNode_4;\n  }","id":104896,"modified_method":"private static SNode _quotation_createNode_5trf1k_a0a0a4a31a0(Object parameter_1, Object parameter_2, Object parameter_3) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_5 = (SNode) parameter_1;\n    if (quotedNode_5 != null) {\n      quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), HUtil.copyIfNecessary(quotedNode_5));\n    }\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_9 = (SNode) parameter_2;\n    if (quotedNode_9 != null) {\n      quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), HUtil.copyIfNecessary(quotedNode_9));\n    }\n    quotedNode_7.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_8);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_7);\n    return quotedNode_4;\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SNode> getFieldDeclarationsWithoutGetters(final SNode classConcept, final Map<String, Object> _params) {\n    final Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n    return Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_fields_5292274854859383272\", new Object[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode field) {\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        return !(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{})).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return getterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).isEmpty();\n          }\n        }));\n      }\n    });\n  }","id":104897,"modified_method":"private Iterable<SNode> getFieldDeclarationsWithoutGetters(final SNode classConcept, final Map<String, Object> _params) {\n    final Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n    Iterable<SNode> fields = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_fields_5292274854859383272\", new Object[]{});\n    Iterable<SNode> staticFields = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_staticFields_5292274854859223538\", new Object[]{});\n    return Sequence.fromIterable(fields).union(Sequence.fromIterable(staticFields)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode field) {\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        Iterable<SNode> methods = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{});\n        Iterable<SNode> statMethods = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_staticMethods_5292274854859435867\", new Object[]{});\n        return !(Sequence.fromIterable(methods).union(Sequence.fromIterable(statMethods)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return getterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).isEmpty();\n          }\n        }));\n      }\n    });\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_xzx12x_a0a0f0o0a(Object parameter_1, Object parameter_2, Object parameter_3) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_5 = (SNode) parameter_1;\n    if (quotedNode_5 != null) {\n      quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), HUtil.copyIfNecessary(quotedNode_5));\n    }\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_9 = (SNode) parameter_2;\n    if (quotedNode_9 != null) {\n      quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), HUtil.copyIfNecessary(quotedNode_9));\n    }\n    quotedNode_7.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_8);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_7);\n    return quotedNode_4;\n  }","id":104898,"modified_method":"private static SNode _quotation_createNode_xzx12x_a0a0a0f0o0a(Object parameter_1, Object parameter_2, Object parameter_3) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_4, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_5 = (SNode) parameter_1;\n    if (quotedNode_5 != null) {\n      quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), HUtil.copyIfNecessary(quotedNode_5));\n    }\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_9 = (SNode) parameter_2;\n    if (quotedNode_9 != null) {\n      quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), HUtil.copyIfNecessary(quotedNode_9));\n    }\n    quotedNode_7.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_8);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_7);\n    return quotedNode_4;\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SNodeReference[] fields;\n      SNode classConcept = GenerateGetters_Action.this.getClassConcept(_params);\n\n      fields = Sequence.fromIterable(GenerateGetters_Action.this.getFieldDeclarationsWithoutGetters(classConcept, _params)).select(new ISelector<SNode, SNodePointer>() {\n        public SNodePointer select(SNode it) {\n          return new SNodePointer(it);\n        }\n      }).toGenericArray(SNodePointer.class);\n\n      SelectFieldsDialog selectFieldsDialog = new SelectFieldsDialog(fields, false, ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject());\n      selectFieldsDialog.setTitle(\"Select Fields to Generate Getters\");\n      selectFieldsDialog.show();\n\n      if (!(selectFieldsDialog.isOK())) {\n        return;\n      }\n      SNodeReference[] selectedFields = Sequence.fromIterable(((Iterable<SNodeReference>) selectFieldsDialog.getSelectedElements())).toGenericArray(SNodeReference.class);\n\n      SNode lastAdded = null;\n      Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n      for (SNodeReference fieldPtr : selectedFields) {\n        final SNode field = SNodeOperations.cast(((SNodePointer) fieldPtr).resolve(MPSModuleRepository.getInstance()), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"));\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        // Method creation begins \n        SNode fieldReference = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), null);\n        SLinkOperations.setTarget(fieldReference, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), field);\n        SNode added = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_xzx12x_a0a0f0o0a(SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), fieldReference, getterName));\n        lastAdded = added;\n      }\n      if (lastAdded != null) {\n        ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(lastAdded);\n      }\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"GenerateGetters\", t);\n      }\n    }\n  }","id":104899,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SNodeReference[] fields;\n      SNode classConcept = GenerateGetters_Action.this.getClassConcept(_params);\n\n      fields = Sequence.fromIterable(GenerateGetters_Action.this.getFieldDeclarationsWithoutGetters(classConcept, _params)).select(new ISelector<SNode, SNodePointer>() {\n        public SNodePointer select(SNode it) {\n          return new SNodePointer(it);\n        }\n      }).toGenericArray(SNodePointer.class);\n\n      SelectFieldsDialog selectFieldsDialog = new SelectFieldsDialog(fields, false, ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject());\n      selectFieldsDialog.setTitle(\"Select Fields to Generate Getters\");\n      selectFieldsDialog.show();\n\n      if (!(selectFieldsDialog.isOK())) {\n        return;\n      }\n      SNodeReference[] selectedFields = Sequence.fromIterable(((Iterable<SNodeReference>) selectFieldsDialog.getSelectedElements())).toGenericArray(SNodeReference.class);\n\n      SNode lastAdded = null;\n      Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n      for (SNodeReference fieldPtr : selectedFields) {\n        final SNode field = SNodeOperations.cast(((SNodePointer) fieldPtr).resolve(MPSModuleRepository.getInstance()), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\"));\n        final String getterName = GenerateGettersAndSettersUtil.getFieldGetterName(field, project);\n        // Method creation begins \n        SNode fieldReference = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), null);\n        SLinkOperations.setTarget(fieldReference, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), field);\n        if (SNodeOperations.isInstanceOf(field, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"))) {\n          lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_xzx12x_a0a0a0f0o0a(SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), fieldReference, getterName));\n        } else {\n          lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_xzx12x_a0a0a0a5a41a0(fieldReference, SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), getterName));\n        }\n      }\n      if (lastAdded != null) {\n        ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(lastAdded);\n      }\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"GenerateGetters\", t);\n      }\n    }\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SNode> getFieldDeclarationsWithoutSetters(final SNode classConcept, final Map<String, Object> _params) {\n    final Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n    return Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_fields_5292274854859383272\", new Object[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode field) {\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        return !(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{})).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return setterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).count() == 1;\n          }\n        }));\n      }\n    });\n  }","id":104900,"modified_method":"private Iterable<SNode> getFieldDeclarationsWithoutSetters(final SNode classConcept, final Map<String, Object> _params) {\n    final Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n    Iterable<SNode> fields = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_fields_5292274854859383272\", new Object[]{});\n    Iterable<SNode> staticFields = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_staticFields_5292274854859223538\", new Object[]{});\n    return Sequence.fromIterable(fields).union(Sequence.fromIterable(staticFields)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode field) {\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        Iterable<SNode> methods = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.Classifier\", \"call_methods_5292274854859311639\", new Object[]{});\n        Iterable<SNode> statMethods = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"call_staticMethods_5292274854859435867\", new Object[]{});\n        return !(Sequence.fromIterable(methods).union(Sequence.fromIterable(statMethods)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode method) {\n            return setterName.equals(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"))) && ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"))).count() == 1;\n          }\n        }));\n      }\n    });\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SNodeReference[] fields;\n      SNode classConcept = GenerateSetters_Action.this.getClassConcept(_params);\n\n      fields = Sequence.fromIterable(GenerateSetters_Action.this.getFieldDeclarationsWithoutSetters(classConcept, _params)).select(new ISelector<SNode, SNodePointer>() {\n        public SNodePointer select(SNode it) {\n          return new SNodePointer(it);\n        }\n      }).toGenericArray(SNodePointer.class);\n\n      SelectFieldsDialog selectFieldsDialog = new SelectFieldsDialog(fields, false, ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject());\n      selectFieldsDialog.setTitle(\"Select Fields to Generate Setters\");\n      selectFieldsDialog.show();\n\n      if (!(selectFieldsDialog.isOK())) {\n        return;\n      }\n\n      SNodeReference[] selectedFields = Sequence.fromIterable(((Iterable<SNodeReference>) selectFieldsDialog.getSelectedElements())).toGenericArray(SNodeReference.class);\n\n      SNode lastAdded = null;\n      Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n      for (SNodeReference fieldPtr : selectedFields) {\n        final SNode field = SNodeOperations.cast(((SNodePointer) fieldPtr).resolve(MPSModuleRepository.getInstance()), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"));\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        // Method creation begins \n        String parameterName = GenerateGettersAndSettersUtil.getParameterNameForField(field, project);\n        SNode fieldReference = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), null);\n        SLinkOperations.setTarget(fieldReference, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), field);\n        SNode added = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_fimngf_a0a0g0p0a(fieldReference, SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), parameterName, setterName));\n        lastAdded = added;\n      }\n      if (lastAdded != null) {\n        ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(lastAdded);\n      }\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"GenerateSetters\", t);\n      }\n    }\n  }","id":104901,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SNodeReference[] fields;\n      SNode classConcept = GenerateSetters_Action.this.getClassConcept(_params);\n\n      fields = Sequence.fromIterable(GenerateSetters_Action.this.getFieldDeclarationsWithoutSetters(classConcept, _params)).select(new ISelector<SNode, SNodePointer>() {\n        public SNodePointer select(SNode it) {\n          return new SNodePointer(it);\n        }\n      }).toGenericArray(SNodePointer.class);\n\n      SelectFieldsDialog selectFieldsDialog = new SelectFieldsDialog(fields, false, ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject());\n      selectFieldsDialog.setTitle(\"Select Fields to Generate Setters\");\n      selectFieldsDialog.show();\n\n      if (!(selectFieldsDialog.isOK())) {\n        return;\n      }\n\n      SNodeReference[] selectedFields = Sequence.fromIterable(((Iterable<SNodeReference>) selectFieldsDialog.getSelectedElements())).toGenericArray(SNodeReference.class);\n\n      SNode lastAdded = null;\n      Project project = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getOperationContext().getProject();\n      for (SNodeReference fieldPtr : selectedFields) {\n        final SNode field = SNodeOperations.cast(((SNodePointer) fieldPtr).resolve(MPSModuleRepository.getInstance()), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\"));\n        final String setterName = GenerateGettersAndSettersUtil.getFieldSetterName(field, project);\n        // Method creation begins \n        String parameterName = GenerateGettersAndSettersUtil.getParameterNameForField(field, project);\n        SNode fieldReference = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), null);\n        SLinkOperations.setTarget(fieldReference, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), field);\n        if (SNodeOperations.isInstanceOf(field, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"))) {\n          lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_fimngf_a0a0a0g0p0a(fieldReference, SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), parameterName, setterName));\n        } else {\n          lastAdded = ListSequence.fromList(SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, 5375687026011219971l, \"member\"))).addElement(_quotation_createNode_fimngf_a0a0a0a6a51a0(fieldReference, SLinkOperations.getTarget(field, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\")), parameterName, setterName));\n        }\n      }\n      if (lastAdded != null) {\n        ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(lastAdded);\n      }\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"GenerateSetters\", t);\n      }\n    }\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_fimngf_a0a0g0p0a(Object parameter_1, Object parameter_2, Object parameter_3, Object parameter_4) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    SNode quotedNode_11 = null;\n    SNode quotedNode_12 = null;\n    SNode quotedNode_13 = null;\n    SNode quotedNode_14 = null;\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_5, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_4);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_7);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_12 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.AssignmentExpression\", null, null, false);\n    quotedNode_13 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", null, null, false);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886297l, \"rValue\"), quotedNode_13);\n    quotedNode_14 = (SNode) parameter_1;\n    if (quotedNode_14 != null) {\n      quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886295l, \"lValue\"), HUtil.copyIfNecessary(quotedNode_14));\n    }\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), quotedNode_12);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_10);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_8);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_9, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_11 = (SNode) parameter_2;\n    if (quotedNode_11 != null) {\n      quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\"), HUtil.copyIfNecessary(quotedNode_11));\n    }\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"), quotedNode_9);\n    quotedNode_13.setReferenceTarget(MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), quotedNode_9);\n    return quotedNode_5;\n  }","id":104902,"modified_method":"private static SNode _quotation_createNode_fimngf_a0a0a0g0p0a(Object parameter_1, Object parameter_2, Object parameter_3, Object parameter_4) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    SNode quotedNode_11 = null;\n    SNode quotedNode_12 = null;\n    SNode quotedNode_13 = null;\n    SNode quotedNode_14 = null;\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_5, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_4);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123133l, \"returnType\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.PublicVisibility\", null, null, false);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1178549954367l, 1178549979242l, \"visibility\"), quotedNode_7);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_12 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.AssignmentExpression\", null, null, false);\n    quotedNode_13 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", null, null, false);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886297l, \"rValue\"), quotedNode_13);\n    quotedNode_14 = (SNode) parameter_1;\n    if (quotedNode_14 != null) {\n      quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886295l, \"lValue\"), HUtil.copyIfNecessary(quotedNode_14));\n    }\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, \"expression\"), quotedNode_12);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, \"statement\"), quotedNode_10);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, \"body\"), quotedNode_8);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_9, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, \"name\"), (String) parameter_3);\n    quotedNode_11 = (SNode) parameter_2;\n    if (quotedNode_11 != null) {\n      quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, \"type\"), HUtil.copyIfNecessary(quotedNode_11));\n    }\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, \"parameter\"), quotedNode_9);\n    quotedNode_13.setReferenceTarget(MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, \"variableDeclaration\"), quotedNode_9);\n    return quotedNode_5;\n  }","commit_id":"71c7a2dccfe3984cbdfa4951559c89b177e657be","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createProperty_4588_0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"text\");\n    provider.setNoTargetText(\"<no text>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_text\");\n    DocumentationCommentStyleSheet_StyleSheet.getComment(editorCell).apply(editorCell);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":104903,"modified_method":"private EditorCell createProperty_4588_0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"text\");\n    provider.setNoTargetText(\"<no text>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_text\");\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor() {\n    ListSequence.fromList(this.myConstraints).addElement(new ClassifierDocReference_classifier_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new MethodDocReference_methodDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new DocMethodParameterReference_parameterDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new DocTypeParameterReference_typeVariableDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new FieldDocReference_fieldDeclaration_ReferentConstraint());\n  }","id":104904,"modified_method":"public ConstraintsDescriptor() {\n    ListSequence.fromList(this.myConstraints).addElement(new ClassifierDocReference_classifier_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new MethodDocReference_methodDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new StaticFieldDocReference_staticFieldDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new DocMethodParameterReference_parameterDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new DocTypeParameterReference_typeVariableDeclaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new FieldDocReference_fieldDeclaration_ReferentConstraint());\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setFieldDeclaration(FieldDeclaration node) {\n    super.setReferent(FieldDocReference.FIELD_DECLARATION, node);\n  }","id":104905,"modified_method":"public void setFieldDeclaration(FieldDeclaration node) {\n    this.setDeclaration(node);\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FieldDeclaration getFieldDeclaration() {\n    return (FieldDeclaration)this.getReferent(FieldDeclaration.class, FieldDocReference.FIELD_DECLARATION);\n  }","id":104906,"modified_method":"public FieldDeclaration getFieldDeclaration() {\n    return this.ensureAdapter(FieldDeclaration.class, \"declaration\", this.getDeclaration());\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void unRegisterSelf(ModelConstraintsManager manager) {\n    manager.unRegisterNodeReferentSearchScopeProvider(\"jetbrains.mps.baseLanguage.javadoc.structure.FieldDocReference\", \"fieldDeclaration\");\n  }","id":104907,"modified_method":"public void unRegisterSelf(ModelConstraintsManager manager) {\n    manager.unRegisterNodeReferentSearchScopeProvider(\"jetbrains.mps.baseLanguage.javadoc.structure.FieldDocReference\", \"declaration\");\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void registerSelf(ModelConstraintsManager manager) {\n    manager.registerNodeReferentSearchScopeProvider(\"jetbrains.mps.baseLanguage.javadoc.structure.FieldDocReference\", \"fieldDeclaration\", this);\n  }","id":104908,"modified_method":"public void registerSelf(ModelConstraintsManager manager) {\n    manager.registerNodeReferentSearchScopeProvider(\"jetbrains.mps.baseLanguage.javadoc.structure.FieldDocReference\", \"declaration\", this);\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_2585_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_2585_0\");\n    editorCell.addEditorCell(this.createConstant_2585_1(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_2585_0(editorContext, node));\n    editorCell.addEditorCell(this.createRefNode_2585_0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_2585_2(editorContext, node));\n    return editorCell;\n  }","id":104909,"modified_method":"private EditorCell createCollection_2585_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_2585_0\");\n    IntlineTagCommentLinePart_Actions.setCellActions(editorCell, node, editorContext);\n    editorCell.addEditorCell(this.createConstant_2585_1(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_2585_0(editorContext, node));\n    editorCell.addEditorCell(this.createRefNode_2585_0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_2585_2(editorContext, node));\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_2585_2(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"}\");\n    editorCell.setCellId(\"Constant_2585_2\");\n    DocumentationCommentStyleSheet_StyleSheet.getComment(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":104910,"modified_method":"private EditorCell createConstant_2585_2(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"}\");\n    editorCell.setCellId(\"Constant_2585_2\");\n    DocumentationCommentStyleSheet_StyleSheet.getComment(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n      style.set(StyleAttributes.MATCHING_LABEL, \"brace\");\n    }\n    IntlineTagCommentLinePart_Actions.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_2585_1(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"{\");\n    editorCell.setCellId(\"Constant_2585_1\");\n    DocumentationCommentStyleSheet_StyleSheet.getComment(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":104911,"modified_method":"private EditorCell createConstant_2585_1(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"{\");\n    editorCell.setCellId(\"Constant_2585_1\");\n    DocumentationCommentStyleSheet_StyleSheet.getComment(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.MATCHING_LABEL, \"brace\");\n      style.set(StyleAttributes.SELECTABLE, true);\n    }\n    IntlineTagCommentLinePart_Actions.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_2585_0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"@\");\n    editorCell.setCellId(\"Constant_2585_0\");\n    DocumentationCommentStyleSheet_StyleSheet.getCommentTag(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    IntlineTagCommentLinePart_Actions.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":104912,"modified_method":"private EditorCell createConstant_2585_0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"@\");\n    editorCell.setCellId(\"Constant_2585_0\");\n    DocumentationCommentStyleSheet_StyleSheet.getCommentTag(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n      style.set(StyleAttributes.SELECTABLE, true);\n    }\n    IntlineTagCommentLinePart_Actions.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      System.out.println(SNodeOperations.getConceptDeclaration(node));\n      SNode commentLine = SNodeOperations.cast(SNodeOperations.getParent(node), \"jetbrains.mps.baseLanguage.javadoc.structure.CommentLine\");\n      SNodeOperations.deleteNode(node);\n      for (int i = 0; i < ListSequence.fromList(SLinkOperations.getTargets(commentLine, \"part\", true)).count() - 1; i++) {\n        SNode part1 = ListSequence.fromList(SLinkOperations.getTargets(commentLine, \"part\", true)).getElement(i);\n        SNode part2 = ListSequence.fromList(SLinkOperations.getTargets(commentLine, \"part\", true)).getElement(i + 1);\n        if (SNodeOperations.isInstanceOf(part1, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\") && SNodeOperations.isInstanceOf(part2, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\")) {\n          SPropertyOperations.set(SNodeOperations.cast(part1, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\"), \"text\", SPropertyOperations.getString(SNodeOperations.cast(part1, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\"), \"text\") + SPropertyOperations.getString(SNodeOperations.cast(part2, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\"), \"text\"));\n          SNodeOperations.deleteNode(part2);\n          i--;\n        }\n      }\n      /*\n        editorContext.flushEvents();\n      */\n    }","id":104913,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      System.out.println(System.currentTimeMillis() + \": \" + SNodeOperations.getConceptDeclaration(node));\n      SNode commentLine = SNodeOperations.cast(SNodeOperations.getParent(node), \"jetbrains.mps.baseLanguage.javadoc.structure.CommentLine\");\n      SNodeOperations.deleteNode(node);\n      for (int i = 0; i < ListSequence.fromList(SLinkOperations.getTargets(commentLine, \"part\", true)).count() - 1; i++) {\n        SNode part1 = ListSequence.fromList(SLinkOperations.getTargets(commentLine, \"part\", true)).getElement(i);\n        SNode part2 = ListSequence.fromList(SLinkOperations.getTargets(commentLine, \"part\", true)).getElement(i + 1);\n        if (SNodeOperations.isInstanceOf(part1, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\") && SNodeOperations.isInstanceOf(part2, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\")) {\n          SPropertyOperations.set(SNodeOperations.cast(part1, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\"), \"text\", SPropertyOperations.getString(SNodeOperations.cast(part1, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\"), \"text\") + SPropertyOperations.getString(SNodeOperations.cast(part2, \"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart\"), \"text\"));\n          SNodeOperations.deleteNode(part2);\n          i--;\n        }\n      }\n      editorContext.flushEvents();\n    }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_9488_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_9488_0\");\n    editorCell.addEditorCell(this.createConceptProperty_9488_0(editorContext, node));\n    return editorCell;\n  }","id":104914,"modified_method":"private EditorCell createCollection_9488_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_9488_0\");\n    editorCell.addEditorCell(this.createConceptProperty_9488_0(editorContext, node));\n    if (renderingCondition9488_0(node, editorContext, editorContext.getOperationContext().getScope())) {\n      editorCell.addEditorCell(this.createRefNode_9488_0(editorContext, node));\n    }\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConceptProperty_9488_0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new ConceptPropertyCellProvider(node, editorContext);\n    provider.setRole(\"alias\");\n    provider.setNoTargetText(\"<no alias>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"conceptProperty_alias\");\n    DocumentationCommentStyleSheet_StyleSheet.getCommentTag(editorCell).apply(editorCell);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":104915,"modified_method":"private EditorCell createConceptProperty_9488_0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new ConceptPropertyCellProvider(node, editorContext);\n    provider.setRole(\"alias\");\n    provider.setNoTargetText(\"<no alias>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"conceptProperty_alias\");\n    DocumentationCommentStyleSheet_StyleSheet.getCommentTag(editorCell).apply(editorCell);\n    ValueInlineDocTag_Actions.setCellActions(editorCell, node, editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"571845afae29be071e7e4a2b3817c5ee0f7d1d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_3798212845297807980(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return StubsCreatorDeclaration_Behavior.call_getGeneratedName_5307115338409984553(_context.getNode());\n  }","id":104916,"modified_method":"public static Object propertyMacro_GetPropertyValue_3798212845297807980(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return AbstractModelCreator_Behavior.call_getGeneratedName_5553449326502826657(_context.getNode());\n  }","commit_id":"8499e78b56d8950f034ba0174e5fcf74dd9d3102","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_5516999836374471953(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SLinkOperations.getTarget(_context.getNode(), \"creatorDeclaration\", false), \"map_StubCreator\");\n  }","id":104917,"modified_method":"public static Object referenceMacro_GetReferent_5516999836374471953(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SLinkOperations.getTarget(_context.getNode(), \"declaration\", false), \"map_StubCreator\");\n  }","commit_id":"8499e78b56d8950f034ba0174e5fcf74dd9d3102","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_createType_1213877527970(SNode thisNode) {\n    return new _Quotations.QuotationClass_0().createNode(thisNode);\n  }","id":104918,"modified_method":"public static SNode virtual_createType_1213877527970(SNode thisNode) {\n    return new StubsCreatorDeclaration_Behavior.QuotationClass_3906_0().createNode(thisNode, thisNode);\n  }","commit_id":"8499e78b56d8950f034ba0174e5fcf74dd9d3102","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setCreatorDeclaration(StubsCreatorDeclaration node) {\n    super.setReferent(StubsCreatorType.CREATOR_DECLARATION, node);\n  }","id":104919,"modified_method":"public void setCreatorDeclaration(StubsCreatorDeclaration node) {\n    this.setDeclaration(node);\n  }","commit_id":"8499e78b56d8950f034ba0174e5fcf74dd9d3102","url":"https://github.com/JetBrains/MPS"},{"original_method":"public StubsCreatorDeclaration getCreatorDeclaration() {\n    return (StubsCreatorDeclaration) this.getReferent(StubsCreatorDeclaration.class, StubsCreatorType.CREATOR_DECLARATION);\n  }","id":104920,"modified_method":"public StubsCreatorDeclaration getCreatorDeclaration() {\n    return this.ensureAdapter(StubsCreatorDeclaration.class, \"declaration\", this.getDeclaration());\n  }","commit_id":"8499e78b56d8950f034ba0174e5fcf74dd9d3102","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypesystemDescriptor() {\n    {\n      SubtypingRule_Runtime subtypingRule = new StubsCreatorType_SubtypeOf_ModelRootManager_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n  }","id":104921,"modified_method":"public TypesystemDescriptor() {\n    {\n      SubtypingRule_Runtime subtypingRule = new StubsCreatorType_SubtypeOf_ModelRootManager_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new ModelManagerType_SubtypeOf_ModelRootManager_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n  }","commit_id":"8499e78b56d8950f034ba0174e5fcf74dd9d3102","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void applyEditorTo(DemoApplication_Configuration configuration) throws ConfigurationException {\n    configuration.myState.myNode = myChooser.getNode();\n  }","id":104922,"modified_method":"protected void applyEditorTo(final DemoApplication_Configuration configuration) throws ConfigurationException {\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  protected JComponent createEditor() {\n    myLabel = new JLabel();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myChooser = new MainNodeChooser<SNode>(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.runConfigurations.demo.structure.SomeConcept\"), new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n          public Boolean invoke(SNode node) {\n            return SPropertyOperations.getBoolean(node, \"valid\");\n          }\n        });\n      }\n    });\n    myChooser.addNodeChangeListener(new IJavaNodeChangeListener() {\n      public void nodeChanged(final SNode node) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            myLabel.setText(SPropertyOperations.getString(node, \"name\"));\n          }\n        });\n      }\n    });\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.add(myLabel, BorderLayout.NORTH);\n    panel.add(myChooser, BorderLayout.CENTER);\n    return panel;\n  }","id":104923,"modified_method":"@NotNull\n  protected JComponent createEditor() {\n    myLabel = new JLabel();\n    // <node> \n    // <node> \n    JPanel panel = new JPanel(new BorderLayout());\n    panel.add(myLabel, BorderLayout.NORTH);\n    // <node> \n    return panel;\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void resetEditorFrom(DemoApplication_Configuration configuration) {\n    myChooser.setNode(configuration.myState.myNode);\n  }","id":104924,"modified_method":"protected void resetEditorFrom(final DemoApplication_Configuration configuration) {\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    SNode instance = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n    SNode configurationType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(instance), HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.runConfigurations.structure.RunConfigurationType\"), false);\n    if ((configurationType == null) || (SLinkOperations.getTarget(configurationType, \"runConfiguration\", false) == null)) {\n      return Sequence.fromIterable(Collections.<SNode>emptyList());\n    }\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(configurationType, \"runConfiguration\", false), \"persistentProperty\", true);\n  }","id":104925,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    SNode instance = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n    SNode propertyHolderType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(instance), HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.runConfigurations.structure.PersistentPropertyHolderType\"), false);\n    if ((propertyHolderType == null) || (SLinkOperations.getTarget(propertyHolderType, \"persistentPropertyHolder\", false) == null)) {\n      return Sequence.fromIterable(Collections.<SNode>emptyList());\n    }\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(propertyHolderType, \"persistentPropertyHolder\", false), \"persistentProperty\", true);\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_3347833162492299799(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"editor\", true), \"applyTo\", true), \"body\", true);\n  }","id":104926,"modified_method":"public static SNode sourceNodeQuery_77193491200351689(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"editor\", true), \"resetFrom\", true), \"body\", true);\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_3347833162492299820(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"editor\", true), \"resetFrom\", true), \"body\", true);\n  }","id":104927,"modified_method":"public static SNode sourceNodeQuery_77193491200359777(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"editor\", true), \"dispose\", true), \"body\", true);\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_3347833162492300625(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"editor\", true), \"dispose\", true), \"body\", true);\n  }","id":104928,"modified_method":"public static SNode sourceNodeQuery_77193491200351644(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"editor\", true), \"applyTo\", true), \"body\", true);\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RunConfiguration getRunConfiguration() {\n    return (RunConfiguration) this.getReferent(RunConfiguration.class, RunConfigurationType.RUN_CONFIGURATION);\n  }","id":104929,"modified_method":"public RunConfiguration getRunConfiguration() {\n    return this.ensureAdapter(RunConfiguration.class, \"persistentPropertyHolder\", this.getPersistentPropertyHolder());\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setRunConfiguration(RunConfiguration node) {\n    super.setReferent(RunConfigurationType.RUN_CONFIGURATION, node);\n  }","id":104930,"modified_method":"public void setRunConfiguration(RunConfiguration node) {\n    this.setPersistentPropertyHolder(node);\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> getContextPersistentProperties_4777576391478338580(SNode node) {\n    SNode configurationType = RunConfiguration_Behavior.getContextRunConfigurationType_4777576391478317632(node);\n    if ((configurationType == null) || (SLinkOperations.getTarget(configurationType, \"runConfiguration\", false) == null)) {\n      return new ArrayList<SNode>();\n    }\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(configurationType, \"runConfiguration\", false), \"persistentProperty\", true);\n  }","id":104931,"modified_method":"public static List<SNode> getContextPersistentProperties_4777576391478338580(SNode node) {\n    SNode configurationType = RunConfiguration_Behavior.getContextRunConfigurationType_4777576391478317632(node);\n    if ((configurationType == null) || (SLinkOperations.getTarget(configurationType, \"persistentPropertyHolder\", false) == null)) {\n      return new ArrayList<SNode>();\n    }\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(configurationType, \"persistentPropertyHolder\", false), \"persistentProperty\", true);\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_Configuration_Parameter_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PersistentPropertyReferenceOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n  }","id":104932,"modified_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_Configuration_Parameter_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PersistentPropertyDeclaration_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PersistentPropertyReferenceOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_SmartPropertyValue_Parameter_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ThisExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new RunConfigurationIsPropertyHolder_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new SmartPropertyIsSubtypeOfSmartProperty_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new SmartPropertyIsSubtypeOfType_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n  }","commit_id":"c84d4f07acf9f48b07ac52dd97de4f91f03cb1e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    return ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.ACTIONS, node);\n  }","id":104933,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    return ListSequence.fromList(ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.ACTIONS, node)).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> getAvailableConceptAspects(LanguageAspect aspect, SNode node) {\n    // [MM] this LanguageAspect usage is reviewed \n    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());\n    for (SLanguage slang : CollectionSequence.fromCollection(aspect.getMainLanguages())) {\n      Language language = ((Language) slang.getSourceModule());\n      if (language == null) {\n        continue;\n      }\n      SModel structureModel = language.getStructureModelDescriptor();\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(getAvailableConceptAspects(structureModel, node)));\n    }\n    return result;\n  }","id":104934,"modified_method":"public static List<SAbstractConcept> getAvailableConceptAspects(LanguageAspect aspect, SNode node) {\n    // [MM] this LanguageAspect usage is reviewed \n    List<SAbstractConcept> result = ListSequence.fromList(new ArrayList<SAbstractConcept>());\n    for (SLanguage slang : CollectionSequence.fromCollection(aspect.getMainLanguages())) {\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(getAvailableConceptAspects(slang, node)));\n    }\n    return result;\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> getAvailableConceptAspects(SModel structureModel, SNode node) {\n    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode root : SModelOperations.roots(structureModel, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))) {\n      if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(root), MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x24614259e94f0c84L, \"jetbrains.mps.lang.structure.structure.IConceptAspect\")) && SPropertyOperations.getBoolean(root, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\")) && !(SPropertyOperations.getBoolean(root, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x403a32c5772c7ec2L, \"abstract\")))) {\n        SNode candidate = (SNode) root;\n        if (((boolean) (Boolean) BHReflection.invoke(SNodeOperations.asSConcept(candidate), SMethodTrimmedId.create(\"canBeAppliedToNode\", null, \"7IH442d05tK\"), node))) {\n          ListSequence.fromList(result).addElement(candidate);\n        }\n      }\n    }\n    return result;\n  }","id":104935,"modified_method":"public static List<SAbstractConcept> getAvailableConceptAspects(SLanguage l, SNode node) {\n    List<SAbstractConcept> result = ListSequence.fromList(new ArrayList<SAbstractConcept>());\n    for (SAbstractConcept c : l.getConcepts()) {\n      if (c.isAbstract()) {\n        continue;\n      }\n      if (!((c instanceof SConcept))) {\n        continue;\n      }\n      if (!(((SConcept) c).isRootable())) {\n        continue;\n      }\n      if (!(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(c), MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x24614259e94f0c84L, \"jetbrains.mps.lang.structure.structure.IConceptAspect\")))) {\n        continue;\n      }\n\n      // todo rewrite canBeAppliedToNode \n      if (((boolean) (Boolean) BHReflection.invoke(SNodeOperations.asSConcept((SNode) c.getDeclarationNode()), SMethodTrimmedId.create(\"canBeAppliedToNode\", null, \"7IH442d05tK\"), node))) {\n        ListSequence.fromList(result).addElement(c);\n      }\n    }\n    return result;\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    return ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.EDITOR, node);\n  }","id":104936,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    return ListSequence.fromList(ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.EDITOR, node)).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    return ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.FIND_USAGES, node);\n  }","id":104937,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    return ListSequence.fromList(ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.FIND_USAGES, node)).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    List<SNode> result = ConceptEditorHelper.getAvailableConceptAspects(SNodeOperations.getModel(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x10313ed7688L, \"jetbrains.mps.lang.generator.structure.TemplateSwitch\").getDeclarationNode()), node);\n    ListSequence.fromList(result).addElement(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x112103dd1e8L, \"jetbrains.mps.lang.generator.structure.InlineTemplate_RuleConsequence\").getDeclarationNode());\n    ListSequence.fromList(result).addElement(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7b85dded0be53d6cL, \"jetbrains.mps.lang.generator.structure.InlineTemplateWithContext_RuleConsequence\").getDeclarationNode());\n    boolean rootable = SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) && SPropertyOperations.getBoolean((SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\"));\n    boolean isInterface = SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"));\n    if (rootable || isInterface) {\n      boolean isNeedRootTemplate = true;\n      for (SNode genFragment : ((List<SNode>) BHReflection.invoke(node, SMethodTrimmedId.create(\"findGeneratorFragments\", MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"), \"5zMz2aJEI4B\")))) {\n        if ((AttributeOperations.getAttribute(genFragment, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x11017244494L, \"jetbrains.mps.lang.generator.structure.RootTemplateAnnotation\"))) != null)) {\n          isNeedRootTemplate = false;\n          break;\n        }\n      }\n      if (isNeedRootTemplate) {\n        for (SLanguage lang : SModelOperations.getAllLanguageImports(SNodeOperations.getModel(node))) {\n          SModule language = lang.getSourceModule();\n          if (!(language instanceof Language)) {\n            continue;\n          }\n          // we could iterate over concepts here with SLanguage#getConcepts() and then access conceptNode with getDeclarationNode \n          // however shall clarify what happens for not-yet built language first (i.e. when there's no StructureAspectDescriptor yet) \n          SModel structureModel = ((Language) language).getStructureModelDescriptor();\n          for (SNode nodeToAdd : jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.roots(structureModel, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))) {\n            SNode conceptToAdd = (SNode) nodeToAdd;\n            if (SPropertyOperations.getBoolean(nodeToAdd, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\"))) {\n              ListSequence.fromList(result).addElement(conceptToAdd);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","id":104938,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    List<SAbstractConcept> result = ConceptEditorHelper.getAvailableConceptAspects(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xb401a68083254110L, 0x8fd384331ff25befL), \"jetbrains.mps.lang.generator\"), node);\n    ListSequence.fromList(result).addElement(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x112103dd1e8L, \"jetbrains.mps.lang.generator.structure.InlineTemplate_RuleConsequence\"));\n    ListSequence.fromList(result).addElement(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7b85dded0be53d6cL, \"jetbrains.mps.lang.generator.structure.InlineTemplateWithContext_RuleConsequence\"));\n    boolean rootable = SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) && SPropertyOperations.getBoolean((SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\"));\n    boolean isInterface = SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"));\n    if (rootable || isInterface) {\n      boolean isNeedRootTemplate = true;\n      for (SNode genFragment : ((List<SNode>) BHReflection.invoke(node, SMethodTrimmedId.create(\"findGeneratorFragments\", MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"), \"5zMz2aJEI4B\")))) {\n        if ((AttributeOperations.getAttribute(genFragment, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x11017244494L, \"jetbrains.mps.lang.generator.structure.RootTemplateAnnotation\"))) != null)) {\n          isNeedRootTemplate = false;\n          break;\n        }\n      }\n      if (isNeedRootTemplate) {\n        for (SLanguage lang : SModelOperations.getAllLanguageImports(SNodeOperations.getModel(node))) {\n          for (SAbstractConcept importedConcept : lang.getConcepts()) {\n            if (importedConcept.isAbstract()) {\n              continue;\n            }\n            if (!((importedConcept instanceof SConcept))) {\n              continue;\n            }\n            if (((SConcept) importedConcept).isRootable()) {\n              ListSequence.fromList(result).addElement(importedConcept);\n            }\n          }\n        }\n      }\n    }\n\n    // todo do not cast to nodes here \n    return ListSequence.fromList(result).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    return ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.INTENTIONS, node);\n  }","id":104939,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    return ListSequence.fromList(ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.INTENTIONS, node)).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    return ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.REFACTORINGS, node);\n  }","id":104940,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    return ListSequence.fromList(ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.REFACTORINGS, node)).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getConcepts(final SNode node) {\n    return ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.TYPESYSTEM, node);\n  }","id":104941,"modified_method":"public List<SNode> getConcepts(final SNode node) {\n    return ListSequence.fromList(ConceptEditorHelper.getAvailableConceptAspects(LanguageAspect.TYPESYSTEM, node)).select(new ISelector<SAbstractConcept, SNode>() {\n      public SNode select(SAbstractConcept it) {\n        return ((SNode) it.getDeclarationNode());\n      }\n    }).toListSequence();\n  }","commit_id":"5a71b36a8d562d16ac2fbcb2c926d67445ed6f9a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadDescriptor( final URL descriptorURL )\n    {\n        // simple path for log messages\n        final String descriptorLocation = descriptorURL.getPath();\n\n        InputStream stream = null;\n        try\n        {\n            stream = descriptorURL.openStream();\n\n            BufferedReader in = new BufferedReader( new InputStreamReader( stream, \"UTF-8\" ) );\n            XmlHandler handler = new XmlHandler( m_context.getBundle(), this );\n            KXml2SAXParser parser;\n\n            parser = new KXml2SAXParser( in );\n\n            parser.parseXML( handler );\n\n            // 112.4.2 Component descriptors may contain a single, root component element\n            // or one or more component elements embedded in a larger document\n            for ( Object o : handler.getComponentMetadataList() )\n            {\n                ComponentMetadata metadata = ( ComponentMetadata ) o;\n                ComponentRegistryKey key = null;\n                try\n                {\n                    // check and reserve the component name (if not null)\n                    if ( metadata.getName() != null )\n                    {\n                        key = m_componentRegistry.checkComponentName( m_context.getBundle(), metadata.getName() );\n                    }\n\n                    // validate the component metadata\n                    metadata.validate( this );\n\n                    // Request creation of the component manager\n                    ComponentHolder holder = m_componentRegistry.createComponentHolder( this, metadata );\n\n                    // register the component after validation\n                    m_componentRegistry.registerComponentHolder( key, holder );\n                    m_managers.add( holder );\n\n                }\n                catch ( Throwable t )\n                {\n                    // There is a problem with this particular component, we'll log the error\n                    // and proceed to the next one\n                    log( LogService.LOG_ERROR, \"Cannot register Component\", metadata, null, t );\n\n                    // make sure the name is not reserved any more\n                    if ( key != null )\n                    {\n                        m_componentRegistry.unregisterComponentHolder( key );\n                    }\n                }\n            }\n        }\n        catch ( IOException ex )\n        {\n            // 112.4.1 If an XML document specified by the header cannot be located in the bundle and its attached\n            // fragments, SCR must log an error message with the Log Service, if present, and continue.\n\n            log( LogService.LOG_ERROR, \"Problem reading descriptor entry ''{0}''\", new Object[]\n                { descriptorLocation }, null, null, ex );\n        }\n        catch ( Exception ex )\n        {\n            log( LogService.LOG_ERROR, \"General problem with descriptor entry ''{0}''\", new Object[]\n                { descriptorLocation }, null, null, ex );\n        }\n        finally\n        {\n            if ( stream != null )\n            {\n                try\n                {\n                    stream.close();\n                }\n                catch ( IOException ignore )\n                {\n                }\n            }\n        }\n    }","id":104942,"modified_method":"private void loadDescriptor( final URL descriptorURL )\n    {\n        // simple path for log messages\n        final String descriptorLocation = descriptorURL.getPath();\n\n        InputStream stream = null;\n        try\n        {\n            stream = descriptorURL.openStream();\n\n            BufferedReader in = new BufferedReader( new InputStreamReader( stream, \"UTF-8\" ) );\n            XmlHandler handler = new XmlHandler( m_context.getBundle(), this );\n            KXml2SAXParser parser;\n\n            parser = new KXml2SAXParser( in );\n\n            parser.parseXML( handler );\n\n            // 112.4.2 Component descriptors may contain a single, root component element\n            // or one or more component elements embedded in a larger document\n            for ( Object o : handler.getComponentMetadataList() )\n            {\n                ComponentMetadata metadata = ( ComponentMetadata ) o;\n                ComponentRegistryKey key = null;\n                try\n                {\n                    // check and reserve the component name (if not null)\n                    if ( metadata.getName() != null )\n                    {\n                        key = m_componentRegistry.checkComponentName( m_context.getBundle(), metadata.getName() );\n                    }\n\n                    // validate the component metadata\n                    metadata.validate( this );\n\n                    // Request creation of the component manager\n                    ComponentHolder holder = m_componentRegistry.createComponentHolder( this, metadata );\n\n                    // register the component after validation\n                    m_componentRegistry.registerComponentHolder( key, holder );\n                    m_managers.add( holder );\n\n                    log( LogService.LOG_DEBUG, \"BundleComponentActivator : Bundle [{0}] ComponentHolder created for {1}\",\n                            new Object[] {m_context.getBundle().getBundleId(), metadata.getName()}, null, null, null );\n\n                }\n                catch ( Throwable t )\n                {\n                    // There is a problem with this particular component, we'll log the error\n                    // and proceed to the next one\n                    log( LogService.LOG_ERROR, \"Cannot register Component\", metadata, null, t );\n\n                    // make sure the name is not reserved any more\n                    if ( key != null )\n                    {\n                        m_componentRegistry.unregisterComponentHolder( key );\n                    }\n                }\n            }\n        }\n        catch ( IOException ex )\n        {\n            // 112.4.1 If an XML document specified by the header cannot be located in the bundle and its attached\n            // fragments, SCR must log an error message with the Log Service, if present, and continue.\n\n            log( LogService.LOG_ERROR, \"Problem reading descriptor entry ''{0}''\", new Object[]\n                { descriptorLocation }, null, null, ex );\n        }\n        catch ( Exception ex )\n        {\n            log( LogService.LOG_ERROR, \"General problem with descriptor entry ''{0}''\", new Object[]\n                { descriptorLocation }, null, null, ex );\n        }\n        finally\n        {\n            if ( stream != null )\n            {\n                try\n                {\n                    stream.close();\n                }\n                catch ( IOException ignore )\n                {\n                }\n            }\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Gets the MetaData location, parses the meta data and requests the processing\n     * of binder instances\n     *\n     * @param descriptorLocations A comma separated list of locations of\n     *      component descriptors. This must not be <code>null<\/code>.\n     *\n     * @throws IllegalStateException If the bundle has already been uninstalled.\n     */\n    private void initialize( String descriptorLocations )\n    {\n\n        // 112.4.1: The value of the the header is a comma separated list of XML entries within the Bundle\n        StringTokenizer st = new StringTokenizer( descriptorLocations, \", \" );\n\n        while ( st.hasMoreTokens() )\n        {\n            String descriptorLocation = st.nextToken();\n\n            URL[] descriptorURLs = findDescriptors( m_context.getBundle(), descriptorLocation );\n            if ( descriptorURLs.length == 0 )\n            {\n                // 112.4.1 If an XML document specified by the header cannot be located in the bundle and its attached\n                // fragments, SCR must log an error message with the Log Service, if present, and continue.\n                log( LogService.LOG_ERROR, \"Component descriptor entry ''{0}'' not found\", new Object[]\n                    { descriptorLocation }, null, null, null );\n                continue;\n            }\n\n            // load from the descriptors\n            for ( URL descriptorURL : descriptorURLs )\n            {\n                loadDescriptor( descriptorURL );\n            }\n        }\n        //enable all the enabled components\n        for ( ComponentHolder componentHolder : m_managers )\n        {\n            if ( componentHolder.getComponentMetadata().isEnabled() )\n            {\n                componentHolder.enableComponents( false );\n            }\n        }\n    }","id":104943,"modified_method":"/**\n     * Gets the MetaData location, parses the meta data and requests the processing\n     * of binder instances\n     *\n     * @param descriptorLocations A comma separated list of locations of\n     *      component descriptors. This must not be <code>null<\/code>.\n     *\n     * @throws IllegalStateException If the bundle has already been uninstalled.\n     */\n    private void initialize( String descriptorLocations )\n    {\n        log( LogService.LOG_DEBUG, \"BundleComponentActivator : Bundle [{0}] descriptor locations {1}\",\n                new Object[] {m_context.getBundle().getBundleId(), descriptorLocations}, null, null, null );\n\n        // 112.4.1: The value of the the header is a comma separated list of XML entries within the Bundle\n        StringTokenizer st = new StringTokenizer( descriptorLocations, \", \" );\n\n        while ( st.hasMoreTokens() )\n        {\n            String descriptorLocation = st.nextToken();\n\n            URL[] descriptorURLs = findDescriptors( m_context.getBundle(), descriptorLocation );\n            if ( descriptorURLs.length == 0 )\n            {\n                // 112.4.1 If an XML document specified by the header cannot be located in the bundle and its attached\n                // fragments, SCR must log an error message with the Log Service, if present, and continue.\n                log( LogService.LOG_ERROR, \"Component descriptor entry ''{0}'' not found\", new Object[]\n                    { descriptorLocation }, null, null, null );\n                continue;\n            }\n\n            // load from the descriptors\n            for ( URL descriptorURL : descriptorURLs )\n            {\n                loadDescriptor( descriptorURL );\n            }\n        }\n        //enable all the enabled components\n        for ( ComponentHolder componentHolder : m_managers )\n        {\n            log( LogService.LOG_DEBUG, \"BundleComponentActivator : Bundle [{0}] May enable component holder {1}\",\n                    new Object[] {m_context.getBundle().getBundleId(), componentHolder.getComponentMetadata().getName()}, null, null, null );\n\n            if ( componentHolder.getComponentMetadata().isEnabled() )\n            {\n                log( LogService.LOG_DEBUG, \"BundleComponentActivator : Bundle [{0}] Enabling component holder {1}\",\n                        new Object[] {m_context.getBundle().getBundleId(), componentHolder.getComponentMetadata().getName()}, null, null, null );\n\n                componentHolder.enableComponents( false );\n            }\n            else\n            {\n                log( LogService.LOG_DEBUG, \"BundleComponentActivator : Bundle [{0}] Will not enable component holder {1}\",\n                        new Object[] {m_context.getBundle().getBundleId(), componentHolder.getComponentMetadata().getName()}, null, null, null );\n            }\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Called upon starting of the bundle. This method invokes initialize() which\n     * parses the metadata and creates the instance managers\n     *\n     * @param componentRegistry The <code>ComponentRegistry<\/code> used to\n     *      register components with to ensure uniqueness of component names\n     *      and to ensure configuration updates.\n     * @param   context  The bundle context owning the components\n     *\n     * @throws ComponentException if any error occurrs initializing this class\n     */\n    BundleComponentActivator( ComponentRegistry componentRegistry,\n        ComponentActorThread componentActor, BundleContext context, ScrConfiguration configuration ) throws ComponentException\n    {\n        // keep the parameters for later\n        m_componentRegistry = componentRegistry;\n        m_componentActor = componentActor;\n        m_context = context;\n\n        // mark this instance active\n        m_active = true;\n\n        // have the LogService handy (if available)\n        m_logService = new ServiceTracker( context, Activator.LOGSERVICE_CLASS, null );\n        m_logService.open();\n        m_configuration = configuration;\n\n        // Get the Metadata-Location value from the manifest\n        String descriptorLocations = ( String ) m_context.getBundle().getHeaders().get( \"Service-Component\" );\n        if ( descriptorLocations == null )\n        {\n            throw new ComponentException( \"Service-Component entry not found in the manifest\" );\n        }\n\n        initialize( descriptorLocations );\n    }","id":104944,"modified_method":"/**\n     * Called upon starting of the bundle. This method invokes initialize() which\n     * parses the metadata and creates the instance managers\n     *\n     * @param componentRegistry The <code>ComponentRegistry<\/code> used to\n     *      register components with to ensure uniqueness of component names\n     *      and to ensure configuration updates.\n     * @param   context  The bundle context owning the components\n     *\n     * @throws ComponentException if any error occurrs initializing this class\n     */\n    BundleComponentActivator( ComponentRegistry componentRegistry,\n        ComponentActorThread componentActor, BundleContext context, ScrConfiguration configuration ) throws ComponentException\n    {\n        // keep the parameters for later\n        m_componentRegistry = componentRegistry;\n        m_componentActor = componentActor;\n        m_context = context;\n\n        // mark this instance active\n        m_active = true;\n\n        // have the LogService handy (if available)\n        m_logService = new ServiceTracker( context, Activator.LOGSERVICE_CLASS, null );\n        m_logService.open();\n        m_configuration = configuration;\n\n        log( LogService.LOG_DEBUG, \"BundleComponentActivator : Bundle [{0}] active\",\n                new Object[] {m_context.getBundle().getBundleId()}, null, null, null );\n\n        // Get the Metadata-Location value from the manifest\n        String descriptorLocations = ( String ) m_context.getBundle().getHeaders().get( \"Service-Component\" );\n        if ( descriptorLocations == null )\n        {\n            throw new ComponentException( \"Service-Component entry not found in the manifest\" );\n        }\n\n        initialize( descriptorLocations );\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"public void disposed( ImmediateComponentManager component )\n    {\n        // ensure the component is removed from the components map\n        synchronized ( m_components )\n        {\n            if ( !m_components.isEmpty() )\n            {\n                for ( Iterator vi = m_components.values().iterator(); vi.hasNext(); )\n                {\n                    if ( component == vi.next() )\n                    {\n                        vi.remove();\n                        break;\n                    }\n                }\n            }\n        }\n\n        // if the component is the single component, we have to replace it\n        // by another entry in the map\n        if ( component == m_singleComponent )\n        {\n            synchronized ( m_components )\n            {\n                if ( m_components.isEmpty() )\n                {\n                    // now what ??\n                    // is it correct to create a new manager ???\n                    m_singleComponent = createComponentManager();\n                }\n                else\n                {\n                    m_singleComponent = m_components.values().iterator().next();\n                }\n            }\n        }\n    }","id":104945,"modified_method":"public void disposed( ImmediateComponentManager component )\n    {\n        // ensure the component is removed from the components map\n        synchronized ( m_components )\n        {\n            if ( !m_components.isEmpty() )\n            {\n                for ( Iterator vi = m_components.values().iterator(); vi.hasNext(); )\n                {\n                    if ( component == vi.next() )\n                    {\n                        vi.remove();\n                        break;\n                    }\n                }\n            }\n\n            // if the component is the single component, we have to replace it\n            // by another entry in the map\n            if ( component == m_singleComponent )\n            {\n                if ( m_components.isEmpty() )\n                {\n                    // now what ??\n                    // is it correct to create a new manager ???\n                    m_singleComponent = createComponentManager();\n                }\n                else\n                {\n                    m_singleComponent = m_components.values().iterator().next();\n                }\n            }\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"public Component[] getComponents()\n    {\n        Component[] components = getComponentManagers( false );\n        return ( components != null ) ? components : new Component[]\n            { m_singleComponent };\n    }","id":104946,"modified_method":"public Component[] getComponents()\n    {\n        synchronized ( m_components )\n        {\n            Component[] components = getComponentManagers( false );\n            return ( components != null ) ? components : new Component[] { m_singleComponent };\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"public void disposeComponents( final int reason )\n    {\n        // FELIX-1733: get a copy of the single component and clear\n        // the field to prevent recreation in disposed(ICM)\n        final ImmediateComponentManager singleComponent = m_singleComponent;\n        m_singleComponent = null;\n\n        final ImmediateComponentManager[] cms = getComponentManagers( true );\n        if ( cms == null )\n        {\n            singleComponent.dispose( reason );\n        }\n        else\n        {\n            for ( ImmediateComponentManager cm : cms )\n            {\n                cm.dispose( reason );\n            }\n        }\n    }","id":104947,"modified_method":"public void disposeComponents( final int reason )\n    {\n        ImmediateComponentManager[] cms;\n        synchronized ( m_components )\n        {\n            // FELIX-1733: get a copy of the single component and clear\n            // the field to prevent recreation in disposed(ICM)\n            final ImmediateComponentManager singleComponent = m_singleComponent;\n            m_singleComponent = null;\n\n            cms = getComponentManagers( true );\n            if ( cms == null )\n            {\n                cms = new ImmediateComponentManager[] { singleComponent };\n            }\n        }\n        for ( ImmediateComponentManager cm : cms )\n        {\n            cm.dispose( reason );\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"public void disableComponents( final boolean async )\n    {\n        m_enabled = false;\n\n        final ImmediateComponentManager[] cms = getComponentManagers( false );\n        if ( cms == null )\n        {\n            m_singleComponent.disable( async );\n        }\n        else\n        {\n            for ( ImmediateComponentManager cm : cms )\n            {\n                cm.disable( async );\n            }\n        }\n    }","id":104948,"modified_method":"public void disableComponents( final boolean async )\n    {\n        ImmediateComponentManager[] cms;\n        synchronized ( m_components )\n        {\n            m_enabled = false;\n\n            cms = getComponentManagers( false );\n            if ( cms == null )\n            {\n                cms = new ImmediateComponentManager[] { m_singleComponent };\n            }\n        }\n        for ( ImmediateComponentManager cm : cms )\n        {\n            cm.disable( async );\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"public void enableComponents( final boolean async )\n    {\n        m_enabled = true;\n        final ImmediateComponentManager[] cms = getComponentManagers( false );\n        if ( cms == null )\n        {\n            m_singleComponent.enable( async );\n        }\n        else\n        {\n            for ( ImmediateComponentManager cm : cms )\n            {\n                cm.enable( async );\n            }\n        }\n\n    }","id":104949,"modified_method":"public void enableComponents( final boolean async )\n    {\n        ImmediateComponentManager[] cms;\n        synchronized ( m_components )\n        {\n            m_enabled = true;\n            cms = getComponentManagers( false );\n            if ( cms == null )\n            {\n                cms = new ImmediateComponentManager[] { m_singleComponent };\n            }\n        }\n        for ( ImmediateComponentManager cm : cms )\n        {\n            cm.enable( async );\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * The configuration with the given <code>pid<\/code>\n     * (<code>service.pid<\/code> of the configuration object) is deleted.\n     * <p>\n     * The following situations are supported:\n     * <ul>\n     * <li>The configuration was a singleton configuration (pid equals the\n     * component name). In this case the internal component map is empty and\n     * the single component has been configured by the singleton configuration\n     * and is no \"deconfigured\".<\/li>\n     * <li>A factory configuration object has been deleted and the configured\n     * object is set as the single component. If the single component held the\n     * last factory configuration object, it is deconfigured. Otherwise the\n     * single component is disposed off and replaced by another component in\n     * the map of existing components.<\/li>\n     * <li>A factory configuration object has been deleted and the configured\n     * object is not set as the single component. In this case the component is\n     * simply disposed off and removed from the internal map.<\/li>\n     * <\/ul>\n     */\n    public void configurationDeleted( final String pid )\n    {\n        // FELIX-2231: nothing to do any more, all components have been disposed off\n        if (m_singleComponent == null) {\n            return;\n        }\n\n        if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )\n        {\n            m_singleComponent.reconfigure( null );\n        }\n        else\n        {\n            // remove the component configured with the deleted configuration\n            ImmediateComponentManager icm = removeComponentManager( pid );\n            if ( icm != null )\n            {\n                boolean dispose = true;\n                // special casing if the single component is deconfigured\n                if ( m_singleComponent == icm )\n                {\n\n                    // if the single component is the last remaining, deconfi\n                    if ( m_components.isEmpty() )\n                    {\n\n                        // if the single component is the last remaining\n                        // deconfigure it\n                        icm.reconfigure( null );\n                        dispose = false;\n\n                    }\n                    else\n                    {\n\n                        // replace the single component field with another\n                        // entry from the map\n                        m_singleComponent = m_components.values().iterator().next();\n\n                    }\n                }\n\n                // icm may be null if the last configuration deleted was the\n                // single component's configuration. Otherwise the component\n                // is not the \"last\" and has to be disposed off\n                if ( dispose )\n                {\n                    icm.disposeInternal( ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED );\n                }\n            }\n        }\n    }","id":104950,"modified_method":"/**\n     * The configuration with the given <code>pid<\/code>\n     * (<code>service.pid<\/code> of the configuration object) is deleted.\n     * <p>\n     * The following situations are supported:\n     * <ul>\n     * <li>The configuration was a singleton configuration (pid equals the\n     * component name). In this case the internal component map is empty and\n     * the single component has been configured by the singleton configuration\n     * and is no \"deconfigured\".<\/li>\n     * <li>A factory configuration object has been deleted and the configured\n     * object is set as the single component. If the single component held the\n     * last factory configuration object, it is deconfigured. Otherwise the\n     * single component is disposed off and replaced by another component in\n     * the map of existing components.<\/li>\n     * <li>A factory configuration object has been deleted and the configured\n     * object is not set as the single component. In this case the component is\n     * simply disposed off and removed from the internal map.<\/li>\n     * <\/ul>\n     */\n    public void configurationDeleted( final String pid )\n    {\n        log( LogService.LOG_DEBUG, \"ImmediateComponentHolder configuration deleted for pid {0}\",\n                new Object[] {pid}, null);\n\n        // component to deconfigure or dispose of\n        final ImmediateComponentManager icm;\n        boolean deconfigure = false;\n\n        synchronized ( m_components )\n        {\n            // FELIX-2231: nothing to do any more, all components have been disposed off\n            if (m_singleComponent == null) \n            {\n                return;\n            }\n\n            if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )\n            {\n                // singleton configuration has pid equal to component name\n                icm = m_singleComponent;\n                deconfigure = true;\n            }\n            else\n            {\n                // remove the component configured with the deleted configuration\n                icm = m_components.remove( pid );\n                if ( icm == null ) \n                {\n                    // we already removed the component with the deleted configuration\n                    return;\n                }\n\n                // special casing if the single component is deconfigured\n                if ( m_singleComponent == icm )\n                {\n\n                    // if the single component is the last remaining, deconfig\n                    if ( m_components.isEmpty() )\n                    {\n\n                        // if the single component is the last remaining\n                        // deconfigure it\n\t\t                deconfigure = true;\n\n                    }\n                    else\n                    {\n\n                        // replace the single component field with another\n                        // entry from the map\n                        m_singleComponent = m_components.values().iterator().next();\n\n                    }\n                }\n            }\n        }\n\n        // icm may be null if the last configuration deleted was the\n        // single component's configuration. Otherwise the component\n        // is not the \"last\" and has to be disposed off\n        if ( deconfigure )\n        {\n\t        icm.reconfigure( null );\n        }\n        else\n        {\n            icm.disposeInternal( ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED );\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Configures a component with the given configuration. This configuration\n     * update may happen in various situations:\n     * <ul>\n     * <li>The <code>pid<\/code> equals the component name. Hence we have a\n     * singleton configuration for the single component held by this holder<\/li>\n     * <li>The configuration is a factory configuration and is the first\n     * configuration provided. In this case the single component is provided\n     * with the configuration and also stored in the map.<\/li>\n     * <li>The configuration is a factory configuration but not the first. In\n     * this case a new component is created, configured and stored in the map<\/li>\n     * <\/ul>\n     */\n    public void configurationUpdated( final String pid, final Dictionary props )\n    {\n        log( LogService.LOG_DEBUG, \"ImmediateComponentHolder configuration updated for pid {0} with properties {1}\",\n                new Object[] {pid, props}, null);\n        // FELIX-2231: nothing to do any more, all components have been disposed off\n        if (m_singleComponent == null) {\n            return;\n        }\n\n        if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )\n        {\n            log( LogService.LOG_DEBUG, \"ImmediateComponentHolder reconfiguring single component for pid {0} \",\n                    new Object[] {pid}, null );\n            // singleton configuration has pid equal to component name\n            m_singleComponent.reconfigure( props );\n        }\n        else\n        {\n            // factory configuration update or created\n            final ImmediateComponentManager icm = getComponentManager( pid );\n            if ( icm != null )\n            {\n                log( LogService.LOG_DEBUG, \"ImmediateComponentHolder reconfiguring existing component for pid {0} \",\n                        new Object[] {pid}, null );\n                // factory configuration updated for existing component instance\n                icm.reconfigure( props );\n            }\n            else\n            {\n                // factory configuration created\n                final ImmediateComponentManager newIcm;\n                if ( !m_singleComponent.hasConfiguration() )\n                {\n                    // configure the single instance if this is not configured\n                    log( LogService.LOG_DEBUG, \"ImmediateComponentHolder configuring the unconfigured single component for pid {0} \",\n                            new Object[] {pid}, null );\n                    newIcm = m_singleComponent;\n                }\n                else\n                {\n                    // otherwise create a new instance to provide the config to\n                    log( LogService.LOG_DEBUG, \"ImmediateComponentHolder configuring a new component for pid {0} \",\n                            new Object[] {pid}, null );\n                    newIcm = createComponentManager();\n                }\n\n                // configure the component\n                newIcm.reconfigure( props );\n                log( LogService.LOG_DEBUG, \"ImmediateComponentHolder Finished configuring the dependency managers for component for pid {0} \",\n                        new Object[] {pid}, null );\n\n                // enable the component if it is initially enabled\n                if ( m_enabled && getComponentMetadata().isEnabled() )\n                {\n                    newIcm.enable( false );\n                    log( LogService.LOG_DEBUG, \"ImmediateComponentHolder Finished enabling component for pid {0} \",\n                            new Object[] {pid}, null );\n                }\n                else\n                {\n                    log( LogService.LOG_DEBUG, \"ImmediateComponentHolder Will not enable component for pid {0}: holder enabled state: {1}, metadata enabled: {2} \",\n                            new Object[] {pid, m_enabled, getComponentMetadata().isEnabled()}, null );\n\n                }\n\n                // store the component in the map\n                putComponentManager( pid, newIcm );\n            }\n        }\n    }","id":104951,"modified_method":"/**\n     * Configures a component with the given configuration. This configuration\n     * update may happen in various situations:\n     * <ul>\n     * <li>The <code>pid<\/code> equals the component name. Hence we have a\n     * singleton configuration for the single component held by this holder<\/li>\n     * <li>The configuration is a factory configuration and is the first\n     * configuration provided. In this case the single component is provided\n     * with the configuration and also stored in the map.<\/li>\n     * <li>The configuration is a factory configuration but not the first. In\n     * this case a new component is created, configured and stored in the map<\/li>\n     * <\/ul>\n     */\n    public void configurationUpdated( final String pid, final Dictionary props )\n    {\n        log( LogService.LOG_DEBUG, \"ImmediateComponentHolder configuration updated for pid {0} with properties {1}\",\n                new Object[] {pid, props}, null);\n\n        // component to update or create\n        final ImmediateComponentManager icm;\n        final String message;\n        final boolean enable;\n        Object[] notEnabledArguments = null;\n\n        synchronized ( m_components )\n        {\n            // FELIX-2231: nothing to do any more, all components have been disposed off\n            if (m_singleComponent == null) \n            {\n                return;\n            }\n\n            if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )\n            {\n                // singleton configuration has pid equal to component name\n                icm = m_singleComponent;\n                message = \"ImmediateComponentHolder reconfiguring single component for pid {0} \";\n                enable = false;\n            }\n            else\n            {\n                final ImmediateComponentManager existingIcm = m_components.get( pid );\n                if ( existingIcm != null )\n                {\n                    // factory configuration updated for existing component instance\n                    icm = existingIcm;\n                    message = \"ImmediateComponentHolder reconfiguring existing component for pid {0} \";\n                    enable = false;\n                }\n                else\n                {\n                    // factory configuration created\n                    if ( !m_singleComponent.hasConfiguration() )\n                    {\n                        // configure the single instance if this is not configured\n                        icm = m_singleComponent;\n                        message = \"ImmediateComponentHolder configuring the unconfigured single component for pid {0} \";\n                    }\n                    else\n                    {\n                        // otherwise create a new instance to provide the config to\n                        icm = createComponentManager();\n                        message = \"ImmediateComponentHolder configuring a new component for pid {0} \";\n                    }\n\n                    // enable the component if it is initially enabled\n                    if ( m_enabled && getComponentMetadata().isEnabled() ) \n                    {\n                        enable = true;\n                    }\n                    else \n                    {\n                        enable = false;\n                        notEnabledArguments = new Object[] {pid, m_enabled, getComponentMetadata().isEnabled()};\n                    }\n\n\t                // store the component in the map\n                    m_components.put( pid, icm );\n                }\n            }\n        }\n        log( LogService.LOG_DEBUG, message, new Object[] {pid}, null);\n\n        // configure the component\n        icm.reconfigure( props );\n        log( LogService.LOG_DEBUG, \"ImmediateComponentHolder Finished configuring the dependency managers for component for pid {0} \",\n                new Object[] {pid}, null );\n\n        if (enable) \n        {\n            icm.enable( false );\n            log( LogService.LOG_DEBUG, \"ImmediateComponentHolder Finished enabling component for pid {0} \",\n                    new Object[] {pid}, null );\n        }\n        else if (notEnabledArguments != null) \n        {\n            log( LogService.LOG_DEBUG, \"ImmediateComponentHolder Will not enable component for pid {0}: holder enabled state: {1}, metadata enabled: {2} \",\n                    notEnabledArguments, null );\n        }\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns all components from the map, optionally also removing them\n     * from the map. If there are no components in the map, <code>null<\/code>\n     * is returned.\n     */\n    private ImmediateComponentManager[] getComponentManagers( final boolean clear )\n    {\n        synchronized ( m_components )\n        {\n            // fast exit if there is no component in the map\n            if ( m_components.isEmpty() )\n            {\n                return null;\n            }\n\n            final ImmediateComponentManager[] cm = new ImmediateComponentManager[m_components.size()];\n            m_components.values().toArray( cm );\n\n            if ( clear )\n            {\n                m_components.clear();\n            }\n\n            return cm;\n        }\n    }","id":104952,"modified_method":"/**\n     * Returns all components from the map, optionally also removing them\n     * from the map. If there are no components in the map, <code>null<\/code>\n     * is returned.\n     */\n    private ImmediateComponentManager[] getComponentManagers( final boolean clear )\n    {\n        // fast exit if there is no component in the map\n        if ( m_components.isEmpty() )\n        {\n            return null;\n        }\n\n        final ImmediateComponentManager[] cm = new ImmediateComponentManager[m_components.size()];\n        m_components.values().toArray( cm );\n\n        if ( clear )\n        {\n            m_components.clear();\n        }\n        return cm;\n    }","commit_id":"620c561461edddd2341653c704968d873844551e","url":"https://github.com/apache/felix"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n      return indexResult == null ? null : Collections.singletonList((OIdentifiable) indexResult);\r\n    }\r\n    return null;\r\n  }","id":104953,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n\t\t\tif(indexResult == null)\r\n\t\t\t\treturn Collections.emptyList();\r\n      return  Collections.singletonList((OIdentifiable) indexResult);\r\n    }\r\n    return null;\r\n  }","commit_id":"0c1c9694e7f068d8f5a7028f47f8b35d42fe57d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    if (!((index.getDefinition() instanceof OPropertyMapIndexDefinition) && ((OPropertyMapIndexDefinition) index.getDefinition())\r\n        .getIndexBy() == OPropertyMapIndexDefinition.INDEX_BY.KEY))\r\n      return null;\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n      return indexResult == null ? null : Collections.singletonList((OIdentifiable) indexResult);\r\n    }\r\n\r\n    return null;\r\n  }","id":104954,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    if (!((index.getDefinition() instanceof OPropertyMapIndexDefinition) && ((OPropertyMapIndexDefinition) index.getDefinition())\r\n        .getIndexBy() == OPropertyMapIndexDefinition.INDEX_BY.KEY))\r\n      return null;\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n\t\t\tif(indexResult == null)\r\n\t\t\t\treturn Collections.emptyList();\r\n\t\t\treturn  Collections.singletonList((OIdentifiable) indexResult);\r\n\t\t}\r\n\r\n    return null;\r\n  }","commit_id":"0c1c9694e7f068d8f5a7028f47f8b35d42fe57d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n    if (indexDefinition.getParamCount() > 1)\r\n      return null;\r\n\r\n    final OIndex<?> internalIndex = index.getInternal();\r\n\r\n    if (internalIndex instanceof OIndexFullText) {\r\n      final Object indexResult = index.get(indexDefinition.createValue(keyParams));\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n      return indexResult == null ? null : Collections.singletonList((OIdentifiable) indexResult);\r\n    }\r\n    return null;\r\n  }","id":104955,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n    if (indexDefinition.getParamCount() > 1)\r\n      return null;\r\n\r\n    final OIndex<?> internalIndex = index.getInternal();\r\n\r\n    if (internalIndex instanceof OIndexFullText) {\r\n      final Object indexResult = index.get(indexDefinition.createValue(keyParams));\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n\t\t\tif(indexResult == null)\r\n\t\t\t\treturn Collections.emptyList();\r\n\t\t\treturn  Collections.singletonList((OIdentifiable) indexResult);\r\n\t\t}\r\n    return null;\r\n  }","commit_id":"0c1c9694e7f068d8f5a7028f47f8b35d42fe57d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    if (!((index.getDefinition() instanceof OPropertyMapIndexDefinition) && ((OPropertyMapIndexDefinition) index.getDefinition())\r\n        .getIndexBy() == OPropertyMapIndexDefinition.INDEX_BY.VALUE))\r\n      return null;\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n      return indexResult == null ? null : Collections.singletonList((OIdentifiable) indexResult);\r\n    }\r\n    return null;\r\n  }","id":104956,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    if (!((index.getDefinition() instanceof OPropertyMapIndexDefinition) && ((OPropertyMapIndexDefinition) index.getDefinition())\r\n        .getIndexBy() == OPropertyMapIndexDefinition.INDEX_BY.VALUE))\r\n      return null;\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n\t\t\tif(indexResult == null)\r\n\t\t\t\treturn Collections.emptyList();\r\n\t\t\treturn  Collections.singletonList((OIdentifiable) indexResult);\r\n\t\t}\r\n    return null;\r\n  }","commit_id":"0c1c9694e7f068d8f5a7028f47f8b35d42fe57d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n      if (indexResult == null)\r\n        return null;\r\n\r\n      return indexResult == null ? null : Collections.singletonList((OIdentifiable) indexResult);\r\n    } else {\r\n      // in case of composite keys several items can be returned in case of we perform search\r\n      // using part of composite key stored in index.\r\n\r\n      final Object keyOne = indexDefinition.createValue(keyParams);\r\n\r\n      if (keyOne == null)\r\n        return null;\r\n\r\n      final Object keyTwo = indexDefinition.createValue(keyParams);\r\n\r\n      final Collection<OIdentifiable> result;\r\n      if (fetchLimit > -1)\r\n        result = index.getValuesBetween(keyOne, true, keyTwo, true, fetchLimit);\r\n      else\r\n        result = index.getValuesBetween(keyOne, true, keyTwo, true);\r\n\r\n      if (OProfiler.getInstance().isRecording()) {\r\n        OProfiler.getInstance().updateCounter(\"Query.compositeIndexUsage\", 1);\r\n        OProfiler.getInstance().updateCounter(\"Query.compositeIndexUsage.\" + indexDefinition.getParamCount(), 1);\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }","id":104957,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  @Override\r\n  public Collection<OIdentifiable> executeIndexQuery(OIndex<?> index, List<Object> keyParams, int fetchLimit) {\r\n    final OIndexDefinition indexDefinition = index.getDefinition();\r\n\r\n    final OIndexInternal<?> internalIndex = index.getInternal();\r\n    if (!internalIndex.canBeUsedInEqualityOperators())\r\n      return null;\r\n\r\n    if (indexDefinition.getParamCount() == 1) {\r\n      final Object key;\r\n      if (indexDefinition instanceof OIndexDefinitionMultiValue)\r\n        key = ((OIndexDefinitionMultiValue) indexDefinition).createSingleValue(keyParams.get(0));\r\n      else\r\n        key = indexDefinition.createValue(keyParams);\r\n\r\n      if (key == null)\r\n        return null;\r\n\r\n      final Object indexResult = index.get(key);\r\n      if (indexResult instanceof Collection)\r\n        return (Collection<OIdentifiable>) indexResult;\r\n\r\n\t\t\tif(indexResult == null)\r\n\t\t\t\treturn Collections.emptyList();\r\n\t\t\treturn  Collections.singletonList((OIdentifiable) indexResult);\r\n\t\t} else {\r\n      // in case of composite keys several items can be returned in case of we perform search\r\n      // using part of composite key stored in index.\r\n\r\n      final Object keyOne = indexDefinition.createValue(keyParams);\r\n\r\n      if (keyOne == null)\r\n        return null;\r\n\r\n      final Object keyTwo = indexDefinition.createValue(keyParams);\r\n\r\n      final Collection<OIdentifiable> result;\r\n      if (fetchLimit > -1)\r\n        result = index.getValuesBetween(keyOne, true, keyTwo, true, fetchLimit);\r\n      else\r\n        result = index.getValuesBetween(keyOne, true, keyTwo, true);\r\n\r\n      if (OProfiler.getInstance().isRecording()) {\r\n        OProfiler.getInstance().updateCounter(\"Query.compositeIndexUsage\", 1);\r\n        OProfiler.getInstance().updateCounter(\"Query.compositeIndexUsage.\" + indexDefinition.getParamCount(), 1);\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }","commit_id":"0c1c9694e7f068d8f5a7028f47f8b35d42fe57d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"UDPPacket buildRelayIntro(RemoteHostId alice, PeerState charlie, UDPPacketReader.RelayRequestReader request) {\n        UDPPacket packet = buildPacketHeader(PEER_RELAY_INTRO_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Sending intro to \" + charlie + \" for \" + alice);\n        \n        // now for the body\n        byte ip[] = alice.getIP();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alice.getPort());\n        off += 2;\n        \n        int sz = request.readChallengeSize();\n        DataHelper.toLong(data, off, 1, sz);\n        off++;\n        if (sz > 0) {\n            request.readChallengeSize(data, off);\n            off += sz;\n        }\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, charlie.getCurrentCipherKey(), charlie.getCurrentMACKey());\n        setTo(packet, charlie.getRemoteIPAddress(), charlie.getRemotePort());\n        packet.setMessageType(TYPE_INTRO);\n        return packet;\n    }","id":104958,"modified_method":"UDPPacket buildRelayIntro(RemoteHostId alice, PeerState charlie, UDPPacketReader.RelayRequestReader request) {\n        UDPPacket packet = buildPacketHeader(PEER_RELAY_INTRO_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Sending intro to \" + charlie + \" for \" + alice);\n        \n        // now for the body\n        byte ip[] = alice.getIP();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alice.getPort());\n        off += 2;\n        \n        int sz = request.readChallengeSize();\n        DataHelper.toLong(data, off, 1, sz);\n        off++;\n        if (sz > 0) {\n            request.readChallengeSize(data, off);\n            off += sz;\n        }\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, charlie.getCurrentCipherKey(), charlie.getCurrentMACKey());\n        setTo(packet, charlie.getRemoteIPAddress(), charlie.getRemotePort());\n        packet.setMessageType(TYPE_INTRO);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Build a packet as if we are Bob sending Charlie a packet to help test Alice.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestToCharlie(InetAddress aliceIP, int alicePort, SessionKey aliceIntroKey, long nonce, \n                                            InetAddress charlieIP, int charliePort, \n                                            SessionKey charlieCipherKey, SessionKey charlieMACKey) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Charlie\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        byte ip[] = aliceIP.getAddress();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alicePort);\n        off += 2;\n        System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, charlieCipherKey, charlieMACKey);\n        setTo(packet, charlieIP, charliePort);\n        packet.setMessageType(TYPE_TBC);\n        return packet;\n    }","id":104959,"modified_method":"/**\n     * Build a packet as if we are Bob sending Charlie a packet to help test Alice.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestToCharlie(InetAddress aliceIP, int alicePort, SessionKey aliceIntroKey, long nonce, \n                                            InetAddress charlieIP, int charliePort, \n                                            SessionKey charlieCipherKey, SessionKey charlieMACKey) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Charlie\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        byte ip[] = aliceIP.getAddress();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alicePort);\n        off += 2;\n        System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, charlieCipherKey, charlieMACKey);\n        setTo(packet, charlieIP, charliePort);\n        packet.setMessageType(TYPE_TBC);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private static void setTo(UDPPacket packet, InetAddress ip, int port) {\n        packet.getPacket().setAddress(ip);\n        packet.getPacket().setPort(port);\n    }","id":104960,"modified_method":"private static void setTo(UDPPacket packet, InetAddress ip, int port) {\n        DatagramPacket pkt = packet.getPacket();\n        pkt.setAddress(ip);\n        pkt.setPort(port);\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public UDPPacket buildPeerTestFromAlice(InetAddress toIP, int toPort, SessionKey toCipherKey, SessionKey toMACKey, long nonce, SessionKey aliceIntroKey) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Bob\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        DataHelper.toLong(data, off, 1, 0); // neither Bob nor Charlie need Alice's IP from her\n        off++;\n        DataHelper.toLong(data, off, 2, 0); // neither Bob nor Charlie need Alice's port from her\n        off += 2;\n        System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, toCipherKey, toMACKey);\n        setTo(packet, toIP, toPort);\n        packet.setMessageType(TYPE_TFA);\n        return packet;\n    }","id":104961,"modified_method":"/**\n     * Build a packet as if we are Alice and we either want Bob to begin a \n     * peer test or Charlie to finish a peer test.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestFromAlice(InetAddress toIP, int toPort, SessionKey toCipherKey, SessionKey toMACKey,\n                                            long nonce, SessionKey aliceIntroKey) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Bob\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        DataHelper.toLong(data, off, 1, 0); // neither Bob nor Charlie need Alice's IP from her\n        off++;\n        DataHelper.toLong(data, off, 2, 0); // neither Bob nor Charlie need Alice's port from her\n        off += 2;\n        System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, toCipherKey, toMACKey);\n        setTo(packet, toIP, toPort);\n        packet.setMessageType(TYPE_TFA);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Build the ack packet. The list need not be sorted into full and partial;\n     *  this method will put all fulls before the partials in the outgoing packet.\n     *  An ack packet is just a data packet with no data.\n     *  See buildPacket() for format.\n     *\n     *  TODO MTU not enforced.\n     *  TODO handle huge number of acks better\n     *\n     * @param ackBitfields list of ACKBitfield instances to either fully or partially ACK\n     */\n    public UDPPacket buildACK(PeerState peer, List<ACKBitfield> ackBitfields) {\n        UDPPacket packet = buildPacketHeader((byte)(UDPPacket.PAYLOAD_TYPE_DATA << 4));\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        \n        StringBuilder msg = null;\n        if (_log.shouldLog(Log.DEBUG)) {\n            msg = new StringBuilder(128);\n            msg.append(\"building ACK packet to \").append(peer.getRemotePeer().toBase64().substring(0,6));\n        }\n\n        int fullACKCount = 0;\n        int partialACKCount = 0;\n        for (int i = 0; i < ackBitfields.size(); i++) {\n            if (ackBitfields.get(i).receivedComplete())\n                fullACKCount++;\n            else\n                partialACKCount++;\n        }\n        // FIXME do better than this, we could still exceed MTU\n        if (fullACKCount > ABSOLUTE_MAX_ACKS ||\n            partialACKCount > ABSOLUTE_MAX_ACKS)\n            throw new IllegalArgumentException(\"Too many acks full/partial \" + fullACKCount +\n                                               '/' + partialACKCount);\n\n        // ok, now for the body...\n        if (fullACKCount > 0)\n            data[off] |= UDPPacket.DATA_FLAG_EXPLICIT_ACK;\n        if (partialACKCount > 0)\n            data[off] |= UDPPacket.DATA_FLAG_ACK_BITFIELDS;\n        // add ECN if (peer.getSomethingOrOther())\n        off++;\n        \n        if (fullACKCount > 0) {\n            DataHelper.toLong(data, off, 1, fullACKCount);\n            off++;\n            for (int i = 0; i < ackBitfields.size(); i++) {\n                ACKBitfield bf = ackBitfields.get(i);\n                if (bf.receivedComplete()) {\n                    DataHelper.toLong(data, off, 4, bf.getMessageId());\n                    off += 4;\n                    if (msg != null) // logging it\n                        msg.append(\" full ack: \").append(bf.getMessageId());\n                }\n            }\n        }\n        \n        if (partialACKCount > 0) {\n            DataHelper.toLong(data, off, 1, partialACKCount);\n            off++;\n            for (int i = 0; i < ackBitfields.size(); i++) {\n                ACKBitfield bitfield = ackBitfields.get(i);\n                if (bitfield.receivedComplete()) continue;\n                DataHelper.toLong(data, off, 4, bitfield.getMessageId());\n                off += 4;\n                int bits = bitfield.fragmentCount();\n                int size = (bits / 7) + 1;\n                for (int curByte = 0; curByte < size; curByte++) {\n                    if (curByte + 1 < size)\n                        data[off] |= (byte)(1 << 7);\n                    \n                    for (int curBit = 0; curBit < 7; curBit++) {\n                        if (bitfield.received(curBit + 7*curByte))\n                            data[off] |= (byte)(1 << curBit);\n                    }\n                    off++;\n                }\n                \n                if (msg != null) // logging it\n                    msg.append(\" partial ack: \").append(bitfield);\n            }\n        }\n        \n        DataHelper.toLong(data, off, 1, 0); // no fragments in this message\n        off++;\n        \n        if (msg != null)\n            _log.debug(msg.toString());\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, peer.getCurrentCipherKey(), peer.getCurrentMACKey());\n        setTo(packet, peer.getRemoteIPAddress(), peer.getRemotePort());\n        return packet;\n    }","id":104962,"modified_method":"/**\n     *  Build the ack packet. The list need not be sorted into full and partial;\n     *  this method will put all fulls before the partials in the outgoing packet.\n     *  An ack packet is just a data packet with no data.\n     *  See buildPacket() for format.\n     *\n     *  TODO MTU not enforced.\n     *  TODO handle huge number of acks better\n     *\n     * @param ackBitfields list of ACKBitfield instances to either fully or partially ACK\n     */\n    public UDPPacket buildACK(PeerState peer, List<ACKBitfield> ackBitfields) {\n        UDPPacket packet = buildPacketHeader((byte)(UDPPacket.PAYLOAD_TYPE_DATA << 4));\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        \n        StringBuilder msg = null;\n        if (_log.shouldLog(Log.DEBUG)) {\n            msg = new StringBuilder(128);\n            msg.append(\"building ACK packet to \").append(peer.getRemotePeer().toBase64().substring(0,6));\n        }\n\n        int fullACKCount = 0;\n        int partialACKCount = 0;\n        for (int i = 0; i < ackBitfields.size(); i++) {\n            if (ackBitfields.get(i).receivedComplete())\n                fullACKCount++;\n            else\n                partialACKCount++;\n        }\n        // FIXME do better than this, we could still exceed MTU\n        if (fullACKCount > ABSOLUTE_MAX_ACKS ||\n            partialACKCount > ABSOLUTE_MAX_ACKS)\n            throw new IllegalArgumentException(\"Too many acks full/partial \" + fullACKCount +\n                                               '/' + partialACKCount);\n\n        // ok, now for the body...\n        if (fullACKCount > 0)\n            data[off] |= UDPPacket.DATA_FLAG_EXPLICIT_ACK;\n        if (partialACKCount > 0)\n            data[off] |= UDPPacket.DATA_FLAG_ACK_BITFIELDS;\n        // add ECN if (peer.getSomethingOrOther())\n        off++;\n        \n        if (fullACKCount > 0) {\n            DataHelper.toLong(data, off, 1, fullACKCount);\n            off++;\n            for (int i = 0; i < ackBitfields.size(); i++) {\n                ACKBitfield bf = ackBitfields.get(i);\n                if (bf.receivedComplete()) {\n                    DataHelper.toLong(data, off, 4, bf.getMessageId());\n                    off += 4;\n                    if (msg != null) // logging it\n                        msg.append(\" full ack: \").append(bf.getMessageId());\n                }\n            }\n        }\n        \n        if (partialACKCount > 0) {\n            DataHelper.toLong(data, off, 1, partialACKCount);\n            off++;\n            for (int i = 0; i < ackBitfields.size(); i++) {\n                ACKBitfield bitfield = ackBitfields.get(i);\n                if (bitfield.receivedComplete()) continue;\n                DataHelper.toLong(data, off, 4, bitfield.getMessageId());\n                off += 4;\n                int bits = bitfield.fragmentCount();\n                int size = (bits / 7) + 1;\n                for (int curByte = 0; curByte < size; curByte++) {\n                    if (curByte + 1 < size)\n                        data[off] |= (byte)(1 << 7);\n                    \n                    for (int curBit = 0; curBit < 7; curBit++) {\n                        if (bitfield.received(curBit + 7*curByte))\n                            data[off] |= (byte)(1 << curBit);\n                    }\n                    off++;\n                }\n                \n                if (msg != null) // logging it\n                    msg.append(\" partial ack: \").append(bitfield);\n            }\n        }\n        \n        DataHelper.toLong(data, off, 1, 0); // no fragments in this message\n        off++;\n        \n        if (msg != null)\n            _log.debug(msg.toString());\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, peer.getCurrentCipherKey(), peer.getCurrentMACKey());\n        setTo(packet, peer.getRemoteIPAddress(), peer.getRemotePort());\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"UDPPacket buildRelayResponse(RemoteHostId alice, PeerState charlie, long nonce, SessionKey aliceIntroKey) {\n        InetAddress aliceAddr = null;\n        try {\n            aliceAddr = InetAddress.getByAddress(alice.getIP());\n        } catch (UnknownHostException uhe) {\n            return null;\n        }\n        \n        UDPPacket packet = buildPacketHeader(PEER_RELAY_RESPONSE_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        \n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Sending relay response to \" + alice + \" for \" + charlie + \" with alice's intro key \" + aliceIntroKey);\n\n        // now for the body\n        byte charlieIP[] = charlie.getRemoteIP();\n        DataHelper.toLong(data, off, 1, charlieIP.length);\n        off++;\n        System.arraycopy(charlieIP, 0, data, off, charlieIP.length);\n        off += charlieIP.length;\n        DataHelper.toLong(data, off, 2, charlie.getRemotePort());\n        off += 2;\n        \n        byte aliceIP[] = alice.getIP();\n        DataHelper.toLong(data, off, 1, aliceIP.length);\n        off++;\n        System.arraycopy(aliceIP, 0, data, off, aliceIP.length);\n        off += aliceIP.length;\n        DataHelper.toLong(data, off, 2, alice.getPort());\n        off += 2;\n        \n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, aliceIntroKey, aliceIntroKey);\n        setTo(packet, aliceAddr, alice.getPort());\n        packet.setMessageType(TYPE_RESP);\n        return packet;\n    }","id":104963,"modified_method":"UDPPacket buildRelayResponse(RemoteHostId alice, PeerState charlie, long nonce, SessionKey aliceIntroKey) {\n        InetAddress aliceAddr = null;\n        try {\n            aliceAddr = InetAddress.getByAddress(alice.getIP());\n        } catch (UnknownHostException uhe) {\n            return null;\n        }\n        \n        UDPPacket packet = buildPacketHeader(PEER_RELAY_RESPONSE_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        \n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Sending relay response to \" + alice + \" for \" + charlie + \" with alice's intro key \" + aliceIntroKey);\n\n        // now for the body\n        byte charlieIP[] = charlie.getRemoteIP();\n        DataHelper.toLong(data, off, 1, charlieIP.length);\n        off++;\n        System.arraycopy(charlieIP, 0, data, off, charlieIP.length);\n        off += charlieIP.length;\n        DataHelper.toLong(data, off, 2, charlie.getRemotePort());\n        off += 2;\n        \n        byte aliceIP[] = alice.getIP();\n        DataHelper.toLong(data, off, 1, aliceIP.length);\n        off++;\n        System.arraycopy(aliceIP, 0, data, off, aliceIP.length);\n        off += aliceIP.length;\n        DataHelper.toLong(data, off, 2, alice.getPort());\n        off += 2;\n        \n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, aliceIntroKey, aliceIntroKey);\n        setTo(packet, aliceAddr, alice.getPort());\n        packet.setMessageType(TYPE_RESP);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Encrypt the packet with the cipher key and the given IV, generate a \n     * MAC for that encrypted data and IV, and store the result in the packet.\n     * The MAC used is: \n     *     HMAC-SHA256(payload || IV || (payloadLength ^ protocolVersion), macKey)[0:15]\n     *\n     * @param packet prepared packet with the first 32 bytes empty and a length\n     *               whose size is mod 16\n     * @param cipherKey key to encrypt the payload \n     * @param macKey key to generate the, er, MAC\n     * @param iv IV to deliver\n     */\n    private void authenticate(UDPPacket packet, SessionKey cipherKey, SessionKey macKey, byte[] iv) {\n        long before = System.currentTimeMillis();\n        int encryptOffset = packet.getPacket().getOffset() + UDPPacket.IV_SIZE + UDPPacket.MAC_SIZE;\n        int encryptSize = packet.getPacket().getLength() - UDPPacket.IV_SIZE - UDPPacket.MAC_SIZE - packet.getPacket().getOffset();\n        byte data[] = packet.getPacket().getData();\n        _context.aes().encrypt(data, encryptOffset, data, encryptOffset, cipherKey, iv, encryptSize);\n        \n        // ok, now we need to prepare things for the MAC, which requires reordering\n        int off = packet.getPacket().getOffset();\n        System.arraycopy(data, encryptOffset, data, off, encryptSize);\n        off += encryptSize;\n        System.arraycopy(iv, 0, data, off, UDPPacket.IV_SIZE);\n        off += UDPPacket.IV_SIZE;\n        DataHelper.toLong(data, off, 2, encryptSize /* ^ PROTOCOL_VERSION */ );\n        \n        int hmacOff = packet.getPacket().getOffset();\n        int hmacLen = encryptSize + UDPPacket.IV_SIZE + 2;\n        //Hash hmac = _context.hmac().calculate(macKey, data, hmacOff, hmacLen);\n        byte[] ba = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n        _context.hmac().calculate(macKey, data, hmacOff, hmacLen, ba, 0);\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Authenticating \" + packet.getPacket().getLength() +\n                       \"\\nIV: \" + Base64.encode(iv) +\n                       \"\\nraw mac: \" + Base64.encode(ba) +\n                       \"\\nMAC key: \" + macKey);\n        // ok, now lets put it back where it belongs...\n        System.arraycopy(data, hmacOff, data, encryptOffset, encryptSize);\n        //System.arraycopy(hmac.getData(), 0, data, hmacOff, UDPPacket.MAC_SIZE);\n        System.arraycopy(ba, 0, data, hmacOff, UDPPacket.MAC_SIZE);\n        System.arraycopy(iv, 0, data, hmacOff + UDPPacket.MAC_SIZE, UDPPacket.IV_SIZE);\n        SimpleByteCache.release(ba);\n        long timeToAuth = System.currentTimeMillis() - before;\n        _context.statManager().addRateData(\"udp.packetAuthTime\", timeToAuth, timeToAuth);\n        if (timeToAuth > 100)\n            _context.statManager().addRateData(\"udp.packetAuthTimeSlow\", timeToAuth, timeToAuth);\n    }","id":104964,"modified_method":"/**\n     * Encrypt the packet with the cipher key and the given IV, generate a \n     * MAC for that encrypted data and IV, and store the result in the packet.\n     * The MAC used is: \n     *     HMAC-SHA256(payload || IV || (payloadLength ^ protocolVersion), macKey)[0:15]\n     *\n     * @param packet prepared packet with the first 32 bytes empty and a length\n     *               whose size is mod 16.\n     *               As of 0.9.7, length non-mod-16 is allowed; the\n     *               last 1-15 bytes are included in the MAC calculation but are not encrypted.\n     * @param cipherKey key to encrypt the payload \n     * @param macKey key to generate the, er, MAC\n     * @param iv IV to deliver\n     */\n    private void authenticate(UDPPacket packet, SessionKey cipherKey, SessionKey macKey, byte[] iv) {\n        long before = System.currentTimeMillis();\n        DatagramPacket pkt = packet.getPacket();\n        int off = pkt.getOffset();\n        int hmacOff = off;\n        int encryptOffset = off + UDPPacket.IV_SIZE + UDPPacket.MAC_SIZE;\n        // including 1-15 pad\n        int totalSize = pkt.getLength() - UDPPacket.IV_SIZE - UDPPacket.MAC_SIZE - off;\n        int mod = totalSize & 0x0f;\n        // not including 1-15 pad\n        int encryptSize = totalSize - mod;\n        byte data[] = pkt.getData();\n        _context.aes().encrypt(data, encryptOffset, data, encryptOffset, cipherKey, iv, encryptSize);\n        \n        // ok, now we need to prepare things for the MAC, which requires reordering\n        // Payload + IV + payloadLength\n        System.arraycopy(data, encryptOffset, data, off, totalSize);\n        off += totalSize;\n        System.arraycopy(iv, 0, data, off, UDPPacket.IV_SIZE);\n        off += UDPPacket.IV_SIZE;\n        DataHelper.toLong(data, off, 2, totalSize /* ^ PROTOCOL_VERSION */ );\n        \n        int hmacLen = totalSize + UDPPacket.IV_SIZE + 2;\n        //Hash hmac = _context.hmac().calculate(macKey, data, hmacOff, hmacLen);\n        byte[] ba = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n        _context.hmac().calculate(macKey, data, hmacOff, hmacLen, ba, 0);\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Authenticating \" + pkt.getLength() +\n                       \"\\nIV: \" + Base64.encode(iv) +\n                       \"\\nraw mac: \" + Base64.encode(ba) +\n                       \"\\nMAC key: \" + macKey);\n        // ok, now lets put it back where it belongs...\n        // MAC + IV + payload\n        System.arraycopy(data, hmacOff, data, encryptOffset, totalSize);\n        //System.arraycopy(hmac.getData(), 0, data, hmacOff, UDPPacket.MAC_SIZE);\n        System.arraycopy(ba, 0, data, hmacOff, UDPPacket.MAC_SIZE);\n        SimpleByteCache.release(ba);\n        System.arraycopy(iv, 0, data, hmacOff + UDPPacket.MAC_SIZE, UDPPacket.IV_SIZE);\n        long timeToAuth = System.currentTimeMillis() - before;\n        _context.statManager().addRateData(\"udp.packetAuthTime\", timeToAuth, timeToAuth);\n        if (timeToAuth > 100)\n            _context.statManager().addRateData(\"udp.packetAuthTimeSlow\", timeToAuth, timeToAuth);\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * This builds a data packet (PAYLOAD_TYPE_DATA).\n     * See the methods below for the other message types.\n     *\n     * Note that while the UDP message spec allows for more than one fragment in a message,\n     * this method writes exactly one fragment.\n     * For no fragments use buildAck().\n     * Multiple fragments in a single packet is not supported.\n     * Rekeying and extended options are not supported.\n     *\n     * Packet format:\n     *<pre>\n     *    16 byte MAC\n     *    16 byte IV\n     *     1 byte flag\n     *     4 byte date\n     *     1 byte flag\n     *     1 byte explicit ack count IF included\n     *   4*n byte explict acks IF included\n     *     1 byte ack bitfield count IF included\n     *   4*n + ?? ack bitfields IF included\n     *     1 byte fragment count (always 1)\n     *     4 byte message ID\n     *     3 byte fragment info\n     *     n byte fragment\n     *  0-15 bytes padding\n     *<\/pre>\n     *\n     * So ignoring the ack bitfields, and assuming we have explicit acks,\n     * it's (47 + 4*explict acks + padding) added to the\n     * fragment length.\n     *\n     * @param ackIdsRemaining list of messageIds (Long) that should be acked by this packet.  \n     *                        The list itself is passed by reference, and if a messageId is\n     *                        transmitted it will be removed from the list.\n     *                        Not all message IDs will necessarily be sent, there may not be room.\n     *                        non-null.\n     *\n     * @param newAckCount the number of ackIdsRemaining entries that are new. These must be the first\n     *                    ones in the list\n     *\n     * @param partialACKsRemaining list of messageIds (ACKBitfield) that should be acked by this packet.  \n     *                        The list itself is passed by reference, and if a messageId is\n     *                        included, it should be removed from the list.\n     *                        Full acks in this list are skipped, they are NOT transmitted.\n     *                        non-null.\n     *                        Not all acks will necessarily be sent, there may not be room.\n     *\n     * @return null on error\n     */\n    public UDPPacket buildPacket(OutboundMessageState state, int fragment, PeerState peer,\n                                 List<Long> ackIdsRemaining, int newAckCount,\n                                 List<ACKBitfield> partialACKsRemaining) {\n        UDPPacket packet = buildPacketHeader((byte)(UDPPacket.PAYLOAD_TYPE_DATA << 4));\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n\n        StringBuilder msg = null;\n        if (_log.shouldLog(Log.INFO)) {\n            msg = new StringBuilder(128);\n            msg.append(\"Data pkt to \").append(peer.getRemotePeer().toBase64());\n            msg.append(\" msg \").append(state.getMessageId()).append(\" frag:\").append(fragment);\n            msg.append('/').append(state.getFragmentCount());\n        }\n        \n        int dataSize = state.fragmentSize(fragment);\n        if (dataSize < 0) {\n            packet.release();\n            return null;\n        }\n\n        int currentMTU = peer.getMTU();\n        int availableForAcks = currentMTU - MIN_DATA_PACKET_OVERHEAD - dataSize;\n        int availableForExplicitAcks = availableForAcks;\n\n        // ok, now for the body...\n        \n        // just always ask for an ACK for now...\n        data[off] |= UDPPacket.DATA_FLAG_WANT_REPLY;\n\n        // partial acks have priority but they are after explicit acks in the packet\n        // so we have to compute the space in advance\n        int partialAcksToSend = 0;\n        if (availableForExplicitAcks >= 6 && !partialACKsRemaining.isEmpty()) {\n            for (ACKBitfield bf : partialACKsRemaining) {\n                if (partialAcksToSend >= ABSOLUTE_MAX_ACKS)\n                    break;  // ack count\n                if (bf.receivedComplete())\n                    continue;\n                int acksz = 4 + (bf.fragmentCount() / 7) + 1;\n                if (partialAcksToSend == 0)\n                    acksz++;  // ack count\n                if (availableForExplicitAcks >= acksz) {\n                    availableForExplicitAcks -= acksz;\n                    partialAcksToSend++;\n                } else {\n                    break;\n                }\n            }\n            if (partialAcksToSend > 0)\n                data[off] |= UDPPacket.DATA_FLAG_ACK_BITFIELDS;\n        }\n\n\n        // Only include acks if we have at least 5 bytes available and at least\n        // one ack is requested.\n        if (availableForExplicitAcks >= 5 && !ackIdsRemaining.isEmpty()) {\n            data[off] |= UDPPacket.DATA_FLAG_EXPLICIT_ACK;\n        }\n        off++;\n\n        if (msg != null) {\n            msg.append(\" data: \").append(dataSize).append(\" bytes, mtu: \")\n               .append(currentMTU).append(\", \")\n               .append(newAckCount).append(\" new full acks requested, \")\n               .append(ackIdsRemaining.size() - newAckCount).append(\" resend acks requested, \")\n               .append(partialACKsRemaining.size()).append(\" partial acks requested, \")\n               .append(availableForAcks).append(\" avail. for all acks, \")\n               .append(availableForExplicitAcks).append(\" for full acks, \");\n        }\n\n        // always send all the new acks if we have room\n        int explicitToSend = Math.min(ABSOLUTE_MAX_ACKS,\n                                      Math.min(newAckCount + (currentMTU > PeerState.MIN_MTU ? MAX_RESEND_ACKS_LARGE : MAX_RESEND_ACKS_SMALL),\n                                               Math.min((availableForExplicitAcks - 1) / 4, ackIdsRemaining.size())));\n        if (explicitToSend > 0) {\n            if (msg != null)\n                msg.append(explicitToSend).append(\" full acks included:\");\n            DataHelper.toLong(data, off, 1, explicitToSend);\n            off++;\n            Iterator<Long> iter = ackIdsRemaining.iterator();\n            for (int i = 0; i < explicitToSend && iter.hasNext(); i++) {\n                Long ackId = iter.next();\n                iter.remove();\n                // NPE here, how did a null get in the List?\n                DataHelper.toLong(data, off, 4, ackId.longValue());\n                off += 4;        \n                if (msg != null) // logging it\n                    msg.append(\" full ack: \").append(ackId.longValue());\n            }\n            //acksIncluded = true;\n        }\n\n        if (partialAcksToSend > 0) {\n            if (msg != null)\n                msg.append(partialAcksToSend).append(\" partial acks included:\");\n            int origNumRemaining = partialACKsRemaining.size();\n            int numPartialOffset = off;\n            // leave it blank for now, since we could skip some\n            off++;\n            Iterator<ACKBitfield> iter = partialACKsRemaining.iterator();\n            for (int i = 0; i < partialAcksToSend && iter.hasNext(); i++) {\n                ACKBitfield bitfield = iter.next();\n                if (bitfield.receivedComplete()) continue;\n                DataHelper.toLong(data, off, 4, bitfield.getMessageId());\n                off += 4;\n                int bits = bitfield.fragmentCount();\n                int size = (bits / 7) + 1;\n                for (int curByte = 0; curByte < size; curByte++) {\n                    if (curByte + 1 < size)\n                        data[off] |= (byte)(1 << 7);\n                    \n                    for (int curBit = 0; curBit < 7; curBit++) {\n                        if (bitfield.received(curBit + 7*curByte))\n                            data[off] |= (byte)(1 << curBit);\n                    }\n                    off++;\n                }\n                iter.remove();\n                if (msg != null) // logging it\n                    msg.append(\" partial ack: \").append(bitfield);\n            }\n            //acksIncluded = true;\n            // now jump back and fill in the number of bitfields *actually* included\n            DataHelper.toLong(data, numPartialOffset, 1, origNumRemaining - partialACKsRemaining.size());\n        }\n        \n        //if ( (msg != null) && (acksIncluded) )\n        //  _log.debug(msg.toString());\n        \n        DataHelper.toLong(data, off, 1, 1); // only one fragment in this message\n        off++;\n        \n        DataHelper.toLong(data, off, 4, state.getMessageId());\n        off += 4;\n        \n        data[off] |= fragment << 1;\n        if (fragment == state.getFragmentCount() - 1)\n            data[off] |= 1; // isLast\n        off++;\n        \n        DataHelper.toLong(data, off, 2, dataSize);\n        data[off] &= (byte)0x3F; // 2 highest bits are reserved\n        off += 2;\n        \n        int sizeWritten = state.writeFragment(data, off, fragment);\n        if (sizeWritten != dataSize) {\n            if (sizeWritten < 0) {\n                // probably already freed from OutboundMessageState\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Write failed for fragment \" + fragment + \" of \" + state.getMessageId());\n            } else {\n                _log.error(\"Size written: \" + sizeWritten + \" but size: \" + dataSize \n                           + \" for fragment \" + fragment + \" of \" + state.getMessageId());\n            }\n            packet.release();\n            return null;\n        //} else if (_log.shouldLog(Log.DEBUG)) {\n        //    _log.debug(\"Size written: \" + sizeWritten + \" for fragment \" + fragment \n        //               + \" of \" + state.getMessageId());\n        }\n        // put this after writeFragment() since dataSize will be zero for use-after-free\n        if (dataSize == 0) {\n            // OK according to the protocol but if we send it, it's a bug\n            _log.error(\"Sending zero-size fragment \" + fragment + \" of \" + state + \" for \" + peer);\n        }\n        off += dataSize;\n\n        \n        // pad up so we're on the encryption boundary\n        // we could do additional random padding here if desired\n        int mod = off % 16;\n        if (mod > 0) {\n            int padSize = 16 - mod;\n            _context.random().nextBytes(data, off, padSize);\n            off += padSize;\n        }\n        packet.getPacket().setLength(off);\n\n        authenticate(packet, peer.getCurrentCipherKey(), peer.getCurrentMACKey());\n        setTo(packet, peer.getRemoteIPAddress(), peer.getRemotePort());\n        \n        if (_log.shouldLog(Log.INFO)) {\n            msg.append(\" pkt size \").append(off + (IP_HEADER_SIZE + UDP_HEADER_SIZE));\n            _log.info(msg.toString());\n        }\n        // the packet could have been built before the current mtu got lowered, so\n        // compare to LARGE_MTU\n        if (off + (IP_HEADER_SIZE + UDP_HEADER_SIZE) > PeerState.LARGE_MTU) {\n            _log.error(\"Size is \" + off + \" for \" + packet +\n                       \" fragment \" + fragment +\n                       \" data size \" + dataSize +\n                       \" pkt size \" + (off + (IP_HEADER_SIZE + UDP_HEADER_SIZE)) +\n                       \" MTU \" + currentMTU +\n                       ' ' + availableForAcks + \" for all acks \" +\n                       availableForExplicitAcks + \" for full acks \" + \n                       explicitToSend + \" full acks included \" +\n                       partialAcksToSend + \" partial acks included \" +\n                       \" OMS \" + state, new Exception());\n        }\n        \n        return packet;\n    }","id":104965,"modified_method":"/**\n     * This builds a data packet (PAYLOAD_TYPE_DATA).\n     * See the methods below for the other message types.\n     *\n     * Note that while the UDP message spec allows for more than one fragment in a message,\n     * this method writes exactly one fragment.\n     * For no fragments use buildAck().\n     * Multiple fragments in a single packet is not supported.\n     * Rekeying and extended options are not supported.\n     *\n     * Packet format:\n     *<pre>\n     *    16 byte MAC\n     *    16 byte IV\n     *     1 byte flag\n     *     4 byte date\n     *     1 byte flag\n     *     1 byte explicit ack count IF included\n     *   4*n byte explict acks IF included\n     *     1 byte ack bitfield count IF included\n     *   4*n + ?? ack bitfields IF included\n     *     1 byte fragment count (always 1)\n     *     4 byte message ID\n     *     3 byte fragment info\n     *     n byte fragment\n     *  0-15 bytes padding\n     *<\/pre>\n     *\n     * So ignoring the ack bitfields, and assuming we have explicit acks,\n     * it's (47 + 4*explict acks + padding) added to the\n     * fragment length.\n     *\n     * @param ackIdsRemaining list of messageIds (Long) that should be acked by this packet.  \n     *                        The list itself is passed by reference, and if a messageId is\n     *                        transmitted it will be removed from the list.\n     *                        Not all message IDs will necessarily be sent, there may not be room.\n     *                        non-null.\n     *\n     * @param newAckCount the number of ackIdsRemaining entries that are new. These must be the first\n     *                    ones in the list\n     *\n     * @param partialACKsRemaining list of messageIds (ACKBitfield) that should be acked by this packet.  \n     *                        The list itself is passed by reference, and if a messageId is\n     *                        included, it should be removed from the list.\n     *                        Full acks in this list are skipped, they are NOT transmitted.\n     *                        non-null.\n     *                        Not all acks will necessarily be sent, there may not be room.\n     *\n     * @return null on error\n     */\n    public UDPPacket buildPacket(OutboundMessageState state, int fragment, PeerState peer,\n                                 List<Long> ackIdsRemaining, int newAckCount,\n                                 List<ACKBitfield> partialACKsRemaining) {\n        UDPPacket packet = buildPacketHeader((byte)(UDPPacket.PAYLOAD_TYPE_DATA << 4));\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n\n        StringBuilder msg = null;\n        if (_log.shouldLog(Log.INFO)) {\n            msg = new StringBuilder(128);\n            msg.append(\"Data pkt to \").append(peer.getRemotePeer().toBase64());\n            msg.append(\" msg \").append(state.getMessageId()).append(\" frag:\").append(fragment);\n            msg.append('/').append(state.getFragmentCount());\n        }\n        \n        int dataSize = state.fragmentSize(fragment);\n        if (dataSize < 0) {\n            packet.release();\n            return null;\n        }\n\n        int currentMTU = peer.getMTU();\n        int availableForAcks = currentMTU - MIN_DATA_PACKET_OVERHEAD - dataSize;\n        int availableForExplicitAcks = availableForAcks;\n\n        // ok, now for the body...\n        \n        // just always ask for an ACK for now...\n        data[off] |= UDPPacket.DATA_FLAG_WANT_REPLY;\n\n        // partial acks have priority but they are after explicit acks in the packet\n        // so we have to compute the space in advance\n        int partialAcksToSend = 0;\n        if (availableForExplicitAcks >= 6 && !partialACKsRemaining.isEmpty()) {\n            for (ACKBitfield bf : partialACKsRemaining) {\n                if (partialAcksToSend >= ABSOLUTE_MAX_ACKS)\n                    break;  // ack count\n                if (bf.receivedComplete())\n                    continue;\n                int acksz = 4 + (bf.fragmentCount() / 7) + 1;\n                if (partialAcksToSend == 0)\n                    acksz++;  // ack count\n                if (availableForExplicitAcks >= acksz) {\n                    availableForExplicitAcks -= acksz;\n                    partialAcksToSend++;\n                } else {\n                    break;\n                }\n            }\n            if (partialAcksToSend > 0)\n                data[off] |= UDPPacket.DATA_FLAG_ACK_BITFIELDS;\n        }\n\n\n        // Only include acks if we have at least 5 bytes available and at least\n        // one ack is requested.\n        if (availableForExplicitAcks >= 5 && !ackIdsRemaining.isEmpty()) {\n            data[off] |= UDPPacket.DATA_FLAG_EXPLICIT_ACK;\n        }\n        off++;\n\n        if (msg != null) {\n            msg.append(\" data: \").append(dataSize).append(\" bytes, mtu: \")\n               .append(currentMTU).append(\", \")\n               .append(newAckCount).append(\" new full acks requested, \")\n               .append(ackIdsRemaining.size() - newAckCount).append(\" resend acks requested, \")\n               .append(partialACKsRemaining.size()).append(\" partial acks requested, \")\n               .append(availableForAcks).append(\" avail. for all acks, \")\n               .append(availableForExplicitAcks).append(\" for full acks, \");\n        }\n\n        // always send all the new acks if we have room\n        int explicitToSend = Math.min(ABSOLUTE_MAX_ACKS,\n                                      Math.min(newAckCount + (currentMTU > PeerState.MIN_MTU ? MAX_RESEND_ACKS_LARGE : MAX_RESEND_ACKS_SMALL),\n                                               Math.min((availableForExplicitAcks - 1) / 4, ackIdsRemaining.size())));\n        if (explicitToSend > 0) {\n            if (msg != null)\n                msg.append(explicitToSend).append(\" full acks included:\");\n            DataHelper.toLong(data, off, 1, explicitToSend);\n            off++;\n            Iterator<Long> iter = ackIdsRemaining.iterator();\n            for (int i = 0; i < explicitToSend && iter.hasNext(); i++) {\n                Long ackId = iter.next();\n                iter.remove();\n                // NPE here, how did a null get in the List?\n                DataHelper.toLong(data, off, 4, ackId.longValue());\n                off += 4;        \n                if (msg != null) // logging it\n                    msg.append(\" full ack: \").append(ackId.longValue());\n            }\n            //acksIncluded = true;\n        }\n\n        if (partialAcksToSend > 0) {\n            if (msg != null)\n                msg.append(partialAcksToSend).append(\" partial acks included:\");\n            int origNumRemaining = partialACKsRemaining.size();\n            int numPartialOffset = off;\n            // leave it blank for now, since we could skip some\n            off++;\n            Iterator<ACKBitfield> iter = partialACKsRemaining.iterator();\n            for (int i = 0; i < partialAcksToSend && iter.hasNext(); i++) {\n                ACKBitfield bitfield = iter.next();\n                if (bitfield.receivedComplete()) continue;\n                DataHelper.toLong(data, off, 4, bitfield.getMessageId());\n                off += 4;\n                int bits = bitfield.fragmentCount();\n                int size = (bits / 7) + 1;\n                for (int curByte = 0; curByte < size; curByte++) {\n                    if (curByte + 1 < size)\n                        data[off] |= (byte)(1 << 7);\n                    \n                    for (int curBit = 0; curBit < 7; curBit++) {\n                        if (bitfield.received(curBit + 7*curByte))\n                            data[off] |= (byte)(1 << curBit);\n                    }\n                    off++;\n                }\n                iter.remove();\n                if (msg != null) // logging it\n                    msg.append(\" partial ack: \").append(bitfield);\n            }\n            //acksIncluded = true;\n            // now jump back and fill in the number of bitfields *actually* included\n            DataHelper.toLong(data, numPartialOffset, 1, origNumRemaining - partialACKsRemaining.size());\n        }\n        \n        //if ( (msg != null) && (acksIncluded) )\n        //  _log.debug(msg.toString());\n        \n        DataHelper.toLong(data, off, 1, 1); // only one fragment in this message\n        off++;\n        \n        DataHelper.toLong(data, off, 4, state.getMessageId());\n        off += 4;\n        \n        data[off] |= fragment << 1;\n        if (fragment == state.getFragmentCount() - 1)\n            data[off] |= 1; // isLast\n        off++;\n        \n        DataHelper.toLong(data, off, 2, dataSize);\n        data[off] &= (byte)0x3F; // 2 highest bits are reserved\n        off += 2;\n        \n        int sizeWritten = state.writeFragment(data, off, fragment);\n        if (sizeWritten != dataSize) {\n            if (sizeWritten < 0) {\n                // probably already freed from OutboundMessageState\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Write failed for fragment \" + fragment + \" of \" + state.getMessageId());\n            } else {\n                _log.error(\"Size written: \" + sizeWritten + \" but size: \" + dataSize \n                           + \" for fragment \" + fragment + \" of \" + state.getMessageId());\n            }\n            packet.release();\n            return null;\n        //} else if (_log.shouldLog(Log.DEBUG)) {\n        //    _log.debug(\"Size written: \" + sizeWritten + \" for fragment \" + fragment \n        //               + \" of \" + state.getMessageId());\n        }\n        // put this after writeFragment() since dataSize will be zero for use-after-free\n        if (dataSize == 0) {\n            // OK according to the protocol but if we send it, it's a bug\n            _log.error(\"Sending zero-size fragment \" + fragment + \" of \" + state + \" for \" + peer);\n        }\n        off += dataSize;\n\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off, currentMTU);\n        pkt.setLength(off);\n\n        authenticate(packet, peer.getCurrentCipherKey(), peer.getCurrentMACKey());\n        setTo(packet, peer.getRemoteIPAddress(), peer.getRemotePort());\n        \n        if (_log.shouldLog(Log.INFO)) {\n            msg.append(\" pkt size \").append(off + (IP_HEADER_SIZE + UDP_HEADER_SIZE));\n            _log.info(msg.toString());\n        }\n        // the packet could have been built before the current mtu got lowered, so\n        // compare to LARGE_MTU\n        if (off + (IP_HEADER_SIZE + UDP_HEADER_SIZE) > PeerState.LARGE_MTU) {\n            _log.error(\"Size is \" + off + \" for \" + packet +\n                       \" fragment \" + fragment +\n                       \" data size \" + dataSize +\n                       \" pkt size \" + (off + (IP_HEADER_SIZE + UDP_HEADER_SIZE)) +\n                       \" MTU \" + currentMTU +\n                       ' ' + availableForAcks + \" for all acks \" +\n                       availableForExplicitAcks + \" for full acks \" + \n                       explicitToSend + \" full acks included \" +\n                       partialAcksToSend + \" partial acks included \" +\n                       \" OMS \" + state, new Exception());\n        }\n        \n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Build a packet as if we are either Bob or Charlie and we are helping test Alice.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestToAlice(InetAddress aliceIP, int alicePort, SessionKey aliceIntroKey, SessionKey charlieIntroKey, long nonce) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Alice\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        byte ip[] = aliceIP.getAddress();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alicePort);\n        off += 2;\n        System.arraycopy(charlieIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, aliceIntroKey, aliceIntroKey);\n        setTo(packet, aliceIP, alicePort);\n        packet.setMessageType(TYPE_TTA);\n        return packet;\n    }","id":104966,"modified_method":"/**\n     * Build a packet as if we are either Bob or Charlie and we are helping test Alice.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestToAlice(InetAddress aliceIP, int alicePort, SessionKey aliceIntroKey, SessionKey charlieIntroKey, long nonce) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Alice\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        byte ip[] = aliceIP.getAddress();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alicePort);\n        off += 2;\n        System.arraycopy(charlieIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, aliceIntroKey, aliceIntroKey);\n        setTo(packet, aliceIP, alicePort);\n        packet.setMessageType(TYPE_TTA);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Build a new SessionConfirmed packet for the given peer\n     * \n     * @return ready to send packets, or null if there was a problem\n     */\n    public UDPPacket buildSessionConfirmedPacket(OutboundEstablishState state, int fragmentNum, int numFragments, byte identity[]) {\n        UDPPacket packet = buildPacketHeader(SESSION_CONFIRMED_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n\n        InetAddress to = null;\n        try {\n            to = InetAddress.getByAddress(state.getSentIP());\n        } catch (UnknownHostException uhe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\n            packet.release();\n            return null;\n        }\n        \n        // now for the body\n        data[off] |= fragmentNum << 4;\n        data[off] |= (numFragments & 0xF);\n        off++;\n        \n        int curFragSize = MAX_IDENTITY_FRAGMENT_SIZE;\n        if (fragmentNum == numFragments-1) {\n            if (identity.length % MAX_IDENTITY_FRAGMENT_SIZE != 0)\n                curFragSize = identity.length % MAX_IDENTITY_FRAGMENT_SIZE;\n        }\n        \n        DataHelper.toLong(data, off, 2, curFragSize);\n        off += 2;\n        \n        int curFragOffset = fragmentNum * MAX_IDENTITY_FRAGMENT_SIZE;\n        System.arraycopy(identity, curFragOffset, data, off, curFragSize);\n        off += curFragSize;\n        \n        if (fragmentNum == numFragments - 1) {\n            DataHelper.toLong(data, off, 4, state.getSentSignedOnTime());\n            off += 4;\n            \n            int paddingRequired = 0;\n            // we need to pad this so we're at the encryption boundary\n            if ( (off + Signature.SIGNATURE_BYTES) % 16 != 0)\n                paddingRequired += 16 - ((off + Signature.SIGNATURE_BYTES) % 16);\n            \n            // add an arbitrary number of 16byte pad blocks too...\n            \n            for (int i = 0; i < paddingRequired; i++) {\n                data[off] = (byte)_context.random().nextInt(255);\n                off++;\n            }\n            \n            // BUG: NPE here if null signature\n            System.arraycopy(state.getSentSignature().getData(), 0, data, off, Signature.SIGNATURE_BYTES);\n            off += Signature.SIGNATURE_BYTES;\n        } else {\n            // nothing more to add beyond the identity fragment, though we can\n            // pad here if we want.  maybe randomized?\n\n            // pad up so we're on the encryption boundary\n            // TODO: why not random data?\n            if ( (off % 16) != 0)\n                off += 16 - (off % 16);\n        } \n        packet.getPacket().setLength(off);\n        authenticate(packet, state.getCipherKey(), state.getMACKey());\n        \n        setTo(packet, to, state.getSentPort());\n        packet.setMessageType(TYPE_CONF);\n        return packet;\n    }","id":104967,"modified_method":"/**\n     * Build a new SessionConfirmed packet for the given peer\n     * \n     * @return ready to send packets, or null if there was a problem\n     */\n    private UDPPacket buildSessionConfirmedPacket(OutboundEstablishState state, int fragmentNum, int numFragments, byte identity[]) {\n        UDPPacket packet = buildPacketHeader(SESSION_CONFIRMED_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n\n        InetAddress to = null;\n        try {\n            to = InetAddress.getByAddress(state.getSentIP());\n        } catch (UnknownHostException uhe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\n            packet.release();\n            return null;\n        }\n        \n        // now for the body\n        data[off] |= fragmentNum << 4;\n        data[off] |= (numFragments & 0xF);\n        off++;\n        \n        int curFragSize = MAX_IDENTITY_FRAGMENT_SIZE;\n        if (fragmentNum == numFragments-1) {\n            if (identity.length % MAX_IDENTITY_FRAGMENT_SIZE != 0)\n                curFragSize = identity.length % MAX_IDENTITY_FRAGMENT_SIZE;\n        }\n        \n        DataHelper.toLong(data, off, 2, curFragSize);\n        off += 2;\n        \n        int curFragOffset = fragmentNum * MAX_IDENTITY_FRAGMENT_SIZE;\n        System.arraycopy(identity, curFragOffset, data, off, curFragSize);\n        off += curFragSize;\n        \n        if (fragmentNum == numFragments - 1) {\n            DataHelper.toLong(data, off, 4, state.getSentSignedOnTime());\n            off += 4;\n            \n            // we need to pad this so we're at the encryption boundary\n            int mod = (off + Signature.SIGNATURE_BYTES) & 0x0f;\n            if (mod != 0) {\n                int paddingRequired = 16 - mod;\n                // add an arbitrary number of 16byte pad blocks too ???\n                _context.random().nextBytes(data, off, paddingRequired);\n                off += paddingRequired;\n            }\n            \n            // BUG: NPE here if null signature\n            System.arraycopy(state.getSentSignature().getData(), 0, data, off, Signature.SIGNATURE_BYTES);\n            off += Signature.SIGNATURE_BYTES;\n        } else {\n            // We never get here (see above)\n\n            // nothing more to add beyond the identity fragment\n            // pad up so we're on the encryption boundary\n            off = pad1(data, off);\n        } \n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, state.getCipherKey(), state.getMACKey());\n        setTo(packet, to, state.getSentPort());\n        packet.setMessageType(TYPE_CONF);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Build a new SessionCreated packet for the given peer, encrypting it \n     * as necessary.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildSessionCreatedPacket(InboundEstablishState state, int externalPort, SessionKey ourIntroKey) {\n        UDPPacket packet = buildPacketHeader(SESSION_CREATED_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        \n        InetAddress to = null;\n        try {\n            to = InetAddress.getByAddress(state.getSentIP());\n        } catch (UnknownHostException uhe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\n            packet.release();\n            return null;\n        }\n\n        state.prepareSessionCreated();\n        \n        byte sentIP[] = state.getSentIP();\n        if ( (sentIP == null) || (sentIP.length <= 0) || ( (_transport != null) && (!_transport.isValid(sentIP)) ) ) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did our sent IP become invalid? \" + state);\n            state.fail();\n            packet.release();\n            return null;\n        }\n        // now for the body\n        System.arraycopy(state.getSentY(), 0, data, off, state.getSentY().length);\n        off += state.getSentY().length;\n        DataHelper.toLong(data, off, 1, sentIP.length);\n        off += 1;\n        System.arraycopy(sentIP, 0, data, off, sentIP.length);\n        off += sentIP.length;\n        DataHelper.toLong(data, off, 2, state.getSentPort());\n        off += 2;\n        DataHelper.toLong(data, off, 4, state.getSentRelayTag());\n        off += 4;\n        DataHelper.toLong(data, off, 4, state.getSentSignedOnTime());\n        off += 4;\n        System.arraycopy(state.getSentSignature().getData(), 0, data, off, Signature.SIGNATURE_BYTES);\n        off += Signature.SIGNATURE_BYTES;\n        // ok, we need another 8 bytes of random padding\n        // (ok, this only gives us 63 bits, not 64)\n        long l = _context.random().nextLong();\n        if (l < 0) l = 0 - l;\n        DataHelper.toLong(data, off, 8, l);\n        off += 8;\n        \n        if (_log.shouldLog(Log.DEBUG)) {\n            StringBuilder buf = new StringBuilder(128);\n            buf.append(\"Sending sessionCreated:\");\n            buf.append(\" Alice: \").append(Addresses.toString(sentIP, state.getSentPort()));\n            buf.append(\" Bob: \").append(Addresses.toString(state.getReceivedOurIP(), externalPort));\n            buf.append(\" RelayTag: \").append(state.getSentRelayTag());\n            buf.append(\" SignedOn: \").append(state.getSentSignedOnTime());\n            buf.append(\" signature: \").append(Base64.encode(state.getSentSignature().getData()));\n            buf.append(\"\\nRawCreated: \").append(Base64.encode(data, 0, off)); \n            buf.append(\"\\nsignedTime: \").append(Base64.encode(data, off-8-Signature.SIGNATURE_BYTES-4, 4));\n            _log.debug(buf.toString());\n        }\n        \n        // ok, now the full data is in there, but we also need to encrypt\n        // the signature, which means we need the IV\n        byte[] iv = SimpleByteCache.acquire(UDPPacket.IV_SIZE);\n        _context.random().nextBytes(iv);\n        \n        int encrWrite = Signature.SIGNATURE_BYTES + 8;\n        int sigBegin = off - encrWrite;\n        _context.aes().encrypt(data, sigBegin, data, sigBegin, state.getCipherKey(), iv, encrWrite);\n        \n        // pad up so we're on the encryption boundary\n        int rem = off & 0x0f;\n        if (rem != 0) {\n            // typ. 12 for IPv4 and 0 for IPv6\n            int pad = 16 - rem;\n            //_log.debug(\"Adding padding: \" + pad);\n            _context.random().nextBytes(data, off, pad);\n            off += pad;\n        }\n        packet.getPacket().setLength(off);\n        authenticate(packet, ourIntroKey, ourIntroKey, iv);\n        setTo(packet, to, state.getSentPort());\n        SimpleByteCache.release(iv);\n        packet.setMessageType(TYPE_CREAT);\n        return packet;\n    }","id":104968,"modified_method":"/**\n     * Build a new SessionCreated packet for the given peer, encrypting it \n     * as necessary.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildSessionCreatedPacket(InboundEstablishState state, int externalPort, SessionKey ourIntroKey) {\n        UDPPacket packet = buildPacketHeader(SESSION_CREATED_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        \n        InetAddress to = null;\n        try {\n            to = InetAddress.getByAddress(state.getSentIP());\n        } catch (UnknownHostException uhe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\n            packet.release();\n            return null;\n        }\n\n        state.prepareSessionCreated();\n        \n        byte sentIP[] = state.getSentIP();\n        if ( (sentIP == null) || (sentIP.length <= 0) || ( (_transport != null) && (!_transport.isValid(sentIP)) ) ) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did our sent IP become invalid? \" + state);\n            state.fail();\n            packet.release();\n            return null;\n        }\n        // now for the body\n        System.arraycopy(state.getSentY(), 0, data, off, state.getSentY().length);\n        off += state.getSentY().length;\n        DataHelper.toLong(data, off, 1, sentIP.length);\n        off += 1;\n        System.arraycopy(sentIP, 0, data, off, sentIP.length);\n        off += sentIP.length;\n        DataHelper.toLong(data, off, 2, state.getSentPort());\n        off += 2;\n        DataHelper.toLong(data, off, 4, state.getSentRelayTag());\n        off += 4;\n        DataHelper.toLong(data, off, 4, state.getSentSignedOnTime());\n        off += 4;\n        System.arraycopy(state.getSentSignature().getData(), 0, data, off, Signature.SIGNATURE_BYTES);\n        off += Signature.SIGNATURE_BYTES;\n        // ok, we need another 8 bytes of random padding\n        // (ok, this only gives us 63 bits, not 64)\n        long l = _context.random().nextLong();\n        if (l < 0) l = 0 - l;\n        DataHelper.toLong(data, off, 8, l);\n        off += 8;\n        \n        if (_log.shouldLog(Log.DEBUG)) {\n            StringBuilder buf = new StringBuilder(128);\n            buf.append(\"Sending sessionCreated:\");\n            buf.append(\" Alice: \").append(Addresses.toString(sentIP, state.getSentPort()));\n            buf.append(\" Bob: \").append(Addresses.toString(state.getReceivedOurIP(), externalPort));\n            buf.append(\" RelayTag: \").append(state.getSentRelayTag());\n            buf.append(\" SignedOn: \").append(state.getSentSignedOnTime());\n            buf.append(\" signature: \").append(Base64.encode(state.getSentSignature().getData()));\n            buf.append(\"\\nRawCreated: \").append(Base64.encode(data, 0, off)); \n            buf.append(\"\\nsignedTime: \").append(Base64.encode(data, off-8-Signature.SIGNATURE_BYTES-4, 4));\n            _log.debug(buf.toString());\n        }\n        \n        // ok, now the full data is in there, but we also need to encrypt\n        // the signature, which means we need the IV\n        byte[] iv = SimpleByteCache.acquire(UDPPacket.IV_SIZE);\n        _context.random().nextBytes(iv);\n        \n        int encrWrite = Signature.SIGNATURE_BYTES + 8;\n        int sigBegin = off - encrWrite;\n        _context.aes().encrypt(data, sigBegin, data, sigBegin, state.getCipherKey(), iv, encrWrite);\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, ourIntroKey, ourIntroKey, iv);\n        setTo(packet, to, state.getSentPort());\n        SimpleByteCache.release(iv);\n        packet.setMessageType(TYPE_CREAT);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public UDPPacket buildRelayRequest(InetAddress introHost, int introPort, byte introKey[], long introTag, SessionKey ourIntroKey, long introNonce, boolean encrypt) {\n        UDPPacket packet = buildPacketHeader(PEER_RELAY_REQUEST_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        \n        byte ourIP[] = getOurExplicitIP();\n        int ourPort = getOurExplicitPort();\n        \n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Sending intro relay request to \" + introHost + \":\" + introPort); // + \" regarding \" + state.getRemoteIdentity().calculateHash().toBase64());\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, introTag);\n        off += 4;\n        if (ourIP != null) {\n            DataHelper.toLong(data, off, 1, ourIP.length);\n            off++;\n            System.arraycopy(ourIP, 0, data, off, ourIP.length);\n            off += ourIP.length;\n        } else {\n            DataHelper.toLong(data, off, 1, 0);\n            off++;\n        }\n        \n        DataHelper.toLong(data, off, 2, ourPort);\n        off += 2;\n        \n        // challenge...\n        DataHelper.toLong(data, off, 1, 0);\n        off++;\n        //off += 0; // *cough*\n        \n        System.arraycopy(ourIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"wrote alice intro key: \" + Base64.encode(data, off-SessionKey.KEYSIZE_BYTES, SessionKey.KEYSIZE_BYTES) \n                      + \" with nonce \" + introNonce + \" size=\" + (off+4 + (16 - (off+4)%16))\n                      + \" and data: \" + Base64.encode(data, 0, off));\n        \n        DataHelper.toLong(data, off, 4, introNonce);\n        off += 4;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        if (encrypt)\n            authenticate(packet, new SessionKey(introKey), new SessionKey(introKey));\n        setTo(packet, introHost, introPort);\n        packet.setMessageType(TYPE_RREQ);\n        return packet;\n    }","id":104969,"modified_method":"private UDPPacket buildRelayRequest(InetAddress introHost, int introPort, byte introKey[],\n                                        long introTag, SessionKey ourIntroKey, long introNonce, boolean encrypt) {\n        UDPPacket packet = buildPacketHeader(PEER_RELAY_REQUEST_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        \n        byte ourIP[] = getOurExplicitIP();\n        int ourPort = getOurExplicitPort();\n        \n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Sending intro relay request to \" + introHost + \":\" + introPort); // + \" regarding \" + state.getRemoteIdentity().calculateHash().toBase64());\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, introTag);\n        off += 4;\n        if (ourIP != null) {\n            DataHelper.toLong(data, off, 1, ourIP.length);\n            off++;\n            System.arraycopy(ourIP, 0, data, off, ourIP.length);\n            off += ourIP.length;\n        } else {\n            DataHelper.toLong(data, off, 1, 0);\n            off++;\n        }\n        \n        DataHelper.toLong(data, off, 2, ourPort);\n        off += 2;\n        \n        // challenge...\n        DataHelper.toLong(data, off, 1, 0);\n        off++;\n        //off += 0; // *cough*\n        \n        System.arraycopy(ourIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"wrote alice intro key: \" + Base64.encode(data, off-SessionKey.KEYSIZE_BYTES, SessionKey.KEYSIZE_BYTES) \n                      + \" with nonce \" + introNonce + \" size=\" + (off+4 + (16 - (off+4)%16))\n                      + \" and data: \" + Base64.encode(data, 0, off));\n        \n        DataHelper.toLong(data, off, 4, introNonce);\n        off += 4;\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        if (encrypt)\n            authenticate(packet, new SessionKey(introKey), new SessionKey(introKey));\n        setTo(packet, introHost, introPort);\n        packet.setMessageType(TYPE_RREQ);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Build a new SessionRequest packet for the given peer, encrypting it \n     * as necessary.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildSessionRequestPacket(OutboundEstablishState state) {\n        UDPPacket packet = buildPacketHeader(SESSION_REQUEST_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n\n        byte toIP[] = state.getSentIP();\n        if ( (_transport !=null) && (!_transport.isValid(toIP)) ) {\n            packet.release();\n            return null;\n        }\n        InetAddress to = null;\n        try {\n            to = InetAddress.getByAddress(toIP);\n        } catch (UnknownHostException uhe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\n            packet.release();\n            return null;\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending request\");\n        \n        // now for the body\n        byte[] x = state.getSentX();\n        System.arraycopy(x, 0, data, off, x.length);\n        off += x.length;\n        DataHelper.toLong(data, off, 1, toIP.length);\n        off += 1;\n        System.arraycopy(toIP, 0, data, off, toIP.length);\n        off += toIP.length;\n        int port = state.getSentPort();\n        DataHelper.toLong(data, off, 2, port);\n        off += 2;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, state.getIntroKey(), state.getIntroKey());\n        setTo(packet, to, port);\n        packet.setMessageType(TYPE_SREQ);\n        return packet;\n    }","id":104970,"modified_method":"/**\n     * Build a new SessionRequest packet for the given peer, encrypting it \n     * as necessary.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildSessionRequestPacket(OutboundEstablishState state) {\n        UDPPacket packet = buildPacketHeader(SESSION_REQUEST_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n\n        byte toIP[] = state.getSentIP();\n        if ( (_transport !=null) && (!_transport.isValid(toIP)) ) {\n            packet.release();\n            return null;\n        }\n        InetAddress to = null;\n        try {\n            to = InetAddress.getByAddress(toIP);\n        } catch (UnknownHostException uhe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\n            packet.release();\n            return null;\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending request\");\n        \n        // now for the body\n        byte[] x = state.getSentX();\n        System.arraycopy(x, 0, data, off, x.length);\n        off += x.length;\n        DataHelper.toLong(data, off, 1, toIP.length);\n        off += 1;\n        System.arraycopy(toIP, 0, data, off, toIP.length);\n        off += toIP.length;\n        int port = state.getSentPort();\n        DataHelper.toLong(data, off, 2, port);\n        off += 2;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, state.getIntroKey(), state.getIntroKey());\n        setTo(packet, to, port);\n        packet.setMessageType(TYPE_SREQ);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Build a packet as if we are Charlie sending Bob a packet verifying that we will help test Alice.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestToBob(InetAddress bobIP, int bobPort, InetAddress aliceIP, int alicePort, SessionKey aliceIntroKey, long nonce, SessionKey bobCipherKey, SessionKey bobMACKey) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        byte data[] = packet.getPacket().getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Bob\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        byte ip[] = aliceIP.getAddress();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alicePort);\n        off += 2;\n        System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // we can pad here if we want, maybe randomized?\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, bobCipherKey, bobMACKey);\n        setTo(packet, bobIP, bobPort);\n        packet.setMessageType(TYPE_TCB);\n        return packet;\n    }","id":104971,"modified_method":"/**\n     * Build a packet as if we are Charlie sending Bob a packet verifying that we will help test Alice.\n     * \n     * @return ready to send packet, or null if there was a problem\n     */\n    public UDPPacket buildPeerTestToBob(InetAddress bobIP, int bobPort, InetAddress aliceIP, int alicePort, SessionKey aliceIntroKey, long nonce, SessionKey bobCipherKey, SessionKey bobMACKey) {\n        UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        int off = HEADER_SIZE;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending peer test \" + nonce + \" to Bob\");\n        \n        // now for the body\n        DataHelper.toLong(data, off, 4, nonce);\n        off += 4;\n        byte ip[] = aliceIP.getAddress();\n        DataHelper.toLong(data, off, 1, ip.length);\n        off++;\n        System.arraycopy(ip, 0, data, off, ip.length);\n        off += ip.length;\n        DataHelper.toLong(data, off, 2, alicePort);\n        off += 2;\n        System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\n        off += SessionKey.KEYSIZE_BYTES;\n        \n        // pad up so we're on the encryption boundary\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, bobCipherKey, bobMACKey);\n        setTo(packet, bobIP, bobPort);\n        packet.setMessageType(TYPE_TCB);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Build a destroy packet, which contains a header but no body.\n     *  @param cipherKey non-null\n     *  @param macKey non-null\n     *  @since 0.9.2\n     */\n    private UDPPacket buildSessionDestroyPacket(SessionKey cipherKey, SessionKey macKey, InetAddress addr, int port) {\n        UDPPacket packet = buildPacketHeader((byte)(UDPPacket.PAYLOAD_TYPE_SESSION_DESTROY << 4));\n        int off = HEADER_SIZE;\n        \n        // no body in this message\n        \n        // pad up so we're on the encryption boundary\n        if ( (off % 16) != 0)\n            off += 16 - (off % 16);\n        packet.getPacket().setLength(off);\n        authenticate(packet, cipherKey, macKey);\n        setTo(packet, addr, port);\n        return packet;\n    }","id":104972,"modified_method":"/**\n     *  Build a destroy packet, which contains a header but no body.\n     *  @param cipherKey non-null\n     *  @param macKey non-null\n     *  @since 0.9.2\n     */\n    private UDPPacket buildSessionDestroyPacket(SessionKey cipherKey, SessionKey macKey, InetAddress addr, int port) {\n        UDPPacket packet = buildPacketHeader((byte)(UDPPacket.PAYLOAD_TYPE_SESSION_DESTROY << 4));\n        int off = HEADER_SIZE;\n        \n        // no body in this message\n        \n        // pad up so we're on the encryption boundary\n        DatagramPacket pkt = packet.getPacket();\n        byte data[] = pkt.getData();\n        off = pad1(data, off);\n        off = pad2(data, off);\n        pkt.setLength(off);\n        authenticate(packet, cipherKey, macKey);\n        setTo(packet, addr, port);\n        return packet;\n    }","commit_id":"5ba86ca2540de234facef51e5fbe1921f4d356de","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Test Tree put on a plain page. Tests first render, and render after a node click.\n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePage_1() throws Exception\n\t{\n\t\tSystem.out.println(\"=== \" + TreePage.class.getName() + \" ===\");\n\t\t\n\t\tapplication = new MockWebApplication(null);\n\t\tapplication.setHomePage(TreePage.class);\n\n\t\t// Do the processing\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.processRequestCycle();\n\n\t\t// Validate the document\n\t\tString document = application.getServletResponse().getDocument();\n\t\t//System.out.println(document);\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageExpectedResult_1.html\"));\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\"?path=0:tree:tree:3:node:junctionLink&interface=ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tdocument = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageExpectedResult_1-1.html\"));\n\t}","id":104973,"modified_method":"/**\n\t * Test Tree put on a plain page. Tests first render, and render after a node click.\n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePage_1() throws Exception\n\t{\n\t\texecuteTest(TreePage.class, \"TreePageExpectedResult_1.html\");\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\"?path=0:tree:tree:3:node:junctionLink&interface=ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tString document = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageExpectedResult_1-1.html\"));\n\t}","commit_id":"43bde0b4e8cb48f5028e53aa4f4083b45c99f647","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test Tree put on a page with a border. Tests first render, and render after a node click.\n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageWithBorder_1() throws Exception\n\t{\n\t\tSystem.out.println(\"=== \" + TreePageWithBorder.class.getName() + \" ===\");\n\t\t\n\t\tapplication = new MockWebApplication(null);\n\t\tapplication.setHomePage(TreePageWithBorder.class);\n\n\t\t// Do the processing\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.processRequestCycle();\n\n\t\t// Validate the document\n\t\tString document = application.getServletResponse().getDocument();\n\t\t//System.out.println(document);\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageWithBorderExpectedResult_1.html\"));\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\"?path=0:border:tree:tree:3:node:junctionLink&interface=ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tdocument = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageWithBorderExpectedResult_1-1.html\"));\n\t}","id":104974,"modified_method":"/**\n\t * Test Tree put on a page with a border. Tests first render, and render after a node click.\n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageWithBorder_1() throws Exception\n\t{\n\t\texecuteTest(TreePageWithBorder.class, \"TreePageWithBorderExpectedResult_1.html\");\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\"?path=0:border:tree:tree:3:node:junctionLink&interface=ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tString document = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageWithBorderExpectedResult_1-1.html\"));\n\t}","commit_id":"43bde0b4e8cb48f5028e53aa4f4083b45c99f647","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test Tree put on a plain page with a html head section, but without a wicket:head tag.\n\t * Tests first render, and render after a node click.\n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageNoWicketHeadTag_1() throws Exception\n\t{\n\t\tSystem.out.println(\"=== \" + TreePageNoWicketHeadTag.class.getName() + \" ===\");\n\t\t\n\t\tapplication = new MockWebApplication(null);\n\t\tapplication.setHomePage(TreePageNoWicketHeadTag.class);\n\n\t\t// Do the processing\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.processRequestCycle();\n\n\t\t// Validate the document\n\t\tString document = application.getServletResponse().getDocument();\n\t\t//System.out.println(document);\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageNoWicketHeadTagExpectedResult_1.html\"));\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\"?path=0:tree:tree:3:node:junctionLink&interface=ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tdocument = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageNoWicketHeadTagExpectedResult_1-1.html\"));\n\t}","id":104975,"modified_method":"/**\n\t * Test Tree put on a plain page with a html head section, but without a wicket:head tag.\n\t * Tests first render, and render after a node click.\n\t * @throws Exception\n\t */\n\tpublic void testRenderTreePageNoWicketHeadTag_1() throws Exception\n\t{\n\t\texecuteTest(TreePageNoWicketHeadTag.class, \"TreePageNoWicketHeadTagExpectedResult_1.html\");\n\n\t\tPage page = application.getLastRenderedPage();\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.getServletRequest().setRequestToRedirectString(\"?path=0:tree:tree:3:node:junctionLink&interface=ILinkListener\");\n\t\tapplication.processRequestCycle();\n\t\tString document = application.getServletResponse().getDocument();\n\n\t\tassertTrue(DiffUtil.validatePage(document, this.getClass(), \"TreePageNoWicketHeadTagExpectedResult_1-1.html\"));\n\t}","commit_id":"43bde0b4e8cb48f5028e53aa4f4083b45c99f647","url":"https://github.com/apache/wicket"},{"original_method":"public void start(BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\t\tplugin = this;\n\n        repositoryFactory = new ServiceTracker<RepositoryFactory, RepositoryFactory>(context, RepositoryFactory.class,\n                null);\n        repositoryFactory.open();\n\n        serializationManager = new ServiceTracker<SerializationManager, SerializationManager>(context,\n                SerializationManager.class, null);\n        serializationManager.open();\n\n        filterLocator = new ServiceTracker<FilterLocator, FilterLocator>(context, FilterLocator.class, null);\n        filterLocator.open();\n\n        osgiClientFactory = new ServiceTracker<OsgiClientFactory, OsgiClientFactory>(context, OsgiClientFactory.class,\n                null);\n        osgiClientFactory.open();\n\t}","id":104976,"modified_method":"public void start(BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\t\tplugin = this;\n\n        tracerRegistration = PluginLoggerRegistrar.register(this);\n\n        repositoryFactory = new ServiceTracker<RepositoryFactory, RepositoryFactory>(context, RepositoryFactory.class,\n                null);\n        repositoryFactory.open();\n\n        serializationManager = new ServiceTracker<SerializationManager, SerializationManager>(context,\n                SerializationManager.class, null);\n        serializationManager.open();\n\n        filterLocator = new ServiceTracker<FilterLocator, FilterLocator>(context, FilterLocator.class, null);\n        filterLocator.open();\n\n        osgiClientFactory = new ServiceTracker<OsgiClientFactory, OsgiClientFactory>(context, OsgiClientFactory.class,\n                null);\n        osgiClientFactory.open();\n\n        // ugh\n        ServiceReference<Object> reference = (ServiceReference<Object>) tracerRegistration.getReference();\n        tracer = new ServiceTracker<Object, Object>(context, reference, null);\n        tracer.open();\n\t}","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"public void stop(BundleContext context) throws Exception {\n        repositoryFactory.close();\n        serializationManager.close();\n        filterLocator.close();\n        osgiClientFactory.close();\n\n        plugin = null;\n\t\tsuper.stop(context);\n\t}","id":104977,"modified_method":"public void stop(BundleContext context) throws Exception {\n\n        tracerRegistration.unregister();\n\n        repositoryFactory.close();\n        serializationManager.close();\n        filterLocator.close();\n        osgiClientFactory.close();\n        tracer.close();\n\n        plugin = null;\n\t\tsuper.stop(context);\n\t}","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Sets the value of the sync directory configured for a project\n     * \n     * <p>\n     * The value must be a path relative to the project's location.\n     * <\/p>\n     * \n     * @param project the project, must not be null\n     * @param path the value\n     */\n    public static void setSyncDirectoryPath(IProject project, String path) {\n\n        try {\n            project.setPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, PROPERTY_SYNC_ROOT), path);\n        } catch (CoreException e) {\n            Activator.getDefault().getLog().log(new Status(Status.ERROR, Activator.PLUGIN_ID, e.getMessage(), e));\n        }\n    }","id":104978,"modified_method":"/**\n     * Sets the value of the sync directory configured for a project\n     * \n     * <p>\n     * The value must be a path relative to the project's location.\n     * <\/p>\n     * \n     * @param project the project, must not be null\n     * @param path the value\n     */\n    public static void setSyncDirectoryPath(IProject project, String path) {\n\n        try {\n            project.setPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, PROPERTY_SYNC_ROOT), path);\n        } catch (CoreException e) {\n            Activator.getDefault().getPluginLogger().error(e.getMessage(), e);\n        }\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the value of the sync directory configured for a project.\n     * \n     * <p>\n     * The value is returned as a relative path to the project's location. If the property value is not set, it defaults\n     * to {@value #PROPERTY_SYNC_ROOT_DEFAULT_VALUE}.\n     * <\/p>\n     * \n     * @param project the project, must not be null\n     * @return the value of the sync directory\n     */\n    public static String getSyncDirectoryValue(IProject project) {\n        String value = null;\n        try {\n            value = project.getPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, PROPERTY_SYNC_ROOT));\n        } catch (CoreException e) {\n            Activator.getDefault().getLog().log(new Status(Status.ERROR, Activator.PLUGIN_ID, e.getMessage(), e));\n        }\n\n        // TODO central place for defaults\n        if (value == null)\n            value = PROPERTY_SYNC_ROOT_DEFAULT_VALUE;\n\n        return value;\n    }","id":104979,"modified_method":"/**\n     * Returns the value of the sync directory configured for a project.\n     * \n     * <p>\n     * The value is returned as a relative path to the project's location. If the property value is not set, it defaults\n     * to {@value #PROPERTY_SYNC_ROOT_DEFAULT_VALUE}.\n     * <\/p>\n     * \n     * @param project the project, must not be null\n     * @return the value of the sync directory\n     */\n    public static String getSyncDirectoryValue(IProject project) {\n        String value = null;\n        try {\n            value = project.getPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, PROPERTY_SYNC_ROOT));\n        } catch (CoreException e) {\n            Activator.getDefault().getPluginLogger().error(e.getMessage(), e);\n        }\n\n        // TODO central place for defaults\n        if (value == null)\n            value = PROPERTY_SYNC_ROOT_DEFAULT_VALUE;\n\n        return value;\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"/**\n         * This returns the list of module resources that make up the bundle.\n         * <p>\n         * This list is composed of all files which are not derived. Derived files\n         * are those that are generated by m2eclipse/eclipse - and typically are \n         * the derived files and/or the files under target/classes (the output dirs).\n         * <p>\n         * This list is further down used as the input to SlingLaunchpadBehaviour\n         * and there evaluated. Depending on that class's behavior, this method\n         * might have to be adjusted (as for example in one version the SlingLaunchpadBehaviour\n         * completely ignores the list of changed files and redeploys everything - if another\n         * behaviour is used where only diffs are published, this members might have\n         * to return exactly the opposite: everything derived..)\n         */\n        @Override\n        public IModuleResource[] members() throws CoreException {\n            IProject project = module.getProject();\n            final IJavaProject javaProject = ProjectHelper.asJavaProject(project);\n            final List<IModuleResource> resources = new ArrayList<IModuleResource>();\n            \n            final Set<String> filteredLocations = new HashSet<String>();\n\n            final IJavaProject jp = javaProject;\n            final IClasspathEntry[] rawCp = jp.getRawClasspath();\n            for (int i = 0; i < rawCp.length; i++) {\n\t\t\t\tIClasspathEntry aCp = rawCp[i];\n\t\t\t\tIPath outputLocation = aCp.getOutputLocation();\n\t\t\t\tif (outputLocation!=null) {\n\t\t\t\t\toutputLocation = outputLocation.makeRelativeTo(project.getFullPath());\n\t\t\t\t\tfilteredLocations.add(outputLocation.toString());\n\t\t\t\t}\n\t\t\t}\n            \n            project.accept(new IResourceVisitor() {\n                @Override\n                public boolean visit(IResource resource) throws CoreException {\n\n                    if (resource.getType() == IResource.PROJECT) {\n                        return true;\n                    }\n\n                    final IPath relativePath = resource.getProjectRelativePath();\n                    if (relativePath == null) {\n                    \treturn false;\n                    }\n                    final String relPathStr = relativePath.toString();\n                    if (relPathStr == null || relPathStr.length()==0) {\n                    \treturn false;\n                    }\n                    if (resource.isDerived()) {\n                    \t// then dont accept it\n                    \treturn false;\n                    }\n\t\t\t\t\tif (filteredLocations.contains(relPathStr)) {\n                    \treturn false;\n                    }\n\t\t\t\t\tif (resource.getType() == IResource.FILE) {\n\t\t\t\t\t\t// the bundle facet accepts all files that are not in the output directory/derived\n\t\t\t\t\t\tModuleFile moduleFile = new ModuleFile((IFile) resource, resource.getName(), relativePath);\n\t\t\t\t\t\tresources.add(moduleFile);\n\t\t\t\t\t}\n                    return true;\n                }\n            });\n\n            for (Iterator<IModuleResource> it = resources.iterator(); it.hasNext();) {\n\t\t\t\tIModuleResource iModuleResource = it.next();\n\t\t\t\tSystem.out.println(\" ADDED: \"+iModuleResource.getModuleRelativePath().toString());\n\t\t\t\t\n\t\t\t}\n            return resources.toArray(new IModuleResource[resources.size()]);\n        }","id":104980,"modified_method":"/**\n         * This returns the list of module resources that make up the bundle.\n         * <p>\n         * This list is composed of all files which are not derived. Derived files\n         * are those that are generated by m2eclipse/eclipse - and typically are \n         * the derived files and/or the files under target/classes (the output dirs).\n         * <p>\n         * This list is further down used as the input to SlingLaunchpadBehaviour\n         * and there evaluated. Depending on that class's behavior, this method\n         * might have to be adjusted (as for example in one version the SlingLaunchpadBehaviour\n         * completely ignores the list of changed files and redeploys everything - if another\n         * behaviour is used where only diffs are published, this members might have\n         * to return exactly the opposite: everything derived..)\n         */\n        @Override\n        public IModuleResource[] members() throws CoreException {\n            IProject project = module.getProject();\n            final IJavaProject javaProject = ProjectHelper.asJavaProject(project);\n            final List<IModuleResource> resources = new ArrayList<IModuleResource>();\n            \n            final Set<String> filteredLocations = new HashSet<String>();\n\n            final IJavaProject jp = javaProject;\n            final IClasspathEntry[] rawCp = jp.getRawClasspath();\n            for (int i = 0; i < rawCp.length; i++) {\n\t\t\t\tIClasspathEntry aCp = rawCp[i];\n\t\t\t\tIPath outputLocation = aCp.getOutputLocation();\n\t\t\t\tif (outputLocation!=null) {\n\t\t\t\t\toutputLocation = outputLocation.makeRelativeTo(project.getFullPath());\n\t\t\t\t\tfilteredLocations.add(outputLocation.toString());\n\t\t\t\t}\n\t\t\t}\n            \n            project.accept(new IResourceVisitor() {\n                @Override\n                public boolean visit(IResource resource) throws CoreException {\n\n                    if (resource.getType() == IResource.PROJECT) {\n                        return true;\n                    }\n\n                    final IPath relativePath = resource.getProjectRelativePath();\n                    if (relativePath == null) {\n                    \treturn false;\n                    }\n                    final String relPathStr = relativePath.toString();\n                    if (relPathStr == null || relPathStr.length()==0) {\n                    \treturn false;\n                    }\n                    if (resource.isDerived()) {\n                    \t// then dont accept it\n                    \treturn false;\n                    }\n\t\t\t\t\tif (filteredLocations.contains(relPathStr)) {\n                    \treturn false;\n                    }\n\t\t\t\t\tif (resource.getType() == IResource.FILE) {\n\t\t\t\t\t\t// the bundle facet accepts all files that are not in the output directory/derived\n\t\t\t\t\t\tModuleFile moduleFile = new ModuleFile((IFile) resource, resource.getName(), relativePath);\n\t\t\t\t\t\tresources.add(moduleFile);\n\t\t\t\t\t}\n                    return true;\n                }\n            });\n\n            PluginLogger logger = Activator.getDefault().getPluginLogger();\n\n            for (Iterator<IModuleResource> it = resources.iterator(); it.hasNext();) {\n\t\t\t\tIModuleResource iModuleResource = it.next();\n                logger.trace(\"For module {0} added {1}\", module.getName(), iModuleResource.getModuleRelativePath()\n                        .toString());\n\t\t\t}\n            return resources.toArray(new IModuleResource[resources.size()]);\n        }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private ResourceProxy buildResourceProxyForPlainFileOrFolder( IModuleResource resource, IFolder syncDirectory)\n\t\t\tthrows IOException, CoreException {\n\t\tIFile file = (IFile) resource.getAdapter(IFile.class);\n\t\tIFolder folder = (IFolder) resource.getAdapter(IFolder.class);\n\n\t\tIResource changedResource = file != null ? file : folder;\n\t\tif (changedResource == null) {\n\t\t    System.err.println(\"Could not find a file or a folder for \" + resource);\n\t\t    return null;\n\t\t}\n\n\t\tSerializationKind serializationKind;\n\t\tString fallbackNodeType;\n\t\tif (changedResource.getType() == IResource.FILE) {\n\t\t    serializationKind = SerializationKind.FILE;\n\t\t    fallbackNodeType = Repository.NT_FILE;\n\t\t} else { // i.e. IResource.FOLDER\n\t\t    serializationKind = SerializationKind.FOLDER;\n\t\t    fallbackNodeType = Repository.NT_FOLDER;\n\t\t}\n\n\t\tString resourceLocation = '/' + changedResource.getFullPath().makeRelativeTo(syncDirectory.getFullPath())\n\t\t        .toPortableString();\n\t\tString serializationFilePath = serializationManager.getSerializationFilePath(resourceLocation,\n\t\t        serializationKind);\n\t\tIResource serializationResource = syncDirectory.findMember(serializationFilePath);\n\t\treturn buildResourceProxy(resourceLocation, serializationResource, syncDirectory, fallbackNodeType);\n\t}","id":104981,"modified_method":"private ResourceProxy buildResourceProxyForPlainFileOrFolder( IModuleResource resource, IFolder syncDirectory)\n\t\t\tthrows IOException, CoreException {\n\t\tIFile file = (IFile) resource.getAdapter(IFile.class);\n\t\tIFolder folder = (IFolder) resource.getAdapter(IFolder.class);\n\n\t\tIResource changedResource = file != null ? file : folder;\n\t\tif (changedResource == null) {\n            Activator.getDefault().getPluginLogger().trace(\"Could not find a file or a folder for \" + resource);\n\t\t    return null;\n\t\t}\n\n\t\tSerializationKind serializationKind;\n\t\tString fallbackNodeType;\n\t\tif (changedResource.getType() == IResource.FILE) {\n\t\t    serializationKind = SerializationKind.FILE;\n\t\t    fallbackNodeType = Repository.NT_FILE;\n\t\t} else { // i.e. IResource.FOLDER\n\t\t    serializationKind = SerializationKind.FOLDER;\n\t\t    fallbackNodeType = Repository.NT_FOLDER;\n\t\t}\n\n\t\tString resourceLocation = '/' + changedResource.getFullPath().makeRelativeTo(syncDirectory.getFullPath())\n\t\t        .toPortableString();\n\t\tString serializationFilePath = serializationManager.getSerializationFilePath(resourceLocation,\n\t\t        serializationKind);\n\t\tIResource serializationResource = syncDirectory.findMember(serializationFilePath);\n\t\treturn buildResourceProxy(resourceLocation, serializationResource, syncDirectory, fallbackNodeType);\n\t}","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private Command<?> addFileCommand(Repository repository, IModuleResource resource) throws CoreException,\n            SerializationException, IOException {\n\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        FileInfo info = createFileInfo(resource, repository);\n\n        IResource res = getResource(resource);\n        if (res == null) {\n            return null;\n        }\n\n        Object ignoreNextUpdate = res.getSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE);\n        if (ignoreNextUpdate != null) {\n            res.setSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE, null);\n            return null;\n        }\n\n        if (res.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getLog()\n                    .log(new Status(IStatus.INFO, Activator.PLUGIN_ID, \"Skipping team-private resource \" + res));\n            return null;\n        }\n\n        System.out.println(\"For \" + resource + \" build fileInfo \" + info);\n        if (info == null) {\n            return null;\n        }\n\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFullPath(res.getProject()).toFile();\n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(res.getProject());\n\n        if (serializationManager(repository, syncDirectoryAsFile).isSerializationFile(info.getLocation())) {\n            InputStream contents = null;\n            try {\n                IFile file = (IFile) resource.getAdapter(IFile.class);\n                contents = file.getContents();\n                String resourceLocation = file.getFullPath().makeRelativeTo(syncDirectory.getFullPath()).toPortableString();\n                ResourceProxy resourceProxy = serializationManager(repository, syncDirectoryAsFile)\n                        .readSerializationData(resourceLocation, contents);\n                // TODO - not sure if this 100% correct, but we definitely should not refer to the FileInfo as the\n                // .serialization file, since for nt:file/nt:resource nodes this will overwrite the file contents\n                String primaryType = (String) resourceProxy.getProperties().get(Repository.JCR_PRIMARY_TYPE);\n                if (Repository.NT_FILE.equals(primaryType) || Repository.NT_RESOURCE.equals(primaryType)) {\n                    // TODO move logic to serializationManager\n                    File locationFile = new File(info.getLocation());\n                    String locationFileParent = locationFile.getParent();\n                    int endIndex = locationFileParent.length() - \".dir\".length();\n                    File actualFile = new File(locationFileParent.substring(0, endIndex));\n                    String newLocation = actualFile.getAbsolutePath();\n                    String newName = actualFile.getName();\n                    String newRelativeLocation = actualFile.getAbsolutePath().substring(\n                            syncDirectoryAsFile.getAbsolutePath().length());\n                    info = new FileInfo(newLocation, newRelativeLocation, newName);\n                }\n\n                return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n            } catch (IOException e) {\n                // TODO logging\n                e.printStackTrace();\n                return null;\n            } finally {\n                if (contents != null) {\n                    contents.close();\n                }\n            }\n        } else {\n\n            ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder( resource, syncDirectory);\n\n            return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n        }\n    }","id":104982,"modified_method":"private Command<?> addFileCommand(Repository repository, IModuleResource resource) throws CoreException,\n            SerializationException, IOException {\n\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        FileInfo info = createFileInfo(resource, repository);\n\n        IResource res = getResource(resource);\n        if (res == null) {\n            return null;\n        }\n\n        Object ignoreNextUpdate = res.getSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE);\n        if (ignoreNextUpdate != null) {\n            res.setSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE, null);\n            return null;\n        }\n\n        if (res.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getPluginLogger().trace(\"Skipping team-private resource {0}\", res);\n            return null;\n        }\n\n        Activator.getDefault().getPluginLogger().trace(\"For {0} build fileInfo {1}\", resource, info);\n        if (info == null) {\n            return null;\n        }\n\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFullPath(res.getProject()).toFile();\n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(res.getProject());\n\n        if (serializationManager(repository, syncDirectoryAsFile).isSerializationFile(info.getLocation())) {\n            InputStream contents = null;\n            try {\n                IFile file = (IFile) resource.getAdapter(IFile.class);\n                contents = file.getContents();\n                String resourceLocation = file.getFullPath().makeRelativeTo(syncDirectory.getFullPath()).toPortableString();\n                ResourceProxy resourceProxy = serializationManager(repository, syncDirectoryAsFile)\n                        .readSerializationData(resourceLocation, contents);\n                // TODO - not sure if this 100% correct, but we definitely should not refer to the FileInfo as the\n                // .serialization file, since for nt:file/nt:resource nodes this will overwrite the file contents\n                String primaryType = (String) resourceProxy.getProperties().get(Repository.JCR_PRIMARY_TYPE);\n                if (Repository.NT_FILE.equals(primaryType) || Repository.NT_RESOURCE.equals(primaryType)) {\n                    // TODO move logic to serializationManager\n                    File locationFile = new File(info.getLocation());\n                    String locationFileParent = locationFile.getParent();\n                    int endIndex = locationFileParent.length() - \".dir\".length();\n                    File actualFile = new File(locationFileParent.substring(0, endIndex));\n                    String newLocation = actualFile.getAbsolutePath();\n                    String newName = actualFile.getName();\n                    String newRelativeLocation = actualFile.getAbsolutePath().substring(\n                            syncDirectoryAsFile.getAbsolutePath().length());\n                    info = new FileInfo(newLocation, newRelativeLocation, newName);\n                }\n\n                return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n            } catch (IOException e) {\n                // TODO logging\n                e.printStackTrace();\n                return null;\n            } finally {\n                if (contents != null) {\n                    contents.close();\n                }\n            }\n        } else {\n\n            ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder( resource, syncDirectory);\n\n            return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n        }\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private IResource getResource(IModuleResource resource) {\n\n        IResource file = (IFile) resource.getAdapter(IFile.class);\n        if (file == null) {\n            file = (IFolder) resource.getAdapter(IFolder.class);\n        }\n\n        if (file == null) {\n            // Usually happens on server startup, it seems to be safe to ignore for now\n            System.out.println(\"Got null '\" + IFile.class.getSimpleName() + \"' and '\" + IFolder.class.getSimpleName()\n                    + \"' for \" + resource);\n            return null;\n        }\n\n        return file;\n    }","id":104983,"modified_method":"private IResource getResource(IModuleResource resource) {\n\n        IResource file = (IFile) resource.getAdapter(IFile.class);\n        if (file == null) {\n            file = (IFolder) resource.getAdapter(IFolder.class);\n        }\n\n        if (file == null) {\n            // Usually happens on server startup, it seems to be safe to ignore for now\n            Activator.getDefault().getPluginLogger()\n                    .trace(\"Got null '{0}' and '{1}' for {2}\", IFile.class.getSimpleName(),\n                            IFolder.class.getSimpleName(), resource);\n            return null;\n        }\n\n        return file;\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"public void start(IProgressMonitor monitor) throws CoreException {\n\n        boolean success = false;\n        Result<ResourceProxy> result = null;\n\n        if (getServer().getMode().equals(ILaunchManager.DEBUG_MODE)) {\n            debuggerConnection = new JVMDebuggerConnection();\n            success = debuggerConnection.connectInDebugMode(launch, getServer(), monitor);\n\n        } else {\n\n            Repository repository;\n            try {\n                repository = ServerUtil.getRepository(getServer(), monitor);\n            } catch (CoreException e) {\n                setServerState(IServer.STATE_STOPPED);\n                throw e;\n            }\n            Command<ResourceProxy> command = repository.newListChildrenNodeCommand(\"/\");\n            result = command.execute();\n            success = result.isSuccess();\n            \n            RepositoryInfo repositoryInfo;\n            try {\n                repositoryInfo = ServerUtil.getRepositoryInfo(getServer(), monitor);\n                OsgiClient client = Activator.getDefault().getOsgiClientFactory().createOsgiClient(repositoryInfo);\n                Version bundleVersion = client.getBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME);\n                \n                ISlingLaunchpadServer launchpadServer = (ISlingLaunchpadServer) getServer().loadAdapter(SlingLaunchpadServer.class,\n                        monitor);\n                launchpadServer.setBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME, bundleVersion,\n                        monitor);\n                \n            } catch (URISyntaxException e) {\n                Activator.getDefault().getLog().log(new Status(IStatus.WARNING, Activator.PLUGIN_ID, \n                        \"Failed retrieving information about the installation support bundle\", e));\n            } catch (OsgiClientException e) {\n                Activator.getDefault().getLog().log(new Status(IStatus.WARNING, Activator.PLUGIN_ID, \n                        \"Failed retrieving information about the installation support bundle\", e));\n            }\n        }\n\n        if (success) {\n            setServerState(IServer.STATE_STARTED);\n        } else {\n            setServerState(IServer.STATE_STOPPED);\n            String message = \"Unable to connect to Sling Lanchpad. Please make sure a Launchpad instance is running \";\n            if (result != null) {\n                message += \" (\" + result.toString() + \")\";\n            }\n            throw new CoreException(new Status(IStatus.ERROR, \"org.apache.sling.ide.eclipse.wst\", message));\n        }\n    }","id":104984,"modified_method":"public void start(IProgressMonitor monitor) throws CoreException {\n\n        boolean success = false;\n        Result<ResourceProxy> result = null;\n\n        if (getServer().getMode().equals(ILaunchManager.DEBUG_MODE)) {\n            debuggerConnection = new JVMDebuggerConnection();\n            success = debuggerConnection.connectInDebugMode(launch, getServer(), monitor);\n\n        } else {\n\n            Repository repository;\n            try {\n                repository = ServerUtil.getRepository(getServer(), monitor);\n            } catch (CoreException e) {\n                setServerState(IServer.STATE_STOPPED);\n                throw e;\n            }\n            Command<ResourceProxy> command = repository.newListChildrenNodeCommand(\"/\");\n            result = command.execute();\n            success = result.isSuccess();\n            \n            RepositoryInfo repositoryInfo;\n            try {\n                repositoryInfo = ServerUtil.getRepositoryInfo(getServer(), monitor);\n                OsgiClient client = Activator.getDefault().getOsgiClientFactory().createOsgiClient(repositoryInfo);\n                Version bundleVersion = client.getBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME);\n                \n                ISlingLaunchpadServer launchpadServer = (ISlingLaunchpadServer) getServer().loadAdapter(SlingLaunchpadServer.class,\n                        monitor);\n                launchpadServer.setBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME, bundleVersion,\n                        monitor);\n                \n            } catch (URISyntaxException e) {\n                Activator.getDefault().getPluginLogger()\n                        .warn(\"Failed retrieving information about the installation support bundle\", e);\n            } catch (OsgiClientException e) {\n                Activator.getDefault().getPluginLogger()\n                        .warn(\"Failed retrieving information about the installation support bundle\", e);\n            }\n        }\n\n        if (success) {\n            setServerState(IServer.STATE_STARTED);\n        } else {\n            setServerState(IServer.STATE_STOPPED);\n            String message = \"Unable to connect to Sling Lanchpad. Please make sure a Launchpad instance is running \";\n            if (result != null) {\n                message += \" (\" + result.toString() + \")\";\n            }\n            throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, message));\n        }\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void publishModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException {\n\n        StringBuilder trace = new StringBuilder();\n        trace.append(\"SlingLaunchpadBehaviour.publishModule(\");\n\n        switch (kind) {\n            case IServer.PUBLISH_CLEAN:\n                trace.append(\"PUBLISH_CLEAN, \");\n                break;\n            case IServer.PUBLISH_INCREMENTAL:\n                trace.append(\"PUBLISH_INCREMENTAL, \");\n                break;\n            case IServer.PUBLISH_AUTO:\n                trace.append(\"PUBLISH_AUTO, \");\n                break;\n            case IServer.PUBLISH_FULL:\n                trace.append(\"PUBLISH_FULL, \");\n                break;\n            default:\n                trace.append(\"UNKNOWN - \").append(kind).append(\", \");\n        }\n\n        switch (deltaKind) {\n            case ServerBehaviourDelegate.ADDED:\n                trace.append(\"ADDED, \");\n                break;\n            case ServerBehaviourDelegate.CHANGED:\n                trace.append(\"CHANGED, \");\n                break;\n            case ServerBehaviourDelegate.NO_CHANGE:\n                trace.append(\"NO_CHANGE, \");\n                break;\n            case ServerBehaviourDelegate.REMOVED:\n                trace.append(\"REMOVED, \");\n                break;\n            default:\n                trace.append(\"UNKONWN - \").append(deltaKind).append(\", \");\n                break;\n        }\n        \n        trace.append(Arrays.toString(module)).append(\")\");\n\n        System.out.println(trace.toString());\n\n        if (deltaKind==ServerBehaviourDelegate.NO_CHANGE) {\n            // then there's no need to publish\n            //int modulePublishState = getServer().getModulePublishState(module);\n            return;\n        }\n        \n        if (kind == IServer.PUBLISH_FULL && deltaKind == ServerBehaviourDelegate.REMOVED) {\n            System.out.println(\"Ignoring request to unpublish all of the module resources\");\n            return;\n        }\n\n        try {\n            if (ProjectHelper.isBundleProject(module[0].getProject())) {\n                String serverMode = getServer().getMode();\n                if (!serverMode.equals(ILaunchManager.DEBUG_MODE)) {\n                    // in debug mode, we rely on the hotcode replacement feature of eclipse/jvm\n                    // otherwise, for run and profile modes we explicitly publish the bundle module\n                    // TODO: make this configurable as part of the server config\n            \t\tpublishBundleModule(module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n            \t}\n            } else if (ProjectHelper.isContentProject(module[0].getProject())) {\n                if ((kind == IServer.PUBLISH_AUTO || kind == IServer.PUBLISH_INCREMENTAL) && deltaKind == ServerBehaviourDelegate.NO_CHANGE) {\n                    System.out\n                            .println(\"Ignoring request to publish the module when no resources have changed; most likely another module has changed\");\n                    return;\n                }\n                try {\n                    publishContentModule(kind, deltaKind, module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n                } catch (SerializationException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Serialization error for \"\n                            + trace.toString(), e));\n                } catch (IOException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"IO error for \"\n                            + trace.toString(), e));\n                }\n            }\n        } finally {\n            if (serializationManager != null) {\n                serializationManager.destroy();\n            }\n        }\n    }","id":104985,"modified_method":"@Override\n    protected void publishModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException {\n\n        PluginLogger logger = Activator.getDefault().getPluginLogger();\n        \n        logger.trace(traceOperation(kind, deltaKind, module));\n\n        if (deltaKind==ServerBehaviourDelegate.NO_CHANGE) {\n            // then there's no need to publish\n            return;\n        }\n        \n        if (kind == IServer.PUBLISH_FULL && deltaKind == ServerBehaviourDelegate.REMOVED) {\n            logger.trace(\"Ignoring request to unpublish all of the module resources\");\n            return;\n        }\n\n        try {\n            if (ProjectHelper.isBundleProject(module[0].getProject())) {\n                String serverMode = getServer().getMode();\n                if (!serverMode.equals(ILaunchManager.DEBUG_MODE)) {\n                    // in debug mode, we rely on the hotcode replacement feature of eclipse/jvm\n                    // otherwise, for run and profile modes we explicitly publish the bundle module\n                    // TODO: make this configurable as part of the server config\n            \t\tpublishBundleModule(module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n            \t}\n            } else if (ProjectHelper.isContentProject(module[0].getProject())) {\n                if ((kind == IServer.PUBLISH_AUTO || kind == IServer.PUBLISH_INCREMENTAL) && deltaKind == ServerBehaviourDelegate.NO_CHANGE) {\n                    logger.trace(\"Ignoring request to publish the module when no resources have changed; most likely another module has changed\");\n                    return;\n                }\n                try {\n                    publishContentModule(kind, deltaKind, module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n                } catch (SerializationException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Serialization error for \"\n                            + traceOperation(kind, deltaKind, module).toString(), e));\n                } catch (IOException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"IO error for \"\n                            + traceOperation(kind, deltaKind, module).toString(), e));\n                }\n            }\n        } finally {\n            if (serializationManager != null) {\n                serializationManager.destroy();\n            }\n        }\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private FileInfo createFileInfo(IModuleResource resource, Repository repository) throws SerializationException,\n            CoreException {\n\n        IResource file = getResource(resource);\n        if (file == null) {\n            return null;\n        }\n\n        IProject project = file.getProject();\n\n        String syncDirectory = ProjectUtil.getSyncDirectoryValue(project);\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(project);\n\n        Filter filter = loadFilter(project.getFolder(syncDirectory));\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile,\n                    repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        IPath relativePath = resource.getModuleRelativePath().removeLastSegments(1);\n\n        FileInfo info = new FileInfo(file.getLocation().toOSString(), relativePath.toOSString(), file.getName());\n\n        System.out.println(\"For \" + resource + \" built fileInfo \" + info);\n\n        return info;\n    }","id":104986,"modified_method":"private FileInfo createFileInfo(IModuleResource resource, Repository repository) throws SerializationException,\n            CoreException {\n\n        IResource file = getResource(resource);\n        if (file == null) {\n            return null;\n        }\n\n        IProject project = file.getProject();\n\n        String syncDirectory = ProjectUtil.getSyncDirectoryValue(project);\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(project);\n\n        Filter filter = loadFilter(project.getFolder(syncDirectory));\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile,\n                    repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        IPath relativePath = resource.getModuleRelativePath().removeLastSegments(1);\n\n        FileInfo info = new FileInfo(file.getLocation().toOSString(), relativePath.toOSString(), file.getName());\n\n        Activator.getDefault().getPluginLogger().trace(\"For {1} built fileInfo {2}\", resource, info);\n\n        return info;\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private void publishContentModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException, SerializationException, IOException {\n\n\t\tif (runLaunchesIfExist(kind, deltaKind, module, monitor)) {\n\t\t\treturn;\n\t\t}\n\t\t// otherwise fallback to old behaviour\n\t\t\n\t\tRepository repository = ServerUtil.getRepository(getServer(), monitor);\n        \n        // TODO it would be more efficient to have a module -> filter mapping\n        // it would be simpler to implement this in SlingContentModuleAdapter, but\n        // the behaviour for resources being filtered out is deletion, and that\n        // would be an incorrect ( or at least suprising ) behaviour at development time\n\n        switch (deltaKind) {\n            case ServerBehaviourDelegate.CHANGED:\n                List<IModuleResourceDelta> publishedResourceDelta = \n                \tArrays.asList(getPublishedResourceDelta(module));\n                \n                List<IModuleResourceDelta> adjustedPublishedResourceDelta = filterContentXmlParents(publishedResourceDelta);\n\n                for (IModuleResourceDelta resourceDelta : adjustedPublishedResourceDelta) {\n\n                    StringBuilder deltaTrace = new StringBuilder();\n                    deltaTrace.append(\"- processing delta kind \");\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                            deltaTrace.append(\"ADDED \");\n                            break;\n                        case IModuleResourceDelta.CHANGED:\n                            deltaTrace.append(\"CHANGED \");\n                            break;\n                        case IModuleResourceDelta.NO_CHANGE:\n                            deltaTrace.append(\"NO_CHANGE \");\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            deltaTrace.append(\"REMOVED \");\n                            break;\n                        default:\n                            deltaTrace.append(\"UNKNOWN - \").append(resourceDelta.getKind());\n                    }\n\n                    deltaTrace.append(\"for resource \").append(resourceDelta.getModuleResource());\n\n                    System.out.println(deltaTrace);\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                        case IModuleResourceDelta.CHANGED:\n                        case IModuleResourceDelta.NO_CHANGE: // TODO is this needed?\n                            execute(addFileCommand(repository, resourceDelta.getModuleResource()));\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            execute(removeFileCommand(repository, resourceDelta.getModuleResource()));\n                            break;\n                    }\n                }\n                break;\n\n            case ServerBehaviourDelegate.ADDED:\n            case ServerBehaviourDelegate.NO_CHANGE: // TODO is this correct ?\n                IModuleResource[] moduleResources1 = getResources(module);\n                List<IModuleResource> adjustedModuleResourcesList = filterContentXmlParents(moduleResources1);\n                for (IModuleResource resource : adjustedModuleResourcesList) {\n                    execute(addFileCommand(repository, resource));\n                }\n                break;\n            case ServerBehaviourDelegate.REMOVED:\n                IModuleResource[] moduleResources2 = getResources(module);\n                for (IModuleResource resource : moduleResources2) {\n                    execute(removeFileCommand(repository, resource));\n                }\n                break;\n        }\n\n\n        // set state to published\n        super.publishModule(kind, deltaKind, module, monitor);\n        setModulePublishState(module, IServer.PUBLISH_STATE_NONE);\n//        setServerPublishState(IServer.PUBLISH_STATE_NONE);\n\t}","id":104987,"modified_method":"private void publishContentModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException, SerializationException, IOException {\n\n\t\tif (runLaunchesIfExist(kind, deltaKind, module, monitor)) {\n\t\t\treturn;\n\t\t}\n\t\t// otherwise fallback to old behaviour\n\t\t\n        PluginLogger logger = Activator.getDefault().getPluginLogger();\n\n\t\tRepository repository = ServerUtil.getRepository(getServer(), monitor);\n        \n        // TODO it would be more efficient to have a module -> filter mapping\n        // it would be simpler to implement this in SlingContentModuleAdapter, but\n        // the behaviour for resources being filtered out is deletion, and that\n        // would be an incorrect ( or at least suprising ) behaviour at development time\n\n        switch (deltaKind) {\n            case ServerBehaviourDelegate.CHANGED:\n                List<IModuleResourceDelta> publishedResourceDelta = \n                \tArrays.asList(getPublishedResourceDelta(module));\n                \n                List<IModuleResourceDelta> adjustedPublishedResourceDelta = filterContentXmlParents(publishedResourceDelta);\n\n                for (IModuleResourceDelta resourceDelta : adjustedPublishedResourceDelta) {\n\n                    StringBuilder deltaTrace = new StringBuilder();\n                    deltaTrace.append(\"- processing delta kind \");\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                            deltaTrace.append(\"ADDED \");\n                            break;\n                        case IModuleResourceDelta.CHANGED:\n                            deltaTrace.append(\"CHANGED \");\n                            break;\n                        case IModuleResourceDelta.NO_CHANGE:\n                            deltaTrace.append(\"NO_CHANGE \");\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            deltaTrace.append(\"REMOVED \");\n                            break;\n                        default:\n                            deltaTrace.append(\"UNKNOWN - \").append(resourceDelta.getKind());\n                    }\n\n                    deltaTrace.append(\"for resource \").append(resourceDelta.getModuleResource());\n\n                    logger.trace(deltaTrace.toString());\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                        case IModuleResourceDelta.CHANGED:\n                        case IModuleResourceDelta.NO_CHANGE: // TODO is this needed?\n                            execute(addFileCommand(repository, resourceDelta.getModuleResource()));\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            execute(removeFileCommand(repository, resourceDelta.getModuleResource()));\n                            break;\n                    }\n                }\n                break;\n\n            case ServerBehaviourDelegate.ADDED:\n            case ServerBehaviourDelegate.NO_CHANGE: // TODO is this correct ?\n                IModuleResource[] moduleResources1 = getResources(module);\n                List<IModuleResource> adjustedModuleResourcesList = filterContentXmlParents(moduleResources1);\n                for (IModuleResource resource : adjustedModuleResourcesList) {\n                    execute(addFileCommand(repository, resource));\n                }\n                break;\n            case ServerBehaviourDelegate.REMOVED:\n                IModuleResource[] moduleResources2 = getResources(module);\n                for (IModuleResource resource : moduleResources2) {\n                    execute(removeFileCommand(repository, resource));\n                }\n                break;\n        }\n\n\n        // set state to published\n        super.publishModule(kind, deltaKind, module, monitor);\n        setModulePublishState(module, IServer.PUBLISH_STATE_NONE);\n//        setServerPublishState(IServer.PUBLISH_STATE_NONE);\n\t}","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private Command<?> removeFileCommand(Repository repository, IModuleResource resource) throws SerializationException, IOException, CoreException {\n    \t\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        IResource deletedResource = getResource(resource);\n        \n        if ( deletedResource == null ) {\n        \treturn null;\n        }\n        \n        if (deletedResource.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator\n                    .getDefault()\n                    .getLog()\n                    .log(new Status(IStatus.INFO, Activator.PLUGIN_ID, \"Skipping team-private resource \"\n                            + deletedResource));\n            return null;\n        }\n        \n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(deletedResource.getProject());\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(deletedResource.getProject());\n        \n        Filter filter = loadFilter(syncDirectory);\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile, repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder(resource, syncDirectory);\n\n        return repository.newDeleteNodeCommand(resourceProxy);\n    }","id":104988,"modified_method":"private Command<?> removeFileCommand(Repository repository, IModuleResource resource) throws SerializationException, IOException, CoreException {\n    \t\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        IResource deletedResource = getResource(resource);\n        \n        if ( deletedResource == null ) {\n        \treturn null;\n        }\n        \n        if (deletedResource.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getPluginLogger().trace(\"Skipping team-private resoruce {0}\", deletedResource);\n            return null;\n        }\n        \n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(deletedResource.getProject());\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(deletedResource.getProject());\n        \n        Filter filter = loadFilter(syncDirectory);\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile, repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder(resource, syncDirectory);\n\n        return repository.newDeleteNodeCommand(resourceProxy);\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"private FilterResult getFilterResult(IModuleResource resource, Filter filter, File contentSyncRoot,\n            Repository repository) throws SerializationException {\n\n        String filePath = resource.getModuleRelativePath().toOSString();\n\t\tString absFilePath = new File(contentSyncRoot, filePath).getAbsolutePath();\n        if (serializationManager(repository, contentSyncRoot).isSerializationFile(absFilePath)) {\n            filePath = serializationManager.getBaseResourcePath(filePath);\n        }\n        \n        String repositoryPath = resource.getModuleRelativePath().toPortableString();\n\n        System.out.println(\"Filtering by \" + repositoryPath + \" for \" + resource);\n\n        return filter.filter(contentSyncRoot, repositoryPath, repository.getRepositoryInfo());\n    }","id":104989,"modified_method":"private FilterResult getFilterResult(IModuleResource resource, Filter filter, File contentSyncRoot,\n            Repository repository) throws SerializationException {\n\n        String filePath = resource.getModuleRelativePath().toOSString();\n\t\tString absFilePath = new File(contentSyncRoot, filePath).getAbsolutePath();\n        if (serializationManager(repository, contentSyncRoot).isSerializationFile(absFilePath)) {\n            filePath = serializationManager.getBaseResourcePath(filePath);\n        }\n        \n        String repositoryPath = resource.getModuleRelativePath().toPortableString();\n\n        Activator.getDefault().getPluginLogger().trace(\"Filtering by {0} for {1}\", repositoryPath, resource);\n\n        return filter.filter(contentSyncRoot, repositoryPath, repository.getRepositoryInfo());\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Object getLaunchable(IServer server, IModuleArtifact moduleArtifact) throws CoreException {\n\n        System.out.println(\"SlingLaunchpadLaunchableAdapterDelegate.getLaunchable()\");\n\n        if (server == null || moduleArtifact == null) {\n            return null;\n        }\n\n        ISlingLaunchpadServer launchpad = (ISlingLaunchpadServer) server.loadAdapter(SlingLaunchpadServer.class, null);\n        if (launchpad == null) {\n            return null;\n        }\n\n        return null;\n    }","id":104990,"modified_method":"@Override\n    public Object getLaunchable(IServer server, IModuleArtifact moduleArtifact) throws CoreException {\n\n        if (server == null || moduleArtifact == null) {\n            return null;\n        }\n\n        ISlingLaunchpadServer launchpad = (ISlingLaunchpadServer) server.loadAdapter(SlingLaunchpadServer.class, null);\n        if (launchpad == null) {\n            return null;\n        }\n\n        return null;\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void setPublishState(int publishState, IProgressMonitor monitor) {\n        System.out.println(\"[\" + Thread.currentThread().getName() + \"] Set \" + PROP_AUTO_PUBLISH_SETTING + \" to \"\n                + publishState);\n        IServerWorkingCopy wc = getServer().createWorkingCopy();\n\t\twc.setAttribute(PROP_AUTO_PUBLISH_SETTING, publishState);\n\t\ttry {\n\t\t\twc.save(false, monitor);\n\t\t} catch (CoreException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n    }","id":104991,"modified_method":"@Override\n    public void setPublishState(int publishState, IProgressMonitor monitor) {\n\n        Activator.getDefault().getPluginLogger().trace(\"Set {0} to {1}\", PROP_AUTO_PUBLISH_SETTING, publishState);\n\n        IServerWorkingCopy wc = getServer().createWorkingCopy();\n\t\twc.setAttribute(PROP_AUTO_PUBLISH_SETTING, publishState);\n\t\ttry {\n\t\t\twc.save(false, monitor);\n\t\t} catch (CoreException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public IStatus canModifyModules(IModule[] toAdd, IModule[] toRemove) {\n\n        System.out.println(\"SlingLaunchpadServer.canModifyModules()\");\n\n        if (toAdd == null) {\n            return Status.OK_STATUS;\n        }\n\n        for (IModule module : toAdd) {\n\n            if (!MODULE_TYPE_SLING_CONTENT.equals(module.getModuleType().getId()) &&\n            \t\t!MODULE_TYPE_SLING_BUNDLE.equals(module.getModuleType().getId())) {\n                return new Status(IStatus.ERROR, \"org.apache.sling.slingclipse\", 0,\n                        \"Will only handle modules of type 'sling.content' or 'sling.bundle'\", null);\n            }\n        }\n\n        return Status.OK_STATUS;\n    }","id":104992,"modified_method":"@Override\n    public IStatus canModifyModules(IModule[] toAdd, IModule[] toRemove) {\n\n        if (toAdd == null) {\n            return Status.OK_STATUS;\n        }\n\n        for (IModule module : toAdd) {\n\n            if (!MODULE_TYPE_SLING_CONTENT.equals(module.getModuleType().getId()) &&\n            \t\t!MODULE_TYPE_SLING_BUNDLE.equals(module.getModuleType().getId())) {\n                return new Status(IStatus.ERROR, \"org.apache.sling.slingclipse\", 0,\n                        \"Will only handle modules of type 'sling.content' or 'sling.bundle'\", null);\n            }\n        }\n\n        return Status.OK_STATUS;\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void modifyModules(IModule[] toAdd, IModule[] toRemove, IProgressMonitor arg2) throws CoreException {\n\n        System.out.println(\"SlingLaunchpadServer.modifyModules()\");\n\n        IStatus status = canModifyModules(toAdd, toRemove);\n        if (!status.isOK()) {\n            throw new CoreException(status);\n        }\n\n        for (IModule module : toAdd) {\n            System.out.println(\"Adding module \" + module);\n        }\n\n        for (IModule module : toRemove) {\n            System.out.println(\"Removing module \" + module);\n        }\n    }","id":104993,"modified_method":"@Override\n    public void modifyModules(IModule[] toAdd, IModule[] toRemove, IProgressMonitor arg2) throws CoreException {\n\n        IStatus status = canModifyModules(toAdd, toRemove);\n        if (!status.isOK()) {\n            throw new CoreException(status);\n        }\n\n        // TODO - actually add/remove modules ...\n    }","commit_id":"b08a5188c1d0dcb104ecc3d6308fa7a06cc3de36","url":"https://github.com/apache/sling"},{"original_method":"@NotNull\n  @Override\n  public PsiField createField(@NotNull final String name, @NotNull final PsiType type) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(type)) {\n      throw new IncorrectOperationException(\"Cannot create field with type \\\"null\\\".\");\n    }\n\n    final String text = join(\"class _Dummy_ { private \", type.getCanonicalText(), \" \", name, \"; }\");\n    final PsiJavaFile aFile = createDummyJavaFile(text);\n    final PsiClass psiClass = aFile.getClasses()[0];\n    final PsiField[] fields = psiClass.getFields();\n    if (fields.length < 1) {\n      throw new IncorrectOperationException(\"Field was not created \" + text);\n    }\n    final PsiField field = fields[0];\n    JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(field);\n    return (PsiField)CodeStyleManager.getInstance(myManager.getProject()).reformat(field);\n  }","id":104994,"modified_method":"@NotNull\n  @Override\n  public PsiField createField(@NotNull final String name, @NotNull final PsiType type) throws IncorrectOperationException {\n    PsiUtil.checkIsIdentifier(myManager, name);\n    if (PsiType.NULL.equals(type)) {\n      throw new IncorrectOperationException(\"Cannot create field with type \\\"null\\\".\");\n    }\n\n    final String text = join(\"class _Dummy_ { private \", type.getCanonicalText(), \" \", name, \"; }\");\n    final PsiJavaFile aFile = createDummyJavaFile(text);\n    final PsiClass[] classes = aFile.getClasses();\n    if (classes.length < 1) {\n      throw new IncorrectOperationException(\"Class was not created \" + text);\n    }\n    final PsiClass psiClass = classes[0];\n    final PsiField[] fields = psiClass.getFields();\n    if (fields.length < 1) {\n      throw new IncorrectOperationException(\"Field was not created \" + text);\n    }\n    final PsiField field = fields[0];\n    JavaCodeStyleManager.getInstance(myManager.getProject()).shortenClassReferences(field);\n    return (PsiField)CodeStyleManager.getInstance(myManager.getProject()).reformat(field);\n  }","commit_id":"930bfe651499924373c92f50cb9b410258ce26a4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testDeleteClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n\n    // set expectations\n    managementController.deleteCluster(Matchers.clusterRequest(null, \"Cluster102\", null, null));\n    managementController.deleteCluster(Matchers.clusterRequest(103L, null, null, null));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    TestObserver observer = new TestObserver();\n\n    ((ObservableResourceProvider)provider).addObserver(observer);\n\n    // delete the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.deleteResources(predicate);\n\n    // delete the cluster where id == 103\n    predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.deleteResources(predicate);\n\n    ResourceProviderEvent lastEvent = observer.getLastEvent();\n    Assert.assertNotNull(lastEvent);\n    Assert.assertEquals(Resource.Type.Cluster, lastEvent.getResourceType());\n    Assert.assertEquals(ResourceProviderEvent.Type.Delete, lastEvent.getType());\n    Assert.assertEquals(predicate, lastEvent.getPredicate());\n    Assert.assertNull(lastEvent.getRequest());\n\n    // verify\n    verify(managementController, response);\n  }","id":104995,"modified_method":"@Test\n  public void testDeleteClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    // set expectations\n    managementController.deleteCluster(Matchers.clusterRequest(null, \"Cluster102\", null, null));\n    managementController.deleteCluster(Matchers.clusterRequest(103L, null, null, null));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    TestObserver observer = new TestObserver();\n\n    ((ObservableResourceProvider)provider).addObserver(observer);\n\n    // delete the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.deleteResources(predicate);\n\n    // delete the cluster where id == 103\n    predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.deleteResources(predicate);\n\n    ResourceProviderEvent lastEvent = observer.getLastEvent();\n    Assert.assertNotNull(lastEvent);\n    Assert.assertEquals(Resource.Type.Cluster, lastEvent.getResourceType());\n    Assert.assertEquals(ResourceProviderEvent.Type.Delete, lastEvent.getType());\n    Assert.assertEquals(predicate, lastEvent.getPredicate());\n    Assert.assertNull(lastEvent.getRequest());\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"7170887107944909d737528b42ac8696a29e7c1d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testCreateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n//    Set<ServiceRequest> requests = new HashSet<ServiceRequest>();\n//    requests.add(Matchers.serviceRequest(\"Cluster100\", \"Service100\", null, \"DEPLOYED\"));\n    managementController.createServices(anyObject(Set.class));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.  add more maps for multiple creates\n    Set<Map<String, Object>> propertySet = new LinkedHashSet<Map<String, Object>>();\n\n    // Service 1: create a map of properties for the request\n    Map<String, Object> properties = new LinkedHashMap<String, Object>();\n\n    // add properties to the request map\n    properties.put(ServiceResourceProvider.SERVICE_CLUSTER_NAME_PROPERTY_ID, \"Cluster100\");\n    properties.put(ServiceResourceProvider.SERVICE_SERVICE_NAME_PROPERTY_ID, \"Service100\");\n    properties.put(ServiceResourceProvider.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    propertySet.add(properties);\n\n    // create the request\n    Request request = PropertyHelper.getCreateRequest(propertySet);\n\n    provider.createResources(request);\n\n    // verify\n    verify(managementController, response);\n  }","id":104996,"modified_method":"@Test\n  public void testCreateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    managementController.createServices(Matchers.serviceRequestSet(\"Cluster100\", \"Service100\", null, \"DEPLOYED\"));\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.  add more maps for multiple creates\n    Set<Map<String, Object>> propertySet = new LinkedHashSet<Map<String, Object>>();\n\n    // Service 1: create a map of properties for the request\n    Map<String, Object> properties = new LinkedHashMap<String, Object>();\n\n    // add properties to the request map\n    properties.put(ServiceResourceProvider.SERVICE_CLUSTER_NAME_PROPERTY_ID, \"Cluster100\");\n    properties.put(ServiceResourceProvider.SERVICE_SERVICE_NAME_PROPERTY_ID, \"Service100\");\n    properties.put(ServiceResourceProvider.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    propertySet.add(properties);\n\n    // create the request\n    Request request = PropertyHelper.getCreateRequest(propertySet);\n\n    provider.createResources(request);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"7170887107944909d737528b42ac8696a29e7c1d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n\n    // set expectations\n    expect(managementController.getClusters(anyObject(Set.class))).andReturn(nameResponse).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(102L, \"Cluster102\", \"HDP-0.1\", null))).andReturn(response).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(103L, null, \"HDP-0.1\", null))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    TestObserver observer = new TestObserver();\n\n    ((ObservableResourceProvider)provider).addObserver(observer);\n\n    Map<String, Object> properties = new LinkedHashMap<String, Object>();\n\n    properties.put(ClusterResourceProvider.CLUSTER_VERSION_PROPERTY_ID, \"HDP-0.1\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // update the cluster where id == 103\n    predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.updateResources(request, predicate);\n\n    ResourceProviderEvent lastEvent = observer.getLastEvent();\n    Assert.assertNotNull(lastEvent);\n    Assert.assertEquals(Resource.Type.Cluster, lastEvent.getResourceType());\n    Assert.assertEquals(ResourceProviderEvent.Type.Update, lastEvent.getType());\n    Assert.assertEquals(request, lastEvent.getRequest());\n    Assert.assertEquals(predicate, lastEvent.getPredicate());\n\n    // verify\n    verify(managementController, response);\n  }","id":104997,"modified_method":"@Test\n  public void testUpdateClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n\n    // set expectations\n    expect(managementController.getClusters(EasyMock.<Set<ClusterRequest>>anyObject())).andReturn(nameResponse).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(102L, \"Cluster102\", \"HDP-0.1\", null))).andReturn(response).once();\n    expect(managementController.updateCluster(Matchers.clusterRequest(103L, null, \"HDP-0.1\", null))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    TestObserver observer = new TestObserver();\n\n    ((ObservableResourceProvider)provider).addObserver(observer);\n\n    Map<String, Object> properties = new LinkedHashMap<String, Object>();\n\n    properties.put(ClusterResourceProvider.CLUSTER_VERSION_PROPERTY_ID, \"HDP-0.1\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // update the cluster where id == 103\n    predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    provider.updateResources(request, predicate);\n\n    ResourceProviderEvent lastEvent = observer.getLastEvent();\n    Assert.assertNotNull(lastEvent);\n    Assert.assertEquals(Resource.Type.Cluster, lastEvent.getResourceType());\n    Assert.assertEquals(ResourceProviderEvent.Type.Update, lastEvent.getType());\n    Assert.assertEquals(request, lastEvent.getRequest());\n    Assert.assertEquals(predicate, lastEvent.getPredicate());\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"7170887107944909d737528b42ac8696a29e7c1d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n\n    Set<ClusterResponse> allResponse = new HashSet<ClusterResponse>();\n    allResponse.add(new ClusterResponse(100L, \"Cluster100\", null, null));\n    allResponse.add(new ClusterResponse(101L, \"Cluster101\", null, null));\n    allResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n    allResponse.add(new ClusterResponse(103L, \"Cluster103\", null, null));\n    allResponse.add(new ClusterResponse(104L, \"Cluster104\", null, null));\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n\n    Set<ClusterResponse> idResponse = new HashSet<ClusterResponse>();\n    idResponse.add(new ClusterResponse(103L, \"Cluster103\", null, null));\n\n    // set expectations\n    expect(managementController.getClusters(anyObject(Set.class))).andReturn(allResponse).once();\n    expect(managementController.getClusters(anyObject(Set.class))).andReturn(nameResponse).once();\n    expect(managementController.getClusters(anyObject(Set.class))).andReturn(idResponse).once();\n\n    // replay\n    replay(managementController);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID);\n    propertyIds.add(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get all ... no predicate\n    Set<Resource> resources = provider.getResources(request, null);\n\n    Assert.assertEquals(5, resources.size());\n    for (Resource resource : resources) {\n      Long id = (Long) resource.getPropertyValue(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID);\n      String name = (String) resource.getPropertyValue(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(name, \"Cluster\" + id);\n    }\n\n    // get cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(102L, resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster102\", resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID));\n\n    // get cluster with id == 103\n    predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(103L, resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster103\", resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID));\n\n    // verify\n    verify(managementController);\n  }","id":104998,"modified_method":"@Test\n  public void testGetClusterResources() throws Exception{\n    Resource.Type type = Resource.Type.Cluster;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n\n    Set<ClusterResponse> allResponse = new HashSet<ClusterResponse>();\n    allResponse.add(new ClusterResponse(100L, \"Cluster100\", null, null));\n    allResponse.add(new ClusterResponse(101L, \"Cluster101\", null, null));\n    allResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n    allResponse.add(new ClusterResponse(103L, \"Cluster103\", null, null));\n    allResponse.add(new ClusterResponse(104L, \"Cluster104\", null, null));\n\n    Set<ClusterResponse> nameResponse = new HashSet<ClusterResponse>();\n    nameResponse.add(new ClusterResponse(102L, \"Cluster102\", null, null));\n\n    Set<ClusterResponse> idResponse = new HashSet<ClusterResponse>();\n    idResponse.add(new ClusterResponse(103L, \"Cluster103\", null, null));\n\n    // set expectations\n    expect(managementController.getClusters(EasyMock.<Set<ClusterRequest>>anyObject())).andReturn(allResponse).once();\n    expect(managementController.getClusters(EasyMock.<Set<ClusterRequest>>anyObject())).andReturn(nameResponse).once();\n    expect(managementController.getClusters(EasyMock.<Set<ClusterRequest>>anyObject())).andReturn(idResponse).once();\n\n    // replay\n    replay(managementController);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID);\n    propertyIds.add(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get all ... no predicate\n    Set<Resource> resources = provider.getResources(request, null);\n\n    Assert.assertEquals(5, resources.size());\n    for (Resource resource : resources) {\n      Long id = (Long) resource.getPropertyValue(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID);\n      String name = (String) resource.getPropertyValue(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID);\n      Assert.assertEquals(name, \"Cluster\" + id);\n    }\n\n    // get cluster named Cluster102\n    Predicate  predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster102\").toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(102L, resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster102\", resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID));\n\n    // get cluster with id == 103\n    predicate = new PredicateBuilder().property(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID).equals(103L).toPredicate();\n    resources = provider.getResources(request, predicate);\n\n    Assert.assertEquals(1, resources.size());\n    Assert.assertEquals(103L, resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_ID_PROPERTY_ID));\n    Assert.assertEquals(\"Cluster103\", resources.iterator().next().getPropertyValue(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID));\n\n    // verify\n    verify(managementController);\n  }","commit_id":"7170887107944909d737528b42ac8696a29e7c1d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    // set expectations\n    expect(managementController.updateServices(anyObject(Set.class))).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.\n    Map<String, Object> properties = new LinkedHashMap<String, Object>();\n\n    properties.put(ServiceResourceProvider.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the service named Service102\n    Predicate  predicate = new PredicateBuilder().property(ServiceResourceProvider.SERVICE_CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster100\").\n        and().property(ServiceResourceProvider.SERVICE_SERVICE_NAME_PROPERTY_ID).equals(\"Service102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // verify\n    verify(managementController, response);\n  }","id":104999,"modified_method":"@Test\n  public void testUpdateServiceResources() throws Exception{\n    Resource.Type type = Resource.Type.Service;\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    RequestStatusResponse response = createNiceMock(RequestStatusResponse.class);\n\n    // set expectations\n    expect(managementController.updateServices(EasyMock.<Set<ServiceRequest>>anyObject())).andReturn(response).once();\n\n    // replay\n    replay(managementController, response);\n\n    ResourceProvider provider = AbstractResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // add the property map to a set for the request.\n    Map<String, Object> properties = new LinkedHashMap<String, Object>();\n\n    properties.put(ServiceResourceProvider.SERVICE_SERVICE_STATE_PROPERTY_ID, \"DEPLOYED\");\n\n    // create the request\n    Request request = PropertyHelper.getUpdateRequest(properties);\n\n    // update the service named Service102\n    Predicate  predicate = new PredicateBuilder().property(ServiceResourceProvider.SERVICE_CLUSTER_NAME_PROPERTY_ID).equals(\"Cluster100\").\n        and().property(ServiceResourceProvider.SERVICE_SERVICE_NAME_PROPERTY_ID).equals(\"Service102\").toPredicate();\n    provider.updateResources(request, predicate);\n\n    // verify\n    verify(managementController, response);\n  }","commit_id":"7170887107944909d737528b42ac8696a29e7c1d","url":"https://github.com/apache/ambari"}]