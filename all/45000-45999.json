[{"original_method":"@Override\n    protected void componentHidden() {\n        logger.log(Level.INFO, \"HIDDEN\");\n\n    }","id":45000,"modified_method":"@Override\n    protected void componentHidden() {\n        //logger.log(Level.INFO, \"HIDDEN\");\n        super.componentHidden();\n\n    }","commit_id":"1759121453eb244cdb36c0e352d953e9a5a8b97e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void resolve(DecoratedKey key, ColumnFamily cf)\n    {\n        currentThroughput.addAndGet(cf.size());\n        currentOperations.addAndGet(cf.getColumnCount());\n\n        ColumnFamily oldCf = columnFamilies.putIfAbsent(key, cf);\n        if (oldCf == null)\n            return;\n\n        oldCf.resolve(cf);\n    }","id":45001,"modified_method":"private void resolve(DecoratedKey key, ColumnFamily cf)\n    {\n        currentThroughput.addAndGet(cf.size());\n        currentOperations.addAndGet((cf.getColumnCount() == 0)\n                                    ? cf.isMarkedForDelete() ? 1 : 0\n                                    : cf.getColumnCount());\n\n        ColumnFamily oldCf = columnFamilies.putIfAbsent(key, cf);\n        if (oldCf == null)\n            return;\n\n        oldCf.resolve(cf);\n    }","commit_id":"23706164f6e1495f2e2a21a454fd07ef0c7164a5","url":"https://github.com/apache/cassandra"},{"original_method":"private void resolve(DecoratedKey key, ColumnFamily cf)\n    {\n        currentThroughput.addAndGet(cf.size());\n        currentOperations.addAndGet(cf.getColumnCount());\n\n        ColumnFamily oldCf = columnFamilies.putIfAbsent(key, cf);\n        if (oldCf == null)\n            return;\n\n        oldCf.resolve(cf);\n    }","id":45002,"modified_method":"private void resolve(DecoratedKey key, ColumnFamily cf)\n    {\n        currentThroughput.addAndGet(cf.size());\n        currentOperations.addAndGet((cf.getColumnCount() == 0)\n                                    ? cf.isMarkedForDelete() ? 1 : 0\n                                    : cf.getColumnCount());\n\n        ColumnFamily oldCf = columnFamilies.putIfAbsent(key, cf);\n        if (oldCf == null)\n            return;\n\n        oldCf.resolve(cf);\n    }","commit_id":"4e9cdccaacdf741d1db498d5bfb6f275e57e65da","url":"https://github.com/apache/cassandra"},{"original_method":"private ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore)\n    {\n        assert columnFamily_.equals(filter.getColumnFamilyName());\n\n        long start = System.nanoTime();\n        try\n        {\n            if (ssTables_.getRowCache().getCapacity() == 0)\n            {\n                ColumnFamily cf = getTopLevelColumns(filter, gcBefore);\n                // TODO this is necessary because when we collate supercolumns together, we don't check\n                // their subcolumns for relevance, so we need to do a second prune post facto here.\n                return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);\n            }\n\n            ColumnFamily cached = cacheRow(filter.key);\n            if (cached == null)\n                return null;\n            \n            // special case slicing the entire row:\n            // we can skip the filter step entirely, and we can help out removeDeleted by re-caching the result\n            // if any tombstones have aged out since last time.  (This means that the row cache will treat gcBefore as\n            // max(gcBefore, all previous gcBefore), which is fine for correctness.)\n            if (filter.filter instanceof SliceQueryFilter)\n            {\n                SliceQueryFilter sliceFilter = (SliceQueryFilter) filter.filter;\n                if (sliceFilter.start.length == 0 && sliceFilter.finish.length == 0 && sliceFilter.count > cached.getColumnCount())\n                {\n                    removeDeletedColumnsOnly(cached, gcBefore);\n                    return removeDeletedCF(cached, gcBefore);\n                }\n            }\n            \n            IColumnIterator ci = filter.getMemtableColumnIterator(cached, null, getComparator());\n            ColumnFamily cf = ci.getColumnFamily().cloneMeShallow();\n            filter.collectCollatedColumns(cf, ci, gcBefore);\n            // TODO this is necessary because when we collate supercolumns together, we don't check\n            // their subcolumns for relevance, so we need to do a second prune post facto here.\n            return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);\n        }\n        catch (IOException e)\n        {\n            throw new IOError(e);\n        }\n        finally\n        {\n            readStats_.addNano(System.nanoTime() - start);\n        }\n    }","id":45003,"modified_method":"private ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore)\n    {\n        assert columnFamily_.equals(filter.getColumnFamilyName());\n\n        long start = System.nanoTime();\n        try\n        {\n            if (ssTables_.getRowCache().getCapacity() == 0)\n            {\n                ColumnFamily cf = getTopLevelColumns(filter, gcBefore);\n                // TODO this is necessary because when we collate supercolumns together, we don't check\n                // their subcolumns for relevance, so we need to do a second prune post facto here.\n                return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);\n            }\n\n            ColumnFamily cached = cacheRow(filter.key);\n            if (cached == null)\n                return null;\n            \n            // special case slicing the entire row:\n            // we can skip the filter step entirely, and we can help out removeDeleted by re-caching the result\n            // if any tombstones have aged out since last time.  (This means that the row cache will treat gcBefore as\n            // max(gcBefore, all previous gcBefore), which is fine for correctness.)\n            //\n            // But, if the filter is asking for less columns than we have cached, we fall back to the slow path\n            // since we have to copy out a subset.\n            if (filter.filter instanceof SliceQueryFilter)\n            {\n                SliceQueryFilter sliceFilter = (SliceQueryFilter) filter.filter;\n                if (sliceFilter.start.length == 0 && sliceFilter.finish.length == 0)\n                {\n                    if (cached.isSuper() && filter.path.superColumnName != null)\n                    {\n                        // subcolumns from named supercolumn\n                        IColumn sc = cached.getColumn(filter.path.superColumnName);\n                        if (sc == null || sliceFilter.count >= sc.getSubColumns().size())\n                        {\n                            ColumnFamily cf = cached.cloneMeShallow();\n                            if (sc != null)\n                                cf.addColumn(sc);\n                            return removeDeleted(cf, gcBefore);\n                        }\n                    }\n                    else\n                    {\n                        // top-level columns\n                        if (sliceFilter.count >= cached.getColumnCount())\n                        {\n                            removeDeletedColumnsOnly(cached, gcBefore);\n                            return removeDeletedCF(cached, gcBefore);\n                        }\n                    }\n                }\n            }\n            \n            IColumnIterator ci = filter.getMemtableColumnIterator(cached, null, getComparator());\n            ColumnFamily cf = ci.getColumnFamily().cloneMeShallow();\n            filter.collectCollatedColumns(cf, ci, gcBefore);\n            // TODO this is necessary because when we collate supercolumns together, we don't check\n            // their subcolumns for relevance, so we need to do a second prune post facto here.\n            return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);\n        }\n        catch (IOException e)\n        {\n            throw new IOError(e);\n        }\n        finally\n        {\n            readStats_.addNano(System.nanoTime() - start);\n        }\n    }","commit_id":"67b39ac85dbfcfde6d21228e1bb91d74b1c56a85","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Constructs the window, by adding all components and panels.\n     */\n    private void initPanels()\n    {\n        this.historyMenuBar.add(historyMenu);\n\n        this.northPanel.add(historyMenuBar, BorderLayout.NORTH);\n\n        this.northPanel.add(searchPanel, BorderLayout.CENTER);\n\n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n\n        this.mainPanel.add(historyPanel, BorderLayout.CENTER);\n\n        this.mainPanel.add(datesPanel, BorderLayout.WEST);\n\n        this.getContentPane().add(mainPanel);\n    }","id":45004,"modified_method":"/**\n     * Constructs the window, by adding all components and panels.\n     */\n    private void initPanels()\n    {\n        this.historyMenuBar.add(historyMenu);\n\n        this.northPanel.add(historyMenuBar, BorderLayout.NORTH);\n\n        this.northPanel.add(searchPanel, BorderLayout.CENTER);\n\n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n\n        this.mainPanel.add(chatConvPanel, BorderLayout.CENTER);\n\n        this.mainPanel.add(datesPanel, BorderLayout.WEST);\n\n        this.getContentPane().add(mainPanel);\n    }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void windowClosing(WindowEvent e) {\n            ConfigurationService configService\n                = GuiActivator.getConfigurationService();\n\n            try {\n                configService.setProperty(\n                    HISTORY_WINDOW_WIDTH_PROPERTY,\n                    new Integer(getWidth()));\n\n                configService.setProperty(\n                    HISTORY_WINDOW_HEIGHT_PROPERTY,\n                    new Integer(getHeight()));\n\n                configService.setProperty(\n                    HISTORY_WINDOW_X_PROPERTY,\n                    new Integer(getX()));\n\n                configService.setProperty(\n                    HISTORY_WINDOW_Y_PROPERTY,\n                    new Integer(getY()));\n            }\n            catch (PropertyVetoException e1) {\n                logger.error(\"The proposed property change \"\n                        + \"represents an unacceptable value\");\n            }\n        }","id":45005,"modified_method":"public void windowClosing(WindowEvent e) {\n            msgHistory.removeSearchProgressListener(HistoryWindow.this);\n            \n            ConfigurationService configService\n                = GuiActivator.getConfigurationService();\n\n            try {\n                configService.setProperty(\n                    HISTORY_WINDOW_WIDTH_PROPERTY,\n                    new Integer(getWidth()));\n\n                configService.setProperty(\n                    HISTORY_WINDOW_HEIGHT_PROPERTY,\n                    new Integer(getHeight()));\n\n                configService.setProperty(\n                    HISTORY_WINDOW_X_PROPERTY,\n                    new Integer(getX()));\n\n                configService.setProperty(\n                    HISTORY_WINDOW_Y_PROPERTY,\n                    new Integer(getY()));\n            }\n            catch (PropertyVetoException e1) {\n                logger.error(\"The proposed property change \"\n                        + \"represents an unacceptable value\");\n            }\n        }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows a history for a given keyword.\n     * @param keyword the keyword to search\n     */\n    public void showHistoryByKeyword(String keyword)\n    {\n        \n        historyPanel.removeAll();\n        datesPanel.removeAllDates();\n        datesPanel.setLastSelectedIndex(-1);\n\n        new KeywordDatesLoader(keyword).start();\n    }","id":45006,"modified_method":"/**\n     * Shows a history for a given keyword.\n     * @param keyword the keyword to search\n     */\n    public void showHistoryByKeyword(String keyword)\n    {   \n        chatConvPanel.clear();        \n        datesPanel.setLastSelectedIndex(-1);\n\n        new KeywordDatesLoader(keyword).start();\n        \n        lastExecutedSearch = KEYWORD_SEARCH;\n        searchKeyword = keyword;\n    }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * \n     */\n    public void progressChanged(ProgressEvent evt)\n    {          \n        if(progressBar.getPercentComplete() == 0) {\n            this.mainPanel.remove(readyLabel);\n            this.mainPanel.add(progressBar, BorderLayout.SOUTH);\n            this.mainPanel.revalidate();\n            this.mainPanel.repaint();\n        }\n\n        this.progressBar.setValue(evt.getProgress());\n        \n        if(progressBar.getPercentComplete() == 1.0) {\n            new ProgressBarTimer().start();\n        }\n    }","id":45007,"modified_method":"/**\n     * Handles the ProgressEvent triggered from the history when processing\n     * a query.\n     */\n    public void progressChanged(ProgressEvent evt)\n    {\n        int progress = evt.getProgress();\n        \n        if((lastProgress != progress)\n                && evt.getStartDate() == null\n                || evt.getStartDate() != ignoreProgressDate) {\n            \n            if(progressBar.getPercentComplete() == 0) {\n                this.mainPanel.remove(readyLabel);\n                this.mainPanel.add(progressBar, BorderLayout.SOUTH);\n                this.mainPanel.revalidate();\n                this.mainPanel.repaint();\n            }\n    \n            this.progressBar.setValue(progress);\n            \n            if(progressBar.getPercentComplete() == 1.0) {\n                new ProgressBarTimer().start();\n            }\n            \n            lastProgress = progress;\n        }\n    }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows a history for a given period.\n     * @param startDate the start date of the period\n     * @param endDate the end date of the period\n     */\n    public void showHistoryByPeriod(Date startDate, Date endDate)\n    {\n        \n        if(dateHistoryTable.containsKey(startDate)) {\n            ChatConversationPanel convPanel\n                = (ChatConversationPanel)dateHistoryTable.get(startDate);\n\n            this.historyPanel.removeAll();\n            \n            this.historyPanel.add(convPanel);\n            \n            historyPanel.revalidate();\n            historyPanel.repaint();\n        }\n        else {\n            historyPanel.removeAll();\n            \n            new MessagesLoader(startDate, endDate).start();                         \n        }\n        this.lastExecutedSearch = PERIOD_SEARCH;\n        this.searchStartDate = startDate;\n    }","id":45008,"modified_method":"/**\n     * Shows a history for a given period.\n     * @param startDate the start date of the period\n     * @param endDate the end date of the period\n     */\n    public void showHistoryByPeriod(Date startDate, Date endDate)\n    {        \n        if((searchKeyword == null || searchKeyword == \"\")\n                && dateHistoryTable.containsKey(startDate)) {\n            \n            HTMLDocument document\n                = (HTMLDocument)dateHistoryTable.get(startDate);\n            \n            this.chatConvPanel.setContent(document);\n        }\n        else {\n            this.chatConvPanel.clear();\n            new MessagesLoader(startDate, endDate).start();                         \n        }\n        \n        this.lastExecutedSearch = PERIOD_SEARCH;\n        this.searchStartDate = startDate;\n    }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run() {\n            Collection msgList = msgHistory.findByEndDate(\n                metaContact, new Date(System.currentTimeMillis()));\n            \n            Object[] msgArray = msgList.toArray();\n            Date date = null;\n\n            for (int i = 0; i < msgArray.length; i ++) {\n                Object o = msgArray[i];\n       \n                if (o instanceof MessageDeliveredEvent) {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n       \n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent) {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n                       \n                boolean containsDate = false;\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; !containsDate && j < dateVector.size(); j ++) {\n                    Date date1 = (Date)dateVector.get(j);\n                    \n                    containsDate = Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date.getTime()/milisecondsPerDay);\n                }\n\n                if(!containsDate) {\n                    dateVector.add(new Date(date.getTime()\n                            - date.getTime()%milisecondsPerDay));\n                }\n            }\n            \n            Runnable updateDatesPanel = new Runnable() {\n                public void run() {\n                    for(int i = 0; i < dateVector.size(); i++) {\n                        Date date = (Date)dateVector.get(i);\n                        datesPanel.addDate(date);\n                    }\n                    //Initializes the conversation panel with the data of the\n                    //last conversation.\n                    datesPanel.setSelected(datesPanel.getModel().getSize() - 1);\n                }\n            };\n            SwingUtilities.invokeLater(updateDatesPanel);            \n        }","id":45009,"modified_method":"public void run() {\n            Collection msgList = msgHistory.findByEndDate(\n                metaContact, new Date(System.currentTimeMillis()));\n            \n            Object[] msgArray = msgList.toArray();\n            Date date = null;\n\n            for (int i = 0; i < msgArray.length; i ++) {\n                Object o = msgArray[i];\n       \n                if (o instanceof MessageDeliveredEvent) {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n       \n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent) {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n                       \n                boolean containsDate = false;\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; !containsDate && j < datesVector.size(); j ++) {\n                    Date date1 = (Date)datesVector.get(j);\n                    \n                    containsDate = Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date.getTime()/milisecondsPerDay);\n                }\n\n                if(!containsDate) {\n                    datesVector.add(new Date(date.getTime()\n                            - date.getTime()%milisecondsPerDay));\n                }\n            }\n            \n            Runnable updateDatesPanel = new Runnable() {\n                public void run() {\n                    Date date = null;\n                    for(int i = 0; i < datesVector.size(); i++) {\n                        date = (Date)datesVector.get(i);\n                        datesPanel.addDate(date);\n                    }\n                    if(date != null) {\n                        ignoreProgressDate = date;\n                    }\n                    //Initializes the conversation panel with the data of the\n                    //last conversation.\n                    datesPanel.setSelected(datesPanel.getModel().getSize() - 1);\n                }\n            };\n            SwingUtilities.invokeLater(updateDatesPanel);            \n        }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"public ProgressBarTimer() {\n            //Set delay\n            super(2 * 1000, null);\n\n            this.addActionListener(new TimerActionListener());\n        }","id":45010,"modified_method":"public ProgressBarTimer() {\n            //Set delay\n            super(1 * 1000, null);\n            this.setRepeats(false);\n            this.addActionListener(new TimerActionListener());\n        }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of the <tt>HistoryWindow<\/tt>.\n     * @param mainFrame the main application window\n     * @param metaContact the <tt>MetaContact<\/tt> for which to display\n     * a history\n     */\n    public HistoryWindow(MainFrame mainFrame, MetaContact metaContact)\n    {\n\n        this.progressBar = new JProgressBar(\n            MessageHistorySearchProgressListener.PROGRESS_MINIMUM_VALUE,\n            MessageHistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);\n                \n        this.progressBar.setValue(0);\n        this.progressBar.setStringPainted(true);\n        \n        this.msgHistory = GuiActivator.getMsgHistoryService();\n        this.msgHistory.addSearchProgressListener(this);\n        \n        this.mainFrame = mainFrame;\n        this.metaContact = metaContact;\n\n        this.setTitle(Messages.getString(\n                \"historyContact\", metaContact.getDisplayName()));\n\n        this.datesPanel = new DatesPanel(this);\n        this.historyMenu = new HistoryMenu(this);\n        this.searchPanel = new SearchPanel(this);\n\n        this.setSizeAndLocation();\n\n        this.setIconImage(ImageLoader.getImage(ImageLoader.SIP_LOGO));\n\n        this.initPanels();\n\n        this.initData();\n\n        this.addWindowListener(new HistoryWindowAdapter());\n        \n        ActionMap amap = this.getRootPane().getActionMap();\n        \n        amap.put(\"close\", new CloseAction());\n        \n        InputMap imap = this.getRootPane().getInputMap(\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\n    }","id":45011,"modified_method":"/**\n     * Creates an instance of the <tt>HistoryWindow<\/tt>.\n     * @param mainFrame the main application window\n     * @param metaContact the <tt>MetaContact<\/tt> for which to display\n     * a history\n     */\n    public HistoryWindow(MainFrame mainFrame, MetaContact metaContact)\n    {\n        chatConvPanel = new ChatConversationPanel(this);\n        \n        this.progressBar = new JProgressBar(\n            MessageHistorySearchProgressListener.PROGRESS_MINIMUM_VALUE,\n            MessageHistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);\n                \n        this.progressBar.setValue(0);\n        this.progressBar.setStringPainted(true);\n        \n        this.msgHistory = GuiActivator.getMsgHistoryService();\n        this.msgHistory.addSearchProgressListener(this);\n        \n        this.mainFrame = mainFrame;\n        this.metaContact = metaContact;\n\n        this.setTitle(Messages.getString(\n                \"historyContact\", metaContact.getDisplayName()));\n\n        this.datesPanel = new DatesPanel(this);\n        this.historyMenu = new HistoryMenu(this);\n        this.searchPanel = new SearchPanel(this);\n\n        this.setSizeAndLocation();\n\n        this.setIconImage(ImageLoader.getImage(ImageLoader.SIP_LOGO));\n\n        this.initPanels();\n\n        this.initData();\n\n        this.addWindowListener(new HistoryWindowAdapter());\n        \n        ActionMap amap = this.getRootPane().getActionMap();\n        \n        amap.put(\"close\", new CloseAction());\n        \n        InputMap imap = this.getRootPane().getInputMap(\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\n    }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            msgList = msgHistory.findByKeyword(\n                    metaContact, keyword);\n            \n            Object[] msgArray = msgList.toArray();\n            Date date = null;\n                        \n            for (int i = 0; i < msgArray.length; i ++) {\n                Object o = msgArray[i];\n\n                if (o instanceof MessageDeliveredEvent) {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent) {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n\n                boolean containsDate = false;\n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; !containsDate && j < dateVector.size(); j ++) {\n                    Date date1 = (Date)dateVector.get(j);\n                    \n                    containsDate = Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date.getTime()/milisecondsPerDay);\n                }\n\n                if(!containsDate) {\n                    dateVector.add(new Date(date.getTime()\n                            - date.getTime()%milisecondsPerDay));\n                }                \n            }\n            \n            Runnable updateDatesPanel = new Runnable() {\n                public void run() {\n                    for(int i = 0; i < dateVector.size(); i++) {\n                        Date date = (Date)dateVector.get(i);\n                        \n                        datesPanel.addDate(date);\n                        \n                        datesPanel.revalidate();\n                        datesPanel.repaint();\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateDatesPanel);\n            \n            for(int i = 0; i < dateVector.size(); i ++) {\n                Date initDate = (Date)dateVector.get(i);\n                \n                msgList = msgHistory.findByPeriod(\n                        metaContact, initDate,\n                        i < (dateVector.size()-1)?(Date)dateVector.get(i+1)\n                                :new Date(System.currentTimeMillis()));\n                \n                SwingUtilities.invokeLater(\n                        new KeywordMessageLoader(i, msgList, keyword));\n            }\n            \n            SwingUtilities.invokeLater(new Runnable() {\n                public void run()\n                {\n                    datesPanel.setSelected(datesPanel.getDatesNumber() - 1);                       \n                }\n            });\n            \n            lastExecutedSearch = KEYWORD_SEARCH;\n            searchKeyword = keyword;\n        }","id":45012,"modified_method":"public void run()\n        {\n            msgList = msgHistory.findByKeyword(\n                    metaContact, keyword);\n            \n            Object[] msgArray = msgList.toArray();\n            Date date = null;\n                        \n            for (int i = 0; i < msgArray.length; i ++) {\n                Object o = msgArray[i];\n\n                if (o instanceof MessageDeliveredEvent) {\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n                    date = evt.getTimestamp();\n                }\n                else if (o instanceof MessageReceivedEvent) {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n                    date = evt.getTimestamp();\n                }\n                \n                long milisecondsPerDay = 24*60*60*1000;\n                for(int j = 0; j < datesVector.size(); j ++) {\n                    Date date1 = (Date)datesVector.get(j);\n                    \n                    if(Math.floor(date1.getTime()/milisecondsPerDay)\n                        == Math.floor(date.getTime()/milisecondsPerDay)\n                        && !keywordDatesVector.contains(date1)) {\n                        \n                        keywordDatesVector.add(date1);\n                    }     \n                }                \n            }\n            \n            Runnable updateDatesPanel = new Runnable() {\n                public void run() {\n                    datesPanel.removeAllDates();\n                    if(keywordDatesVector.size() > 0) {\n                        Date date = null;\n                        for(int i = 0; i < keywordDatesVector.size(); i++) {\n                            date = (Date)keywordDatesVector.get(i);\n                            \n                            /* I have tried to remove and add dates in the\n                             * datesList. A lot of problems occured because\n                             * it seems that the list generates selection events\n                             * when removing elements. This was solved but after\n                             * that a problem occured when one and the same\n                             * selection was done twice.\n                             *  \n                             * if(!keywordDatesVector.contains(date)) {                            \n                             *    datesPanel.removeDate(date);\n                             * }\n                             * else {\n                             *    if(!datesPanel.containsDate(date)) {\n                             *        datesPanel.addDate(date);\n                             *    }\n                            }*/\n                            datesPanel.addDate(date);\n                        }\n                        if(date != null) {\n                            ignoreProgressDate = date;\n                        }\n                        datesPanel.setSelected(\n                                datesPanel.getModel().getSize() - 1);\n                    }\n                    else {\n                        chatConvPanel.setDefaultContent();\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateDatesPanel);\n        }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n             msgList = msgHistory.findByPeriod(\n                    metaContact, startDate, endDate);\n         \n            Runnable updateMessagesPanel = new Runnable() {\n                public void run() {\n                    ChatConversationPanel convPanel\n                        = new ChatConversationPanel(HistoryWindow.this);\n    \n                    historyPanel.add(convPanel);\n    \n                    createHistory(convPanel, msgList, null);\n                    dateHistoryTable.put(startDate, convPanel);\n                    \n                    historyPanel.revalidate();\n                    historyPanel.repaint();\n                }\n            };\n            SwingUtilities.invokeLater(updateMessagesPanel);\n        }","id":45013,"modified_method":"public void run()\n        {\n            msgList = msgHistory.findByPeriod(\n                    metaContact, startDate, endDate);\n            \n            Runnable updateMessagesPanel = new Runnable() {\n                public void run() {\n                    HTMLDocument doc = createHistory(msgList);\n                    if(searchKeyword == null || searchKeyword == \"\") {\n                        dateHistoryTable.put(startDate, doc);\n                    }\n                }\n            };\n            SwingUtilities.invokeLater(updateMessagesPanel);\n        }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows the history given by the collection into a ChatConversationPanel.\n     * @param historyRecords a collection of history records\n     */\n    private void createHistory(ChatConversationPanel chatConvPanel,\n            Collection historyRecords, String keyword)\n    {\n\n        if(historyRecords.size() > 0) {\n\n            Iterator i = historyRecords.iterator();\n\n            while (i.hasNext()) {\n\n                Object o = i.next();\n\n                if(o instanceof MessageDeliveredEvent) {\n\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n\n                    ProtocolProviderService protocolProvider = evt\n                        .getDestinationContact().getProtocolProvider();\n\n                    chatConvPanel.processMessage(\n                            this.mainFrame.getAccount(protocolProvider),\n                            evt.getTimestamp(), Constants.OUTGOING_MESSAGE,\n                            evt.getSourceMessage().getContent(), keyword);\n                }\n                else if(o instanceof MessageReceivedEvent) {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n\n                    chatConvPanel.processMessage(\n                            evt.getSourceContact().getDisplayName(),\n                            evt.getTimestamp(), Constants.INCOMING_MESSAGE,\n                            evt.getSourceMessage().getContent(), keyword);\n                }\n            }\n        }\n    }","id":45014,"modified_method":"/**\n     * Shows the history given by the collection into a ChatConversationPanel.\n     * @param historyRecords a collection of history records\n     */\n    private HTMLDocument createHistory(Collection historyRecords)\n    {\n        if(historyRecords.size() > 0) {\n            \n            Iterator i = historyRecords.iterator();\n            String processedMessage = \"\";\n            while (i.hasNext()) {\n\n                Object o = i.next();\n\n                if(o instanceof MessageDeliveredEvent) {\n\n                    MessageDeliveredEvent evt = (MessageDeliveredEvent)o;\n\n                    ProtocolProviderService protocolProvider = evt\n                        .getDestinationContact().getProtocolProvider();\n\n                    processedMessage = chatConvPanel.processMessage(\n                            this.mainFrame.getAccount(protocolProvider),\n                            evt.getTimestamp(), Constants.OUTGOING_MESSAGE,\n                            evt.getSourceMessage().getContent(), searchKeyword);                    \n                }\n                else if(o instanceof MessageReceivedEvent) {\n                    MessageReceivedEvent evt = (MessageReceivedEvent)o;\n\n                    processedMessage = chatConvPanel.processMessage(\n                            evt.getSourceContact().getDisplayName(),\n                            evt.getTimestamp(), Constants.INCOMING_MESSAGE,\n                            evt.getSourceMessage().getContent(), searchKeyword);\n                }\n                chatConvPanel.appendMessageToEnd(processedMessage);\n            }\n        }\n        this.chatConvPanel.setDefaultContent();\n        \n        return this.chatConvPanel.getContent();\n    }","commit_id":"dc1b80c7547069edb8c2eabb60fd5467d1ead504","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n   * Set up the distributed cache by localizing the resources, and updating\n   * the configuration with references to the localized resources.\n   * @param conf\n   * @throws IOException\n   */\n  public void setup(JobConf conf) throws IOException {\n\n    String dir = String.format(\"%s/%s/%s\", System.getProperty(\"user.dir\"),\n                                           conf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                           conf.get(Constants.AppFabric.OUTPUT_DIR));\n    File workDir = new File(dir);\n\n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map<String, LocalResource> localResources =\n      new LinkedHashMap<String, LocalResource>();\n    MRApps.setupDistributedCache(conf, localResources);\n\n    // Find which resources are to be put on the local classpath\n    Map<String, Path> classpaths = new HashMap<String, Path>();\n    Path[] archiveClassPaths = DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths != null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS = p.getFileSystem(conf);\n        p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n                                                 remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths = DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths != null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS = p.getFileSystem(conf);\n        p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n                                                 remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n\n    // Localize the resources\n    LocalDirAllocator localDirAllocator =\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext = FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();\n\n    ExecutorService exec = null;\n    try {\n      ThreadFactory tf = new ThreadFactoryBuilder()\n        .setNameFormat(\"LocalDistributedCacheManagerWithFix Downloader #%d\")\n        .build();\n      exec = Executors.newCachedThreadPool(tf);\n      Path destPath = localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map<LocalResource, Future<Path>> resourcesToPaths = Maps.newHashMap();\n      Random rand = new Random();\n      for (LocalResource resource : localResources.values()) {\n        Callable<Path> download = new FSDownload(localFSFileContext, ugi, conf,\n                                                 new Path(destPath, Long.toString(rand.nextLong())), resource);\n        Future<Path> future = exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry<String, LocalResource> entry : localResources.entrySet()) {\n        LocalResource resource = entry.getValue();\n        Path path;\n        try {\n          path = resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString = path.toUri().toString();\n        String link = entry.getKey();\n        String target = new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n\n        if (resource.getType() == LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() == LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() == LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n                                               \"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath = ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp = resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec != null) {\n        exec.shutdown();\n      }\n    }\n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n        .arrayToString(localArchives.toArray(new String[localArchives\n          .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n        .arrayToString(localFiles.toArray(new String[localArchives\n          .size()])));\n    }\n    setupCalled = true;\n  }","id":45015,"modified_method":"/**\n   * Set up the distributed cache by localizing the resources, and updating\n   * the configuration with references to the localized resources.\n   * @param conf\n   * @throws IOException\n   */\n  public void setup(JobConf conf) throws IOException {\n\n    String dir = String.format(\"%s/%s/%s\", System.getProperty(\"user.dir\"),\n                                           conf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                           conf.get(Constants.AppFabric.OUTPUT_DIR));\n    File workDir = new File(dir);\n\n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map<String, LocalResource> localResources =\n      new LinkedHashMap<String, LocalResource>();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n    AtomicLong uniqueNumberGenerator =\n      new AtomicLong(System.currentTimeMillis());\n\n    // Find which resources are to be put on the local classpath\n    Map<String, Path> classpaths = new HashMap<String, Path>();\n    Path[] archiveClassPaths = DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths != null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS = p.getFileSystem(conf);\n        p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n                                                 remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths = DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths != null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS = p.getFileSystem(conf);\n        p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n                                                 remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n\n    // Localize the resources\n    LocalDirAllocator localDirAllocator =\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext = FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();\n\n    ExecutorService exec = null;\n    try {\n      ThreadFactory tf = new ThreadFactoryBuilder()\n        .setNameFormat(\"LocalDistributedCacheManagerWithFix Downloader #%d\")\n        .build();\n      exec = Executors.newCachedThreadPool(tf);\n      Path destPath = localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map<LocalResource, Future<Path>> resourcesToPaths = Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable<Path> download =\n          new FSDownload(localFSFileContext, ugi, conf,\n                         new Path(destPath, Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                         resource);\n        Future<Path> future = exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry<String, LocalResource> entry : localResources.entrySet()) {\n        LocalResource resource = entry.getValue();\n        Path path;\n        try {\n          path = resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString = path.toUri().toString();\n        String link = entry.getKey();\n        String target = new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n\n        if (resource.getType() == LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() == LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() == LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n                                               \"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath = ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp = resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec != null) {\n        exec.shutdown();\n      }\n    }\n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n        .arrayToString(localArchives.toArray(new String[localArchives\n          .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n        .arrayToString(localFiles.toArray(new String[localArchives\n          .size()])));\n    }\n    setupCalled = true;\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Create Runnables to encapsulate map tasks for use by the executor\n     * service.\n     * @param taskInfo Info about the map task splits\n     * @param jobId the job id\n     * @param mapOutputFiles a mapping from task attempts to output files\n     * @return a List of Runnables, one per map task.\n     */\n    protected List<MapTaskRunnable> getMapTaskRunnables(\n      TaskSplitMetaInfo [] taskInfo, JobID jobId,\n      Map<TaskAttemptID, MapOutputFile> mapOutputFiles) {\n\n      int numTasks = 0;\n      ArrayList<MapTaskRunnable> list = new ArrayList<MapTaskRunnable>();\n      for (TaskSplitMetaInfo task : taskInfo) {\n        list.add(new MapTaskRunnable(task, numTasks++, jobId,\n                                     mapOutputFiles));\n      }\n\n      return list;\n    }","id":45016,"modified_method":"/**\n     * Create Runnables to encapsulate map tasks for use by the executor\n     * service.\n     * @param taskInfo Info about the map task splits\n     * @param jobId the job id\n     * @param mapOutputFiles a mapping from task attempts to output files\n     * @return a List of Runnables, one per map task.\n     */\n    protected List<RunnableWithThrowable> getMapTaskRunnables(\n      TaskSplitMetaInfo [] taskInfo, JobID jobId,\n      Map<TaskAttemptID, MapOutputFile> mapOutputFiles) {\n\n      int numTasks = 0;\n      ArrayList<RunnableWithThrowable> list =\n        new ArrayList<RunnableWithThrowable>();\n      for (TaskSplitMetaInfo task : taskInfo) {\n        list.add(new MapTaskRunnable(task, numTasks++, jobId,\n                                     mapOutputFiles));\n      }\n\n      return list;\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized boolean statusUpdate(TaskAttemptID taskId,\n                                             TaskStatus taskStatus) throws IOException, InterruptedException {\n      LOG.info(taskStatus.getStateString());\n      int taskIndex = mapIds.indexOf(taskId);\n      if (taskIndex >= 0) {                       // mapping\n        float numTasks = (float) this.numMapTasks;\n\n        partialMapProgress[taskIndex] = taskStatus.getProgress();\n        mapCounters[taskIndex] = taskStatus.getCounters();\n\n        float partialProgress = 0.0f;\n        for (float f : partialMapProgress) {\n          partialProgress += f;\n        }\n        status.setMapProgress(partialProgress / numTasks);\n      } else {\n        reduceCounters = taskStatus.getCounters();\n        status.setReduceProgress(taskStatus.getProgress());\n      }\n\n      // ignore phase\n      return true;\n    }","id":45017,"modified_method":"public synchronized boolean statusUpdate(TaskAttemptID taskId,\n                                             TaskStatus taskStatus) throws IOException, InterruptedException {\n      // Serialize as we would if distributed in order to make deep copy\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      DataOutputStream dos = new DataOutputStream(baos);\n      taskStatus.write(dos);\n      dos.close();\n      taskStatus = TaskStatus.createTaskStatus(taskStatus.getIsMap());\n      taskStatus.readFields(new DataInputStream(\n        new ByteArrayInputStream(baos.toByteArray())));\n\n      LOG.info(taskStatus.getStateString());\n      int mapTaskIndex = mapIds.indexOf(taskId);\n      if (mapTaskIndex >= 0) {\n        // mapping\n        float numTasks = (float) this.numMapTasks;\n\n        partialMapProgress[mapTaskIndex] = taskStatus.getProgress();\n        mapCounters[mapTaskIndex] = taskStatus.getCounters();\n\n        float partialProgress = 0.0f;\n        for (float f : partialMapProgress) {\n          partialProgress += f;\n        }\n        status.setMapProgress(partialProgress / numTasks);\n      } else {\n        // reducing\n        int reduceTaskIndex = taskId.getTaskID().getId();\n        float numTasks = (float) this.numReduceTasks;\n\n        partialReduceProgress[reduceTaskIndex] = taskStatus.getProgress();\n        reduceCounters[reduceTaskIndex] = taskStatus.getCounters();\n\n        float partialProgress = 0.0f;\n        for (float f : partialReduceProgress) {\n          partialProgress += f;\n        }\n        status.setReduceProgress(partialProgress / numTasks);\n      }\n\n      // ignore phase\n      return true;\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/** Return the current values of the counters for this job,\n     * including tasks that are in progress.\n     */\n    public synchronized Counters getCurrentCounters() {\n      if (null == mapCounters) {\n        // Counters not yet initialized for job.\n        return EMPTY_COUNTERS;\n      }\n\n      Counters current = EMPTY_COUNTERS;\n      for (Counters c : mapCounters) {\n        current = Counters.sum(current, c);\n      }\n      current = Counters.sum(current, reduceCounters);\n      return current;\n    }","id":45018,"modified_method":"/** Return the current values of the counters for this job,\n     * including tasks that are in progress.\n     */\n    public synchronized Counters getCurrentCounters() {\n      if (null == mapCounters) {\n        // Counters not yet initialized for job.\n        return new Counters();\n      }\n\n      Counters current = new Counters();\n      for (Counters c : mapCounters) {\n        current = Counters.sum(current, c);\n      }\n\n      if (null != reduceCounters && reduceCounters.length > 0) {\n        for (Counters c : reduceCounters) {\n          current = Counters.sum(current, c);\n        }\n      }\n\n      return current;\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#getStagingAreaDir()\n   */\n  public String getStagingAreaDir() throws IOException {\n    Path stagingRootDir = new Path(conf.get(JTConfig.JT_STAGING_AREA_ROOT,\n                                            \"/tmp/hadoop/mapred/staging\"));\n    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();\n    String user;\n    if (ugi != null) {\n      user = ugi.getShortUserName() + rand.nextInt();\n    } else {\n      user = \"dummy\" + rand.nextInt();\n    }\n    return fs.makeQualified(new Path(stagingRootDir, user+\"/.staging\")).toString();\n  }","id":45019,"modified_method":"/**\n   * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#getStagingAreaDir()\n   */\n  public String getStagingAreaDir() throws IOException {\n    Path stagingRootDir = new Path(conf.get(JTConfig.JT_STAGING_AREA_ROOT,\n                                            \"/tmp/hadoop/mapred/staging\"));\n    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();\n    String user;\n    randid = rand.nextInt(Integer.MAX_VALUE);\n    if (ugi != null) {\n      user = ugi.getShortUserName() + randid;\n    } else {\n      user = \"dummy\" + randid;\n    }\n    return fs.makeQualified(new Path(stagingRootDir, user+\"/.staging\")).toString();\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized org.apache.hadoop.mapreduce.JobID getNewJobID() {\n    return new org.apache.hadoop.mapreduce.JobID(\"local\", ++jobid);\n  }","id":45020,"modified_method":"public synchronized org.apache.hadoop.mapreduce.JobID getNewJobID() {\n    return new org.apache.hadoop.mapreduce.JobID(\"local\" + randid, ++jobid);\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClusterMetrics getClusterMetrics() {\n    int numMapTasks = map_tasks.get();\n    return new ClusterMetrics(numMapTasks, reduce_tasks, numMapTasks,\n                              reduce_tasks, 0, 0, 1, 1, jobs.size(), 1, 0, 0);\n  }","id":45021,"modified_method":"public ClusterMetrics getClusterMetrics() {\n    int numMapTasks = map_tasks.get();\n    int numReduceTasks = reduce_tasks.get();\n    return new ClusterMetrics(numMapTasks, numReduceTasks, numMapTasks,\n                              numReduceTasks, 0, 0, 1, 1, jobs.size(), 1, 0, 0);\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Initialize the counters that will hold partial-progress from\n     * the various task attempts.\n     * @param numMaps the number of map tasks in this job.\n     */\n    private synchronized void initCounters(int numMaps) {\n      // Initialize state trackers for all map tasks.\n      this.partialMapProgress = new float[numMaps];\n      this.mapCounters = new Counters[numMaps];\n      for (int i = 0; i < numMaps; i++) {\n        this.mapCounters[i] = EMPTY_COUNTERS;\n      }\n\n      this.reduceCounters = EMPTY_COUNTERS;\n    }","id":45022,"modified_method":"/**\n     * Initialize the counters that will hold partial-progress from\n     * the various task attempts.\n     * @param numMaps the number of map tasks in this job.\n     */\n    private synchronized void initCounters(int numMaps, int numReduces) {\n      // Initialize state trackers for all map tasks.\n      this.partialMapProgress = new float[numMaps];\n      this.mapCounters = new Counters[numMaps];\n      for (int i = 0; i < numMaps; i++) {\n        this.mapCounters[i] = new Counters();\n      }\n\n      this.partialReduceProgress = new float[numReduces];\n      this.reduceCounters = new Counters[numReduces];\n      for (int i = 0; i < numReduces; i++) {\n        this.reduceCounters[i] = new Counters();\n      }\n\n      this.numMapTasks = numMaps;\n      this.numReduceTasks = numReduces;\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"static String getLocalTaskDir(String user, String jobid, String taskid,\n                                boolean isCleanupAttempt) {\n    String taskDir = SUBDIR + Path.SEPARATOR + user + Path.SEPARATOR + JOBCACHE\n      + Path.SEPARATOR + jobid + Path.SEPARATOR + taskid;\n    if (isCleanupAttempt) {\n      taskDir = taskDir + TASK_CLEANUP_SUFFIX;\n    }\n    return taskDir;\n  }","id":45023,"modified_method":"static String getLocalTaskDir(String user, String jobid, String taskid,\n                                boolean isCleanupAttempt) {\n    String taskDir = jobDir + Path.SEPARATOR + user + Path.SEPARATOR + JOBCACHE\n      + Path.SEPARATOR + jobid + Path.SEPARATOR + taskid;\n    if (isCleanupAttempt) {\n      taskDir = taskDir + TASK_CLEANUP_SUFFIX;\n    }\n    return taskDir;\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Get all blacklisted trackers in cluster. \n   * @return array of TaskTrackerInfo\n   */\n  public TaskTrackerInfo[] getBlacklistedTrackers()\n    throws IOException, InterruptedException {\n    return null;\n  }","id":45024,"modified_method":"/**\n   * Get all blacklisted trackers in cluster.\n   * @return array of TaskTrackerInfo\n   */\n  public TaskTrackerInfo[] getBlacklistedTrackers()\n    throws IOException, InterruptedException {\n    return new TaskTrackerInfo[0];\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void run() {\n      JobID jobId = profile.getJobID();\n      JobContext jContext = new JobContextImpl(job, jobId);\n\n      org.apache.hadoop.mapreduce.OutputCommitter outputCommitter = null;\n      try {\n        outputCommitter = createOutputCommitter(conf.getUseNewMapper(), jobId, conf);\n      } catch (Exception e) {\n        LOG.info(\"Failed to createOutputCommitter\", e);\n        return;\n      }\n\n      try {\n        TaskSplitMetaInfo[] taskSplitMetaInfos =\n          SplitMetaInfoReader.readSplitMetaInfo(jobId, localFs, conf, systemJobDir);\n\n        int numReduceTasks = job.getNumReduceTasks();\n        if (numReduceTasks > 1 || numReduceTasks < 0) {\n          // we only allow 0 or 1 reducer in local mode\n          numReduceTasks = 1;\n          job.setNumReduceTasks(1);\n        }\n        outputCommitter.setupJob(jContext);\n        status.setSetupProgress(1.0f);\n\n        Map<TaskAttemptID, MapOutputFile> mapOutputFiles =\n          Collections.synchronizedMap(new HashMap<TaskAttemptID, MapOutputFile>());\n\n        List<MapTaskRunnable> taskRunnables = getMapTaskRunnables(taskSplitMetaInfos,\n                                                                  jobId, mapOutputFiles);\n        ExecutorService mapService = createMapExecutor(taskRunnables.size());\n\n        // Start populating the executor with work units.\n        // They may begin running immediately (in other threads).\n        for (Runnable r : taskRunnables) {\n          mapService.submit(r);\n        }\n\n        try {\n          mapService.shutdown(); // Instructs queue to drain.\n\n          // Wait for tasks to finish; do not use a time-based timeout.\n          // (See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6179024)\n          LOG.info(\"Waiting for map tasks\");\n          mapService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n        } catch (InterruptedException ie) {\n          // Cancel all threads.\n          mapService.shutdownNow();\n          throw ie;\n        }\n\n        LOG.info(\"Map task executor complete.\");\n\n        // After waiting for the map tasks to complete, if any of these\n        // have thrown an exception, rethrow it now in the main thread context.\n        for (MapTaskRunnable r : taskRunnables) {\n          if (r.storedException != null) {\n            throw new Exception(r.storedException);\n          }\n        }\n\n        TaskAttemptID reduceId =\n          new TaskAttemptID(new TaskID(jobId, TaskType.REDUCE, 0), 0);\n        try {\n          if (numReduceTasks > 0) {\n            ReduceTask reduce = new ReduceTask(systemJobFile.toString(),\n                                               reduceId, 0, mapIds.size(), 1);\n            reduce.setUser(UserGroupInformation.getCurrentUser().\n              getShortUserName());\n            JobConf localConf = new JobConf(job);\n            localConf.set(\"mapreduce.jobtracker.address\", \"local\");\n            setupChildMapredLocalDirs(reduce, localConf);\n            // move map output to reduce input  \n            for (int i = 0; i < mapIds.size(); i++) {\n              if (!this.isInterrupted()) {\n                TaskAttemptID mapId = mapIds.get(i);\n                Path mapOut = mapOutputFiles.get(mapId).getOutputFile();\n                MapOutputFile localOutputFile = new MROutputFiles();\n                localOutputFile.setConf(localConf);\n                Path reduceIn =\n                  localOutputFile.getInputFileForWrite(mapId.getTaskID(),\n                                                       localFs.getFileStatus(mapOut).getLen());\n                if (!localFs.mkdirs(reduceIn.getParent())) {\n                  throw new IOException(\"Mkdirs failed to create \"\n                                          + reduceIn.getParent().toString());\n                }\n                if (!localFs.rename(mapOut, reduceIn))\n                  throw new IOException(\"Couldn't rename \" + mapOut);\n              } else {\n                throw new InterruptedException();\n              }\n            }\n            if (!this.isInterrupted()) {\n              reduce.setJobFile(localJobFile.toString());\n              localConf.setUser(reduce.getUser());\n              reduce.localizeConfiguration(localConf);\n              reduce.setConf(localConf);\n              reduce_tasks += 1;\n              myMetrics.launchReduce(reduce.getTaskID());\n              reduce.run(localConf, this);\n              myMetrics.completeReduce(reduce.getTaskID());\n              reduce_tasks -= 1;\n            } else {\n              throw new InterruptedException();\n            }\n          }\n        } finally {\n          for (MapOutputFile output : mapOutputFiles.values()) {\n            output.removeAll();\n          }\n        }\n        // delete the temporary directory in output directory\n        outputCommitter.commitJob(jContext);\n        status.setCleanupProgress(1.0f);\n\n        if (killed) {\n          this.status.setRunState(JobStatus.KILLED);\n        } else {\n          this.status.setRunState(JobStatus.SUCCEEDED);\n        }\n\n        JobEndNotifier.localRunnerNotification(job, status);\n\n      } catch (Throwable t) {\n        try {\n          outputCommitter.abortJob(jContext,\n                                   org.apache.hadoop.mapreduce.JobStatus.State.FAILED);\n        } catch (IOException ioe) {\n          LOG.info(\"Error cleaning up job:\" + id);\n        }\n        status.setCleanupProgress(1.0f);\n        if (killed) {\n          this.status.setRunState(JobStatus.KILLED);\n        } else {\n          this.status.setRunState(JobStatus.FAILED);\n        }\n        LOG.warn(id, t);\n\n        JobEndNotifier.localRunnerNotification(job, status);\n\n      } finally {\n        try {\n          fs.delete(systemJobFile.getParent(), true);  // delete submit dir\n          localFs.delete(localJobFile, true);              // delete local copy\n          // Cleanup distributed cache\n          localDistributedCacheManager.close();\n        } catch (IOException e) {\n          LOG.warn(\"Error cleaning up \"+id+\": \"+e);\n        }\n      }\n    }","id":45025,"modified_method":"@Override\n    public void run() {\n      JobID jobId = profile.getJobID();\n      JobContext jContext = new JobContextImpl(job, jobId);\n\n      org.apache.hadoop.mapreduce.OutputCommitter outputCommitter = null;\n      try {\n        outputCommitter = createOutputCommitter(conf.getUseNewMapper(), jobId, conf);\n      } catch (Exception e) {\n        LOG.info(\"Failed to createOutputCommitter\", e);\n        return;\n      }\n\n      try {\n        TaskSplitMetaInfo[] taskSplitMetaInfos =\n          SplitMetaInfoReader.readSplitMetaInfo(jobId, localFs, conf, systemJobDir);\n\n        int numReduceTasks = job.getNumReduceTasks();\n        outputCommitter.setupJob(jContext);\n        status.setSetupProgress(1.0f);\n\n        Map<TaskAttemptID, MapOutputFile> mapOutputFiles =\n          Collections.synchronizedMap(new HashMap<TaskAttemptID, MapOutputFile>());\n\n        List<RunnableWithThrowable> mapRunnables = getMapTaskRunnables(\n          taskSplitMetaInfos, jobId, mapOutputFiles);\n\n        initCounters(mapRunnables.size(), numReduceTasks);\n        ExecutorService mapService = createMapExecutor();\n        runTasks(mapRunnables, mapService, \"map\");\n\n        try {\n          if (numReduceTasks > 0) {\n            List<RunnableWithThrowable> reduceRunnables = getReduceTaskRunnables(\n              jobId, mapOutputFiles);\n            ExecutorService reduceService = createReduceExecutor();\n            runTasks(reduceRunnables, reduceService, \"reduce\");\n          }\n        } finally {\n          for (MapOutputFile output : mapOutputFiles.values()) {\n            output.removeAll();\n          }\n        }\n        // delete the temporary directory in output directory\n        outputCommitter.commitJob(jContext);\n        status.setCleanupProgress(1.0f);\n\n        if (killed) {\n          this.status.setRunState(JobStatus.KILLED);\n        } else {\n          this.status.setRunState(JobStatus.SUCCEEDED);\n        }\n\n        JobEndNotifier.localRunnerNotification(job, status);\n      } catch (Throwable t) {\n        try {\n          outputCommitter.abortJob(jContext,\n                                   org.apache.hadoop.mapreduce.JobStatus.State.FAILED);\n        } catch (IOException ioe) {\n          LOG.info(\"Error cleaning up job:\" + id);\n        }\n        status.setCleanupProgress(1.0f);\n        if (killed) {\n          this.status.setRunState(JobStatus.KILLED);\n        } else {\n          this.status.setRunState(JobStatus.FAILED);\n        }\n        LOG.warn(id, t);\n\n        JobEndNotifier.localRunnerNotification(job, status);\n\n      } finally {\n        try {\n          fs.delete(systemJobFile.getParent(), true);  // delete submit dir\n          localFs.delete(localJobFile, true);              // delete local copy\n          // Cleanup distributed cache\n          localDistributedCacheManager.close();\n        } catch (IOException e) {\n          LOG.warn(\"Error cleaning up \"+id+\": \"+e);\n        }\n      }\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Creates the executor service used to run map tasks.\n     *\n     * @param numMapTasks the total number of map tasks to be run\n     * @return an ExecutorService instance that handles map tasks\n     */\n    protected ExecutorService createMapExecutor(int numMapTasks) {\n\n      // Determine the size of the thread pool to use\n      int maxMapThreads = job.getInt(LOCAL_MAX_MAPS, 1);\n      if (maxMapThreads < 1) {\n        throw new IllegalArgumentException(\n          \"Configured \" + LOCAL_MAX_MAPS + \" must be >= 1\");\n      }\n      this.numMapTasks = numMapTasks;\n      maxMapThreads = Math.min(maxMapThreads, this.numMapTasks);\n      maxMapThreads = Math.max(maxMapThreads, 1); // In case of no tasks.\n\n      initCounters(this.numMapTasks);\n\n      LOG.debug(\"Starting thread pool executor.\");\n      LOG.debug(\"Max local threads: \" + maxMapThreads);\n      LOG.debug(\"Map tasks to process: \" + this.numMapTasks);\n\n      // Create a new executor service to drain the work queue.\n      ThreadFactory tf = new ThreadFactoryBuilder()\n        .setNameFormat(\"LocalJobRunner Map Task Executor #%d\")\n        .build();\n      ExecutorService executor = Executors.newFixedThreadPool(maxMapThreads, tf);\n\n      return executor;\n    }","id":45026,"modified_method":"/**\n     * Creates the executor service used to run map tasks.\n     *\n     * @return an ExecutorService instance that handles map tasks\n     */\n    protected synchronized ExecutorService createMapExecutor() {\n\n      // Determine the size of the thread pool to use\n      int maxMapThreads = job.getInt(LOCAL_MAX_MAPS, 1);\n      if (maxMapThreads < 1) {\n        throw new IllegalArgumentException(\n          \"Configured \" + LOCAL_MAX_MAPS + \" must be >= 1\");\n      }\n      maxMapThreads = Math.min(maxMapThreads, this.numMapTasks);\n      maxMapThreads = Math.max(maxMapThreads, 1); // In case of no tasks.\n\n      LOG.debug(\"Starting mapper thread pool executor.\");\n      LOG.debug(\"Max local threads: \" + maxMapThreads);\n      LOG.debug(\"Map tasks to process: \" + this.numMapTasks);\n\n      // Create a new executor service to drain the work queue.\n      ThreadFactory tf = new ThreadFactoryBuilder()\n        .setNameFormat(\"LocalJobRunner Map Task Executor #%d\")\n        .build();\n      ExecutorService executor = Executors.newFixedThreadPool(maxMapThreads, tf);\n\n      return executor;\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Get all active trackers in cluster. \n   * @return array of TaskTrackerInfo\n   */\n  public TaskTrackerInfo[] getActiveTrackers()\n    throws IOException, InterruptedException {\n    return null;\n  }","id":45027,"modified_method":"/**\n   * Get all active trackers in cluster.\n   * @return array of TaskTrackerInfo\n   */\n  public TaskTrackerInfo[] getActiveTrackers()\n    throws IOException, InterruptedException {\n    return new TaskTrackerInfo[0];\n  }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"public Job(JobID jobid, String jobSubmitDir) throws IOException {\n      this.systemJobDir = new Path(jobSubmitDir);\n      this.systemJobFile = new Path(systemJobDir, \"job.xml\");\n      this.id = jobid;\n      JobConf conf = new JobConf(systemJobFile);\n      this.localFs = FileSystem.getLocal(conf);\n      this.localJobDir = localFs.makeQualified(conf.getLocalPath(jobDir));\n      this.localJobFile = new Path(this.localJobDir, id + \".xml\");\n\n      // This is another fix for LocalJobRunner bug: job jar is not added to classpath.\n      // Alternatively to doing it here, we could use job.addFileToClassPath(jobJar) before submitting job in client\n      // code, but we don't want to mess with \"correct\" distributed execution (which adds job jar in classpath).\n      DistributedCache.addFileToClassPath(new Path(conf.getJar()), conf, FileSystem.get(conf));\n\n      // Use reflection to invoke the determineXXX method due to api change in hadoop API between 2.0.2-alpha\n      // and 2.0.4-alpha.\n      try {\n        try {\n          // Try with the 2.0.4-alpha method first\n          Method determineMethod = ClientDistributedCacheManager.class.getMethod(\n            \"determineTimestampsAndCacheVisibilities\", Configuration.class);\n          determineMethod.invoke(null, conf);\n\n        } catch (NoSuchMethodException e) {\n          // Assuming it's older hadoop\n          try {\n            Method determineTimestamps = ClientDistributedCacheManager.class.getMethod(\"determineTimestamps\",\n                                                                                       Configuration.class);\n            Method determineCaches = ClientDistributedCacheManager.class.getMethod(\"determineCacheVisibilities\",\n                                                                                   Configuration.class);\n\n            determineTimestamps.invoke(null, conf);\n            determineCaches.invoke(null, conf);\n          } catch (NoSuchMethodException ex) {\n            throw Throwables.propagate(ex);\n          }\n        }\n      } catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n\n      // Manage the distributed cache.  If there are files to be copied,\n      // this will trigger localFile to be re-written again.\n      localDistributedCacheManager = new LocalDistributedCacheManagerWithFix();\n      localDistributedCacheManager.setup(conf);\n\n      // Write out configuration file.  Instead of copying it from\n      // systemJobFile, we re-write it, since setup(), above, may have\n      // updated it.\n      OutputStream out = localFs.create(localJobFile);\n      try {\n        conf.writeXml(out);\n      } finally {\n        out.close();\n      }\n      this.job = new JobConf(localJobFile);\n\n      // Job (the current object) is a Thread, so we wrap its class loader.\n      if (localDistributedCacheManager.hasLocalClasspaths()) {\n        ClassLoader classLoader = localDistributedCacheManager.makeClassLoader(getContextClassLoader());\n        setContextClassLoader(classLoader);\n        this.job.setClassLoader(classLoader);\n      }\n\n      profile = new JobProfile(job.getUser(), id, systemJobFile.toString(),\n                               \"http://localhost:8080/\", job.getJobName());\n      status = new JobStatus(id, 0.0f, 0.0f, JobStatus.RUNNING,\n                             profile.getUser(), profile.getJobName(), profile.getJobFile(),\n                             profile.getURL().toString());\n\n      jobs.put(id, this);\n\n      this.start();\n    }","id":45028,"modified_method":"public Job(JobID jobid, String jobSubmitDir) throws IOException {\n      this.systemJobDir = new Path(jobSubmitDir);\n      this.systemJobFile = new Path(systemJobDir, \"job.xml\");\n      this.id = jobid;\n      JobConf conf = new JobConf(systemJobFile);\n      this.localFs = FileSystem.getLocal(conf);\n      String user = UserGroupInformation.getCurrentUser().getShortUserName();\n      this.localJobDir = localFs.makeQualified(new Path(\n        new Path(conf.getLocalPath(jobDir), user), jobid.toString()));\n      this.localJobFile = new Path(this.localJobDir, id + \".xml\");\n\n      // This is another fix for LocalJobRunner bug: job jar is not added to classpath.\n      // Alternatively to doing it here, we could use job.addFileToClassPath(jobJar) before submitting job in client\n      // code, but we don't want to mess with \"correct\" distributed execution (which adds job jar in classpath).\n      DistributedCache.addFileToClassPath(new Path(conf.getJar()), conf, FileSystem.get(conf));\n      ClientDistributedCacheManager.determineTimestampsAndCacheVisibilities(conf);\n\n      // Manage the distributed cache.  If there are files to be copied,\n      // this will trigger localFile to be re-written again.\n      localDistributedCacheManager = new LocalDistributedCacheManagerWithFix();\n      localDistributedCacheManager.setup(conf);\n\n      // Write out configuration file.  Instead of copying it from\n      // systemJobFile, we re-write it, since setup(), above, may have\n      // updated it.\n      OutputStream out = localFs.create(localJobFile);\n      try {\n        conf.writeXml(out);\n      } finally {\n        out.close();\n      }\n      this.job = new JobConf(localJobFile);\n\n      // Job (the current object) is a Thread, so we wrap its class loader.\n      if (localDistributedCacheManager.hasLocalClasspaths()) {\n        ClassLoader classLoader = localDistributedCacheManager.makeClassLoader(getContextClassLoader());\n        setContextClassLoader(classLoader);\n        this.job.setClassLoader(classLoader);\n      }\n\n      profile = new JobProfile(job.getUser(), id, systemJobFile.toString(),\n                               \"http://localhost:8080/\", job.getJobName());\n      status = new JobStatus(id, 0.0f, 0.0f, JobStatus.RUNNING,\n                             profile.getUser(), profile.getJobName(), profile.getJobFile(),\n                             profile.getURL().toString());\n\n      jobs.put(id, this);\n\n      this.start();\n    }","commit_id":"a372354a3cb65a4de88a1bdc4413940c6cec32f0","url":"https://github.com/caskdata/cdap"},{"original_method":"private static StringBuilder createReplacementText(@Nullable PsiExpression expression, StringBuilder out) {\n      if (expression instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n        final IElementType tokenType = polyadicExpression.getOperationTokenType();\n        final PsiElement parent = expression.getParent();\n        if (parent instanceof PsiPolyadicExpression) {\n          final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n          final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n          if (!tokenType.equals(parentOperationSign)) {\n            out.append('(');\n            createText(polyadicExpression, out);\n            out.append(')');\n            return out;\n          }\n        } else if (parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression) {\n          out.append('(');\n          createText(polyadicExpression, out);\n          out.append(')');\n          return out;\n        }\n        createText(polyadicExpression, out);\n      }\n      else if (expression instanceof PsiParenthesizedExpression) {\n        final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n        final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n        final PsiElement parent = expression.getParent();\n        if (!(parent instanceof PsiParenthesizedExpression)) {\n          out.append('(');\n          createReplacementText(unwrappedExpression, out);\n          out.append(')');\n        }\n        else {\n          createReplacementText(unwrappedExpression, out);\n        }\n      }\n      else if (expression instanceof PsiInstanceOfExpression) {\n        final PsiElement parent = expression.getParent();\n        final PsiInstanceOfExpression instanceofExpression = (PsiInstanceOfExpression)expression;\n        if (mightBeConfusingExpression(parent)) {\n          out.append('(');\n          createText(instanceofExpression, out);\n          out.append(')');\n        }\n        else {\n          createText(instanceofExpression, out);\n        }\n      }\n      else if (expression instanceof PsiConditionalExpression) {\n        final PsiElement parent = expression.getParent();\n        final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)expression;\n        if (mightBeConfusingExpression(parent)) {\n          out.append('(');\n          createText(conditionalExpression, out);\n          out.append(')');\n        }\n        else {\n          createText(conditionalExpression, out);\n        }\n      }\n      else if (expression != null) {\n        out.append(expression.getText());\n      }\n      return out;\n    }","id":45029,"modified_method":"private static StringBuilder createReplacementText(@Nullable PsiExpression expression, StringBuilder out) {\n      if (expression instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n        final IElementType tokenType = polyadicExpression.getOperationTokenType();\n        final PsiElement parent = expression.getParent();\n        if (parent instanceof PsiPolyadicExpression) {\n          final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n          final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n          final boolean parentheses = !tokenType.equals(parentOperationSign);\n          appendText(polyadicExpression, parentheses, out);\n        } else {\n          final boolean parentheses = parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression;\n          appendText(polyadicExpression, parentheses, out);\n        }\n      }\n      else if (expression instanceof PsiParenthesizedExpression) {\n        final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n        final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n        final PsiElement parent = expression.getParent();\n        if (!(parent instanceof PsiParenthesizedExpression)) {\n          out.append('(');\n          createReplacementText(unwrappedExpression, out);\n          out.append(')');\n        }\n        else {\n          createReplacementText(unwrappedExpression, out);\n        }\n      }\n      else if (expression instanceof PsiInstanceOfExpression) {\n        final PsiInstanceOfExpression instanceofExpression = (PsiInstanceOfExpression)expression;\n        final PsiElement parent = expression.getParent();\n        final boolean parentheses = mightBeConfusingExpression(parent);\n        appendText(instanceofExpression, parentheses, out);\n      }\n      else if (expression instanceof PsiConditionalExpression) {\n        final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)expression;\n        final PsiElement parent = expression.getParent();\n        final boolean parentheses = mightBeConfusingExpression(parent);\n        appendText(conditionalExpression, parentheses, out);\n      }\n      else if (expression instanceof PsiAssignmentExpression) {\n        final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)expression;\n        final PsiElement parent = expression.getParent();\n        final boolean parentheses = mightBeConfusingExpression(parent) && !isSimpleAssignment(assignmentExpression, parent);\n        appendText(assignmentExpression, parentheses, out);\n      }\n      else if (expression != null) {\n        out.append(expression.getText());\n      }\n      return out;\n    }","commit_id":"18868caae3fceba8920a29feba7b445c9568724d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean mightBeConfusingExpression(@Nullable PsiElement element) {\n    return element instanceof PsiPolyadicExpression || element instanceof PsiConditionalExpression ||\n           element instanceof PsiInstanceOfExpression;\n  }","id":45030,"modified_method":"static boolean mightBeConfusingExpression(@Nullable PsiElement element) {\n    return element instanceof PsiPolyadicExpression || element instanceof PsiConditionalExpression ||\n           element instanceof PsiInstanceOfExpression || element instanceof PsiAssignmentExpression;\n  }","commit_id":"18868caae3fceba8920a29feba7b445c9568724d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void createText(PsiPolyadicExpression polyadicExpression, StringBuilder out) {\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand == null) {\n          continue;\n        }\n        if (operand.getType() == PsiType.VOID) {\n          throw new ProcessCanceledException();\n        }\n        if (operands.length == 1) {\n          createReplacementText(operand, out);\n        }\n        final PsiJavaToken token = polyadicExpression.getTokenBeforeOperand(operand);\n        if (token != null) {\n          final PsiElement beforeToken = token.getPrevSibling();\n          if (beforeToken instanceof PsiWhiteSpace) {\n            out.append(beforeToken.getText());\n          }\n          out.append(token.getText());\n          final PsiElement afterToken = token.getNextSibling();\n          if (afterToken instanceof PsiWhiteSpace) {\n            out.append(afterToken.getText());\n          }\n        }\n        if (operands.length != 1) {\n          createReplacementText(operand, out);\n        }\n      }\n    }","id":45031,"modified_method":"private static void appendText(PsiPolyadicExpression polyadicExpression, boolean parentheses, StringBuilder out) {\n      if (parentheses) {\n        out.append('(');\n      }\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand == null) {\n          continue;\n        }\n        if (operand.getType() == PsiType.VOID) {\n          throw new ProcessCanceledException();\n        }\n        if (operands.length == 1) {\n          createReplacementText(operand, out);\n        }\n        final PsiJavaToken token = polyadicExpression.getTokenBeforeOperand(operand);\n        if (token != null) {\n          final PsiElement beforeToken = token.getPrevSibling();\n          if (beforeToken instanceof PsiWhiteSpace) {\n            out.append(beforeToken.getText());\n          }\n          out.append(token.getText());\n          final PsiElement afterToken = token.getNextSibling();\n          if (afterToken instanceof PsiWhiteSpace) {\n            out.append(afterToken.getText());\n          }\n        }\n        if (operands.length != 1) {\n          createReplacementText(operand, out);\n        }\n      }\n      if (parentheses) {\n        out.append(')');\n      }\n    }","commit_id":"18868caae3fceba8920a29feba7b445c9568724d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void createText(PsiInstanceOfExpression instanceofExpression, StringBuilder out) {\n      final PsiExpression operand = instanceofExpression.getOperand();\n      createReplacementText(operand, out);\n      out.append(\" instanceof \");\n      final PsiTypeElement checkType = instanceofExpression.getCheckType();\n      if (checkType != null) {\n        out.append(checkType.getText());\n      }\n    }","id":45032,"modified_method":"private static void appendText(PsiInstanceOfExpression instanceofExpression, boolean parentheses, StringBuilder out) {\n      if (parentheses) {\n        out.append('(');\n      }\n      final PsiExpression operand = instanceofExpression.getOperand();\n      createReplacementText(operand, out);\n      out.append(\" instanceof \");\n      final PsiTypeElement checkType = instanceofExpression.getCheckType();\n      if (checkType != null) {\n        out.append(checkType.getText());\n      }\n      if (parentheses) {\n        out.append(')');\n      }\n    }","commit_id":"18868caae3fceba8920a29feba7b445c9568724d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void createText(PsiConditionalExpression conditionalExpression, StringBuilder out) {\n      final PsiExpression condition = conditionalExpression.getCondition();\n      createReplacementText(condition, out);\n      out.append('?');\n      final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n      createReplacementText(thenExpression, out);\n      out.append(':');\n      final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n      createReplacementText(elseExpression, out);\n    }","id":45033,"modified_method":"private static void appendText(PsiConditionalExpression conditionalExpression, boolean parentheses, StringBuilder out) {\n      if (parentheses) {\n        out.append('(');\n      }\n      final PsiExpression condition = conditionalExpression.getCondition();\n      createReplacementText(condition, out);\n      out.append('?');\n      final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n      createReplacementText(thenExpression, out);\n      out.append(':');\n      final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n      createReplacementText(elseExpression, out);\n      if (parentheses) {\n        out.append(')');\n      }\n    }","commit_id":"18868caae3fceba8920a29feba7b445c9568724d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static StringBuilder createReplacementText(@Nullable PsiExpression expression, StringBuilder out) {\n    if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n        final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n        final boolean parentheses = !tokenType.equals(parentOperationSign);\n        appendText(polyadicExpression, parentheses, out);\n      } else {\n        final boolean parentheses = parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression;\n        appendText(polyadicExpression, parentheses, out);\n      }\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression unwrappedExpression = parenthesizedExpression.getExpression();\n      final PsiElement parent = expression.getParent();\n      if (!(parent instanceof PsiParenthesizedExpression)) {\n        out.append('(');\n        createReplacementText(unwrappedExpression, out);\n        out.append(')');\n      }\n      else {\n        createReplacementText(unwrappedExpression, out);\n      }\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceofExpression = (PsiInstanceOfExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent);\n      appendText(instanceofExpression, parentheses, out);\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent);\n      appendText(conditionalExpression, parentheses, out);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent) && !isSimpleAssignment(assignmentExpression, parent);\n      appendText(assignmentExpression, parentheses, out);\n    }\n    else if (expression != null) {\n      out.append(expression.getText());\n    }\n    return out;\n  }","id":45034,"modified_method":"private static StringBuilder createReplacementText(@Nullable PsiExpression expression, StringBuilder out) {\n    if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses;\n      if (parent instanceof PsiPolyadicExpression) {\n        final PsiPolyadicExpression parentPolyadicExpression = (PsiPolyadicExpression)parent;\n        final IElementType parentOperationSign = parentPolyadicExpression.getOperationTokenType();\n        final IElementType tokenType = polyadicExpression.getOperationTokenType();\n        parentheses = !tokenType.equals(parentOperationSign);\n      } else {\n        parentheses = parent instanceof PsiConditionalExpression || parent instanceof PsiInstanceOfExpression;\n      }\n      appendText(polyadicExpression, parentheses, out);\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiElement parent = expression.getParent();\n      for (PsiElement child : parenthesizedExpression.getChildren()) {\n        if (child instanceof PsiJavaToken) {\n          final PsiJavaToken token = (PsiJavaToken)child;\n          final IElementType tokenType = token.getTokenType();\n          if ((tokenType != JavaTokenType.LPARENTH && tokenType != JavaTokenType.RPARENTH) ||\n              !(parent instanceof PsiParenthesizedExpression)) {\n            out.append(child.getText());\n          }\n        }\n        else if (child instanceof PsiExpression) {\n          final PsiExpression unwrappedExpression = (PsiExpression)child;\n          createReplacementText(unwrappedExpression, out);\n        }\n        else {\n          out.append(child.getText());\n        }\n      }\n    }\n    else if (expression instanceof PsiInstanceOfExpression || expression instanceof PsiConditionalExpression) {\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = mightBeConfusingExpression(parent);\n      appendText(expression, parentheses, out);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)expression;\n      final PsiElement parent = expression.getParent();\n      final boolean parentheses = (mightBeConfusingExpression(parent) || parent instanceof PsiVariable) &&\n                                  !isSimpleAssignment(assignmentExpression, parent);\n      appendText(assignmentExpression, parentheses, out);\n    }\n    else if (expression != null) {\n      out.append(expression.getText());\n    }\n    return out;\n  }","commit_id":"ee0893c26c966039f6a1a567c74858c8aacb1bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendText(PsiConditionalExpression conditionalExpression, boolean parentheses, StringBuilder out) {\n    if (parentheses) {\n      out.append('(');\n    }\n    final PsiExpression condition = conditionalExpression.getCondition();\n    createReplacementText(condition, out);\n    out.append('?');\n    final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n    createReplacementText(thenExpression, out);\n    out.append(':');\n    final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n    createReplacementText(elseExpression, out);\n    if (parentheses) {\n      out.append(')');\n    }\n  }","id":45035,"modified_method":"private static void appendText(PsiExpression expression, boolean parentheses, StringBuilder out) {\n    if (parentheses) {\n      out.append('(');\n    }\n    for (PsiElement child : expression.getChildren()) {\n      if (child instanceof PsiExpression) {\n        createReplacementText((PsiExpression)child, out);\n      }\n      else {\n        out.append(child.getText());\n      }\n    }\n    if (parentheses) {\n      out.append(')');\n    }\n  }","commit_id":"ee0893c26c966039f6a1a567c74858c8aacb1bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isSimpleAssignment(PsiAssignmentExpression assignmentExpression, PsiElement parent) {\n    if (!(parent instanceof PsiAssignmentExpression)) {\n      return false;\n    }\n    final PsiAssignmentExpression parentAssignmentExpression = (PsiAssignmentExpression)parent;\n    final IElementType parentTokenType = parentAssignmentExpression.getOperationTokenType();\n    final IElementType tokenType = assignmentExpression.getOperationTokenType();\n    return parentTokenType.equals(tokenType);\n  }","id":45036,"modified_method":"private static boolean isSimpleAssignment(PsiAssignmentExpression assignmentExpression, PsiElement parent) {\n    final IElementType parentTokenType;\n    if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression parentAssignmentExpression = (PsiAssignmentExpression)parent;\n      parentTokenType = parentAssignmentExpression.getOperationTokenType();\n    }\n    else if (parent instanceof PsiVariable) {\n      parentTokenType = JavaTokenType.EQ;\n    }\n    else {\n      return false;\n    }\n    final IElementType tokenType = assignmentExpression.getOperationTokenType();\n    return parentTokenType.equals(tokenType);\n  }","commit_id":"ee0893c26c966039f6a1a567c74858c8aacb1bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(@NotNull PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (mightBeConfusingExpression(parent)) {\n      return false;\n    }\n    if (element instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)element;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand instanceof PsiInstanceOfExpression) {\n          return true;\n        }\n        if (!(operand instanceof PsiPolyadicExpression)) {\n          continue;\n        }\n        final PsiPolyadicExpression expression = (PsiPolyadicExpression)operand;\n        final IElementType otherTokenType = expression.getOperationTokenType();\n        if (!tokenType.equals(otherTokenType)) {\n          return true;\n        }\n      }\n    }\n    else if (element instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)element;\n      final PsiExpression condition = conditionalExpression.getCondition();\n      if (mightBeConfusingExpression(condition)) {\n        return true;\n      }\n      final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n      if (mightBeConfusingExpression(thenExpression)) {\n        return true;\n      }\n      final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n      if (mightBeConfusingExpression(elseExpression)) {\n        return true;\n      }\n    }\n    else if (element instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression = (PsiInstanceOfExpression)element;\n      final PsiExpression operand = instanceOfExpression.getOperand();\n      if (mightBeConfusingExpression(operand)) {\n        return true;\n      }\n    }\n    else if (element instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)element;\n      final PsiExpression rhs = assignmentExpression.getRExpression();\n      if (!(mightBeConfusingExpression(rhs))) {\n        return false;\n      }\n      if (rhs instanceof PsiAssignmentExpression) {\n        final PsiAssignmentExpression nestedAssignment = (PsiAssignmentExpression)rhs;\n        final IElementType nestedTokenType = nestedAssignment.getOperationTokenType();\n        final IElementType tokenType = assignmentExpression.getOperationTokenType();\n        if (nestedTokenType.equals(tokenType)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }","id":45037,"modified_method":"public boolean satisfiedBy(@NotNull PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (mightBeConfusingExpression(parent)) {\n      return false;\n    }\n    if (element instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)element;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (operand instanceof PsiInstanceOfExpression) {\n          return true;\n        }\n        if (!(operand instanceof PsiPolyadicExpression)) {\n          continue;\n        }\n        final PsiPolyadicExpression expression = (PsiPolyadicExpression)operand;\n        final IElementType otherTokenType = expression.getOperationTokenType();\n        if (!tokenType.equals(otherTokenType)) {\n          return true;\n        }\n      }\n    }\n    else if (element instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditionalExpression = (PsiConditionalExpression)element;\n      final PsiExpression condition = conditionalExpression.getCondition();\n      if (mightBeConfusingExpression(condition)) {\n        return true;\n      }\n      final PsiExpression thenExpression = conditionalExpression.getThenExpression();\n      if (mightBeConfusingExpression(thenExpression)) {\n        return true;\n      }\n      final PsiExpression elseExpression = conditionalExpression.getElseExpression();\n      if (mightBeConfusingExpression(elseExpression)) {\n        return true;\n      }\n    }\n    else if (element instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression = (PsiInstanceOfExpression)element;\n      final PsiExpression operand = instanceOfExpression.getOperand();\n      if (mightBeConfusingExpression(operand)) {\n        return true;\n      }\n    }\n    else if (element instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)element;\n      final IElementType tokenType = assignmentExpression.getOperationTokenType();\n      if (parent instanceof PsiVariable && tokenType != JavaTokenType.EQ) {\n        return true;\n      }\n      final PsiExpression rhs = assignmentExpression.getRExpression();\n      if (!mightBeConfusingExpression(rhs)) {\n        return false;\n      }\n      if (rhs instanceof PsiAssignmentExpression) {\n        final PsiAssignmentExpression nestedAssignment = (PsiAssignmentExpression)rhs;\n        final IElementType nestedTokenType = nestedAssignment.getOperationTokenType();\n        if (nestedTokenType.equals(tokenType)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"ee0893c26c966039f6a1a567c74858c8aacb1bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Future<?> getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    return executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n\n          try {\n            SortedMap<Long, Path> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n            Path prevFile = null;\n            List<Path> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Path> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && entry.getKey() < toTimeMs && prevFile != null) {\n                files.add(prevFile);\n              }\n              prevFile = entry.getValue();\n            }\n\n            if (prevFile != null) {\n              files.add(prevFile);\n            }\n\n            callback.init();\n            AvroFileLogReader avroFileLogReader = new AvroFileLogReader(hConfig, schema);\n            for (Path file : files) {\n              avroFileLogReader.readLog(file, logFilter, fromTimeMs, toTimeMs, Integer.MAX_VALUE, callback);\n            }\n          } catch (OperationException e) {\n            throw  Throwables.propagate(e);\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","id":45038,"modified_method":"@Override\n  public void getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n\n          try {\n            SortedMap<Long, Path> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n            Path prevFile = null;\n            List<Path> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n            for (Map.Entry<Long, Path> entry : sortedFiles.entrySet()) {\n              if (entry.getKey() >= fromTimeMs && entry.getKey() < toTimeMs && prevFile != null) {\n                files.add(prevFile);\n              }\n              prevFile = entry.getValue();\n            }\n\n            if (prevFile != null) {\n              files.add(prevFile);\n            }\n\n            callback.init();\n            AvroFileLogReader avroFileLogReader = new AvroFileLogReader(hConfig, schema);\n            for (Path file : files) {\n              avroFileLogReader.readLog(file, logFilter, fromTimeMs, toTimeMs, Integer.MAX_VALUE, callback);\n            }\n          } catch (OperationException e) {\n            throw  Throwables.propagate(e);\n          } finally {\n            callback.close();\n          }\n        }\n      }\n    );\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Future<?> getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    return executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          int partition = MD5Hash.digest(loggingContext.getLogPartition()).hashCode() % numPartitions;\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n\n          try {\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset - maxEvents;\n            if (fromOffset < 0 || startOffset >= latestOffset)  {\n              startOffset = latestOffset - maxEvents - 1;\n            }\n\n            callback.init();\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","id":45039,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          int partition = MD5Hash.digest(loggingContext.getLogPartition()).hashCode() % numPartitions;\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n\n          try {\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset - maxEvents;\n            if (fromOffset < 0 || startOffset >= latestOffset)  {\n              startOffset = latestOffset - maxEvents - 1;\n            }\n\n            callback.init();\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Future<?> getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    return executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          int partition = MD5Hash.digest(loggingContext.getLogPartition()).hashCode() % numPartitions;\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n\n          try {\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset + 1;\n            if (fromOffset < 0 || startOffset >= latestOffset) {\n              startOffset = latestOffset - maxEvents - 1;\n            }\n\n            callback.init();\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","id":45040,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          int partition = MD5Hash.digest(loggingContext.getLogPartition()).hashCode() % numPartitions;\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n\n          try {\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset + 1;\n            if (fromOffset < 0 || startOffset >= latestOffset) {\n              startOffset = latestOffset - maxEvents - 1;\n            }\n\n            callback.init();\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"public LogCleanup(FileSystem fileSystem, FileMetaDataManager fileMetaDataManager, Path logBaseDir,\n             long retentionDurationMs) {\n    this.fileSystem = fileSystem;\n    this.fileMetaDataManager = fileMetaDataManager;\n    this.logBaseDir = logBaseDir;\n    this.retentionDurationMs = retentionDurationMs;\n  }","id":45041,"modified_method":"public LogCleanup(FileSystem fileSystem, FileMetaDataManager fileMetaDataManager, Path logBaseDir,\n             long retentionDurationMs) {\n    this.fileSystem = fileSystem;\n    this.fileMetaDataManager = fileMetaDataManager;\n    this.logBaseDir = logBaseDir;\n    this.retentionDurationMs = retentionDurationMs;\n\n    LOG.info(\"Log base dir = {}\", logBaseDir);\n    LOG.info(\"Log retention duration = {} ms\", retentionDurationMs);\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void run() {\n    try {\n      long tillTime = System.currentTimeMillis() - retentionDurationMs;\n      final Set<Path> parentDirs = Sets.newHashSet();\n      fileMetaDataManager.cleanMetaData(tillTime,\n                                        new FileMetaDataManager.DeleteCallback() {\n                                          @Override\n                                          public void handle(Path path) {\n                                            try {\n                                              if (fileSystem.exists(path)) {\n                                                LOG.info(String.format(\"Deleting log file %s\", path.toUri()));\n                                                fileSystem.delete(path, false);\n                                              }\n\n                                              parentDirs.add(path.getParent());\n                                            } catch (IOException e) {\n                                              LOG.error(\n                                                String.format(\"Got exception when deleting path %s\", path), e);\n                                              throw Throwables.propagate(e);\n                                            }\n                                          }\n                                        });\n\n      // Delete any empty parent dirs\n      for (Path dir : parentDirs) {\n        deleteEmptyDir(dir);\n      }\n\n    } catch (Throwable e){\n      LOG.error(\"Got exception when cleaning up. Will try again later.\", e);\n    }\n  }","id":45042,"modified_method":"@Override\n  public void run() {\n    LOG.info(\"Running log cleanup...\");\n    try {\n      long tillTime = System.currentTimeMillis() - retentionDurationMs;\n      final Set<Path> parentDirs = Sets.newHashSet();\n      fileMetaDataManager.cleanMetaData(tillTime,\n                                        new FileMetaDataManager.DeleteCallback() {\n                                          @Override\n                                          public void handle(Path path) {\n                                            try {\n                                              if (fileSystem.exists(path)) {\n                                                LOG.info(String.format(\"Deleting log file %s\", path.toUri()));\n                                                fileSystem.delete(path, false);\n                                              }\n\n                                              parentDirs.add(path.getParent());\n                                            } catch (IOException e) {\n                                              LOG.error(\n                                                String.format(\"Got exception when deleting path %s\", path), e);\n                                              throw Throwables.propagate(e);\n                                            }\n                                          }\n                                        });\n\n      // Delete any empty parent dirs\n      for (Path dir : parentDirs) {\n        deleteEmptyDir(dir);\n      }\n\n    } catch (Throwable e){\n      LOG.error(\"Got exception when cleaning up. Will try again later.\", e);\n    }\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<TLogResult> getLogPrev(String accountId, String applicationId, String entityId, TEntityType entityType,\n                                     long fromOffset, int maxEvents, String filterStr)\n    throws MetricsServiceException, TException {\n    LoggingContext loggingContext = LoggingContextHelper.getLoggingContext(accountId, applicationId,\n                                                                           entityId, getEntityType(entityType));\n    LogCallback logCallback = new LogCallback(maxEvents, logPattern);\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n      logReader.getLogPrev(loggingContext, fromOffset, maxEvents, filter, logCallback).get();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    return logCallback.getLogResults();\n  }","id":45043,"modified_method":"@Override\n  public List<TLogResult> getLogPrev(String accountId, String applicationId, String entityId, TEntityType entityType,\n                                     long fromOffset, int maxEvents, String filterStr)\n    throws MetricsServiceException, TException {\n    LoggingContext loggingContext = LoggingContextHelper.getLoggingContext(accountId, applicationId,\n                                                                           entityId, getEntityType(entityType));\n    LogCallback logCallback = new LogCallback(maxEvents, logPattern);\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n      logReader.getLogPrev(loggingContext, fromOffset, maxEvents, filter, logCallback);\n      logCallback.await();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    return logCallback.getLogResults();\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<TLogResult> getLogNext(String accountId, String applicationId, String entityId, TEntityType entityType,\n                                     long fromOffset, int maxEvents, String filterStr)\n    throws MetricsServiceException, TException {\n    LoggingContext loggingContext = LoggingContextHelper.getLoggingContext(accountId, applicationId,\n                                                                           entityId, getEntityType(entityType));\n    LogCallback logCallback = new LogCallback(maxEvents, logPattern);\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n      logReader.getLogNext(loggingContext, fromOffset, maxEvents, filter, logCallback).get();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    return logCallback.getLogResults();\n  }","id":45044,"modified_method":"@Override\n  public List<TLogResult> getLogNext(String accountId, String applicationId, String entityId, TEntityType entityType,\n                                     long fromOffset, int maxEvents, String filterStr)\n    throws MetricsServiceException, TException {\n    LoggingContext loggingContext = LoggingContextHelper.getLoggingContext(accountId, applicationId,\n                                                                           entityId, getEntityType(entityType));\n    LogCallback logCallback = new LogCallback(maxEvents, logPattern);\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n      logReader.getLogNext(loggingContext, fromOffset, maxEvents, filter, logCallback);\n      logCallback.await();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    return logCallback.getLogResults();\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void close() {\n      patternLayout.stop();\n    }","id":45045,"modified_method":"@Override\n    public void close() {\n      patternLayout.stop();\n      doneLatch.countDown();\n    }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Future<?> getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    return executor.submit(new Runnable() {\n      @Override\n      public void run() {\n        Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n        SortedMap<Long, FileStatus> sortedFiles = getFiles(Collections.<Long>reverseOrder());\n        if (sortedFiles.isEmpty()) {\n          return;\n        }\n\n        long fromTimeMs = fromOffset >= 0 ? fromOffset - 1 :\n          sortedFiles.get(sortedFiles.firstKey()).getModificationTime();\n\n        List<Path> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n        for (Map.Entry<Long, FileStatus> entry : sortedFiles.entrySet()){\n          if (entry.getKey() <= fromTimeMs) {\n            tailFiles.add(entry.getValue().getPath());\n          }\n        }\n\n        List<ILoggingEvent> loggingEvents = Lists.newLinkedList();\n        AvroFileLogReader logReader = new AvroFileLogReader(hConf, schema);\n        for (Path file : tailFiles) {\n          Collection<ILoggingEvent> events = logReader.readLogPrev(file, logFilter, fromTimeMs,\n                                                                   maxEvents - loggingEvents.size());\n          loggingEvents.addAll(0, events);\n          if (events.size() >= maxEvents) {\n            break;\n          }\n        }\n\n        callback.init();\n        // TODO: better algorithm to read previous events\n        for (ILoggingEvent event : loggingEvents) {\n          callback.handle(new LogEvent(event, event.getTimeStamp()));\n        }\n        callback.close();\n      }\n    });\n  }","id":45046,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(new Runnable() {\n      @Override\n      public void run() {\n        Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n        SortedMap<Long, FileStatus> sortedFiles = getFiles(Collections.<Long>reverseOrder());\n        if (sortedFiles.isEmpty()) {\n          return;\n        }\n\n        long fromTimeMs = fromOffset >= 0 ? fromOffset - 1 :\n          sortedFiles.get(sortedFiles.firstKey()).getModificationTime();\n\n        List<Path> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n        for (Map.Entry<Long, FileStatus> entry : sortedFiles.entrySet()){\n          if (entry.getKey() <= fromTimeMs) {\n            tailFiles.add(entry.getValue().getPath());\n          }\n        }\n\n        List<ILoggingEvent> loggingEvents = Lists.newLinkedList();\n        AvroFileLogReader logReader = new AvroFileLogReader(hConf, schema);\n        for (Path file : tailFiles) {\n          Collection<ILoggingEvent> events = logReader.readLogPrev(file, logFilter, fromTimeMs,\n                                                                   maxEvents - loggingEvents.size());\n          loggingEvents.addAll(0, events);\n          if (events.size() >= maxEvents) {\n            break;\n          }\n        }\n\n        callback.init();\n        // TODO: better algorithm to read previous events\n        for (ILoggingEvent event : loggingEvents) {\n          callback.handle(new LogEvent(event, event.getTimeStamp()));\n        }\n        callback.close();\n      }\n    });\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Future<?> getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (fromOffset < 0) {\n      return getLogPrev(loggingContext, -1, maxEvents, filter, callback);\n    }\n\n    return executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          long fromTimeMs = fromOffset + 1;\n          SortedMap<Long, FileStatus> sortedFiles = getFiles(null);\n          if (sortedFiles.isEmpty()) {\n            return;\n          }\n\n          long prevInterval = -1;\n          Path prevPath = null;\n          List<Path> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n          for (Map.Entry<Long, FileStatus> entry : sortedFiles.entrySet()){\n            if (entry.getKey() >= fromTimeMs && prevPath != null) {\n              tailFiles.add(prevPath);\n            }\n            prevInterval = entry.getKey();\n            prevPath = entry.getValue().getPath();\n          }\n\n          if (prevInterval != -1) {\n            tailFiles.add(prevPath);\n          }\n\n          callback.init();\n          final List<ILoggingEvent> loggingEvents = Lists.newLinkedList();\n          AvroFileLogReader logReader = new AvroFileLogReader(hConf, schema);\n          for (Path file : tailFiles) {\n            logReader.readLog(file, logFilter, fromTimeMs, Long.MAX_VALUE, maxEvents - loggingEvents.size(), callback);\n            if (loggingEvents.size() >= maxEvents) {\n              break;\n            }\n          }\n          callback.close();\n        }\n      }\n    );\n  }","id":45047,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (fromOffset < 0) {\n      getLogPrev(loggingContext, -1, maxEvents, filter, callback);\n    }\n\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          long fromTimeMs = fromOffset + 1;\n          SortedMap<Long, FileStatus> sortedFiles = getFiles(null);\n          if (sortedFiles.isEmpty()) {\n            return;\n          }\n\n          long prevInterval = -1;\n          Path prevPath = null;\n          List<Path> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n          for (Map.Entry<Long, FileStatus> entry : sortedFiles.entrySet()){\n            if (entry.getKey() >= fromTimeMs && prevPath != null) {\n              tailFiles.add(prevPath);\n            }\n            prevInterval = entry.getKey();\n            prevPath = entry.getValue().getPath();\n          }\n\n          if (prevInterval != -1) {\n            tailFiles.add(prevPath);\n          }\n\n          callback.init();\n          final List<ILoggingEvent> loggingEvents = Lists.newLinkedList();\n          AvroFileLogReader logReader = new AvroFileLogReader(hConf, schema);\n          for (Path file : tailFiles) {\n            logReader.readLog(file, logFilter, fromTimeMs, Long.MAX_VALUE, maxEvents - loggingEvents.size(), callback);\n            if (loggingEvents.size() >= maxEvents) {\n              break;\n            }\n          }\n          callback.close();\n        }\n      }\n    );\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Future<?> getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    return executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          SortedMap<Long, FileStatus> sortedFiles = getFiles(null);\n          if (sortedFiles.isEmpty()) {\n            return;\n          }\n\n          long prevInterval = -1;\n          Path prevPath = null;\n          List<Path> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n          for (Map.Entry<Long, FileStatus> entry : sortedFiles.entrySet()){\n            if (entry.getKey() >= fromTimeMs && entry.getKey() < toTimeMs && prevPath != null) {\n              files.add(prevPath);\n            }\n            prevInterval = entry.getKey();\n            prevPath = entry.getValue().getPath();\n          }\n\n          if (prevInterval != -1) {\n            files.add(prevPath);\n          }\n\n          callback.init();\n          AvroFileLogReader avroFileLogReader = new AvroFileLogReader(hConf, schema);\n          for (Path file : files) {\n            avroFileLogReader.readLog(file, logFilter, fromTimeMs, toTimeMs, Integer.MAX_VALUE, callback);\n          }\n          callback.close();\n        }\n      }\n    );\n  }","id":45048,"modified_method":"@Override\n  public void getLog(final LoggingContext loggingContext, final long fromTimeMs, final long toTimeMs,\n                          final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext), filter));\n          SortedMap<Long, FileStatus> sortedFiles = getFiles(null);\n          if (sortedFiles.isEmpty()) {\n            return;\n          }\n\n          long prevInterval = -1;\n          Path prevPath = null;\n          List<Path> files = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n          for (Map.Entry<Long, FileStatus> entry : sortedFiles.entrySet()){\n            if (entry.getKey() >= fromTimeMs && entry.getKey() < toTimeMs && prevPath != null) {\n              files.add(prevPath);\n            }\n            prevInterval = entry.getKey();\n            prevPath = entry.getValue().getPath();\n          }\n\n          if (prevInterval != -1) {\n            files.add(prevPath);\n          }\n\n          callback.init();\n          AvroFileLogReader avroFileLogReader = new AvroFileLogReader(hConf, schema);\n          for (Path file : files) {\n            avroFileLogReader.readLog(file, logFilter, fromTimeMs, toTimeMs, Integer.MAX_VALUE, callback);\n          }\n          callback.close();\n        }\n      }\n    );\n  }","commit_id":"bb982a203fd7235c67bca7bb7a1ed55fcce1d025","url":"https://github.com/caskdata/cdap"},{"original_method":"private void procedureCall(HttpRequest request, final HttpResponder responder,\n                            String appId, String procedureName, String methodName,\n                            byte [] body) {\n\n    try {\n      String accountId = getAuthenticatedAccountId(request);\n\n      // determine the service provider for the given path\n      String serviceName = String.format(\"procedure.%s.%s.%s\", accountId, appId, procedureName);\n      List<Discoverable> endpoints = Lists.newArrayList(discoveryServiceClient.discover(serviceName));\n      if (endpoints.isEmpty()) {\n        LOG.trace(\"No endpoint for service {}\", serviceName);\n        responder.sendStatus(NOT_FOUND);\n        return;\n      }\n\n      // make HTTP call to provider\n      Collections.shuffle(endpoints);\n      InetSocketAddress endpoint = endpoints.get(0).getSocketAddress();\n      final String relayUri = Joiner.on('/').appendTo(\n        new StringBuilder(\"http://\").append(endpoint.getHostName()).append(\":\").append(endpoint.getPort()).append(\"/\"),\n        \"apps\", appId, \"procedures\", procedureName, methodName).toString();\n\n      LOG.trace(\"Relaying request to \" + relayUri);\n\n      // Construct request\n      RequestBuilder requestBuilder = new RequestBuilder(\"POST\");\n      requestBuilder.setUrl(relayUri);\n\n      if (body != null) {\n        requestBuilder.setBody(body);\n      }\n\n      // Add headers\n      for (Map.Entry<String, String> entry : request.getHeaders()) {\n        requestBuilder.addHeader(entry.getKey(), entry.getValue());\n      }\n\n      Request postRequest = requestBuilder.build();\n      asyncHttpClient.executeRequest(postRequest,\n                                     new AsyncCompletionHandler<Void>() {\n                                       @Override\n                                       public Void onCompleted(Response response) throws Exception {\n                                         if (response.getStatusCode() == OK.getCode()) {\n                                           String contentType = response.getContentType();\n                                           ChannelBuffer content;\n\n                                           int contentLength = getContentLength(response);\n                                           if (contentLength > 0) {\n                                             content = ChannelBuffers.dynamicBuffer(contentLength);\n                                           } else {\n                                             // the transfer encoding is usually chunked, so no content length is\n                                             // provided. Just trying to read anything\n                                             content = ChannelBuffers.dynamicBuffer();\n                                           }\n\n                                           // Should not close the inputstream as per Response javadoc\n                                           InputStream input = response.getResponseBodyAsStream();\n                                           ByteStreams.copy(input, new ChannelBufferOutputStream(content));\n\n                                           // Copy headers\n                                           ImmutableListMultimap.Builder<String, String> headerBuilder =\n                                             ImmutableListMultimap.builder();\n                                           for (Map.Entry<String, List<String>> entry : response.getHeaders()) {\n                                             headerBuilder.putAll(entry.getKey(), entry.getValue());\n                                           }\n\n                                           responder.sendContent(OK,\n                                                                 content,\n                                                                 contentType,\n                                                                 headerBuilder.build());\n                                         } else {\n                                           responder.sendStatus(HttpResponseStatus.valueOf(response.getStatusCode()));\n                                         }\n                                         return null;\n                                       }\n\n                                       @Override\n                                       public void onThrowable(Throwable t) {\n                                         LOG.trace(\"Got exception while posting {}\", relayUri, t);\n                                         responder.sendStatus(INTERNAL_SERVER_ERROR);\n                                       }\n                                     });\n    } catch (SecurityException e) {\n      responder.sendStatus(FORBIDDEN);\n    } catch (IllegalArgumentException e) {\n      responder.sendStatus(BAD_REQUEST);\n    }  catch (Throwable e) {\n      responder.sendStatus(INTERNAL_SERVER_ERROR);\n    }\n  }","id":45049,"modified_method":"private void procedureCall(HttpRequest request, final HttpResponder responder,\n                            String appId, String procedureName, String methodName,\n                            byte [] body) {\n\n    try {\n      String accountId = getAuthenticatedAccountId(request);\n\n      // determine the service provider for the given path\n      String serviceName = String.format(\"procedure.%s.%s.%s\", accountId, appId, procedureName);\n      List<Discoverable> endpoints = Lists.newArrayList(discoveryServiceClient.discover(serviceName));\n      if (endpoints.isEmpty()) {\n        LOG.trace(\"No endpoint for service {}\", serviceName);\n        responder.sendStatus(NOT_FOUND);\n        return;\n      }\n\n      // make HTTP call to provider\n      Collections.shuffle(endpoints);\n      InetSocketAddress endpoint = endpoints.get(0).getSocketAddress();\n      final String relayUri = Joiner.on('/').appendTo(\n        new StringBuilder(\"http://\").append(endpoint.getHostName()).append(\":\").append(endpoint.getPort()).append(\"/\"),\n        \"apps\", appId, \"procedures\", procedureName, methodName).toString();\n\n      LOG.trace(\"Relaying request to \" + relayUri);\n\n      // Construct request\n      RequestBuilder requestBuilder = new RequestBuilder(\"POST\");\n      requestBuilder.setUrl(relayUri);\n\n      if (body != null) {\n        requestBuilder.setBody(body);\n      }\n\n      // Add headers\n      for (Map.Entry<String, String> entry : request.getHeaders()) {\n        requestBuilder.addHeader(entry.getKey(), entry.getValue());\n      }\n\n      Request postRequest = requestBuilder.build();\n      asyncHttpClient.executeRequest(postRequest,\n                                     new AsyncCompletionHandler<Void>() {\n                                       @Override\n                                       public Void onCompleted(Response response) throws Exception {\n                                         if (response.getStatusCode() == OK.getCode()) {\n                                           String contentType = response.getContentType();\n                                           ChannelBuffer content;\n\n                                           int contentLength = getContentLength(response);\n                                           if (contentLength > 0) {\n                                             content = ChannelBuffers.dynamicBuffer(contentLength);\n                                           } else {\n                                             // the transfer encoding is usually chunked, so no content length is\n                                             // provided. Just trying to read anything\n                                             content = ChannelBuffers.dynamicBuffer();\n                                           }\n\n                                           // Should not close the inputstream as per Response javadoc\n                                           InputStream input = response.getResponseBodyAsStream();\n                                           ByteStreams.copy(input, new ChannelBufferOutputStream(content));\n\n                                           // Copy headers\n                                           ImmutableListMultimap.Builder<String, String> headerBuilder =\n                                             ImmutableListMultimap.builder();\n                                           for (Map.Entry<String, List<String>> entry : response.getHeaders()) {\n                                             headerBuilder.putAll(entry.getKey(), entry.getValue());\n                                           }\n\n                                           responder.sendContent(OK,\n                                                                 content,\n                                                                 contentType,\n                                                                 headerBuilder.build());\n                                         } else {\n                                           responder.sendStatus(HttpResponseStatus.valueOf(response.getStatusCode()));\n                                         }\n                                         return null;\n                                       }\n\n                                       @Override\n                                       public void onThrowable(Throwable t) {\n                                         LOG.trace(\"Got exception while posting {}\", relayUri, t);\n                                         responder.sendStatus(INTERNAL_SERVER_ERROR);\n                                       }\n                                     });\n    } catch (SecurityException e) {\n      responder.sendStatus(FORBIDDEN);\n    } catch (IllegalArgumentException e) {\n      responder.sendStatus(BAD_REQUEST);\n    }  catch (Throwable e) {\n      LOG.error(\"Caught exception\", e);\n      responder.sendStatus(INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"2c0daf2ad4274574949ae4742efce75c68a42c30","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetProcedureCall() throws Exception {\n    Map<String, String> content = ImmutableMap.of(\"key1\", \"val1\", \"key3\", \"val3\");\n    Type type = new TypeToken<Map<String, String>>() {}.getType();\n    Gson gson = new Gson();\n\n    HttpResponse response =\n      GET(\"/v2/apps/testApp1/procedures/testProc1/methods/testMethod1?\" + getQueryParams(content),\n          new Header[]{new BasicHeader(\"X-Test\", \"1234\")});\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), response.getStatusLine().getStatusCode());\n\n    String responseStr = EntityUtils.toString(response.getEntity());\n    Assert.assertEquals(content, gson.fromJson(responseStr, type));\n    Assert.assertEquals(\"1234\", response.getFirstHeader(\"X-Test\").getValue());\n  }","id":45050,"modified_method":"@Test\n  public void testGetProcedureCall() throws Exception {\n    Map<String, String> content = ImmutableMap.of(\"key1&\", \"val1=\", \"key3\", \"\\\"val3\\\"\");\n    Type type = new TypeToken<Map<String, String>>() {}.getType();\n    Gson gson = new Gson();\n\n    HttpResponse response =\n      GET(\"/v2/apps/testApp1/procedures/testProc1/methods/testMethod1?\" + getQueryParams(content),\n          new Header[]{new BasicHeader(\"X-Test\", \"1234\")});\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), response.getStatusLine().getStatusCode());\n\n    String responseStr = EntityUtils.toString(response.getEntity());\n    Assert.assertEquals(content, gson.fromJson(responseStr, type));\n    Assert.assertEquals(\"1234\", response.getFirstHeader(\"X-Test\").getValue());\n  }","commit_id":"2c0daf2ad4274574949ae4742efce75c68a42c30","url":"https://github.com/caskdata/cdap"},{"original_method":"private String getQueryParams(Map<String, String> params) {\n    List<String> plist = Lists.newArrayList();\n    for (Map.Entry<String, String> entry : params.entrySet()) {\n      plist.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n    }\n    return Joiner.on(\"&\").join(plist);\n  }","id":45051,"modified_method":"private String getQueryParams(Map<String, String> params) throws Exception {\n    List<String> plist = Lists.newArrayList();\n    for (Map.Entry<String, String> entry : params.entrySet()) {\n      plist.add(String.format(\"%s=%s\", URLEncoder.encode(entry.getKey(), \"utf-8\"),\n                              URLEncoder.encode(entry.getValue(), \"utf-8\")));\n    }\n    return Joiner.on(\"&\").join(plist);\n  }","commit_id":"2c0daf2ad4274574949ae4742efce75c68a42c30","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Method to export all the metrics.\n   *\n   * @param metricsBuilder Builder to accept metrics\n   * @param all            push all or only changed?\n   */\n  @Override\n  public void getMetrics(MetricsBuilder metricsBuilder, boolean all) {\n\n    MetricsRecordBuilder metricsRecordBuilder = metricsBuilder.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    // masterWrapper can be null because this function is called inside of init.\n    if (masterWrapper != null) {\n      metricsRecordBuilder\n          .addGauge(MASTER_ACTIVE_TIME_NAME,\n              MASTER_ACTIVE_TIME_DESC, masterWrapper.getActiveTime())\n          .addGauge(MASTER_START_TIME_NAME,\n              MASTER_START_TIME_DESC, masterWrapper.getStartTime())\n          .addGauge(AVERAGE_LOAD_NAME, AVERAGE_LOAD_DESC, masterWrapper.getAverageLoad())\n          .addGauge(NUM_REGION_SERVERS_NAME,\n              NUMBER_OF_REGION_SERVERS_DESC, masterWrapper.getRegionServers())\n          .addGauge(NUM_DEAD_REGION_SERVERS_NAME,\n              NUMBER_OF_DEAD_REGION_SERVERS_DESC,\n              masterWrapper.getDeadRegionServers())\n          .tag(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC, masterWrapper.getZookeeperQuorum())\n          .tag(SERVER_NAME_NAME, SERVER_NAME_DESC, masterWrapper.getServerName())\n          .tag(CLUSTER_ID_NAME, CLUSTER_ID_DESC, masterWrapper.getClusterId())\n          .tag(IS_ACTIVE_MASTER_NAME,\n              IS_ACTIVE_MASTER_DESC,\n              String.valueOf(masterWrapper.getIsActiveMaster()));\n    }\n\n    metricsRegistry.snapshot(metricsRecordBuilder, all);\n  }","id":45052,"modified_method":"/**\n   * Method to export all the metrics.\n   *\n   * @param metricsBuilder Builder to accept metrics\n   * @param all            push all or only changed?\n   */\n  @Override\n  public void getMetrics(MetricsBuilder metricsBuilder, boolean all) {\n\n    MetricsRecordBuilder metricsRecordBuilder = metricsBuilder.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    // masterWrapper can be null because this function is called inside of init.\n    if (masterWrapper != null) {\n      metricsRecordBuilder\n          .addGauge(MASTER_ACTIVE_TIME_NAME,\n              MASTER_ACTIVE_TIME_DESC, masterWrapper.getActiveTime())\n          .addGauge(MASTER_START_TIME_NAME,\n              MASTER_START_TIME_DESC, masterWrapper.getStartTime())\n          .addGauge(AVERAGE_LOAD_NAME, AVERAGE_LOAD_DESC, masterWrapper.getAverageLoad())\n          .tag(LIVE_REGION_SERVERS_NAME, LIVE_REGION_SERVERS_DESC,\n                masterWrapper.getRegionServers())\n          .addGauge(NUM_REGION_SERVERS_NAME,\n              NUMBER_OF_REGION_SERVERS_DESC, masterWrapper.getNumRegionServers())\n          .tag(DEAD_REGION_SERVERS_NAME, DEAD_REGION_SERVERS_DESC,\n                masterWrapper.getDeadRegionServers())\n          .addGauge(NUM_DEAD_REGION_SERVERS_NAME,\n              NUMBER_OF_DEAD_REGION_SERVERS_DESC,\n              masterWrapper.getNumDeadRegionServers())\n          .tag(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC, masterWrapper.getZookeeperQuorum())\n          .tag(SERVER_NAME_NAME, SERVER_NAME_DESC, masterWrapper.getServerName())\n          .tag(CLUSTER_ID_NAME, CLUSTER_ID_DESC, masterWrapper.getClusterId())\n          .tag(IS_ACTIVE_MASTER_NAME,\n              IS_ACTIVE_MASTER_DESC,\n              String.valueOf(masterWrapper.getIsActiveMaster()));\n    }\n\n    metricsRegistry.snapshot(metricsRecordBuilder, all);\n  }","commit_id":"fb349b084e41131d5f07dd0db6e60a414282420d","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n\n    MetricsRecordBuilder metricsRecordBuilder = metricsCollector.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    // masterWrapper can be null because this function is called inside of init.\n    if (masterWrapper != null) {\n      metricsRecordBuilder\n          .addGauge(Interns.info(MASTER_ACTIVE_TIME_NAME,\n              MASTER_ACTIVE_TIME_DESC), masterWrapper.getActiveTime())\n          .addGauge(Interns.info(MASTER_START_TIME_NAME,\n              MASTER_START_TIME_DESC), masterWrapper.getStartTime())\n          .addGauge(Interns.info(AVERAGE_LOAD_NAME, AVERAGE_LOAD_DESC),\n              masterWrapper.getAverageLoad())\n          .addGauge(Interns.info(NUM_REGION_SERVERS_NAME,\n              NUMBER_OF_REGION_SERVERS_DESC), masterWrapper.getRegionServers())\n          .addGauge(Interns.info(NUM_DEAD_REGION_SERVERS_NAME,\n              NUMBER_OF_DEAD_REGION_SERVERS_DESC),\n              masterWrapper.getDeadRegionServers())\n          .tag(Interns.info(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC),\n              masterWrapper.getZookeeperQuorum())\n          .tag(Interns.info(SERVER_NAME_NAME, SERVER_NAME_DESC), masterWrapper.getServerName())\n          .tag(Interns.info(CLUSTER_ID_NAME, CLUSTER_ID_DESC), masterWrapper.getClusterId())\n          .tag(Interns.info(IS_ACTIVE_MASTER_NAME,\n              IS_ACTIVE_MASTER_DESC),\n              String.valueOf(masterWrapper.getIsActiveMaster()));\n    }\n\n    metricsRegistry.snapshot(metricsRecordBuilder, all);\n  }","id":45053,"modified_method":"@Override\n  public void getMetrics(MetricsCollector metricsCollector, boolean all) {\n\n    MetricsRecordBuilder metricsRecordBuilder = metricsCollector.addRecord(metricsName)\n        .setContext(metricsContext);\n\n    // masterWrapper can be null because this function is called inside of init.\n    if (masterWrapper != null) {\n      metricsRecordBuilder\n          .addGauge(Interns.info(MASTER_ACTIVE_TIME_NAME,\n              MASTER_ACTIVE_TIME_DESC), masterWrapper.getActiveTime())\n          .addGauge(Interns.info(MASTER_START_TIME_NAME,\n              MASTER_START_TIME_DESC), masterWrapper.getStartTime())\n          .addGauge(Interns.info(AVERAGE_LOAD_NAME, AVERAGE_LOAD_DESC),\n              masterWrapper.getAverageLoad())\n          .tag(Interns.info(LIVE_REGION_SERVERS_NAME, LIVE_REGION_SERVERS_DESC),\n                masterWrapper.getRegionServers())\n          .addGauge(Interns.info(NUM_REGION_SERVERS_NAME,\n              NUMBER_OF_REGION_SERVERS_DESC), masterWrapper.getNumRegionServers())\n          .tag(Interns.info(DEAD_REGION_SERVERS_NAME, DEAD_REGION_SERVERS_DESC),\n                masterWrapper.getDeadRegionServers())\n          .addGauge(Interns.info(NUM_DEAD_REGION_SERVERS_NAME,\n              NUMBER_OF_DEAD_REGION_SERVERS_DESC),\n              masterWrapper.getNumDeadRegionServers())\n          .tag(Interns.info(ZOOKEEPER_QUORUM_NAME, ZOOKEEPER_QUORUM_DESC),\n              masterWrapper.getZookeeperQuorum())\n          .tag(Interns.info(SERVER_NAME_NAME, SERVER_NAME_DESC), masterWrapper.getServerName())\n          .tag(Interns.info(CLUSTER_ID_NAME, CLUSTER_ID_DESC), masterWrapper.getClusterId())\n          .tag(Interns.info(IS_ACTIVE_MASTER_NAME,\n              IS_ACTIVE_MASTER_DESC),\n              String.valueOf(masterWrapper.getIsActiveMaster()));\n    }\n\n    metricsRegistry.snapshot(metricsRecordBuilder, all);\n  }","commit_id":"fb349b084e41131d5f07dd0db6e60a414282420d","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int getDeadRegionServers() {\n    ServerManager serverManager = this.master.getServerManager();\n    if (serverManager == null) {\n      return 0;\n    }\n    return serverManager.getDeadServers().size();\n  }","id":45054,"modified_method":"@Override\n  public String getDeadRegionServers() {\n    ServerManager serverManager = this.master.getServerManager();\n    if (serverManager == null) {\n      return \"\";\n    }\n    return StringUtils.join(serverManager.getDeadServers().copyServerNames(), \";\");\n  }","commit_id":"fb349b084e41131d5f07dd0db6e60a414282420d","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int getRegionServers() {\n    ServerManager serverManager = this.master.getServerManager();\n    if (serverManager == null) {\n      return 0;\n    }\n    return serverManager.getOnlineServers().size();\n  }","id":45055,"modified_method":"@Override\n  public String getRegionServers() {\n    ServerManager serverManager = this.master.getServerManager();\n    if (serverManager == null) {\n      return \"\";\n    }\n    return StringUtils.join(serverManager.getOnlineServers().keySet(), \";\");\n  }","commit_id":"fb349b084e41131d5f07dd0db6e60a414282420d","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout = 30000)\n  public void testInfo() {\n    HMaster master = TEST_UTIL.getHBaseCluster().getMaster();\n    MetricsMasterWrapperImpl info = new MetricsMasterWrapperImpl(master);\n    assertEquals(master.getAverageLoad(), info.getAverageLoad(), 0);\n    assertEquals(master.getClusterId(), info.getClusterId());\n    assertEquals(master.getMasterActiveTime(), info.getActiveTime());\n    assertEquals(master.getMasterStartTime(), info.getStartTime());\n    assertEquals(master.getCoprocessors().length, info.getCoprocessors().length);\n    assertEquals(master.getServerManager().getOnlineServersList().size(), info.getRegionServers());\n    assertTrue(info.getRegionServers() == 4);\n\n    String zkServers = info.getZookeeperQuorum();\n    assertEquals(zkServers.split(\",\").length, TEST_UTIL.getZkCluster().getZooKeeperServerNum());\n\n    final int index = 3;\n    LOG.info(\"Stopping \" + TEST_UTIL.getMiniHBaseCluster().getRegionServer(index));\n    TEST_UTIL.getMiniHBaseCluster().stopRegionServer(index, false);\n    TEST_UTIL.getMiniHBaseCluster().waitOnRegionServer(index);\n    // We stopped the regionserver but could take a while for the master to notice it so hang here\n    // until it does... then move forward to see if metrics wrapper notices.\n    while (TEST_UTIL.getHBaseCluster().getMaster().getServerManager().getOnlineServers().size() !=\n        index) {\n      Threads.sleep(10);\n    }\n    assertTrue(info.getRegionServers() == 3);\n    assertTrue(info.getDeadRegionServers() == 1);\n  }","id":45056,"modified_method":"@Test (timeout = 30000)\n  public void testInfo() {\n    HMaster master = TEST_UTIL.getHBaseCluster().getMaster();\n    MetricsMasterWrapperImpl info = new MetricsMasterWrapperImpl(master);\n    assertEquals(master.getAverageLoad(), info.getAverageLoad(), 0);\n    assertEquals(master.getClusterId(), info.getClusterId());\n    assertEquals(master.getMasterActiveTime(), info.getActiveTime());\n    assertEquals(master.getMasterStartTime(), info.getStartTime());\n    assertEquals(master.getCoprocessors().length, info.getCoprocessors().length);\n    assertEquals(master.getServerManager().getOnlineServersList().size(), info.getNumRegionServers());\n    assertTrue(info.getNumRegionServers() == 4);\n\n    String zkServers = info.getZookeeperQuorum();\n    assertEquals(zkServers.split(\",\").length, TEST_UTIL.getZkCluster().getZooKeeperServerNum());\n\n    final int index = 3;\n    LOG.info(\"Stopping \" + TEST_UTIL.getMiniHBaseCluster().getRegionServer(index));\n    TEST_UTIL.getMiniHBaseCluster().stopRegionServer(index, false);\n    TEST_UTIL.getMiniHBaseCluster().waitOnRegionServer(index);\n    // We stopped the regionserver but could take a while for the master to notice it so hang here\n    // until it does... then move forward to see if metrics wrapper notices.\n    while (TEST_UTIL.getHBaseCluster().getMaster().getServerManager().getOnlineServers().size() !=\n        index) {\n      Threads.sleep(10);\n    }\n    assertTrue(info.getNumRegionServers() == 3);\n    assertTrue(info.getNumDeadRegionServers() == 1);\n  }","commit_id":"fb349b084e41131d5f07dd0db6e60a414282420d","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Starts the execution of the neomedia bundle in the specified context.\n     *\n     * @param bundleContext the context in which the neomedia bundle is to start\n     * executing\n     * @throws Exception if an error occurs while starting the execution of the\n     * neomedia bundle in the specified context\n     */\n    public void start(BundleContext bundleContext)\n        throws Exception\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"Started.\");\n\n        NeomediaActivator.bundleContext = bundleContext;\n\n        // MediaService\n        mediaServiceImpl = (MediaServiceImpl) LibJitsi.getMediaService();\n\n        bundleContext.registerService(\n                MediaService.class.getName(),\n                mediaServiceImpl,\n                null);\n        if (logger.isDebugEnabled())\n            logger.debug(\"Media Service ... [REGISTERED]\");\n        \n        mediaConfiguration = new MediaConfigurationImpl();\n        bundleContext.registerService(\n                MediaConfigurationService.class.getName(),\n                getMediaConfiguration(),\n                null);\n        if (logger.isDebugEnabled())\n            logger.debug(\"Media Configuration ... [REGISTERED]\");\n        \n        ConfigurationService cfg = NeomediaActivator.getConfigurationService();\n        Dictionary<String, String> mediaProps = new Hashtable<String, String>();\n\n        mediaProps.put( ConfigurationForm.FORM_TYPE,\n                        ConfigurationForm.GENERAL_TYPE);\n\n        // If the audio configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(AUDIO_CONFIG_DISABLED_PROP, false))\n        {\n            final ConfigurationForm audioConfigurationForm\n                = new LazyConfigurationForm(\n                        AudioConfigurationPanel.class.getName(),\n                        getClass().getClassLoader(),\n                        \"plugin.mediaconfig.AUDIO_ICON\",\n                        \"impl.neomedia.configform.AUDIO\",\n                        3);\n\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    audioConfigurationForm,\n                    mediaProps);\n\n            if (deviceConfigurationPropertyChangeListener == null)\n            {\n                deviceConfigurationPropertyChangeListener\n                    = new PropertyChangeListener()\n                    {\n                        public void propertyChange(PropertyChangeEvent event)\n                        {\n                            if (DeviceConfiguration.PROP_AUDIO_SYSTEM_DEVICES\n                                    .equals(event.getPropertyName()))\n                            {\n                                showAudioConfiguration();\n                            }\n                        }\n                    };\n                mediaServiceImpl\n                    .getDeviceConfiguration()\n                        .addPropertyChangeListener(\n                                deviceConfigurationPropertyChangeListener);\n            }\n        }\n\n        // If the video configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(VIDEO_CONFIG_DISABLED_PROP, false))\n        {\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                            VideoConfigurationPanel.class.getName(),\n                            getClass().getClassLoader(),\n                            \"plugin.mediaconfig.VIDEO_ICON\",\n                            \"impl.neomedia.configform.VIDEO\",\n                            4),\n                    mediaProps);\n        }\n\n        // H.264\n        // If the H.264 configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(H264_CONFIG_DISABLED_PROP, false))\n        {\n            Dictionary<String, String> h264Props\n                = new Hashtable<String, String>();\n\n            h264Props.put(\n                    ConfigurationForm.FORM_TYPE,\n                    ConfigurationForm.ADVANCED_TYPE);\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                            ConfigurationPanel.class.getName(),\n                            getClass().getClassLoader(),\n                            \"plugin.mediaconfig.VIDEO_ICON\",\n                            \"impl.neomedia.configform.H264\",\n                            -1,\n                            true),\n                    h264Props);\n        }\n\n        // ZRTP\n        // If the ZRTP configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(ZRTP_CONFIG_DISABLED_PROP, false))\n        {\n            Dictionary<String, String> securityProps\n                = new Hashtable<String, String>();\n\n            securityProps.put( ConfigurationForm.FORM_TYPE,\n                            ConfigurationForm.SECURITY_TYPE);\n            bundleContext.registerService(\n                ConfigurationForm.class.getName(),\n                new LazyConfigurationForm(\n                    SecurityConfigForm.class.getName(),\n                    getClass().getClassLoader(),\n                    \"impl.media.security.zrtp.CONF_ICON\",\n                    \"impl.media.security.zrtp.TITLE\",\n                    0),\n                securityProps);\n        }\n\n        //we use the nist-sdp stack to make parse sdp and we need to set the\n        //following property to make sure that it would accept java generated\n        //IPv6 addresses that contain address scope zones.\n        System.setProperty(\"gov.nist.core.STRIP_ADDR_SCOPES\", \"true\");\n\n        // AudioNotifierService\n        AudioNotifierService audioNotifierService\n            = LibJitsi.getAudioNotifierService();\n\n        audioNotifierService.setMute(\n                (cfg == null)\n                    || !cfg.getBoolean(\n                            \"net.java.sip.communicator\"\n                                + \".impl.sound.isSoundEnabled\",\n                            true));\n        bundleContext.registerService(\n                AudioNotifierService.class.getName(),\n                audioNotifierService,\n                null);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"Audio Notifier Service ...[REGISTERED]\");\n\n        // Call Recording\n        // If the call recording configuration form is disabled don't continue.\n        if ((cfg == null)\n                || !cfg.getBoolean(CALL_RECORDING_CONFIG_DISABLED_PROP, false))\n        {\n            Dictionary<String, String> callRecordingProps\n                = new Hashtable<String, String>();\n\n            callRecordingProps.put(\n                    ConfigurationForm.FORM_TYPE,\n                    ConfigurationForm.ADVANCED_TYPE);\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                            CallRecordingConfigForm.class.getName(),\n                            getClass().getClassLoader(),\n                            null,\n                            \"plugin.callrecordingconfig.CALL_RECORDING_CONFIG\", \n                            1100,\n                            true), \n                    callRecordingProps);\n        }\n    }","id":45057,"modified_method":"/**\n     * Starts the execution of the neomedia bundle in the specified context.\n     *\n     * @param bundleContext the context in which the neomedia bundle is to start\n     * executing\n     * @throws Exception if an error occurs while starting the execution of the\n     * neomedia bundle in the specified context\n     */\n    public void start(BundleContext bundleContext)\n        throws Exception\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"Started.\");\n\n        NeomediaActivator.bundleContext = bundleContext;\n\n        // MediaService\n        mediaServiceImpl = (MediaServiceImpl) LibJitsi.getMediaService();\n\n        bundleContext.registerService(\n                MediaService.class.getName(),\n                mediaServiceImpl,\n                null);\n        if (logger.isDebugEnabled())\n            logger.debug(\"Media Service ... [REGISTERED]\");\n        \n        mediaConfiguration = new MediaConfigurationImpl();\n        bundleContext.registerService(\n                MediaConfigurationService.class.getName(),\n                getMediaConfiguration(),\n                null);\n        if (logger.isDebugEnabled())\n            logger.debug(\"Media Configuration ... [REGISTERED]\");\n        \n        ConfigurationService cfg = NeomediaActivator.getConfigurationService();\n        Dictionary<String, String> mediaProps = new Hashtable<String, String>();\n\n        mediaProps.put( ConfigurationForm.FORM_TYPE,\n                        ConfigurationForm.GENERAL_TYPE);\n\n        // If the audio configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(AUDIO_CONFIG_DISABLED_PROP, false))\n        {\n            audioConfigurationForm\n                = new LazyConfigurationForm(\n                        AudioConfigurationPanel.class.getName(),\n                        getClass().getClassLoader(),\n                        \"plugin.mediaconfig.AUDIO_ICON\",\n                        \"impl.neomedia.configform.AUDIO\",\n                        3);\n\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    audioConfigurationForm,\n                    mediaProps);\n\n            if (deviceConfigurationPropertyChangeListener == null)\n            {\n                // Initializes and registers the changed device configuration\n                // event ot the notification service.\n                getNotificationService();\n\n                deviceConfigurationPropertyChangeListener\n                    = new AudioDeviceConfigurationListener();\n                mediaServiceImpl\n                    .getDeviceConfiguration()\n                        .addPropertyChangeListener(\n                                deviceConfigurationPropertyChangeListener);\n            }\n        }\n\n        // If the video configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(VIDEO_CONFIG_DISABLED_PROP, false))\n        {\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                            VideoConfigurationPanel.class.getName(),\n                            getClass().getClassLoader(),\n                            \"plugin.mediaconfig.VIDEO_ICON\",\n                            \"impl.neomedia.configform.VIDEO\",\n                            4),\n                    mediaProps);\n        }\n\n        // H.264\n        // If the H.264 configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(H264_CONFIG_DISABLED_PROP, false))\n        {\n            Dictionary<String, String> h264Props\n                = new Hashtable<String, String>();\n\n            h264Props.put(\n                    ConfigurationForm.FORM_TYPE,\n                    ConfigurationForm.ADVANCED_TYPE);\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                            ConfigurationPanel.class.getName(),\n                            getClass().getClassLoader(),\n                            \"plugin.mediaconfig.VIDEO_ICON\",\n                            \"impl.neomedia.configform.H264\",\n                            -1,\n                            true),\n                    h264Props);\n        }\n\n        // ZRTP\n        // If the ZRTP configuration form is disabled don't register it.\n        if ((cfg == null) || !cfg.getBoolean(ZRTP_CONFIG_DISABLED_PROP, false))\n        {\n            Dictionary<String, String> securityProps\n                = new Hashtable<String, String>();\n\n            securityProps.put( ConfigurationForm.FORM_TYPE,\n                            ConfigurationForm.SECURITY_TYPE);\n            bundleContext.registerService(\n                ConfigurationForm.class.getName(),\n                new LazyConfigurationForm(\n                    SecurityConfigForm.class.getName(),\n                    getClass().getClassLoader(),\n                    \"impl.media.security.zrtp.CONF_ICON\",\n                    \"impl.media.security.zrtp.TITLE\",\n                    0),\n                securityProps);\n        }\n\n        //we use the nist-sdp stack to make parse sdp and we need to set the\n        //following property to make sure that it would accept java generated\n        //IPv6 addresses that contain address scope zones.\n        System.setProperty(\"gov.nist.core.STRIP_ADDR_SCOPES\", \"true\");\n\n        // AudioNotifierService\n        AudioNotifierService audioNotifierService\n            = LibJitsi.getAudioNotifierService();\n\n        audioNotifierService.setMute(\n                (cfg == null)\n                    || !cfg.getBoolean(\n                            \"net.java.sip.communicator\"\n                                + \".impl.sound.isSoundEnabled\",\n                            true));\n        bundleContext.registerService(\n                AudioNotifierService.class.getName(),\n                audioNotifierService,\n                null);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"Audio Notifier Service ...[REGISTERED]\");\n\n        // Call Recording\n        // If the call recording configuration form is disabled don't continue.\n        if ((cfg == null)\n                || !cfg.getBoolean(CALL_RECORDING_CONFIG_DISABLED_PROP, false))\n        {\n            Dictionary<String, String> callRecordingProps\n                = new Hashtable<String, String>();\n\n            callRecordingProps.put(\n                    ConfigurationForm.FORM_TYPE,\n                    ConfigurationForm.ADVANCED_TYPE);\n            bundleContext.registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                            CallRecordingConfigForm.class.getName(),\n                            getClass().getClassLoader(),\n                            null,\n                            \"plugin.callrecordingconfig.CALL_RECORDING_CONFIG\", \n                            1100,\n                            true), \n                    callRecordingProps);\n        }\n    }","commit_id":"81c971944b8a28235abc9e277ada7e306388ba53","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops the execution of the neomedia bundle in the specified context.\n     *\n     * @param bundleContext the context in which the neomedia bundle is to stop\n     * executing\n     * @throws Exception if an error occurs while stopping the execution of the\n     * neomedia bundle in the specified context\n     */\n    public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n        try\n        {\n            if (deviceConfigurationPropertyChangeListener != null)\n            {\n                mediaServiceImpl\n                    .getDeviceConfiguration()\n                        .removePropertyChangeListener(\n                                deviceConfigurationPropertyChangeListener);\n                deviceConfigurationPropertyChangeListener = null;\n            }\n        }\n        finally\n        {\n            configurationService = null;\n            fileAccessService = null;\n            mediaServiceImpl = null;\n            resources = null;\n        }\n    }","id":45058,"modified_method":"/**\n     * Stops the execution of the neomedia bundle in the specified context.\n     *\n     * @param bundleContext the context in which the neomedia bundle is to stop\n     * executing\n     * @throws Exception if an error occurs while stopping the execution of the\n     * neomedia bundle in the specified context\n     */\n    public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n        try\n        {\n            if (deviceConfigurationPropertyChangeListener != null)\n            {\n                mediaServiceImpl\n                    .getDeviceConfiguration()\n                        .removePropertyChangeListener(\n                                deviceConfigurationPropertyChangeListener);\n                if(deviceConfigurationPropertyChangeListener != null)\n                {\n                    deviceConfigurationPropertyChangeListener\n                        .managePopupMessageListenerRegistration(false);\n                    deviceConfigurationPropertyChangeListener = null;\n                }\n            }\n        }\n        finally\n        {\n            configurationService = null;\n            fileAccessService = null;\n            mediaServiceImpl = null;\n            resources = null;\n        }\n    }","commit_id":"81c971944b8a28235abc9e277ada7e306388ba53","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void disposeImpl() {\n    if (isTemporaryDisposed()) {\n      super.dispose();\n      return;\n    }\n    MouseGestureManager.getInstance().remove(this);\n    WelcomeFrame.notifyFrameClosed(this);\n\n    if (myRootPane != null) {\n      // clear both our and swing hard refs\n      myRootPane = null;\n      setRootPane(null);\n    }\n\n    if (myFrameDecorator != null) {\n      Disposer.dispose(myFrameDecorator);\n      myFrameDecorator = null;\n    }\n\n    FocusTrackback.release(this);\n\n    super.dispose();\n  }","id":45059,"modified_method":"public void disposeImpl() {\n    if (isTemporaryDisposed()) {\n      super.dispose();\n      return;\n    }\n    MouseGestureManager.getInstance().remove(this);\n    WelcomeFrame.notifyFrameClosed(this);\n\n    if (myRootPane != null) {\n      // clear both our and swing hard refs\n      myRootPane = null;\n      setRootPane(null);\n    }\n\n    if (myFrameDecorator != null) {\n      Disposer.dispose(myFrameDecorator);\n      myFrameDecorator = null;\n    }\n    if (myWindowsBorderUpdater != null) {\n      Toolkit.getDefaultToolkit().removePropertyChangeListener(\"win.xpstyle.themeActive\", myWindowsBorderUpdater);\n    }\n\n    FocusTrackback.release(this);\n\n    super.dispose();\n  }","commit_id":"c5a36e5f7d90fb8921ec8bb33da1d0758ea063ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IdeFrameImpl(ApplicationInfoEx applicationInfoEx,\n                      ActionManagerEx actionManager,\n                      DataManager dataManager,\n                      Application application) {\n    super(applicationInfoEx.getFullApplicationName());\n    myRootPane = createRootPane(actionManager, UISettings.getInstance(), dataManager, application);\n    setRootPane(myRootPane);\n    setBackground(UIUtil.getPanelBackground());\n    AppUIUtil.updateWindowIcon(this);\n    final Dimension size = ScreenUtil.getMainScreenBounds().getSize();\n\n    size.width = Math.min(1400, size.width - 20);\n    size.height= Math.min(1000, size.height - 40);\n\n    setSize(size);\n    setLocationRelativeTo(null);\n\n    LayoutFocusTraversalPolicyExt layoutFocusTraversalPolicy = new LayoutFocusTraversalPolicyExt();\n    setFocusTraversalPolicy(layoutFocusTraversalPolicy);\n\n    setupCloseAction();\n    MnemonicHelper.init(this);\n\n    myBalloonLayout = new BalloonLayoutImpl(myRootPane, new Insets(8, 8, 8, 8));\n\n    // to show window thumbnail under Macs\n    // http://lists.apple.com/archives/java-dev/2009/Dec/msg00240.html\n    if (SystemInfo.isMac) setIconImage(null);\n\n    MouseGestureManager.getInstance().add(this);\n\n    myFrameDecorator = IdeFrameDecorator.decorate(this);\n\n    addWindowStateListener(new WindowAdapter() {\n      @Override\n      public void windowStateChanged(WindowEvent e) {\n        updateBorder();\n      }\n    });\n\n    Toolkit.getDefaultToolkit().addPropertyChangeListener(\"win.xpstyle.themeActive\", new PropertyChangeListener() {\n      @Override\n      public void propertyChange(@NotNull PropertyChangeEvent evt) {\n        updateBorder();\n      }\n    });\n\n    IdeMenuBar.installAppMenuIfNeeded(this);\n\n    // UIUtil.suppressFocusStealing();\n\n  }","id":45060,"modified_method":"public IdeFrameImpl(ApplicationInfoEx applicationInfoEx,\n                      ActionManagerEx actionManager,\n                      DataManager dataManager,\n                      Application application) {\n    super(applicationInfoEx.getFullApplicationName());\n    myRootPane = createRootPane(actionManager, UISettings.getInstance(), dataManager, application);\n    setRootPane(myRootPane);\n    setBackground(UIUtil.getPanelBackground());\n    AppUIUtil.updateWindowIcon(this);\n    final Dimension size = ScreenUtil.getMainScreenBounds().getSize();\n\n    size.width = Math.min(1400, size.width - 20);\n    size.height= Math.min(1000, size.height - 40);\n\n    setSize(size);\n    setLocationRelativeTo(null);\n\n    LayoutFocusTraversalPolicyExt layoutFocusTraversalPolicy = new LayoutFocusTraversalPolicyExt();\n    setFocusTraversalPolicy(layoutFocusTraversalPolicy);\n\n    setupCloseAction();\n    MnemonicHelper.init(this);\n\n    myBalloonLayout = new BalloonLayoutImpl(myRootPane, new Insets(8, 8, 8, 8));\n\n    // to show window thumbnail under Macs\n    // http://lists.apple.com/archives/java-dev/2009/Dec/msg00240.html\n    if (SystemInfo.isMac) setIconImage(null);\n\n    MouseGestureManager.getInstance().add(this);\n\n    myFrameDecorator = IdeFrameDecorator.decorate(this);\n\n    addWindowStateListener(new WindowAdapter() {\n      @Override\n      public void windowStateChanged(WindowEvent e) {\n        updateBorder();\n      }\n    });\n    if (SystemInfo.isWindows) {\n      myWindowsBorderUpdater = new PropertyChangeListener() {\n        @Override\n        public void propertyChange(@NotNull PropertyChangeEvent evt) {\n          updateBorder();\n        }\n      };\n      Toolkit.getDefaultToolkit().addPropertyChangeListener(\"win.xpstyle.themeActive\", myWindowsBorderUpdater);\n    }\n\n    IdeMenuBar.installAppMenuIfNeeded(this);\n\n    // UIUtil.suppressFocusStealing();\n\n  }","commit_id":"c5a36e5f7d90fb8921ec8bb33da1d0758ea063ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showInvalidIndex(boolean plural, List<HashDb> unindexed, String total){\n        String firstMessage = \"\";\n        String secondMessage = \"\";\n        String thirdMessage = \"Unindexed databases successfuly removed from Hash List\";\n       \n        if(plural){\n            firstMessage = \"The following databases are not indexed, would you like to index them now? \\n \" + total;\n            secondMessage = \"Indeces successfully created.\";\n        }\n        else{\n            firstMessage = \"The following database is not indexed, would you like to index it now? \\n\" + total;\n            secondMessage = \"Index successfully created.\";\n        }\n        int res = JOptionPane.showConfirmDialog(this, firstMessage, \"Unindexed databases\", JOptionPane.YES_NO_OPTION);\n        if(res == JOptionPane.YES_OPTION){\n            ModalNoButtons indexingDialog = new ModalNoButtons(new Frame(),unindexed);\n            indexingDialog.setLocationRelativeTo(null);\n            indexingDialog.setVisible(true);\n            indexingDialog.setModal(true);\n           JOptionPane.showMessageDialog(this, secondMessage);\n           hashSetTableModel.resync();\n        }\n        if(res == JOptionPane.NO_OPTION){\n            JOptionPane.showMessageDialog(this, \"All unindexed databases will be removed the list\");\n            removeThese(unindexed);\n            JOptionPane.showMessageDialog(this, thirdMessage);\n        }\n    }","id":45061,"modified_method":"private void showInvalidIndex(boolean plural, List<HashDb> unindexed, String total){\n        String firstMessage = \"\";\n\n       \n        if(plural){\n            firstMessage = \"The following databases are not indexed, would you like to index them now? \\n \" + total;\n        }\n        else{\n            firstMessage = \"The following database is not indexed, would you like to index it now? \\n\" + total;\n        }\n        int res = JOptionPane.showConfirmDialog(this, firstMessage, \"Unindexed databases\", JOptionPane.YES_NO_OPTION);\n        if(res == JOptionPane.YES_OPTION){\n            ModalNoButtons indexingDialog = new ModalNoButtons(this, new Frame(),unindexed);\n            indexingDialog.setLocationRelativeTo(null);\n            indexingDialog.setVisible(true);\n            indexingDialog.setModal(true);\n           //JOptionPane.showMessageDialog(this, secondMessage);\n           hashSetTableModel.resync();\n        }\n        if(res == JOptionPane.NO_OPTION){\n            JOptionPane.showMessageDialog(this, \"All unindexed databases will be removed the list\");\n            removeThese(unindexed);\n        }\n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void removeThese(List<HashDb> toRemove) {\n        HashDbXML xmlHandle = HashDbXML.getCurrent();\n        for (HashDb hdb : toRemove) {\n            for (int i = 0; i < hashSetTableModel.getRowCount(); i++) {\n                if (hashSetTableModel.getDBAt(i).equals(hdb)) {\n                    if (xmlHandle.getNSRLSet() != null) {\n                        if (i == 0) {\n                            HashDbXML.getCurrent().removeNSRLSet();\n                        } else {\n                            HashDbXML.getCurrent().removeKnownBadSetAt(i - 1);\n                        }\n                    } else {\n                        HashDbXML.getCurrent().removeKnownBadSetAt(i);\n                    }\n                    hashSetTableModel.resync();\n                }\n            }\n        }\n    }","id":45062,"modified_method":"void removeThese(List<HashDb> toRemove) {\n        HashDbXML xmlHandle = HashDbXML.getCurrent();\n        for (HashDb hdb : toRemove) {\n            for (int i = 0; i < hashSetTableModel.getRowCount(); i++) {\n                if (hashSetTableModel.getDBAt(i).equals(hdb)) {\n                    if (xmlHandle.getNSRLSet() != null) {\n                        if (i == 0) {\n                            HashDbXML.getCurrent().removeNSRLSet();\n                        } else {\n                            HashDbXML.getCurrent().removeKnownBadSetAt(i - 1);\n                        }\n                    } else {\n                        HashDbXML.getCurrent().removeKnownBadSetAt(i);\n                    }\n                    hashSetTableModel.resync();\n                }\n            }\n        }\n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void indexButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_indexButtonActionPerformed\n        int selected = getSelection();\n        final HashDb current = HashDbXML.getCurrent().getAllSets().get(selected);\n        current.addPropertyChangeListener(new PropertyChangeListener() {\n\n            @Override\n            public void propertyChange(PropertyChangeEvent evt) {\n                if (evt.getPropertyName().equals(HashDb.EVENT.INDEXING_DONE.toString())) {\n                    //update tracking of indexing status\n                    indexingState.put((String)evt.getNewValue(), Boolean.FALSE);\n                    \n                    setButtonFromIndexStatus(indexButton, hashDbIndexStatusLabel, current.status());\n                    resync();\n                }\n            }\n            \n        });\n            indexingState.put(current.getName(), Boolean.TRUE);\n            ModalNoButtons singleMNB = new ModalNoButtons(new Frame(), current);\n            singleMNB.setLocationRelativeTo(null);\n            singleMNB.setVisible(true);\n            singleMNB.setModal(true);\n            JOptionPane.showMessageDialog(this, \"Successfuly created index\");\n            indexingState.put(current.getName(), Boolean.FALSE);\n        setButtonFromIndexStatus(indexButton, this.hashDbIndexStatusLabel, current.status());      \n    }","id":45063,"modified_method":"private void indexButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_indexButtonActionPerformed\n        int selected = getSelection();\n        final HashDb current = HashDbXML.getCurrent().getAllSets().get(selected);\n        current.addPropertyChangeListener(new PropertyChangeListener() {\n\n            @Override\n            public void propertyChange(PropertyChangeEvent evt) {\n                if (evt.getPropertyName().equals(HashDb.EVENT.INDEXING_DONE.toString())) {\n                    //update tracking of indexing status\n                    indexingState.put((String)evt.getNewValue(), Boolean.FALSE);\n                    \n                    setButtonFromIndexStatus(indexButton, hashDbIndexStatusLabel, current.status());\n                    resync();\n                }\n            }\n            \n        });\n            indexingState.put(current.getName(), Boolean.TRUE);\n            ModalNoButtons singleMNB = new ModalNoButtons(this, new Frame(), current);\n            singleMNB.setLocationRelativeTo(null);\n            singleMNB.setVisible(true);\n            singleMNB.setModal(true);\n            JOptionPane.showMessageDialog(this, \"Successfuly created index\");\n            indexingState.put(current.getName(), Boolean.FALSE);\n        setButtonFromIndexStatus(indexButton, this.hashDbIndexStatusLabel, current.status());      \n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void indexThis(){\n        this.INDEXING_PROGBAR.setIndeterminate(true);\n        currentDb = this.toIndex.getName();\n        this.CURRENTDB_LABEL.setText(\"(\" + currentDb + \")\");\n        \n        this.CURRENTLYON_LABEL.setText(\"Currently indexing 1 database\");\n        this.toIndex.addPropertyChangeListener(this);\n        try{\n            this.toIndex.createIndex();\n        }\n        catch(TskException e){\n            Logger.getLogger(ModalNoButtons.class.getName()).log(Level.WARNING, \"Error making TSK index\", e);\n        }\n    }","id":45064,"modified_method":"void indexThis() {\n        this.INDEXING_PROGBAR.setIndeterminate(true);\n        currentDb = this.toIndex.getName();\n        this.CURRENTDB_LABEL.setText(\"(\" + currentDb + \")\");\n        this.length = 1;\n        this.CURRENTLYON_LABEL.setText(\"Currently indexing 1 database\");\n        if (!this.toIndex.isIndexing()) {\n            this.toIndex.addPropertyChangeListener(this);\n            try {\n                this.toIndex.createIndex();\n            } catch (TskException e) {\n                Logger.getLogger(ModalNoButtons.class.getName()).log(Level.WARNING, \"Error making TSK index\", e);\n            }\n        }\n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void indexThese(List<HashDb> unindexedd) {\n        length = unindexedd.size();\n        this.INDEXING_PROGBAR.setIndeterminate(true);\n        for (HashDb db : unindexedd) {\n            currentDb = db.getName();\n            this.CURRENTDB_LABEL.setText(\"(\" + currentDb + \")\");\n            db.addPropertyChangeListener(this);\n            try {\n                db.createIndex();\n            } catch (TskException e) {\n                Logger.getLogger(ModalNoButtons.class.getName()).log(Level.WARNING, \"Error making TSK index\", e);\n            }\n        }\n    }","id":45065,"modified_method":"void indexThese(List<HashDb> unindexedd) {\n        length = unindexedd.size();\n        this.INDEXING_PROGBAR.setIndeterminate(true);\n        for (HashDb db : unindexedd) {\n            currentDb = db.getName();\n            this.CURRENTDB_LABEL.setText(\"(\" + currentDb + \")\");\n            this.CURRENTLYON_LABEL.setText(\"Currently indexing 1 of \" + unindexed.size());\n            if (!db.isIndexing()) {\n                db.addPropertyChangeListener(this);\n                try {\n                    db.createIndex();\n                } catch (TskException e) {\n                    Logger.getLogger(ModalNoButtons.class.getName()).log(Level.WARNING, \"Error making TSK index\", e);\n                }\n            }\n        }\n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Creates new form ModalNoButtons\n     */\n    public ModalNoButtons(java.awt.Frame parent, List<HashDb> unindexed) {\n        super(parent, \"Indexing databases\", true);\n        this.unindexed = unindexed;\n        this.toIndex = null;\n        initComponents();\n        initCustom();\n    }","id":45066,"modified_method":"/**\n     * Creates new form ModalNoButtons\n     */\n    public ModalNoButtons(HashDbManagementPanel hdbmp, java.awt.Frame parent, List<HashDb> unindexed) {\n        super(parent, \"Indexing databases\", true);\n        this.unindexed = unindexed;\n        this.toIndex = null;\n        this.hdbmp = hdbmp;\n        initComponents();\n        initCustom();\n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void CANCEL_BUTTONMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CANCEL_BUTTONMouseClicked\n        // TODO add your handling code here:\n        String message = \"You are about to exit out of indexing your hash databases. \\n\"\n                + \"The generated index will be left unusable. If you choose to continue,\\n \"\n                + \"please delete the corresponding -md5.idx file in the hash folder.\\n\"\n                + \"                                    Continue?\";\n\n        int res = JOptionPane.showConfirmDialog(this, message, \"Unfinished Indexing\", JOptionPane.YES_NO_OPTION);\n        if(res == JOptionPane.YES_OPTION){\n            this.setVisible(false);\n            this.setModal(false);\n            this.dispose();\n          }\n        \n    }","id":45067,"modified_method":"private void CANCEL_BUTTONMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CANCEL_BUTTONMouseClicked\n        // TODO add your handling code here:\n        String message = \"You are about to exit out of indexing your hash databases. \\n\"\n                + \"The generated index will be left unusable. If you choose to continue,\\n \"\n                + \"please delete the corresponding -md5.idx file in the hash folder.\\n\"\n                + \"                                                Exit indexing?\";\n\n        int res = JOptionPane.showConfirmDialog(this, message, \"Unfinished Indexing\", JOptionPane.YES_NO_OPTION);\n        if(res == JOptionPane.YES_OPTION){\n            List<HashDb> remove = new ArrayList<HashDb>();\n            if(this.toIndex == null){\n                remove = this.unindexed;\n            }\n            else{\n                remove.add(this.toIndex);\n            }\n            this.hdbmp.removeThese(remove);\n            this.setVisible(false);\n            this.setModal(false);\n            this.dispose();\n          }\n        \n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public ModalNoButtons(java.awt.Frame parent, HashDb unindexed){\n        super(parent, \"Indexing database\", true);\n        this.unindexed = null;\n        this.toIndex = unindexed;\n        initComponents();\n        initCustom();\n    }","id":45068,"modified_method":"public ModalNoButtons(HashDbManagementPanel hdbmp, java.awt.Frame parent, HashDb unindexed){\n        super(parent, \"Indexing database\", true);\n        this.unindexed = null;\n        this.toIndex = unindexed;\n        this.hdbmp = hdbmp;\n        initComponents();\n        initCustom();\n    }","commit_id":"50163cf4369006eb29b83a59d5669314e671b3ad","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void dispose() {\n      editor.removeEditorMouseListener(mouseListener);\n      editor.getCaretModel().removeCaretListener(caretListener);\n      editor.getSelectionModel().removeSelectionListener(selectionListener);\n      editor.getDocument().removeDocumentListener(documentListener);\n      LookupManager.getInstance(project).removePropertyChangeListener(lookupListener);\n    }","id":45069,"modified_method":"@Override\n    public void dispose() {\n      editor.removeEditorMouseListener(mouseListener);\n      editor.getCaretModel().removeCaretListener(caretListener);\n      editor.getSelectionModel().removeSelectionListener(selectionListener);\n    }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EmptyAutoPopup(CompletionProgressIndicator indicator) {\n      super(indicator);\n      this.editor = indicator.getEditor();\n      this.project = indicator.getProject();\n      MessageBusConnection connection = project.getMessageBus().connect(this);\n      connection.subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerAdapter() {\n        @Override\n        public void selectionChanged(@NotNull FileEditorManagerEvent event) {\n          stopAutoPopup();\n        }\n      });\n\n      mouseListener = new EditorMouseAdapter() {\n        @Override\n        public void mouseClicked(EditorMouseEvent e) {\n          stopAutoPopup();\n        }\n      };\n\n      caretListener = new CaretListener() {\n        @Override\n        public void caretPositionChanged(CaretEvent e) {\n          if (!TypedAction.isTypedActionInProgress()) {\n            stopAutoPopup();\n          }\n        }\n      };\n      selectionListener = new SelectionListener() {\n        @Override\n        public void selectionChanged(SelectionEvent e) {\n          stopAutoPopup();\n        }\n      };\n      documentListener = new DocumentAdapter() {\n        @Override\n        public void documentChanged(DocumentEvent e) {\n          if (!TypedAction.isTypedActionInProgress()) {\n            stopAutoPopup();\n          }\n        }\n      };\n      lookupListener = new PropertyChangeListener() {\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n          stopAutoPopup();\n        }\n      };\n\n      editor.addEditorMouseListener(mouseListener);\n      editor.getCaretModel().addCaretListener(caretListener);\n      editor.getDocument().addDocumentListener(documentListener);\n      editor.getSelectionModel().addSelectionListener(selectionListener);\n      LookupManager.getInstance(project).addPropertyChangeListener(lookupListener);\n    }","id":45070,"modified_method":"public EmptyAutoPopup(CompletionProgressIndicator indicator) {\n      super(indicator);\n      editor = indicator.getEditor();\n      project = indicator.getProject();\n      MessageBusConnection connection = project.getMessageBus().connect(this);\n      connection.subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerAdapter() {\n        @Override\n        public void selectionChanged(@NotNull FileEditorManagerEvent event) {\n          stopAutoPopup();\n        }\n      });\n\n      mouseListener = new EditorMouseAdapter() {\n        @Override\n        public void mouseClicked(EditorMouseEvent e) {\n          stopAutoPopup();\n        }\n      };\n\n      caretListener = new CaretListener() {\n        @Override\n        public void caretPositionChanged(CaretEvent e) {\n          if (!TypedAction.isTypedActionInProgress()) {\n            stopAutoPopup();\n          }\n        }\n      };\n      selectionListener = new SelectionListener() {\n        @Override\n        public void selectionChanged(SelectionEvent e) {\n          stopAutoPopup();\n        }\n      };\n\n      editor.addEditorMouseListener(mouseListener);\n      editor.getCaretModel().addCaretListener(caretListener);\n      editor.getDocument().addDocumentListener(new DocumentAdapter() {\n        @Override\n        public void documentChanged(DocumentEvent e) {\n          if (!TypedAction.isTypedActionInProgress()) {\n            stopAutoPopup();\n          }\n        }\n      }, this);\n      editor.getSelectionModel().addSelectionListener(selectionListener);\n      LookupManager.getInstance(project).addPropertyChangeListener(new PropertyChangeListener() {\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n          stopAutoPopup();\n        }\n      }, this);\n    }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public LookupEx showLookup(final Editor editor,\n                           @NotNull LookupElement[] items,\n                           @NotNull final String prefix,\n                           @NotNull final LookupArranger arranger) {\n    for (LookupElement item : items) {\n      assert item != null;\n    }\n\n    LookupImpl lookup = createLookup(editor, items, prefix, arranger);\n    return lookup != null && lookup.showLookup() ? lookup : null;\n  }","id":45071,"modified_method":"@Override\n  public LookupEx showLookup(@NotNull final Editor editor,\n                           @NotNull LookupElement[] items,\n                           @NotNull final String prefix,\n                           @NotNull final LookupArranger arranger) {\n    for (LookupElement item : items) {\n      assert item != null;\n    }\n\n    LookupImpl lookup = createLookup(editor, items, prefix, arranger);\n    return lookup.showLookup() ? lookup : null;\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public LookupImpl createLookup(final Editor editor,\n                                 @NotNull LookupElement[] items,\n                                 @NotNull final String prefix,\n                                 @NotNull final LookupArranger arranger) {\n    hideActiveLookup();\n\n    final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n    final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(editor.getDocument());\n\n    final LookupImpl lookup = new LookupImpl(myProject, editor, arranger);\n    DaemonCodeAnalyzer.getInstance(myProject).disableUpdateByTimer(lookup);\n\n   final UiNotifyConnector connector = new UiNotifyConnector(editor.getContentComponent(), new Activatable() {\n      @Override\n      public void showNotify() {\n      }\n\n      @Override\n      public void hideNotify() {\n        hideActiveLookup();\n      }\n    });\n\n    final Alarm alarm = new Alarm();\n    final Runnable request = new Runnable() {\n      @Override\n      public void run() {\n        if (myActiveLookup == lookup && lookup.getCurrentItem() != null) {\n          final CompletionProcess completion = CompletionService.getCompletionService().getCurrentCompletion();\n          if (completion != null && !completion.isAutopopupCompletion()) {\n            try {\n              DocumentationManager.getInstance(myProject).showJavaDocInfo(editor, psiFile, false);\n            }\n            catch (IndexNotReadyException ignored) {\n            }\n          }\n        }\n      }\n    };\n    if (settings.AUTO_POPUP_JAVADOC_INFO) {\n      alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n    }\n\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    myActiveLookup = lookup;\n    myActiveLookupEditor = editor;\n    myActiveLookup.addLookupListener(new LookupAdapter() {\n      @Override\n      public void itemSelected(LookupEvent event) {\n        lookupClosed();\n      }\n\n      @Override\n      public void lookupCanceled(LookupEvent event) {\n        lookupClosed();\n      }\n\n      @Override\n      public void currentItemChanged(LookupEvent event) {\n        alarm.cancelAllRequests();\n        if (settings.AUTO_POPUP_JAVADOC_INFO) {\n          alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n        }\n      }\n\n      private void lookupClosed() {\n        ApplicationManager.getApplication().assertIsDispatchThread();\n\n        alarm.cancelAllRequests();\n        LookupImpl lookup = myActiveLookup;\n        if (lookup == null) return;\n\n        LOG.assertTrue(lookup.isLookupDisposed());\n        myActiveLookup = null;\n        myActiveLookupEditor = null;\n        lookup.removeLookupListener(this);\n        myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, lookup, null);\n\n        Disposer.dispose(connector);\n      }\n    });\n\n    CamelHumpMatcher matcher = new CamelHumpMatcher(prefix);\n    if (items.length > 0) {\n      for (final LookupElement item : items) {\n        myActiveLookup.addItem(item, matcher);\n      }\n      myActiveLookup.refreshUi(true, true);\n    } else {\n      alarm.cancelAllRequests(); // no items -> no doc\n    }\n\n    myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, null, myActiveLookup);\n    return myActiveLookup;\n  }","id":45072,"modified_method":"@NotNull\n  @Override\n  public LookupImpl createLookup(@NotNull final Editor editor,\n                                 @NotNull LookupElement[] items,\n                                 @NotNull final String prefix,\n                                 @NotNull final LookupArranger arranger) {\n    hideActiveLookup();\n\n    final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n    final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(editor.getDocument());\n\n    final LookupImpl lookup = new LookupImpl(myProject, editor, arranger);\n    DaemonCodeAnalyzer.getInstance(myProject).disableUpdateByTimer(lookup);\n\n   final UiNotifyConnector connector = new UiNotifyConnector(editor.getContentComponent(), new Activatable() {\n      @Override\n      public void showNotify() {\n      }\n\n      @Override\n      public void hideNotify() {\n        hideActiveLookup();\n      }\n    });\n\n    final Alarm alarm = new Alarm();\n    final Runnable request = new Runnable() {\n      @Override\n      public void run() {\n        if (myActiveLookup == lookup && lookup.getCurrentItem() != null) {\n          final CompletionProcess completion = CompletionService.getCompletionService().getCurrentCompletion();\n          if (completion != null && !completion.isAutopopupCompletion()) {\n            try {\n              DocumentationManager.getInstance(myProject).showJavaDocInfo(editor, psiFile, false);\n            }\n            catch (IndexNotReadyException ignored) {\n            }\n          }\n        }\n      }\n    };\n    if (settings.AUTO_POPUP_JAVADOC_INFO) {\n      alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n    }\n\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    myActiveLookup = lookup;\n    myActiveLookupEditor = editor;\n    myActiveLookup.addLookupListener(new LookupAdapter() {\n      @Override\n      public void itemSelected(LookupEvent event) {\n        lookupClosed();\n      }\n\n      @Override\n      public void lookupCanceled(LookupEvent event) {\n        lookupClosed();\n      }\n\n      @Override\n      public void currentItemChanged(LookupEvent event) {\n        alarm.cancelAllRequests();\n        if (settings.AUTO_POPUP_JAVADOC_INFO) {\n          alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n        }\n      }\n\n      private void lookupClosed() {\n        ApplicationManager.getApplication().assertIsDispatchThread();\n\n        alarm.cancelAllRequests();\n        LookupImpl lookup = myActiveLookup;\n        if (lookup == null) return;\n\n        LOG.assertTrue(lookup.isLookupDisposed());\n        myActiveLookup = null;\n        myActiveLookupEditor = null;\n        lookup.removeLookupListener(this);\n        myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, lookup, null);\n\n        Disposer.dispose(connector);\n      }\n    });\n\n    CamelHumpMatcher matcher = new CamelHumpMatcher(prefix);\n    if (items.length > 0) {\n      for (final LookupElement item : items) {\n        myActiveLookup.addItem(item, matcher);\n      }\n      myActiveLookup.refreshUi(true, true);\n    }\n    else {\n      alarm.cancelAllRequests(); // no items -> no doc\n    }\n\n    myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, null, myActiveLookup);\n    return lookup;\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateComponent(){\n    if (!myHint.isVisible()){\n      dispose();\n      return;\n    }\n\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    final PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument());\n    CharSequence chars = myEditor.getDocument().getCharsSequence();\n    final int offset = CharArrayUtil.shiftBackward(chars, myEditor.getCaretModel().getOffset() - 1, \" \\t\") + 1;\n\n    final UpdateParameterInfoContext context = new MyUpdateParameterInfoContext(offset, file);\n    final Object elementForUpdating = myHandler.findElementForUpdatingParameterInfo(context);\n\n    if (elementForUpdating != null) {\n      myHandler.updateParameterInfo(elementForUpdating, context);\n      if (!myDisposed && myHint.isVisible() && myEditor.getComponent().getRootPane() != null) {\n        myComponent.update();\n        Pair<Point,Short> pos = myProvider.getBestPointPosition(myHint, (PsiElement)elementForUpdating, offset, true, HintManager.UNDER);\n        HintManagerImpl.adjustEditorHintPosition(myHint, myEditor, pos.getFirst(), pos.getSecond());\n      }\n    }\n    else {\n      context.removeHint();\n    }\n  }","id":45073,"modified_method":"private void updateComponent(){\n    if (!myHint.isVisible()){\n      Disposer.dispose(this);\n      return;\n    }\n\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    final PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument());\n    CharSequence chars = myEditor.getDocument().getCharsSequence();\n    final int offset = CharArrayUtil.shiftBackward(chars, myEditor.getCaretModel().getOffset() - 1, \" \\t\") + 1;\n\n    final UpdateParameterInfoContext context = new MyUpdateParameterInfoContext(offset, file);\n    final Object elementForUpdating = myHandler.findElementForUpdatingParameterInfo(context);\n\n    if (elementForUpdating != null) {\n      myHandler.updateParameterInfo(elementForUpdating, context);\n      if (!myDisposed && myHint.isVisible() && myEditor.getComponent().getRootPane() != null) {\n        myComponent.update();\n        Pair<Point,Short> pos = myProvider.getBestPointPosition(myHint, (PsiElement)elementForUpdating, offset, true, HintManager.UNDER);\n        HintManagerImpl.adjustEditorHintPosition(myHint, myEditor, pos.getFirst(), pos.getSecond());\n      }\n    }\n    else {\n      context.removeHint();\n    }\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ParameterInfoController findControllerAtOffset(Editor editor, int offset) {\n    ArrayList<ParameterInfoController> allControllers = getAllControllers(editor);\n    for (int i = 0; i < allControllers.size(); ++i) {\n      ParameterInfoController controller = allControllers.get(i);\n\n      if (controller.myLbraceMarker.getStartOffset() == offset) {\n        if (controller.myHint.isVisible()) return controller;\n        controller.dispose();\n        --i;\n      }\n    }\n\n    return null;\n  }","id":45074,"modified_method":"public static ParameterInfoController findControllerAtOffset(Editor editor, int offset) {\n    List<ParameterInfoController> allControllers = getAllControllers(editor);\n    for (int i = 0; i < allControllers.size(); ++i) {\n      ParameterInfoController controller = allControllers.get(i);\n\n      if (controller.myLbraceMarker.getStartOffset() == offset) {\n        if (controller.myHint.isVisible()) return controller;\n        Disposer.dispose(controller);\n        --i;\n      }\n    }\n\n    return null;\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ParameterInfoController(@NotNull Project project,\n                                 @NotNull Editor editor,\n                                 int lbraceOffset,\n                                 @NotNull LightweightHint hint,\n                                 @NotNull ParameterInfoHandler handler,\n                                 @NotNull ShowParameterInfoHandler.BestLocationPointProvider provider) {\n    myProject = project;\n    myEditor = editor;\n    myHandler = handler;\n    myProvider = provider;\n    myParameterCloseChars = handler.getParameterCloseChars();\n    myLbraceMarker = editor.getDocument().createRangeMarker(lbraceOffset, lbraceOffset);\n    myHint = hint;\n    myComponent = (ParameterInfoComponent)myHint.getComponent();\n\n    ArrayList<ParameterInfoController> allControllers = getAllControllers(myEditor);\n    allControllers.add(this);\n\n    myEditorCaretListener = new CaretListener(){\n      @Override\n      public void caretPositionChanged(CaretEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    };\n    myEditor.getCaretModel().addCaretListener(myEditorCaretListener);\n\n    myEditorDocumentListener = new DocumentAdapter(){\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    };\n    myEditor.getDocument().addDocumentListener(myEditorDocumentListener);\n\n    myLookupListener = new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (LookupManager.PROP_ACTIVE_LOOKUP.equals(evt.getPropertyName())){\n          final LookupImpl lookup = (LookupImpl)evt.getNewValue();\n          if (lookup != null && lookup.isShown()){\n            adjustPositionForLookup(lookup);\n          }\n        }\n      }\n    };\n    LookupManager.getInstance(project).addPropertyChangeListener(myLookupListener);\n\n    updateComponent();\n    if (myEditor instanceof EditorImpl) {\n      Disposer.register(((EditorImpl)myEditor).getDisposable(), new Disposable() {\n        @Override\n        public void dispose() {\n          ParameterInfoController.this.dispose();\n        }\n      });\n    }\n  }","id":45075,"modified_method":"public ParameterInfoController(@NotNull Project project,\n                                 @NotNull Editor editor,\n                                 int lbraceOffset,\n                                 @NotNull LightweightHint hint,\n                                 @NotNull ParameterInfoHandler handler,\n                                 @NotNull ShowParameterInfoHandler.BestLocationPointProvider provider) {\n    myProject = project;\n    myEditor = editor;\n    myHandler = handler;\n    myProvider = provider;\n    myLbraceMarker = editor.getDocument().createRangeMarker(lbraceOffset, lbraceOffset);\n    myHint = hint;\n    myComponent = (ParameterInfoComponent)myHint.getComponent();\n\n    List<ParameterInfoController> allControllers = getAllControllers(myEditor);\n    allControllers.add(this);\n\n    myEditorCaretListener = new CaretListener(){\n      @Override\n      public void caretPositionChanged(CaretEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    };\n    myEditor.getCaretModel().addCaretListener(myEditorCaretListener);\n\n    myEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    }, this);\n\n    PropertyChangeListener lookupListener = new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (LookupManager.PROP_ACTIVE_LOOKUP.equals(evt.getPropertyName())) {\n          final LookupImpl lookup = (LookupImpl)evt.getNewValue();\n          if (lookup != null && lookup.isShown()) {\n            adjustPositionForLookup(lookup);\n          }\n        }\n      }\n    };\n    LookupManager.getInstance(project).addPropertyChangeListener(lookupListener, this);\n\n    updateComponent();\n    if (myEditor instanceof EditorImpl) {\n      Disposer.register(((EditorImpl)myEditor).getDisposable(), this);\n    }\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void dispose(){\n    if (myDisposed) return;\n    myDisposed = true;\n\n    ArrayList<ParameterInfoController> allControllers = getAllControllers(myEditor);\n    allControllers.remove(this);\n    myEditor.getCaretModel().removeCaretListener(myEditorCaretListener);\n    myEditor.getDocument().removeDocumentListener(myEditorDocumentListener);\n    LookupManager.getInstance(myProject).removePropertyChangeListener(myLookupListener);\n  }","id":45076,"modified_method":"@Override\n  public void dispose(){\n    if (myDisposed) return;\n    myDisposed = true;\n\n    List<ParameterInfoController> allControllers = getAllControllers(myEditor);\n    allControllers.remove(this);\n    myEditor.getCaretModel().removeCaretListener(myEditorCaretListener);\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void removeHint() {\n      myHint.hide();\n      dispose();\n    }","id":45077,"modified_method":"@Override\n    public void removeHint() {\n      myHint.hide();\n      Disposer.dispose(ParameterInfoController.this);\n    }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ArrayList<ParameterInfoController> getAllControllers(@NotNull Editor editor) {\n    ArrayList<ParameterInfoController> array = editor.getUserData(ALL_CONTROLLERS_KEY);\n    if (array == null){\n      array = new ArrayList<ParameterInfoController>();\n      editor.putUserData(ALL_CONTROLLERS_KEY, array);\n    }\n    return array;\n  }","id":45078,"modified_method":"private static List<ParameterInfoController> getAllControllers(@NotNull Editor editor) {\n    List<ParameterInfoController> array = editor.getUserData(ALL_CONTROLLERS_KEY);\n    if (array == null){\n      array = new ArrayList<ParameterInfoController>();\n      editor.putUserData(ALL_CONTROLLERS_KEY, array);\n    }\n    return array;\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void adjustPositionForLookup(@NotNull Lookup lookup) {\n    if (!myHint.isVisible() || myEditor.isDisposed()) {\n      dispose();\n      return;\n    }\n\n    HintManagerImpl hintManager = HintManagerImpl.getInstanceImpl();\n    short constraint = lookup.isPositionedAboveCaret() ? HintManager.UNDER : HintManager.ABOVE;\n    Point p = hintManager.getHintPosition(myHint, myEditor, constraint);\n    //Dimension hintSize = myHint.getComponent().getPreferredSize();\n    //JLayeredPane layeredPane = myEditor.getComponent().getRootPane().getLayeredPane();\n    //p.x = Math.min(p.x, layeredPane.getWidth() - hintSize.width);\n    //p.x = Math.max(p.x, 0);\n    myHint.updateBounds(p.x, p.y);\n  }","id":45079,"modified_method":"private void adjustPositionForLookup(@NotNull Lookup lookup) {\n    if (!myHint.isVisible() || myEditor.isDisposed()) {\n      Disposer.dispose(this);\n      return;\n    }\n\n    HintManagerImpl hintManager = HintManagerImpl.getInstanceImpl();\n    short constraint = lookup.isPositionedAboveCaret() ? HintManager.UNDER : HintManager.ABOVE;\n    Point p = hintManager.getHintPosition(myHint, myEditor, constraint);\n    //Dimension hintSize = myHint.getComponent().getPreferredSize();\n    //JLayeredPane layeredPane = myEditor.getComponent().getRootPane().getLayeredPane();\n    //p.x = Math.min(p.x, layeredPane.getWidth() - hintSize.width);\n    //p.x = Math.max(p.x, 0);\n    myHint.updateBounds(p.x, p.y);\n  }","commit_id":"0c8af20f315bbae1ceb67c45fc8949ed0d432683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<EObject> getUsedGrammar(Grammar grammar, INode node) {\n\t\ttry {\n\t\t\tString grammarName = (String) valueConverterService.toValue(\"\", \"GrammarID\", node);\n\t\t\tif (grammarName != null) {\n\t\t\t\tfinal ResourceSet resourceSet = grammar.eResource().getResourceSet();\n\t\t\t\tList<Resource> resources = resourceSet.getResources();\n\t\t\t\tfor(int i = 0; i < resources.size(); i++) {\n\t\t\t\t\tResource resource = resources.get(i);\n\t\t\t\t\tEObject rootElement = null;\n\t\t\t\t\tif (resource instanceof XtextResource) {\n\t\t\t\t\t\tIParseResult parseResult = ((XtextResource) resource).getParseResult();\n\t\t\t\t\t\tif (parseResult != null)\n\t\t\t\t\t\t\trootElement = parseResult.getRootASTElement();\n\t\t\t\t\t} else if (!resource.getContents().isEmpty()) {\n\t\t\t\t\t\trootElement = resource.getContents().get(0);\n\t\t\t\t\t}\n\t\t\t\t\tif (rootElement instanceof Grammar) {\n\t\t\t\t\t\tGrammar otherGrammar = (Grammar) rootElement;\n\t\t\t\t\t\tif (grammarName.equals(otherGrammar.getName())) {\n\t\t\t\t\t\t\tif (resource instanceof DerivedStateAwareResource)\n\t\t\t\t\t\t\t\tresource.getContents();\n\t\t\t\t\t\t\treturn Collections.<EObject>singletonList(otherGrammar);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tURI classpathURI = URI.createURI(\n\t\t\t\t\t\tClasspathUriUtil.CLASSPATH_SCHEME + \":/\" + grammarName.replace('.', '/') + \".\" + fileExtension);\n\t\t\t\tURI normalizedURI = resourceSet.getURIConverter().normalize(classpathURI);\n\t\t\t\tfinal Resource resource = resourceSet.getResource(normalizedURI, true);\n\t\t\t\tif (!resource.getContents().isEmpty()) {\n\t\t\t\t\tfinal Grammar usedGrammar = (Grammar) resource.getContents().get(0);\n\t\t\t\t\tif (grammarName.equals(usedGrammar.getName()))\n\t\t\t\t\t\treturn Collections.<EObject>singletonList(usedGrammar);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tcatch (ClasspathUriResolutionException e) {\n\t\t\tlog.debug(\"Cannot load used grammar.\" , e);\n\t\t\treturn Collections.emptyList();\n\t\t} catch (ValueConverterException e) {\n\t\t\tlog.debug(\"Cannot load used grammar.\" , e);\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","id":45080,"modified_method":"private List<EObject> getUsedGrammar(Grammar grammar, INode node) {\n\t\ttry {\n\t\t\tString grammarName = (String) valueConverterService.toValue(\"\", \"GrammarID\", node);\n\t\t\tif (grammarName != null) {\n\t\t\t\tfinal ResourceSet resourceSet = grammar.eResource().getResourceSet();\n\t\t\t\tList<Resource> resources = resourceSet.getResources();\n\t\t\t\tfor(int i = 0; i < resources.size(); i++) {\n\t\t\t\t\tResource resource = resources.get(i);\n\t\t\t\t\tEObject rootElement = null;\n\t\t\t\t\tif (resource instanceof XtextResource) {\n\t\t\t\t\t\tIParseResult parseResult = ((XtextResource) resource).getParseResult();\n\t\t\t\t\t\tif (parseResult != null)\n\t\t\t\t\t\t\trootElement = parseResult.getRootASTElement();\n\t\t\t\t\t} else if (!resource.getContents().isEmpty()) {\n\t\t\t\t\t\trootElement = resource.getContents().get(0);\n\t\t\t\t\t}\n\t\t\t\t\tif (rootElement instanceof Grammar) {\n\t\t\t\t\t\tGrammar otherGrammar = (Grammar) rootElement;\n\t\t\t\t\t\tif (grammarName.equals(otherGrammar.getName())) {\n\t\t\t\t\t\t\tif (resource instanceof DerivedStateAwareResource)\n\t\t\t\t\t\t\t\tresource.getContents();\n\t\t\t\t\t\t\treturn Collections.<EObject>singletonList(otherGrammar);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tURI classpathURI = URI.createURI(\n\t\t\t\t\t\tClasspathUriUtil.CLASSPATH_SCHEME + \":/\" + grammarName.replace('.', '/') + \".\" + fileExtension);\n\t\t\t\tURI normalizedURI = null;\n\t\t\t\tif (resourceSet instanceof XtextResourceSet) {\n\t\t\t\t\tXtextResourceSet set = (XtextResourceSet) resourceSet;\n\t\t\t\t\tnormalizedURI = set.getClasspathUriResolver().resolve(set.getClasspathURIContext(), classpathURI);\n\t\t\t\t} else {\n\t\t\t\t\tnormalizedURI = resourceSet.getURIConverter().normalize(classpathURI);\n\t\t\t\t}\n\t\t\t\tfinal Resource resource = resourceSet.getResource(normalizedURI, true);\n\t\t\t\tif (!resource.getContents().isEmpty()) {\n\t\t\t\t\tfinal Grammar usedGrammar = (Grammar) resource.getContents().get(0);\n\t\t\t\t\tif (grammarName.equals(usedGrammar.getName()))\n\t\t\t\t\t\treturn Collections.<EObject>singletonList(usedGrammar);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tcatch (ClasspathUriResolutionException e) {\n\t\t\tlog.debug(\"Cannot load used grammar.\" , e);\n\t\t\treturn Collections.emptyList();\n\t\t} catch (ValueConverterException e) {\n\t\t\tlog.debug(\"Cannot load used grammar.\" , e);\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","commit_id":"ea0d82da5c9c36732fa3f49ce9fede26d9c76efb","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * @param sstable SSTable to scan; must not be null\n     * @param dataRange a single range to scan; must not be null\n     * @param limiter background i/o RateLimiter; may be null\n     */\n    private SSTableScanner(SSTableReader sstable, DataRange dataRange, RateLimiter limiter)\n    {\n        assert sstable != null;\n\n        this.dfile = limiter == null ? sstable.openDataReader() : sstable.openDataReader(limiter);\n        this.ifile = sstable.openIndexReader();\n        this.sstable = sstable;\n        this.dataRange = dataRange;\n\n        List<AbstractBounds<RowPosition>> boundsList = new ArrayList<>(2);\n        if (dataRange.isWrapAround())\n        {\n            if (dataRange.stopKey().compareTo(sstable.first) >= 0)\n            {\n                // since we wrap, we must contain the whole sstable prior to stopKey()\n                Boundary<RowPosition> left = new Boundary<RowPosition>(sstable.first, true);\n                Boundary<RowPosition> right;\n                right = dataRange.keyRange().rightBoundary();\n                right = minRight(right, sstable.last, true);\n                if (!isEmpty(left, right))\n                    boundsList.add(AbstractBounds.bounds(left, right));\n            }\n            if (dataRange.startKey().compareTo(sstable.last) <= 0)\n            {\n                // since we wrap, we must contain the whole sstable after dataRange.startKey()\n                Boundary<RowPosition> right = new Boundary<RowPosition>(sstable.last, true);\n                Boundary<RowPosition> left;\n                left = dataRange.keyRange().leftBoundary();\n                left = maxLeft(left, sstable.first, true);\n                if (!isEmpty(left, right))\n                    boundsList.add(AbstractBounds.bounds(left, right));\n            }\n        }\n        else\n        {\n            assert dataRange.startKey().compareTo(dataRange.stopKey()) <= 0 || dataRange.stopKey().isMinimum();\n            Boundary<RowPosition> left, right;\n            left = dataRange.keyRange().leftBoundary();\n            right = dataRange.keyRange().rightBoundary();\n            left = maxLeft(left, sstable.first, true);\n            // apparently isWrapAround() doesn't count Bounds that extend to the limit (min) as wrapping\n            right = dataRange.stopKey().isMinimum() ? new Boundary<RowPosition>(sstable.last, true)\n                                                    : minRight(right, sstable.last, true);\n            if (!isEmpty(left, right))\n                boundsList.add(AbstractBounds.bounds(left, right));\n        }\n        this.rangeIterator = boundsList.iterator();\n    }","id":45081,"modified_method":"/**\n     * @param sstable SSTable to scan; must not be null\n     * @param dataRange a single range to scan; must not be null\n     * @param limiter background i/o RateLimiter; may be null\n     */\n    private SSTableScanner(SSTableReader sstable, DataRange dataRange, RateLimiter limiter)\n    {\n        assert sstable != null;\n\n        this.dfile = limiter == null ? sstable.openDataReader() : sstable.openDataReader(limiter);\n        this.ifile = sstable.openIndexReader();\n        this.sstable = sstable;\n        this.dataRange = dataRange;\n\n        List<AbstractBounds<RowPosition>> boundsList = new ArrayList<>(2);\n        addRange(dataRange.keyRange(), boundsList);\n        this.rangeIterator = boundsList.iterator();\n    }","commit_id":"4eef4499ba24dd5168fdd759f4e2587892e4394b","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * @param sstable SSTable to scan; must not be null\n     * @param tokenRanges A set of token ranges to scan\n     * @param limiter background i/o RateLimiter; may be null\n     */\n    private SSTableScanner(SSTableReader sstable, Collection<Range<Token>> tokenRanges, RateLimiter limiter)\n    {\n        assert sstable != null;\n\n        this.dfile = limiter == null ? sstable.openDataReader() : sstable.openDataReader(limiter);\n        this.ifile = sstable.openIndexReader();\n        this.sstable = sstable;\n        this.dataRange = null;\n\n        List<Range<Token>> normalized = Range.normalize(tokenRanges);\n        List<AbstractBounds<RowPosition>> boundsList = new ArrayList<>(normalized.size());\n        for (Range<Token> range : normalized)\n        {\n            // cap our ranges by the start/end of the sstable\n            RowPosition right = range.right.maxKeyBound(sstable.partitioner);\n            if (right.compareTo(sstable.last) > 0)\n                right = sstable.last;\n\n            RowPosition left = range.left.maxKeyBound(sstable.partitioner);\n            if (left.compareTo(sstable.first) < 0)\n            {\n                if (sstable.first.compareTo(right) <= 0)\n                    boundsList.add(new Bounds<>(sstable.first, right, sstable.partitioner));\n            }\n            else if (left.compareTo(right) < 0)\n                boundsList.add(new Range<>(left, right, sstable.partitioner));\n        }\n\n        this.rangeIterator = boundsList.iterator();\n    }","id":45082,"modified_method":"/**\n     * @param sstable SSTable to scan; must not be null\n     * @param tokenRanges A set of token ranges to scan\n     * @param limiter background i/o RateLimiter; may be null\n     */\n    private SSTableScanner(SSTableReader sstable, Collection<Range<Token>> tokenRanges, RateLimiter limiter)\n    {\n        assert sstable != null;\n\n        this.dfile = limiter == null ? sstable.openDataReader() : sstable.openDataReader(limiter);\n        this.ifile = sstable.openIndexReader();\n        this.sstable = sstable;\n        this.dataRange = null;\n\n        List<AbstractBounds<RowPosition>> boundsList = new ArrayList<>(tokenRanges.size());\n        for (Range<Token> range : Range.normalize(tokenRanges))\n            addRange(range.toRowBounds(), boundsList);\n\n        this.rangeIterator = boundsList.iterator();\n    }","commit_id":"4eef4499ba24dd5168fdd759f4e2587892e4394b","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Ensures that this object is in a valid state to serve resources, checks\n     * that the path is a String that starts with '/' and checks that the path\n     * can be normalized without stepping outside of the root.\n     *\n     * @param path\n     * @return  the normlized path\n     */\n    private String validate(String path) {\n        if (!getState().isAvailable()) {\n            throw new IllegalStateException(\n                    sm.getString(\"standardRoot.checkStateNotStarted\"));\n        }\n\n        if (path == null || path.length() == 0 || !path.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPath\", path));\n        }\n\n        String result = RequestUtil.normalize(path);\n        if (result == null || result.length() == 0 || !result.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPathNormal\", path, result));\n        }\n\n        return result;\n    }","id":45083,"modified_method":"/**\n     * Ensures that this object is in a valid state to serve resources, checks\n     * that the path is a String that starts with '/' and checks that the path\n     * can be normalized without stepping outside of the root.\n     *\n     * @param path\n     * @return  the normlized path\n     */\n    private String validate(String path) {\n        if (!getState().isAvailable()) {\n            throw new IllegalStateException(\n                    sm.getString(\"standardRoot.checkStateNotStarted\"));\n        }\n\n        if (path == null || path.length() == 0 || !path.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPath\", path));\n        }\n\n        String result;\n        if (File.separatorChar == '\\\\') {\n            // On Windows '\\\\' is a separator so in case a Windows style\n            // separator has managed to make it into the path, replace it.\n            result = RequestUtil.normalize(path, true);\n        } else {\n            // On UNIX and similar systems, '\\\\' is a valid file name so do not\n            // convert it to '/'\n            result = RequestUtil.normalize(path, false);\n        }\n        if (result == null || result.length() == 0 || !result.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPathNormal\", path, result));\n        }\n\n        return result;\n    }","commit_id":"ddf7c54909ff97b0af5e3523141fc5e0e4708cc4","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Checks if the given <tt>detailAddress<\/tt> exists in the given\n     * <tt>contact<\/tt> details.\n     *\n     * @param contact the <tt>Contact<\/tt>, which details to check\n     * @param detailAddress the detail address we're looking for\n     * @return <tt>true<\/tt> if the given <tt>detailAdress<\/tt> exists in the\n     * details of the given <tt>contact<\/tt>\n     */\n    public boolean doesDetailBelong(Contact contact, String detailAddress)\n    {\n        List<String> contactPhones\n            = ContactPhoneUtil.getContactAdditionalPhones(\n                contact, null, false, false);\n\n        if (contactPhones == null || contactPhones.size() <= 0)\n            return false;\n\n        Iterator<String> phonesIter = contactPhones.iterator();\n\n        while (phonesIter.hasNext())\n        {\n            String phone = phonesIter.next();\n\n            if (phone.equals(detailAddress)\n                || PhoneNumberI18nService.normalize(phone)\n                    .equals(detailAddress))\n                return true;\n        }\n\n        return false;\n    }","id":45084,"modified_method":"/**\n     * Checks if the given <tt>detailAddress<\/tt> exists in the given\n     * <tt>contact<\/tt> details.\n     *\n     * @param contact the <tt>Contact<\/tt>, which details to check\n     * @param detailAddress the detail address we're looking for\n     * @return <tt>true<\/tt> if the given <tt>detailAdress<\/tt> exists in the\n     * details of the given <tt>contact<\/tt>\n     */\n    public boolean doesDetailBelong(Contact contact, String detailAddress)\n    {\n        List<String> contactPhones\n            = ContactPhoneUtil.getContactAdditionalPhones(\n                contact, null, false, false);\n\n        if (contactPhones == null || contactPhones.size() <= 0)\n            return false;\n\n        Iterator<String> phonesIter = contactPhones.iterator();\n\n        while (phonesIter.hasNext())\n        {\n            String phone = phonesIter.next();\n            String normalizedPhone = PhoneNumberI18nService.normalize(phone);\n\n            if (phone.equals(detailAddress)\n                || normalizedPhone.equals(detailAddress)\n                || detailAddress.contains(phone)\n                || detailAddress.contains(normalizedPhone))\n                return true;\n        }\n\n        return false;\n    }","commit_id":"45c35afd9f68eb26c2b6bb0d129f0c08811ce973","url":"https://github.com/jitsi/jitsi"},{"original_method":"protected final void checkPath(String path) {\n        if (path == null || path.length() == 0 || path.charAt(0) != '/') {\n            throw new IllegalArgumentException();\n        }\n    }","id":45085,"modified_method":"protected final void checkPath(String path) {\n        if (path == null || path.length() == 0 || path.charAt(0) != '/') {\n            throw new IllegalArgumentException(\n                    sm.getString(\"abstractResourceSet.checkPath\", path));\n        }\n    }","commit_id":"979b3c0a867665afaa8d1b11f354151240423e76","url":"https://github.com/apache/tomcat"},{"original_method":"private boolean noCache(String path) {\n        // Don't cache resources used by the class loader (it has its own cache)\n        if (path == null || path.startsWith(\"/WEB-INF/classes\") ||\n                path.startsWith(\"/WEB-INF/lib\")) {\n            return true;\n        }\n        return false;\n    }","id":45086,"modified_method":"private boolean noCache(String path) {\n        // Don't cache resources used by the class loader (it has its own cache)\n        if (path.startsWith(\"/WEB-INF/classes\") ||\n                path.startsWith(\"/WEB-INF/lib\")) {\n            return true;\n        }\n        return false;\n    }","commit_id":"979b3c0a867665afaa8d1b11f354151240423e76","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Ensures that this object is in a valid state to serve resources, checks\n     * that the path is a String that starts with '/' and checks that the path\n     * can be normalized without stepping outside of the root.\n     *\n     * @param path\n     * @return  the normlized path\n     */\n    private String validate(String path) {\n        if (!getState().isAvailable()) {\n            throw new IllegalStateException(\n                    sm.getString(\"standardRoot.checkStateNotStarted\"));\n        }\n\n        if (path == null || path.length() == 0 || !path.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPath\", path));\n        }\n        return RequestUtil.normalize(path);\n    }","id":45087,"modified_method":"/**\n     * Ensures that this object is in a valid state to serve resources, checks\n     * that the path is a String that starts with '/' and checks that the path\n     * can be normalized without stepping outside of the root.\n     *\n     * @param path\n     * @return  the normlized path\n     */\n    private String validate(String path) {\n        if (!getState().isAvailable()) {\n            throw new IllegalStateException(\n                    sm.getString(\"standardRoot.checkStateNotStarted\"));\n        }\n\n        if (path == null || path.length() == 0 || !path.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPath\", path));\n        }\n\n        String result = RequestUtil.normalize(path);\n        if (result == null || result.length() == 0 || !result.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"standardRoot.invalidPathNormal\", path, result));\n        }\n\n        return result;\n    }","commit_id":"979b3c0a867665afaa8d1b11f354151240423e76","url":"https://github.com/apache/tomcat"},{"original_method":"protected void verifyURLTitle() throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(\"select distinct urlTitle from JournalArticle where \");\n\t\t\tsb.append(\"urlTitle like '%\\u00a3%' or urlTitle like '%\\u2013%' \");\n\t\t\tsb.append(\"or urlTitle like '%\\u2014%' or urlTitle like \");\n\t\t\tsb.append(\"'%\\u2018%' or urlTitle like '%\\u2019%' or urlTitle \");\n\t\t\tsb.append(\"like '%\\u201c%' or urlTitle like '%\\u201d%'\");\n\n\t\t\tps = con.prepareStatement(sb.toString());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tString urlTitle = rs.getString(\"urlTitle\");\n\n\t\t\t\tupdateURLTitle(urlTitle);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","id":45088,"modified_method":"protected void verifyURLTitle() throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select distinct groupId, articleId, urlTitle from \" +\n\t\t\t\t\t\"JournalArticle\");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong groupId = Long.valueOf(rs.getString(\"groupId\"));\n\t\t\t\tString articleId = rs.getString(\"articleId\");\n\t\t\t\tString urlTitle = rs.getString(\"urlTitle\");\n\n\t\t\t\tupdateURLTitle(groupId, articleId, urlTitle);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"639fad48f84ef91c2d001bd467f9b54f4ab3e0e0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateURLTitle(String urlTitle) throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"update JournalArticle set urlTitle = ? where urlTitle = ?\");\n\n\t\t\tps.setString(1, FriendlyURLNormalizerUtil.normalize(urlTitle));\n\t\t\tps.setString(2, urlTitle);\n\n\t\t\tps.executeUpdate();\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","id":45089,"modified_method":"protected void updateURLTitle(\n\t\t\tlong groupId, String articleId, String urlTitle)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tString normalizedURLTitle = FriendlyURLNormalizerUtil.normalize(\n\t\t\t\turlTitle, _friendlyURLPattern);\n\n\t\t\tif (!urlTitle.equals(normalizedURLTitle)) {\n\t\t\t\tnormalizedURLTitle =\n\t\t\t\t\tJournalArticleLocalServiceUtil.getUniqueUrlTitle(\n\t\t\t\t\t\tgroupId, articleId, normalizedURLTitle);\n\n\t\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\t\tps = con.prepareStatement(\n\t\t\t\t\t\"update JournalArticle set urlTitle = ? where urlTitle = \" +\n\t\t\t\t\t\t\"?\");\n\n\t\t\t\tps.setString(1, normalizedURLTitle);\n\t\t\t\tps.setString(2, urlTitle);\n\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","commit_id":"639fad48f84ef91c2d001bd467f9b54f4ab3e0e0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void createHyperlinksTo(XtextResource from, Region region, EObject to, IHyperlinkAcceptor acceptor) {\n\t\tfinal URIConverter uriConverter = from.getResourceSet().getURIConverter();\n\t\tfinal String hyperlinkText = labelProvider.getText(to);\n\t\tfinal URI uri = EcoreUtil.getURI(to);\n\t\tfinal URI normalized = uriConverter.normalize(uri);\n\n\t\tXtextHyperlink result = hyperlinkProvider.get();\n\t\tresult.setHyperlinkRegion(region);\n\t\tresult.setURI(normalized);\n\t\tresult.setHyperlinkText(hyperlinkText);\n\t\tacceptor.accept(result);\n\t}","id":45090,"modified_method":"public void createHyperlinksTo(XtextResource from, Region region, EObject to, IHyperlinkAcceptor acceptor) {\n\t\tfinal URIConverter uriConverter = from.getResourceSet().getURIConverter();\n\t\tfinal String hyperlinkText = labelProvider.getText(to);\n\t\tfinal URI uri = EcoreUtil.getURI(to);\n\t\tfinal URI normalized = uri.isPlatformResource()?uri:uriConverter.normalize(uri);\n\n\t\tXtextHyperlink result = hyperlinkProvider.get();\n\t\tresult.setHyperlinkRegion(region);\n\t\tresult.setURI(normalized);\n\t\tresult.setHyperlinkText(hyperlinkText);\n\t\tacceptor.accept(result);\n\t}","commit_id":"0da0b65ba744732a70b4776a65a8c36233685326","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test public void testConstructor() throws Exception {\n\t\tString modelAsString =\n\t\t\t\"class Foo {\\n\"\n\t\t\t+ \"  def bar() { new Foo() }\\n\"\n\t\t\t+ \"}\";\n\t\tXtextResource resource = (XtextResource) testHelper.xtendFile(\"Foo\", modelAsString).eResource();\n\t\tIHyperlink[] hyperlinks = hyperlinkHelper.createHyperlinksByOffset(resource, modelAsString.indexOf(\"Foo\", 10), true);\n\t\tassertEquals(1, hyperlinks.length);\n\t\tassertEquals(\"Foo\", hyperlinks[0].getHyperlinkText());\n\t}","id":45091,"modified_method":"@Test public void testConstructor() throws Exception {\n\t\tString modelAsString =\n\t\t\t\"class Foo {\\n\"\n\t\t\t+ \"  def bar() { new Foo() }\\n\"\n\t\t\t+ \"}\";\n\t\tXtextResource resource = (XtextResource) testHelper.xtendFile(\"Foo\", modelAsString).eResource();\n\t\tIHyperlink[] hyperlinks = hyperlinkHelper.createHyperlinksByOffset(resource, modelAsString.indexOf(\"Foo\", 10), true);\n\t\tassertEquals(1, hyperlinks.length);\n\t\tassertEquals(\"Foo\", hyperlinks[0].getHyperlinkText());\n\t\tassertTrue(((XtextHyperlink)hyperlinks[0]).getURI().isPlatformResource());\n\t}","commit_id":"0da0b65ba744732a70b4776a65a8c36233685326","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test public void testPlainMethod() throws Exception {\n\t\tString modelAsString = \"class Foo {\\n\"\n\t\t\t\t+ \"  def bar() { foo() }\\n\"\n\t\t\t\t+ \"  def foo() { null }\\n\"\n\t\t\t\t+ \"}\";\n\t\tXtextResource resource = (XtextResource) testHelper.xtendFile(\"Foo\", modelAsString).eResource();\n\t\tIHyperlink[] hyperlinks = hyperlinkHelper.createHyperlinksByOffset(resource, modelAsString.indexOf(\"foo\"), true);\n\t\tassertEquals(1, hyperlinks.length);\n\t\tassertEquals(\"foo() : Object\", hyperlinks[0].getHyperlinkText());\n\t}","id":45092,"modified_method":"@Test public void testPlainMethod() throws Exception {\n\t\tString modelAsString = \"class Foo {\\n\"\n\t\t\t\t+ \"  def bar() { foo() }\\n\"\n\t\t\t\t+ \"  def foo() { null }\\n\"\n\t\t\t\t+ \"}\";\n\t\tXtextResource resource = (XtextResource) testHelper.xtendFile(\"Foo\", modelAsString).eResource();\n\t\tIHyperlink[] hyperlinks = hyperlinkHelper.createHyperlinksByOffset(resource, modelAsString.indexOf(\"foo\"), true);\n\t\tassertEquals(1, hyperlinks.length);\n\t\tassertEquals(\"foo() : Object\", hyperlinks[0].getHyperlinkText());\n\t\tassertTrue(((XtextHyperlink)hyperlinks[0]).getURI().isPlatformResource());\n\t}","commit_id":"0da0b65ba744732a70b4776a65a8c36233685326","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test public void testDispatchMethod() throws Exception {\n\t\tString modelAsString = \"class Foo {\\n\"\n\t\t\t\t+ \"  def bar() { foo(new Object()) }\\n\"\n\t\t\t\t+ \"  def dispatch foo(Object o) { null }\\n\"\n\t\t\t\t+ \"  def dispatch foo(String s) { null }\\n\"\n\t\t\t\t+ \"  def dispatch foo(Number n) { null }\\n\"\n\t\t\t\t+ \"}\";\n\t\tXtextResource resource = (XtextResource) testHelper.xtendFile(\"Foo\", modelAsString).eResource();\n\t\tIHyperlink[] hyperlinks = hyperlinkHelper.createHyperlinksByOffset(resource, modelAsString.indexOf(\"foo\"), true);\n\t\tassertEquals(3, hyperlinks.length);\n\t\tassertEquals(\"foo(Number) : Object\", hyperlinks[0].getHyperlinkText());\n\t\tassertEquals(\"foo(String) : Object\", hyperlinks[1].getHyperlinkText());\n\t\tassertEquals(\"foo(Object) : Object\", hyperlinks[2].getHyperlinkText());\n\t}","id":45093,"modified_method":"@Test public void testDispatchMethod() throws Exception {\n\t\tString modelAsString = \"class Foo {\\n\"\n\t\t\t\t+ \"  def bar() { foo(new Object()) }\\n\"\n\t\t\t\t+ \"  def dispatch foo(Object o) { null }\\n\"\n\t\t\t\t+ \"  def dispatch foo(String s) { null }\\n\"\n\t\t\t\t+ \"  def dispatch foo(Number n) { null }\\n\"\n\t\t\t\t+ \"}\";\n\t\tXtextResource resource = (XtextResource) testHelper.xtendFile(\"Foo\", modelAsString).eResource();\n\t\tIHyperlink[] hyperlinks = hyperlinkHelper.createHyperlinksByOffset(resource, modelAsString.indexOf(\"foo\"), true);\n\t\tassertEquals(3, hyperlinks.length);\n\t\tassertEquals(\"foo(Number) : Object\", hyperlinks[0].getHyperlinkText());\n\t\tassertTrue(((XtextHyperlink)hyperlinks[0]).getURI().isPlatformResource());\n\t\tassertEquals(\"foo(String) : Object\", hyperlinks[1].getHyperlinkText());\n\t\tassertTrue(((XtextHyperlink)hyperlinks[1]).getURI().isPlatformResource());\n\t\tassertEquals(\"foo(Object) : Object\", hyperlinks[2].getHyperlinkText());\n\t\tassertTrue(((XtextHyperlink)hyperlinks[2]).getURI().isPlatformResource());\n\t}","commit_id":"0da0b65ba744732a70b4776a65a8c36233685326","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n   protected void prepareResources()\n   {\n      seam.reset();\n      seam.ignoreNonResolvable()\n            .use(\"session\", getSession())\n            .use(\"identity\", mockIdentity)\n            .useImpl(LocaleServiceImpl.class)\n            .useImpl(CopyTransServiceImpl.class)\n            .useImpl(DocumentServiceImpl.class)\n            .useImpl(TranslationServiceImpl.class);\n\n      SourceDocResourceService sourceDocResourceService = seam.autowire(SourceDocResourceService.class);\n      TranslatedDocResourceService translatedDocResourceService = seam.autowire(TranslatedDocResourceService.class);\n\n      resources.add(sourceDocResourceService);\n      resources.add(translatedDocResourceService);\n   }","id":45094,"modified_method":"@Override\n   protected void prepareResources()\n   {\n      seam.reset();\n      seam.ignoreNonResolvable()\n            .use(\"entityManager\", getEm())\n            .use(\"session\", getSession())\n            .use(\"identity\", mockIdentity)\n            .useImpl(LocaleServiceImpl.class)\n            .useImpl(CopyTransServiceImpl.class)\n            .useImpl(DocumentServiceImpl.class)\n            .useImpl(TranslationServiceImpl.class);\n\n      SourceDocResourceService sourceDocResourceService = seam.autowire(SourceDocResourceService.class);\n      TranslatedDocResourceService translatedDocResourceService = seam.autowire(TranslatedDocResourceService.class);\n\n      resources.add(sourceDocResourceService);\n      resources.add(translatedDocResourceService);\n   }","commit_id":"a68e74aee86229c6848662ef4b074e68f647be73","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n    public final void prepareRestEasyFramework() {\n\n        Dispatcher dispatcher = MockDispatcherFactory.createDispatcher();\n        prepareSeamAutowire();\n        prepareAccount();\n        prepareResources();\n        prepareExceptionMappers();\n        prepareProviders();\n\n        // register resources\n        for (Object obj : resources) {\n            ResourceFactory factory = new MockResourceFactory(obj);\n            dispatcher.getRegistry().addResourceFactory(factory);\n        }\n\n        // register Exception Mappers\n        for (Class<? extends ExceptionMapper<? extends Throwable>> mapper : exceptionMappers) {\n            dispatcher.getProviderFactory().addExceptionMapper(mapper);\n        }\n\n        // register Providers\n        for (Class<?> provider : providers) {\n            dispatcher.getProviderFactory().registerProvider(provider);\n        }\n\n        // register Provider instances\n        for (Object providerInstance : providerInstances) {\n            dispatcher.getProviderFactory().registerProviderInstance(\n                    providerInstance);\n        }\n\n        InMemoryClientExecutor executor =\n                new InMemoryClientExecutor(dispatcher);\n        executor.setBaseUri(MOCK_BASE_URI);\n        clientRequestFactory =\n                new ClientRequestFactory(executor, MOCK_BASE_URI);\n\n    }","id":45095,"modified_method":"@BeforeMethod\n    public final void prepareRestEasyFramework() {\n        MockitoAnnotations.initMocks(this);\n        when(jndiBackedConfig.getEnabledAuthenticationPolicies()).thenReturn(\n                Sets.newHashSet(AuthenticationType.INTERNAL.name()));\n        Dispatcher dispatcher = MockDispatcherFactory.createDispatcher();\n        prepareSeamAutowire();\n        prepareAccount();\n        prepareResources();\n        prepareExceptionMappers();\n        prepareProviders();\n\n        // register resources\n        for (Object obj : resources) {\n            ResourceFactory factory = new MockResourceFactory(obj);\n            dispatcher.getRegistry().addResourceFactory(factory);\n        }\n\n        // register Exception Mappers\n        for (Class<? extends ExceptionMapper<? extends Throwable>> mapper : exceptionMappers) {\n            dispatcher.getProviderFactory().addExceptionMapper(mapper);\n        }\n\n        // register Providers\n        for (Class<?> provider : providers) {\n            dispatcher.getProviderFactory().registerProvider(provider);\n        }\n\n        // register Provider instances\n        for (Object providerInstance : providerInstances) {\n            dispatcher.getProviderFactory().registerProviderInstance(\n                    providerInstance);\n        }\n\n        InMemoryClientExecutor executor =\n                new InMemoryClientExecutor(dispatcher);\n        executor.setBaseUri(MOCK_BASE_URI);\n        clientRequestFactory =\n                new ClientRequestFactory(executor, MOCK_BASE_URI);\n\n    }","commit_id":"5029d81f999686f4933a2b869372b5945352bad5","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Override this method to add custom Seam autowire preparations.\n     */\n    protected void prepareSeamAutowire() {\n        seamAutowire.reset().ignoreNonResolvable();\n    }","id":45096,"modified_method":"/**\n     * Override this method to add custom Seam autowire preparations.\n     */\n    protected void prepareSeamAutowire() {\n        seamAutowire\n                .reset()\n                .ignoreNonResolvable()\n                .use(SeamAutowire.getComponentName(JndiBackedConfig.class),\n                        jndiBackedConfig);\n    }","commit_id":"5029d81f999686f4933a2b869372b5945352bad5","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void canUploadExistingDocument() throws IOException\n   {\n      conf = defaultUpload().existingDocument(new HDocument()).build();\n      mockRequiredServices();\n      response = sourceUpload.tryUploadSourceFile(conf.id, conf.uploadForm);\n      assertResponseHasStatus(OK);\n      assertThat(responseEntity().getAcceptedChunks(), is(1));\n      assertThat(responseEntity().isExpectingMore(), is(false));\n      assertThat(responseEntity().getSuccessMessage(),\n            is(\"Upload of new version of source document successful.\"));\n      assertThat(responseEntity().getErrorMessage(), is(nullValue()));\n   }","id":45097,"modified_method":"public void canUploadExistingDocument() throws IOException\n   {\n      conf = defaultUpload().existingDocument(new HDocument()).build();\n      mockRequiredServices();\n      when(documentUploadUtil.isNewDocument(conf.id)).thenReturn(false);\n\n      response = sourceUpload.tryUploadSourceFile(conf.id, conf.uploadForm);\n      assertResponseHasStatus(OK);\n      assertThat(responseEntity().getAcceptedChunks(), is(1));\n      assertThat(responseEntity().isExpectingMore(), is(false));\n      assertThat(responseEntity().getSuccessMessage(),\n            is(\"Upload of new version of source document successful.\"));\n      assertThat(responseEntity().getErrorMessage(), is(nullValue()));\n   }","commit_id":"fbc88bd162d4814d67ec3a824ceba5a0c991845f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@AfterMethod\n   public void clearResponse()\n   {\n      response = null;\n   }","id":45098,"modified_method":"@AfterMethod\n   public void clearResponse()\n   {\n      response = null;\n      conf = null;\n   }","commit_id":"fbc88bd162d4814d67ec3a824ceba5a0c991845f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n   public void beforeTest()\n   {\n      MockitoAnnotations.initMocks(this);\n      seam.reset();\n      seam.ignoreNonResolvable()\n            .use(\"identity\", identity)\n            .use(\"projectIterationDAO\", projectIterationDAO)\n            .use(\"translationFileServiceImpl\", translationFileService)\n            .use(\"documentServiceImpl\", documentService)\n            .use(\"documentDAO\", documentDAO)\n            .use(\"filePersistService\", filePersistService)\n            .allowCycles();\n\n      sourceUpload = seam.autowire(SourceDocumentUpload.class);\n   }","id":45099,"modified_method":"@BeforeMethod\n   public void beforeTest()\n   {\n      MockitoAnnotations.initMocks(this);\n      seam.reset();\n      seam.ignoreNonResolvable()\n            .use(\"documentUploadUtil\", documentUploadUtil)\n            .use(\"identity\", identity)\n            .use(\"projectIterationDAO\", projectIterationDAO)\n            .use(\"translationFileServiceImpl\", translationFileService)\n            .use(\"documentServiceImpl\", documentService)\n            .use(\"documentDAO\", documentDAO)\n            .use(\"filePersistService\", filePersistService)\n            .allowCycles();\n\n      sourceUpload = seam.autowire(SourceDocumentUpload.class);\n   }","commit_id":"fbc88bd162d4814d67ec3a824ceba5a0c991845f","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void canUploadNewDocument() throws IOException\n   {\n      conf = defaultUpload().build();\n      mockRequiredServices();\n      response = sourceUpload.tryUploadSourceFile(conf.id, conf.uploadForm);\n      assertResponseHasStatus(CREATED);\n      assertThat(responseEntity().getAcceptedChunks(), is(1));\n      assertThat(responseEntity().isExpectingMore(), is(false));\n      assertThat(responseEntity().getSuccessMessage(),\n            is(\"Upload of new source document successful.\"));\n      assertThat(responseEntity().getErrorMessage(), is(nullValue()));\n   }","id":45100,"modified_method":"public void canUploadNewDocument() throws IOException\n   {\n      conf = defaultUpload().build();\n      mockRequiredServices();\n      when(documentUploadUtil.isNewDocument(conf.id)).thenReturn(true);\n\n      response = sourceUpload.tryUploadSourceFile(conf.id, conf.uploadForm);\n      assertThat(responseEntity().getSuccessMessage(),\n            is(\"Upload of new source document successful.\"));\n      assertResponseHasStatus(CREATED);\n      assertThat(responseEntity().getAcceptedChunks(), is(1));\n      assertThat(responseEntity().isExpectingMore(), is(false));\n      assertThat(responseEntity().getErrorMessage(), is(nullValue()));\n   }","commit_id":"fbc88bd162d4814d67ec3a824ceba5a0c991845f","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void mockRequiredServices() throws IOException\n   {\n      mockLoggedIn();\n      mockProjectAndVersionStatus(conf);\n      when(identity.hasPermission(\"import-template\", projectIteration)).thenReturn(conf.hasImportTemplatePermission);\n      when(translationFileService.hasAdapterFor(DocumentType.PLAIN_TEXT)).thenReturn(conf.plaintextAdapterAvailable);\n      ZanataCredentials creds = new ZanataCredentials();\n      creds.setUsername(\"johnsmith\");\n      when(identity.getCredentials()).thenReturn(creds);\n      File someFile = File.createTempFile(\"tests\", \"something\");\n      when(translationFileService.persistToTempFile(Matchers.<InputStream> any())).thenReturn(someFile);\n      when(documentDAO.getAdapterParams(conf.projectSlug, conf.versionSlug, conf.docId))\n            .thenReturn(Optional.fromNullable(conf.storedParams));\n      when(documentDAO.addRawDocument(Matchers.<HDocument> any(), persistedRawDocument.capture()))\n            .thenReturn(new HRawDocument());\n      when(documentDAO.getByProjectIterationAndDocId(conf.projectSlug, conf.versionSlug,\n            conf.docId)).thenReturn(conf.existingDocument);\n      Resource document = new Resource();\n      when(translationFileService.parseUpdatedAdapterDocumentFile(\n            Matchers.<URI> any(), eq(conf.docId), eq(conf.fileType), paramCaptor.capture()))\n            .thenReturn(document);\n      when(documentService.saveDocument(eq(conf.projectSlug), eq(conf.versionSlug), Matchers.<Resource> any(),\n            Matchers.anySetOf(String.class), Matchers.anyBoolean()))\n            .thenReturn(new HDocument());\n   }","id":45101,"modified_method":"private void mockRequiredServices() throws IOException\n   {\n      mockProjectAndVersionStatus();\n      mockHasUploadPermission();\n      mockHasPlainTextAdapter();\n\n      ZanataCredentials creds = new ZanataCredentials();\n      creds.setUsername(\"johnsmith\");\n      when(identity.getCredentials()).thenReturn(creds);\n\n      File someFile = File.createTempFile(\"tests\", \"something\");\n      when(documentUploadUtil.persistTempFileFromUpload(conf.uploadForm)).thenReturn(someFile);\n\n      when(documentDAO.getAdapterParams(conf.projectSlug, conf.versionSlug, conf.docId))\n            .thenReturn(Optional.fromNullable(conf.storedParams));\n      when(documentDAO.addRawDocument(Matchers.<HDocument> any(), persistedRawDocument.capture()))\n            .thenReturn(new HRawDocument());\n      when(documentDAO.getByProjectIterationAndDocId(conf.projectSlug, conf.versionSlug,\n            conf.docId)).thenReturn(conf.existingDocument);\n      Resource document = new Resource();\n      when(translationFileService.parseUpdatedAdapterDocumentFile(\n            Matchers.<URI> any(), eq(conf.docId), eq(conf.fileType), paramCaptor.capture()))\n            .thenReturn(document);\n      when(documentService.saveDocument(eq(conf.projectSlug), eq(conf.versionSlug), Matchers.<Resource> any(),\n            Matchers.anySetOf(String.class), Matchers.anyBoolean()))\n            .thenReturn(new HDocument());\n   }","commit_id":"fbc88bd162d4814d67ec3a824ceba5a0c991845f","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void testAbortHelper(boolean earlyException, boolean offline) throws Exception\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF);\n        truncate(cfs);\n        SSTableReader s = writeFile(cfs, 1000);\n        if (!offline)\n            cfs.addSSTable(s);\n        Set<SSTableReader> compacting = Sets.newHashSet(s);\n        cfs.getDataTracker().markCompacting(compacting);\n        SSTableRewriter rewriter = new SSTableRewriter(cfs, compacting, 1000, offline, 10000000);\n        SSTableWriter w = getWriter(cfs, s.descriptor.directory);\n        rewriter.switchWriter(w);\n        try (ISSTableScanner scanner = compacting.iterator().next().getScanner();\n             CompactionController controller = new CompactionController(cfs, compacting, 0))\n        {\n            while (scanner.hasNext())\n            {\n                rewriter.append(new LazilyCompactedRow(controller, Arrays.asList(scanner.next())));\n                if (rewriter.currentWriter().getOnDiskFilePointer() > 25000000)\n                {\n                    rewriter.switchWriter(getWriter(cfs, s.descriptor.directory));\n                }\n            }\n            try\n            {\n                rewriter.finishAndThrow(earlyException);\n            }\n            catch (Throwable t)\n            {\n                rewriter.abort();\n            }\n        }\n        finally\n        {\n            cfs.getDataTracker().unmarkCompacting(compacting);\n        }\n        Thread.sleep(1000);\n        int filecount = assertFileCounts(s.descriptor.directory.list(), 0, 0);\n        assertEquals(filecount, 1);\n        if (!offline)\n        {\n            assertEquals(1, cfs.getSSTables().size());\n            validateCFS(cfs);\n        }\n        truncate(cfs);\n        filecount = assertFileCounts(s.descriptor.directory.list(), 0, 0);\n        if (offline)\n        {\n            s.selfRef().release();\n            // the file is not added to the CFS, therefor not truncated away above\n            assertEquals(1, filecount);\n            for (File f : s.descriptor.directory.listFiles())\n            {\n                f.delete();\n            }\n            filecount = assertFileCounts(s.descriptor.directory.list(), 0, 0);\n        }\n\n        assertEquals(0, filecount);\n        truncate(cfs);\n    }","id":45102,"modified_method":"private void testAbortHelper(boolean earlyException, boolean offline) throws Exception\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF);\n        truncate(cfs);\n        SSTableReader s = writeFile(cfs, 1000);\n        if (!offline)\n            cfs.addSSTable(s);\n        Set<SSTableReader> compacting = Sets.newHashSet(s);\n        cfs.getDataTracker().markCompacting(compacting);\n        SSTableRewriter rewriter = new SSTableRewriter(cfs, compacting, 1000, offline, 10000000);\n        SSTableWriter w = getWriter(cfs, s.descriptor.directory);\n        rewriter.switchWriter(w);\n        try (ISSTableScanner scanner = compacting.iterator().next().getScanner();\n             CompactionController controller = new CompactionController(cfs, compacting, 0))\n        {\n            while (scanner.hasNext())\n            {\n                rewriter.append(new LazilyCompactedRow(controller, Arrays.asList(scanner.next())));\n                if (rewriter.currentWriter().getOnDiskFilePointer() > 25000000)\n                {\n                    rewriter.switchWriter(getWriter(cfs, s.descriptor.directory));\n                }\n            }\n            try\n            {\n                rewriter.finishAndThrow(earlyException);\n            }\n            catch (Throwable t)\n            {\n                rewriter.abort();\n            }\n        }\n        finally\n        {\n            cfs.getDataTracker().unmarkCompacting(compacting);\n        }\n        Thread.sleep(1000);\n        int filecount = assertFileCounts(s.descriptor.directory.list(), 0, 0);\n        assertEquals(filecount, 1);\n        if (!offline)\n        {\n            assertEquals(1, cfs.getSSTables().size());\n            validateCFS(cfs);\n            truncate(cfs);\n        }\n        else\n        {\n            assertEquals(0, cfs.getSSTables().size());\n            cfs.truncateBlocking();\n        }\n        filecount = assertFileCounts(s.descriptor.directory.list(), 0, 0);\n        if (offline)\n        {\n            s.selfRef().release();\n            // the file is not added to the CFS, therefor not truncated away above\n            assertEquals(1, filecount);\n            for (File f : s.descriptor.directory.listFiles())\n            {\n                f.delete();\n            }\n            filecount = assertFileCounts(s.descriptor.directory.list(), 0, 0);\n        }\n\n        assertEquals(0, filecount);\n        truncate(cfs);\n    }","commit_id":"aa8a7b5576417c0469417eace131f270afc29923","url":"https://github.com/apache/cassandra"},{"original_method":"private void truncate(long spHandle)\n    {\n        // MIN signals no truncation work to do.\n        if (spHandle == Long.MIN_VALUE) {\n            return;\n        }\n\n        m_truncationPoint = spHandle;\n        while (!m_log.isEmpty()) {\n            if (m_log.peek().m_handle <= m_truncationPoint) {\n                m_log.poll();\n                continue;\n            }\n            break;\n        }\n    }","id":45103,"modified_method":"private void truncate(long mpHandle, long spHandle)\n    {\n        // MIN signals no truncation work to do.\n        if (spHandle == Long.MIN_VALUE && mpHandle == Long.MIN_VALUE) {\n            return;\n        }\n\n        Iterator<RepairLog.Item> it = m_log.iterator();\n        while (it.hasNext()) {\n            RepairLog.Item item = it.next();\n            if (item.isSP() && item.m_handle <= spHandle) {\n                it.remove();\n            }\n            else if (item.isMP() && item.m_handle <= mpHandle) {\n                it.remove();\n            }\n        }\n    }","commit_id":"f0cd449a4b328778a9fc7906f92e7bb1380b8586","url":"https://github.com/VoltDB/voltdb"},{"original_method":"RepairLog()\n    {\n        m_log = new LinkedList<Item>();\n    }","id":45104,"modified_method":"RepairLog()\n    {\n        m_log = new ArrayList<Item>();\n    }","commit_id":"f0cd449a4b328778a9fc7906f92e7bb1380b8586","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void setLeaderState(boolean isLeader)\n    {\n        m_isLeader = isLeader;\n        // If we're the leader, wipe out the old repair log.\n        // This call to setLeaderState() to promote us to the leader shouldn't\n        // happen until after log repair is complete.\n        if (m_isLeader) {\n            truncate(Long.MAX_VALUE);\n        }\n    }","id":45105,"modified_method":"void setLeaderState(boolean isLeader)\n    {\n        m_isLeader = isLeader;\n        // If we're the leader, wipe out the old repair log.\n        // This call to setLeaderState() to promote us to the leader shouldn't\n        // happen until after log repair is complete.\n        if (m_isLeader) {\n            truncate(Long.MAX_VALUE, Long.MAX_VALUE);\n        }\n    }","commit_id":"f0cd449a4b328778a9fc7906f92e7bb1380b8586","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void deliver(VoltMessage msg)\n    {\n        if (!m_isLeader && msg instanceof Iv2InitiateTaskMessage) {\n            final Iv2InitiateTaskMessage m = (Iv2InitiateTaskMessage)msg;\n            truncate(m.getTruncationHandle());\n            m_lastSpHandle = m.getSpHandle();\n            m_log.offer(new Item(m, m.getSpHandle()));\n        }\n    }","id":45106,"modified_method":"public void deliver(VoltMessage msg)\n    {\n        if (msg instanceof FragmentTaskMessage) {\n            final FragmentTaskMessage m = (FragmentTaskMessage)msg;\n            truncate(m.getTruncationHandle(), Long.MIN_VALUE);\n            m_log.add(new Item(IS_MP, m, m.getTxnId()));\n        }\n        if (!m_isLeader && msg instanceof Iv2InitiateTaskMessage) {\n            final Iv2InitiateTaskMessage m = (Iv2InitiateTaskMessage)msg;\n            m_lastSpHandle = m.getSpHandle();\n            truncate(Long.MIN_VALUE, m.getTruncationHandle());\n            m_log.add(new Item(IS_SP, m, m.getSpHandle()));\n        }\n    }","commit_id":"f0cd449a4b328778a9fc7906f92e7bb1380b8586","url":"https://github.com/VoltDB/voltdb"},{"original_method":"Item(VoltMessage msg, long handle)\n        {\n            m_msg = msg;\n            m_handle = handle;\n        }","id":45107,"modified_method":"Item(boolean type, VoltMessage msg, long handle)\n        {\n            m_type = type;\n            m_msg = msg;\n            m_handle = handle;\n        }","commit_id":"f0cd449a4b328778a9fc7906f92e7bb1380b8586","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Constructor. Using a 'li'-tag as default root element.<p>\n     * \n     * @param infoBean bean holding the item information\n     */\n    public CmsListItemWidget(CmsListInfoBean infoBean) {\n\n        initWidget(uiBinder.createAndBindUi(this));\n        m_handlerRegistrations = new ArrayList<HandlerRegistration>();\n        m_backgroundStyle = new CmsStyleVariable(this);\n        m_subtitleSuffix = new CmsLabel();\n        m_subtitleSuffix.addStyleName(I_CmsLayoutBundle.INSTANCE.generalCss().inlineBlock());\n        init(infoBean);\n    }","id":45108,"modified_method":"/**\n     * Constructor. Using a 'li'-tag as default root element.<p>\n     * \n     * @param infoBean bean holding the item information\n     */\n    public CmsListItemWidget(CmsListInfoBean infoBean) {\n\n        initWidget(uiBinder.createAndBindUi(this));\n        m_handlerRegistrations = new ArrayList<HandlerRegistration>();\n        m_backgroundStyle = new CmsStyleVariable(this);\n        m_shortExtraInfoLabel = new InlineLabel();\n        init(infoBean);\n    }","commit_id":"11eb0b69d1a6a3f3cd3cbdd508eed9e80537e5ff","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        m_childWidth = widgetWidth;\n        m_tmPrefix = textMetricsPrefix;\n        int width = widgetWidth - 4; // just to be on the save side\n        if (m_openClose != null) {\n            width -= 16;\n        }\n        if (m_iconPanel.isVisible()) {\n            width -= 32;\n        }\n        if (width < 0) {\n            // IE fails with a JS error if the width is negative \n            width = 0;\n        }\n        m_title.truncate(textMetricsPrefix + TM_TITLE, width - 10);\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_subtitleSuffix.getText())) {\n            m_subtitleSuffix.getElement().getStyle().clearWidth();\n            int suffixWidth = m_subtitleSuffix.getOffsetWidth();\n            CmsDebugLog.getInstance().printLine(\"suffix '\" + m_subtitleSuffix.getText() + \"' width: \" + suffixWidth);\n            if (suffixWidth <= 0) {\n                // in case the suffix is not rendered yet and no width is available, use truncation\n                suffixWidth = 100;\n                m_subtitleSuffix.truncate(textMetricsPrefix + \"_STSUFFIX\", suffixWidth);\n            }\n            if (suffixWidth > 200) {\n                suffixWidth = 200;\n                m_subtitleSuffix.truncate(textMetricsPrefix + \"_STSUFFIX\", suffixWidth);\n            }\n            m_subtitle.truncate(textMetricsPrefix + TM_SUBTITLE, width - suffixWidth - 10);\n        } else {\n            m_subtitle.truncate(textMetricsPrefix + TM_SUBTITLE, width - 10);\n        }\n        for (Widget addInfo : m_additionalInfo) {\n            ((AdditionalInfoItem)addInfo).truncate(textMetricsPrefix, widgetWidth - 10);\n        }\n    }","id":45109,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(final String textMetricsPrefix, final int widgetWidth) {\n\n        m_childWidth = widgetWidth;\n        m_tmPrefix = textMetricsPrefix;\n        int width = widgetWidth - 4; // just to be on the save side\n        if (m_openClose != null) {\n            width -= 16;\n        }\n        if (m_iconPanel.isVisible()) {\n            width -= 32;\n        }\n        if (width < 0) {\n            // IE fails with a JS error if the width is negative \n            width = 0;\n        }\n        m_titleBox.setWidth(Math.max(0, width - 30) + \"px\");\n        m_subtitle.truncate(textMetricsPrefix + TM_SUBTITLE, width);\n        for (Widget addInfo : m_additionalInfo) {\n            ((AdditionalInfoItem)addInfo).truncate(textMetricsPrefix, widgetWidth - 10);\n        }\n    }","commit_id":"11eb0b69d1a6a3f3cd3cbdd508eed9e80537e5ff","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Internal method which is called when the user clicks on an editable title field.<p>\n     */\n    protected void editTitle() {\n\n        m_title.setVisible(false);\n        final TextBox box = new TextBox();\n        box.setText(m_title.getText());\n        box.getElement().setAttribute(\"size\", \"45\");\n        box.addStyleName(I_CmsInputLayoutBundle.INSTANCE.inputCss().labelInput());\n        box.addStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().titleInput());\n        final String originalTitle = m_title.getText();\n        // wrap the boolean flag in an array so we can change it from the event handlers \n        final boolean[] checked = new boolean[] {false};\n\n        box.addBlurHandler(new BlurHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.BlurHandler#onBlur(com.google.gwt.event.dom.client.BlurEvent)\n             */\n            public void onBlur(BlurEvent event) {\n\n                if (checked[0]) {\n                    return;\n                }\n\n                onEditTitleTextBox(box);\n                checked[0] = true;\n            }\n        });\n\n        box.addKeyPressHandler(new KeyPressHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.KeyPressHandler#onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent)\n             */\n            public void onKeyPress(KeyPressEvent event) {\n\n                if (checked[0]) {\n                    return;\n                }\n\n                int keycode = event.getNativeEvent().getKeyCode();\n\n                if ((keycode == 10) || (keycode == 13)) {\n                    onEditTitleTextBox(box);\n                    checked[0] = true;\n                }\n                if (keycode == 27) {\n                    box.setText(originalTitle);\n                    onEditTitleTextBox(box);\n                    checked[0] = true;\n\n                }\n            }\n        });\n        m_titleRow.insert(box, 1);\n        box.setFocus(true);\n    }","id":45110,"modified_method":"/**\n     * Internal method which is called when the user clicks on an editable title field.<p>\n     */\n    protected void editTitle() {\n\n        m_title.setVisible(false);\n        final TextBox box = new TextBox();\n        box.setText(m_title.getText());\n        box.getElement().setAttribute(\"size\", \"45\");\n        box.addStyleName(I_CmsInputLayoutBundle.INSTANCE.inputCss().labelInput());\n        box.addStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().titleInput());\n        final String originalTitle = m_title.getText();\n        // wrap the boolean flag in an array so we can change it from the event handlers \n        final boolean[] checked = new boolean[] {false};\n\n        box.addBlurHandler(new BlurHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.BlurHandler#onBlur(com.google.gwt.event.dom.client.BlurEvent)\n             */\n            public void onBlur(BlurEvent event) {\n\n                if (checked[0]) {\n                    return;\n                }\n\n                onEditTitleTextBox(box);\n                checked[0] = true;\n            }\n        });\n\n        box.addKeyPressHandler(new KeyPressHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.KeyPressHandler#onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent)\n             */\n            public void onKeyPress(KeyPressEvent event) {\n\n                if (checked[0]) {\n                    return;\n                }\n\n                int keycode = event.getNativeEvent().getKeyCode();\n\n                if ((keycode == 10) || (keycode == 13)) {\n                    onEditTitleTextBox(box);\n                    checked[0] = true;\n                }\n                if (keycode == 27) {\n                    box.setText(originalTitle);\n                    onEditTitleTextBox(box);\n                    checked[0] = true;\n\n                }\n            }\n        });\n        m_titleBox.insert(box, 2);\n        box.setFocus(true);\n    }","commit_id":"11eb0b69d1a6a3f3cd3cbdd508eed9e80537e5ff","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Ensures the open close button for the additional info list is present.<p>\n     */\n    protected void ensureOpenCloseAdditionalInfo() {\n\n        if (m_openClose == null) {\n            m_openClose = new CmsPushButton(\n                I_CmsImageBundle.INSTANCE.style().triangleRight(),\n                I_CmsImageBundle.INSTANCE.style().triangleDown());\n            m_openClose.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n            m_titleRow.insert(m_openClose, 0);\n            m_openClose.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    setAdditionalInfoVisible(!getElement().getClassName().contains(CmsListItemWidget.OPENCLASS));\n                    CmsDomUtil.resizeAncestor(CmsListItemWidget.this);\n                }\n            });\n        }\n    }","id":45111,"modified_method":"/**\n     * Ensures the open close button for the additional info list is present.<p>\n     */\n    protected void ensureOpenCloseAdditionalInfo() {\n\n        if (m_openClose == null) {\n            m_openClose = new CmsPushButton(\n                I_CmsImageBundle.INSTANCE.style().triangleRight(),\n                I_CmsImageBundle.INSTANCE.style().triangleDown());\n            m_openClose.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n            m_titleBox.insert(m_openClose, 0);\n            m_openClose.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    setAdditionalInfoVisible(!getElement().getClassName().contains(CmsListItemWidget.OPENCLASS));\n                    CmsDomUtil.resizeAncestor(CmsListItemWidget.this);\n                }\n            });\n        }\n    }","commit_id":"11eb0b69d1a6a3f3cd3cbdd508eed9e80537e5ff","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Default constructor.<p>\n     * \n     * @param entry the sitemap entry\n     */\n    public CmsSitemapTreeItem(CmsClientSitemapEntry entry) {\n\n        super(generateItemWidget(entry), false);\n        m_entryId = entry.getId();\n        m_decoratedPanel.addDecorationBoxStyle(CSS.sitemapEntryDecoration());\n        m_detailPageLabelTitleGenerator = new DetailPageLabelTitleGenerator();\n        getListItemWidget().setUnselectable();\n        getListItemWidget().getSubTitleSuffix().setTitleGenerator(m_detailPageLabelTitleGenerator);\n        getListItemWidget().addOpenHandler(new OpenHandler<CmsListItemWidget>() {\n\n            public void onOpen(OpenEvent<CmsListItemWidget> event) {\n\n                CmsSitemapView.getInstance().getController().updateSingleEntry(m_entryId);\n            }\n        });\n        getListItemWidget().addIconClickHandler(new ClickHandler() {\n\n            public void onClick(ClickEvent event) {\n\n                CmsSitemapController controller = CmsSitemapView.getInstance().getController();\n                CmsClientSitemapEntry sitemapEntry = controller.getEntryById(m_entryId);\n                if (sitemapEntry != null) {\n                    if (sitemapEntry.isSubSitemapType()) {\n                        controller.openSiteMap(sitemapEntry.getSitePath());\n                    } else if (sitemapEntry.isNavigationLevelType()) {\n                        if (!sitemapEntry.getSubEntries().isEmpty()) {\n                            CmsClientSitemapEntry subEntry = sitemapEntry.getSubEntries().get(0);\n                            if (!subEntry.isNavigationLevelType()) {\n                                controller.leaveEditor(subEntry.getSitePath());\n                                return;\n                            }\n                        }\n                        getListItemWidget().setIconTitle(\n                            Messages.get().key(Messages.GUI_NAVIGATION_LEVEL_UNKOWN_TARGET_0));\n                    } else {\n                        controller.leaveEditor(sitemapEntry.getSitePath());\n                    }\n                }\n            }\n        });\n        m_inNavigationStyle = new CmsStyleVariable(this);\n        m_openerForNonNavigationStyle = new CmsStyleVariable(m_opener);\n        getListItemWidget().addTitleStyleName(CSS.itemTitle());\n        updateInNavigation(entry);\n        m_itemsById.put(m_entryId, this);\n        setId(getName(entry.getSitePath()));\n        updateSitePath(entry.getSitePath());\n        updateDetailPageStatus();\n        updateLock(entry);\n        if (!entry.isFolderType()) {\n            hideOpeners();\n        }\n        setDropEnabled(entry.isFolderType() && !entry.hasForeignFolderLock());\n        getListItemWidget().setTitleEditHandler(new I_CmsTitleEditHandler() {\n\n            /**\n             * @see org.opencms.gwt.client.ui.CmsListItemWidget.I_CmsTitleEditHandler#handleEdit(org.opencms.gwt.client.ui.input.CmsLabel, com.google.gwt.user.client.ui.TextBox)\n             */\n            public void handleEdit(CmsLabel titleLabel, TextBox box) {\n\n                CmsClientSitemapEntry editEntry = getSitemapEntry();\n                final String newTitle = box.getText();\n                box.removeFromParent();\n                if (CmsStringUtil.isEmpty(newTitle)) {\n                    titleLabel.setVisible(true);\n                    String dialogTitle = Messages.get().key(Messages.GUI_EDIT_TITLE_ERROR_DIALOG_TITLE_0);\n                    String dialogText = Messages.get().key(Messages.GUI_TITLE_CANT_BE_EMPTY_0);\n                    CmsAlertDialog alert = new CmsAlertDialog(dialogTitle, dialogText);\n                    alert.center();\n                    return;\n                }\n                String oldTitle = editEntry.getTitle();\n                if (!oldTitle.equals(newTitle)) {\n                    CmsPropertyModification propMod = new CmsPropertyModification(\n                        editEntry.getId(),\n                        CmsClientProperty.PROPERTY_NAVTEXT,\n                        newTitle,\n                        true);\n                    final List<CmsPropertyModification> propChanges = new ArrayList<CmsPropertyModification>();\n                    propChanges.add(propMod);\n                    CmsSitemapController controller = CmsSitemapView.getInstance().getController();\n                    if (editEntry.isNew() && !editEntry.isRoot()) {\n                        String urlName = controller.ensureUniqueName(\n                            CmsResource.getParentFolder(editEntry.getSitePath()),\n                            newTitle);\n                        if (oldTitle.equals(editEntry.getPropertyValue(CmsClientProperty.PROPERTY_TITLE))) {\n                            CmsPropertyModification titleMod = new CmsPropertyModification(\n                                editEntry.getId(),\n                                CmsClientProperty.PROPERTY_TITLE,\n                                newTitle,\n                                true);\n                            propChanges.add(titleMod);\n                        }\n                        controller.editAndChangeName(editEntry, urlName, propChanges, true, CmsReloadMode.none);\n                    } else {\n                        controller.edit(editEntry, propChanges, CmsReloadMode.none);\n                    }\n                }\n                titleLabel.setVisible(true);\n            }\n        });\n    }","id":45112,"modified_method":"/**\n     * Default constructor.<p>\n     * \n     * @param entry the sitemap entry\n     */\n    public CmsSitemapTreeItem(CmsClientSitemapEntry entry) {\n\n        super(generateItemWidget(entry), false);\n        m_entryId = entry.getId();\n        m_decoratedPanel.addDecorationBoxStyle(CSS.sitemapEntryDecoration());\n        m_detailPageLabelTitleGenerator = new DetailPageLabelTitleGenerator();\n        getListItemWidget().setUnselectable();\n        getListItemWidget().addOpenHandler(new OpenHandler<CmsListItemWidget>() {\n\n            public void onOpen(OpenEvent<CmsListItemWidget> event) {\n\n                CmsSitemapView.getInstance().getController().updateSingleEntry(m_entryId);\n            }\n        });\n        getListItemWidget().addIconClickHandler(new ClickHandler() {\n\n            public void onClick(ClickEvent event) {\n\n                CmsSitemapController controller = CmsSitemapView.getInstance().getController();\n                CmsClientSitemapEntry sitemapEntry = controller.getEntryById(m_entryId);\n                if (sitemapEntry != null) {\n                    if (sitemapEntry.isSubSitemapType()) {\n                        controller.openSiteMap(sitemapEntry.getSitePath());\n                    } else if (sitemapEntry.isNavigationLevelType()) {\n                        if (!sitemapEntry.getSubEntries().isEmpty()) {\n                            CmsClientSitemapEntry subEntry = sitemapEntry.getSubEntries().get(0);\n                            if (!subEntry.isNavigationLevelType()) {\n                                controller.leaveEditor(subEntry.getSitePath());\n                                return;\n                            }\n                        }\n                        getListItemWidget().setIconTitle(\n                            Messages.get().key(Messages.GUI_NAVIGATION_LEVEL_UNKOWN_TARGET_0));\n                    } else {\n                        controller.leaveEditor(sitemapEntry.getSitePath());\n                    }\n                }\n            }\n        });\n        m_inNavigationStyle = new CmsStyleVariable(this);\n        m_openerForNonNavigationStyle = new CmsStyleVariable(m_opener);\n        getListItemWidget().addTitleStyleName(CSS.itemTitle());\n        updateInNavigation(entry);\n        m_itemsById.put(m_entryId, this);\n        setId(getName(entry.getSitePath()));\n        updateSitePath(entry.getSitePath());\n        updateDetailPageStatus();\n        updateLock(entry);\n        if (!entry.isFolderType()) {\n            hideOpeners();\n        }\n        setDropEnabled(entry.isFolderType() && !entry.hasForeignFolderLock());\n        getListItemWidget().setTitleEditHandler(new I_CmsTitleEditHandler() {\n\n            /**\n             * @see org.opencms.gwt.client.ui.CmsListItemWidget.I_CmsTitleEditHandler#handleEdit(org.opencms.gwt.client.ui.input.CmsLabel, com.google.gwt.user.client.ui.TextBox)\n             */\n            public void handleEdit(CmsLabel titleLabel, TextBox box) {\n\n                CmsClientSitemapEntry editEntry = getSitemapEntry();\n                final String newTitle = box.getText();\n                box.removeFromParent();\n                if (CmsStringUtil.isEmpty(newTitle)) {\n                    titleLabel.setVisible(true);\n                    String dialogTitle = Messages.get().key(Messages.GUI_EDIT_TITLE_ERROR_DIALOG_TITLE_0);\n                    String dialogText = Messages.get().key(Messages.GUI_TITLE_CANT_BE_EMPTY_0);\n                    CmsAlertDialog alert = new CmsAlertDialog(dialogTitle, dialogText);\n                    alert.center();\n                    return;\n                }\n                String oldTitle = editEntry.getTitle();\n                if (!oldTitle.equals(newTitle)) {\n                    CmsPropertyModification propMod = new CmsPropertyModification(\n                        editEntry.getId(),\n                        CmsClientProperty.PROPERTY_NAVTEXT,\n                        newTitle,\n                        true);\n                    final List<CmsPropertyModification> propChanges = new ArrayList<CmsPropertyModification>();\n                    propChanges.add(propMod);\n                    CmsSitemapController controller = CmsSitemapView.getInstance().getController();\n                    if (editEntry.isNew() && !editEntry.isRoot()) {\n                        String urlName = controller.ensureUniqueName(\n                            CmsResource.getParentFolder(editEntry.getSitePath()),\n                            newTitle);\n                        if (oldTitle.equals(editEntry.getPropertyValue(CmsClientProperty.PROPERTY_TITLE))) {\n                            CmsPropertyModification titleMod = new CmsPropertyModification(\n                                editEntry.getId(),\n                                CmsClientProperty.PROPERTY_TITLE,\n                                newTitle,\n                                true);\n                            propChanges.add(titleMod);\n                        }\n                        controller.editAndChangeName(editEntry, urlName, propChanges, true, CmsReloadMode.none);\n                    } else {\n                        controller.edit(editEntry, propChanges, CmsReloadMode.none);\n                    }\n                }\n                titleLabel.setVisible(true);\n            }\n        });\n    }","commit_id":"11eb0b69d1a6a3f3cd3cbdd508eed9e80537e5ff","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Updates the detail page description.<p>\n     */\n    public void updateDetailPageStatus() {\n\n        CmsDetailPageTable detailPageTable = CmsSitemapView.getInstance().getController().getDetailPageTable();\n        String type;\n        String text = null;\n        String suffixTitle = null;\n        switch (detailPageTable.getStatus(m_entryId)) {\n            case firstDetailPage:\n                type = detailPageTable.get(m_entryId).getDisplayType();\n                suffixTitle = Messages.get().key(Messages.GUI_MAIN_DETAIL_PAGE_TITLE_1, type);\n                text = \"(*\" + type + \")\";\n                break;\n            case otherDetailPage:\n                type = detailPageTable.get(m_entryId).getDisplayType();\n                suffixTitle = Messages.get().key(Messages.GUI_DETAIL_PAGE_TITLE_1, type);\n                text = \"(\" + type + \")\";\n                break;\n            case noDetailPage:\n            default:\n        }\n        m_detailPageLabelTitleGenerator.setDetailPageTitle(suffixTitle);\n        getListItemWidget().updateTruncation();\n        CmsLabel label = getListItemWidget().getSubTitleSuffix();\n        label.addStyleName(I_CmsInputLayoutBundle.INSTANCE.inputCss().subtitleSuffix());\n        getListItemWidget().setSubtitleSuffixText(text);\n    }","id":45113,"modified_method":"/**\n     * Updates the detail page description.<p>\n     */\n    public void updateDetailPageStatus() {\n\n        CmsDetailPageTable detailPageTable = CmsSitemapView.getInstance().getController().getDetailPageTable();\n        String type;\n        String text = null;\n        String suffixTitle = null;\n        switch (detailPageTable.getStatus(m_entryId)) {\n            case firstDetailPage:\n                type = detailPageTable.get(m_entryId).getDisplayType();\n                suffixTitle = Messages.get().key(Messages.GUI_MAIN_DETAIL_PAGE_TITLE_1, type);\n                text = \"(*\" + type + \")\";\n                break;\n            case otherDetailPage:\n                type = detailPageTable.get(m_entryId).getDisplayType();\n                suffixTitle = Messages.get().key(Messages.GUI_DETAIL_PAGE_TITLE_1, type);\n                text = \"(\" + type + \")\";\n                break;\n            case noDetailPage:\n            default:\n        }\n        m_detailPageLabelTitleGenerator.setDetailPageTitle(suffixTitle);\n        getListItemWidget().updateTruncation();\n        Widget label = getListItemWidget().getShortExtraInfoLabel();\n        label.addStyleName(I_CmsInputLayoutBundle.INSTANCE.inputCss().subtitleSuffix());\n        getListItemWidget().setExtraInfo(text);\n    }","commit_id":"11eb0b69d1a6a3f3cd3cbdd508eed9e80537e5ff","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n   * Configures all queues being used in this flow.\n   *\n   * @return A Multimap from flowletId to QueueName where the flowlet is a consumer of.\n   */\n  private Multimap<String, QueueName> configureQueue(Program program, FlowSpecification flowSpec) {\n    // Generate all queues specifications\n    Id.Application appId = Id.Application.from(program.getAccountId(), program.getApplicationId());\n    Table<QueueSpecificationGenerator.Node, String, Set<QueueSpecification>> queueSpecs\n      = new SimpleQueueSpecificationGenerator(appId).create(flowSpec);\n\n    // For each queue in the flow, gather a map of consumer groupId to number of instances\n    Table<QueueName, Long, Integer> queueConfigs = HashBasedTable.create();\n\n    // For storing result from flowletId to queue.\n    ImmutableSetMultimap.Builder<String, QueueName> resultBuilder = ImmutableSetMultimap.builder();\n\n    // Loop through each flowlet\n    for (Map.Entry<String, FlowletDefinition> entry : flowSpec.getFlowlets().entrySet()) {\n      String flowletId = entry.getKey();\n      long groupId = FlowUtils.generateConsumerGroupId(program, flowletId);\n      int instances = entry.getValue().getInstances();\n\n      // For each queue that the flowlet is a consumer, store the number of instances for this flowlet\n      for (QueueSpecification queueSpec : Iterables.concat(queueSpecs.column(flowletId).values())) {\n        queueConfigs.put(queueSpec.getQueueName(), groupId, instances);\n        resultBuilder.put(flowletId, queueSpec.getQueueName());\n      }\n    }\n\n    try {\n      // For each queue in the flow, configure it through QueueAdmin\n      for (Map.Entry<QueueName, Map<Long, Integer>> row : queueConfigs.rowMap().entrySet()) {\n        LOG.info(\"Queue config for {} : {}\", row.getKey(), row.getValue());\n        queueAdmin.configureGroups(row.getKey(), row.getValue());\n      }\n      return resultBuilder.build();\n    } catch (Exception e) {\n      LOG.error(\"Failed to configure queues\", e);\n      throw Throwables.propagate(e);\n    }\n  }","id":45114,"modified_method":"/**\n   * Configures all queues being used in this flow.\n   *\n   * @return A Multimap from flowletId to QueueName where the flowlet is a consumer of.\n   */\n  private Multimap<String, QueueName> configureQueue(Program program, FlowSpecification flowSpec) {\n    // Generate all queues specifications\n    Id.Application appId = Id.Application.from(program.getAccountId(), program.getApplicationId());\n    Table<QueueSpecificationGenerator.Node, String, Set<QueueSpecification>> queueSpecs\n      = new SimpleQueueSpecificationGenerator(appId).create(flowSpec);\n\n    // For each queue in the flow, gather a map of consumer groupId to number of instances\n    Table<QueueName, Long, Integer> queueConfigs = HashBasedTable.create();\n\n    // For storing result from flowletId to queue.\n    ImmutableSetMultimap.Builder<String, QueueName> resultBuilder = ImmutableSetMultimap.builder();\n\n    // Loop through each flowlet\n    for (Map.Entry<String, FlowletDefinition> entry : flowSpec.getFlowlets().entrySet()) {\n      String flowletId = entry.getKey();\n      long groupId = FlowUtils.generateConsumerGroupId(program, flowletId);\n      int instances = entry.getValue().getInstances();\n\n      // For each queue that the flowlet is a consumer, store the number of instances for this flowlet\n      for (QueueSpecification queueSpec : Iterables.concat(queueSpecs.column(flowletId).values())) {\n        queueConfigs.put(queueSpec.getQueueName(), groupId, instances);\n        resultBuilder.put(flowletId, queueSpec.getQueueName());\n      }\n    }\n\n    try {\n      // For each queue in the flow, configure it through QueueAdmin\n      for (Map.Entry<QueueName, Map<Long, Integer>> row : queueConfigs.rowMap().entrySet()) {\n        LOG.info(\"Queue config for {} : {}\", row.getKey(), row.getValue());\n        if (row.getKey().isStream()) {\n          streamAdmin.configureGroups(row.getKey(), row.getValue());\n        } else {\n          queueAdmin.configureGroups(row.getKey(), row.getValue());\n        }\n      }\n      return resultBuilder.build();\n    } catch (Exception e) {\n      LOG.error(\"Failed to configure queues\", e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  DistributedFlowProgramRunner(WeaveRunner weaveRunner, Configuration hConfig,\n                               CConfiguration cConfig, QueueAdmin queueAdmin) {\n    super(weaveRunner, hConfig, cConfig);\n    this.queueAdmin = queueAdmin;\n  }","id":45115,"modified_method":"@Inject\n  DistributedFlowProgramRunner(WeaveRunner weaveRunner, Configuration hConfig,\n                               CConfiguration cConfig, QueueAdmin queueAdmin, StreamAdmin streamAdmin) {\n    super(weaveRunner, hConfig, cConfig);\n    this.queueAdmin = queueAdmin;\n    this.streamAdmin = streamAdmin;\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     File hConfFile, File cConfFile, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    Type processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == Type.FLOW, \"Only FLOW process type is supported.\");\n\n    try {\n      boolean disableTransaction = program.getMainClass().isAnnotationPresent(DisableTransaction.class);\n\n      if (disableTransaction) {\n        LOG.info(\"Transaction is disable for flow {}.{}\", program.getApplicationId(), program.getId().getId());\n      }\n\n      FlowSpecification flowSpec = appSpec.getFlows().get(program.getName());\n      Preconditions.checkNotNull(flowSpec, \"Missing FlowSpecification for %s\", program.getName());\n\n      LOG.info(\"Configuring flowlets queues\");\n      Multimap<String, QueueName> flowletQueues = configureQueue(program, flowSpec);\n\n      // Launch flowlet program runners\n      LOG.info(\"Launching distributed flow: \" + program.getName() + \":\" + flowSpec.getName());\n\n      WeaveController controller = launcher.launch(new FlowWeaveApplication(program, flowSpec,\n                                                                            hConfFile, cConfFile, disableTransaction));\n      DistributedFlowletInstanceUpdater instanceUpdater = new DistributedFlowletInstanceUpdater(program,\n                                                                                                controller,\n                                                                                                queueAdmin,\n                                                                                                flowletQueues);\n      return new FlowWeaveProgramController(program.getName(), controller, instanceUpdater).startListen();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":45116,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     File hConfFile, File cConfFile, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    Type processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == Type.FLOW, \"Only FLOW process type is supported.\");\n\n    try {\n      boolean disableTransaction = program.getMainClass().isAnnotationPresent(DisableTransaction.class);\n\n      if (disableTransaction) {\n        LOG.info(\"Transaction is disable for flow {}.{}\", program.getApplicationId(), program.getId().getId());\n      }\n\n      FlowSpecification flowSpec = appSpec.getFlows().get(program.getName());\n      Preconditions.checkNotNull(flowSpec, \"Missing FlowSpecification for %s\", program.getName());\n\n      LOG.info(\"Configuring flowlets queues\");\n      Multimap<String, QueueName> flowletQueues = configureQueue(program, flowSpec);\n\n      // Launch flowlet program runners\n      LOG.info(\"Launching distributed flow: \" + program.getName() + \":\" + flowSpec.getName());\n\n      WeaveController controller = launcher.launch(new FlowWeaveApplication(program, flowSpec,\n                                                                            hConfFile, cConfFile, disableTransaction));\n      DistributedFlowletInstanceUpdater instanceUpdater = new DistributedFlowletInstanceUpdater(program, controller,\n                                                                                                queueAdmin, streamAdmin,\n                                                                                                flowletQueues);\n      return new FlowWeaveProgramController(program.getName(), controller, instanceUpdater).startListen();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"DistributedFlowletInstanceUpdater(Program program, WeaveController weaveController, QueueAdmin queueAdmin,\n                                    Multimap<String, QueueName> consumerQueues) {\n    this.program = program;\n    this.weaveController = weaveController;\n    this.queueAdmin = queueAdmin;\n    this.consumerQueues = consumerQueues;\n  }","id":45117,"modified_method":"DistributedFlowletInstanceUpdater(Program program, WeaveController weaveController, QueueAdmin queueAdmin,\n                                    StreamAdmin streamAdmin, Multimap<String, QueueName> consumerQueues) {\n    this.program = program;\n    this.weaveController = weaveController;\n    this.queueAdmin = queueAdmin;\n    this.streamAdmin = streamAdmin;\n    this.consumerQueues = consumerQueues;\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"void update(String flowletId, int newInstanceCount) throws Exception {\n    weaveController.sendCommand(flowletId, ProgramCommands.SUSPEND).get();\n\n    for (QueueName queueName : consumerQueues.get(flowletId)) {\n      queueAdmin.configureInstances(queueName, FlowUtils.generateConsumerGroupId(program, flowletId), newInstanceCount);\n    }\n\n    weaveController.changeInstances(flowletId, newInstanceCount).get();\n    weaveController.sendCommand(flowletId, ProgramCommands.RESUME).get();\n\n  }","id":45118,"modified_method":"void update(String flowletId, int newInstanceCount) throws Exception {\n    weaveController.sendCommand(flowletId, ProgramCommands.SUSPEND).get();\n\n    for (QueueName queueName : consumerQueues.get(flowletId)) {\n      if (queueName.isStream()) {\n        streamAdmin.configureInstances(queueName, FlowUtils.generateConsumerGroupId(program, flowletId),\n                                       newInstanceCount);\n      } else {\n        queueAdmin.configureInstances(queueName, FlowUtils.generateConsumerGroupId(program, flowletId),\n                                      newInstanceCount);\n      }\n    }\n\n    weaveController.changeInstances(flowletId, newInstanceCount).get();\n    weaveController.sendCommand(flowletId, ProgramCommands.RESUME).get();\n\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  DistributedProgramRuntimeService(ProgramRunnerFactory programRunnerFactory, WeaveRunner weaveRunner,\n                                   StoreFactory storeFactory, QueueAdmin queueAdmin,\n                                   MetricsCollectionService metricsCollectionService,\n                                   Configuration hConf, CConfiguration cConf) {\n    super(programRunnerFactory);\n    this.weaveRunner = weaveRunner;\n    this.store = storeFactory.create();\n    this.queueAdmin = queueAdmin;\n    this.resourceReporter = new ClusterResourceReporter(metricsCollectionService, hConf, cConf);\n  }","id":45119,"modified_method":"@Inject\n  DistributedProgramRuntimeService(ProgramRunnerFactory programRunnerFactory, WeaveRunner weaveRunner,\n                                   StoreFactory storeFactory, QueueAdmin queueAdmin, StreamAdmin streamAdmin,\n                                   MetricsCollectionService metricsCollectionService,\n                                   Configuration hConf, CConfiguration cConf) {\n    super(programRunnerFactory);\n    this.weaveRunner = weaveRunner;\n    this.store = storeFactory.create();\n    this.queueAdmin = queueAdmin;\n    this.streamAdmin = streamAdmin;\n    this.resourceReporter = new ClusterResourceReporter(metricsCollectionService, hConf, cConf);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"private ProgramController createController(Program program, WeaveController controller) {\n    AbstractWeaveProgramController programController = null;\n    String programId = program.getId().getId();\n\n    switch (program.getType()) {\n      case FLOW: {\n        FlowSpecification flowSpec = program.getSpecification().getFlows().get(programId);\n        DistributedFlowletInstanceUpdater instanceUpdater = new DistributedFlowletInstanceUpdater(\n          program, controller, queueAdmin, getFlowletQueues(program, flowSpec)\n        );\n        programController = new FlowWeaveProgramController(programId, controller, instanceUpdater);\n        break;\n      }\n      case PROCEDURE:\n        programController = new ProcedureWeaveProgramController(programId, controller);\n        break;\n      case MAPREDUCE:\n        programController = new MapReduceWeaveProgramController(programId, controller);\n        break;\n      case WORKFLOW:\n        programController = new WorkflowWeaveProgramController(programId, controller);\n        break;\n      case WEBAPP:\n        programController = new WebappWeaveProgramController(programId, controller);\n        break;\n    }\n    return programController == null ? null : programController.startListen();\n  }","id":45120,"modified_method":"private ProgramController createController(Program program, WeaveController controller) {\n    AbstractWeaveProgramController programController = null;\n    String programId = program.getId().getId();\n\n    switch (program.getType()) {\n      case FLOW: {\n        FlowSpecification flowSpec = program.getSpecification().getFlows().get(programId);\n        DistributedFlowletInstanceUpdater instanceUpdater = new DistributedFlowletInstanceUpdater(\n          program, controller, queueAdmin, streamAdmin, getFlowletQueues(program, flowSpec)\n        );\n        programController = new FlowWeaveProgramController(programId, controller, instanceUpdater);\n        break;\n      }\n      case PROCEDURE:\n        programController = new ProcedureWeaveProgramController(programId, controller);\n        break;\n      case MAPREDUCE:\n        programController = new MapReduceWeaveProgramController(programId, controller);\n        break;\n      case WORKFLOW:\n        programController = new WorkflowWeaveProgramController(programId, controller);\n        break;\n      case WEBAPP:\n        programController = new WebappWeaveProgramController(programId, controller);\n        break;\n    }\n    return programController == null ? null : programController.startListen();\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean exists(String name) throws Exception {\n    // NOTE: as of now, all queues stored in same table, hence name ignored.\n    return exists();\n  }","id":45121,"modified_method":"@Override\n  public boolean exists(String name) throws Exception {\n    return exists(QueueName.from(URI.create(name)));\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configureGroups(QueueName queueName, Map<Long, Integer> groupInfo) throws Exception {\n    Preconditions.checkArgument(!groupInfo.isEmpty(), \"Consumer group information must not be empty.\");\n\n    if (!exists()) {\n      create();\n    }\n\n    HTable hTable = new HTable(admin.getConfiguration(), configTableName);\n\n    try {\n      byte[] rowKey = queueName.toBytes();\n\n      // Get the whole row\n      Result result = hTable.get(new Get(rowKey));\n\n      // Generate existing groupInfo, also find smallest rowKey from existing group if there is any\n      NavigableMap<byte[], byte[]> columns = result.getFamilyMap(QueueEntryRow.COLUMN_FAMILY);\n      if (columns == null) {\n        columns = ImmutableSortedMap.of();\n      }\n      Map<Long, Integer> oldGroupInfo = Maps.newHashMap();\n      byte[] smallest = decodeGroupInfo(groupInfo, columns, oldGroupInfo);\n\n      List<Mutation> mutations = Lists.newArrayList();\n\n      // For groups that are removed, simply delete the columns\n      Sets.SetView<Long> removedGroups = Sets.difference(oldGroupInfo.keySet(), groupInfo.keySet());\n      if (!removedGroups.isEmpty()) {\n        Delete delete = new Delete(rowKey);\n        for (long removeGroupId : removedGroups) {\n          for (int i = 0; i < oldGroupInfo.get(removeGroupId); i++) {\n            delete.deleteColumns(QueueEntryRow.COLUMN_FAMILY,\n                                 getConsumerStateColumn(removeGroupId, i));\n          }\n        }\n        mutations.add(delete);\n      }\n\n      // For each group that changed (either a new group or number of instances change), update the startRow\n      Put put = new Put(rowKey);\n      for (Map.Entry<Long, Integer> entry : groupInfo.entrySet()) {\n        long groupId = entry.getKey();\n        int instances = entry.getValue();\n        if (!oldGroupInfo.containsKey(groupId)) {\n          // For new group, simply put with smallest rowKey from other group or an empty byte array if none exists.\n          for (int i = 0; i < instances; i++) {\n            put.add(QueueEntryRow.COLUMN_FAMILY,\n                    getConsumerStateColumn(groupId, i),\n                    smallest == null ? Bytes.EMPTY_BYTE_ARRAY : smallest);\n          }\n        } else if (oldGroupInfo.get(groupId) != instances) {\n          // compute the mutations needed using the change instances logic\n          SortedMap<byte[], byte[]> columnMap =\n            columns.subMap(getConsumerStateColumn(groupId, 0),\n                           getConsumerStateColumn(groupId, oldGroupInfo.get(groupId)));\n\n          mutations = getConfigMutations(groupId, instances, rowKey, HBaseConsumerState.create(columnMap), mutations);\n        }\n      }\n      mutations.add(put);\n\n      // Compute and applies changes\n      if (!mutations.isEmpty()) {\n        hTable.batch(mutations);\n      }\n\n    } finally {\n      hTable.close();\n    }\n  }","id":45122,"modified_method":"@Override\n  public void configureGroups(QueueName queueName, Map<Long, Integer> groupInfo) throws Exception {\n    Preconditions.checkArgument(!groupInfo.isEmpty(), \"Consumer group information must not be empty.\");\n\n    if (!exists(queueName)) {\n      create(queueName);\n    }\n\n    HTable hTable = new HTable(admin.getConfiguration(), configTableName);\n\n    try {\n      byte[] rowKey = queueName.toBytes();\n\n      // Get the whole row\n      Result result = hTable.get(new Get(rowKey));\n\n      // Generate existing groupInfo, also find smallest rowKey from existing group if there is any\n      NavigableMap<byte[], byte[]> columns = result.getFamilyMap(QueueEntryRow.COLUMN_FAMILY);\n      if (columns == null) {\n        columns = ImmutableSortedMap.of();\n      }\n      Map<Long, Integer> oldGroupInfo = Maps.newHashMap();\n      byte[] smallest = decodeGroupInfo(groupInfo, columns, oldGroupInfo);\n\n      List<Mutation> mutations = Lists.newArrayList();\n\n      // For groups that are removed, simply delete the columns\n      Sets.SetView<Long> removedGroups = Sets.difference(oldGroupInfo.keySet(), groupInfo.keySet());\n      if (!removedGroups.isEmpty()) {\n        Delete delete = new Delete(rowKey);\n        for (long removeGroupId : removedGroups) {\n          for (int i = 0; i < oldGroupInfo.get(removeGroupId); i++) {\n            delete.deleteColumns(QueueEntryRow.COLUMN_FAMILY,\n                                 getConsumerStateColumn(removeGroupId, i));\n          }\n        }\n        mutations.add(delete);\n      }\n\n      // For each group that changed (either a new group or number of instances change), update the startRow\n      Put put = new Put(rowKey);\n      for (Map.Entry<Long, Integer> entry : groupInfo.entrySet()) {\n        long groupId = entry.getKey();\n        int instances = entry.getValue();\n        if (!oldGroupInfo.containsKey(groupId)) {\n          // For new group, simply put with smallest rowKey from other group or an empty byte array if none exists.\n          for (int i = 0; i < instances; i++) {\n            put.add(QueueEntryRow.COLUMN_FAMILY,\n                    getConsumerStateColumn(groupId, i),\n                    smallest == null ? Bytes.EMPTY_BYTE_ARRAY : smallest);\n          }\n        } else if (oldGroupInfo.get(groupId) != instances) {\n          // compute the mutations needed using the change instances logic\n          SortedMap<byte[], byte[]> columnMap =\n            columns.subMap(getConsumerStateColumn(groupId, 0),\n                           getConsumerStateColumn(groupId, oldGroupInfo.get(groupId)));\n\n          mutations = getConfigMutations(groupId, instances, rowKey, HBaseConsumerState.create(columnMap), mutations);\n        }\n      }\n      mutations.add(put);\n\n      // Compute and applies changes\n      if (!mutations.isEmpty()) {\n        hTable.batch(mutations);\n      }\n\n    } finally {\n      hTable.close();\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void create(String name) throws Exception {\n    // NOTE: as of now, all queues stored in same table, hence name ignored.\n    create();\n  }","id":45123,"modified_method":"@Override\n  public void create(String name) throws IOException {\n    create(QueueName.from(URI.create(name)));\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"private void truncate(byte[] tableNameBytes) throws IOException {\n    HTableDescriptor tableDescriptor = admin.getTableDescriptor(tableNameBytes);\n    admin.disableTable(tableNameBytes);\n    admin.deleteTable(tableNameBytes);\n    admin.createTable(tableDescriptor);\n  }","id":45124,"modified_method":"private void truncate(byte[] tableNameBytes) throws IOException {\n    if (admin.tableExists(tableNameBytes)) {\n      HTableDescriptor tableDescriptor = admin.getTableDescriptor(tableNameBytes);\n      admin.disableTable(tableNameBytes);\n      admin.deleteTable(tableNameBytes);\n      admin.createTable(tableDescriptor);\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void drop(String name) throws Exception {\n    // No-op, as all queue entries are in one table.\n    LOG.warn(\"Drop({}) on HBase queue table has no effect.\", name);\n  }","id":45125,"modified_method":"@Override\n  public void drop(String name) throws Exception {\n    QueueName queueName = QueueName.from(URI.create(name));\n    // all queues for one flow are stored in same table, and we would drop all of them. this makes it optional.\n    if (doDropTable(queueName)) {\n      byte[] tableNameBytes = Bytes.toBytes(getFullTableName(queueName));\n      drop(tableNameBytes);\n    } else {\n      LOG.warn(\"drop({}) on HBase queue table has no effect.\", name);\n    }\n    // we can delete the config for this queue in any case.\n    deleteConfig(queueName);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"public String getTableName() {\n    return tableName;\n  }","id":45126,"modified_method":"protected String getTableNamePrefix() {\n    return tableNamePrefix;\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configureInstances(QueueName queueName, long groupId, int instances) throws Exception {\n    Preconditions.checkArgument(instances > 0, \"Number of consumer instances must be > 0.\");\n\n    if (!exists()) {\n      create();\n    }\n\n    HTable hTable = new HTable(admin.getConfiguration(), configTableName);\n\n    try {\n      byte[] rowKey = queueName.toBytes();\n\n      // Get all latest entry row key of all existing instances\n      // Consumer state column is named as \"<groupId><instanceId>\"\n      Get get = new Get(rowKey);\n      get.addFamily(QueueEntryRow.COLUMN_FAMILY);\n      get.setFilter(new ColumnPrefixFilter(Bytes.toBytes(groupId)));\n      List<HBaseConsumerState> consumerStates = HBaseConsumerState.create(hTable.get(get));\n\n      int oldInstances = consumerStates.size();\n\n      // Nothing to do if size doesn't change\n      if (oldInstances == instances) {\n        return;\n      }\n      // Compute and applies changes\n      hTable.batch(getConfigMutations(groupId, instances, rowKey, consumerStates, new ArrayList<Mutation>()));\n\n    } finally {\n      hTable.close();\n    }\n  }","id":45127,"modified_method":"@Override\n  public void configureInstances(QueueName queueName, long groupId, int instances) throws Exception {\n    Preconditions.checkArgument(instances > 0, \"Number of consumer instances must be > 0.\");\n\n    if (!exists(queueName)) {\n      create(queueName);\n    }\n\n    HTable hTable = new HTable(admin.getConfiguration(), configTableName);\n\n    try {\n      byte[] rowKey = queueName.toBytes();\n\n      // Get all latest entry row key of all existing instances\n      // Consumer state column is named as \"<groupId><instanceId>\"\n      Get get = new Get(rowKey);\n      get.addFamily(QueueEntryRow.COLUMN_FAMILY);\n      get.setFilter(new ColumnPrefixFilter(Bytes.toBytes(groupId)));\n      List<HBaseConsumerState> consumerStates = HBaseConsumerState.create(hTable.get(get));\n\n      int oldInstances = consumerStates.size();\n\n      // Nothing to do if size doesn't change\n      if (oldInstances == instances) {\n        return;\n      }\n      // Compute and applies changes\n      hTable.batch(getConfigMutations(groupId, instances, rowKey, consumerStates, new ArrayList<Mutation>()));\n\n    } finally {\n      hTable.close();\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void dropAll() throws Exception {\n    // NOTE: as of now, all queues stored in same table\n    // It's important to keep config table enabled while disabling queue table.\n    admin.disableTable(tableName);\n    admin.deleteTable(tableName);\n    admin.disableTable(configTableName);\n    admin.deleteTable(configTableName);\n  }","id":45128,"modified_method":"@Override\n  public void dropAll() throws Exception {\n    for (HTableDescriptor desc : admin.listTables()) {\n      String tableName = Bytes.toString(desc.getName());\n      // It's important to keep config table enabled while disabling queue tables.\n      if (tableName.startsWith(tableNamePrefix) && !tableName.equals(configTableName)) {\n        drop(desc.getName());\n      }\n    }\n    // drop config table last\n    drop(Bytes.toBytes(configTableName));\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected HBaseQueueAdmin(Configuration hConf,\n                            CConfiguration cConf,\n                            String namespace,\n                            DataSetAccessor dataSetAccessor,\n                            LocationFactory locationFactory) throws IOException {\n    this.admin = new HBaseAdmin(hConf);\n    this.cConf = cConf;\n    // todo: we have to do that because queues do not follow dataset semantic fully (yet)\n    this.namespace = namespace;\n    this.tableName =\n      HBaseTableUtil.getHBaseTableName(dataSetAccessor.namespace(namespace, DataSetAccessor.Namespace.SYSTEM));\n    this.configTableName = QueueConstants.QUEUE_CONFIG_TABLE_NAME;\n    this.locationFactory = locationFactory;\n  }","id":45129,"modified_method":"protected HBaseQueueAdmin(Configuration hConf,\n                            CConfiguration cConf,\n                            QueueConstants.QueueType type,\n                            DataSetAccessor dataSetAccessor,\n                            LocationFactory locationFactory) throws IOException {\n    this.admin = new HBaseAdmin(hConf);\n    this.cConf = cConf;\n    // todo: we have to do that because queues do not follow dataset semantic fully (yet)\n    String unqualifiedTableNamePrefix =\n      type == QUEUE ? QueueConstants.QUEUE_TABLE_PREFIX : QueueConstants.STREAM_TABLE_PREFIX;\n    this.tableNamePrefix = HBaseTableUtil.getHBaseTableName(\n      dataSetAccessor.namespace(unqualifiedTableNamePrefix, DataSetAccessor.Namespace.SYSTEM));\n    this.configTableName = HBaseTableUtil.getHBaseTableName(\n      dataSetAccessor.namespace(QueueConstants.QUEUE_CONFIG_TABLE_NAME, DataSetAccessor.Namespace.SYSTEM));\n    this.locationFactory = locationFactory;\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void truncate(String name) throws Exception {\n    // NOTE: as of now, all queues stored in same table\n    byte[] tableNameBytes = Bytes.toBytes(tableName);\n    truncate(tableNameBytes);\n\n    byte[] configTableBytes = Bytes.toBytes(configTableName);\n    truncate(configTableBytes);\n  }","id":45130,"modified_method":"@Override\n  public void truncate(String name) throws Exception {\n    QueueName queueName = QueueName.from(URI.create(name));\n    // all queues for one flow are stored in same table, and we would clear all of them. this makes it optional.\n    if (doTruncateTable(queueName)) {\n      byte[] tableNameBytes = Bytes.toBytes(getFullTableName(queueName));\n      truncate(tableNameBytes);\n    } else {\n      LOG.warn(\"truncate({}) on HBase queue table has no effect.\", name);\n    }\n    // we can delete the config for this queue in any case.\n    deleteConfig(queueName);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Helper method to select the queue or stream admin, and to ensure it's table exists.\n   * @param queueName name of the queue to be opened.\n   * @return the queue admin for that queue.\n   * @throws IOException\n   */\n  private HBaseQueueAdmin ensureTableExists(QueueName queueName) throws IOException {\n    HBaseQueueAdmin admin = queueName.isStream() ? streamAdmin : queueAdmin;\n    try {\n      if (!admin.exists()) {\n        admin.create();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Failed to open table \" + admin.getTableName(), e);\n    }\n    return admin;\n  }","id":45131,"modified_method":"/**\n   * Helper method to select the queue or stream admin, and to ensure it's table exists.\n   * @param queueName name of the queue to be opened.\n   * @return the queue admin for that queue.\n   * @throws IOException\n   */\n  private HBaseQueueAdmin ensureTableExists(QueueName queueName) throws IOException {\n    HBaseQueueAdmin admin = queueName.isStream() ? streamAdmin : queueAdmin;\n    try {\n      if (!admin.exists(queueName)) {\n        admin.create(queueName);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Failed to open table \" + admin.getFullTableName(queueName), e);\n    }\n    return admin;\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Queue2Producer createProducer(QueueName queueName, QueueMetrics queueMetrics) throws IOException {\n    HBaseQueueAdmin admin = ensureTableExists(queueName);\n    return new HBaseQueue2Producer(createHTable(admin.getTableName()), queueName, queueMetrics);\n  }","id":45132,"modified_method":"@Override\n  public Queue2Producer createProducer(QueueName queueName, QueueMetrics queueMetrics) throws IOException {\n    HBaseQueueAdmin admin = ensureTableExists(queueName);\n    return new HBaseQueue2Producer(createHTable(admin.getFullTableName(queueName)), queueName, queueMetrics);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Queue2Consumer createConsumer(QueueName queueName,\n                                       ConsumerConfig consumerConfig, int numGroups) throws IOException {\n    HBaseQueueAdmin admin = ensureTableExists(queueName);\n    HBaseConsumerStateStore stateStore = new HBaseConsumerStateStore(queueName, consumerConfig,\n                                                                     createHTable(admin.getConfigTableName()));\n    return new HBaseQueue2Consumer(consumerConfig, createHTable(admin.getTableName()),\n                                   queueName, stateStore.getState(), stateStore);\n  }","id":45133,"modified_method":"@Override\n  public Queue2Consumer createConsumer(QueueName queueName,\n                                       ConsumerConfig consumerConfig, int numGroups) throws IOException {\n    HBaseQueueAdmin admin = ensureTableExists(queueName);\n    HBaseConsumerStateStore stateStore = new HBaseConsumerStateStore(queueName, consumerConfig,\n                                                                     createHTable(admin.getConfigTableName()));\n    return new HBaseQueue2Consumer(consumerConfig, createHTable(admin.getFullTableName(queueName)),\n                                   queueName, stateStore.getState(), stateStore);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"String getTableName(QueueName queueName) {\n    return (queueName.isStream() ? streamAdmin : queueAdmin).getTableName();\n  }","id":45134,"modified_method":"String getTableName(QueueName queueName) {\n    return (queueName.isStream() ? streamAdmin : queueAdmin).getFullTableName(queueName);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testHTablePreSplitted() throws Exception {\n    HBaseQueueAdmin[] admins = { (HBaseQueueAdmin) queueAdmin, (HBaseQueueAdmin) streamAdmin };\n    for (HBaseQueueAdmin admin : admins) {\n      String tableName = admin.getTableName();\n      if (!admin.exists(tableName)) {\n        admin.create(tableName);\n      }\n      HTable hTable = HBaseTestBase.getHTable(Bytes.toBytes(tableName));\n      Assert.assertEquals(\"Failed for \" + admin.getClass().getName(),\n                          QueueConstants.DEFAULT_QUEUE_TABLE_PRESPLITS,\n                          hTable.getRegionsInRange(new byte[] {0}, new byte[] {(byte) 0xff}).size());\n    }\n  }","id":45135,"modified_method":"@Test\n  public void testHTablePreSplitted() throws Exception {\n    testHTablePreSplitted((HBaseQueueAdmin) queueAdmin, QueueName.fromFlowlet(\"app\", \"flow\", \"flowlet\", \"out\"));\n    testHTablePreSplitted((HBaseQueueAdmin) streamAdmin, QueueName.fromStream(\"test\", \"mystream\"));\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testPrefix() {\n    String queueTablename = ((HBaseQueueAdmin) queueAdmin).getTableName();\n    String streamTableName = ((HBaseQueueAdmin) streamAdmin).getTableName();\n    Assert.assertTrue(queueTablename.startsWith(\"test.\"));\n    Assert.assertTrue(streamTableName.startsWith(\"test.\"));\n    Assert.assertNotEquals(queueTablename, streamTableName);\n  }","id":45136,"modified_method":"@Test\n  public void testPrefix() {\n    String queueTablename = ((HBaseQueueAdmin) queueAdmin).getTableNamePrefix();\n    String streamTableName = ((HBaseQueueAdmin) streamAdmin).getTableNamePrefix();\n    Assert.assertTrue(queueTablename.startsWith(\"test.\"));\n    Assert.assertTrue(streamTableName.startsWith(\"test.\"));\n    Assert.assertNotEquals(queueTablename, streamTableName);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void configureGroups(QueueName queueName, Map<Long, Integer> groupInfo) throws Exception {\n    queueAdmin.configureGroups(queueName, groupInfo);\n  }","id":45137,"modified_method":"@Override\n  protected void configureGroups(QueueName queueName, Map<Long, Integer> groupInfo) throws Exception {\n    if (queueName.isQueue()) {\n      queueAdmin.configureGroups(queueName, groupInfo);\n    } else {\n      streamAdmin.configureGroups(queueName, groupInfo);\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"private Object computeQueueLength(MetricsRequest metricsRequest) {\n    AggregatesTable aggregatesTable = aggregatesTables.get(metricsRequest.getScope());\n\n    // process.events.processed will have a tag like \"input.queue://PurchaseFlow/reader/queue\" which indicates\n    // where the processed event came from.  So first get the aggregate count for events processed and all the\n    // queues they came from. Next, for all those queues, get the aggregate count for events they wrote,\n    // and subtract the two to get queue length.\n    AggregatesScanner scanner = aggregatesTable.scan(metricsRequest.getContextPrefix(),\n                                                     \"process.events.processed\",\n                                                     metricsRequest.getRunId(),\n                                                     \"input\");\n\n    long processed = 0;\n    Set<QueueName> queueNames = Sets.newHashSet();\n    while (scanner.hasNext()) {\n      AggregatesScanResult scanResult = scanner.next();\n      processed += scanResult.getValue();\n      // tag is of the form input.[queueURI].  ex: input.queue://PurchaseFlow/reader/queue\n      String tag = scanResult.getTag();\n      // strip the preceding \"input.\" from the tag.\n      queueNames.add(QueueName.from(URI.create(tag.substring(6, tag.length()))));\n    }\n\n    // For each queue, get the enqueue aggregate\n    long enqueue = 0;\n    for (QueueName queueName : queueNames) {\n      if (queueName.isStream()) {\n        // It's a stream, use stream context\n        enqueue += sumAll(aggregatesTable.scan(Constants.Gateway.METRICS_CONTEXT,\n                                               \"collect.events\", \"0\", queueName.getSimpleName()));\n      } else {\n        // The paths would be /flowId/flowletId/queueSimpleName\n        enqueue += sumAll(aggregatesTable.scan(String.format(\"%s.f.%s.%s\", queueName.getAppId(),\n                                                             queueName.getFlowId(), queueName.getFlowletId()),\n                                               \"process.events.out\", \"0\", queueName.getSimpleName()));\n      }\n    }\n\n    long len = enqueue - processed;\n    return new AggregateResponse(len >= 0 ? len : 0);\n  }","id":45138,"modified_method":"private Object computeQueueLength(MetricsRequest metricsRequest) {\n    AggregatesTable aggregatesTable = aggregatesTables.get(metricsRequest.getScope());\n\n    // process.events.processed will have a tag like \"input.queue://PurchaseFlow/reader/queue\" which indicates\n    // where the processed event came from.  So first get the aggregate count for events processed and all the\n    // queues they came from. Next, for all those queues, get the aggregate count for events they wrote,\n    // and subtract the two to get queue length.\n    AggregatesScanner scanner = aggregatesTable.scan(metricsRequest.getContextPrefix(),\n                                                     \"process.events.processed\",\n                                                     metricsRequest.getRunId(),\n                                                     \"input\");\n\n    long processed = 0;\n    Set<QueueName> queueNames = Sets.newHashSet();\n    while (scanner.hasNext()) {\n      AggregatesScanResult scanResult = scanner.next();\n      processed += scanResult.getValue();\n      // tag is of the form input.[queueURI].  ex: input.queue://PurchaseFlow/reader/queue\n      String tag = scanResult.getTag();\n      // strip the preceding \"input.\" from the tag.\n      queueNames.add(QueueName.from(URI.create(tag.substring(6, tag.length()))));\n    }\n\n    // For each queue, get the enqueue aggregate\n    long enqueue = 0;\n    for (QueueName queueName : queueNames) {\n      if (queueName.isStream()) {\n        // It's a stream, use stream context\n        enqueue += sumAll(aggregatesTable.scan(Constants.Gateway.METRICS_CONTEXT,\n                                               \"collect.events\", \"0\", queueName.getSimpleName()));\n      } else {\n        // The paths would be /flowId/flowletId/queueSimpleName\n        enqueue += sumAll(aggregatesTable.scan(String.format(\"%s.f.%s.%s\",\n                                                             queueName.getFirstComponent(), // the app\n                                                             queueName.getSecondComponent(), // the flow\n                                                             queueName.getThirdComponent()), // the flowlet\n                                               \"process.events.out\", \"0\", queueName.getSimpleName()));\n      }\n    }\n\n    long len = enqueue - processed;\n    return new AggregateResponse(len >= 0 ? len : 0);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void main(String args[]) throws Exception {\n\n    if (args.length != 1) {\n      usage(true);\n      return;\n    }\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      return;\n    }\n\n    int command;\n\n    if (\"start\".equals(args[0])) {\n      command = START;\n    } else if (\"stop\".equals(args[0])) {\n      command = STOP;\n    } else {\n      usage(true);\n      return;\n    }\n\n    CConfiguration cConf = CConfiguration.create();\n    Configuration hConf = HBaseConfiguration.create(new HdfsConfiguration());\n\n    DataFabricOpexModule module = new DataFabricOpexModule(cConf, hConf);\n\n    ZKClientService zkClientService =\n      ZKClientServices.delegate(\n        ZKClients.reWatchOnExpire(\n          ZKClients.retryOnFailure(\n            ZKClientService.Builder.of(cConf.get(Constants.Zookeeper.QUORUM))\n              .setSessionTimeout(cConf.getInt(\n                Constants.Zookeeper.CFG_SESSION_TIMEOUT_MILLIS,\n                Constants.Zookeeper.DEFAULT_SESSION_TIMEOUT_MILLIS))\n              .build(),\n            RetryStrategies.fixDelay(2, TimeUnit.SECONDS)\n          )\n        )\n      );\n    String kafkaZKNamespace = cConf.get(KafkaConstants.ConfigKeys.ZOOKEEPER_NAMESPACE_CONFIG);\n    KafkaClientService kafkaClientService = new ZKKafkaClientService(\n      kafkaZKNamespace == null\n        ? zkClientService\n        : ZKClients.namespace(zkClientService, \"/\" + kafkaZKNamespace)\n    );\n\n    Injector injector = Guice.createInjector(\n      new MetricsClientRuntimeModule(kafkaClientService).getDistributedModules(),\n      new IOModule(),\n      new ConfigModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n      module);\n\n    // start a tx server\n    final TransactionService txService = injector.getInstance(TransactionService.class);\n\n    if (START == command) {\n      Runtime.getRuntime().addShutdownHook(new Thread() {\n        @Override\n        public void run() {\n          try {\n            if (txService.isRunning()) {\n              txService.stopAndWait();\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to shutdown transaction service.\", e);\n            // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n            System.err.println(\"Failed to shutdown transaction service: \" + e.getMessage());\n            e.printStackTrace(System.err);\n          }\n        }\n      });\n\n      // Starts metrics collection\n      MetricsCollectionService metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n      Futures.getUnchecked(Services.chainStart(zkClientService, kafkaClientService, metricsCollectionService));\n\n      Copyright.print(System.out);\n      System.out.println(\"Starting Operation Executor Service...\");\n\n      // Creates HBase queue table\n      QueueAdmin queueAdmin = injector.getInstance(QueueAdmin.class);\n      // NOTE: queues currently stored in one table, so it doesn't matter what you pass a param\n      queueAdmin.create(\"queue\");\n\n      // populate the current configuration into an HBase table, for use by HBase components\n      ConfigurationTable configTable = new ConfigurationTable(injector.getInstance(\n          Key.get(Configuration.class, Names.named(\"HBaseOVCTableHandleHConfig\"))));\n      configTable.write(ConfigurationTable.Type.DEFAULT, cConf);\n\n      // start it. start is not blocking, hence we want to block to avoid termination of main\n      Future<?> future = Services.getCompletionFuture(txService);\n      try {\n        txService.start();\n      } catch (Exception e) {\n        System.err.println(\"Failed to start service: \" + e.getMessage());\n      }\n      // starting health/status check service\n      CommandPortService service = startHealthCheckService(cConf);\n\n      future.get();\n\n      service.stop();\n\n    } else {\n      Copyright.print(System.out);\n      System.out.println(\"Stopping Operation Executor Service...\");\n      txService.stop();\n    }\n  }","id":45139,"modified_method":"public static void main(String args[]) throws Exception {\n\n    if (args.length != 1) {\n      usage(true);\n      return;\n    }\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      return;\n    }\n\n    int command;\n\n    if (\"start\".equals(args[0])) {\n      command = START;\n    } else if (\"stop\".equals(args[0])) {\n      command = STOP;\n    } else {\n      usage(true);\n      return;\n    }\n\n    CConfiguration cConf = CConfiguration.create();\n    Configuration hConf = HBaseConfiguration.create(new HdfsConfiguration());\n\n    DataFabricOpexModule module = new DataFabricOpexModule(cConf, hConf);\n\n    ZKClientService zkClientService =\n      ZKClientServices.delegate(\n        ZKClients.reWatchOnExpire(\n          ZKClients.retryOnFailure(\n            ZKClientService.Builder.of(cConf.get(Constants.Zookeeper.QUORUM))\n              .setSessionTimeout(cConf.getInt(\n                Constants.Zookeeper.CFG_SESSION_TIMEOUT_MILLIS,\n                Constants.Zookeeper.DEFAULT_SESSION_TIMEOUT_MILLIS))\n              .build(),\n            RetryStrategies.fixDelay(2, TimeUnit.SECONDS)\n          )\n        )\n      );\n    String kafkaZKNamespace = cConf.get(KafkaConstants.ConfigKeys.ZOOKEEPER_NAMESPACE_CONFIG);\n    KafkaClientService kafkaClientService = new ZKKafkaClientService(\n      kafkaZKNamespace == null\n        ? zkClientService\n        : ZKClients.namespace(zkClientService, \"/\" + kafkaZKNamespace)\n    );\n\n    Injector injector = Guice.createInjector(\n      new MetricsClientRuntimeModule(kafkaClientService).getDistributedModules(),\n      new IOModule(),\n      new ConfigModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n      module);\n\n    // start a tx server\n    final TransactionService txService = injector.getInstance(TransactionService.class);\n\n    if (START == command) {\n      Runtime.getRuntime().addShutdownHook(new Thread() {\n        @Override\n        public void run() {\n          try {\n            if (txService.isRunning()) {\n              txService.stopAndWait();\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to shutdown transaction service.\", e);\n            // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n            System.err.println(\"Failed to shutdown transaction service: \" + e.getMessage());\n            e.printStackTrace(System.err);\n          }\n        }\n      });\n\n      // Starts metrics collection\n      MetricsCollectionService metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n      Futures.getUnchecked(Services.chainStart(zkClientService, kafkaClientService, metricsCollectionService));\n\n      Copyright.print(System.out);\n      System.out.println(\"Starting Operation Executor Service...\");\n\n      // populate the current configuration into an HBase table, for use by HBase components\n      ConfigurationTable configTable = new ConfigurationTable(injector.getInstance(\n          Key.get(Configuration.class, Names.named(\"HBaseOVCTableHandleHConfig\"))));\n      configTable.write(ConfigurationTable.Type.DEFAULT, cConf);\n\n      // start it. start is not blocking, hence we want to block to avoid termination of main\n      Future<?> future = Services.getCompletionFuture(txService);\n      try {\n        txService.start();\n      } catch (Exception e) {\n        System.err.println(\"Failed to start service: \" + e.getMessage());\n      }\n      // starting health/status check service\n      CommandPortService service = startHealthCheckService(cConf);\n\n      future.get();\n\n      service.stop();\n\n    } else {\n      Copyright.print(System.out);\n      System.out.println(\"Stopping Operation Executor Service...\");\n      txService.stop();\n    }\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Called from static method {@code QueueName#from(URI)} and {@code QueueName#from(bytes[])}.\n   *\n   * @param uri of the queue.\n   */\n  private QueueName(URI uri) {\n    this.uri = uri;\n    this.simpleName = new File(uri.getPath()).getName();\n    this.stringName = uri.toASCIIString();\n    this.byteName = stringName.getBytes(Charsets.US_ASCII);\n    if (isQueue()) {\n      appId = uri.getHost();\n      Iterator<String> iter = Splitter.on('/').omitEmptyStrings().split(uri.getPath()).iterator();\n      flowId = iter.next();\n      flowletId = iter.next();\n    } else {\n      appId = null;\n      flowId = null;\n      flowletId = null;\n    }\n  }","id":45140,"modified_method":"/**\n   * Called from static method {@code QueueName#from(URI)} and {@code QueueName#from(bytes[])}.\n   *\n   * @param uri of the queue.\n   */\n  private QueueName(URI uri) {\n    this.uri = uri;\n    this.simpleName = new File(uri.getPath()).getName();\n    this.stringName = uri.toASCIIString();\n    this.byteName = stringName.getBytes(Charsets.US_ASCII);\n    List<String> comps = Lists.asList(uri.getHost(), uri.getPath().split(\"/\"));\n    this.components = comps.toArray(new String[comps.size()]);\n  }","commit_id":"6b6c5da3a108d889b20a0101f1121d49fb79807f","url":"https://github.com/caskdata/cdap"},{"original_method":"/** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\n\t\t * (typically) moving toward the beginning of the glyphs array. */\n\t\tpublic int getWrapIndex (Array<Glyph> glyphs, int start) {\n\t\t\tchar ch = (char)glyphs.get(start).id;\n\t\t\tif (isWhitespace(ch)) return start + 1;\n\t\t\tfor (int i = start - 1; i >= 1; i--) {\n\t\t\t\tch = (char)glyphs.get(i).id;\n\t\t\t\tif (isWhitespace(ch)) return i + 1;\n\t\t\t\tif (isBreakChar(ch)) return i;\n\t\t\t}\n\t\t\treturn start;\n\t\t}","id":45141,"modified_method":"/** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\n\t\t * (typically) moving toward the beginning of the glyphs array. */\n\t\tpublic int getWrapIndex (Array<Glyph> glyphs, int start) {\n\t\t\tchar ch = (char)glyphs.get(start).id;\n\t\t\tif (isWhitespace(ch)) return start + 1;\n\t\t\tfor (int i = start - 1; i >= 1; i--) {\n\t\t\t\tch = (char)glyphs.get(i).id;\n\t\t\t\tif (isWhitespace(ch)) return i + 1;\n\t\t\t\tif (isBreakChar(ch)) return i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}","commit_id":"b1ec2278ff49fab2cee8f61aab4e1c2b0ee2950b","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void wrap (BitmapFontData fontData, GlyphRun first, GlyphRun second, int wrapIndex, int widthIndex) {\n\t\tsecond.color.set(first.color);\n\n\t\t// Copy wrapped glyphs and xAdvances.\n\t\tsecond.glyphs.addAll(first.glyphs, wrapIndex, first.glyphs.size - wrapIndex);\n\t\tsecond.xAdvances.add(-second.glyphs.first().xoffset * fontData.scaleX);\n\t\tsecond.xAdvances.addAll(first.xAdvances, wrapIndex + 1, first.xAdvances.size - (wrapIndex + 1));\n\n\t\t// Increase first run width up to the wrap index.\n\t\twhile (widthIndex < wrapIndex)\n\t\t\tfirst.width += first.xAdvances.get(widthIndex++);\n\n\t\t// Reduce first run width by the wrapped glyphs that have contributed to the width.\n\t\twhile (widthIndex > wrapIndex + 1)\n\t\t\tfirst.width -= first.xAdvances.get(--widthIndex);\n\n\t\t// Eat whitespace at end of first run.\n\t\tfor (; wrapIndex > 0; wrapIndex--) {\n\t\t\tif (fontData.isWhitespace((char)first.glyphs.get(wrapIndex - 1).id)) {\n\t\t\t\tfirst.width -= first.xAdvances.get(wrapIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// Truncate wrapped glyphs from first run.\n\t\tfirst.glyphs.truncate(wrapIndex);\n\t\tfirst.xAdvances.truncate(wrapIndex + 1);\n\t\tadjustLastGlyph(fontData, first);\n\t}","id":45142,"modified_method":"private GlyphRun wrap (BitmapFontData fontData, GlyphRun first, Pool<GlyphRun> glyphRunPool, int wrapIndex, int widthIndex) {\n\t\tGlyphRun second = glyphRunPool.obtain();\n\t\tsecond.color.set(first.color);\n\n\t\t// Copy wrapped glyphs and xAdvances.\n\t\tsecond.glyphs.addAll(first.glyphs, wrapIndex, first.glyphs.size - wrapIndex);\n\t\tsecond.xAdvances.add(-second.glyphs.first().xoffset * fontData.scaleX);\n\t\tsecond.xAdvances.addAll(first.xAdvances, wrapIndex + 1, first.xAdvances.size - (wrapIndex + 1));\n\n\t\t// Increase first run width up to the wrap index.\n\t\twhile (widthIndex < wrapIndex)\n\t\t\tfirst.width += first.xAdvances.get(widthIndex++);\n\n\t\t// Reduce first run width by the wrapped glyphs that have contributed to the width.\n\t\twhile (widthIndex > wrapIndex + 1)\n\t\t\tfirst.width -= first.xAdvances.get(--widthIndex);\n\n\t\t// Eat whitespace at end of first run.\n\t\tfor (; wrapIndex > 0; wrapIndex--) {\n\t\t\tif (fontData.isWhitespace((char)first.glyphs.get(wrapIndex - 1).id)) {\n\t\t\t\tfirst.width -= first.xAdvances.get(wrapIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wrapIndex == 0) {\n\t\t\t// If the first run is now empty, remove it.\n\t\t\tglyphRunPool.free(first);\n\t\t\truns.pop();\n\t\t} else {\n\t\t\t// Truncate wrapped glyphs from first run.\n\t\t\tfirst.glyphs.truncate(wrapIndex);\n\t\t\tfirst.xAdvances.truncate(wrapIndex + 1);\n\t\t\tadjustLastGlyph(fontData, first);\n\t\t}\n\t\treturn second;\n\t}","commit_id":"b1ec2278ff49fab2cee8f61aab4e1c2b0ee2950b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param color The default color to use for the text (the BitmapFont {@link BitmapFont#getColor() color} is not used). If\n\t *           {@link BitmapFontData#markupEnabled} is true, color markup tags in the specified string may change the color for\n\t *           portions of the text.\n\t * @param targetWidth The width used for alignment, line wrapping, and truncation. May be zero if those features are not used.\n\t * @param truncate If not null and the width of the glyphs exceed targetWidth, the glyphs are truncated and the glyphs for the\n\t *           specified truncate string are placed at the end. Empty string can be used to truncate without adding glyphs. */\n\tpublic void setText (BitmapFont font, CharSequence str, int start, int end, Color color, float targetWidth, int halign,\n\t\tboolean wrap, String truncate) {\n\t\tif (targetWidth <= font.data.spaceWidth) // Avoid wrapping every character to it's own line/run, which is very inefficient.\n\t\t\twrap = false;\n\t\tif (truncate != null) wrap = true; // Causes truncate code to run, doesn't actually cause wrapping.\n\n\t\tBitmapFontData fontData = font.data;\n\t\tboolean markupEnabled = fontData.markupEnabled;\n\n\t\tPool<GlyphRun> glyphRunPool = Pools.get(GlyphRun.class);\n\t\tArray<GlyphRun> runs = this.runs;\n\t\tglyphRunPool.freeAll(runs);\n\t\truns.clear();\n\n\t\tfloat x = 0, y = 0, width = 0;\n\t\tint lines = 0;\n\n\t\tArray<Color> colorStack = GlyphLayout.colorStack;\n\t\tColor nextColor = color;\n\t\tcolorStack.add(color);\n\t\tPool<Color> colorPool = Pools.get(Color.class);\n\n\t\tint runStart = start;\n\t\touter:\n\t\twhile (true) {\n\t\t\t// Each run is delimited by newline or left square bracket.\n\t\t\tint runEnd = -1;\n\t\t\tboolean newline = false;\n\t\t\tif (start == end) {\n\t\t\t\tif (runStart == end) break; // End of string with no run to process, we're done.\n\t\t\t\trunEnd = end; // End of string, process last run.\n\t\t\t} else {\n\t\t\t\tswitch (str.charAt(start++)) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\t// End of line.\n\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\tnewline = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\t// Possible color tag.\n\t\t\t\t\tif (markupEnabled) {\n\t\t\t\t\t\tint length = parseColorMarkup(str, start, end, colorPool);\n\t\t\t\t\t\tif (length >= 0) {\n\t\t\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\t\t\tstart += length + 1;\n\t\t\t\t\t\t\tnextColor = colorStack.peek();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (runEnd != -1) {\n\t\t\t\tif (runEnd != runStart) { // Can happen (eg) when a color tag is at text start.\n\t\t\t\t\t// Store the run that has ended.\n\t\t\t\t\tGlyphRun run = glyphRunPool.obtain();\n\t\t\t\t\truns.add(run);\n\t\t\t\t\trun.color.set(color);\n\t\t\t\t\trun.x = x;\n\t\t\t\t\trun.y = y;\n\t\t\t\t\tfontData.getGlyphs(run, str, runStart, runEnd);\n\n\t\t\t\t\t// Compute the run width, wrap if necessary, and position the run.\n\t\t\t\t\tfloat[] xAdvances = run.xAdvances.items;\n\t\t\t\t\tfor (int i = 0, n = run.xAdvances.size; i < n; i++) {\n\t\t\t\t\t\tfloat xAdvance = xAdvances[i];\n\t\t\t\t\t\tx += xAdvance;\n\n\t\t\t\t\t\t// Don't wrap if the glyph would fit with just its width (no xadvance or kerning).\n\t\t\t\t\t\tif (wrap && x > targetWidth && i > 1 && x - xAdvance //\n\t\t\t\t\t\t\t+ (run.glyphs.get(i - 1).xoffset + run.glyphs.get(i - 1).width) * fontData.scaleX - 0.00001f > targetWidth) {\n\n\t\t\t\t\t\t\tif (truncate != null) {\n\t\t\t\t\t\t\t\ttruncate(fontData, run, targetWidth, truncate, i, glyphRunPool);\n\t\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tGlyphRun next = glyphRunPool.obtain();\n\t\t\t\t\t\t\truns.add(next);\n\t\t\t\t\t\t\twrap(fontData, run, next, Math.max(1, fontData.getWrapIndex(run.glyphs, i - 1)), i);\n\n\t\t\t\t\t\t\t// Start the loop over with the new run on the next line.\n\t\t\t\t\t\t\twidth = Math.max(width, run.width);\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty += fontData.down;\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t\tnext.x = 0;\n\t\t\t\t\t\t\tnext.y = y;\n\t\t\t\t\t\t\ti = -1;\n\t\t\t\t\t\t\tn = next.xAdvances.size;\n\t\t\t\t\t\t\txAdvances = next.xAdvances.items;\n\t\t\t\t\t\t\trun = next;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\trun.width += xAdvance;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newline) {\n\t\t\t\t\t\t// Next run will be on the next line.\n\t\t\t\t\t\twidth = Math.max(width, x);\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty += fontData.down;\n\t\t\t\t\t\tlines++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trunStart = start;\n\t\t\t\tcolor = nextColor;\n\t\t\t}\n\t\t}\n\t\twidth = Math.max(width, x);\n\n\t\tfor (int i = 1, n = colorStack.size; i < n; i++)\n\t\t\tcolorPool.free(colorStack.get(i));\n\t\tcolorStack.clear();\n\n\t\t// Align runs to center or right of targetWidth.\n\t\tif ((halign & Align.left) == 0) { // Not left aligned, so must be center or right aligned.\n\t\t\tboolean center = (halign & Align.center) != 0;\n\t\t\tfloat lineWidth = 0, lineY = Integer.MIN_VALUE;\n\t\t\tint lineStart = 0, n = runs.size;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tGlyphRun run = runs.get(i);\n\t\t\t\tif (run.y != lineY) {\n\t\t\t\t\tlineY = run.y;\n\t\t\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\t\t\tif (center) shift /= 2;\n\t\t\t\t\twhile (lineStart < i)\n\t\t\t\t\t\truns.get(lineStart++).x += shift;\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\t}\n\t\t\t\tlineWidth += run.width;\n\t\t\t}\n\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\tif (center) shift /= 2;\n\t\t\twhile (lineStart < n)\n\t\t\t\truns.get(lineStart++).x += shift;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.height = fontData.capHeight + lines * fontData.lineHeight;\n\t}","id":45143,"modified_method":"/** @param color The default color to use for the text (the BitmapFont {@link BitmapFont#getColor() color} is not used). If\n\t *           {@link BitmapFontData#markupEnabled} is true, color markup tags in the specified string may change the color for\n\t *           portions of the text.\n\t * @param targetWidth The width used for alignment, line wrapping, and truncation. May be zero if those features are not used.\n\t * @param truncate If not null and the width of the glyphs exceed targetWidth, the glyphs are truncated and the glyphs for the\n\t *           specified truncate string are placed at the end. Empty string can be used to truncate without adding glyphs. */\n\tpublic void setText (BitmapFont font, CharSequence str, int start, int end, Color color, float targetWidth, int halign,\n\t\tboolean wrap, String truncate) {\n\t\tif (targetWidth <= font.data.spaceWidth) // Avoid wrapping every character to it's own line/run, which is very inefficient.\n\t\t\twrap = false;\n\t\tif (truncate != null) wrap = true; // Causes truncate code to run, doesn't actually cause wrapping.\n\n\t\tBitmapFontData fontData = font.data;\n\t\tboolean markupEnabled = fontData.markupEnabled;\n\n\t\tPool<GlyphRun> glyphRunPool = Pools.get(GlyphRun.class);\n\t\tArray<GlyphRun> runs = this.runs;\n\t\tglyphRunPool.freeAll(runs);\n\t\truns.clear();\n\n\t\tfloat x = 0, y = 0, width = 0;\n\t\tint lines = 0;\n\n\t\tArray<Color> colorStack = GlyphLayout.colorStack;\n\t\tColor nextColor = color;\n\t\tcolorStack.add(color);\n\t\tPool<Color> colorPool = Pools.get(Color.class);\n\n\t\tint runStart = start;\n\t\touter:\n\t\twhile (true) {\n\t\t\t// Each run is delimited by newline or left square bracket.\n\t\t\tint runEnd = -1;\n\t\t\tboolean newline = false;\n\t\t\tif (start == end) {\n\t\t\t\tif (runStart == end) break; // End of string with no run to process, we're done.\n\t\t\t\trunEnd = end; // End of string, process last run.\n\t\t\t} else {\n\t\t\t\tswitch (str.charAt(start++)) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\t// End of line.\n\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\tnewline = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\t// Possible color tag.\n\t\t\t\t\tif (markupEnabled) {\n\t\t\t\t\t\tint length = parseColorMarkup(str, start, end, colorPool);\n\t\t\t\t\t\tif (length >= 0) {\n\t\t\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\t\t\tstart += length + 1;\n\t\t\t\t\t\t\tnextColor = colorStack.peek();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (runEnd != -1) {\n\t\t\t\tif (runEnd != runStart) { // Can happen (eg) when a color tag is at text start.\n\t\t\t\t\t// Store the run that has ended.\n\t\t\t\t\tGlyphRun run = glyphRunPool.obtain();\n\t\t\t\t\truns.add(run);\n\t\t\t\t\trun.color.set(color);\n\t\t\t\t\trun.x = x;\n\t\t\t\t\trun.y = y;\n\t\t\t\t\tfontData.getGlyphs(run, str, runStart, runEnd);\n\t\t\t\t\tif (run.glyphs.size == 0) System.out.println();\n\n\t\t\t\t\t// Compute the run width, wrap if necessary, and position the run.\n\t\t\t\t\tfloat[] xAdvances = run.xAdvances.items;\n\t\t\t\t\tfor (int i = 0, n = run.xAdvances.size; i < n; i++) {\n\t\t\t\t\t\tfloat xAdvance = xAdvances[i];\n\t\t\t\t\t\tx += xAdvance;\n\n\t\t\t\t\t\t// Don't wrap if the glyph would fit with just its width (no xadvance or kerning).\n\t\t\t\t\t\tif (wrap && x > targetWidth && i > 1 && x - xAdvance //\n\t\t\t\t\t\t\t+ (run.glyphs.get(i - 1).xoffset + run.glyphs.get(i - 1).width) * fontData.scaleX - 0.00001f > targetWidth) {\n\n\t\t\t\t\t\t\tif (truncate != null) {\n\t\t\t\t\t\t\t\ttruncate(fontData, run, targetWidth, truncate, i, glyphRunPool);\n\t\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint wrapIndex = fontData.getWrapIndex(run.glyphs, i - 1);\n\t\t\t\t\t\t\tif (run.x == 0 && wrapIndex == 0) wrapIndex = i - 1; // Require at least one glyph per line.\n\t\t\t\t\t\t\tGlyphRun next = wrap(fontData, run, glyphRunPool, wrapIndex, i);\n\t\t\t\t\t\t\truns.add(next);\n\n\t\t\t\t\t\t\t// Start the loop over with the new run on the next line.\n\t\t\t\t\t\t\twidth = Math.max(width, run.x + run.width);\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty += fontData.down;\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t\tnext.x = 0;\n\t\t\t\t\t\t\tnext.y = y;\n\t\t\t\t\t\t\ti = -1;\n\t\t\t\t\t\t\tn = next.xAdvances.size;\n\t\t\t\t\t\t\txAdvances = next.xAdvances.items;\n\t\t\t\t\t\t\trun = next;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\trun.width += xAdvance;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newline) {\n\t\t\t\t\t\t// Next run will be on the next line.\n\t\t\t\t\t\twidth = Math.max(width, x);\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty += fontData.down;\n\t\t\t\t\t\tlines++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trunStart = start;\n\t\t\t\tcolor = nextColor;\n\t\t\t}\n\t\t}\n\t\twidth = Math.max(width, x);\n\n\t\tfor (int i = 1, n = colorStack.size; i < n; i++)\n\t\t\tcolorPool.free(colorStack.get(i));\n\t\tcolorStack.clear();\n\n\t\t// Align runs to center or right of targetWidth.\n\t\tif ((halign & Align.left) == 0) { // Not left aligned, so must be center or right aligned.\n\t\t\tboolean center = (halign & Align.center) != 0;\n\t\t\tfloat lineWidth = 0, lineY = Integer.MIN_VALUE;\n\t\t\tint lineStart = 0, n = runs.size;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tGlyphRun run = runs.get(i);\n\t\t\t\tif (run.y != lineY) {\n\t\t\t\t\tlineY = run.y;\n\t\t\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\t\t\tif (center) shift /= 2;\n\t\t\t\t\twhile (lineStart < i)\n\t\t\t\t\t\truns.get(lineStart++).x += shift;\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\t}\n\t\t\t\tlineWidth += run.width;\n\t\t\t}\n\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\tif (center) shift /= 2;\n\t\t\twhile (lineStart < n)\n\t\t\t\truns.get(lineStart++).x += shift;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.height = fontData.capHeight + lines * fontData.lineHeight;\n\t}","commit_id":"b1ec2278ff49fab2cee8f61aab4e1c2b0ee2950b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Updates the layout for all list items in this list.<p>\n     */\n    public void updateLayout() {\n\n        for (Widget widget : this) {\n            if (widget instanceof I_CmsListItem) {\n                ((I_CmsListItem)widget).updateLayout();\n            }\n        }\n    }","id":45144,"modified_method":"/**\n     * Updates the layout for all list items in this list.<p>\n     */\n    public void updateLayout() {\n\n        for (Widget widget : this) {\n            if (widget instanceof CmsSimpleListItem) {\n                ((CmsSimpleListItem)widget).updateLayout();\n            }\n        }\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsListItem#updateLayout()\n     */\n    public void updateLayout() {\n\n        m_content.updateLayout();\n    }","id":45145,"modified_method":"/**\n     * Method for updating the layout of the item.<p>\n     */\n    public void updateLayout() {\n\n        m_content.updateLayout();\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsKey, int labelWidth) {\n\n        int width = labelWidth - 4; // just to be on the safe side\n        for (Widget widget : m_panel) {\n            if (widget instanceof CmsListItemWidget) {\n                ((CmsListItemWidget)widget).truncate(textMetricsKey, width);\n            }\n            if (widget instanceof CmsList<?>) {\n                ((CmsList<?>)widget).truncate(textMetricsKey, width - 25); // 25px indentation\n            }\n            if (widget instanceof CmsFloatDecoratedPanel) {\n                ((CmsFloatDecoratedPanel)widget).truncate(textMetricsKey, width);\n            }\n        }\n\n    }","id":45146,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        for (Widget widget : m_panel) {\n            if (!(widget instanceof I_CmsTruncable)) {\n                continue;\n            }\n            int width = widgetWidth - 4; // just to be on the safe side\n            if (widget instanceof CmsList<?>) {\n                width -= 25; // 25px left margin\n            }\n            ((I_CmsTruncable)widget).truncate(textMetricsPrefix, width);\n        }\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes an item from the list.<p>\n     * \n     * @param itemId the id of the item to remove\n     * \n     * @return the removed item\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#removeItem(String)\n     */\n    public CmsTreeItem removeChild(String itemId) {\n\n        m_children.getItem(itemId).setParentItem(null);\n        CmsTreeItem removeItem = m_children.removeItem(itemId);\n        onChangeChildren();\n        return removeItem;\n    }","id":45147,"modified_method":"/**\n     * Removes an item from the list.<p>\n     * \n     * @param itemId the id of the item to remove\n     * \n     * @return the removed item\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#removeItem(String)\n     */\n    public CmsTreeItem removeChild(String itemId) {\n\n        CmsTreeItem removeItem = m_children.removeItem(itemId);\n        removeItem.setParentItem(null);\n        onChangeChildren();\n        return removeItem;\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Opens or closes this tree item (i.e. shows or hides its descendants).<p>\n     * \n     * @param open if true, open the tree item, else close it\n     */\n    public void setOpen(boolean open) {\n\n        m_styleVar.setValue(open ? CSS.listTreeItemOpen() : CSS.listTreeItemClosed());\n        m_opener.setDown(open);\n        if (open) {\n            for (Widget widget : m_children) {\n                ((I_CmsListItem)widget).updateLayout();\n            }\n            fireOpen();\n        }\n    }","id":45148,"modified_method":"/**\n     * Opens or closes this tree item (i.e. shows or hides its descendants).<p>\n     * \n     * @param open if true, open the tree item, else close it\n     */\n    public void setOpen(boolean open) {\n\n        m_styleVar.setValue(open ? CSS.listTreeItemOpen() : CSS.listTreeItemClosed());\n        m_opener.setDown(open);\n        if (open) {\n            for (Widget widget : m_children) {\n                if (widget instanceof CmsSimpleListItem) {\n                    ((CmsSimpleListItem)widget).updateLayout();\n                }\n            }\n            fireOpen();\n        }\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a child list item.<p>\n     * \n     * @param item the child to add\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#addItem(I_CmsListItem)\n     */\n    public void addChild(CmsTreeItem item) {\n\n        m_children.addItem(item);\n        item.setParentItem(this);\n        item.setTree(m_tree);\n        onChangeChildren();\n    }","id":45149,"modified_method":"/**\n     * Adds a child list item.<p>\n     * \n     * @param item the child to add\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#addItem(org.opencms.gwt.client.ui.I_CmsListItem)\n     */\n    public void addChild(CmsTreeItem item) {\n\n        m_children.addItem(item);\n        item.setParentItem(this);\n        item.setTree(m_tree);\n        onChangeChildren();\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Inserts the given item at the given position.<p>\n     * \n     * @param item the item to insert\n     * @param position the position\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#insertItem(I_CmsListItem, int)\n     */\n    public void insertChild(CmsTreeItem item, int position) {\n\n        m_children.insert(item, position);\n        item.setTree(m_tree);\n        onChangeChildren();\n    }","id":45150,"modified_method":"/**\n     * Inserts the given item at the given position.<p>\n     * \n     * @param item the item to insert\n     * @param position the position\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#insertItem(org.opencms.gwt.client.ui.I_CmsListItem, int)\n     */\n    public void insertChild(CmsTreeItem item, int position) {\n\n        m_children.insert(item, position);\n        item.setTree(m_tree);\n        onChangeChildren();\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes an item from the list.<p>\n     * \n     * @param item the item to remove\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#removeItem(I_CmsListItem)\n     */\n    public void removeChild(CmsTreeItem item) {\n\n        item.setParentItem(null);\n        m_children.removeItem(item);\n        onChangeChildren();\n    }","id":45151,"modified_method":"/**\n     * Removes an item from the list.<p>\n     * \n     * @param item the item to remove\n     * \n     * @see org.opencms.gwt.client.ui.CmsList#removeItem(org.opencms.gwt.client.ui.I_CmsListItem)\n     */\n    public void removeChild(CmsTreeItem item) {\n\n        item.setParentItem(null);\n        m_children.removeItem(item);\n        onChangeChildren();\n    }","commit_id":"e327dd4bf61456890e08fe76512508d6c69d82be","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        int width = widgetWidth;\n        width -= (!isAttached() ? 30 * m_floatBox.getWidgetCount() : getFloatBoxWidth());\n        for (Widget widget : m_primary) {\n            if (widget instanceof CmsListItemWidget) {\n                ((CmsListItemWidget)widget).truncate(textMetricsPrefix, width);\n            }\n        }\n    }","id":45152,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        int width = widgetWidth;\n        width -= (!isAttached() ? 30 * m_floatBox.getWidgetCount() : getFloatBoxWidth());\n        for (Widget widget : m_primary) {\n            if (widget instanceof I_CmsTruncable) {\n                ((I_CmsTruncable)widget).truncate(textMetricsPrefix, width);\n            }\n        }\n    }","commit_id":"87b4ea4aea6809d8ca5fcdefbf148af949e098af","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        int width = widgetWidth - 4; // just to be on the safe side\n        for (Widget widget : m_panel) {\n            if (widget instanceof CmsListItemWidget) {\n                ((CmsListItemWidget)widget).truncate(textMetricsPrefix, width);\n            }\n            if (widget instanceof CmsList<?>) {\n                ((CmsList<?>)widget).truncate(textMetricsPrefix, width - 25); // 25px indentation\n            }\n            if (widget instanceof CmsFloatDecoratedPanel) {\n                ((CmsFloatDecoratedPanel)widget).truncate(textMetricsPrefix, width);\n            }\n        }\n    }","id":45153,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        for (Widget widget : m_panel) {\n            if (!(widget instanceof I_CmsTruncable)) {\n                continue;\n            }\n            int width = widgetWidth - 4; // just to be on the safe side\n            if (widget instanceof CmsList<?>) {\n                width -= 25; // 25px left margin\n            }\n            ((I_CmsTruncable)widget).truncate(textMetricsPrefix, width);\n        }\n    }","commit_id":"87b4ea4aea6809d8ca5fcdefbf148af949e098af","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        m_openerLabel.truncate(textMetricsPrefix + TM_OPENER_LABEL, widgetWidth);\n        for (Widget widget : m_selector) {\n            if (widget instanceof CmsLabel) {\n                ((CmsLabel)widget).truncate(textMetricsPrefix + TM_OPTION, widgetWidth - 2 - 5); // 2px border left/right + 5px left margin\n            }\n        }\n    }","id":45154,"modified_method":"/**\n     * @see org.opencms.gwt.client.ui.I_CmsTruncable#truncate(java.lang.String, int)\n     */\n    public void truncate(String textMetricsPrefix, int widgetWidth) {\n\n        m_openerLabel.truncate(textMetricsPrefix + TM_OPENER_LABEL, widgetWidth);\n        int labelWidth = widgetWidth - 2 - 5; // 2px border left/right + 5px left margin\n        for (Widget widget : m_selector) {\n            if (widget instanceof I_CmsTruncable) {\n                ((I_CmsTruncable)widget).truncate(textMetricsPrefix + TM_OPTION, labelWidth);\n            }\n        }\n    }","commit_id":"87b4ea4aea6809d8ca5fcdefbf148af949e098af","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public TYPE get(final int index) {\r\n\t\tTYPE o = (TYPE) list.get(index);\r\n\t\tif (o == null) {\r\n\t\t\tOIdentifiable record = (OIdentifiable) recordList.get(index);\r\n\t\t\to = OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(), getDatabase().getEntityManager(), (ODocument) record.getRecord());\r\n\t\t\tlist.set(index, o);\r\n\t\t}\r\n\t\treturn o;\r\n\t}","id":45155,"modified_method":"public TYPE get(final int index) {\r\n    TYPE o = (TYPE) list.get(index);\r\n    if (o == null) {\r\n      OIdentifiable record = (OIdentifiable) recordList.get(index);\r\n      o = (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(),\r\n          getDatabase().getEntityManager(), (ODocument) record.getRecord());\r\n      list.set(index, o);\r\n    }\r\n    return o;\r\n  }","commit_id":"7e1e85e0f06dd706cd68aae44c97007ac86cf638","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public TYPE remove(int index) {\r\n\t\tTYPE element;\r\n\t\tOIdentifiable record = recordList.remove(index);\r\n\t\tif (indexLoaded(index)) {\r\n\t\t\telement = (TYPE) list.remove(index);\r\n\t\t} else {\r\n\t\t\telement = OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(), getDatabase().getEntityManager(),\r\n\t\t\t\t\t(ODocument) record.getRecord());\r\n\t\t}\r\n\t\tsetDirty();\r\n\t\treturn element;\r\n\t}","id":45156,"modified_method":"public TYPE remove(int index) {\r\n    TYPE element;\r\n    OIdentifiable record = recordList.remove(index);\r\n    if (indexLoaded(index)) {\r\n      element = (TYPE) list.remove(index);\r\n    } else {\r\n      element = (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(),\r\n          getDatabase().getEntityManager(), (ODocument) record.getRecord());\r\n    }\r\n    setDirty();\r\n    return element;\r\n  }","commit_id":"7e1e85e0f06dd706cd68aae44c97007ac86cf638","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public TYPE get(final int index) {\r\n\t\tTYPE o = (TYPE) list.get(index);\r\n\t\tif (o == null) {\r\n\t\t\tOIdentifiable record = (OIdentifiable) recordList.get(index);\r\n\t\t\to = (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(),\r\n\t\t\t\t\tgetDatabase().getEntityManager(), (ODocument) record.getRecord(), sourceRecord);\r\n\t\t\tlist.set(index, o);\r\n\t\t}\r\n\t\treturn o;\r\n\t}","id":45157,"modified_method":"public TYPE get(final int index) {\r\n    TYPE o = (TYPE) super.get(index);\r\n    if (o == null) {\r\n      OIdentifiable record = (OIdentifiable) recordList.get(index);\r\n      o = (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(),\r\n          getDatabase().getEntityManager(), (ODocument) record.getRecord(), sourceRecord);\r\n      super.set(index, o);\r\n    }\r\n    return o;\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public <T> T[] toArray(final T[] a) {\r\n\t\tconvertAll();\r\n\t\treturn list.toArray(a);\r\n\t}","id":45158,"modified_method":"public <T> T[] toArray(final T[] a) {\r\n    convertAll();\r\n    return super.toArray(a);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void add(int index, TYPE element) {\r\n\t\tsetDirty();\r\n\t\tif (element instanceof OIdentifiable) {\r\n\t\t\tif (converted)\r\n\t\t\t\tconverted = false;\r\n\t\t\trecordList.add(index, (OIdentifiable) element);\r\n\t\t\treturn;\r\n\t\t} else if (element instanceof Proxy)\r\n\t\t\trecordList.add(OObjectEntitySerializer.getDocument((Proxy) element));\r\n\t\telse {\r\n\t\t\telement = (TYPE) OObjectEntitySerializer.serializeObject(element, getDatabase());\r\n\t\t\trecordList.add(index, OObjectEntitySerializer.getDocument((Proxy) element));\r\n\t\t}\r\n\t\tlist.add(index, element);\r\n\t}","id":45159,"modified_method":"public void add(int index, TYPE element) {\r\n    setDirty();\r\n    if (element instanceof OIdentifiable) {\r\n      if (converted)\r\n        converted = false;\r\n      recordList.add(index, (OIdentifiable) element);\r\n      return;\r\n    } else if (element instanceof Proxy)\r\n      recordList.add(OObjectEntitySerializer.getDocument((Proxy) element));\r\n    else {\r\n      element = (TYPE) OObjectEntitySerializer.serializeObject(element, getDatabase());\r\n      recordList.add(index, OObjectEntitySerializer.getDocument((Proxy) element));\r\n    }\r\n    super.add(index, element);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OObjectLazyList(final Object iSourceRecord, final List<OIdentifiable> iRecordList,\r\n\t\t\tfinal Collection<? extends TYPE> iSourceList) {\r\n\t\tthis.sourceRecord = iSourceRecord instanceof ProxyObject ? (ProxyObject) iSourceRecord : null;\r\n\t\tthis.recordList = iRecordList;\r\n\t\tfor (int i = 0; i < iRecordList.size(); i++) {\r\n\t\t\tlist.add(i, null);\r\n\t\t}\r\n\t\taddAll(iSourceList);\r\n\t}","id":45160,"modified_method":"public OObjectLazyList(final Object iSourceRecord, final List<OIdentifiable> iRecordList,\r\n      final Collection<? extends TYPE> iSourceList) {\r\n    this.sourceRecord = iSourceRecord instanceof ProxyObject ? (ProxyObject) iSourceRecord : null;\r\n    this.recordList = iRecordList;\r\n    for (int i = 0; i < iRecordList.size(); i++) {\r\n      super.add(i, null);\r\n    }\r\n    addAll(iSourceList);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int indexOf(final Object o) {\r\n\t\tif (o instanceof Proxy)\r\n\t\t\treturn recordList.indexOf(OObjectEntitySerializer.getDocument((Proxy) o));\r\n\t\telse if (o instanceof OIdentifiable)\r\n\t\t\treturn recordList.indexOf(o);\r\n\t\tconvertAll();\r\n\t\treturn list.indexOf(o);\r\n\t}","id":45161,"modified_method":"public int indexOf(final Object o) {\r\n    if (o instanceof Proxy)\r\n      return recordList.indexOf(OObjectEntitySerializer.getDocument((Proxy) o));\r\n    else if (o instanceof OIdentifiable)\r\n      return recordList.indexOf(o);\r\n    convertAll();\r\n    return super.indexOf(o);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Convert the item requested.\r\n\t * \r\n\t * @param iIndex\r\n\t *          Position of the item to convert\r\n\t */\r\n\tprivate void convert(final int iIndex) {\r\n\t\tif (converted || !convertToRecord)\r\n\t\t\treturn;\r\n\r\n\t\tObject o = list.get(iIndex);\r\n\t\tif (o == null) {\r\n\r\n\t\t\tfinal ODatabaseRecord database = getDatabase().getUnderlying();\r\n\r\n\t\t\to = recordList.get(iIndex);\r\n\t\t\tODocument doc;\r\n\t\t\tif (o instanceof ORID) {\r\n\t\t\t\tdoc = database.load((ORID) o, fetchPlan);\r\n\t\t\t} else {\r\n\t\t\t\tdoc = (ODocument) o;\r\n\t\t\t}\r\n\t\t\tlist.set(\r\n\t\t\t\t\tiIndex,\r\n\t\t\t\t\tOObjectEntityEnhancer.getInstance().getProxiedInstance(doc.getClassName(), getDatabase().getEntityManager(), doc,\r\n\t\t\t\t\t\t\tsourceRecord));\r\n\t\t}\r\n\t}","id":45162,"modified_method":"/**\r\n   * Convert the item requested.\r\n   * \r\n   * @param iIndex\r\n   *          Position of the item to convert\r\n   */\r\n  private void convert(final int iIndex) {\r\n    if (converted || !convertToRecord)\r\n      return;\r\n\r\n    Object o = super.get(iIndex);\r\n    if (o == null) {\r\n\r\n      final ODatabaseRecord database = getDatabase().getUnderlying();\r\n\r\n      o = recordList.get(iIndex);\r\n      ODocument doc;\r\n      if (o instanceof ORID) {\r\n        doc = database.load((ORID) o, fetchPlan);\r\n      } else {\r\n        doc = (ODocument) o;\r\n      }\r\n      super.set(\r\n          iIndex,\r\n          (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(doc.getClassName(), getDatabase().getEntityManager(), doc,\r\n              sourceRecord));\r\n    }\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ListIterator<TYPE> listIterator() {\r\n\t\treturn (ListIterator<TYPE>) list.listIterator();\r\n\t}","id":45163,"modified_method":"public ListIterator<TYPE> listIterator() {\r\n    return (ListIterator<TYPE>) super.listIterator();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void clear() {\r\n\t\tsetDirty();\r\n\t\trecordList.clear();\r\n\t\tlist.clear();\r\n\t}","id":45164,"modified_method":"public void clear() {\r\n    setDirty();\r\n    recordList.clear();\r\n    super.clear();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OObjectLazyList(final Object iSourceRecord, final List<OIdentifiable> iRecordList) {\r\n\t\tthis.sourceRecord = iSourceRecord instanceof ProxyObject ? (ProxyObject) iSourceRecord : null;\r\n\t\tthis.recordList = iRecordList;\r\n\t\tfor (int i = 0; i < iRecordList.size(); i++) {\r\n\t\t\tlist.add(i, null);\r\n\t\t}\r\n\t}","id":45165,"modified_method":"public OObjectLazyList(final Object iSourceRecord, final List<OIdentifiable> iRecordList) {\r\n    this.sourceRecord = iSourceRecord instanceof ProxyObject ? (ProxyObject) iSourceRecord : null;\r\n    this.recordList = iRecordList;\r\n    for (int i = 0; i < iRecordList.size(); i++) {\r\n      super.add(i, null);\r\n    }\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void convertAndDetachAll(final int iIndex, boolean nonProxiedInstance) {\r\n\t\tif (converted || !convertToRecord)\r\n\t\t\treturn;\r\n\r\n\t\tObject o = list.get(iIndex);\r\n\t\tif (o == null) {\r\n\r\n\t\t\tfinal ODatabaseRecord database = getDatabase().getUnderlying();\r\n\r\n\t\t\to = recordList.get(iIndex);\r\n\t\t\tODocument doc;\r\n\t\t\tif (o instanceof ORID) {\r\n\t\t\t\tdoc = database.load((ORID) o, fetchPlan);\r\n\t\t\t} else {\r\n\t\t\t\tdoc = (ODocument) o;\r\n\t\t\t}\r\n\t\t\to = OObjectEntityEnhancer.getInstance().getProxiedInstance(doc.getClassName(), getDatabase().getEntityManager(), doc,\r\n\t\t\t\t\tsourceRecord);\r\n\t\t\to = ((OObjectDatabaseTx) getDatabase()).detachAll(o, nonProxiedInstance);\r\n\t\t\tlist.set(iIndex, o);\r\n\t\t}\r\n\t}","id":45166,"modified_method":"private void convertAndDetachAll(final int iIndex, boolean nonProxiedInstance) {\r\n    if (converted || !convertToRecord)\r\n      return;\r\n\r\n    Object o = super.get(iIndex);\r\n    if (o == null) {\r\n\r\n      final ODatabaseRecord database = getDatabase().getUnderlying();\r\n\r\n      o = recordList.get(iIndex);\r\n      ODocument doc;\r\n      if (o instanceof ORID) {\r\n        doc = database.load((ORID) o, fetchPlan);\r\n      } else {\r\n        doc = (ODocument) o;\r\n      }\r\n      o = OObjectEntityEnhancer.getInstance().getProxiedInstance(doc.getClassName(), getDatabase().getEntityManager(), doc,\r\n          sourceRecord);\r\n      o = ((OObjectDatabaseTx) getDatabase()).detachAll(o, nonProxiedInstance);\r\n      super.set(iIndex, (TYPE) o);\r\n    }\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic String toString() {\r\n\t\treturn list.toString();\r\n\t}","id":45167,"modified_method":"@Override\r\n  public String toString() {\r\n    return super.toString();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ListIterator<TYPE> listIterator(int index) {\r\n\t\treturn (ListIterator<TYPE>) list.listIterator(index);\r\n\t}","id":45168,"modified_method":"public ListIterator<TYPE> listIterator(int index) {\r\n    return (ListIterator<TYPE>) super.listIterator(index);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public TYPE set(int index, TYPE element) {\r\n\t\tif (element instanceof OIdentifiable) {\r\n\t\t\tif (converted)\r\n\t\t\t\tconverted = false;\r\n\t\t\trecordList.set(index, (OIdentifiable) element);\r\n\t\t} else if (element instanceof Proxy)\r\n\t\t\trecordList.set(index, OObjectEntitySerializer.getDocument((Proxy) element));\r\n\t\telse {\r\n\t\t\telement = (TYPE) OObjectEntitySerializer.serializeObject(element, getDatabase());\r\n\t\t\trecordList.add(index, OObjectEntitySerializer.getDocument((Proxy) element));\r\n\t\t}\r\n\t\tsetDirty();\r\n\t\treturn (TYPE) list.set(index, element);\r\n\t}","id":45169,"modified_method":"public TYPE set(int index, TYPE element) {\r\n    if (element instanceof OIdentifiable) {\r\n      if (converted)\r\n        converted = false;\r\n      recordList.set(index, (OIdentifiable) element);\r\n    } else if (element instanceof Proxy)\r\n      recordList.set(index, OObjectEntitySerializer.getDocument((Proxy) element));\r\n    else {\r\n      element = (TYPE) OObjectEntitySerializer.serializeObject(element, getDatabase());\r\n      recordList.add(index, OObjectEntitySerializer.getDocument((Proxy) element));\r\n    }\r\n    setDirty();\r\n    return (TYPE) super.set(index, element);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean add(TYPE element) {\r\n\t\tboolean dirty = false;\r\n\t\tif (element instanceof OIdentifiable) {\r\n\t\t\tif (converted)\r\n\t\t\t\tconverted = false;\r\n\t\t\tif (recordList.add((OIdentifiable) element)) {\r\n\t\t\t\tsetDirty();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (element instanceof Proxy)\r\n\t\t\tdirty = recordList.add((OIdentifiable) OObjectEntitySerializer.getDocument((Proxy) element));\r\n\t\telse {\r\n\t\t\telement = (TYPE) OObjectEntitySerializer.serializeObject(element, getDatabase());\r\n\t\t\tdirty = recordList.add((OIdentifiable) OObjectEntitySerializer.getDocument((Proxy) element));\r\n\t\t}\r\n\t\tif (dirty)\r\n\t\t\tsetDirty();\r\n\t\treturn list.add(element);\r\n\t}","id":45170,"modified_method":"public boolean add(TYPE element) {\r\n    boolean dirty = false;\r\n    if (element instanceof OIdentifiable) {\r\n      if (converted)\r\n        converted = false;\r\n      if (recordList.add((OIdentifiable) element)) {\r\n        setDirty();\r\n        return true;\r\n      }\r\n    } else if (element instanceof Proxy)\r\n      dirty = recordList.add((OIdentifiable) OObjectEntitySerializer.getDocument((Proxy) element));\r\n    else {\r\n      element = (TYPE) OObjectEntitySerializer.serializeObject(element, getDatabase());\r\n      dirty = recordList.add((OIdentifiable) OObjectEntitySerializer.getDocument((Proxy) element));\r\n    }\r\n    if (dirty)\r\n      setDirty();\r\n    return super.add(element);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean contains(final Object o) {\r\n\t\tif (o instanceof Proxy)\r\n\t\t\treturn recordList.contains(OObjectEntitySerializer.getDocument((Proxy) o));\r\n\t\telse if (o instanceof OIdentifiable)\r\n\t\t\treturn recordList.contains(o);\r\n\t\tconvertAll();\r\n\t\treturn list.contains(o);\r\n\t}","id":45171,"modified_method":"public boolean contains(final Object o) {\r\n    if (o instanceof Proxy)\r\n      return recordList.contains(OObjectEntitySerializer.getDocument((Proxy) o));\r\n    else if (o instanceof OIdentifiable)\r\n      return recordList.contains(o);\r\n    convertAll();\r\n    return super.contains(o);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public List<TYPE> subList(int fromIndex, int toIndex) {\r\n\t\treturn (List<TYPE>) list.subList(fromIndex, toIndex);\r\n\t}","id":45172,"modified_method":"public List<TYPE> subList(int fromIndex, int toIndex) {\r\n    return (List<TYPE>) super.subList(fromIndex, toIndex);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int lastIndexOf(final Object o) {\r\n\t\tif (o instanceof Proxy)\r\n\t\t\treturn recordList.lastIndexOf(OObjectEntitySerializer.getDocument((Proxy) o));\r\n\t\telse if (o instanceof OIdentifiable)\r\n\t\t\treturn recordList.lastIndexOf(o);\r\n\t\tconvertAll();\r\n\t\treturn list.lastIndexOf(o);\r\n\t}","id":45173,"modified_method":"public int lastIndexOf(final Object o) {\r\n    if (o instanceof Proxy)\r\n      return recordList.lastIndexOf(OObjectEntitySerializer.getDocument((Proxy) o));\r\n    else if (o instanceof OIdentifiable)\r\n      return recordList.lastIndexOf(o);\r\n    convertAll();\r\n    return super.lastIndexOf(o);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public TYPE remove(int index) {\r\n\t\tTYPE element;\r\n\t\tOIdentifiable record = recordList.remove(index);\r\n\t\tif (indexLoaded(index)) {\r\n\t\t\telement = (TYPE) list.remove(index);\r\n\t\t} else {\r\n\t\t\telement = (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(),\r\n\t\t\t\t\tgetDatabase().getEntityManager(), (ODocument) record.getRecord(), sourceRecord);\r\n\t\t}\r\n\t\tsetDirty();\r\n\t\treturn element;\r\n\t}","id":45174,"modified_method":"public TYPE remove(int index) {\r\n    TYPE element;\r\n    OIdentifiable record = recordList.remove(index);\r\n    if (indexLoaded(index)) {\r\n      element = (TYPE) super.remove(index);\r\n    } else {\r\n      element = (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(((ODocument) record.getRecord()).getClassName(),\r\n          getDatabase().getEntityManager(), (ODocument) record.getRecord(), sourceRecord);\r\n    }\r\n    setDirty();\r\n    return element;\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object[] toArray() {\r\n\t\tconvertAll();\r\n\t\treturn list.toArray();\r\n\t}","id":45175,"modified_method":"public Object[] toArray() {\r\n    convertAll();\r\n    return super.toArray();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean remove(Object o) {\r\n\t\tsetDirty();\r\n\t\tif (o instanceof OIdentifiable) {\r\n\t\t\tint elementIndex = recordList.indexOf(o);\r\n\t\t\tif (indexLoaded(elementIndex))\r\n\t\t\t\tlist.remove(elementIndex);\r\n\t\t\treturn recordList.remove(o);\r\n\t\t} else if (o instanceof Proxy)\r\n\t\t\trecordList.remove((OIdentifiable) OObjectEntitySerializer.getDocument((Proxy) o));\r\n\t\treturn list.remove(o);\r\n\t}","id":45176,"modified_method":"public boolean remove(Object o) {\r\n    setDirty();\r\n    if (o instanceof OIdentifiable) {\r\n      int elementIndex = recordList.indexOf(o);\r\n      if (indexLoaded(elementIndex))\r\n        super.remove(elementIndex);\r\n      return recordList.remove(o);\r\n    } else if (o instanceof Proxy)\r\n      recordList.remove((OIdentifiable) OObjectEntitySerializer.getDocument((Proxy) o));\r\n    return super.remove(o);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean indexLoaded(int iIndex) {\r\n\t\treturn list.get(iIndex) != null;\r\n\t}","id":45177,"modified_method":"protected boolean indexLoaded(int iIndex) {\r\n    return super.get(iIndex) != null;\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void convertAll() {\r\n\t\tif (converted || !convertToRecord)\r\n\t\t\treturn;\r\n\r\n\t\tfinal Set<Object> copy = new HashSet<Object>(underlying);\r\n\t\tthis.clear();\r\n\t\tfinal ODatabasePojoAbstract<TYPE> database = getDatabase();\r\n\t\tfor (Object e : copy) {\r\n\t\t\tif (e != null) {\r\n\t\t\t\tif (e instanceof ORID)\r\n\t\t\t\t\tadd(database.getUserObjectByRecord(\r\n\t\t\t\t\t\t\t(ORecordInternal<?>) ((ODatabaseRecord) getDatabase().getUnderlying()).load((ORID) e, fetchPlan), fetchPlan));\r\n\t\t\t\telse if (e instanceof ODocument)\r\n\t\t\t\t\tadd(database.getUserObjectByRecord((ORecordInternal<?>) e, fetchPlan));\r\n\t\t\t\telse\r\n\t\t\t\t\tadd((TYPE) e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconverted = true;\r\n\t}","id":45178,"modified_method":"protected void convertAll() {\r\n    if (converted || !convertToRecord)\r\n      return;\r\n\r\n    final Set<Object> copy = new HashSet<Object>(underlying);\r\n    super.clear();\r\n    final ODatabasePojoAbstract<TYPE> database = getDatabase();\r\n    for (Object e : copy) {\r\n      if (e != null) {\r\n        if (e instanceof ORID)\r\n          add(database.getUserObjectByRecord(\r\n              (ORecordInternal<?>) ((ODatabaseRecord) getDatabase().getUnderlying()).load((ORID) e, fetchPlan), fetchPlan));\r\n        else if (e instanceof ODocument)\r\n          add(database.getUserObjectByRecord((ORecordInternal<?>) e, fetchPlan));\r\n        else\r\n          add((TYPE) e);\r\n      }\r\n    }\r\n\r\n    converted = true;\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void clear() {\r\n\t\tsetDirty();\r\n\t\tunderlying.clear();\r\n\t}","id":45179,"modified_method":"public void clear() {\r\n    setDirty();\r\n    super.clear();\r\n    underlying.clear();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void convertAndDetachAll(boolean nonProxiedInstance) {\r\n\t\tif (converted || !convertToRecord)\r\n\t\t\treturn;\r\n\r\n\t\tfinal Set<Object> copy = new HashSet<Object>(underlying);\r\n\t\tthis.clear();\r\n\t\tfinal ODatabasePojoAbstract<TYPE> database = getDatabase();\r\n\t\tfor (Object e : copy) {\r\n\t\t\tif (e != null) {\r\n\t\t\t\tif (e instanceof ORID) {\r\n\t\t\t\t\te = database.getUserObjectByRecord(\r\n\t\t\t\t\t\t\t(ORecordInternal<?>) ((ODatabaseRecord) getDatabase().getUnderlying()).load((ORID) e, fetchPlan), fetchPlan);\r\n\t\t\t\t\te = ((OObjectDatabaseTx) getDatabase()).detachAll(e, nonProxiedInstance);\r\n\t\t\t\t} else if (e instanceof ODocument) {\r\n\t\t\t\t\te = database.getUserObjectByRecord((ORecordInternal<?>) e, fetchPlan);\r\n\t\t\t\t\te = ((OObjectDatabaseTx) getDatabase()).detachAll(e, nonProxiedInstance);\r\n\t\t\t\t} else\r\n\t\t\t\t\tadd((TYPE) e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconverted = true;\r\n\t}","id":45180,"modified_method":"protected void convertAndDetachAll(boolean nonProxiedInstance) {\r\n    if (converted || !convertToRecord)\r\n      return;\r\n\r\n    final Set<Object> copy = new HashSet<Object>(underlying);\r\n    super.clear();\r\n    final ODatabasePojoAbstract<TYPE> database = getDatabase();\r\n    for (Object e : copy) {\r\n      if (e != null) {\r\n        if (e instanceof ORID) {\r\n          e = database.getUserObjectByRecord(\r\n              (ORecordInternal<?>) ((ODatabaseRecord) getDatabase().getUnderlying()).load((ORID) e, fetchPlan), fetchPlan);\r\n          super.add((TYPE) ((OObjectDatabaseTx) getDatabase()).detachAll(e, nonProxiedInstance));\r\n        } else if (e instanceof ODocument) {\r\n          e = database.getUserObjectByRecord((ORecordInternal<?>) e, fetchPlan);\r\n          super.add((TYPE) ((OObjectDatabaseTx) getDatabase()).detachAll(e, nonProxiedInstance));\r\n        } else\r\n          add((TYPE) e);\r\n      }\r\n    }\r\n\r\n    converted = true;\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean remove(final Object o) {\r\n\t\tsetDirty();\r\n\t\treturn underlying.remove(getDatabase().getRecordByUserObject(o, false));\r\n\t}","id":45181,"modified_method":"public boolean remove(final Object o) {\r\n    setDirty();\r\n    return super.remove(o) && underlying.remove(getDatabase().getRecordByUserObject(o, false));\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean contains(final Object o) {\r\n\t\treturn underlying.contains(getDatabase().getRecordByUserObject(o, false));\r\n\t}","id":45182,"modified_method":"public boolean contains(final Object o) {\r\n    return super.contains(o) || underlying.contains(getDatabase().getRecordByUserObject(o, false));\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public <T> T[] toArray(final T[] a) {\r\n\t\tunderlying.toArray(a);\r\n\t\tfinal ODatabasePojoAbstract<TYPE> database = getDatabase();\r\n\t\tfor (int i = 0; i < a.length; ++i)\r\n\t\t\ta[i] = (T) database.getUserObjectByRecord((OIdentifiable) a[i], fetchPlan);\r\n\t\treturn a;\r\n\t}","id":45183,"modified_method":"public <T> T[] toArray(final T[] a) {\r\n    convertAll();\r\n    return super.toArray(a);\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean retainAll(final Collection<?> c) {\r\n\t\tsetDirty();\r\n\t\treturn underlying.retainAll(c);\r\n\t}","id":45184,"modified_method":"public boolean retainAll(final Collection<?> c) {\r\n    setDirty();\r\n    final ODatabasePojoAbstract<TYPE> database = getDatabase();\r\n    boolean modified = super.retainAll(c);\r\n    Set<Object> toRetain = new HashSet<Object>();\r\n    for (Object o : c) {\r\n      toRetain.add(database.getRecordByUserObject(o, false));\r\n      if (underlying.retainAll(toRetain))\r\n        modified = true;\r\n    }\r\n    return modified;\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic String toString() {\r\n\t\treturn underlying.toString();\r\n\t}","id":45185,"modified_method":"@Override\r\n  public String toString() {\r\n    return super.size() == underlying.size() ? super.toString() : underlying.toString();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean isEmpty() {\r\n\t\treturn underlying.isEmpty();\r\n\t}","id":45186,"modified_method":"public boolean isEmpty() {\r\n    return super.isEmpty() && underlying.isEmpty();\r\n  }","commit_id":"27b02004f63aac4d34e41bd77559670a4200790c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * To be called the first time the page is opened, using a password reset link.\n     * \n     * @return true if the reset link is valid and the form to change the password is being displayed, false otherwise.\n     */\n    public boolean isResetLinkValid()\n    {\n        // If we see the form, the the link is valid.\n        return !getDriver().findElements(By.cssSelector(\".xcontent form\")).isEmpty();\n    }","id":45187,"modified_method":"/**\n     * To be called the first time the page is opened, using a password reset link.\n     * \n     * @return true if the reset link is valid and the form to change the password is being displayed, false otherwise.\n     */\n    public boolean isResetLinkValid()\n    {\n        // If we see the form, the the link is valid.\n        return getDriver().hasElementWithoutWaiting(By.cssSelector(\".xcontent form\"));\n    }","commit_id":"a2fb0563811158da1bdf073195aa5e5e855f014e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean isPasswordSuccessfullyReset()\n    {\n        // success = no form and a message that is not error or warning.\n        return getDriver().findElements(By.cssSelector(\".xcontent form\")).isEmpty()\n            && messageBox.getAttribute(\"class\").contains(\"infomessage\");\n    }","id":45188,"modified_method":"public boolean isPasswordSuccessfullyReset()\n    {\n        // success = no form and a message that is not error or warning.\n        return !getDriver().hasElementWithoutWaiting(By.cssSelector(\".xcontent form\"))\n            && messageBox.getAttribute(\"class\").contains(\"infomessage\");\n    }","commit_id":"a2fb0563811158da1bdf073195aa5e5e855f014e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean isResetPasswordSent()\n    {\n        return getDriver().findElements(By.cssSelector(\".xcontent form\")).isEmpty()\n            && messageBox.getAttribute(\"class\").contains(\"infomessage\");\n    }","id":45189,"modified_method":"public boolean isResetPasswordSent()\n    {\n        // If there is no form and we see an info box, then the request was sent.\n        return !getDriver().hasElementWithoutWaiting(By.cssSelector(\".xcontent form\"))\n            && messageBox.getAttribute(\"class\").contains(\"infomessage\");\n    }","commit_id":"a2fb0563811158da1bdf073195aa5e5e855f014e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void init() {\n      myContentPanel.setContent(myViewer.getComponent());\n\n      if (myTitleLabel != null) {\n        myTitleLabel.setText(myActiveRequest.getWindowTitle());\n      }\n      else {\n        setWindowTitle(myActiveRequest.getWindowTitle());\n      }\n\n      myPanel.validate();\n\n      FrameDiffTool.ToolbarComponents toolbarComponents = myViewer.init();\n\n      buildToolbar(toolbarComponents.toolbarActions);\n      buildActionPopup(toolbarComponents.popupActions);\n\n      myToolbarStatusPanel.setContent(toolbarComponents.statusPanel);\n\n      myPanel.validate();\n    }","id":45190,"modified_method":"@Override\n    public void init() {\n      myContentPanel.setContent(myViewer.getComponent());\n\n      setTitle(myActiveRequest.getWindowTitle());\n\n      myPanel.validate();\n\n      FrameDiffTool.ToolbarComponents toolbarComponents = myViewer.init();\n\n      buildToolbar(toolbarComponents.toolbarActions);\n      buildActionPopup(toolbarComponents.popupActions);\n\n      myToolbarStatusPanel.setContent(toolbarComponents.statusPanel);\n\n      myPanel.validate();\n    }","commit_id":"6811860873201f7ecc4f61d14cce2bf9ca03f977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void init() {\n      myContentPanel.setContent(myWrapperViewer.getComponent());\n\n      if (myTitleLabel != null) {\n        myTitleLabel.setText(myActiveRequest.getWindowTitle());\n      }\n      else {\n        setWindowTitle(myActiveRequest.getWindowTitle());\n      }\n\n      myPanel.validate();\n\n\n      FrameDiffTool.ToolbarComponents toolbarComponents1 = myViewer.init();\n      FrameDiffTool.ToolbarComponents toolbarComponents2 = myWrapperViewer.init();\n\n      List<AnAction> toolbarActions = new ArrayList<AnAction>();\n      if (toolbarComponents1.toolbarActions != null) toolbarActions.addAll(toolbarComponents1.toolbarActions);\n      if (toolbarComponents2.toolbarActions != null) {\n        if (!toolbarActions.isEmpty() && !toolbarComponents2.toolbarActions.isEmpty()) toolbarActions.add(Separator.getInstance());\n        toolbarActions.addAll(toolbarComponents2.toolbarActions);\n      }\n      buildToolbar(toolbarActions);\n\n      List<AnAction> popupActions = new ArrayList<AnAction>();\n      if (toolbarComponents1.popupActions != null) popupActions.addAll(toolbarComponents1.popupActions);\n      if (toolbarComponents2.popupActions != null) {\n        if (!popupActions.isEmpty() && !toolbarComponents2.popupActions.isEmpty()) popupActions.add(Separator.getInstance());\n        popupActions.addAll(toolbarComponents2.popupActions);\n      }\n      buildActionPopup(popupActions);\n\n\n      myToolbarStatusPanel.setContent(toolbarComponents2.statusPanel); // TODO: combine both panels ?\n\n      myPanel.validate();\n    }","id":45191,"modified_method":"@Override\n    public void init() {\n      myContentPanel.setContent(myWrapperViewer.getComponent());\n\n      setTitle(myActiveRequest.getWindowTitle());\n\n      myPanel.validate();\n\n\n      FrameDiffTool.ToolbarComponents toolbarComponents1 = myViewer.init();\n      FrameDiffTool.ToolbarComponents toolbarComponents2 = myWrapperViewer.init();\n\n      List<AnAction> toolbarActions = new ArrayList<AnAction>();\n      if (toolbarComponents1.toolbarActions != null) toolbarActions.addAll(toolbarComponents1.toolbarActions);\n      if (toolbarComponents2.toolbarActions != null) {\n        if (!toolbarActions.isEmpty() && !toolbarComponents2.toolbarActions.isEmpty()) toolbarActions.add(Separator.getInstance());\n        toolbarActions.addAll(toolbarComponents2.toolbarActions);\n      }\n      buildToolbar(toolbarActions);\n\n      List<AnAction> popupActions = new ArrayList<AnAction>();\n      if (toolbarComponents1.popupActions != null) popupActions.addAll(toolbarComponents1.popupActions);\n      if (toolbarComponents2.popupActions != null) {\n        if (!popupActions.isEmpty() && !toolbarComponents2.popupActions.isEmpty()) popupActions.add(Separator.getInstance());\n        popupActions.addAll(toolbarComponents2.popupActions);\n      }\n      buildActionPopup(popupActions);\n\n\n      myToolbarStatusPanel.setContent(toolbarComponents2.statusPanel); // TODO: combine both panels ?\n\n      myPanel.validate();\n    }","commit_id":"6811860873201f7ecc4f61d14cce2bf9ca03f977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (item.getItemId() == CONNECT_TO) {\n\t\t\tconnectToDevice();\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == SETTINGS_ID) {\n\t\t\tstartActivity(new Intent(this, SettingsOsMoActivity.class));\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == SHARE_SESSION) {\n\t\t\tshareSession();\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == CREATE_GROUP) {\n\t\t\tcreateGroup(true);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}","id":45192,"modified_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (item.getItemId() == CONNECT_TO) {\n\t\t\tconnectToDevice();\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == SETTINGS_ID) {\n\t\t\tstartActivity(new Intent(this, SettingsOsMoActivity.class));\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == LOGIN_ID) {\n\t\t\tloginDialog();\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == SHARE_SESSION) {\n\t\t\tshareSession();\n\t\t\treturn true;\n\t\t} else if (item.getItemId() == CREATE_GROUP) {\n\t\t\tcreateGroup(true);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}","commit_id":"ee69e3f4c634e55401c9561400057d813d1d2308","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void signinPost(final boolean createGroup) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.osmo_sign_in);\n\t\tLinearLayout ll = new LinearLayout(this);\n\t\tll.setOrientation(LinearLayout.VERTICAL);\n\t\tll.setPadding(5, 5, 5, 5);\n\t\tsetSupportProgressBarIndeterminateVisibility(true);\n\t\tfinal WebView wv = new WebView(this);\n\t\twv.loadUrl(OsMoService.SIGN_IN_URL + app.getSettings().OSMO_DEVICE_KEY.get());\n\t\tll.addView(wv);\n\t\tfinal EditText et = new EditText(this);\n\t\tet.setVisibility(View.GONE);\n\t\tll.addView(et);\n\t\tScrollView scrollView = new ScrollView(this);\n\t\tscrollView.addView(ll);\n\t\tbuilder.setView(scrollView);\n\t\twv.setFocusable(true);\n        wv.setFocusableInTouchMode(true);\n\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\twv.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tif (!v.hasFocus()) {\n\t\t\t\t\t\tv.requestFocus();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\tbuilder.setCancelable(true);\n\t\tbuilder.setOnCancelListener(new OnCancelListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onCancel(DialogInterface dialog) {\n\t\t\t\tif (!createGroup) {\n\t\t\t\t\tupdateStatus();\n\t\t\t\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfinal AlertDialog dlg = builder.show();\n\t\t\n\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onPageFinished(WebView view, String url) {\n\t\t\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\t\t}\n\t\t    public boolean shouldOverrideUrlLoading(WebView view, String url){\n\t\t\t\tif (url.contains(OsMoService.SIGNED_IN_CONTAINS)) {\n\t\t\t\t\tUri data = Uri.parse(url);\n\t\t\t\t\tString user = data.getQueryParameter(\"u\");\n\t\t\t\t\tString pwd = data.getQueryParameter(\"p\");\n\t\t\t\t\tapp.getSettings().OSMO_USER_NAME.set(user);\n\t\t\t\t\tapp.getSettings().OSMO_USER_PWD.set(pwd);\n\t\t\t\t\tosMoPlugin.getService().reconnectToServer();\n\t\t\t\t\tif (createGroup) {\n\t\t\t\t\t\tcreateGroupWithDelay(3000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateStatus();\n\t\t\t\t\t}\n\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t        return false; // then it is not handled by default action\n\t\t   }\n\t\t});\n\t}","id":45193,"modified_method":"private void signinPost(final boolean createGroup) {\n\t\tfinal Dialog dialog = new Dialog(this, \n\t\t\t\tapp.getSettings().isLightContent() ?\n\t\t\t\t\t\tR.style.OsmandLightTheme:\n\t\t\t\t\t\t\tR.style.OsmandDarkTheme);\n\t\tLinearLayout ll = new LinearLayout(this);\n\t\tll.setOrientation(LinearLayout.VERTICAL);\n\t\tToolbar tb = new Toolbar(this);\n\t\ttb.setClickable(true);\n\t\tDrawable back = ((OsmandApplication)getApplication()).getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);\n\t\ttb.setNavigationIcon(back);\n\t\ttb.setTitle(R.string.osmo_sign_in);\n\t\ttb.setBackgroundColor(getResources().getColor( getResIdFromAttribute(this, R.attr.pstsTabBackground)));\n\t\ttb.setTitleTextColor(getResources().getColor(getResIdFromAttribute(this, R.attr.pstsTextColor)));\n\t\ttb.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(final View v) {\n\t\t\t\tdialog.dismiss();\n\t\t\t}\n\t\t});\n\t\tsetSupportProgressBarIndeterminateVisibility(true);\n\t\tfinal WebView wv = new WebView(this);\n\t\twv.loadUrl(OsMoService.SIGN_IN_URL + app.getSettings().OSMO_DEVICE_KEY.get());\n\t\tScrollView scrollView = new ScrollView(this);\n\t\tint pad = (int) getResources().getDimension(R.dimen.list_content_padding);\n//\t\tscrollView.setPadding(pad, pad, pad, pad);\n\t\tll.addView(tb);\n\t\tll.addView(scrollView);\n\t\tscrollView.addView(wv);\n\t\tdialog.setContentView(ll);\n\t\twv.setFocusable(true);\n        wv.setFocusableInTouchMode(true);\n\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\twv.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tif (!v.hasFocus()) {\n\t\t\t\t\t\tv.requestFocus();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\tdialog.setCancelable(true);\n\t\tdialog.setOnCancelListener(new OnCancelListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onCancel(DialogInterface dialog) {\n\t\t\t\tif (!createGroup) {\n\t\t\t\t\tupdateStatus();\n\t\t\t\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdialog.show();\t\t\n\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onPageFinished(WebView view, String url) {\n\t\t\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\t\t}\n\t\t    public boolean shouldOverrideUrlLoading(WebView view, String url){\n\t\t\t\tif (url.contains(OsMoService.SIGNED_IN_CONTAINS)) {\n\t\t\t\t\tUri data = Uri.parse(url);\n\t\t\t\t\tString user = data.getQueryParameter(\"u\");\n\t\t\t\t\tString pwd = data.getQueryParameter(\"p\");\n\t\t\t\t\tapp.getSettings().OSMO_USER_NAME.set(user);\n\t\t\t\t\tapp.getSettings().OSMO_USER_PWD.set(pwd);\n\t\t\t\t\tosMoPlugin.getService().reconnectToServer();\n\t\t\t\t\tif (createGroup) {\n\t\t\t\t\t\tcreateGroupWithDelay(3000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateStatus();\n\t\t\t\t\t}\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t        return false; // then it is not handled by default action\n\t\t   }\n\t\t});\n\t}","commit_id":"ee69e3f4c634e55401c9561400057d813d1d2308","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updateStatus() {\n\t\tImageView status = (ImageView) header.findViewById(R.id.osmo_status);\n\t\tfinal Drawable srcSmall = getResources().getDrawable(R.drawable.mon_osmo_conn_small);\n\t\tfinal Drawable srcSignalSmall = getResources().getDrawable(R.drawable.mon_osmo_conn_signal_small);\n\t\tfinal Drawable srcBig = getResources().getDrawable(R.drawable.mon_osmo_conn_big);\n\t\tfinal Drawable srcSignalBig = getResources().getDrawable(R.drawable.mon_osmo_conn_signal_big);\n//\t\tfinal Drawable srcinactive = getResources().getDrawable(R.drawable.mon_osmo_inactive);\n\t\tfinal Drawable srcSignalinactive = getResources().getDrawable(R.drawable.mon_osmo_signal_inactive);\n\t\tOsMoService service = osMoPlugin.getService();\n\t\tOsMoTracker tracker = osMoPlugin.getTracker();\n\t\tDrawable small = srcSignalinactive; //tracker.isEnabledTracker() ? srcSignalinactive : srcinactive;\n\t\tDrawable big = srcSignalinactive;// tracker.isEnabledTracker() ? srcSignalinactive : srcinactive;\n\t\tlong last = service.getLastCommandTime();\n\t\tif (service.isActive()) {\n\t\t\tsmall = tracker.isEnabledTracker() ? srcSignalSmall : srcSmall;\n\t\t\tbig = tracker.isEnabledTracker() ? srcSignalBig : srcBig;\n\t\t}\n\t\tif (blinkImg != small) {\n\t\t\tstatus.setImageDrawable(small);\n\t\t}\n\t\tif (last != lastUpdateTime) {\n\t\t\tlastUpdateTime = last;\n\t\t\tblink(status, big, small);\n\t\t}\n\t\tView logOffLayout = header.findViewById(R.id.osmo_log_off_layout);\n\t\tCompoundButton login = (CompoundButton) header.findViewById(R.id.osmo_login_logoff);\n\t\tif(service.isConnected()) {\n\t\t\theader.findViewById(R.id.motd).setVisibility(View.VISIBLE);\n\t\t\theader.findViewById(R.id.enable_tracker).setVisibility(View.VISIBLE);\n\n\t\t\tlogOffLayout.setVisibility(View.VISIBLE);\n\t\t\tTextView userNameTextView = (TextView) header.findViewById(R.id.osmo_user_name_text_view);\n\t\t\tButton hintBtn = (Button) header.findViewById(R.id.osmo_login_hint_button);\n\t\t\tif (service.isLoggedIn()) {\n\t\t\t\tString text = getString(R.string.logged_as, app.getSettings().OSMO_USER_NAME.get());\n\t\t\t\tuserNameTextView.setText(text);\n\t\t\t\thintBtn.setVisibility(View.GONE);\n\t\t\t\tif (!login.isChecked()) {\n\t\t\t\t\tlogin.setOnCheckedChangeListener(null);\n\t\t\t\t\tlogin.setChecked(true);\n\t\t\t\t\tlogin.setOnCheckedChangeListener(new LoginOnCheckedChangeListener());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuserNameTextView.setText(R.string.anonymous_user);\n\t\t\t\thintBtn.setVisibility(View.VISIBLE);\n\t\t\t\tif (login.isChecked()) {\n\t\t\t\t\tlogin.setOnCheckedChangeListener(null);\n\t\t\t\t\tlogin.setChecked(false);\n\t\t\t\t\tlogin.setOnCheckedChangeListener(new LoginOnCheckedChangeListener());\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\theader.findViewById(R.id.motd).setVisibility(View.GONE);\n\t\t\theader.findViewById(R.id.enable_tracker).setVisibility(View.GONE);\n\t\t\tlogOffLayout.setVisibility(View.GONE);\n\t\t}\n\t}","id":45194,"modified_method":"private void updateStatus() {\n\t\tImageView status = (ImageView) header.findViewById(R.id.osmo_status);\n\t\tfinal Drawable srcSmall = getResources().getDrawable(R.drawable.mon_osmo_conn_small);\n\t\tfinal Drawable srcSignalSmall = getResources().getDrawable(R.drawable.mon_osmo_conn_signal_small);\n\t\tfinal Drawable srcBig = getResources().getDrawable(R.drawable.mon_osmo_conn_big);\n\t\tfinal Drawable srcSignalBig = getResources().getDrawable(R.drawable.mon_osmo_conn_signal_big);\n//\t\tfinal Drawable srcinactive = getResources().getDrawable(R.drawable.mon_osmo_inactive);\n\t\tfinal Drawable srcSignalinactive = getResources().getDrawable(R.drawable.mon_osmo_signal_inactive);\n\t\tOsMoService service = osMoPlugin.getService();\n\t\tOsMoTracker tracker = osMoPlugin.getTracker();\n\t\tDrawable small = srcSignalinactive; //tracker.isEnabledTracker() ? srcSignalinactive : srcinactive;\n\t\tDrawable big = srcSignalinactive;// tracker.isEnabledTracker() ? srcSignalinactive : srcinactive;\n\t\tlong last = service.getLastCommandTime();\n\t\tif (service.isActive()) {\n\t\t\tsmall = tracker.isEnabledTracker() ? srcSignalSmall : srcSmall;\n\t\t\tbig = tracker.isEnabledTracker() ? srcSignalBig : srcBig;\n\t\t}\n\t\tif (blinkImg != small) {\n\t\t\tstatus.setImageDrawable(small);\n\t\t}\n\t\tif (last != lastUpdateTime) {\n\t\t\tlastUpdateTime = last;\n\t\t\tblink(status, big, small);\n\t\t}\n\t\tsupportInvalidateOptionsMenu();\n\t\tif(service.isConnected()) {\n\t\t\theader.findViewById(R.id.motd).setVisibility(View.VISIBLE);\n\t\t\theader.findViewById(R.id.enable_tracker).setVisibility(View.VISIBLE);\n\t\t\tif (service.isLoggedIn()) {\n\t\t\t\tgetSupportActionBar().setTitle(app.getSettings().OSMO_USER_NAME.get());\n\t\t\t} else {\n\t\t\t\tgetSupportActionBar().setTitle(R.string.anonymous_user);\n\t\t\t}\n\t\t} else {\n\t\t\theader.findViewById(R.id.motd).setVisibility(View.GONE);\n\t\t\theader.findViewById(R.id.enable_tracker).setVisibility(View.GONE);\n\t\t\tgetSupportActionBar().setTitle(R.string.osmo);\n\t\t}\n\t}","commit_id":"ee69e3f4c634e55401c9561400057d813d1d2308","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tmenu.clear();\n\t\tMenu oldMenu = menu;\n\t\tboolean portrait = AndroidUiHelper.isOrientationPortrait(this);\n\t\tif (portrait) {\n\t\t\tmenu = getClearToolbar(true).getMenu();\n\t\t} else {\n\t\t\tgetClearToolbar(false);\n\t\t}\n\t\tcreateMenuItem(menu, CONNECT_TO, R.string.osmo_connect, \n\t\t\t\t0, 0,/*R.drawable.ic_action_marker_light,*/\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\tcreateMenuItem(menu, SHARE_SESSION, R.string.osmo_share_session, \n\t\t\t\tR.drawable.ic_action_gshare_dark,\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\tcreateMenuItem(menu, CREATE_GROUP, R.string.osmo_create_group, \n\t\t\t\tR.drawable.ic_group_add,\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\tcreateMenuItem(oldMenu, SETTINGS_ID, R.string.shared_string_settings,\n\t\t\t\tR.drawable.ic_action_settings,\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}","id":45195,"modified_method":"@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tmenu.clear();\n\t\tMenu oldMenu = menu;\n\t\taddLoginActionMenu(oldMenu);\n\t\tcreateMenuItem(oldMenu, SETTINGS_ID, R.string.shared_string_settings, R.drawable.ic_action_settings,\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\tboolean portrait = AndroidUiHelper.isOrientationPortrait(this);\n\t\tif (portrait) {\n\t\t\tmenu = getClearToolbar(true).getMenu();\n\t\t} else {\n\t\t\tgetClearToolbar(false);\n\t\t}\n\t\tcreateMenuItem(menu, CONNECT_TO, R.string.osmo_connect, \n\t\t\t\t0, 0,/*R.drawable.ic_action_marker_light,*/\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\tcreateMenuItem(menu, SHARE_SESSION, R.string.osmo_share_session, \n\t\t\t\tR.drawable.ic_action_gshare_dark,\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\tcreateMenuItem(menu, CREATE_GROUP, R.string.osmo_create_group, \n\t\t\t\tR.drawable.ic_group_add,\n\t\t\t\tMenuItemCompat.SHOW_AS_ACTION_ALWAYS);\n\t\t\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}","commit_id":"ee69e3f4c634e55401c9561400057d813d1d2308","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void setupHeader() {\n\t\theader = getLayoutInflater().inflate(R.layout.osmo_groups_list_header, null);\n\t\tgetExpandableListView().addHeaderView(header);\n\t\tCompoundButton trackr = (CompoundButton) header.findViewById(R.id.enable_tracker);\n\t\tif(osMoPlugin != null && osMoPlugin.getTracker() != null){\n\t\t\ttrackr.setChecked(osMoPlugin.getTracker().isEnabledTracker());\n\t\t}\n\t\ttrackr.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tif(isChecked) {\n\t\t\t\t\tif (osMoPlugin != null && osMoPlugin.getTracker() != null){\n\t\t\t\t\t\tosMoPlugin.getTracker().enableTracker();\n\t\t\t\t\t}\n\t\t\t\t\tapp.startNavigationService(NavigationService.USED_BY_LIVE);\n\t\t\t\t\t//interval setting not needed here, handled centrally in app.startNavigationService\n\t\t\t\t\t//app.getSettings().SERVICE_OFF_INTERVAL.set(0);\n\t\t\t\t} else {\n\t\t\t\t\tif (osMoPlugin != null && osMoPlugin.getTracker() != null){\n\t\t\t\t\t\tosMoPlugin.getTracker().disableTracker();\n\t\t\t\t\t}\n\t\t\t\t\tif (app.getNavigationService() != null) {\n\t\t\t\t\t\tapp.getNavigationService().stopIfNeeded(app,NavigationService.USED_BY_LIVE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tupdateStatus();\n\t\t\t}\n\t\t});\n\t\t\n\t\tCompoundButton srvc = (CompoundButton) header.findViewById(R.id.enable_service);\n\t\tsrvc.setChecked(osMoPlugin.getService().isEnabled());\n\t\tsrvc.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tif (isChecked) {\n\t\t\t\t\tosMoPlugin.getService().connect(true);\n\t\t\t\t} else {\n\t\t\t\t\tosMoPlugin.getTracker().disableTracker();\n\t\t\t\t\tosMoPlugin.getService().disconnect();\n\t\t\t\t\tif (app.getNavigationService() != null) {\n\t\t\t\t\t\tapp.getNavigationService().stopIfNeeded(app, NavigationService.USED_BY_LIVE);\n\t\t\t\t\t}\n\t\t\t\t\tif (getExpandableListView().getFooterViewsCount() > 0) {\n\t\t\t\t\t\tgetExpandableListView().removeFooterView(footer);\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetSupportProgressBarIndeterminateVisibility(true);\n\t\t\t\theader.postDelayed(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateStatus();\n\t\t\t\t\t\tif (osMoPlugin.getService().isConnected()) {\n\t\t\t\t\t\t\tadapter.synchronizeGroups();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadapter.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\t\t\t}\n\t\t\t\t}, 3000);\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\t\n\t\tTextView mtd = (TextView) header.findViewById(R.id.motd);\n\t\tSessionInfo si = osMoPlugin.getService().getCurrentSessionInfo();\n\t\tboolean visible = si != null && si.motd != null && si.motd.length() > 0;\n\t\tmtd.setVisibility(visible? View.VISIBLE:View.GONE);\n\t\tif(visible) {\n\t\t\tmtd.setText(si.motd);\n\t\t\tmtd.setLinksClickable(true);\n\t\t\tmtd.setMovementMethod(LinkMovementMethod.getInstance());\n\t\t}\n\t\t\n\t\t\n\t\tCompoundButton login = (CompoundButton) header.findViewById(R.id.osmo_login_logoff);\n\t\tlogin.setChecked(osMoPlugin.getService().isLoggedIn());\n\t\tlogin.setOnCheckedChangeListener(new LoginOnCheckedChangeListener());\n\n\t\tButton hintBtn = (Button) header.findViewById(R.id.osmo_login_hint_button);\n\t\thintBtn.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tshowHint();\n\t\t\t}\n\t\t});\n\t}","id":45196,"modified_method":"private void setupHeader() {\n\t\theader = getLayoutInflater().inflate(R.layout.osmo_groups_list_header, null);\n\t\tgetExpandableListView().addHeaderView(header);\n\t\tCompoundButton trackr = (CompoundButton) header.findViewById(R.id.enable_tracker);\n\t\tif(osMoPlugin != null && osMoPlugin.getTracker() != null){\n\t\t\ttrackr.setChecked(osMoPlugin.getTracker().isEnabledTracker());\n\t\t}\n\t\ttrackr.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tif(isChecked) {\n\t\t\t\t\tif (osMoPlugin != null && osMoPlugin.getTracker() != null){\n\t\t\t\t\t\tosMoPlugin.getTracker().enableTracker();\n\t\t\t\t\t}\n\t\t\t\t\tapp.startNavigationService(NavigationService.USED_BY_LIVE);\n\t\t\t\t\t//interval setting not needed here, handled centrally in app.startNavigationService\n\t\t\t\t\t//app.getSettings().SERVICE_OFF_INTERVAL.set(0);\n\t\t\t\t} else {\n\t\t\t\t\tif (osMoPlugin != null && osMoPlugin.getTracker() != null){\n\t\t\t\t\t\tosMoPlugin.getTracker().disableTracker();\n\t\t\t\t\t}\n\t\t\t\t\tif (app.getNavigationService() != null) {\n\t\t\t\t\t\tapp.getNavigationService().stopIfNeeded(app,NavigationService.USED_BY_LIVE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tupdateStatus();\n\t\t\t}\n\t\t});\n\t\t\n\t\tCompoundButton srvc = (CompoundButton) header.findViewById(R.id.enable_service);\n\t\tsrvc.setChecked(osMoPlugin.getService().isEnabled());\n\t\tsrvc.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tif (isChecked) {\n\t\t\t\t\tosMoPlugin.getService().connect(true);\n\t\t\t\t} else {\n\t\t\t\t\tosMoPlugin.getTracker().disableTracker();\n\t\t\t\t\tosMoPlugin.getService().disconnect();\n\t\t\t\t\tif (app.getNavigationService() != null) {\n\t\t\t\t\t\tapp.getNavigationService().stopIfNeeded(app, NavigationService.USED_BY_LIVE);\n\t\t\t\t\t}\n\t\t\t\t\tif (getExpandableListView().getFooterViewsCount() > 0) {\n\t\t\t\t\t\tgetExpandableListView().removeFooterView(footer);\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetSupportProgressBarIndeterminateVisibility(true);\n\t\t\t\theader.postDelayed(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateStatus();\n\t\t\t\t\t\tif (osMoPlugin.getService().isConnected()) {\n\t\t\t\t\t\t\tadapter.synchronizeGroups();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadapter.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\t\t\t}\n\t\t\t\t}, 3000);\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\t\n\t\tTextView mtd = (TextView) header.findViewById(R.id.motd);\n\t\tSessionInfo si = osMoPlugin.getService().getCurrentSessionInfo();\n\t\tboolean visible = si != null && si.motd != null && si.motd.length() > 0;\n\t\tmtd.setVisibility(visible? View.VISIBLE:View.GONE);\n\t\tif(visible) {\n\t\t\tmtd.setText(si.motd);\n\t\t\tmtd.setLinksClickable(true);\n\t\t\tmtd.setMovementMethod(LinkMovementMethod.getInstance());\n\t\t}\n\t\t\n\t\t\n\t}","commit_id":"ee69e3f4c634e55401c9561400057d813d1d2308","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n        public boolean isLoggable(Level level) {\n            if (Level.OFF == level) {\n                return false;\n            } else {\n                return logger.isEnabled(getLevel(level), null);\n            }\n        }","id":45197,"modified_method":"@Override\n        public boolean isLoggable(Level level) {\n            return level != Level.OFF && logger.isEnabled(toLog4j2Level(level), null);\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public Level getLevel() {\n            if (logger.isDebugEnabled()) {\n                return Level.FINEST;\n            } else if (logger.isInfoEnabled()) {\n                return Level.INFO;\n            } else if (logger.isWarnEnabled()) {\n                return Level.WARNING;\n            } else if (logger.isFatalEnabled()) {\n                return Level.SEVERE;\n            } else {\n                return Level.OFF;\n            }\n        }","id":45198,"modified_method":"@Override\n        public Level getLevel() {\n            return logger.isTraceEnabled() ? Level.FINEST\n                 : logger.isDebugEnabled() ? Level.FINE\n                 : logger.isInfoEnabled()  ? Level.INFO\n                 : logger.isWarnEnabled()  ? Level.WARNING\n                 : logger.isErrorEnabled() ? Level.SEVERE\n                 : logger.isFatalEnabled() ? Level.SEVERE\n                 : Level.OFF;\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message) {\n            logger.logIfEnabled(FQCN, getLevel(level), null, message);\n        }","id":45199,"modified_method":"@Override\n        public void log(Level level, String message) {\n            logger.logIfEnabled(FQCN, toLog4j2Level(level), null, message);\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            logger.logIfEnabled(FQCN, getLevel(level), null, message, thrown);\n        }","id":45200,"modified_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            logger.logIfEnabled(FQCN, toLog4j2Level(level), null, message, thrown);\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Log4jLogger(Logger logger) {\n            this.logger = logger;\n            org.apache.log4j.Level log4jLevel = logger.getLevel();\n            if (log4jLevel == org.apache.log4j.Level.DEBUG) {\n                this.level = Level.FINEST;\n            } else if (log4jLevel == org.apache.log4j.Level.INFO) {\n                this.level = Level.INFO;\n            } else if (log4jLevel == org.apache.log4j.Level.WARN) {\n                this.level = Level.WARNING;\n            } else if (log4jLevel == org.apache.log4j.Level.FATAL) {\n                this.level = Level.SEVERE;\n            } else if (log4jLevel == org.apache.log4j.Level.OFF) {\n                this.level = Level.OFF;\n            } else {\n                this.level = Level.INFO;\n            }\n        }","id":45201,"modified_method":"public Log4jLogger(Logger logger) {\n            this.logger = logger;\n            org.apache.log4j.Level log4jLevel = logger.getLevel();\n            this.level = toStandardLevel(log4jLevel);\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (Level.FINEST == level) {\n                logger.debug(message, thrown);\n            } else if (Level.WARNING == level) {\n                logger.warn(message, thrown);\n            } else if (Level.SEVERE == level) {\n                logger.fatal(message, thrown);\n            } else if (Level.OFF != level) {\n                logger.info(message, thrown);\n            }\n        }","id":45202,"modified_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            logger.log(toLog4jLevel(level), message, thrown);\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message) {\n            if (Level.FINEST == level) {\n                logger.debug(message);\n            } else if (Level.SEVERE == level) {\n                logger.fatal(message);\n            } else if (Level.WARNING == level) {\n                logger.warn(message);\n            } else if (level != Level.OFF) {\n                logger.info(message);\n            }\n        }","id":45203,"modified_method":"@Override\n        public void log(Level level, String message) {\n            logger.log(toLog4jLevel(level), message);\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(LogEvent logEvent) {\n            LogRecord logRecord = logEvent.getLogRecord();\n            String name = logEvent.getLogRecord().getLoggerName();\n            org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(name);\n            org.apache.log4j.Level level;\n            if (logRecord.getLevel() == Level.FINEST) {\n                level = org.apache.log4j.Level.DEBUG;\n            } else if (logRecord.getLevel() == Level.INFO) {\n                level = org.apache.log4j.Level.INFO;\n            } else if (logRecord.getLevel() == Level.WARNING) {\n                level = org.apache.log4j.Level.WARN;\n            } else if (logRecord.getLevel() == Level.SEVERE) {\n                level = org.apache.log4j.Level.FATAL;\n            } else if (logRecord.getLevel() == Level.OFF) {\n                return;\n            } else {\n                level = org.apache.log4j.Level.INFO;\n            }\n            String message = logRecord.getMessage();\n            Throwable throwable = logRecord.getThrown();\n            logger.callAppenders(new LoggingEvent(name, logger, level, message, throwable));\n        }","id":45204,"modified_method":"@Override\n        public void log(LogEvent logEvent) {\n            LogRecord logRecord = logEvent.getLogRecord();\n            if (logRecord.getLevel() == Level.OFF) {\n                return;\n            }\n            String name = logEvent.getLogRecord().getLoggerName();\n            org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(name);\n            org.apache.log4j.Level level = toLog4jLevel(logRecord.getLevel());\n            String message = logRecord.getMessage();\n            Throwable throwable = logRecord.getThrown();\n            logger.callAppenders(new LoggingEvent(name, logger, level, message, throwable));\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public boolean isLoggable(Level level) {\n            if (Level.OFF == level) {\n                return false;\n            } else if (Level.FINEST == level) {\n                return logger.isDebugEnabled();\n            } else if (Level.WARNING == level) {\n                return logger.isEnabledFor(org.apache.log4j.Level.WARN);\n            } else if (Level.SEVERE == level) {\n                return logger.isEnabledFor(org.apache.log4j.Level.FATAL);\n            } else if (Level.OFF == level) {\n                return false;\n            } else {\n                return logger.isEnabledFor(org.apache.log4j.Level.INFO);\n            }\n        }","id":45205,"modified_method":"@Override\n        public boolean isLoggable(Level level) {\n            return level != Level.OFF && logger.isEnabledFor(toLog4jLevel(level));\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void isLoggable_whenOffLevel_thenReturnFalse() {\n        boolean loggable = hazelcastLogger.isLoggable(Level.OFF);\n        assertFalse(loggable);\n    }","id":45206,"modified_method":"@Test\n    public void isLoggable_whenLevelOff_shouldReturnFalse() {\n        assertFalse(hazelcastLogger.isLoggable(Level.OFF));\n    }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@BeforeClass\n    public static void beforeClass() {\n        try {\n            LOGGER_FACTORY_FIELD = Logger.class.getDeclaredField(\"loggerFactory\");\n            LOGGER_FACTORY_FIELD.setAccessible(true);\n        } catch (NoSuchFieldException e) {\n            throw\n                    new IllegalStateException(\n                            \"Couldn't retrieve \\\"loggerFactory\\\" field from \"\n                                    + Logger.class.getName() + \" class !\", e);\n        }\n\n        // Store actual logging type property value to set this current value after all tests\n        actualLoggingTypePropertyValue = System.getProperty(LOGGING_TYPE_PROPERTY_NAME);\n    }","id":45207,"modified_method":"@BeforeClass\n    public static void beforeClass() {\n        try {\n            LOGGER_FACTORY_FIELD = Logger.class.getDeclaredField(\"loggerFactory\");\n            LOGGER_FACTORY_FIELD.setAccessible(true);\n        } catch (NoSuchFieldException e) {\n            throw new IllegalStateException(\n                    \"Couldn't retrieve \\\"loggerFactory\\\" field from \" + Logger.class.getName() + \" class !\", e);\n        }\n        backupLoggingTypeProperty = System.getProperty(LOGGING_TYPE_PROPERTY_NAME);\n    }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@AfterClass\n    public static void afterClass() {\n        // Back to the old (actual) value of logging type property after all tests\n        System.setProperty(LOGGING_TYPE_PROPERTY_NAME, actualLoggingTypePropertyValue);\n    }","id":45208,"modified_method":"@AfterClass\n    public static void afterClass() {\n        System.setProperty(LOGGING_TYPE_PROPERTY_NAME, backupLoggingTypeProperty);\n    }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            boolean loggable = logger.isLoggable(level);\n            if (loggable || level.intValue() >= minLevel.intValue()) {\n                String address = thisAddressString;\n                String logMessage = (address != null ? address : \"\")\n                        + \" [\" + groupName + \"] \"\n                        + \"[\" + buildInfo.getVersion() + \"] \" + message;\n\n                if (loggable) {\n                    logger.log(level, logMessage, thrown);\n                }\n                if (listeners.size() > 0) {\n                    LogRecord logRecord = new LogRecord(level, logMessage);\n                    logRecord.setThrown(thrown);\n                    logRecord.setLoggerName(name);\n                    logRecord.setSourceClassName(name);\n                    LogEvent logEvent = new LogEvent(logRecord, thisMember);\n                    handleLogEvent(logEvent);\n                }\n            }\n        }","id":45209,"modified_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            boolean loggable = logger.isLoggable(level);\n            if (loggable || level.intValue() >= minLevel.intValue()) {\n                String address = thisAddressString;\n                String logMessage = (address != null ? address : \"\")\n                        + \" [\" + groupName + \"] [\" + buildInfo.getVersion() + \"] \" + message;\n\n                if (loggable) {\n                    logger.log(level, logMessage, thrown);\n                }\n                if (listeners.size() > 0) {\n                    LogRecord logRecord = new LogRecord(level, logMessage);\n                    logRecord.setThrown(thrown);\n                    logRecord.setLoggerName(name);\n                    logRecord.setSourceClassName(name);\n                    LogEvent logEvent = new LogEvent(logRecord, thisMember);\n                    handleLogEvent(logEvent);\n                }\n            }\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message) {\n            if (Level.FINEST == level) {\n                logger.debug(message);\n            } else if (Level.SEVERE == level) {\n                logger.error(message);\n            } else if (Level.WARNING == level) {\n                logger.warn(message);\n            } else if (Level.OFF != level) {\n                logger.info(message);\n            }\n        }","id":45210,"modified_method":"@Override\n        public void log(Level level, String message) {\n            if (level == Level.FINEST) {\n                logger.trace(message);\n            } else if (level == Level.FINER || level == Level.FINE) {\n                logger.debug(message);\n            } else if (level == Level.CONFIG || level == Level.INFO) {\n                logger.info(message);\n            } else if (level == Level.WARNING) {\n                logger.warn(message);\n            } else if (level == Level.SEVERE) {\n                logger.error(message);\n            } else if (level != Level.OFF) {\n                logger.info(message);\n            }\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (Level.FINEST == level) {\n                logger.debug(message, thrown);\n            } else if (Level.INFO == level) {\n                logger.info(message, thrown);\n            } else if (Level.WARNING == level) {\n                logger.warn(message, thrown);\n            } else if (Level.SEVERE == level) {\n                logger.error(message, thrown);\n            } else if (Level.OFF != level) {\n                logger.info(message, thrown);\n            }\n        }","id":45211,"modified_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (level == Level.FINEST) {\n                logger.trace(message, thrown);\n            } else if (level == Level.FINER || level == Level.FINE) {\n                logger.debug(message, thrown);\n            } else if (level == Level.CONFIG || level == Level.INFO) {\n                logger.info(message, thrown);\n            } else if (level == Level.WARNING) {\n                logger.warn(message, thrown);\n            } else if (level == Level.SEVERE) {\n                logger.error(message, thrown);\n            } else if (level != Level.OFF) {\n                logger.info(message, thrown);\n            }\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public Level getLevel() {\n            if (logger.isDebugEnabled()) {\n                return Level.FINEST;\n            } else if (logger.isInfoEnabled()) {\n                return Level.INFO;\n            } else if (logger.isWarnEnabled()) {\n                return Level.WARNING;\n            } else if (logger.isErrorEnabled()) {\n                return Level.SEVERE;\n            } else {\n                return Level.OFF;\n            }\n        }","id":45212,"modified_method":"@Override\n        public Level getLevel() {\n            return logger.isTraceEnabled() ? Level.FINEST\n                 : logger.isDebugEnabled() ? Level.FINE\n                 : logger.isInfoEnabled()  ? Level.INFO\n                 : logger.isWarnEnabled()  ? Level.WARNING\n                 : logger.isErrorEnabled() ? Level.SEVERE\n                 : Level.OFF;\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public boolean isLoggable(Level level) {\n            if (Level.OFF == level) {\n                return false;\n            } else if (Level.FINEST == level) {\n                return logger.isDebugEnabled();\n            } else if (Level.INFO == level) {\n                return logger.isInfoEnabled();\n            } else if (Level.WARNING == level) {\n                return logger.isWarnEnabled();\n            } else if (Level.SEVERE == level) {\n                return logger.isErrorEnabled();\n            } else {\n                return logger.isInfoEnabled();\n            }\n        }","id":45213,"modified_method":"@Override\n        public boolean isLoggable(Level level) {\n            return level == Level.FINEST  ? logger.isTraceEnabled()\n                 : level == Level.FINER   ? logger.isDebugEnabled()\n                 : level == Level.FINE    ? logger.isDebugEnabled()\n                 : level == Level.CONFIG  ? logger.isInfoEnabled()\n                 : level == Level.INFO    ? logger.isInfoEnabled()\n                 : level == Level.WARNING ? logger.isWarnEnabled()\n                 : level == Level.SEVERE  ? logger.isErrorEnabled()\n                 : level != Level.OFF && logger.isInfoEnabled();\n        }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void isLoggable_whenOffLevel_thenReturnFalse() {\n        boolean loggable = hazelcastLogger.isLoggable(Level.OFF);\n        assertFalse(loggable);\n    }","id":45214,"modified_method":"@Test\n    public void isLoggable_whenLevelOff_shouldReturnFalse() {\n        assertFalse(hazelcastLogger.isLoggable(Level.OFF));\n    }","commit_id":"6a061dcc85179907c143cfa58a2a2da95a6a61e6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public Level getLevel() {\n            if (logger.isDebugEnabled()) {\n                return Level.FINEST;\n            } else if (logger.isInfoEnabled()) {\n                return Level.INFO;\n            } else if (logger.isWarnEnabled()) {\n                return Level.WARNING;\n            } else {\n                return Level.SEVERE;\n            }\n        }","id":45215,"modified_method":"@Override\n        public Level getLevel() {\n            if (logger.isDebugEnabled()) {\n                return Level.FINEST;\n            } else if (logger.isInfoEnabled()) {\n                return Level.INFO;\n            } else if (logger.isWarnEnabled()) {\n                return Level.WARNING;\n            } else if (logger.isFatalEnabled()) {\n                return Level.SEVERE;\n            } else {\n                return Level.OFF;\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private org.apache.logging.log4j.Level getLevel(Level level) {\n            if (Level.SEVERE == level) {\n                return org.apache.logging.log4j.Level.ERROR;\n            } else if (Level.WARNING == level) {\n                return org.apache.logging.log4j.Level.WARN;\n            } else if (Level.INFO == level) {\n                return org.apache.logging.log4j.Level.INFO;\n            } else if (Level.CONFIG == level) {\n                return org.apache.logging.log4j.Level.INFO;\n            } else if (Level.FINE == level) {\n                return org.apache.logging.log4j.Level.DEBUG;\n            } else if (Level.FINER == level) {\n                return org.apache.logging.log4j.Level.DEBUG;\n            } else if (Level.FINEST == level) {\n                return org.apache.logging.log4j.Level.DEBUG;\n            } else {\n                return org.apache.logging.log4j.Level.INFO;\n            }\n        }","id":45216,"modified_method":"private org.apache.logging.log4j.Level getLevel(Level level) {\n            if (Level.SEVERE == level) {\n                return org.apache.logging.log4j.Level.ERROR;\n            } else if (Level.WARNING == level) {\n                return org.apache.logging.log4j.Level.WARN;\n            } else if (Level.INFO == level) {\n                return org.apache.logging.log4j.Level.INFO;\n            } else if (Level.CONFIG == level) {\n                return org.apache.logging.log4j.Level.INFO;\n            } else if (Level.FINE == level) {\n                return org.apache.logging.log4j.Level.DEBUG;\n            } else if (Level.FINER == level) {\n                return org.apache.logging.log4j.Level.DEBUG;\n            } else if (Level.FINEST == level) {\n                return org.apache.logging.log4j.Level.DEBUG;\n            } else if (Level.OFF == level) {\n                return org.apache.logging.log4j.Level.OFF;\n            } else {\n                return org.apache.logging.log4j.Level.INFO;\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Log4jLogger(Logger logger) {\n            this.logger = logger;\n            if (logger.getLevel() == org.apache.log4j.Level.DEBUG) {\n                level = Level.FINEST;\n            } else if (logger.getLevel() == org.apache.log4j.Level.INFO) {\n                level = Level.INFO;\n            } else if (logger.getLevel() == org.apache.log4j.Level.WARN) {\n                level = Level.WARNING;\n            } else if (logger.getLevel() == org.apache.log4j.Level.FATAL) {\n                level = Level.SEVERE;\n            } else {\n                level = Level.INFO;\n            }\n        }","id":45217,"modified_method":"public Log4jLogger(Logger logger) {\n            this.logger = logger;\n            org.apache.log4j.Level log4jLevel = logger.getLevel();\n            if (log4jLevel == org.apache.log4j.Level.DEBUG) {\n                this.level = Level.FINEST;\n            } else if (log4jLevel == org.apache.log4j.Level.INFO) {\n                this.level = Level.INFO;\n            } else if (log4jLevel == org.apache.log4j.Level.WARN) {\n                this.level = Level.WARNING;\n            } else if (log4jLevel == org.apache.log4j.Level.FATAL) {\n                this.level = Level.SEVERE;\n            } else if (log4jLevel == org.apache.log4j.Level.OFF) {\n                this.level = Level.OFF;\n            } else {\n                this.level = Level.INFO;\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message) {\n            if (Level.FINEST == level) {\n                logger.debug(message);\n            } else if (Level.SEVERE == level) {\n                logger.fatal(message);\n            } else if (Level.WARNING == level) {\n                logger.warn(message);\n            } else {\n                logger.info(message);\n            }\n        }","id":45218,"modified_method":"@Override\n        public void log(Level level, String message) {\n            if (Level.FINEST == level) {\n                logger.debug(message);\n            } else if (Level.SEVERE == level) {\n                logger.fatal(message);\n            } else if (Level.WARNING == level) {\n                logger.warn(message);\n            } else if (level != Level.OFF) {\n                logger.info(message);\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (Level.FINEST == level) {\n                logger.debug(message, thrown);\n            } else if (Level.WARNING == level) {\n                logger.warn(message, thrown);\n            } else if (Level.SEVERE == level) {\n                logger.fatal(message, thrown);\n            } else {\n                logger.info(message, thrown);\n            }\n        }","id":45219,"modified_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (Level.FINEST == level) {\n                logger.debug(message, thrown);\n            } else if (Level.WARNING == level) {\n                logger.warn(message, thrown);\n            } else if (Level.SEVERE == level) {\n                logger.fatal(message, thrown);\n            } else if (Level.OFF != level) {\n                logger.info(message, thrown);\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public boolean isLoggable(Level level) {\n            if (Level.OFF == level) {\n                return false;\n            } else if (Level.FINEST == level) {\n                return logger.isDebugEnabled();\n            } else if (Level.WARNING == level) {\n                return logger.isEnabledFor(org.apache.log4j.Level.WARN);\n            } else if (Level.SEVERE == level) {\n                return logger.isEnabledFor(org.apache.log4j.Level.FATAL);\n            } else {\n                return logger.isEnabledFor(org.apache.log4j.Level.INFO);\n            }\n        }","id":45220,"modified_method":"@Override\n        public boolean isLoggable(Level level) {\n            if (Level.OFF == level) {\n                return false;\n            } else if (Level.FINEST == level) {\n                return logger.isDebugEnabled();\n            } else if (Level.WARNING == level) {\n                return logger.isEnabledFor(org.apache.log4j.Level.WARN);\n            } else if (Level.SEVERE == level) {\n                return logger.isEnabledFor(org.apache.log4j.Level.FATAL);\n            } else if (Level.OFF == level) {\n                return false;\n            } else {\n                return logger.isEnabledFor(org.apache.log4j.Level.INFO);\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(LogEvent logEvent) {\n            LogRecord logRecord = logEvent.getLogRecord();\n            String name = logEvent.getLogRecord().getLoggerName();\n            org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(name);\n            org.apache.log4j.Level level;\n            if (logRecord.getLevel() == Level.FINEST) {\n                level = org.apache.log4j.Level.DEBUG;\n            } else if (logRecord.getLevel() == Level.INFO) {\n                level = org.apache.log4j.Level.INFO;\n            } else if (logRecord.getLevel() == Level.WARNING) {\n                level = org.apache.log4j.Level.WARN;\n            } else if (logRecord.getLevel() == Level.SEVERE) {\n                level = org.apache.log4j.Level.FATAL;\n            } else {\n                level = org.apache.log4j.Level.INFO;\n            }\n            String message = logRecord.getMessage();\n            Throwable throwable = logRecord.getThrown();\n            logger.callAppenders(new LoggingEvent(name, logger, level, message, throwable));\n        }","id":45221,"modified_method":"@Override\n        public void log(LogEvent logEvent) {\n            LogRecord logRecord = logEvent.getLogRecord();\n            String name = logEvent.getLogRecord().getLoggerName();\n            org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(name);\n            org.apache.log4j.Level level;\n            if (logRecord.getLevel() == Level.FINEST) {\n                level = org.apache.log4j.Level.DEBUG;\n            } else if (logRecord.getLevel() == Level.INFO) {\n                level = org.apache.log4j.Level.INFO;\n            } else if (logRecord.getLevel() == Level.WARNING) {\n                level = org.apache.log4j.Level.WARN;\n            } else if (logRecord.getLevel() == Level.SEVERE) {\n                level = org.apache.log4j.Level.FATAL;\n            } else if (logRecord.getLevel() == Level.OFF) {\n                return;\n            } else {\n                level = org.apache.log4j.Level.INFO;\n            }\n            String message = logRecord.getMessage();\n            Throwable throwable = logRecord.getThrown();\n            logger.callAppenders(new LoggingEvent(name, logger, level, message, throwable));\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (Level.FINEST == level) {\n                logger.debug(message, thrown);\n            } else if (Level.INFO == level) {\n                logger.info(message, thrown);\n            } else if (Level.WARNING == level) {\n                logger.warn(message, thrown);\n            } else if (Level.SEVERE == level) {\n                logger.error(message, thrown);\n            } else {\n                logger.info(message, thrown);\n            }\n        }","id":45222,"modified_method":"@Override\n        public void log(Level level, String message, Throwable thrown) {\n            if (Level.FINEST == level) {\n                logger.debug(message, thrown);\n            } else if (Level.INFO == level) {\n                logger.info(message, thrown);\n            } else if (Level.WARNING == level) {\n                logger.warn(message, thrown);\n            } else if (Level.SEVERE == level) {\n                logger.error(message, thrown);\n            } else if (Level.OFF != level) {\n                logger.info(message, thrown);\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void log(Level level, String message) {\n            if (Level.FINEST == level) {\n                logger.debug(message);\n            } else if (Level.SEVERE == level) {\n                logger.error(message);\n            } else if (Level.WARNING == level) {\n                logger.warn(message);\n            } else {\n                logger.info(message);\n            }\n        }","id":45223,"modified_method":"@Override\n        public void log(Level level, String message) {\n            if (Level.FINEST == level) {\n                logger.debug(message);\n            } else if (Level.SEVERE == level) {\n                logger.error(message);\n            } else if (Level.WARNING == level) {\n                logger.warn(message);\n            } else if (Level.OFF != level) {\n                logger.info(message);\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public Level getLevel() {\n            if (logger.isErrorEnabled()) {\n                return Level.SEVERE;\n            } else if (logger.isWarnEnabled()) {\n                return Level.WARNING;\n            } else if (logger.isInfoEnabled()) {\n                return Level.INFO;\n            } else {\n                return Level.FINEST;\n            }\n        }","id":45224,"modified_method":"@Override\n        public Level getLevel() {\n            if (logger.isDebugEnabled()) {\n                return Level.FINEST;\n            } else if (logger.isInfoEnabled()) {\n                return Level.INFO;\n            } else if (logger.isWarnEnabled()) {\n                return Level.WARNING;\n            } else if (logger.isErrorEnabled()) {\n                return Level.SEVERE;\n            } else {\n                return Level.OFF;\n            }\n        }","commit_id":"83573d766b033aa38cd738f073832c7022f1fccd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n\tprotected Statement methodBlock(FrameworkMethod method) {\n\t\tfinal Statement methodBlock = super.methodBlock(method);\n\n\t\treturn new Statement() {\n\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tif (TestPropsValues.ASSERT_LOGS) {\n\t\t\t\t\tLogAssertionUtil.installLog4jAppender();\n\n\t\t\t\t\tLogAssertionUtil.installJdk14Handler();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tmethodBlock.evaluate();\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","id":45225,"modified_method":"@Override\n\tprotected Statement methodBlock(FrameworkMethod method) {\n\t\tfinal Statement methodBlock = super.methodBlock(method);\n\n\t\tif (!TestPropsValues.ASSERT_LOGS) {\n\t\t\treturn methodBlock;\n\t\t}\n\n\t\treturn new Statement() {\n\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tLogAssertionUtil.enableLogAssertion();\n\n\t\t\t\tmethodBlock.evaluate();\n\t\t\t}\n\n\t\t};\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void append(LoggingEvent loggingEvent) {\n\t\tif (loggingEvent.getLevel().equals(Level.WARN) ||\n\t\t\tloggingEvent.getLevel().equals(Level.ERROR) ||\n\t\t\tloggingEvent.getLevel().equals(Level.FATAL)) {\n\n\t\t\tAssert.fail(\n\t\t\t\t\"Method failed due to logged error or warning: \" +\n\t\t\t\tloggingEvent.getMessage());\n\t\t}\n\t}","id":45226,"modified_method":"@Override\n\tprotected void append(LoggingEvent loggingEvent) {\n\t\tLevel level = loggingEvent.getLevel();\n\n\t\tif (level.equals(Level.ERROR) || level.equals(Level.FATAL)) {\n\t\t\tAssert.fail(\n\t\t\t\t\"Method failed due to logged error : \" +\n\t\t\t\t\tloggingEvent.getMessage());\n\t\t}\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void close() {\n\t\t_logger.setLevel(_level);\n\n\t\t_logger.removeAppender(this);\n\t}","id":45227,"modified_method":"@Override\n\tpublic void close() {\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void publish(LogRecord logRecord) {\n\t\tif (logRecord.getLevel().equals(Level.WARNING) ||\n\t\t\tlogRecord.getLevel().equals(Level.SEVERE)) {\n\n\t\t\tAssert.fail(\n\t\t\t\t\"Method failed due to logged error or warning: \" +\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t}","id":45228,"modified_method":"@Override\n\tpublic void publish(LogRecord logRecord) {\n\t\tLevel level = logRecord.getLevel();\n\n\t\tif (level.equals(Level.SEVERE)) {\n\t\t\tAssert.fail(\n\t\t\t\t\"Method failed due to logged error : \" +\n\t\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void close() throws SecurityException {\n\t\t_logRecords.clear();\n\n\t\t_logger.setLevel(_level);\n\n\t\t_logger.removeHandler(this);\n\t}","id":45229,"modified_method":"@Override\n\tpublic void close() throws SecurityException {\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void flush() {\n\t\t_logRecords.clear();\n\t}","id":45230,"modified_method":"@Override\n\tpublic void flush() {\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void installJdk14Handler() {\n\t\tjava.util.logging.Logger jdkLogger = java.util.logging.Logger.getLogger(\n\t\t\t\"\");\n\n\t\tHandler[] handlers = jdkLogger.getHandlers();\n\n\t\tBoolean needsInstalation = true;\n\n\t\tfor (Handler handler : handlers) {\n\t\t\tif (handler instanceof LogAssertionHandler) {\n\t\t\t\tneedsInstalation = true;\n\t\t\t}\n\t\t}\n\n\t\tif (needsInstalation) {\n\t\t\tLogAssertionHandler logAssertionHandler = new LogAssertionHandler(\n\t\t\t\tjdkLogger);\n\n\t\t\tjdkLogger.addHandler(logAssertionHandler);\n\t\t}\n\t}","id":45231,"modified_method":"protected static void installJdk14Handler() {\n\t\tLogger logger = Logger.getLogger(StringPool.BLANK);\n\n\t\tlogger.removeHandler(LogAssertionHandler.INSTANCE);\n\t\tlogger.addHandler(LogAssertionHandler.INSTANCE);\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void installLog4jAppender() {\n\t\torg.apache.log4j.Logger log4jLogger =\n\t\t\torg.apache.log4j.Logger.getRootLogger();\n\n\t\tAppender appender = log4jLogger.getAppender(\"logAssertionAppender\");\n\n\t\tif (appender == null) {\n\t\t\tLogAssertionAppender logAssertionAppender =\n\t\t\t\tnew LogAssertionAppender(log4jLogger);\n\n\t\t\tlogAssertionAppender.setName(\"logAssertionAppender\");\n\n\t\t\tlog4jLogger.addAppender(logAssertionAppender);\n\t\t}\n\t}","id":45232,"modified_method":"protected static void installLog4jAppender() {\n\t\torg.apache.log4j.Logger logger =\n\t\t\torg.apache.log4j.Logger.getRootLogger();\n\n\t\tlogger.removeAppender(LogAssertionAppender.INSTANCE);\n\t\tlogger.addAppender(LogAssertionAppender.INSTANCE);\n\t}","commit_id":"61744593a08de302c68951b1f19ef1094b7ce2cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void getInfo( LoadFileInputMeta in ) throws KettleException {\n    stepname = wStepname.getText(); // return value\n\n    // copy info to TextFileInputMeta class (input)\n    in.setRowLimit( Const.toLong( wLimit.getText(), 0L ) );\n    in.setEncoding( wEncoding.getText() );\n    in.setFilenameField( wInclFilenameField.getText() );\n    in.setRowNumberField( wInclRownumField.getText() );\n    in.setAddResultFile( wAddResult.getSelection() );\n    in.setIgnoreEmptyFile( wIgnoreEmptyFile.getSelection() );\n\n    in.setIncludeFilename( wInclFilename.getSelection() );\n    in.setIncludeRowNumber( wInclRownum.getSelection() );\n\n    in.setIsInFields( wFilenameInField.getSelection() );\n    in.setDynamicFilenameField( wFilenameField.getText() );\n\n    int nrFiles = wFilenameList.getItemCount();\n    int nrFields = wFields.nrNonEmpty();\n\n    in.allocate( nrFiles, nrFields );\n\n    in.setFileName( wFilenameList.getItems( 0 ) );\n    in.setFileMask( wFilenameList.getItems( 1 ) );\n    in.setExcludeFileMask( wFilenameList.getItems( 2 ) );\n    in.setFileRequired( wFilenameList.getItems( 3 ) );\n    in.setIncludeSubFolders( wFilenameList.getItems( 4 ) );\n\n    for ( int i = 0; i < nrFields; i++ ) {\n      LoadFileInputField field = new LoadFileInputField();\n\n      TableItem item = wFields.getNonEmpty( i );\n\n      field.setName( item.getText( 1 ) );\n      field.setElementType( LoadFileInputField.getElementTypeByDesc( item.getText( 2 ) ) );\n      field.setType( ValueMeta.getType( item.getText( 3 ) ) );\n      field.setFormat( item.getText( 4 ) );\n      field.setLength( Const.toInt( item.getText( 5 ), -1 ) );\n      field.setPrecision( Const.toInt( item.getText( 6 ), -1 ) );\n      field.setCurrencySymbol( item.getText( 7 ) );\n      field.setDecimalSymbol( item.getText( 8 ) );\n      field.setGroupSymbol( item.getText( 9 ) );\n      field.setTrimType( LoadFileInputField.getTrimTypeByDesc( item.getText( 10 ) ) );\n      field.setRepeated( BaseMessages.getString( PKG, \"System.Combo.Yes\" ).equalsIgnoreCase( item.getText( 11 ) ) );\n\n      //CHECKSTYLE:Indentation:OFF\n      in.getInputFields()[i] = field;\n    }\n    in.setShortFileNameField( wShortFileFieldName.getText() );\n    in.setPathField( wPathFieldName.getText() );\n    in.setIsHiddenField( wIsHiddenName.getText() );\n    in.setLastModificationDateField( wLastModificationTimeName.getText() );\n    in.setUriField( wUriName.getText() );\n    in.setRootUriField( wRootUriName.getText() );\n    in.setExtensionField( wExtensionFieldName.getText() );\n  }","id":45233,"modified_method":"private void getInfo( LoadFileInputMeta in ) throws KettleException {\n    stepname = wStepname.getText(); // return value\n\n    // copy info to TextFileInputMeta class (input)\n    in.setRowLimit( Const.toLong( wLimit.getText(), 0L ) );\n    in.setEncoding( wEncoding.getText() );\n    in.setRowNumberField( wInclRownumField.getText() );\n    in.setAddResultFile( wAddResult.getSelection() );\n    in.setIgnoreEmptyFile( wIgnoreEmptyFile.getSelection() );\n\n    in.setIncludeFilename( wInclFilename.getSelection() );\n    in.setIncludeRowNumber( wInclRownum.getSelection() );\n\n    in.setIsInFields( wFilenameInField.getSelection() );\n    in.setDynamicFilenameField( wFilenameField.getText() );\n\n    int nrFields = wFields.nrNonEmpty();\n\n    if ( wFilenameInField.getSelection() ) {\n      in.allocate( 0, nrFields );\n\n      in.setFilenameField( wInclFilenameField.getText() );\n      in.setFileName( new String[0] );\n      in.setFileMask( new String[0] );\n      in.setExcludeFileMask( new String[0] );\n      in.setFileRequired( new String[0] );\n      in.setIncludeSubFolders( new String[0] );\n    } else {\n      in.allocate( wFilenameList.getItemCount(), nrFields );\n\n      in.setFilenameField( null );\n      in.setFileName( wFilenameList.getItems( 0 ) );\n      in.setFileMask( wFilenameList.getItems( 1 ) );\n      in.setExcludeFileMask( wFilenameList.getItems( 2 ) );\n      in.setFileRequired( wFilenameList.getItems( 3 ) );\n      in.setIncludeSubFolders( wFilenameList.getItems( 4 ) );\n    }\n\n    for ( int i = 0; i < nrFields; i++ ) {\n      LoadFileInputField field = new LoadFileInputField();\n\n      TableItem item = wFields.getNonEmpty( i );\n\n      field.setName( item.getText( 1 ) );\n      field.setElementType( LoadFileInputField.getElementTypeByDesc( item.getText( 2 ) ) );\n      field.setType( ValueMeta.getType( item.getText( 3 ) ) );\n      field.setFormat( item.getText( 4 ) );\n      field.setLength( Const.toInt( item.getText( 5 ), -1 ) );\n      field.setPrecision( Const.toInt( item.getText( 6 ), -1 ) );\n      field.setCurrencySymbol( item.getText( 7 ) );\n      field.setDecimalSymbol( item.getText( 8 ) );\n      field.setGroupSymbol( item.getText( 9 ) );\n      field.setTrimType( LoadFileInputField.getTrimTypeByDesc( item.getText( 10 ) ) );\n      field.setRepeated( BaseMessages.getString( PKG, \"System.Combo.Yes\" ).equalsIgnoreCase( item.getText( 11 ) ) );\n\n      //CHECKSTYLE:Indentation:OFF\n      in.getInputFields()[i] = field;\n    }\n    in.setShortFileNameField( wShortFileFieldName.getText() );\n    in.setPathField( wPathFieldName.getText() );\n    in.setIsHiddenField( wIsHiddenName.getText() );\n    in.setLastModificationDateField( wLastModificationTimeName.getText() );\n    in.setUriField( wUriName.getText() );\n    in.setRootUriField( wRootUriName.getText() );\n    in.setExtensionField( wExtensionFieldName.getText() );\n  }","commit_id":"57630a9327506be4fb46b18267c32fb329d5de9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void closeFile() throws KettleException {\n\t\t\n\t\ttry {\n\t\t\tif (data.fc!=null) {\n\t\t\t\tdata.fc.close();\n\t\t\t}\n\t\t\tif (data.fis!=null) {\r\n\t\t\t\tdata.fis.close();\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\n\t\t\tthrow new KettleException(\"Unable to close file channel for file '\"+data.filenames[data.filenr],e);\n\t\t}\n\t}","id":45234,"modified_method":"public void closeFile() throws KettleException {\n\t\t\n\t\ttry {\n\t\t\tif (data.fc!=null) {\n\t\t\t\tdata.fc.close();\n\t\t\t}\n\t\t\tif (data.fis!=null) {\r\n\t\t\t\tdata.fis.close();\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\n\t\t\tthrow new KettleException(\"Unable to close file channel for file '\"+data.filenames[data.filenr-1],e);\n\t\t}\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean openNextFile() throws KettleException {\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\t// Close the previous file...\r\n\t\t\t//\r\n\t\t\tif (data.fc!=null) {\r\n\t\t\t\tdata.fc.close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (data.fis!=null) {\r\n\t\t\t\tdata.fis.close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (data.filenr>=data.filenames.length) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Open the next one...\r\n\t\t\t//\r\n\t\t\tFileObject fileObject = KettleVFS.getFileObject(data.filenames[data.filenr]);\r\n\t\t\tif (!(fileObject instanceof LocalFile)) {\r\n\t\t\t\t// We can only use NIO on local files at the moment, so that's what we limit ourselves to.\r\n\t\t\t\t//\r\n\t\t\t\tthrow new KettleException(Messages.getString(\"CsvInput.Log.OnlyLocalFilesAreSupported\"));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tdata.fis = (FileInputStream)((LocalFile)fileObject).getInputStream();\r\n\t\t\tdata.fc = data.fis.getChannel();\r\n\t\t\tdata.bb = ByteBuffer.allocateDirect( data.preferredBufferSize );\r\n\t\t\t\r\n\t\t\t// Move to the next filename\r\n\t\t\t//\r\n\t\t\tdata.filenr++;\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch(Exception e) {\r\n\t\t\tthrow new KettleException(e);\r\n\t\t}\r\n\t}","id":45235,"modified_method":"private boolean openNextFile() throws KettleException {\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\t// Close the previous file...\r\n\t\t\t//\r\n\t\t\tif (data.fc!=null) {\r\n\t\t\t\tdata.fc.close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (data.fis!=null) {\r\n\t\t\t\tdata.fis.close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (data.filenr>=data.filenames.length) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Open the next one...\r\n\t\t\t//\r\n\t\t\tFileObject fileObject = KettleVFS.getFileObject(data.filenames[data.filenr]);\r\n\t\t\tif (!(fileObject instanceof LocalFile)) {\r\n\t\t\t\t// We can only use NIO on local files at the moment, so that's what we limit ourselves to.\r\n\t\t\t\t//\r\n\t\t\t\tthrow new KettleException(Messages.getString(\"CsvInput.Log.OnlyLocalFilesAreSupported\"));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (meta.isLazyConversionActive()) {\r\n\t\t\t\tdata.binaryFilename=data.filenames[data.filenr].getBytes();\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\tdata.fis = (FileInputStream)((LocalFile)fileObject).getInputStream();\r\n\t\t\tdata.fc = data.fis.getChannel();\r\n\t\t\tdata.bb = ByteBuffer.allocateDirect( data.preferredBufferSize );\r\n\t\t\t\r\n\t\t\t// Move to the next filename\r\n\t\t\t//\r\n\t\t\tdata.filenr++;\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch(Exception e) {\r\n\t\t\tthrow new KettleException(e);\r\n\t\t}\r\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** Read a single row of data from the file... \n\t * \n\t * @param doConversions if you want to do conversions, set to false for the header row.\n\t * @return a row of data...\n\t * @throws KettleException\n\t */\n\tprivate Object[] readOneRow(boolean doConversions) throws KettleException {\n\n\t\ttry {\n\n\t\t\tObject[] outputRowData = RowDataUtil.allocateRowData(data.outputRowMeta.size());\n\t\t\tint outputIndex=0;\n\t\t\tboolean newLineFound = false;\n\t\t\tint newLines = 0;\n\t\t\t\n\t\t\t// The strategy is as follows...\n\t\t\t// We read a block of byte[] from the file.\n\t\t\t// We scan for the separators in the file (NOT for line feeds etc)\n\t\t\t// Then we scan that block of data.\n\t\t\t// We keep a byte[] that we extend if needed..\n\t\t\t// At the end of the block we read another, etc.\n\t\t\t//\n\t\t\t// Let's start by looking where we left off reading.\n\t\t\t//\n\t\t\twhile (!newLineFound && outputIndex<data.convertRowMeta.size()) {\n\t\t\t\t\n\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t//\n\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\n\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\tif (!data.readBufferFromFile()) {\n\t\t\t\t\t\t// TODO handle EOF properly for EOF in the middle of the row, etc.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// OK, at this point we should have data in the byteBuffer and we should be able to scan for the next \n\t\t\t\t// delimiter (;)\n\t\t\t\t// So let's look for a delimiter.\n\t\t\t\t// Also skip over the enclosures (\"), it is NOT taking into account escaped enclosures.\n\t\t\t\t// Later we can add an option for having escaped or double enclosures in the file. <sigh>\n\t\t\t\t//\n\t\t\t\tboolean delimiterFound = false;\n\t\t\t\tboolean enclosureFound = false;\n\t\t\t\tint escapedEnclosureFound = 0;\n\t\t\t\twhile (!delimiterFound) {\n\t\t\t\t\t// If we find the first char, we might find others as well ;-)\n\t\t\t\t\t// Single byte delimiters only for now.\n\t\t\t\t\t//\n\t\t\t\t\tif (data.byteBuffer[data.endBuffer]==data.delimiter[0]) {\n\t\t\t\t\t\tdelimiterFound = true;\n\t\t\t\t\t}\n\t\t\t\t\t// Perhaps we found a new line?\n\t\t\t\t\t// \n\t\t\t\t\t//\n\t\t\t\t\telse if (data.byteBuffer[data.endBuffer]=='\\n' || data.byteBuffer[data.endBuffer]=='\\r') {\n\t\t\t\t\t\t\n\t\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t\t\tnewLines=1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\t\t\t// Ignore EOF, there might be other stuff in the buffer.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tdata.readBufferFromFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// re-check for double delimiters...\n\t\t\t\t\t\tif (data.byteBuffer[data.endBuffer]=='\\n' || data.byteBuffer[data.endBuffer]=='\\r') {\n\t\t\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t\t\t\tnewLines=2;\n\t\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\t\t\t\t// Ignore EOF, there might be other stuff in the buffer.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tdata.readBufferFromFile();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnewLineFound = true;\n\t\t\t\t\t\tdelimiterFound = true;\n\t\t\t\t\t}\n\t\t\t\t\t// Perhaps we need to skip over an enclosed part?\n\t\t\t\t\t// We always expect exactly one enclosure character\n\t\t\t\t\t// If we find the enclosure doubled, we consider it escaped.\n\t\t\t\t\t// --> \"\" is converted to \" later on.\n\t\t\t\t\t//\n\t\t\t\t\telse if (data.enclosure != null && data.byteBuffer[data.endBuffer]==data.enclosure[0]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tenclosureFound=true;\n\t\t\t\t\t\tboolean keepGoing;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (data.increaseEndBuffer())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tenclosureFound=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeepGoing = data.byteBuffer[data.endBuffer]!=data.enclosure[0];\n\t\t\t\t\t\t\tif (!keepGoing)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// We found an enclosure character.\n\t\t\t\t\t\t\t\t// Read another byte...\n\t\t\t\t\t\t\t\tif (data.increaseEndBuffer())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tenclosureFound=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// If this character is also an enclosure, we can consider the enclosure \"escaped\".\n\t\t\t\t\t\t\t\t// As such, if this is an enclosure, we keep going...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tkeepGoing = data.byteBuffer[data.endBuffer]==data.enclosure[0];\n\t\t\t\t\t\t\t\tif (keepGoing) escapedEnclosureFound++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (keepGoing);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Did we reach the end of the buffer?\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnewLineFound=true; // consider it a newline to break out of the upper while loop\n\t\t\t\t\t\t\tnewLines+=2; // to remove the enclosures in case of missing newline on last line.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\t\t\tif (!data.readBufferFromFile()) {\n\t\t\t\t\t\t\t\t// Break out of the loop if we don't have enough buffer space to continue...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnewLineFound=true; // consider it a newline to break out of the upper while loop\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If we're still here, we found a delimiter..\n\t\t\t\t// Since the starting point never changed really, we just can grab range:\n\t\t\t\t//\n\t\t\t\t//    [startBuffer-endBuffer[\n\t\t\t\t//\n\t\t\t\t// This is the part we want.\n\t\t\t\t//\n\t\t\t\tint length = data.endBuffer-data.startBuffer;\n\t\t\t\tif (newLineFound) {\n\t\t\t\t\tlength-=newLines;\n\t\t\t\t\tif (length<=0) length=0;\n\t\t\t\t}\n\t\t\t\tif (enclosureFound) {\n\t\t\t\t\tdata.startBuffer++;\n\t\t\t\t\tlength-=2;\n\t\t\t\t\tif (length<=0) length=0;\n\t\t\t\t}\n\t\t\t\tif (length<=0) length=0;\n\t\t\t\t\n\t\t\t\tbyte[] field = new byte[length];\n\t\t\t\tSystem.arraycopy(data.byteBuffer, data.startBuffer, field, 0, length);\n\n\t\t\t\t// Did we have any escaped characters in there?\n\t\t\t\t//\n\t\t\t\tif (escapedEnclosureFound>0)\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"Escaped enclosures found in \"+new String(field));\n\t\t\t\t\tfield = data.removeEscapedEnclosures(field, escapedEnclosureFound);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (doConversions) {\n\t\t\t\t\tif (meta.isLazyConversionActive()) {\n\t\t\t\t\t\toutputRowData[outputIndex++] = field;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// We're not lazy so we convert the data right here and now.\n\t\t\t\t\t\t// The convert object uses binary storage as such we just have to ask the native type from it.\n\t\t\t\t\t\t// That will do the actual conversion.\n\t\t\t\t\t\t//\n\t\t\t\t\t\tValueMetaInterface sourceValueMeta = data.convertRowMeta.getValueMeta(outputIndex);\n\t\t\t\t\t\toutputRowData[outputIndex++] = sourceValueMeta.convertBinaryStringToNativeType(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutputRowData[outputIndex++] = null; // nothing for the header, no conversions here.\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// OK, move on to the next field...\n\t\t\t\tif( !newLineFound) \n\t\t\t\t{\n\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t}\n\t\t\t\tdata.startBuffer = data.endBuffer;\n\t\t\t}\n\t\t\n\t\t\tlinesInput++;\n\t\t\treturn outputRowData;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleFileException(\"Exception reading line using NIO\", e);\n\t\t}\n\n\t}","id":45236,"modified_method":"/** Read a single row of data from the file... \n\t * \n\t * @param doConversions if you want to do conversions, set to false for the header row.\n\t * @return a row of data...\n\t * @throws KettleException\n\t */\n\tprivate Object[] readOneRow(boolean doConversions) throws KettleException {\n\n\t\ttry {\n\n\t\t\tObject[] outputRowData = RowDataUtil.allocateRowData(data.outputRowMeta.size());\n\t\t\tint outputIndex=0;\n\t\t\tboolean newLineFound = false;\n\t\t\tint newLines = 0;\n\t\t\t\n\t\t\t// The strategy is as follows...\n\t\t\t// We read a block of byte[] from the file.\n\t\t\t// We scan for the separators in the file (NOT for line feeds etc)\n\t\t\t// Then we scan that block of data.\n\t\t\t// We keep a byte[] that we extend if needed..\n\t\t\t// At the end of the block we read another, etc.\n\t\t\t//\n\t\t\t// Let's start by looking where we left off reading.\n\t\t\t//\n\t\t\twhile (!newLineFound && outputIndex<data.convertRowMeta.size()) {\n\t\t\t\t\n\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t//\n\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\n\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\tif (!data.readBufferFromFile()) {\n\t\t\t\t\t\t// TODO handle EOF properly for EOF in the middle of the row, etc.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// OK, at this point we should have data in the byteBuffer and we should be able to scan for the next \n\t\t\t\t// delimiter (;)\n\t\t\t\t// So let's look for a delimiter.\n\t\t\t\t// Also skip over the enclosures (\"), it is NOT taking into account escaped enclosures.\n\t\t\t\t// Later we can add an option for having escaped or double enclosures in the file. <sigh>\n\t\t\t\t//\n\t\t\t\tboolean delimiterFound = false;\n\t\t\t\tboolean enclosureFound = false;\n\t\t\t\tint escapedEnclosureFound = 0;\n\t\t\t\twhile (!delimiterFound) {\n\t\t\t\t\t// If we find the first char, we might find others as well ;-)\n\t\t\t\t\t// Single byte delimiters only for now.\n\t\t\t\t\t//\n\t\t\t\t\tif (data.byteBuffer[data.endBuffer]==data.delimiter[0]) {\n\t\t\t\t\t\tdelimiterFound = true;\n\t\t\t\t\t}\n\t\t\t\t\t// Perhaps we found a new line?\n\t\t\t\t\t// \n\t\t\t\t\t//\n\t\t\t\t\telse if (data.byteBuffer[data.endBuffer]=='\\n' || data.byteBuffer[data.endBuffer]=='\\r') {\n\t\t\t\t\t\t\n\t\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t\t\tnewLines=1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\t\t\t// Ignore EOF, there might be other stuff in the buffer.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tdata.readBufferFromFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// re-check for double delimiters...\n\t\t\t\t\t\tif (data.byteBuffer[data.endBuffer]=='\\n' || data.byteBuffer[data.endBuffer]=='\\r') {\n\t\t\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t\t\t\tnewLines=2;\n\t\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\t\t\t\t// Ignore EOF, there might be other stuff in the buffer.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tdata.readBufferFromFile();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnewLineFound = true;\n\t\t\t\t\t\tdelimiterFound = true;\n\t\t\t\t\t}\n\t\t\t\t\t// Perhaps we need to skip over an enclosed part?\n\t\t\t\t\t// We always expect exactly one enclosure character\n\t\t\t\t\t// If we find the enclosure doubled, we consider it escaped.\n\t\t\t\t\t// --> \"\" is converted to \" later on.\n\t\t\t\t\t//\n\t\t\t\t\telse if (data.enclosure != null && data.byteBuffer[data.endBuffer]==data.enclosure[0]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tenclosureFound=true;\n\t\t\t\t\t\tboolean keepGoing;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (data.increaseEndBuffer())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tenclosureFound=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeepGoing = data.byteBuffer[data.endBuffer]!=data.enclosure[0];\n\t\t\t\t\t\t\tif (!keepGoing)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// We found an enclosure character.\n\t\t\t\t\t\t\t\t// Read another byte...\n\t\t\t\t\t\t\t\tif (data.increaseEndBuffer())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tenclosureFound=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// If this character is also an enclosure, we can consider the enclosure \"escaped\".\n\t\t\t\t\t\t\t\t// As such, if this is an enclosure, we keep going...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tkeepGoing = data.byteBuffer[data.endBuffer]==data.enclosure[0];\n\t\t\t\t\t\t\t\tif (keepGoing) escapedEnclosureFound++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (keepGoing);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Did we reach the end of the buffer?\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnewLineFound=true; // consider it a newline to break out of the upper while loop\n\t\t\t\t\t\t\tnewLines+=2; // to remove the enclosures in case of missing newline on last line.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize) {\n\t\t\t\t\t\t\t// Oops, we need to read more data...\n\t\t\t\t\t\t\t// Better resize this before we read other things in it...\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tdata.resizeByteBuffer();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Also read another chunk of data, now that we have the space for it...\n\t\t\t\t\t\t\tif (!data.readBufferFromFile()) {\n\t\t\t\t\t\t\t\t// Break out of the loop if we don't have enough buffer space to continue...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tif (data.endBuffer>=data.bufferSize)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnewLineFound=true; // consider it a newline to break out of the upper while loop\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If we're still here, we found a delimiter..\n\t\t\t\t// Since the starting point never changed really, we just can grab range:\n\t\t\t\t//\n\t\t\t\t//    [startBuffer-endBuffer[\n\t\t\t\t//\n\t\t\t\t// This is the part we want.\n\t\t\t\t//\n\t\t\t\tint length = data.endBuffer-data.startBuffer;\n\t\t\t\tif (newLineFound) {\n\t\t\t\t\tlength-=newLines;\n\t\t\t\t\tif (length<=0) length=0;\n\t\t\t\t}\n\t\t\t\tif (enclosureFound) {\n\t\t\t\t\tdata.startBuffer++;\n\t\t\t\t\tlength-=2;\n\t\t\t\t\tif (length<=0) length=0;\n\t\t\t\t}\n\t\t\t\tif (length<=0) length=0;\n\t\t\t\t\n\t\t\t\tbyte[] field = new byte[length];\n\t\t\t\tSystem.arraycopy(data.byteBuffer, data.startBuffer, field, 0, length);\n\n\t\t\t\t// Did we have any escaped characters in there?\n\t\t\t\t//\n\t\t\t\tif (escapedEnclosureFound>0)\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"Escaped enclosures found in \"+new String(field));\n\t\t\t\t\tfield = data.removeEscapedEnclosures(field, escapedEnclosureFound);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (doConversions) {\n\t\t\t\t\tif (meta.isLazyConversionActive()) {\n\t\t\t\t\t\toutputRowData[outputIndex++] = field;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// We're not lazy so we convert the data right here and now.\n\t\t\t\t\t\t// The convert object uses binary storage as such we just have to ask the native type from it.\n\t\t\t\t\t\t// That will do the actual conversion.\n\t\t\t\t\t\t//\n\t\t\t\t\t\tValueMetaInterface sourceValueMeta = data.convertRowMeta.getValueMeta(outputIndex);\n\t\t\t\t\t\toutputRowData[outputIndex++] = sourceValueMeta.convertBinaryStringToNativeType(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutputRowData[outputIndex++] = null; // nothing for the header, no conversions here.\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// OK, move on to the next field...\n\t\t\t\tif( !newLineFound) \n\t\t\t\t{\n\t\t\t\t\tdata.endBuffer++;\n\t\t\t\t}\n\t\t\t\tdata.startBuffer = data.endBuffer;\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Optionally add the current filename to the mix as well...\r\n\t\t\t//\r\n\t\t\tif (meta.isIncludingFilename() && !Const.isEmpty(meta.getFilenameField())) {\r\n\t\t\t\tif (meta.isLazyConversionActive()) {\r\n\t\t\t\t\toutputRowData[outputIndex++] = data.binaryFilename;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toutputRowData[outputIndex++] = data.filenames[data.filenr-1];\r\n\t\t\t\t}\r\n\t\t\t}\n\t\t\n\t\t\tlinesInput++;\n\t\t\treturn outputRowData;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleFileException(\"Exception reading line using NIO\", e);\n\t\t}\n\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(CsvInputMeta inputMeta) {\n\t\t\r\n\t\tif (isReceivingInput) {\r\n\t\t\tinputMeta.setFilenameField(wFilename.getText());\r\n\t\t} else {\r\n\t\t\tinputMeta.setFilename(wFilename.getText());\r\n\t\t}\r\n\t\t\n\t\tinputMeta.setDelimiter(wDelimiter.getText());\n\t\tinputMeta.setEnclosure(wEnclosure.getText());\n\t\tinputMeta.setBufferSize(wBufferSize.getText());\n\t\tinputMeta.setLazyConversionActive(wLazyConversion.getSelection());\n\t\tinputMeta.setHeaderPresent(wHeaderPresent.getSelection());\n\n    \tint nrNonEmptyFields = wFields.nrNonEmpty(); \n    \tinputMeta.allocate(nrNonEmptyFields);\n\n\t\tfor (int i=0;i<nrNonEmptyFields;i++) {\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tinputMeta.getInputFields()[i] = new TextFileInputField();\n\t\t\t\n\t\t\tint colnr=1;\n\t\t\tinputMeta.getInputFields()[i].setName( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setType( ValueMeta.getType( item.getText(colnr++) ) );\n\t\t\tinputMeta.getInputFields()[i].setFormat( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setLength( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setPrecision( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setCurrencySymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setDecimalSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setGroupSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setTrimType(ValueMeta.getTrimTypeByDesc( item.getText(colnr++) ));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\tinputMeta.setChanged();\n\t}","id":45237,"modified_method":"private void getInfo(CsvInputMeta inputMeta) {\n\t\t\r\n\t\tif (isReceivingInput) {\r\n\t\t\tinputMeta.setFilenameField(wFilenameField.getText());\r\n\t\t\tinputMeta.setIncludingFilename(wIncludeFilename.getSelection());\r\n\t\t} else {\r\n\t\t\tinputMeta.setFilename(wFilename.getText());\r\n\t\t}\r\n\t\t\n\t\tinputMeta.setDelimiter(wDelimiter.getText());\n\t\tinputMeta.setEnclosure(wEnclosure.getText());\n\t\tinputMeta.setBufferSize(wBufferSize.getText());\n\t\tinputMeta.setLazyConversionActive(wLazyConversion.getSelection());\n\t\tinputMeta.setHeaderPresent(wHeaderPresent.getSelection());\n\n    \tint nrNonEmptyFields = wFields.nrNonEmpty(); \n    \tinputMeta.allocate(nrNonEmptyFields);\n\n\t\tfor (int i=0;i<nrNonEmptyFields;i++) {\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tinputMeta.getInputFields()[i] = new TextFileInputField();\n\t\t\t\n\t\t\tint colnr=1;\n\t\t\tinputMeta.getInputFields()[i].setName( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setType( ValueMeta.getType( item.getText(colnr++) ) );\n\t\t\tinputMeta.getInputFields()[i].setFormat( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setLength( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setPrecision( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setCurrencySymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setDecimalSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setGroupSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setTrimType(ValueMeta.getTrimTypeByDesc( item.getText(colnr++) ));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\tinputMeta.setChanged();\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData(CsvInputMeta inputMeta)\n\t{\n\t\twStepname.setText(stepname);\r\n\t\tif (isReceivingInput) {\n\t\t\twFilename.setText(Const.NVL(inputMeta.getFilenameField(), \"\"));\r\n\t\t} else {\r\n\t\t\twFilename.setText(Const.NVL(inputMeta.getFilename(), \"\"));\r\n\t\t}\n\t\twDelimiter.setText(Const.NVL(inputMeta.getDelimiter(), \"\"));\n\t\twEnclosure.setText(Const.NVL(inputMeta.getEnclosure(), \"\"));\n\t\twBufferSize.setText(Const.NVL(inputMeta.getBufferSize(), \"\"));\n\t\twLazyConversion.setSelection(inputMeta.isLazyConversionActive());\n\t\twHeaderPresent.setSelection(inputMeta.isHeaderPresent());\n\n\t\tfor (int i=0;i<inputMeta.getInputFields().length;i++) {\n\t\t\tTextFileInputField field = inputMeta.getInputFields()[i];\n\t\t\t\n\t\t\tTableItem item = new TableItem(wFields.table, SWT.NONE);\n\t\t\tint colnr=1;\n\t\t\titem.setText(colnr++, Const.NVL(field.getName(), \"\"));\n\t\t\titem.setText(colnr++, ValueMeta.getTypeDesc(field.getType()));\n\t\t\titem.setText(colnr++, Const.NVL(field.getFormat(), \"\"));\n\t\t\titem.setText(colnr++, field.getLength()>=0?Integer.toString(field.getLength()):\"\") ;\n\t\t\titem.setText(colnr++, field.getPrecision()>=0?Integer.toString(field.getPrecision()):\"\") ;\n\t\t\titem.setText(colnr++, Const.NVL(field.getCurrencySymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getDecimalSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getGroupSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getTrimTypeDesc(), \"\"));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\twStepname.selectAll();\n\t}","id":45238,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData(CsvInputMeta inputMeta)\n\t{\n\t\twStepname.setText(stepname);\r\n\t\tif (isReceivingInput) {\n\t\t\twFilenameField.setText(Const.NVL(inputMeta.getFilenameField(), \"\"));\r\n\t\t\twIncludeFilename.setSelection(inputMeta.isIncludingFilename());\r\n\t\t} else {\r\n\t\t\twFilename.setText(Const.NVL(inputMeta.getFilename(), \"\"));\r\n\t\t}\n\t\twDelimiter.setText(Const.NVL(inputMeta.getDelimiter(), \"\"));\n\t\twEnclosure.setText(Const.NVL(inputMeta.getEnclosure(), \"\"));\n\t\twBufferSize.setText(Const.NVL(inputMeta.getBufferSize(), \"\"));\n\t\twLazyConversion.setSelection(inputMeta.isLazyConversionActive());\n\t\twHeaderPresent.setSelection(inputMeta.isHeaderPresent());\n\n\t\tfor (int i=0;i<inputMeta.getInputFields().length;i++) {\n\t\t\tTextFileInputField field = inputMeta.getInputFields()[i];\n\t\t\t\n\t\t\tTableItem item = new TableItem(wFields.table, SWT.NONE);\n\t\t\tint colnr=1;\n\t\t\titem.setText(colnr++, Const.NVL(field.getName(), \"\"));\n\t\t\titem.setText(colnr++, ValueMeta.getTypeDesc(field.getType()));\n\t\t\titem.setText(colnr++, Const.NVL(field.getFormat(), \"\"));\n\t\t\titem.setText(colnr++, field.getLength()>=0?Integer.toString(field.getLength()):\"\") ;\n\t\t\titem.setText(colnr++, field.getPrecision()>=0?Integer.toString(field.getPrecision()):\"\") ;\n\t\t\titem.setText(colnr++, Const.NVL(field.getCurrencySymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getDecimalSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getGroupSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getTrimTypeDesc(), \"\"));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\twStepname.selectAll();\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, inputMeta);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinputMeta.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = inputMeta.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"CsvInputDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Step name line\n\t\t//\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"CsvInputDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\t\tControl lastControl = wStepname;\n\t\t\r\n\t\t\r\n\t\t// See if the step receives input.  If so, we don't ask for the filename, but for the filename field.\r\n\t\t//\r\n\t\tisReceivingInput = transMeta.findNrPrevSteps(stepMeta)>0;\r\n\t\tif (isReceivingInput) {\r\n\t\t\t\r\n\t\t\t// The filename field ...\r\n\t\t\t//\r\n\t\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\r\n\t\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.FilenameField.Label\")); //$NON-NLS-1$\r\n\t \t\tprops.setLook(wlFilename);\r\n\t\t\tFormData fdlFilename = new FormData();\r\n\t\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\t\twlFilename.setLayoutData(fdlFilename);\r\n\t\t\twFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t \t\tprops.setLook(wFilename);\r\n\t\t\twFilename.addModifyListener(lsMod);\r\n\t\t\tFormData fdFilename = new FormData();\r\n\t\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\t\tfdFilename.right= new FormAttachment(100, 0);\r\n\t\t\twFilename.setLayoutData(fdFilename);\r\n\t\t\tlastControl = wFilename;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\r\n\t\t\t// Filename...\n\t\t\t//\n\t\t\t// The filename browse button\n\t\t\t//\n\t        wbbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n\t        props.setLook(wbbFilename);\n\t        wbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t        wbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t        FormData fdbFilename = new FormData();\n\t        fdbFilename.top  = new FormAttachment(lastControl, margin);\n\t        fdbFilename.right= new FormAttachment(100, 0);\n\t        wbbFilename.setLayoutData(fdbFilename);\n\t\n\t        // The field itself...\n\t        //\n\t\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\n\t\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.Filename.Label\")); //$NON-NLS-1$\n\t \t\tprops.setLook(wlFilename);\n\t\t\tFormData fdlFilename = new FormData();\n\t\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\n\t\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\t\twlFilename.setLayoutData(fdlFilename);\n\t\t\twFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t \t\tprops.setLook(wFilename);\n\t\t\twFilename.addModifyListener(lsMod);\n\t\t\tFormData fdFilename = new FormData();\n\t\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\n\t\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\t\tfdFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\t\twFilename.setLayoutData(fdFilename);\n\t\t\tlastControl = wFilename;\r\n\t\t}\n\t\t\n\t\t// delimiter\n\t\tLabel wlDelimiter = new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tFormData fdlDelimiter = new FormData();\n\t\tfdlDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\r\n\t\twbDelimiter=new Button(shell, SWT.PUSH| SWT.CENTER);\r\n        props.setLook(wbDelimiter);\r\n        wbDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Button\"));\r\n        FormData fdbDelimiter=new FormData();\r\n        fdbDelimiter.top  = new FormAttachment(lastControl, margin);\r\n        fdbDelimiter.right= new FormAttachment(100, 0);        \r\n        wbDelimiter.setLayoutData(fdbDelimiter);\n\t\twDelimiter=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tFormData fdDelimiter = new FormData();\n\t\tfdDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.right= new FormAttachment(wbDelimiter, -margin);\n\t\twDelimiter.setLayoutData(fdDelimiter);\t\t\r\n        lastControl = wDelimiter;\r\n\t\t\n\t\t// enclosure\n\t\tLabel wlEnclosure = new Label(shell, SWT.RIGHT);\n\t\twlEnclosure.setText(Messages.getString(\"CsvInputDialog.Enclosure.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlEnclosure);\n\t\tFormData fdlEnclosure = new FormData();\n\t\tfdlEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdlEnclosure.left = new FormAttachment(0, 0);\n\t\tfdlEnclosure.right= new FormAttachment(middle, -margin);\n\t\twlEnclosure.setLayoutData(fdlEnclosure);\n\t\twEnclosure=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wEnclosure);\n\t\twEnclosure.addModifyListener(lsMod);\n\t\tFormData fdEnclosure = new FormData();\n\t\tfdEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdEnclosure.left = new FormAttachment(middle, 0);\n\t\tfdEnclosure.right= new FormAttachment(100, 0);\n\t\twEnclosure.setLayoutData(fdEnclosure);\n\t\tlastControl = wEnclosure;\n\n\t\t// bufferSize\n\t\t//\n\t\tLabel wlBufferSize = new Label(shell, SWT.RIGHT);\n\t\twlBufferSize.setText(Messages.getString(\"CsvInputDialog.BufferSize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlBufferSize);\n\t\tFormData fdlBufferSize = new FormData();\n\t\tfdlBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdlBufferSize.left = new FormAttachment(0, 0);\n\t\tfdlBufferSize.right= new FormAttachment(middle, -margin);\n\t\twlBufferSize.setLayoutData(fdlBufferSize);\n\t\twBufferSize = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wBufferSize);\n\t\twBufferSize.addModifyListener(lsMod);\n\t\tFormData fdBufferSize = new FormData();\n\t\tfdBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdBufferSize.left = new FormAttachment(middle, 0);\n\t\tfdBufferSize.right= new FormAttachment(100, 0);\n\t\twBufferSize.setLayoutData(fdBufferSize);\n\t\tlastControl = wBufferSize;\n\t\t\n\t\t// performingLazyConversion?\n\t\t//\n\t\tLabel wlLazyConversion = new Label(shell, SWT.RIGHT);\n\t\twlLazyConversion.setText(Messages.getString(\"CsvInputDialog.LazyConversion.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlLazyConversion);\n\t\tFormData fdlLazyConversion = new FormData();\n\t\tfdlLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdlLazyConversion.left = new FormAttachment(0, 0);\n\t\tfdlLazyConversion.right= new FormAttachment(middle, -margin);\n\t\twlLazyConversion.setLayoutData(fdlLazyConversion);\n\t\twLazyConversion = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wLazyConversion);\n\t\tFormData fdLazyConversion = new FormData();\n\t\tfdLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdLazyConversion.left = new FormAttachment(middle, 0);\n\t\tfdLazyConversion.right= new FormAttachment(100, 0);\n\t\twLazyConversion.setLayoutData(fdLazyConversion);\n\t\tlastControl = wLazyConversion;\n\n\t\t// header row?\n\t\t//\n\t\tLabel wlHeaderPresent = new Label(shell, SWT.RIGHT);\n\t\twlHeaderPresent.setText(Messages.getString(\"CsvInputDialog.HeaderPresent.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHeaderPresent);\n\t\tFormData fdlHeaderPresent = new FormData();\n\t\tfdlHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdlHeaderPresent.left = new FormAttachment(0, 0);\n\t\tfdlHeaderPresent.right= new FormAttachment(middle, -margin);\n\t\twlHeaderPresent.setLayoutData(fdlHeaderPresent);\n\t\twHeaderPresent = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wHeaderPresent);\n\t\tFormData fdHeaderPresent = new FormData();\n\t\tfdHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdHeaderPresent.left = new FormAttachment(middle, 0);\n\t\tfdHeaderPresent.right= new FormAttachment(100, 0);\n\t\twHeaderPresent.setLayoutData(fdHeaderPresent);\n\t\tlastControl = wHeaderPresent;\n\n\t\t// Some buttons first, so that the dialog scales nicely...\n\t\t//\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"System.Button.Preview\")); //$NON-NLS-1$\n\t\twPreview.setEnabled(!isReceivingInput);\r\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"System.Button.GetFields\")); //$NON-NLS-1$\r\n\t\twGet.setEnabled(!isReceivingInput);\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel, wPreview, wGet, }, margin, null);\n\n\n\t\t// Fields\n        ColumnInfo[] colinf=new ColumnInfo[]\n            {\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.NameColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.getTypes(), true ),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO,  Const.getConversionFormats()),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.LengthColumn.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.PrecisionColumn.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.CurrencyColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.DecimalColumn.Column\"),    ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.GroupColumn.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TrimTypeColumn.Column\"),   ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.trimTypeDesc),\n            };\n        \n        colinf[2].setComboValuesSelectionListener(new ComboValuesSelectionListener() {\n    \t\t\n\t\t\tpublic String[] getComboValues(TableItem tableItem, int rowNr, int colNr) {\n\t\t\t\tString[] comboValues = new String[] { };\n\t\t\t\tint type = ValueMeta.getType( tableItem.getText(colNr-1) );\n\t\t\t\tswitch(type) {\n\t\t\t\tcase ValueMetaInterface.TYPE_DATE: comboValues = Const.getDateFormats(); break;\n\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER: \n\t\t\t\tcase ValueMetaInterface.TYPE_BIGNUMBER:\n\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER: comboValues = Const.getNumberFormats(); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\treturn comboValues;\n\t\t\t}\n\t\t\n\t\t});\n\n        \n        wFields=new TableView(transMeta, shell, \n                              SWT.FULL_SELECTION | SWT.MULTI, \n                              colinf, \n                              1,  \n                              lsMod,\n                              props\n                              );\n\n        FormData fdFields = new FormData();\n        fdFields.top   = new FormAttachment(lastControl, margin*2);\n        fdFields.bottom= new FormAttachment(wOK, -margin*2);\n        fdFields.left  = new FormAttachment(0, 0);\n        fdFields.right = new FormAttachment(100, 0);\n        wFields.setLayoutData(fdFields);\n        \n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview(); } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { getCSV(); } };\n\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twGet.addListener    (SWT.Selection, lsGet    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twFilename.addSelectionListener( lsDef );\n\t\twDelimiter.addSelectionListener( lsDef );\n\t\twEnclosure.addSelectionListener( lsDef );\n\t\twBufferSize.addSelectionListener( lsDef );\n\t\t\r\n\t\t// Allow the insertion of tabs as separator...\r\n\t\twbDelimiter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t\t{\r\n\t\t\t\t\tText t = wDelimiter.getTextWidget();\r\n\t\t\t\t\tif ( t != null )\r\n\t\t\t\t\t    t.insert(\"\\t\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif (wbbFilename!=null) {\n\t\t\t// Listen to the browse button next to the file name\n\t\t\twbbFilename.addSelectionListener(\n\t\t\t\t\tnew SelectionAdapter()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.txt;*.csv\", \"*.csv\", \"*.txt\", \"*\"});\n\t\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString fname = transMeta.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"System.FileType.CSVFiles\")+\", \"+Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.CSVFiles\"), Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\r\n\t\t}\n\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinputMeta.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":45239,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, inputMeta);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinputMeta.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = inputMeta.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"CsvInputDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Step name line\n\t\t//\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"CsvInputDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\t\tControl lastControl = wStepname;\n\t\t\r\n\t\t\r\n\t\t// See if the step receives input.  If so, we don't ask for the filename, but for the filename field.\r\n\t\t//\r\n\t\tisReceivingInput = transMeta.findNrPrevSteps(stepMeta)>0;\r\n\t\tif (isReceivingInput) {\r\n\t\t\t\r\n\t\t\tRowMetaInterface previousFields;\r\n\t\t\ttry {\r\n\t\t\t\tpreviousFields = transMeta.getPrevStepFields(stepMeta);\r\n\t\t\t}\r\n\t\t\tcatch(KettleStepException e) {\r\n\t\t\t\tnew ErrorDialog(shell, Messages.getString(\"CsvInputDialog.ErrorDialog.UnableToGetInputFields.Title\"), Messages.getString(\"CsvInputDialog.ErrorDialog.UnableToGetInputFields.Message\"), e);\r\n\t\t\t\tpreviousFields = new RowMeta();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// The filename field ...\r\n\t\t\t//\r\n\t\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\r\n\t\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.FilenameField.Label\")); //$NON-NLS-1$\r\n\t \t\tprops.setLook(wlFilename);\r\n\t\t\tFormData fdlFilename = new FormData();\r\n\t\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\t\twlFilename.setLayoutData(fdlFilename);\r\n\t\t\twFilenameField=new CCombo(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\t\twFilenameField.setItems(previousFields.getFieldNames());\r\n\t \t\tprops.setLook(wFilenameField);\r\n\t \t\twFilenameField.addModifyListener(lsMod);\r\n\t\t\tFormData fdFilename = new FormData();\r\n\t\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\t\tfdFilename.right= new FormAttachment(100, 0);\r\n\t\t\twFilenameField.setLayoutData(fdFilename);\r\n\t\t\tlastControl = wFilenameField;\r\n\t\t\t\r\n\t\t\t// Checkbox to include the filename in the output...\r\n\t\t\t//\r\n\t\t\tLabel wlIncludeFilename = new Label(shell, SWT.RIGHT);\r\n\t\t\twlIncludeFilename.setText(Messages.getString(\"CsvInputDialog.IncludeFilenameField.Label\")); //$NON-NLS-1$\r\n\t \t\tprops.setLook(wlIncludeFilename);\r\n\t\t\tFormData fdlIncludeFilename = new FormData();\r\n\t\t\tfdlIncludeFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdlIncludeFilename.left = new FormAttachment(0, 0);\r\n\t\t\tfdlIncludeFilename.right= new FormAttachment(middle, -margin);\r\n\t\t\twlIncludeFilename.setLayoutData(fdlIncludeFilename);\r\n\t\t\twIncludeFilename=new Button(shell, SWT.CHECK);\r\n\t \t\tprops.setLook(wIncludeFilename);\r\n\t \t\twFilenameField.addModifyListener(lsMod);\r\n\t\t\tFormData fdIncludeFilename = new FormData();\r\n\t\t\tfdIncludeFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdIncludeFilename.left = new FormAttachment(middle, 0);\r\n\t\t\tfdIncludeFilename.right= new FormAttachment(100, 0);\r\n\t\t\twIncludeFilename.setLayoutData(fdIncludeFilename);\r\n\t\t\tlastControl = wIncludeFilename;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\r\n\t\t\t// Filename...\n\t\t\t//\n\t\t\t// The filename browse button\n\t\t\t//\n\t        wbbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n\t        props.setLook(wbbFilename);\n\t        wbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t        wbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t        FormData fdbFilename = new FormData();\n\t        fdbFilename.top  = new FormAttachment(lastControl, margin);\n\t        fdbFilename.right= new FormAttachment(100, 0);\n\t        wbbFilename.setLayoutData(fdbFilename);\n\t\n\t        // The field itself...\n\t        //\n\t\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\n\t\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.Filename.Label\")); //$NON-NLS-1$\n\t \t\tprops.setLook(wlFilename);\n\t\t\tFormData fdlFilename = new FormData();\n\t\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\n\t\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\t\twlFilename.setLayoutData(fdlFilename);\n\t\t\twFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t \t\tprops.setLook(wFilename);\n\t\t\twFilename.addModifyListener(lsMod);\n\t\t\tFormData fdFilename = new FormData();\n\t\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\n\t\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\t\tfdFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\t\twFilename.setLayoutData(fdFilename);\n\t\t\tlastControl = wFilename;\r\n\t\t}\n\t\t\n\t\t// delimiter\n\t\tLabel wlDelimiter = new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tFormData fdlDelimiter = new FormData();\n\t\tfdlDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\r\n\t\twbDelimiter=new Button(shell, SWT.PUSH| SWT.CENTER);\r\n        props.setLook(wbDelimiter);\r\n        wbDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Button\"));\r\n        FormData fdbDelimiter=new FormData();\r\n        fdbDelimiter.top  = new FormAttachment(lastControl, margin);\r\n        fdbDelimiter.right= new FormAttachment(100, 0);        \r\n        wbDelimiter.setLayoutData(fdbDelimiter);\n\t\twDelimiter=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tFormData fdDelimiter = new FormData();\n\t\tfdDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.right= new FormAttachment(wbDelimiter, -margin);\n\t\twDelimiter.setLayoutData(fdDelimiter);\t\t\r\n        lastControl = wDelimiter;\r\n\t\t\n\t\t// enclosure\n\t\tLabel wlEnclosure = new Label(shell, SWT.RIGHT);\n\t\twlEnclosure.setText(Messages.getString(\"CsvInputDialog.Enclosure.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlEnclosure);\n\t\tFormData fdlEnclosure = new FormData();\n\t\tfdlEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdlEnclosure.left = new FormAttachment(0, 0);\n\t\tfdlEnclosure.right= new FormAttachment(middle, -margin);\n\t\twlEnclosure.setLayoutData(fdlEnclosure);\n\t\twEnclosure=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wEnclosure);\n\t\twEnclosure.addModifyListener(lsMod);\n\t\tFormData fdEnclosure = new FormData();\n\t\tfdEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdEnclosure.left = new FormAttachment(middle, 0);\n\t\tfdEnclosure.right= new FormAttachment(100, 0);\n\t\twEnclosure.setLayoutData(fdEnclosure);\n\t\tlastControl = wEnclosure;\n\n\t\t// bufferSize\n\t\t//\n\t\tLabel wlBufferSize = new Label(shell, SWT.RIGHT);\n\t\twlBufferSize.setText(Messages.getString(\"CsvInputDialog.BufferSize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlBufferSize);\n\t\tFormData fdlBufferSize = new FormData();\n\t\tfdlBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdlBufferSize.left = new FormAttachment(0, 0);\n\t\tfdlBufferSize.right= new FormAttachment(middle, -margin);\n\t\twlBufferSize.setLayoutData(fdlBufferSize);\n\t\twBufferSize = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wBufferSize);\n\t\twBufferSize.addModifyListener(lsMod);\n\t\tFormData fdBufferSize = new FormData();\n\t\tfdBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdBufferSize.left = new FormAttachment(middle, 0);\n\t\tfdBufferSize.right= new FormAttachment(100, 0);\n\t\twBufferSize.setLayoutData(fdBufferSize);\n\t\tlastControl = wBufferSize;\n\t\t\n\t\t// performingLazyConversion?\n\t\t//\n\t\tLabel wlLazyConversion = new Label(shell, SWT.RIGHT);\n\t\twlLazyConversion.setText(Messages.getString(\"CsvInputDialog.LazyConversion.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlLazyConversion);\n\t\tFormData fdlLazyConversion = new FormData();\n\t\tfdlLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdlLazyConversion.left = new FormAttachment(0, 0);\n\t\tfdlLazyConversion.right= new FormAttachment(middle, -margin);\n\t\twlLazyConversion.setLayoutData(fdlLazyConversion);\n\t\twLazyConversion = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wLazyConversion);\n\t\tFormData fdLazyConversion = new FormData();\n\t\tfdLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdLazyConversion.left = new FormAttachment(middle, 0);\n\t\tfdLazyConversion.right= new FormAttachment(100, 0);\n\t\twLazyConversion.setLayoutData(fdLazyConversion);\n\t\tlastControl = wLazyConversion;\n\n\t\t// header row?\n\t\t//\n\t\tLabel wlHeaderPresent = new Label(shell, SWT.RIGHT);\n\t\twlHeaderPresent.setText(Messages.getString(\"CsvInputDialog.HeaderPresent.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHeaderPresent);\n\t\tFormData fdlHeaderPresent = new FormData();\n\t\tfdlHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdlHeaderPresent.left = new FormAttachment(0, 0);\n\t\tfdlHeaderPresent.right= new FormAttachment(middle, -margin);\n\t\twlHeaderPresent.setLayoutData(fdlHeaderPresent);\n\t\twHeaderPresent = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wHeaderPresent);\n\t\tFormData fdHeaderPresent = new FormData();\n\t\tfdHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdHeaderPresent.left = new FormAttachment(middle, 0);\n\t\tfdHeaderPresent.right= new FormAttachment(100, 0);\n\t\twHeaderPresent.setLayoutData(fdHeaderPresent);\n\t\tlastControl = wHeaderPresent;\n\n\t\t// Some buttons first, so that the dialog scales nicely...\n\t\t//\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"System.Button.Preview\")); //$NON-NLS-1$\n\t\twPreview.setEnabled(!isReceivingInput);\r\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"System.Button.GetFields\")); //$NON-NLS-1$\r\n\t\twGet.setEnabled(!isReceivingInput);\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel, wPreview, wGet, }, margin, null);\n\n\n\t\t// Fields\n        ColumnInfo[] colinf=new ColumnInfo[]\n            {\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.NameColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.getTypes(), true ),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO,  Const.getConversionFormats()),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.LengthColumn.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.PrecisionColumn.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.CurrencyColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.DecimalColumn.Column\"),    ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.GroupColumn.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TrimTypeColumn.Column\"),   ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.trimTypeDesc),\n            };\n        \n        colinf[2].setComboValuesSelectionListener(new ComboValuesSelectionListener() {\n    \t\t\n\t\t\tpublic String[] getComboValues(TableItem tableItem, int rowNr, int colNr) {\n\t\t\t\tString[] comboValues = new String[] { };\n\t\t\t\tint type = ValueMeta.getType( tableItem.getText(colNr-1) );\n\t\t\t\tswitch(type) {\n\t\t\t\tcase ValueMetaInterface.TYPE_DATE: comboValues = Const.getDateFormats(); break;\n\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER: \n\t\t\t\tcase ValueMetaInterface.TYPE_BIGNUMBER:\n\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER: comboValues = Const.getNumberFormats(); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\treturn comboValues;\n\t\t\t}\n\t\t\n\t\t});\n\n        \n        wFields=new TableView(transMeta, shell, \n                              SWT.FULL_SELECTION | SWT.MULTI, \n                              colinf, \n                              1,  \n                              lsMod,\n                              props\n                              );\n\n        FormData fdFields = new FormData();\n        fdFields.top   = new FormAttachment(lastControl, margin*2);\n        fdFields.bottom= new FormAttachment(wOK, -margin*2);\n        fdFields.left  = new FormAttachment(0, 0);\n        fdFields.right = new FormAttachment(100, 0);\n        wFields.setLayoutData(fdFields);\n        \n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview(); } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { getCSV(); } };\n\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twGet.addListener    (SWT.Selection, lsGet    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\tif (wFilename!=null) wFilename.addSelectionListener( lsDef );\n\t\tif (wFilenameField!=null) wFilenameField.addSelectionListener( lsDef );\r\n\t\twDelimiter.addSelectionListener( lsDef );\n\t\twEnclosure.addSelectionListener( lsDef );\n\t\twBufferSize.addSelectionListener( lsDef );\n\t\t\r\n\t\t// Allow the insertion of tabs as separator...\r\n\t\twbDelimiter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t\t{\r\n\t\t\t\t\tText t = wDelimiter.getTextWidget();\r\n\t\t\t\t\tif ( t != null )\r\n\t\t\t\t\t    t.insert(\"\\t\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif (wbbFilename!=null) {\n\t\t\t// Listen to the browse button next to the file name\n\t\t\twbbFilename.addSelectionListener(\n\t\t\t\t\tnew SelectionAdapter()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.txt;*.csv\", \"*.csv\", \"*.txt\", \"*\"});\n\t\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString fname = transMeta.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"System.FileType.CSVFiles\")+\", \"+Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.CSVFiles\"), Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\r\n\t\t}\n\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinputMeta.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n\t\tStringBuffer retval = new StringBuffer(500);\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename\", filename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename_field\", filenameField));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", delimiter));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\", headerPresent));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"buffer_size\", bufferSize));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"lazy_conversion\", lazyConversionActive));\n\n\t\tretval.append(\"    <fields>\").append(Const.CR);\n\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t{\n\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\n\t\t\tretval.append(\"      <field>\").append(Const.CR);\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\", field.getName()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(field.getType())));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\", field.getFormat()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\", field.getCurrencySymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\", field.getDecimalSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\", field.getGroupSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\", field.getLength()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", ValueMeta.getTrimTypeCode(field.getTrimType())));\n\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\n\t\t}\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\n\n\t\treturn retval.toString();\n\t}","id":45240,"modified_method":"public String getXML()\n\t{\n\t\tStringBuffer retval = new StringBuffer(500);\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename\", filename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename_field\", filenameField));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"include_filename\", includingFilename));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", delimiter));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\", headerPresent));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"buffer_size\", bufferSize));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"lazy_conversion\", lazyConversionActive));\n\n\t\tretval.append(\"    <fields>\").append(Const.CR);\n\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t{\n\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\n\t\t\tretval.append(\"      <field>\").append(Const.CR);\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\", field.getName()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(field.getType())));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\", field.getFormat()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\", field.getCurrencySymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\", field.getDecimalSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\", field.getGroupSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\", field.getLength()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", ValueMeta.getTrimTypeCode(field.getTrimType())));\n\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\n\t\t}\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\n\n\t\treturn retval.toString();\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = rep.getStepAttributeString(id_step, \"filename\");\n\t\t\tfilenameField = rep.getStepAttributeString(id_step, \"filename_field\");\r\n\t\t\tdelimiter = rep.getStepAttributeString(id_step, \"separator\");\n\t\t\tenclosure = rep.getStepAttributeString(id_step, \"enclosure\");\n\t\t\theaderPresent = rep.getStepAttributeBoolean(id_step, \"header\");\n\t\t\tbufferSize = rep.getStepAttributeString(id_step, \"buffer_size\");\n\t\t\tlazyConversionActive = rep.getStepAttributeBoolean(id_step, \"lazy_conversion\");\n\t\t\t\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tinputFields[i].setName( rep.getStepAttributeString(id_step, i, \"field_name\") );\n\t\t\t\tinputFields[i].setType( ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"field_type\")) );\n\t\t\t\tinputFields[i].setFormat( rep.getStepAttributeString(id_step, i, \"field_format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( rep.getStepAttributeString(id_step, i, \"field_currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( rep.getStepAttributeString(id_step, i, \"field_decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( rep.getStepAttributeString(id_step, i, \"field_group\") );\n\t\t\t\tinputFields[i].setLength( (int) rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tinputFields[i].setPrecision( (int) rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":45241,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = rep.getStepAttributeString(id_step, \"filename\");\n\t\t\tfilenameField = rep.getStepAttributeString(id_step, \"filename_field\");\r\n\t\t\tincludingFilename = rep.getStepAttributeBoolean(id_step, \"include_filename\");\r\n\t\t\tdelimiter = rep.getStepAttributeString(id_step, \"separator\");\n\t\t\tenclosure = rep.getStepAttributeString(id_step, \"enclosure\");\n\t\t\theaderPresent = rep.getStepAttributeBoolean(id_step, \"header\");\n\t\t\tbufferSize = rep.getStepAttributeString(id_step, \"buffer_size\");\n\t\t\tlazyConversionActive = rep.getStepAttributeBoolean(id_step, \"lazy_conversion\");\n\t\t\t\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tinputFields[i].setName( rep.getStepAttributeString(id_step, i, \"field_name\") );\n\t\t\t\tinputFields[i].setType( ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"field_type\")) );\n\t\t\t\tinputFields[i].setFormat( rep.getStepAttributeString(id_step, i, \"field_format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( rep.getStepAttributeString(id_step, i, \"field_currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( rep.getStepAttributeString(id_step, i, \"field_decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( rep.getStepAttributeString(id_step, i, \"field_group\") );\n\t\t\t\tinputFields[i].setLength( (int) rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tinputFields[i].setPrecision( (int) rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = XMLHandler.getTagValue(stepnode, \"filename\");\n\t\t\tfilenameField = XMLHandler.getTagValue(stepnode, \"filename_field\");\r\n\t\t\tdelimiter = XMLHandler.getTagValue(stepnode, \"separator\");\n\t\t\tenclosure = XMLHandler.getTagValue(stepnode, \"enclosure\");\n\t\t\tbufferSize  = XMLHandler.getTagValue(stepnode, \"buffer_size\");\n\t\t\theaderPresent = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\n\t\t\tlazyConversionActive= \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"lazy_conversion\"));\n\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\n\t\t\t\tinputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\n\t\t\t\tinputFields[i].setType(  ValueMeta.getType(XMLHandler.getTagValue(fnode, \"type\")) );\n\t\t\t\tinputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( XMLHandler.getTagValue(fnode, \"group\") );\n\t\t\t\tinputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\n\t\t\t\tinputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( XMLHandler.getTagValue(fnode, \"trim_type\") ) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":45242,"modified_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = XMLHandler.getTagValue(stepnode, \"filename\");\n\t\t\tfilenameField = XMLHandler.getTagValue(stepnode, \"filename_field\");\r\n\t\t\tincludingFilename = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"include_filename\"));\r\n\t\t\tdelimiter = XMLHandler.getTagValue(stepnode, \"separator\");\n\t\t\tenclosure = XMLHandler.getTagValue(stepnode, \"enclosure\");\n\t\t\tbufferSize  = XMLHandler.getTagValue(stepnode, \"buffer_size\");\n\t\t\theaderPresent = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\n\t\t\tlazyConversionActive= \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"lazy_conversion\"));\n\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\n\t\t\t\tinputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\n\t\t\t\tinputFields[i].setType(  ValueMeta.getType(XMLHandler.getTagValue(fnode, \"type\")) );\n\t\t\t\tinputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( XMLHandler.getTagValue(fnode, \"group\") );\n\t\t\t\tinputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\n\t\t\t\tinputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( XMLHandler.getTagValue(fnode, \"trim_type\") ) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename\", filename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename_field\", filenameField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\", delimiter);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\", enclosure);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"buffer_size\", bufferSize);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\", headerPresent);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"lazy_conversion\", lazyConversionActive);\n\n\t\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t\t{\n\t\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\t\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\", field.getName());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\", ValueMeta.getTypeDesc(field.getType()));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\", field.getFormat());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\", field.getCurrencySymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\", field.getDecimalSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\", field.getGroupSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\", field.getLength());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", ValueMeta.getTrimTypeCode( field.getTrimType()));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\" + id_step, e);\n\t\t}\n\t}","id":45243,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename\", filename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename_field\", filenameField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"include_filename\", includingFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\", delimiter);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\", enclosure);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"buffer_size\", bufferSize);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\", headerPresent);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"lazy_conversion\", lazyConversionActive);\n\n\t\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t\t{\n\t\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\t\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\", field.getName());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\", ValueMeta.getTypeDesc(field.getType()));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\", field.getFormat());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\", field.getCurrencySymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\", field.getDecimalSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\", field.getGroupSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\", field.getLength());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", ValueMeta.getTrimTypeCode( field.getTrimType()));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\" + id_step, e);\n\t\t}\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getFields(RowMetaInterface rowMeta, String origin, RowMetaInterface[] info, StepMeta nextStep, VariableSpace space) throws KettleStepException\n\t{\n\t\tfor (int i=0;i<inputFields.length;i++) {\n\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\n\t\t\tValueMetaInterface valueMeta = new ValueMeta(field.getName(), field.getType());\n\t\t\tvalueMeta.setConversionMask( field.getFormat() );\n\t\t\tvalueMeta.setLength( field.getLength() );\n\t\t\tvalueMeta.setPrecision( field.getPrecision() );\n\t\t\tvalueMeta.setConversionMask( field.getFormat() );\n\t\t\tvalueMeta.setDecimalSymbol( field.getDecimalSymbol() );\n\t\t\tvalueMeta.setGroupingSymbol( field.getGroupSymbol() );\n\t\t\tvalueMeta.setCurrencySymbol( field.getCurrencySymbol() );\n\t\t\tvalueMeta.setTrimType( field.getTrimType() );\n\t\t\tif (lazyConversionActive) valueMeta.setStorageType(ValueMetaInterface.STORAGE_TYPE_BINARY_STRING);\n\t\t\t\n\t\t\t// In case we want to convert Strings...\n\t\t\t// Using a copy of the valueMeta object means that the inner and outer representation format is the same.\n\t\t\t// Preview will show the data the same way as we read it.\n\t\t\t// This layout is then taken further down the road by the metadata through the transformation.\n\t\t\t//\n\t\t\tValueMetaInterface storageMetadata = valueMeta.clone();\n\t\t\tstorageMetadata.setType(ValueMetaInterface.TYPE_STRING);\n\t\t\tstorageMetadata.setStorageType(ValueMetaInterface.STORAGE_TYPE_NORMAL);\n\t\t\tstorageMetadata.setLength(-1,-1); // we don't really know the lengths of the strings read in advance.\n\t\t\tvalueMeta.setStorageMetadata(storageMetadata);\n\t\t\t\n\t\t\tvalueMeta.setOrigin(origin);\n\t\t\t\n\t\t\trowMeta.addValueMeta(valueMeta);\n\t\t}\n\t}","id":45244,"modified_method":"public void getFields(RowMetaInterface rowMeta, String origin, RowMetaInterface[] info, StepMeta nextStep, VariableSpace space) throws KettleStepException\n\t{\r\n\t\trowMeta.clear(); // Start with a clean slate, eats the input\r\n\t\t\n\t\tfor (int i=0;i<inputFields.length;i++) {\n\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\n\t\t\tValueMetaInterface valueMeta = new ValueMeta(field.getName(), field.getType());\n\t\t\tvalueMeta.setConversionMask( field.getFormat() );\n\t\t\tvalueMeta.setLength( field.getLength() );\n\t\t\tvalueMeta.setPrecision( field.getPrecision() );\n\t\t\tvalueMeta.setConversionMask( field.getFormat() );\n\t\t\tvalueMeta.setDecimalSymbol( field.getDecimalSymbol() );\n\t\t\tvalueMeta.setGroupingSymbol( field.getGroupSymbol() );\n\t\t\tvalueMeta.setCurrencySymbol( field.getCurrencySymbol() );\n\t\t\tvalueMeta.setTrimType( field.getTrimType() );\n\t\t\tif (lazyConversionActive) valueMeta.setStorageType(ValueMetaInterface.STORAGE_TYPE_BINARY_STRING);\n\t\t\t\n\t\t\t// In case we want to convert Strings...\n\t\t\t// Using a copy of the valueMeta object means that the inner and outer representation format is the same.\n\t\t\t// Preview will show the data the same way as we read it.\n\t\t\t// This layout is then taken further down the road by the metadata through the transformation.\n\t\t\t//\n\t\t\tValueMetaInterface storageMetadata = valueMeta.clone();\n\t\t\tstorageMetadata.setType(ValueMetaInterface.TYPE_STRING);\n\t\t\tstorageMetadata.setStorageType(ValueMetaInterface.STORAGE_TYPE_NORMAL);\n\t\t\tstorageMetadata.setLength(-1,-1); // we don't really know the lengths of the strings read in advance.\n\t\t\tvalueMeta.setStorageMetadata(storageMetadata);\n\t\t\t\n\t\t\tvalueMeta.setOrigin(origin);\n\t\t\t\n\t\t\trowMeta.addValueMeta(valueMeta);\n\t\t}\r\n\t\t\r\n\t\tif (!Const.isEmpty(filenameField) && includingFilename) {\r\n\t\t\tValueMetaInterface filenameMeta = new ValueMeta(filenameField, ValueMetaInterface.TYPE_STRING);\r\n\t\t\tfilenameMeta.setOrigin(origin);\r\n\t\t\tif (lazyConversionActive) {\r\n\t\t\t\tfilenameMeta.setStorageType(ValueMetaInterface.STORAGE_TYPE_BINARY_STRING);\r\n\t\t\t\tfilenameMeta.setStorageMetadata(new ValueMeta(filenameField, ValueMetaInterface.TYPE_STRING));\r\n\t\t\t}\r\n\t\t\trowMeta.addValueMeta(filenameMeta);\r\n\t\t}\r\n\t\t\n\t}","commit_id":"628428ad41e69048108a6b216921c56aa0a60f42","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void Processfile(FileObject file)\r\n\t{\r\n\t\tDatabase d = null;\r\n\t\t\r\n\t\ttry \r\n\t\t{\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n        \td = Database.open(new File(KettleVFS.getFilename(data.file)));\t\t\t\r\n\t\t\tTable t=d.getTable(meta.getRealTableName());\r\n\r\n\t\t\tMap rw;\r\n\t\t\t\r\n\t\t\tint rowCount = 0;\r\n\t\t\twhile ((rowCount++ < Long.MAX_VALUE) && ((rw = t.getNextRow()) != null)) \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// Create new row\r\n\t\t\t\tRow row = buildEmptyRow();\r\n\t\t\t\t\t\t\r\n\t\t\t\t// Execute for each Input field...\r\n\t\t\t\tfor (int i=0;i<meta.getInputFields().length;i++)\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tObject obj = rw.get(meta.getInputFields()[i].getAttribut());\t\r\n\t\t\t\t\r\n\t\t\t\t\t// OK, we have the string...\r\n\t\t\t\t\tValue v = row.getValue(i);\r\n\t\t\t\t\tv.setValue(String.valueOf(obj));\r\n\t\t            \r\n\t\t            // Do we need to repeat this field if it is null?\r\n\t\t            if (meta.getInputFields()[i].isRepeated())\r\n\t\t            {\r\n\t\t                if (v.isNull() && data.previousRow!=null)\r\n\t\t                {\r\n\t\t                    Value previous = data.previousRow.getValue(i);\r\n\t\t                    v.setValue(previous);\r\n\t\t                }\r\n\t\t            }\r\n\t\t \t\t\t\r\n\t\t\t\t}    // End of loop over fields...\r\n\t\t            \r\n\t\t\t\t   // See if we need to add the filename to the row...  \r\n\t\t        if (meta.includeFilename() && meta.getFilenameField()!=null && meta.getFilenameField().length()>0)\r\n\t\t        {\r\n\t\t            Value fn = new Value( meta.getFilenameField(), KettleVFS.getFilename(data.file));\r\n\t\t            row.addValue(fn);\r\n\t\t        }\r\n\t\t        \r\n\t\t        // See if we need to add the row number to the row...  \r\n\t\t        if (meta.includeRowNumber() && meta.getRowNumberField()!=null && meta.getRowNumberField().length()>0)\r\n\t\t        {\r\n\t\t            Value fn = new Value( meta.getRowNumberField(), data.rownr );\r\n\t\t            row.addValue(fn);\r\n\t\t        }\r\n\t\t        \r\n\t\t\t\tdata.previousRow = new Row(row); // copy it to make sure the next step doesn't change it in between... \r\n\t\t\t\tdata.rownr++;\r\n\t\t        \r\n\t    \t\t\r\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"AccessInput.Log.ReadRow\", row.toString()));        \r\n\t            \r\n\t\t\t\tputRow(row);\r\n\t\t\t}\r\n\t\t\t       \r\n\t\t} \r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"AccessInput.Log.UnableToOpenFile\", \"\"+data.filenr, data.file.toString(), e.toString()));\r\n\t\t\tstopAll();\r\n\t\t\tsetErrors(1);\r\n\t\t} \r\n\t\t finally\r\n\t        {\r\n\t            // Don't forget to close the bugger.\r\n\t            try\r\n\t            {\r\n\t                if (d!=null) d.close();\r\n\t            }\r\n\t            catch(Exception e)\r\n\t            {\r\n\t                \r\n\t            }\r\n\t        }\r\n\t}","id":45245,"modified_method":"private void Processfile(FileObject file)\r\n\t{\r\n\t\tDatabase d = null;\r\n\t\t\r\n\t\ttry \r\n\t\t{\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n        \td = Database.open(new File(KettleVFS.getFilename(data.file)));\t\t\t\r\n\t\t\tTable t=d.getTable(meta.getRealTableName());\r\n\r\n\t\t\tMap rw;\r\n\t\t\t\r\n\t\t\tint rowCount = 0;\r\n\t\t\twhile ((rowCount++ < Long.MAX_VALUE) && ((rw = t.getNextRow()) != null)) \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// Create new row\r\n\t\t\t\tRow row = buildEmptyRow();\r\n\t\t\t\t\t\t\r\n\t\t\t\t// Execute for each Input field...\r\n\t\t\t\tfor (int i=0;i<meta.getInputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tAccessInputField accessInputField = meta.getInputFields()[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\tObject obj = rw.get(meta.getInputFields()[i].getAttribut());\t\r\n\t\t\t\t\r\n\t\t\t\t\t// OK, we have the string...\r\n\t\t\t\t\tValue v = row.getValue(i);\r\n\t\t\t\t\tv.setValue(String.valueOf(obj));\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t// DO Trimming!\r\n\t\t\t\t\tswitch(accessInputField.getTrimType())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase AccessInputField.TYPE_TRIM_LEFT  : v.ltrim(); break;\r\n\t\t\t\t\t\tcase AccessInputField.TYPE_TRIM_RIGHT : v.rtrim(); break;\r\n\t\t\t\t\t\tcase AccessInputField.TYPE_TRIM_BOTH  : v.trim(); break;\r\n\t\t\t\t\t\tdefault: break;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t            \r\n\t\t\t\t\t// DO CONVERSIONS...\r\n\t\t\t\t\tswitch(accessInputField.getType())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase Value.VALUE_TYPE_STRING:\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase Value.VALUE_TYPE_NUMBER:\r\n\t\t\t\t\t\t\t// System.out.println(\"Convert value to Number :\"+v);\r\n\t\t\t\t\t\t\tif (accessInputField.getFormat()!=null && accessInputField.getFormat().length()>0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (accessInputField.getDecimalSymbol()!=null && accessInputField.getDecimalSymbol().length()>0)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif (accessInputField.getGroupSymbol()!=null && accessInputField.getGroupSymbol().length()>0)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tif (accessInputField.getCurrencySymbol()!=null && accessInputField.getCurrencySymbol().length()>0)\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tv.str2num(accessInputField.getFormat(), accessInputField.getDecimalSymbol(), accessInputField.getGroupSymbol(), accessInputField.getCurrencySymbol());\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tv.str2num(accessInputField.getFormat(), accessInputField.getDecimalSymbol(), accessInputField.getGroupSymbol());\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tv.str2num(accessInputField.getFormat(), accessInputField.getDecimalSymbol());\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tv.str2num(accessInputField.getFormat()); // just a format mask\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tv.str2num();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tv.setLength(accessInputField.getLength(), accessInputField.getPrecision());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase Value.VALUE_TYPE_INTEGER:\r\n\t\t\t\t\t\t\t// System.out.println(\"Convert value to integer :\"+v);\r\n\t\t\t\t\t\t\tv.setValue(v.getInteger());\r\n\t\t\t\t\t\t\tv.setLength(accessInputField.getLength(), accessInputField.getPrecision());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase Value.VALUE_TYPE_BIGNUMBER:\r\n\t\t\t\t\t\t\t// System.out.println(\"Convert value to BigNumber :\"+v);\r\n\t\t\t\t\t\t\tv.setValue(v.getBigNumber());\r\n\t\t\t\t\t\t\tv.setLength(accessInputField.getLength(), accessInputField.getPrecision());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase Value.VALUE_TYPE_DATE:\r\n\t\t\t\t\t\t\t// System.out.println(\"Convert value to Date :\"+v);\r\n\r\n\t\t\t\t\t\t\tif (accessInputField.getFormat()!=null && accessInputField.getFormat().length()>0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tv.str2dat(accessInputField.getFormat());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tv.setValue(v.getDate());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase Value.VALUE_TYPE_BOOLEAN:\r\n\t\t\t\t\t\t\tv.setValue(v.getBoolean());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: break;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t            \r\n\t\t            // Do we need to repeat this field if it is null?\r\n\t\t            if (meta.getInputFields()[i].isRepeated())\r\n\t\t            {\r\n\t\t                if (v.isNull() && data.previousRow!=null)\r\n\t\t                {\r\n\t\t                    Value previous = data.previousRow.getValue(i);\r\n\t\t                    v.setValue(previous);\r\n\t\t                }\r\n\t\t            }\r\n\t\t \t\t\t\r\n\t\t\t\t}    // End of loop over fields...\r\n\t\t            \r\n\t\t\t\t// See if we need to add the filename to the row...  \r\n\t\t        if (meta.includeFilename() && meta.getFilenameField()!=null && meta.getFilenameField().length()>0)\r\n\t\t        {\r\n\t\t            Value fn = new Value( meta.getFilenameField(), KettleVFS.getFilename(data.file));\r\n\t\t            row.addValue(fn);\r\n\t\t        }\r\n\t\t        \r\n\t\t \t   // See if we need to add the tablename to the row...  \r\n\t\t        if (meta.includeTablename() && meta.gettablenameField()!=null && meta.gettablenameField().length()>0)\r\n\t\t        {\r\n\t\t            Value fn = new Value( meta.gettablenameField(), meta.getRealTableName());\r\n\t\t            row.addValue(fn);\r\n\t\t        }\r\n\t\t        \r\n\t\t        \r\n\t\t        // See if we need to add the row number to the row...  \r\n\t\t        if (meta.includeRowNumber() && meta.getRowNumberField()!=null && meta.getRowNumberField().length()>0)\r\n\t\t        {\r\n\t\t            Value fn = new Value( meta.getRowNumberField(), data.rownr );\r\n\t\t            row.addValue(fn);\r\n\t\t        }\r\n\t\t        \r\n\t\t\t\tdata.previousRow = new Row(row); // copy it to make sure the next step doesn't change it in between... \r\n\t\t\t\tdata.rownr++;\r\n\t\t        \r\n\t    \t\t\r\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"AccessInput.Log.ReadRow\", row.toString()));        \r\n\t            \r\n\t\t\t\tputRow(row);\r\n\t\t\t}\r\n\t\t\t       \r\n\t\t} \r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"AccessInput.Log.UnableToOpenFile\", \"\"+data.filenr, data.file.toString(), e.toString()));\r\n\t\t\tstopAll();\r\n\t\t\tsetErrors(1);\r\n\t\t} \r\n\t\t finally\r\n\t        {\r\n\t            // Don't forget to close the bugger.\r\n\t            try\r\n\t            {\r\n\t                if (d!=null) d.close();\r\n\t            }\r\n\t            catch(Exception e)\r\n\t            {\r\n\t                \r\n\t            }\r\n\t        }\r\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(AccessInputMeta in) throws KettleException\n\t{\n\t\tstepname = wStepname.getText(); // return value\n\n\t\t// copy info to TextFileInputMeta class (input)\n\t\tin.setRowLimit( Const.toLong(wLimit.getText(), 0L) );\n\t\tin.setFilenameField( wInclFilenameField.getText() );\n\t\t\n\t\tin.setTableName( wTable.getText() );\n\t\tin.setRowNumberField( wInclRownumField.getText() );\n\t\t\t\t\n\t\tin.setIncludeFilename( wInclFilename.getSelection() );\n\t\tin.setIncludeRowNumber( wInclRownum.getSelection() );\n\t\t\n\t\tint nrFiles     = wFilenameList.getItemCount();\n\t\tint nrFields    = wFields.nrNonEmpty();\n         \n\t\tin.allocate(nrFiles, nrFields);\n\n\t\tin.setFileName( wFilenameList.getItems(0) );\n\t\tin.setFileMask( wFilenameList.getItems(1) );\n\n\t\tfor (int i=0;i<nrFields;i++)\n\t\t{\n\t\t    AccessInputField field = new AccessInputField();\n\t\t    \n\t\t\tTableItem item  = wFields.getNonEmpty(i);\n            \n\t\t\tfield.setName( item.getText(1) );\n\t\t\tfield.setAttribut( item.getText(2) );\n\t\t\tfield.setType( Value.getType(item.getText(3)) );\n\t\t\tfield.setFormat( item.getText(4) );\n\t\t\tfield.setLength( Const.toInt(item.getText(5), -1) );\n\t\t\tfield.setPrecision( Const.toInt(item.getText(6), -1) );\n\t\t\tfield.setCurrencySymbol( item.getText(7) );\n\t\t\tfield.setDecimalSymbol( item.getText(8) );\n\t\t\tfield.setGroupSymbol( item.getText(9) );\n\t\t\tfield.setTrimType( AccessInputField.getTrimTypeByDesc(item.getText(10)) );\n\t\t\tfield.setRepeated( Messages.getString(\"System.Combo.Yes\").equalsIgnoreCase(item.getText(11)) );\t\t\n            \n\t\t\tin.getInputFields()[i] = field;\n\t\t}\t\t \n\t}","id":45246,"modified_method":"private void getInfo(AccessInputMeta in) throws KettleException\n\t{\n\t\tstepname = wStepname.getText(); // return value\n\n\t\t// copy info to TextFileInputMeta class (input)\n\t\tin.setRowLimit( Const.toLong(wLimit.getText(), 0L) );\n\t\t\n\t\t\n\t\tin.setTableName( wTable.getText() );\n\t\t\n\t\tin.setIncludeFilename( wInclFilename.getSelection() );\n\t\tin.setFilenameField( wInclFilenameField.getText() );\n\t\t\n\t\tin.setIncludeTablename( wInclTablename.getSelection() );\n\t\tin.setTablenameField( wInclTablenameField.getText() );\n\t\t\n\t\tin.setIncludeRowNumber( wInclRownum.getSelection() );\n\t\tin.setRowNumberField( wInclRownumField.getText() );\n\t\t\t\t\n\n\t\t\n\t\tint nrFiles     = wFilenameList.getItemCount();\n\t\tint nrFields    = wFields.nrNonEmpty();\n         \n\t\tin.allocate(nrFiles, nrFields);\n\n\t\tin.setFileName( wFilenameList.getItems(0) );\n\t\tin.setFileMask( wFilenameList.getItems(1) );\n\n\t\tfor (int i=0;i<nrFields;i++)\n\t\t{\n\t\t    AccessInputField field = new AccessInputField();\n\t\t    \n\t\t\tTableItem item  = wFields.getNonEmpty(i);\n            \n\t\t\tfield.setName( item.getText(1) );\n\t\t\tfield.setAttribut( item.getText(2) );\n\t\t\tfield.setType( Value.getType(item.getText(3)) );\n\t\t\tfield.setFormat( item.getText(4) );\n\t\t\tfield.setLength( Const.toInt(item.getText(5), -1) );\n\t\t\tfield.setPrecision( Const.toInt(item.getText(6), -1) );\n\t\t\tfield.setCurrencySymbol( item.getText(7) );\n\t\t\tfield.setDecimalSymbol( item.getText(8) );\n\t\t\tfield.setGroupSymbol( item.getText(9) );\n\t\t\tfield.setTrimType( AccessInputField.getTrimTypeByDesc(item.getText(10)) );\n\t\t\tfield.setRepeated( Messages.getString(\"System.Combo.Yes\").equalsIgnoreCase(item.getText(11)) );\t\t\n            \n\t\t\tin.getInputFields()[i] = field;\n\t\t}\t\t \n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void preview()\n\t{\n        try\n        {\n            // Create the XML input step\n            AccessInputMeta oneMeta = new AccessInputMeta();\n            getInfo(oneMeta);\n            \n            // check if the path is given\n    \t\tif (!checkInputPositionsFilled(oneMeta)) return;\n\n            TransMeta previewMeta = TransPreviewFactory.generatePreviewTransformation(oneMeta, wStepname.getText());\n            \n            EnterNumberDialog numberDialog = new EnterNumberDialog(shell, 500, Messages.getString(\"AccessInputDialog.NumberRows.DialogTitle\"), Messages.getString(\"AccessInputDialog.NumberRows.DialogMessage\"));\n            int previewSize = numberDialog.open();\n            if (previewSize>0)\n            {\n                TransPreviewProgressDialog progressDialog = new TransPreviewProgressDialog(shell, previewMeta, new String[] { wStepname.getText() }, new int[] { previewSize } );\n                progressDialog.open();\n                \n                if (!progressDialog.isCancelled())\n                {\n                    Trans trans = progressDialog.getTrans();\n                    String loggingText = progressDialog.getLoggingText();\n                    \n                    if (trans.getResult()!=null && trans.getResult().getNrErrors()>0)\n                    {\n                    \tEnterTextDialog etd = new EnterTextDialog(shell, Messages.getString(\"System.Dialog.PreviewError.Title\"),  \n                    \t\t\tMessages.getString(\"System.Dialog.PreviewError.Message\"), loggingText, true );\n                    \tetd.setReadOnly();\n                    \tetd.open();\n                    }\n                    \n                    PreviewRowsDialog prd =new PreviewRowsDialog(shell, SWT.NONE, wStepname.getText(), progressDialog.getPreviewRows(wStepname.getText()), loggingText);\n                    prd.open();\n                }\n            }\n        }\n        catch(KettleException e)\n        {\n            new ErrorDialog(shell, Messages.getString(\"AccessInputDialog.ErrorPreviewingData.DialogTitle\"), Messages.getString(\"AccessInputDialog.ErrorPreviewingData.DialogMessage\"), e);\n       }\n\t}","id":45247,"modified_method":"private void preview()\n\t{\n        try\n        {\n            // Create the XML input step\n            AccessInputMeta oneMeta = new AccessInputMeta();\n            getInfo(oneMeta);\n            \n            // check if the path is given\n    \t\t//if (!checkInputPositionsFilled(oneMeta)) return;\n\n            TransMeta previewMeta = TransPreviewFactory.generatePreviewTransformation(oneMeta, wStepname.getText());\n            \n            EnterNumberDialog numberDialog = new EnterNumberDialog(shell, 500, Messages.getString(\"AccessInputDialog.NumberRows.DialogTitle\"), Messages.getString(\"AccessInputDialog.NumberRows.DialogMessage\"));\n            int previewSize = numberDialog.open();\n            if (previewSize>0)\n            {\n                TransPreviewProgressDialog progressDialog = new TransPreviewProgressDialog(shell, previewMeta, new String[] { wStepname.getText() }, new int[] { previewSize } );\n                progressDialog.open();\n                \n                if (!progressDialog.isCancelled())\n                {\n                    Trans trans = progressDialog.getTrans();\n                    String loggingText = progressDialog.getLoggingText();\n                    \n                    if (trans.getResult()!=null && trans.getResult().getNrErrors()>0)\n                    {\n                    \tEnterTextDialog etd = new EnterTextDialog(shell, Messages.getString(\"System.Dialog.PreviewError.Title\"),  \n                    \t\t\tMessages.getString(\"System.Dialog.PreviewError.Message\"), loggingText, true );\n                    \tetd.setReadOnly();\n                    \tetd.open();\n                    }\n                    \n                    PreviewRowsDialog prd =new PreviewRowsDialog(shell, SWT.NONE, wStepname.getText(), progressDialog.getPreviewRows(wStepname.getText()), loggingText);\n                    prd.open();\n                }\n            }\n        }\n        catch(KettleException e)\n        {\n            new ErrorDialog(shell, Messages.getString(\"AccessInputDialog.ErrorPreviewingData.DialogTitle\"), Messages.getString(\"AccessInputDialog.ErrorPreviewingData.DialogMessage\"), e);\n       }\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void get()\n\t{\n \n        try\n        {\n        \t\n\n        \t\n    \t\tAccessInputMeta meta = new AccessInputMeta();\n    \t\tgetInfo(meta);\n            \n            FileInputList inputList = meta.getFiles();\n            // Clear Fields Grid\n            wFields.removeAll();\n            \n            if (inputList.getFiles().size()>0)\n            {\n                // Open the file (only first file)...\n\n            \tDatabase d = Database.open(new File(KettleVFS.getFilename(inputList.getFile(0))));\t\t\t\n    \t\t\tTable t=d.getTable(meta.getRealTableName());\n    \t\t\t// Get the list of columns\n    \t\t\tList col = t.getColumns();\n    \t\t\tIterator iter = col.iterator();\n    \t\t\tMap row;\n    \t\t\trow = t.getNextRow();\n    \t\t\t\n    \t\t\titer = row.keySet().iterator();\n\n    \t\t\twhile (iter.hasNext()) \n    \t\t\t{\n    \t\t\t\tString fieldName = (String) iter.next();\n    \t\t\t\tObject obj = row.get(fieldName);\n    \t\t\t\t\n\t\t\t\t\t// Get attribut Name\n\t\t            TableItem item = new TableItem(wFields.table, SWT.NONE);\n\t\t            item.setText(1, fieldName);\n\t\t            item.setText(2, fieldName);\n\t\t            \n\t\t            String attributeValue=String.valueOf(obj);\n\t\t            // Try to get the Type\n\t\t            if(IsDate(attributeValue))\n            \t\t{\n            \t\t\titem.setText(3, \"Date\");\n            \t\t}\n\t\t            else if(IsInteger(attributeValue))\n            \t\t{\n            \t\t\titem.setText(3, \"Integer\");\n            \t\t}\n\t\t            else if(IsNumber(attributeValue))\n            \t\t{\n            \t\t\titem.setText(3, \"Number\");\n            \t\t}\t    \t\t          \n\t\t            else\n\t\t            {\n\t\t            \titem.setText(3, \"String\");\t    \t\t            \n\t\t            }\n    \t\t\t}    \t\t\t\t\t\n    \t\t}\n\n\n            wFields.removeEmptyRows();\n            wFields.setRowNums();\n            wFields.optWidth(true);            \n        }\n        catch(KettleException e)\n        {\n            new ErrorDialog(shell, Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogMessage\"), e);\n        }\n    \tcatch(Exception e)\n\t\t{\n    \t\t new ErrorDialog(shell, Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogMessage\"), e);\n\n\t\t}  \n\t}","id":45248,"modified_method":"private void get()\n\t{\n \n        try\n        {\n        \t\n        \t\n        \t\n    \t\tAccessInputMeta meta = new AccessInputMeta();\n    \t\tgetInfo(meta);\n    \t\t\n    \t\t// Check if a table name is specified \n    \t\tif (!checkInputTableName(meta)) return;\n            \n            FileInputList inputList = meta.getFiles();\n            // Clear Fields Grid\n            wFields.removeAll();\n            \n            if (inputList.getFiles().size()>0)\n            {\n                // Open the file (only first file)...\n\n            \tDatabase d = Database.open(new File(KettleVFS.getFilename(inputList.getFile(0))));\t\t\t\n    \t\t\tTable t=d.getTable(meta.getRealTableName());\n    \t\t\t// Get the list of columns\n    \t\t\tList col = t.getColumns();\n    \t\t\tIterator iter = col.iterator();\n    \t\t\tMap row;\n    \t\t\trow = t.getNextRow();\n    \t\t\t\n    \t\t\titer = row.keySet().iterator();\n\n    \t\t\twhile (iter.hasNext()) \n    \t\t\t{\n    \t\t\t\tString fieldName = (String) iter.next();\n    \t\t\t\tObject obj = row.get(fieldName);\n    \t\t\t\t\n\t\t\t\t\t// Get attribut Name\n\t\t            TableItem item = new TableItem(wFields.table, SWT.NONE);\n\t\t            item.setText(1, fieldName);\n\t\t            item.setText(2, fieldName);\n\t\t            \n\t\t            String attributeValue=String.valueOf(obj);\n\t\t            // Try to get the Type\n\t\t            if(IsDate(attributeValue))\n            \t\t{\n            \t\t\titem.setText(3, \"Date\");\n            \t\t}\n\t\t            else if(IsInteger(attributeValue))\n            \t\t{\n            \t\t\titem.setText(3, \"Integer\");\n            \t\t}\n\t\t            else if(IsNumber(attributeValue))\n            \t\t{\n            \t\t\titem.setText(3, \"Number\");\n            \t\t}\t    \t\t          \n\t\t            else\n\t\t            {\n\t\t            \titem.setText(3, \"String\");\t    \t\t            \n\t\t            }\n    \t\t\t}    \t\t\t\t\t\n    \t\t}\n\n\n            wFields.removeEmptyRows();\n            wFields.setRowNums();\n            wFields.optWidth(true);            \n        }\n        catch(KettleException e)\n        {\n            new ErrorDialog(shell, Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogMessage\"), e);\n        }\n    \tcatch(Exception e)\n\t\t{\n    \t\t new ErrorDialog(shell, Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"XMLInputDialog.ErrorParsingData.DialogMessage\"), e);\n\n\t\t}  \n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getTableName()\n\t{\n\n\t\tDatabase d = null;\n\t\t\n\t\ttry\n\t\t{\n\t\t\t\n\t\t\tAccessInputMeta meta = new AccessInputMeta();\n\t\t\tgetInfo(meta);\n\t\t\t\n\n\t\t    FileInputList inputList = meta.getFiles();\n\t\t    \n\t\t\n\t\t\t // Open the file (only first file)...\n\t\t\n\t\t\td = Database.open(new File(KettleVFS.getFilename(inputList.getFile(0))));\t\n\t\t\t\n\t\t\t if (!inputList.getFile(0).exists())\n\t            {\n\t                throw new KettleException(Messages.getString(\"AccessInputMeta.Exception.FileDoesNotExist\", KettleVFS.getFilename(inputList.getFile(0))));\n\t            }\n\t\t\n\t\t\tSet set= d.getTableNames();\n\t\t\tString[] tablenames =  (String[]) set.toArray(new String[set.size()])  ;\n\n\t\t\t\n\t\t\tEnterSelectionDialog dialog = new EnterSelectionDialog(shell, tablenames, Messages.getString(\"AccessInputDialog.Dialog.SelectATable.Title\"), Messages.getString(\"AccessInputDialog.Dialog.SelectATable.Message\"));\n\t\t    String tablename = dialog.open();\n\t\t    if (tablename!=null)\n\t\t    {\n\t\t        wTable.setText(tablename);\n\t\t    }\n\t\t}\n\t\t catch(Throwable e)\n\t        {\n\t            new ErrorDialog(shell, Messages.getString(\"AccessInputDialog.UnableToGetListOfTables.Title\"), Messages.getString(\"AccessInputDialog.UnableToGetListOfTables.Message\"), new Exception(e));\n\t        }\n\t        finally\n\t        {\n\t            // Don't forget to close the bugger.\n\t            try\n\t            {\n\t                if (d!=null) d.close();\n\t            }\n\t            catch(Exception e)\n\t            {\n\t                \n\t            }\n\t        }\n\t\t\t\t\n\t\t         \n\t}","id":45249,"modified_method":"private void getTableName()\n\t{\n\n\t\tDatabase d = null;\n\t\t\n\t\ttry\n\t\t{\n\t\t\t\n\t\t\tAccessInputMeta meta = new AccessInputMeta();\n\t\t\tgetInfo(meta);\n\t\t\t\n\t\t\tif (!checkInputFilesName(meta)) return;\n\n\t\t    FileInputList inputList = meta.getFiles();\n\t\t    \n\t\t\n\t\t\t // Open the file (only first file)...\n\t\t\n\t\t\td = Database.open(new File(KettleVFS.getFilename(inputList.getFile(0))));\t\n\t\t\t\n\t\t\t if (!inputList.getFile(0).exists())\n\t            {\n\t                throw new KettleException(Messages.getString(\"AccessInputMeta.Exception.FileDoesNotExist\", KettleVFS.getFilename(inputList.getFile(0))));\n\t            }\n\t\t\n\t\t\tSet set= d.getTableNames();\n\t\t\tString[] tablenames =  (String[]) set.toArray(new String[set.size()])  ;\n\n\t\t\t\n\t\t\tEnterSelectionDialog dialog = new EnterSelectionDialog(shell, tablenames, Messages.getString(\"AccessInputDialog.Dialog.SelectATable.Title\"), Messages.getString(\"AccessInputDialog.Dialog.SelectATable.Message\"));\n\t\t    String tablename = dialog.open();\n\t\t    if (tablename!=null)\n\t\t    {\n\t\t        wTable.setText(tablename);\n\t\t    }\n\t\t}\n\t\t catch(Throwable e)\n\t        {\n\t            new ErrorDialog(shell, Messages.getString(\"AccessInputDialog.UnableToGetListOfTables.Title\"), Messages.getString(\"AccessInputDialog.UnableToGetListOfTables.Message\"), new Exception(e));\n\t        }\n\t        finally\n\t        {\n\t            // Don't forget to close the bugger.\n\t            try\n\t            {\n\t                if (d!=null) d.close();\n\t            }\n\t            catch(Exception e)\n\t            {\n\t                \n\t            }\n\t        }\n\t\t\t\t\n\t\t         \n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\t\t\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"AccessInputDialog.DialogTitle\"));\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\n\n\t\t//////////////////////////\n\t\t// START OF FILE TAB   ///\n\t\t//////////////////////////\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twFileTab.setText(Messages.getString(\"AccessInputDialog.File.Tab\"));\n\t\t\n\t\twFileComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wFileComp);\n\n\t\tFormLayout fileLayout = new FormLayout();\n\t\tfileLayout.marginWidth  = 3;\n\t\tfileLayout.marginHeight = 3;\n\t\twFileComp.setLayout(fileLayout);\n\n\t\t// Filename line\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"AccessInputDialog.Filename.Label\"));\n \t\tprops.setLook(wlFilename);\n\t\tfdlFilename=new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top  = new FormAttachment(0, 0);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbbFilename);\n\t\twbbFilename.setText(Messages.getString(\"AccessInputDialog.FilenameBrowse.Button\"));\n\t\twbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t\tfdbFilename=new FormData();\n\t\tfdbFilename.right= new FormAttachment(100, 0);\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\n\t\twbbFilename.setLayoutData(fdbFilename);\n\n\t\twbaFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbaFilename);\n\t\twbaFilename.setText(Messages.getString(\"AccessInputDialog.FilenameAdd.Button\"));\n\t\twbaFilename.setToolTipText(Messages.getString(\"AccessInputDialog.FilenameAdd.Tooltip\"));\n\t\tfdbaFilename=new FormData();\n\t\tfdbaFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\tfdbaFilename.top  = new FormAttachment(0, 0);\n\t\twbaFilename.setLayoutData(fdbaFilename);\n\n\t\twFilename=new TextVar(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename=new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.right= new FormAttachment(wbaFilename, -margin);\n\t\tfdFilename.top  = new FormAttachment(0, 0);\n\t\twFilename.setLayoutData(fdFilename);\n\n\t\twlFilemask=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilemask.setText(Messages.getString(\"AccessInputDialog.RegExp.Label\"));\n \t\tprops.setLook(wlFilemask);\n\t\tfdlFilemask=new FormData();\n\t\tfdlFilemask.left = new FormAttachment(0, 0);\n\t\tfdlFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdlFilemask.right= new FormAttachment(middle, -margin);\n\t\twlFilemask.setLayoutData(fdlFilemask);\n\t\twFilemask=new TextVar(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilemask);\n\t\twFilemask.addModifyListener(lsMod);\n\t\tfdFilemask=new FormData();\n\t\tfdFilemask.left = new FormAttachment(middle, 0);\n\t\tfdFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdFilemask.right= new FormAttachment(100, 0);\n\t\twFilemask.setLayoutData(fdFilemask);\n\n\t\t// Filename list line\n\t\twlFilenameList=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilenameList.setText(Messages.getString(\"AccessInputDialog.FilenameList.Label\"));\n \t\tprops.setLook(wlFilenameList);\n\t\tfdlFilenameList=new FormData();\n\t\tfdlFilenameList.left = new FormAttachment(0, 0);\n\t\tfdlFilenameList.top  = new FormAttachment(wFilemask, margin);\n\t\tfdlFilenameList.right= new FormAttachment(middle, -margin);\n\t\twlFilenameList.setLayoutData(fdlFilenameList);\n\n\t\t// Buttons to the right of the screen...\n\t\twbdFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbdFilename);\n\t\twbdFilename.setText(Messages.getString(\"AccessInputDialog.FilenameRemove.Button\"));\n\t\twbdFilename.setToolTipText(Messages.getString(\"AccessInputDialog.FilenameRemove.Tooltip\"));\n\t\tfdbdFilename=new FormData();\n\t\tfdbdFilename.right = new FormAttachment(100, 0);\n\t\tfdbdFilename.top  = new FormAttachment (wFilemask, 40);\n\t\twbdFilename.setLayoutData(fdbdFilename);\n\n\t\twbeFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbeFilename);\n\t\twbeFilename.setText(Messages.getString(\"AccessInputDialog.FilenameEdit.Button\"));\n\t\twbeFilename.setToolTipText(Messages.getString(\"AccessInputDialog.FilenameEdit.Tooltip\"));\n\t\tfdbeFilename=new FormData();\n\t\tfdbeFilename.right = new FormAttachment(100, 0);\n\t\tfdbeFilename.top  = new FormAttachment (wbdFilename, margin);\n\t\twbeFilename.setLayoutData(fdbeFilename);\n\t\t\n\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbShowFiles);\n\t\twbShowFiles.setText(Messages.getString(\"AccessInputDialog.ShowFiles.Button\"));\n\t\tfdbShowFiles=new FormData();\n\t\tfdbShowFiles.left   = new FormAttachment(middle, 0);\n\t\tfdbShowFiles.bottom = new FormAttachment(100, 0);\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\n\n\t\tColumnInfo[] colinfo=new ColumnInfo[2];\n\t\tcolinfo[ 0]=new ColumnInfo(\n          Messages.getString(\"AccessInputDialog.Files.Filename.Column\"),\n          ColumnInfo.COLUMN_TYPE_TEXT,\n          false);\n\t\tcolinfo[ 1]=new ColumnInfo(\n          Messages.getString(\"AccessInputDialog.Files.Wildcard.Column\"),\n          ColumnInfo.COLUMN_TYPE_TEXT,\n          false);\n\t\t\n\t\tcolinfo[0].setUsingVariables(true);\n\t\tcolinfo[1].setUsingVariables(true);\n\t\tcolinfo[1].setToolTip(Messages.getString(\"AccessInputDialog.Files.Wildcard.Tooltip\"));\n\t\t\t\t\n\t\twFilenameList = new TableView(wFileComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.SINGLE | SWT.BORDER, \n\t\t\t\t\t\t      colinfo, \n\t\t\t\t\t\t      2,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n \t\tprops.setLook(wFilenameList);\n\n \t\n \t\t\n\t\tfdFilenameList=new FormData();\n\t\tfdFilenameList.left   = new FormAttachment(middle, 0);\n\t\tfdFilenameList.right  = new FormAttachment(wbdFilename, -margin);\n\t\tfdFilenameList.top    = new FormAttachment(wFilemask, margin);\n\t\tfdFilenameList.bottom = new FormAttachment(wbShowFiles, -margin);\n\t\twFilenameList.setLayoutData(fdFilenameList);\n\t\t\n\t\n\t\tfdFileComp=new FormData();\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\n\t\tfdFileComp.right = new FormAttachment(100, 0);\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\n\t\twFileComp.setLayoutData(fdFileComp);\n\t\n\t\twFileComp.layout();\n\t\twFileTab.setControl(wFileComp);\n\t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF FILE TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t//////////////////////////\n\t\t// START OF CONTENT TAB///\n\t\t///\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twContentTab.setText(Messages.getString(\"AccessInputDialog.Content.Tab\"));\n\n\t\tFormLayout contentLayout = new FormLayout ();\n\t\tcontentLayout.marginWidth  = 3;\n\t\tcontentLayout.marginHeight = 3;\n\t\t\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wContentComp);\n\t\twContentComp.setLayout(contentLayout);\n\t\t\n\t\t\n\t\twlTable=new Label(wContentComp, SWT.RIGHT);\n        wlTable.setText(Messages.getString(\"AccessInputDialog.Table.Label\"));\n        props.setLook(wlTable);\n        fdlTable=new FormData();\n        fdlTable.left = new FormAttachment(0, 0);\n        fdlTable.top  = new FormAttachment(0, margin);\n        fdlTable.right= new FormAttachment(middle, -margin);\n        wlTable.setLayoutData(fdlTable);\n        wTable=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wTable.setToolTipText(Messages.getString(\"AccessInputDialog.Table.Tooltip\"));\n        props.setLook(wTable);\n        wTable.addModifyListener(lsMod);\n        fdTable=new FormData();\n        fdTable.left = new FormAttachment(middle, 0);\n        fdTable.top  = new FormAttachment(0, margin);\n        fdTable.right= new FormAttachment(100, -70);\n        wTable.setLayoutData(fdTable);\n        \n        \n\t\twbbTablename=new Button(wContentComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbbTablename);\n \t\twbbTablename.setText(Messages.getString(\"AccessInputDialog.FilenameBrowse.Button\"));\n \t\twbbTablename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t\tfdbTablename=new FormData();\n\t\tfdbTablename.right= new FormAttachment(100, 0);\n\t\tfdbTablename.top  = new FormAttachment(0, 0);\n\t\twbbTablename.setLayoutData(fdbTablename);\n\n\t\twbbTablename.addSelectionListener( new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { getTableName(); } } );\n\n\t\t\n\n\t\twlInclFilename=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclFilename.setText(Messages.getString(\"AccessInputDialog.InclFilename.Label\"));\n \t\tprops.setLook(wlInclFilename);\n\t\tfdlInclFilename=new FormData();\n\t\tfdlInclFilename.left = new FormAttachment(0, 0);\n\t\tfdlInclFilename.top  = new FormAttachment(wTable, 2*margin);\n\t\tfdlInclFilename.right= new FormAttachment(middle, -margin);\n\t\twlInclFilename.setLayoutData(fdlInclFilename);\n\t\twInclFilename=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wInclFilename);\n\t\twInclFilename.setToolTipText(Messages.getString(\"AccessInputDialog.InclFilename.Tooltip\"));\n\t\tfdInclFilename=new FormData();\n\t\tfdInclFilename.left = new FormAttachment(middle, 0);\n\t\tfdInclFilename.top  = new FormAttachment(wTable, 2*margin);\n\t\twInclFilename.setLayoutData(fdInclFilename);\n\n\t\twlInclFilenameField=new Label(wContentComp, SWT.LEFT);\n\t\twlInclFilenameField.setText(Messages.getString(\"AccessInputDialog.InclFilenameField.Label\"));\n \t\tprops.setLook(wlInclFilenameField);\n\t\tfdlInclFilenameField=new FormData();\n\t\tfdlInclFilenameField.left = new FormAttachment(wInclFilename, margin);\n\t\tfdlInclFilenameField.top  = new FormAttachment(wTable, 2*margin);\n\t\twlInclFilenameField.setLayoutData(fdlInclFilenameField);\n\t\twInclFilenameField=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclFilenameField);\n\t\twInclFilenameField.addModifyListener(lsMod);\n\t\tfdInclFilenameField=new FormData();\n\t\tfdInclFilenameField.left = new FormAttachment(wlInclFilenameField, margin);\n\t\tfdInclFilenameField.top  = new FormAttachment(wTable, 2*margin);\n\t\tfdInclFilenameField.right= new FormAttachment(100, 0);\n\t\twInclFilenameField.setLayoutData(fdInclFilenameField);\n\n\t\twlInclRownum=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclRownum.setText(Messages.getString(\"AccessInputDialog.InclRownum.Label\"));\n \t\tprops.setLook(wlInclRownum);\n\t\tfdlInclRownum=new FormData();\n\t\tfdlInclRownum.left = new FormAttachment(0, 0);\n\t\tfdlInclRownum.top  = new FormAttachment(wInclFilenameField, margin);\n\t\tfdlInclRownum.right= new FormAttachment(middle, -margin);\n\t\twlInclRownum.setLayoutData(fdlInclRownum);\n\t\twInclRownum=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wInclRownum);\n\t\twInclRownum.setToolTipText(Messages.getString(\"AccessInputDialog.InclRownum.Tooltip\"));\n\t\tfdRownum=new FormData();\n\t\tfdRownum.left = new FormAttachment(middle, 0);\n\t\tfdRownum.top  = new FormAttachment(wInclFilenameField, margin);\n\t\twInclRownum.setLayoutData(fdRownum);\n\n\t\twlInclRownumField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclRownumField.setText(Messages.getString(\"AccessInputDialog.InclRownumField.Label\"));\n \t\tprops.setLook(wlInclRownumField);\n\t\tfdlInclRownumField=new FormData();\n\t\tfdlInclRownumField.left = new FormAttachment(wInclRownum, margin);\n\t\tfdlInclRownumField.top  = new FormAttachment(wInclFilenameField, margin);\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\n\t\twInclRownumField=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclRownumField);\n\t\twInclRownumField.addModifyListener(lsMod);\n\t\tfdInclRownumField=new FormData();\n\t\tfdInclRownumField.left = new FormAttachment(wlInclRownumField, margin);\n\t\tfdInclRownumField.top  = new FormAttachment(wInclFilenameField, margin);\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\n\n\t\twlLimit=new Label(wContentComp, SWT.RIGHT);\n\t\twlLimit.setText(Messages.getString(\"AccessInputDialog.Limit.Label\"));\n \t\tprops.setLook(wlLimit);\n\t\tfdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tfdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\twLimit.setLayoutData(fdLimit);\n       \n\t\tfdContentComp = new FormData();\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\n\t\tfdContentComp.right = new FormAttachment(100, 0);\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\n\t\twContentComp.setLayoutData(fdContentComp);\n\n\t\twContentComp.layout();\n\t\twContentTab.setControl(wContentComp);\n\n\t\t// ///////////////////////////////////////////////////////////\n\t\t// / END OF CONTENT TAB\n\t\t// ///////////////////////////////////////////////////////////\n\n\n\t\t// Fields tab...\n\t\t//\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\n\t\twFieldsTab.setText(Messages.getString(\"AccessInputDialog.Fields.Tab\"));\n\t\t\n\t\tFormLayout fieldsLayout = new FormLayout ();\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\n\t\t\n\t\twFieldsComp = new Composite(wTabFolder, SWT.NONE);\n\t\twFieldsComp.setLayout(fieldsLayout);\n \t\tprops.setLook(wFieldsComp);\n\t\t\n \t\twGet=new Button(wFieldsComp, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"AccessInputDialog.GetFields.Button\"));\n\t\tfdGet=new FormData();\n\t\tfdGet.left=new FormAttachment(50, 0);\n\t\tfdGet.bottom =new FormAttachment(100, 0);\n\t\twGet.setLayoutData(fdGet);\n\t\t\n\t\tfinal int FieldsRows=input.getInputFields().length;\n\t\t\n\t\t// Prepare a list of possible formats...\n\t\tString dats[] = Const.getDateFormats();\n\t\tString nums[] = Const.getNumberFormats();\n\t\tint totsize = dats.length + nums.length;\n\t\tString formats[] = new String[totsize];\n\t\tfor (int x=0;x<dats.length;x++) formats[x] = dats[x];\n\t\tfor (int x=0;x<nums.length;x++) formats[dats.length+x] = nums[x];\n\t\t\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[]\n            {\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Name.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n         new ColumnInfo(\n                 Messages.getString(\"AccessInputDialog.FieldsTable.Attribut.Column\"),\n                 ColumnInfo.COLUMN_TYPE_TEXT,\n                 false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Type.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         Value.getTypes(),\n         true ),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Format.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         formats),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Length.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Precision.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Currency.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Decimal.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Group.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.TrimType.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         AccessInputField.trimTypeDesc,\n         true ),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Repeat.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         new String[] { Messages.getString(\"System.Combo.Yes\"), Messages.getString(\"System.Combo.No\") },\n         true ),\n     \n    };\n\t\t\n\t\tcolinf[0].setUsingVariables(true);\n\t\tcolinf[0].setToolTip(Messages.getString(\"AccessInputDialog.FieldsTable.Name.Column.Tooltip\"));\n\t\tcolinf[1].setUsingVariables(true);\n\t\tcolinf[1].setToolTip(Messages.getString(\"AccessInputDialog.FieldsTable.Attribut.Column.Tooltip\"));\n\t\t\n\t\twFields=new TableView(wFieldsComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t      colinf, \n\t\t\t\t\t\t      FieldsRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left  = new FormAttachment(0, 0);\n\t\tfdFields.top   = new FormAttachment(0, 0);\n\t\tfdFields.right = new FormAttachment(100, 0);\n\t\tfdFields.bottom= new FormAttachment(wGet, -margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\tfdFieldsComp=new FormData();\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\n\t\t\n\t\twFieldsComp.layout();\n\t\twFieldsTab.setControl(wFieldsComp);\n\t\t\n\t\tfdTabFolder = new FormData();\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\n\t\twTabFolder.setLayoutData(fdTabFolder);\n\t\t\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"AccessInputDialog.Button.PreviewRows\"));\n\t\t\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview();   } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();     } };\n\t\t\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twGet.addListener    (SWT.Selection, lsGet    );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twLimit.addSelectionListener( lsDef );\n\t\twInclRownumField.addSelectionListener( lsDef );\n\t\twInclFilenameField.addSelectionListener( lsDef );\n\n\t\t// Add the file to the list of files...\n\t\tSelectionAdapter selA = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { wFilename.getText(), wFilemask.getText() } );\n\t\t\t\twFilename.setText(\"\");\n\t\t\t\twFilemask.setText(\"\");\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n                wFilenameList.optWidth(true);\n\t\t\t}\n\t\t};\n\t\twbaFilename.addSelectionListener(selA);\n\t\twFilename.addSelectionListener(selA);\n\t\t\n\t\t// Delete files from the list of files...\n\t\twbdFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx[] = wFilenameList.getSelectionIndices();\n\t\t\t\twFilenameList.remove(idx);\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Edit the selected file & remove from the list...\n\t\twbeFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx = wFilenameList.getSelectionIndex();\n\t\t\t\tif (idx>=0)\n\t\t\t\t{\n\t\t\t\t\tString string[] = wFilenameList.getItem(idx);\n\t\t\t\t\twFilename.setText(string[0]);\n\t\t\t\t\twFilemask.setText(string[1]);\n\t\t\t\t\twFilenameList.remove(idx);\n\t\t\t\t}\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Show the files that are selected at this time...\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n                    try\n                    {\n    \t\t\t\t\tAccessInputMeta tfii = new AccessInputMeta();\n    \t\t\t\t\tgetInfo(tfii);\n                        FileInputList fileInputList = tfii.getFiles();\n    \t\t\t\t\tString files[] = fileInputList.getFileStrings();\n    \t\t\t\t\tif (files!=null && files.length>0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, Messages.getString(\"AccessInputDialog.FilesReadSelection.DialogTitle\"), Messages.getString(\"AccessInputDialog.FilesReadSelection.DialogMessage\"));\n    \t\t\t\t\t\tesd.setViewOnly();\n    \t\t\t\t\t\tesd.open();\n    \t\t\t\t\t}\n    \t\t\t\t\telse\n    \t\t\t\t\t{\n    \t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n    \t\t\t\t\t\tmb.setMessage(Messages.getString(\"AccessInputDialog.NoFileFound.DialogMessage\"));\n    \t\t\t\t\t\tmb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\n    \t\t\t\t\t\tmb.open(); \n    \t\t\t\t\t}\n                    }\n                    catch(KettleException ex)\n                    {\n                        new ErrorDialog(shell, Messages.getString(\"AccessInputDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"AccessInputDialog.ErrorParsingData.DialogMessage\"), ex);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// Enable/disable the right fields to allow a filename to be added to each row...\n\t\twInclFilename.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tsetIncludeFilename();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Enable/disable the right fields to allow a row number to be added to each row...\n\t\twInclRownum.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tsetIncludeRownum();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version of the filename:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename.setToolTipText(StringUtil.environmentSubstitute( wFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t\n\t\t\n\t\t// Listen to the Browse... button\n\t\twbbFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tif (wFilemask.getText()!=null && wFilemask.getText().length()>0) // A mask: a directory!\n\t\t\t\t\t{\n\t\t\t\t\t\tDirectoryDialog dialog = new DirectoryDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fpath = StringUtil.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFilterPath( fpath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str= dialog.getFilterPath();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*mdb;*.MDB\", \"*\"});\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fname = StringUtil.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"AccessInputDialog.FileType.AccessFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twTabFolder.setSelection(0);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\tgetData(input);\n\t\tinput.setChanged(changed);\n\t\twFields.optWidth(true);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":45250,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\t\t\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"AccessInputDialog.DialogTitle\"));\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\n\n\t\t//////////////////////////\n\t\t// START OF FILE TAB   ///\n\t\t//////////////////////////\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twFileTab.setText(Messages.getString(\"AccessInputDialog.File.Tab\"));\n\t\t\n\t\twFileComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wFileComp);\n\n\t\tFormLayout fileLayout = new FormLayout();\n\t\tfileLayout.marginWidth  = 3;\n\t\tfileLayout.marginHeight = 3;\n\t\twFileComp.setLayout(fileLayout);\n\n\t\t// Filename line\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"AccessInputDialog.Filename.Label\"));\n \t\tprops.setLook(wlFilename);\n\t\tfdlFilename=new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top  = new FormAttachment(0, 0);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbbFilename);\n\t\twbbFilename.setText(Messages.getString(\"AccessInputDialog.FilenameBrowse.Button\"));\n\t\twbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t\tfdbFilename=new FormData();\n\t\tfdbFilename.right= new FormAttachment(100, 0);\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\n\t\twbbFilename.setLayoutData(fdbFilename);\n\n\t\twbaFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbaFilename);\n\t\twbaFilename.setText(Messages.getString(\"AccessInputDialog.FilenameAdd.Button\"));\n\t\twbaFilename.setToolTipText(Messages.getString(\"AccessInputDialog.FilenameAdd.Tooltip\"));\n\t\tfdbaFilename=new FormData();\n\t\tfdbaFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\tfdbaFilename.top  = new FormAttachment(0, 0);\n\t\twbaFilename.setLayoutData(fdbaFilename);\n\n\t\twFilename=new TextVar(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename=new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.right= new FormAttachment(wbaFilename, -margin);\n\t\tfdFilename.top  = new FormAttachment(0, 0);\n\t\twFilename.setLayoutData(fdFilename);\n\n\t\twlFilemask=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilemask.setText(Messages.getString(\"AccessInputDialog.RegExp.Label\"));\n \t\tprops.setLook(wlFilemask);\n\t\tfdlFilemask=new FormData();\n\t\tfdlFilemask.left = new FormAttachment(0, 0);\n\t\tfdlFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdlFilemask.right= new FormAttachment(middle, -margin);\n\t\twlFilemask.setLayoutData(fdlFilemask);\n\t\twFilemask=new TextVar(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilemask);\n\t\twFilemask.addModifyListener(lsMod);\n\t\tfdFilemask=new FormData();\n\t\tfdFilemask.left = new FormAttachment(middle, 0);\n\t\tfdFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdFilemask.right= new FormAttachment(100, 0);\n\t\twFilemask.setLayoutData(fdFilemask);\n\n\t\t// Filename list line\n\t\twlFilenameList=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilenameList.setText(Messages.getString(\"AccessInputDialog.FilenameList.Label\"));\n \t\tprops.setLook(wlFilenameList);\n\t\tfdlFilenameList=new FormData();\n\t\tfdlFilenameList.left = new FormAttachment(0, 0);\n\t\tfdlFilenameList.top  = new FormAttachment(wFilemask, margin);\n\t\tfdlFilenameList.right= new FormAttachment(middle, -margin);\n\t\twlFilenameList.setLayoutData(fdlFilenameList);\n\n\t\t// Buttons to the right of the screen...\n\t\twbdFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbdFilename);\n\t\twbdFilename.setText(Messages.getString(\"AccessInputDialog.FilenameRemove.Button\"));\n\t\twbdFilename.setToolTipText(Messages.getString(\"AccessInputDialog.FilenameRemove.Tooltip\"));\n\t\tfdbdFilename=new FormData();\n\t\tfdbdFilename.right = new FormAttachment(100, 0);\n\t\tfdbdFilename.top  = new FormAttachment (wFilemask, 40);\n\t\twbdFilename.setLayoutData(fdbdFilename);\n\n\t\twbeFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbeFilename);\n\t\twbeFilename.setText(Messages.getString(\"AccessInputDialog.FilenameEdit.Button\"));\n\t\twbeFilename.setToolTipText(Messages.getString(\"AccessInputDialog.FilenameEdit.Tooltip\"));\n\t\tfdbeFilename=new FormData();\n\t\tfdbeFilename.right = new FormAttachment(100, 0);\n\t\tfdbeFilename.top  = new FormAttachment (wbdFilename, margin);\n\t\twbeFilename.setLayoutData(fdbeFilename);\n\t\t\n\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbShowFiles);\n\t\twbShowFiles.setText(Messages.getString(\"AccessInputDialog.ShowFiles.Button\"));\n\t\tfdbShowFiles=new FormData();\n\t\tfdbShowFiles.left   = new FormAttachment(middle, 0);\n\t\tfdbShowFiles.bottom = new FormAttachment(100, 0);\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\n\n\t\tColumnInfo[] colinfo=new ColumnInfo[2];\n\t\tcolinfo[ 0]=new ColumnInfo(\n          Messages.getString(\"AccessInputDialog.Files.Filename.Column\"),\n          ColumnInfo.COLUMN_TYPE_TEXT,\n          false);\n\t\tcolinfo[ 1]=new ColumnInfo(\n          Messages.getString(\"AccessInputDialog.Files.Wildcard.Column\"),\n          ColumnInfo.COLUMN_TYPE_TEXT,\n          false);\n\t\t\n\t\tcolinfo[0].setUsingVariables(true);\n\t\tcolinfo[1].setUsingVariables(true);\n\t\tcolinfo[1].setToolTip(Messages.getString(\"AccessInputDialog.Files.Wildcard.Tooltip\"));\n\t\t\t\t\n\t\twFilenameList = new TableView(wFileComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.SINGLE | SWT.BORDER, \n\t\t\t\t\t\t      colinfo, \n\t\t\t\t\t\t      2,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n \t\tprops.setLook(wFilenameList);\n\n \t\n \t\t\n\t\tfdFilenameList=new FormData();\n\t\tfdFilenameList.left   = new FormAttachment(middle, 0);\n\t\tfdFilenameList.right  = new FormAttachment(wbdFilename, -margin);\n\t\tfdFilenameList.top    = new FormAttachment(wFilemask, margin);\n\t\tfdFilenameList.bottom = new FormAttachment(wbShowFiles, -margin);\n\t\twFilenameList.setLayoutData(fdFilenameList);\n\t\t\n\t\n\t\tfdFileComp=new FormData();\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\n\t\tfdFileComp.right = new FormAttachment(100, 0);\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\n\t\twFileComp.setLayoutData(fdFileComp);\n\t\n\t\twFileComp.layout();\n\t\twFileTab.setControl(wFileComp);\n\t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF FILE TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t//////////////////////////\n\t\t// START OF CONTENT TAB///\n\t\t///\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twContentTab.setText(Messages.getString(\"AccessInputDialog.Content.Tab\"));\n\n\t\tFormLayout contentLayout = new FormLayout ();\n\t\tcontentLayout.marginWidth  = 3;\n\t\tcontentLayout.marginHeight = 3;\n\t\t\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wContentComp);\n\t\twContentComp.setLayout(contentLayout);\n\t\t\n\t\t\n\t\twlTable=new Label(wContentComp, SWT.RIGHT);\n        wlTable.setText(Messages.getString(\"AccessInputDialog.Table.Label\"));\n        props.setLook(wlTable);\n        fdlTable=new FormData();\n        fdlTable.left = new FormAttachment(0, 0);\n        fdlTable.top  = new FormAttachment(0, margin);\n        fdlTable.right= new FormAttachment(middle, -margin);\n        wlTable.setLayoutData(fdlTable);\n        wTable=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wTable.setToolTipText(Messages.getString(\"AccessInputDialog.Table.Tooltip\"));\n        props.setLook(wTable);\n        wTable.addModifyListener(lsMod);\n        fdTable=new FormData();\n        fdTable.left = new FormAttachment(middle, 0);\n        fdTable.top  = new FormAttachment(0, margin);\n        fdTable.right= new FormAttachment(100, -70);\n        wTable.setLayoutData(fdTable);\n        \n        \n\t\twbbTablename=new Button(wContentComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbbTablename);\n \t\twbbTablename.setText(Messages.getString(\"AccessInputDialog.FilenameBrowse.Button\"));\n \t\twbbTablename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t\tfdbTablename=new FormData();\n\t\tfdbTablename.right= new FormAttachment(100, 0);\n\t\tfdbTablename.top  = new FormAttachment(0, 0);\n\t\twbbTablename.setLayoutData(fdbTablename);\n\n\t\twbbTablename.addSelectionListener( new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { getTableName(); } } );\n\n\t\t\n\n\t\twlInclFilename=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclFilename.setText(Messages.getString(\"AccessInputDialog.InclFilename.Label\"));\n \t\tprops.setLook(wlInclFilename);\n\t\tfdlInclFilename=new FormData();\n\t\tfdlInclFilename.left = new FormAttachment(0, 0);\n\t\tfdlInclFilename.top  = new FormAttachment(wTable, 2*margin);\n\t\tfdlInclFilename.right= new FormAttachment(middle, -margin);\n\t\twlInclFilename.setLayoutData(fdlInclFilename);\n\t\twInclFilename=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wInclFilename);\n\t\twInclFilename.setToolTipText(Messages.getString(\"AccessInputDialog.InclFilename.Tooltip\"));\n\t\tfdInclFilename=new FormData();\n\t\tfdInclFilename.left = new FormAttachment(middle, 0);\n\t\tfdInclFilename.top  = new FormAttachment(wTable, 2*margin);\n\t\twInclFilename.setLayoutData(fdInclFilename);\n\n\t\twlInclFilenameField=new Label(wContentComp, SWT.LEFT);\n\t\twlInclFilenameField.setText(Messages.getString(\"AccessInputDialog.InclFilenameField.Label\"));\n \t\tprops.setLook(wlInclFilenameField);\n\t\tfdlInclFilenameField=new FormData();\n\t\tfdlInclFilenameField.left = new FormAttachment(wInclFilename, margin);\n\t\tfdlInclFilenameField.top  = new FormAttachment(wTable, 2*margin);\n\t\twlInclFilenameField.setLayoutData(fdlInclFilenameField);\n\t\twInclFilenameField=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclFilenameField);\n\t\twInclFilenameField.addModifyListener(lsMod);\n\t\tfdInclFilenameField=new FormData();\n\t\tfdInclFilenameField.left = new FormAttachment(wlInclFilenameField , margin);\n\t\tfdInclFilenameField.top  = new FormAttachment(wTable, 2*margin);\n\t\tfdInclFilenameField.right= new FormAttachment(100, 0);\n\t\twInclFilenameField.setLayoutData(fdInclFilenameField);\n\n\t\twlInclTablename=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclTablename.setText(Messages.getString(\"AccessInputDialog.InclTablename.Label\"));\n \t\tprops.setLook(wlInclTablename);\n\t\tfdlInclTablename=new FormData();\n\t\tfdlInclTablename.left = new FormAttachment(0, 0);\n\t\tfdlInclTablename.top  = new FormAttachment(wInclFilenameField, margin);\n\t\tfdlInclTablename.right= new FormAttachment(middle, -margin);\n\t\twlInclTablename.setLayoutData(fdlInclTablename);\n\t\twInclTablename=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wInclTablename);\n\t\twInclTablename.setToolTipText(Messages.getString(\"AccessInputDialog.InclTablename.Tooltip\"));\n\t\tfdInclTablename=new FormData();\n\t\tfdInclTablename.left = new FormAttachment(middle, 0);\n\t\tfdInclTablename.top  = new FormAttachment(wInclFilenameField, margin);\n\t\twInclTablename.setLayoutData(fdInclTablename);\n\t\t\n\t\t\n\t\twlInclTablenameField=new Label(wContentComp, SWT.LEFT);\n\t\twlInclTablenameField.setText(Messages.getString(\"AccessInputDialog.InclTablenameField.Label\"));\n \t\tprops.setLook(wlInclTablenameField);\n\t\tfdlInclTablenameField=new FormData();\n\t\tfdlInclTablenameField.left = new FormAttachment(wInclFilename, margin);\n\t\tfdlInclTablenameField.top  = new FormAttachment(wInclFilenameField, margin);\n\t\twlInclTablenameField.setLayoutData(fdlInclTablenameField);\n\t\twInclTablenameField=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclTablenameField);\n\t\twInclTablenameField.addModifyListener(lsMod);\n\t\tfdInclTablenameField=new FormData();\n\t\tfdInclTablenameField.left = new FormAttachment(wlInclTablenameField, margin);\n\t\tfdInclTablenameField.top  = new FormAttachment(wInclFilenameField, margin);\n\t\tfdInclTablenameField.right= new FormAttachment(100, 0);\n\t\twInclTablenameField.setLayoutData(fdInclTablenameField);\n\n\t\n\t\t\n\t\twlInclRownum=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclRownum.setText(Messages.getString(\"AccessInputDialog.InclRownum.Label\"));\n \t\tprops.setLook(wlInclRownum);\n\t\tfdlInclRownum=new FormData();\n\t\tfdlInclRownum.left = new FormAttachment(0, 0);\n\t\tfdlInclRownum.top  = new FormAttachment(wInclTablenameField, margin);\n\t\tfdlInclRownum.right= new FormAttachment(middle, -margin);\n\t\twlInclRownum.setLayoutData(fdlInclRownum);\n\t\twInclRownum=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wInclRownum);\n\t\twInclRownum.setToolTipText(Messages.getString(\"AccessInputDialog.InclRownum.Tooltip\"));\n\t\tfdRownum=new FormData();\n\t\tfdRownum.left = new FormAttachment(middle, 0);\n\t\tfdRownum.top  = new FormAttachment(wInclTablenameField, margin);\n\t\twInclRownum.setLayoutData(fdRownum);\n\n\t\twlInclRownumField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclRownumField.setText(Messages.getString(\"AccessInputDialog.InclRownumField.Label\"));\n \t\tprops.setLook(wlInclRownumField);\n\t\tfdlInclRownumField=new FormData();\n\t\tfdlInclRownumField.left = new FormAttachment(wInclRownum, margin);\n\t\tfdlInclRownumField.top  = new FormAttachment(wInclTablenameField, margin);\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\n\t\twInclRownumField=new TextVar(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclRownumField);\n\t\twInclRownumField.addModifyListener(lsMod);\n\t\tfdInclRownumField=new FormData();\n\t\tfdInclRownumField.left = new FormAttachment(wlInclRownumField, margin);\n\t\tfdInclRownumField.top  = new FormAttachment(wInclTablenameField, margin);\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\n\n\t\twlLimit=new Label(wContentComp, SWT.RIGHT);\n\t\twlLimit.setText(Messages.getString(\"AccessInputDialog.Limit.Label\"));\n \t\tprops.setLook(wlLimit);\n\t\tfdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tfdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\twLimit.setLayoutData(fdLimit);\n       \n\t\tfdContentComp = new FormData();\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\n\t\tfdContentComp.right = new FormAttachment(100, 0);\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\n\t\twContentComp.setLayoutData(fdContentComp);\n\n\t\twContentComp.layout();\n\t\twContentTab.setControl(wContentComp);\n\n\t\t// ///////////////////////////////////////////////////////////\n\t\t// / END OF CONTENT TAB\n\t\t// ///////////////////////////////////////////////////////////\n\n\n\t\t// Fields tab...\n\t\t//\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\n\t\twFieldsTab.setText(Messages.getString(\"AccessInputDialog.Fields.Tab\"));\n\t\t\n\t\tFormLayout fieldsLayout = new FormLayout ();\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\n\t\t\n\t\twFieldsComp = new Composite(wTabFolder, SWT.NONE);\n\t\twFieldsComp.setLayout(fieldsLayout);\n \t\tprops.setLook(wFieldsComp);\n\t\t\n \t\twGet=new Button(wFieldsComp, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"AccessInputDialog.GetFields.Button\"));\n\t\tfdGet=new FormData();\n\t\tfdGet.left=new FormAttachment(50, 0);\n\t\tfdGet.bottom =new FormAttachment(100, 0);\n\t\twGet.setLayoutData(fdGet);\n\t\t\n\t\tfinal int FieldsRows=input.getInputFields().length;\n\t\t\n\t\t// Prepare a list of possible formats...\n\t\tString dats[] = Const.getDateFormats();\n\t\tString nums[] = Const.getNumberFormats();\n\t\tint totsize = dats.length + nums.length;\n\t\tString formats[] = new String[totsize];\n\t\tfor (int x=0;x<dats.length;x++) formats[x] = dats[x];\n\t\tfor (int x=0;x<nums.length;x++) formats[dats.length+x] = nums[x];\n\t\t\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[]\n            {\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Name.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n         new ColumnInfo(\n                 Messages.getString(\"AccessInputDialog.FieldsTable.Attribut.Column\"),\n                 ColumnInfo.COLUMN_TYPE_TEXT,\n                 false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Type.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         Value.getTypes(),\n         true ),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Format.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         formats),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Length.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Precision.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Currency.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Decimal.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Group.Column\"),\n         ColumnInfo.COLUMN_TYPE_TEXT,\n         false),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.TrimType.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         AccessInputField.trimTypeDesc,\n         true ),\n\t\t\t new ColumnInfo(\n         Messages.getString(\"AccessInputDialog.FieldsTable.Repeat.Column\"),\n         ColumnInfo.COLUMN_TYPE_CCOMBO,\n         new String[] { Messages.getString(\"System.Combo.Yes\"), Messages.getString(\"System.Combo.No\") },\n         true ),\n     \n    };\n\t\t\n\t\tcolinf[0].setUsingVariables(true);\n\t\tcolinf[0].setToolTip(Messages.getString(\"AccessInputDialog.FieldsTable.Name.Column.Tooltip\"));\n\t\tcolinf[1].setUsingVariables(true);\n\t\tcolinf[1].setToolTip(Messages.getString(\"AccessInputDialog.FieldsTable.Attribut.Column.Tooltip\"));\n\t\t\n\t\twFields=new TableView(wFieldsComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t      colinf, \n\t\t\t\t\t\t      FieldsRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left  = new FormAttachment(0, 0);\n\t\tfdFields.top   = new FormAttachment(0, 0);\n\t\tfdFields.right = new FormAttachment(100, 0);\n\t\tfdFields.bottom= new FormAttachment(wGet, -margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\tfdFieldsComp=new FormData();\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\n\t\t\n\t\twFieldsComp.layout();\n\t\twFieldsTab.setControl(wFieldsComp);\n\t\t\n\t\tfdTabFolder = new FormData();\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\n\t\twTabFolder.setLayoutData(fdTabFolder);\n\t\t\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"AccessInputDialog.Button.PreviewRows\"));\n\t\t\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview();   } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();     } };\n\t\t\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twGet.addListener    (SWT.Selection, lsGet    );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twLimit.addSelectionListener( lsDef );\n\t\twInclRownumField.addSelectionListener( lsDef );\n\t\twInclFilenameField.addSelectionListener( lsDef );\n\t\twInclTablenameField.addSelectionListener( lsDef );\n\t\t\n\t\t// Add the file to the list of files...\n\t\tSelectionAdapter selA = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { wFilename.getText(), wFilemask.getText() } );\n\t\t\t\twFilename.setText(\"\");\n\t\t\t\twFilemask.setText(\"\");\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n                wFilenameList.optWidth(true);\n\t\t\t}\n\t\t};\n\t\twbaFilename.addSelectionListener(selA);\n\t\twFilename.addSelectionListener(selA);\n\t\t\n\t\t// Delete files from the list of files...\n\t\twbdFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx[] = wFilenameList.getSelectionIndices();\n\t\t\t\twFilenameList.remove(idx);\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Edit the selected file & remove from the list...\n\t\twbeFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx = wFilenameList.getSelectionIndex();\n\t\t\t\tif (idx>=0)\n\t\t\t\t{\n\t\t\t\t\tString string[] = wFilenameList.getItem(idx);\n\t\t\t\t\twFilename.setText(string[0]);\n\t\t\t\t\twFilemask.setText(string[1]);\n\t\t\t\t\twFilenameList.remove(idx);\n\t\t\t\t}\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Show the files that are selected at this time...\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n                    try\n                    {\n    \t\t\t\t\tAccessInputMeta tfii = new AccessInputMeta();\n    \t\t\t\t\tgetInfo(tfii);\n                        FileInputList fileInputList = tfii.getFiles();\n    \t\t\t\t\tString files[] = fileInputList.getFileStrings();\n    \t\t\t\t\tif (files!=null && files.length>0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, Messages.getString(\"AccessInputDialog.FilesReadSelection.DialogTitle\"), Messages.getString(\"AccessInputDialog.FilesReadSelection.DialogMessage\"));\n    \t\t\t\t\t\tesd.setViewOnly();\n    \t\t\t\t\t\tesd.open();\n    \t\t\t\t\t}\n    \t\t\t\t\telse\n    \t\t\t\t\t{\n    \t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n    \t\t\t\t\t\tmb.setMessage(Messages.getString(\"AccessInputDialog.NoFileFound.DialogMessage\"));\n    \t\t\t\t\t\tmb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\n    \t\t\t\t\t\tmb.open(); \n    \t\t\t\t\t}\n                    }\n                    catch(KettleException ex)\n                    {\n                        new ErrorDialog(shell, Messages.getString(\"AccessInputDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"AccessInputDialog.ErrorParsingData.DialogMessage\"), ex);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// Enable/disable the right fields to allow a filename to be added to each row...\n\t\twInclFilename.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tsetIncludeFilename();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Enable/disable the right fields to allow a row number to be added to each row...\n\t\twInclRownum.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tsetIncludeRownum();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// Enable/disable the right fields to allow a table name to be added to each row...\n\t\twInclTablename.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tsetIncludeTablename();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// Whenever something changes, set the tooltip to the expanded version of the filename:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename.setToolTipText(StringUtil.environmentSubstitute( wFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t\n\t\t\n\t\t// Listen to the Browse... button\n\t\twbbFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tif (wFilemask.getText()!=null && wFilemask.getText().length()>0) // A mask: a directory!\n\t\t\t\t\t{\n\t\t\t\t\t\tDirectoryDialog dialog = new DirectoryDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fpath = StringUtil.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFilterPath( fpath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str= dialog.getFilterPath();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*mdb;*.MDB\", \"*\"});\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fname = StringUtil.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"AccessInputDialog.FileType.AccessFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twTabFolder.setSelection(0);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\tgetData(input);\n\t\tinput.setChanged(changed);\n\t\twFields.optWidth(true);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Read the data from the TextFileInputMeta object and show it in this dialog.\n\t * \n\t * @param in The TextFileInputMeta object to obtain the data from.\n\t */\n\tpublic void getData(AccessInputMeta in)\n\t{\n\t\tif (in.getFileName() !=null) \n\t\t{\n\t\t\twFilenameList.removeAll();\n\t\t\tfor (int i=0;i<in.getFileName().length;i++) \n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { in.getFileName()[i], in.getFileMask()[i] } );\n\t\t\t}\n\t\t\twFilenameList.removeEmptyRows();\n\t\t\twFilenameList.setRowNums();\n\t\t\twFilenameList.optWidth(true);\n\t\t}\n\t\twInclFilename.setSelection(in.includeFilename());\n\t\twInclRownum.setSelection(in.includeRowNumber());\n\t\tif (in.getTableName()!=null) wTable.setText(in.getTableName());\n\t\tif (in.getFilenameField()!=null) wInclFilenameField.setText(in.getFilenameField());\n\t\tif (in.getRowNumberField()!=null) wInclRownumField.setText(in.getRowNumberField());\n\t\twLimit.setText(\"\"+in.getRowLimit());\n\n\t\tlog.logDebug(toString(), Messages.getString(\"AccessInputDialog.Log.GettingFieldsInfo\"));\n\t\tfor (int i=0;i<in.getInputFields().length;i++)\n\t\t{\n\t\t    AccessInputField field = in.getInputFields()[i];\n\t\t    \n            if (field!=null)\n            {\n    \t\t\tTableItem item  = wFields.table.getItem(i);\n    \t\t\tString name     = field.getName();\n    \t\t\tString xpath\t= field.getAttribut();\n    \t\t\tString type     = field.getTypeDesc();\n    \t\t\tString format   = field.getFormat();\n    \t\t\tString length   = \"\"+field.getLength();\n    \t\t\tString prec     = \"\"+field.getPrecision();\n    \t\t\tString curr     = field.getCurrencySymbol();\n    \t\t\tString group    = field.getGroupSymbol();\n    \t\t\tString decim    = field.getDecimalSymbol();\n    \t\t\tString trim     = field.getTrimTypeDesc();\n    \t\t\tString rep      = field.isRepeated()?Messages.getString(\"System.Combo.Yes\"):Messages.getString(\"System.Combo.No\");\n    \t\t\t\n                if (name    !=null) item.setText( 1, name);\n                if (xpath   !=null) item.setText( 2, xpath);\n    \t\t\tif (type    !=null) item.setText( 3, type);\n    \t\t\tif (format  !=null) item.setText( 4, format);\n    \t\t\tif (length  !=null && !\"-1\".equals(length)) item.setText( 5, length);\n    \t\t\tif (prec    !=null && !\"-1\".equals(prec)) item.setText( 6, prec);\n    \t\t\tif (curr    !=null) item.setText( 7, curr);\n    \t\t\tif (decim   !=null) item.setText( 8, decim);\n    \t\t\tif (group   !=null) item.setText( 9, group);\n    \t\t\tif (trim    !=null) item.setText(10, trim);\n    \t\t\tif (rep     !=null) item.setText(11, rep);                \n            }\n\t\t}\n        \n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n        wFields.optWidth(true);\n\n\t\tsetMultiple();\n\t\tsetIncludeFilename();\n\t\tsetIncludeRownum();\n\n\t\twStepname.selectAll();\n\t}","id":45251,"modified_method":"/**\n\t * Read the data from the TextFileInputMeta object and show it in this dialog.\n\t * \n\t * @param in The TextFileInputMeta object to obtain the data from.\n\t */\n\tpublic void getData(AccessInputMeta in)\n\t{\n\t\tif (in.getFileName() !=null) \n\t\t{\n\t\t\twFilenameList.removeAll();\n\t\t\tfor (int i=0;i<in.getFileName().length;i++) \n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { in.getFileName()[i], in.getFileMask()[i] } );\n\t\t\t}\n\t\t\twFilenameList.removeEmptyRows();\n\t\t\twFilenameList.setRowNums();\n\t\t\twFilenameList.optWidth(true);\n\t\t}\n\t\twInclFilename.setSelection(in.includeFilename());\n\t\twInclTablename.setSelection(in.includeTablename());\n\t\twInclRownum.setSelection(in.includeRowNumber());\n\t\tif (in.getTableName()!=null) wTable.setText(in.getTableName());\n\t\tif (in.getFilenameField()!=null) wInclFilenameField.setText(in.getFilenameField());\n\t\tif (in.gettablenameField()!=null) wInclTablenameField.setText(in.gettablenameField());\n\t\tif (in.getRowNumberField()!=null) wInclRownumField.setText(in.getRowNumberField());\n\t\twLimit.setText(\"\"+in.getRowLimit());\n\n\t\tlog.logDebug(toString(), Messages.getString(\"AccessInputDialog.Log.GettingFieldsInfo\"));\n\t\tfor (int i=0;i<in.getInputFields().length;i++)\n\t\t{\n\t\t    AccessInputField field = in.getInputFields()[i];\n\t\t    \n            if (field!=null)\n            {\n    \t\t\tTableItem item  = wFields.table.getItem(i);\n    \t\t\tString name     = field.getName();\n    \t\t\tString xpath\t= field.getAttribut();\n    \t\t\tString type     = field.getTypeDesc();\n    \t\t\tString format   = field.getFormat();\n    \t\t\tString length   = \"\"+field.getLength();\n    \t\t\tString prec     = \"\"+field.getPrecision();\n    \t\t\tString curr     = field.getCurrencySymbol();\n    \t\t\tString group    = field.getGroupSymbol();\n    \t\t\tString decim    = field.getDecimalSymbol();\n    \t\t\tString trim     = field.getTrimTypeDesc();\n    \t\t\tString rep      = field.isRepeated()?Messages.getString(\"System.Combo.Yes\"):Messages.getString(\"System.Combo.No\");\n    \t\t\t\n                if (name    !=null) item.setText( 1, name);\n                if (xpath   !=null) item.setText( 2, xpath);\n    \t\t\tif (type    !=null) item.setText( 3, type);\n    \t\t\tif (format  !=null) item.setText( 4, format);\n    \t\t\tif (length  !=null && !\"-1\".equals(length)) item.setText( 5, length);\n    \t\t\tif (prec    !=null && !\"-1\".equals(prec)) item.setText( 6, prec);\n    \t\t\tif (curr    !=null) item.setText( 7, curr);\n    \t\t\tif (decim   !=null) item.setText( 8, decim);\n    \t\t\tif (group   !=null) item.setText( 9, group);\n    \t\t\tif (trim    !=null) item.setText(10, trim);\n    \t\t\tif (rep     !=null) item.setText(11, rep);                \n            }\n\t\t}\n        \n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n        wFields.optWidth(true);\n\n\t\tsetMultiple();\n\t\tsetIncludeFilename();\n\t\tsetIncludeTablename();\n\t\tsetIncludeRownum();\n\n\t\twStepname.selectAll();\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean checkInputPositionsFilled(AccessInputMeta meta){\n        /*if (meta.getLoopXPath()==null || meta.getLoopXPath().length()<1)\n        {\n            MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n            mb.setMessage(Messages.getString(\"AccessInputDialog.SpecifyRepeatingElement.DialogMessage\"));\n            mb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\n            mb.open(); \n\n            return false;\n        }\n        else\n        {*/\n        \treturn true;\n        //}\n\t}","id":45252,"modified_method":"private boolean checkInputFilesName(AccessInputMeta meta){\n        if (meta.getFiles().nrOfFiles()==0)\n        {\n            MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n            mb.setMessage(Messages.getString(\"AccessInputDialog.FilesMissing.DialogMessage\"));\n            mb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\n            mb.open(); \n\n            return false;\n        }\n        else\n        {\n        \treturn true;\n        }\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tincludeFilename   = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"include\"));\n\t\t\tfilenameField     = XMLHandler.getTagValue(stepnode, \"include_field\");\n\t\t\tincludeRowNumber  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"rownum\"));\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownum_field\");\n\t\t\tTableName    = XMLHandler.getTagValue(stepnode, \"table_name\");\n\t\n\t\t\tNode filenode   = XMLHandler.getSubNode(stepnode,  \"file\");\n\t\t\tNode fields     = XMLHandler.getSubNode(stepnode,  \"fields\");\n\t\t\tint nrFiles     = XMLHandler.countNodes(filenode,  \"name\");\n\t\t\tint nrFields    = XMLHandler.countNodes(fields,    \"field\");\n\t\n\t\t\tallocate(nrFiles, nrFields);\n\t\t\t\n\t\t\tfor (int i=0;i<nrFiles;i++)\n\t\t\t{\n\t\t\t\tNode filenamenode = XMLHandler.getSubNodeByNr(filenode, \"name\", i); \n\t\t\t\tNode filemasknode = XMLHandler.getSubNodeByNr(filenode, \"filemask\", i); \n\t\t\t\tfileName[i] = XMLHandler.getNodeValue(filenamenode);\n\t\t\t\tfileMask[i] = XMLHandler.getNodeValue(filemasknode);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<nrFields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\tAccessInputField field = new AccessInputField(fnode);\n\t\t\t\tinputFields[i] = field;\n\t\t\t}\n\t\t\t\n\t\t\t// Is there a limit on the number of rows we process?\n\t\t\trowLimit = Const.toLong(XMLHandler.getTagValue(stepnode, \"limit\"), 0L);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":45253,"modified_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tincludeFilename   = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"include\"));\n\t\t\tfilenameField     = XMLHandler.getTagValue(stepnode, \"include_field\");\n\t\t\tincludeTablename  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"tablename\"));\n\t\t\ttablenameField    = XMLHandler.getTagValue(stepnode, \"tablename_field\");\n\t\t\tincludeRowNumber  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"rownum\"));\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownum_field\");\n\t\t\tTableName    = XMLHandler.getTagValue(stepnode, \"table_name\");\n\t\n\t\t\tNode filenode   = XMLHandler.getSubNode(stepnode,  \"file\");\n\t\t\tNode fields     = XMLHandler.getSubNode(stepnode,  \"fields\");\n\t\t\tint nrFiles     = XMLHandler.countNodes(filenode,  \"name\");\n\t\t\tint nrFields    = XMLHandler.countNodes(fields,    \"field\");\n\t\n\t\t\tallocate(nrFiles, nrFields);\n\t\t\t\n\t\t\tfor (int i=0;i<nrFiles;i++)\n\t\t\t{\n\t\t\t\tNode filenamenode = XMLHandler.getSubNodeByNr(filenode, \"name\", i); \n\t\t\t\tNode filemasknode = XMLHandler.getSubNodeByNr(filenode, \"filemask\", i); \n\t\t\t\tfileName[i] = XMLHandler.getNodeValue(filenamenode);\n\t\t\t\tfileMask[i] = XMLHandler.getNodeValue(filemasknode);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<nrFields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\tAccessInputField field = new AccessInputField(fnode);\n\t\t\t\tinputFields[i] = field;\n\t\t\t}\n\t\t\t\n\t\t\t// Is there a limit on the number of rows we process?\n\t\t\trowLimit = Const.toLong(XMLHandler.getTagValue(stepnode, \"limit\"), 0L);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"include\",         includeFilename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"include_field\",   filenameField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownum\",          includeRowNumber);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownum_field\",    rowNumberField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"limit\",           rowLimit);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"table_name\",      TableName);\n\t\t\t\n\t\t\tfor (int i=0;i<fileName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_name\",     fileName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_mask\",     fileMask[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<inputFields.length;i++)\n\t\t\t{\n\t\t\t    AccessInputField field = inputFields[i];\n\t\t\t    \n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",          field.getName());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"fied_attribut\",       field.getAttribut());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",          field.getTypeDesc());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",        field.getFormat());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\",      field.getCurrencySymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",       field.getDecimalSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",         field.getGroupSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",        field.getLength());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\",     field.getPrecision());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\",     field.getTrimTypeCode());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_repeat\",        field.isRepeated());\n                rep.saveStepAttribute(id_transformation, id_step, i, \"field_position_code\", field.getFieldPositionsCode());\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"AccessInputMeta.Exception.ErrorSavingToRepository\", \"\"+id_step), e);\n\t\t}\n\t}","id":45254,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"include\",         includeFilename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"include_field\",   filenameField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"tablename\",          includeTablename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"tablename_field\",    tablenameField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownum\",          includeRowNumber);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownum_field\",    rowNumberField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"limit\",           rowLimit);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"table_name\",      TableName);\n\t\t\t\n\t\t\tfor (int i=0;i<fileName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_name\",     fileName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_mask\",     fileMask[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<inputFields.length;i++)\n\t\t\t{\n\t\t\t    AccessInputField field = inputFields[i];\n\t\t\t    \n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",          field.getName());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"fied_attribut\",       field.getAttribut());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",          field.getTypeDesc());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",        field.getFormat());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\",      field.getCurrencySymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",       field.getDecimalSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",         field.getGroupSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",        field.getLength());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\",     field.getPrecision());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\",     field.getTrimTypeCode());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_repeat\",        field.isRepeated());\n                rep.saveStepAttribute(id_transformation, id_step, i, \"field_position_code\", field.getFieldPositionsCode());\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"AccessInputMeta.Exception.ErrorSavingToRepository\", \"\"+id_step), e);\n\t\t}\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tincludeFilename   = rep.getStepAttributeBoolean(id_step, \"include\");  \n\t\t\tfilenameField     = rep.getStepAttributeString (id_step, \"include_field\");\n\t\t\tTableName          = rep.getStepAttributeString(id_step, \"table_name\");\n\t\t\tincludeRowNumber  = rep.getStepAttributeBoolean(id_step, \"rownum\");\n\t\t\trowNumberField    = rep.getStepAttributeString (id_step, \"rownum_field\");\n\t\t\trowLimit          = rep.getStepAttributeInteger(id_step, \"limit\");\n\t\n\t\t\tint nrFiles       = rep.countNrStepAttributes(id_step, \"file_name\");\n\t\t\tint nrFields      = rep.countNrStepAttributes(id_step, \"field_name\");\n            \n\t\t\tallocate(nrFiles, nrFields);\n\n\t\t\tfor (int i=0;i<nrFiles;i++)\n\t\t\t{\n\t\t\t\tfileName[i] =      rep.getStepAttributeString (id_step, i, \"file_name\"    );\n\t\t\t\tfileMask[i] =      rep.getStepAttributeString (id_step, i, \"file_mask\"    );\n\t\t\t}\n\n\t\t\tfor (int i=0;i<nrFields;i++)\n\t\t\t{\n\t\t\t    AccessInputField field = new AccessInputField();\n\t\t\t    \n\t\t\t\tfield.setName( rep.getStepAttributeString (id_step, i, \"field_name\") );\n\t\t\t\tfield.setAttribut( rep.getStepAttributeString (id_step, i, \"field_attribut\") );\n\t\t\t\tfield.setType( Value.getType( rep.getStepAttributeString (id_step, i, \"field_type\") ) );\n\t\t\t\tfield.setFormat( rep.getStepAttributeString (id_step, i, \"field_format\") );\n\t\t\t\tfield.setCurrencySymbol( rep.getStepAttributeString (id_step, i, \"field_currency\") );\n\t\t\t\tfield.setDecimalSymbol( rep.getStepAttributeString (id_step, i, \"field_decimal\") );\n\t\t\t\tfield.setGroupSymbol( rep.getStepAttributeString (id_step, i, \"field_group\") );\n\t\t\t\tfield.setLength( (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tfield.setPrecision( (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tfield.setTrimType( AccessInputField.getTrimTypeByCode( rep.getStepAttributeString (id_step, i, \"field_trim_type\") ));\n\t\t\t\tfield.setRepeated( rep.getStepAttributeBoolean(id_step, i, \"field_repeat\") );\n\n\t\t\t\tinputFields[i] = field;\n\t\t\t}\n        }\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"AccessInputMeta.Exception.ErrorReadingRepository\"), e);\n\t\t}\n\t}","id":45255,"modified_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tincludeFilename   = rep.getStepAttributeBoolean(id_step, \"include\");  \n\t\t\tfilenameField     = rep.getStepAttributeString (id_step, \"include_field\");\n\t\t\tTableName          = rep.getStepAttributeString(id_step, \"table_name\");\n\t\t\tincludeTablename  = rep.getStepAttributeBoolean(id_step, \"tablename\");\n\t\t\ttablenameField    = rep.getStepAttributeString (id_step, \"tablename_field\");\n\t\t\tincludeRowNumber  = rep.getStepAttributeBoolean(id_step, \"rownum\");\n\t\t\trowNumberField    = rep.getStepAttributeString (id_step, \"rownum_field\");\n\t\t\trowLimit          = rep.getStepAttributeInteger(id_step, \"limit\");\n\t\n\t\t\tint nrFiles       = rep.countNrStepAttributes(id_step, \"file_name\");\n\t\t\tint nrFields      = rep.countNrStepAttributes(id_step, \"field_name\");\n            \n\t\t\tallocate(nrFiles, nrFields);\n\n\t\t\tfor (int i=0;i<nrFiles;i++)\n\t\t\t{\n\t\t\t\tfileName[i] =      rep.getStepAttributeString (id_step, i, \"file_name\"    );\n\t\t\t\tfileMask[i] =      rep.getStepAttributeString (id_step, i, \"file_mask\"    );\n\t\t\t}\n\n\t\t\tfor (int i=0;i<nrFields;i++)\n\t\t\t{\n\t\t\t    AccessInputField field = new AccessInputField();\n\t\t\t    \n\t\t\t\tfield.setName( rep.getStepAttributeString (id_step, i, \"field_name\") );\n\t\t\t\tfield.setAttribut( rep.getStepAttributeString (id_step, i, \"field_attribut\") );\n\t\t\t\tfield.setType( Value.getType( rep.getStepAttributeString (id_step, i, \"field_type\") ) );\n\t\t\t\tfield.setFormat( rep.getStepAttributeString (id_step, i, \"field_format\") );\n\t\t\t\tfield.setCurrencySymbol( rep.getStepAttributeString (id_step, i, \"field_currency\") );\n\t\t\t\tfield.setDecimalSymbol( rep.getStepAttributeString (id_step, i, \"field_decimal\") );\n\t\t\t\tfield.setGroupSymbol( rep.getStepAttributeString (id_step, i, \"field_group\") );\n\t\t\t\tfield.setLength( (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tfield.setPrecision( (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tfield.setTrimType( AccessInputField.getTrimTypeByCode( rep.getStepAttributeString (id_step, i, \"field_trim_type\") ));\n\t\t\t\tfield.setRepeated( rep.getStepAttributeBoolean(id_step, i, \"field_repeat\") );\n\n\t\t\t\tinputFields[i] = field;\n\t\t\t}\n        }\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"AccessInputMeta.Exception.ErrorReadingRepository\"), e);\n\t\t}\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n    {\n        StringBuffer retval=new StringBuffer();\n        \n        retval.append(\"    \"+XMLHandler.addTagValue(\"include\",         includeFilename));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"include_field\",   filenameField));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"rownum\",          includeRowNumber));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"rownum_field\",    rowNumberField));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"table_name\",      TableName));\n        \n        retval.append(\"    <file>\"+Const.CR);\n        for (int i=0;i<fileName.length;i++)\n        {\n            retval.append(\"      \"+XMLHandler.addTagValue(\"name\",     fileName[i]));\n            retval.append(\"      \"+XMLHandler.addTagValue(\"filemask\", fileMask[i]));\n        }\n        retval.append(\"      <\/file>\"+Const.CR);\n        \n        retval.append(\"    <fields>\"+Const.CR);\n        for (int i=0;i<inputFields.length;i++)\n        {\n            AccessInputField field = inputFields[i];\n            retval.append(field.getXML());\n        }\n        retval.append(\"      <\/fields>\"+Const.CR);\n        retval.append(\"    \"+XMLHandler.addTagValue(\"limit\", rowLimit));\n\n        return retval.toString();\n    }","id":45256,"modified_method":"public String getXML()\n    {\n        StringBuffer retval=new StringBuffer();\n        \n        retval.append(\"    \"+XMLHandler.addTagValue(\"include\",         includeFilename));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"include_field\",   filenameField));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"tablename\",         includeTablename));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"tablename_field\",   tablenameField));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"rownum\",          includeRowNumber));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"rownum_field\",    rowNumberField));\n        retval.append(\"    \"+XMLHandler.addTagValue(\"table_name\",      TableName));\n        \n        retval.append(\"    <file>\"+Const.CR);\n        for (int i=0;i<fileName.length;i++)\n        {\n            retval.append(\"      \"+XMLHandler.addTagValue(\"name\",     fileName[i]));\n            retval.append(\"      \"+XMLHandler.addTagValue(\"filemask\", fileMask[i]));\n        }\n        retval.append(\"      <\/file>\"+Const.CR);\n        \n        retval.append(\"    <fields>\"+Const.CR);\n        for (int i=0;i<inputFields.length;i++)\n        {\n            AccessInputField field = inputFields[i];\n            retval.append(field.getXML());\n        }\n        retval.append(\"      <\/fields>\"+Const.CR);\n        retval.append(\"    \"+XMLHandler.addTagValue(\"limit\", rowLimit));\n\n        return retval.toString();\n    }","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n\t\tincludeFilename  = false;\n\t\tfilenameField    = \"\";\n\t\tincludeRowNumber = false;\n\t\trowNumberField   = \"\";\n\t\tTableName   = \"\";\n\t\t\n\t\tint nrFiles  =0;\n\t\tint nrFields =0;\n\n\t\tallocate(nrFiles, nrFields);\t\n\t\t\n\t\tfor (int i=0;i<nrFiles;i++) \n\t\t{\n\t\t\tfileName[i]=\"filename\"+(i+1);\n\t\t\tfileMask[i]=\"\";\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrFields;i++)\n\t\t{\n\t\t    inputFields[i] = new AccessInputField(\"field\"+(i+1), null);\n\t\t}\n\n\t\trowLimit=0;\n\t}","id":45257,"modified_method":"public void setDefault()\n\t{\n\t\tincludeFilename  = false;\n\t\tfilenameField    = \"\";\n\t\tincludeTablename = false;\n\t\ttablenameField   = \"\";\n\t\tincludeRowNumber = false;\n\t\trowNumberField   = \"\";\n\t\tTableName   = \"\";\n\t\t\n\t\tint nrFiles  =0;\n\t\tint nrFields =0;\n\n\t\tallocate(nrFiles, nrFields);\t\n\t\t\n\t\tfor (int i=0;i<nrFiles;i++) \n\t\t{\n\t\t\tfileName[i]=\"filename\"+(i+1);\n\t\t\tfileMask[i]=\"\";\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrFields;i++)\n\t\t{\n\t\t    inputFields[i] = new AccessInputField(\"field\"+(i+1), null);\n\t\t}\n\n\t\trowLimit=0;\n\t}","commit_id":"45201267e7ce32edb703ec2b1e0655aab21835b7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    public void addVertexHopCriteria(SearchResult searchResult, GraphContainer container) {\n        LOG.debug(\"BusinessServiceSearchProvider->addVertexHopCriteria: called with search result: '{}'\", searchResult);\n\n        BusinessServiceCriteria criterion = new BusinessServiceCriteria(searchResult.getId(), searchResult.getLabel(), m_businessServiceManager);\n        container.addCriteria(criterion);\n\n        LOG.debug(\"BusinessServiceSearchProvider->addVertexHop: adding hop criteria {}.\", criterion);\n        LOG.debug(\"BusinessServiceSearchProvider->addVertexHop: current criteria {}.\", Arrays.toString(container.getCriteria()));\n    }","id":45258,"modified_method":"@Override\n    public void addVertexHopCriteria(SearchResult searchResult, GraphContainer container) {\n        LOG.debug(\"BusinessServiceSearchProvider->addVertexHopCriteria: called with search result: '{}'\", searchResult);\n\n        BusinessServiceCriteria criterion = new BusinessServiceCriteria(searchResult.getId(), searchResult.getLabel(), businessServiceManager);\n        container.addCriteria(criterion);\n\n        LOG.debug(\"BusinessServiceSearchProvider->addVertexHop: adding hop criteria {}.\", criterion);\n        LOG.debug(\"BusinessServiceSearchProvider->addVertexHop: current criteria {}.\", Arrays.toString(container.getCriteria()));\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void removeVertexHopCriteria(SearchResult searchResult, GraphContainer container) {\n        LOG.debug(\"BusinessServiceSearchProvider->removeVertexHopCriteria: called with search result: '{}'\", searchResult);\n\n        BusinessServiceCriteria criterion = new BusinessServiceCriteria(searchResult.getId(), searchResult.getLabel(), m_businessServiceManager);\n        container.removeCriteria(criterion);\n\n        LOG.debug(\"BusinessServiceSearchProvider->removeVertexHopCriteria: current criteria {}.\", Arrays.toString(container.getCriteria()));\n    }","id":45259,"modified_method":"@Override\n    public void removeVertexHopCriteria(SearchResult searchResult, GraphContainer container) {\n        LOG.debug(\"BusinessServiceSearchProvider->removeVertexHopCriteria: called with search result: '{}'\", searchResult);\n\n        BusinessServiceCriteria criterion = new BusinessServiceCriteria(searchResult.getId(), searchResult.getLabel(), businessServiceManager);\n        container.removeCriteria(criterion);\n\n        LOG.debug(\"BusinessServiceSearchProvider->removeVertexHopCriteria: current criteria {}.\", Arrays.toString(container.getCriteria()));\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public List<SearchResult> query(SearchQuery searchQuery, GraphContainer container) {\n        LOG.info(\"BusinessServiceSearchProvider->query: called with search query: '{}'\", searchQuery);\n        List<SearchResult> results = Lists.newArrayList();\n\n        String queryString = searchQuery.getQueryString();        \n        CriteriaBuilder bldr = new CriteriaBuilder(BusinessService.class);\n        if (queryString != null && queryString.length() > 0) {\n            bldr.ilike(\"name\", String.format(\"%%%s%%\", queryString));\n        }\n        bldr.orderBy(\"name\", true);\n        bldr.limit(10);\n        Criteria dbQueryCriteria = bldr.toCriteria();\n\n        for (BusinessService bs: m_businessServiceDao.findMatching(dbQueryCriteria)) {\n            SearchResult searchResult = new SearchResult(getSearchProviderNamespace(), String.valueOf(bs.getId()), bs.getName(), queryString);\n            searchResult.setCollapsed(false);\n            searchResult.setCollapsible(true);\n            results.add(searchResult);\n        }\n\n        LOG.info(\"BusinessServiceSearchProvider->query: found {} results: {}\", results.size(), results);\n        return results;\n    }","id":45260,"modified_method":"@Override\n    public List<SearchResult> query(SearchQuery searchQuery, GraphContainer container) {\n        LOG.info(\"BusinessServiceSearchProvider->query: called with search query: '{}'\", searchQuery);\n        List<SearchResult> results = Lists.newArrayList();\n\n        String queryString = searchQuery.getQueryString();        \n        CriteriaBuilder bldr = new CriteriaBuilder(BusinessService.class);\n        if (queryString != null && queryString.length() > 0) {\n            bldr.ilike(\"name\", String.format(\"%%%s%%\", queryString));\n        }\n        bldr.orderBy(\"name\", true);\n        bldr.limit(10);\n        Criteria dbQueryCriteria = bldr.toCriteria();\n\n        for (BusinessServiceDTO bs: businessServiceManager.findMatching(dbQueryCriteria)) {\n            SearchResult searchResult = new SearchResult(getSearchProviderNamespace(), String.valueOf(bs.getId()), bs.getName(), queryString);\n            searchResult.setCollapsed(false);\n            searchResult.setCollapsible(true);\n            results.add(searchResult);\n        }\n\n        LOG.info(\"BusinessServiceSearchProvider->query: found {} results: {}\", results.size(), results);\n        return results;\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setBusinessServiceManager(BusinessServiceManager businessServiceManager) {\n        m_businessServiceManager = businessServiceManager;\n    }","id":45261,"modified_method":"public void setBusinessServiceManager(BusinessServiceManager businessServiceManager) {\n        this.businessServiceManager = Objects.requireNonNull(businessServiceManager);\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void load() {\n        resetContainer();\n        // we only consider root business services to build the graph\n        Collection<BusinessService> businessServices = Collections2.filter(businessServiceDao.findAll(), new Predicate<BusinessService>() {\n            @Override\n            public boolean apply(BusinessService input) {\n                return input.getParentServices().isEmpty();\n            }\n        });\n        addBusinessServices(null, businessServices);\n    }","id":45262,"modified_method":"private void load() {\n        resetContainer();\n        // we only consider root business services to build the graph\n        Collection<BusinessServiceDTO> businessServices = Collections2.filter(businessServiceManager.findAll(), new Predicate<BusinessServiceDTO>() {\n            @Override\n            public boolean apply(BusinessServiceDTO input) {\n                return input.getParentServices().isEmpty();\n            }\n        });\n        addBusinessServices(null, businessServices);\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BusinessServiceVertex createVertex(BusinessService businessService) {\n        BusinessServiceVertex businessServiceVertex = new BusinessServiceVertex(String.valueOf(businessService.getId()), businessService.getName());\n        businessServiceVertex.setLabel(businessService.getName());\n        businessServiceVertex.setTooltipText(String.format(\"BusinessService '%s'\", businessService.getName()));\n        businessServiceVertex.setIconKey(\"business-service\");\n        return businessServiceVertex;\n    }","id":45263,"modified_method":"private BusinessServiceVertex createVertex(BusinessServiceDTO businessService) {\n        BusinessServiceVertex businessServiceVertex = new BusinessServiceVertex(String.valueOf(businessService.getId()), businessService.getName());\n        businessServiceVertex.setLabel(businessService.getName());\n        businessServiceVertex.setTooltipText(String.format(\"BusinessService '%s'\", businessService.getName()));\n        businessServiceVertex.setIconKey(\"business-service\");\n        return businessServiceVertex;\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public Criteria getDefaultCriteria() {\n        // Only show the first application by default\n        List<BusinessService> businessServices = businessServiceDao.findAll();\n        if (!businessServices.isEmpty()) {\n            BusinessService businessService = businessServices.iterator().next();\n            return new BusinessServiceCriteria(String.valueOf(businessService.getId()), businessService.getName(), businessServiceManager);\n        }\n        return null;\n    }","id":45264,"modified_method":"@Override\n    public Criteria getDefaultCriteria() {\n        // Only show the first application by default\n        List<BusinessServiceDTO> businessServices = businessServiceManager.findAll();\n        if (!businessServices.isEmpty()) {\n            BusinessServiceDTO businessService = businessServices.iterator().next();\n            return new BusinessServiceCriteria(String.valueOf(businessService.getId()), businessService.getName(), businessServiceManager);\n        }\n        return null;\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addBusinessService(BusinessServiceVertex parentVertex, BusinessService businessService) {\n        // create the vertex itself\n        BusinessServiceVertex businessServiceVertex = createVertex(businessService);\n        addVertices(businessServiceVertex);\n\n        // if we have a parent, connect the parent at the current business service vertex as well\n        if (parentVertex != null) {\n            parentVertex.addChildren(businessServiceVertex);\n            addEdges(createConnection(parentVertex, businessServiceVertex));\n        }\n\n        // add ip services\n        for (OnmsMonitoredService eachIpService : businessService.getIpServices()) {\n            BusinessServiceVertex serviceVertex = createVertex(businessService, eachIpService);\n            businessServiceVertex.addChildren(serviceVertex);\n            addVertices(serviceVertex);\n\n            // connect with businessService\n            Edge edge = createConnection(businessServiceVertex, serviceVertex);\n            addEdges(edge);\n        }\n\n        // add children to the hierarchy as well\n        addBusinessServices(businessServiceVertex, businessService.getChildServices());\n    }","id":45265,"modified_method":"private void addBusinessService(BusinessServiceVertex parentVertex, BusinessServiceDTO businessService) {\n        // create the vertex itself\n        BusinessServiceVertex businessServiceVertex = createVertex(businessService);\n        addVertices(businessServiceVertex);\n\n        // if we have a parent, connect the parent at the current business service vertex as well\n        if (parentVertex != null) {\n            parentVertex.addChildren(businessServiceVertex);\n            addEdges(createConnection(parentVertex, businessServiceVertex));\n        }\n\n        // add ip services\n        for (IpServiceDTO eachIpService : businessService.getIpServices()) {\n            BusinessServiceVertex serviceVertex = createVertex(businessService, eachIpService);\n            businessServiceVertex.addChildren(serviceVertex);\n            addVertices(serviceVertex);\n\n            // connect with businessService\n            Edge edge = createConnection(businessServiceVertex, serviceVertex);\n            addEdges(edge);\n        }\n\n        // add children to the hierarchy as well\n        addBusinessServices(businessServiceVertex, businessService.getChildServices());\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addBusinessServices(BusinessServiceVertex parentVertex, Collection<BusinessService> businessServices) {\n        for (BusinessService eachBusinessService : businessServices) {\n            addBusinessService(parentVertex, eachBusinessService);\n        }\n    }","id":45266,"modified_method":"private void addBusinessServices(BusinessServiceVertex parentVertex, Collection<BusinessServiceDTO> businessServices) {\n        for (BusinessServiceDTO eachBusinessService : businessServices) {\n            addBusinessService(parentVertex, eachBusinessService);\n        }\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setBusinessServiceManager(BusinessServiceManager businessServiceManager) {\n        this.businessServiceManager =  Objects.requireNonNull(businessServiceManager);\n    }","id":45267,"modified_method":"public void setBusinessServiceManager(BusinessServiceManager businessServiceManager) {\n        Objects.requireNonNull(businessServiceManager);\n        this.businessServiceManager = transactionAwareBeanProxyFactory.createProxy(businessServiceManager);\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BusinessServiceVertex createVertex(BusinessService parentBusinessService, OnmsMonitoredService monitoredService) {\n        final BusinessServiceVertex serviceVertex = new BusinessServiceVertex(parentBusinessService.getId() + \":\" + String.valueOf(monitoredService.getId()), monitoredService.getServiceName());\n        serviceVertex.setIpAddress(monitoredService.getIpAddress().toString());\n        serviceVertex.setLabel(monitoredService.getServiceName());\n        serviceVertex.setTooltipText(String.format(\"Service '%s', IP: %s\", monitoredService.getServiceName(), monitoredService.getIpAddress().toString()));\n//      serviceVertex.setNodeID(eachIpService.getNodeId());\n//      serviceVertex.setServiceType(eachIpService.getServiceType());\n        return serviceVertex;\n    }","id":45268,"modified_method":"private BusinessServiceVertex createVertex(BusinessServiceDTO parentBusinessService, IpServiceDTO ipService) {\n        final BusinessServiceVertex serviceVertex = new BusinessServiceVertex(parentBusinessService.getId() + \":\" + String.valueOf(ipService.getId()), ipService.getServiceName());\n        serviceVertex.setIpAddress(ipService.getIpAddress().toString());\n        serviceVertex.setLabel(ipService.getServiceName());\n        serviceVertex.setTooltipText(String.format(\"Service '%s', IP: %s\", ipService.getServiceName(), ipService.getIpAddress().toString()));\n        return serviceVertex;\n    }","commit_id":"f78013a1565a3599acc1f8c612e056f304b00672","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * @return the untouchedExamples\n   */\n  public List<String> getUntouchedExamples() {\n    return untouchedExamples;\n  }","id":45269,"modified_method":"/**\n   * @return the untouchedExamples\n   */\n  public List<String> getUntouchedExamples() {\n    return Collections.unmodifiableList(untouchedExamples);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @param untouchedExamples the untouchedExamples to set\n   */\n  public void setUntouchedExamples(final List<String> untouchedExamples) {\n    this.untouchedExamples = untouchedExamples;\n  }","id":45270,"modified_method":"/**\n   * @param untouchedExamples the untouchedExamples to set\n   */\n  public void setUntouchedExamples(final List<String> untouchedExamples) {\n    this.untouchedExamples = Objects.requireNonNull(untouchedExamples);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * For testing only.\n   */\n  public final List<Element> getElements() {\n    return patternElements;\n  }","id":45271,"modified_method":"/**\n   * For testing only.\n   */\n  public final List<Element> getElements() {\n    return Collections.unmodifiableList(patternElements);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @param examples the examples to set\n   */\n  public void setExamples(final List<DisambiguatedExample> examples) {\n    this.examples = examples;\n  }","id":45272,"modified_method":"/**\n   * @param examples the examples to set\n   */\n  public void setExamples(final List<DisambiguatedExample> examples) {\n    this.examples = Objects.requireNonNull(examples);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @return the examples\n   */\n  public List<DisambiguatedExample> getExamples() {\n    return examples;\n  }","id":45273,"modified_method":"/**\n   * @return the examples\n   */\n  public List<DisambiguatedExample> getExamples() {\n    return Collections.unmodifiableList(examples);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @param srxInClassPath the path to an SRX file in the classpath \n   */\n  public LocalSRXSentenceTokenizer(Language language, String srxInClassPath) {\n    this.language = Objects.requireNonNull(language);\n    InputStream stream = this.getClass().getResourceAsStream(srxInClassPath);\n    if (stream == null) {\n      throw new RuntimeException(\"Could not find SRX file in classpath: \" + srxInClassPath);\n    }\n    this.srxDocument = SrxTools.createSrxDocument(stream);  // will close the stream on its own\n    setSingleLineBreaksMarksParagraph(false);\n  }","id":45274,"modified_method":"/**\n   * @param srxInClassPath the path to an SRX file in the classpath \n   */\n  public LocalSRXSentenceTokenizer(Language language, String srxInClassPath) {\n    this.language = Objects.requireNonNull(language);\n    try {\n      InputStream stream = Tools.getStream(srxInClassPath);\n      this.srxDocument = SrxTools.createSrxDocument(stream);  // will close the stream on its own\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    setSingleLineBreaksMarksParagraph(false);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Implements multiword POS tags, e.g., &lt;ELLIPSIS&gt; for ellipsis (...)\n   * start, and &lt;/ELLIPSIS&gt; for ellipsis end.\n   *\n   * @param input The tokens to be chunked.\n   * @return AnalyzedSentence with additional markers.\n   */\n  @Override\n  public final AnalyzedSentence disambiguate(final AnalyzedSentence input) {\n\n    lazyInit();\n\n    final AnalyzedTokenReadings[] anTokens = input.getTokens();\n    final AnalyzedTokenReadings[] output = anTokens;\n\n    for (int i = 0; i < anTokens.length; i++) {\n      String tok = output[i].getToken();\n      if (tok.length()<1) {\n        continue;\n      }\n      // If the second token is not whitespace, concatenate it\n      if (i + 1 < anTokens.length && !anTokens[i+1].isWhitespace()) {\n        tok=tok.concat(output[i+1].getToken());\n      }\n      // If it is a capitalized word, the second time try with lowercase word.\n      int myCount = 0;\n      while (myCount < 2) {\n        final StringBuilder tokens = new StringBuilder();\n        int finalLen = 0;\n        if (mStartSpace.containsKey(tok)) {\n          final int len = mStartSpace.get(tok);\n          int j = i;\n          int lenCounter = 0;\n          while (j < anTokens.length) {\n            if (!anTokens[j].isWhitespace()) {\n              if ((j == i) && (myCount == 1)) {\n                tokens.append(anTokens[j].getToken().toLowerCase());\n              } else {\n                tokens.append(anTokens[j].getToken());\n              }\n              final String toks = tokens.toString();\n              if (mFull.containsKey(toks)) {\n                output[i] = prepareNewReading(toks, output[i].getToken(), output[i], false);\n                output[finalLen] = prepareNewReading(toks,\n                    anTokens[finalLen].getToken(), output[finalLen], true);\n              }\n            } else {\n              if (j>1 && !anTokens[j-1].isWhitespace()) { //avoid multiple whitespaces\n                tokens.append(' ');\n                lenCounter++;\n              }\n              if (lenCounter == len) {\n                break;\n              }\n            }\n            j++;\n            finalLen = j;\n          } \n        }\n\n        if (mStartNoSpace.containsKey(tok.substring(0, 1))) {\n          int j = i;\n          while (j < anTokens.length && !anTokens[j].isWhitespace()) {\n            if ((j == i) && (myCount == 1)) {\n              tokens.append(anTokens[j].getToken().toLowerCase());\n            } else {\n              tokens.append(anTokens[j].getToken());\n            }\n            final String toks = tokens.toString();\n            if (mFull.containsKey(toks)) {\n              output[i] = prepareNewReading(toks, anTokens[i].getToken(),\n                  output[i], false);\n              output[j] = prepareNewReading(toks, anTokens[j].getToken(),\n                  output[j], true);\n            }\n            j++;\n          }\n        }\n        // If it is a capitalized word, try with lowercase word.\n        myCount++;\n        if (bAllowFirstCapitalized && StringTools.isCapitalizedWord(tok) \n            && myCount == 1) {\n            tok = tok.toLowerCase();\n        } else {\n          myCount = 2;\n        }\n      }\n    }\n    return new AnalyzedSentence(output);\n  }","id":45275,"modified_method":"/**\n   * Implements multiword POS tags, e.g., &lt;ELLIPSIS&gt; for ellipsis (...)\n   * start, and &lt;/ELLIPSIS&gt; for ellipsis end.\n   *\n   * @param input The tokens to be chunked.\n   * @return AnalyzedSentence with additional markers.\n   */\n  @Override\n  public final AnalyzedSentence disambiguate(final AnalyzedSentence input) {\n\n    lazyInit();\n\n    final AnalyzedTokenReadings[] anTokens = input.getTokens();\n    final AnalyzedTokenReadings[] output = anTokens;\n\n    for (int i = 0; i < anTokens.length; i++) {\n      String tok = output[i].getToken();\n      if (tok.length()<1) {\n        continue;\n      }\n      // If the second token is not whitespace, concatenate it\n      if (i + 1 < anTokens.length && !anTokens[i+1].isWhitespace()) {\n        tok = tok.concat(output[i+1].getToken());\n      }\n      // If it is a capitalized word, the second time try with lowercase word.\n      int myCount = 0;\n      while (myCount < 2) {\n        final StringBuilder tokens = new StringBuilder();\n        int finalLen = 0;\n        if (mStartSpace.containsKey(tok)) {\n          final int len = mStartSpace.get(tok);\n          int j = i;\n          int lenCounter = 0;\n          while (j < anTokens.length) {\n            if (!anTokens[j].isWhitespace()) {\n              if ((j == i) && (myCount == 1)) {\n                tokens.append(anTokens[j].getToken().toLowerCase());\n              } else {\n                tokens.append(anTokens[j].getToken());\n              }\n              final String toks = tokens.toString();\n              if (mFull.containsKey(toks)) {\n                output[i] = prepareNewReading(toks, output[i].getToken(), output[i], false);\n                output[finalLen] = prepareNewReading(toks,\n                    anTokens[finalLen].getToken(), output[finalLen], true);\n              }\n            } else {\n              if (j > 1 && !anTokens[j-1].isWhitespace()) { //avoid multiple whitespaces\n                tokens.append(' ');\n                lenCounter++;\n              }\n              if (lenCounter == len) {\n                break;\n              }\n            }\n            j++;\n            finalLen = j;\n          } \n        }\n\n        if (mStartNoSpace.containsKey(tok.substring(0, 1))) {\n          int j = i;\n          while (j < anTokens.length && !anTokens[j].isWhitespace()) {\n            if ((j == i) && (myCount == 1)) {\n              tokens.append(anTokens[j].getToken().toLowerCase());\n            } else {\n              tokens.append(anTokens[j].getToken());\n            }\n            final String toks = tokens.toString();\n            if (mFull.containsKey(toks)) {\n              output[i] = prepareNewReading(toks, anTokens[i].getToken(),\n                  output[i], false);\n              output[j] = prepareNewReading(toks, anTokens[j].getToken(),\n                  output[j], true);\n            }\n            j++;\n          }\n        }\n        // If it is a capitalized word, try with lowercase word.\n        myCount++;\n        if (allowFirstCapitalized && StringTools.isCapitalizedWord(tok)\n            && myCount == 1) {\n            tok = tok.toLowerCase();\n        } else {\n          myCount = 2;\n        }\n      }\n    }\n    return new AnalyzedSentence(output);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @param filename\n   *          file text with multiwords and tags\n   */\n  public MultiWordChunker(final String filename) {\n    super();\n    this.filename = filename;\n  }","id":45276,"modified_method":"/**\n   * @param filename file text with multiwords and tags\n   */\n  public MultiWordChunker(final String filename) {\n    this(filename, false);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @param filename\n   *          file text with multiwords and tags\n   * @param bAllowFirstUpperCase\n   *          if set to {@code true}, first word of the multiword can be capitalized\n   */\n  public MultiWordChunker(final String filename, boolean allowFirstCapitalized) {\n    super();\n    this.filename = filename;\n    bAllowFirstCapitalized = allowFirstCapitalized;\n  }","id":45277,"modified_method":"/**\n   * @param filename file text with multiwords and tags\n   * @param allowFirstCapitalized if set to {@code true}, first word of the multiword can be capitalized\n   */\n  public MultiWordChunker(final String filename, boolean allowFirstCapitalized) {\n    this.filename = filename;\n    this.allowFirstCapitalized = allowFirstCapitalized;\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void testSplit(String... sentences) {\n    TestTools.testSplit(sentences, tokenizer);\n  }","id":45278,"modified_method":"private void testSplit(String... sentences) {\n    SimpleSentenceTokenizer tokenizer = new SimpleSentenceTokenizer();\n    TestTools.testSplit(sentences, tokenizer);\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Load a file from the classpath using {@link Class#getResourceAsStream(String)}.\n   * \n   * @return the stream of the file\n   */\n  public static InputStream getStream(final String filename) throws IOException {\n    // the other ways to load the stream like\n    // \"Tools.class.getClass().getResourceAsStream(filename)\"\n    // don't work in a web context (using Grails):\n    final InputStream is = Tools.class.getResourceAsStream(filename);\n    if (is == null) {\n      throw new IOException(\"Could not load file from classpath : \" + filename);\n    }\n    return is;\n  }","id":45279,"modified_method":"/**\n   * Load a file from the classpath using {@link Class#getResourceAsStream(String)}.\n   *\n   * @return the stream of the file\n   */\n  public static InputStream getStream(final String path) throws IOException {\n    // the other ways to load the stream like\n    // \"Tools.class.getClass().getResourceAsStream(filename)\"\n    // don't work in a web context (using Grails):\n    final InputStream is = Tools.class.getResourceAsStream(path);\n    if (is == null) {\n      throw new IOException(\"Could not load file from classpath: '\" + path + \"'\");\n    }\n    return is;\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public XmlRuleDisambiguator(final Language language) {\n    this.language = Objects.requireNonNull(language);\n  }","id":45280,"modified_method":"public XmlRuleDisambiguator(final Language language) {\n    Objects.requireNonNull(language);\n    final String disambiguationFile =\n            JLanguageTool.getDataBroker().getResourceDir() + \"/\" + language.getShortName() + \"/\" + DISAMBIGUATION_FILE;\n    try {\n      disambiguationRules = loadPatternRules(disambiguationFile);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Problems with loading disambiguation file: \" + disambiguationFile, e);\n    }\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public AnalyzedSentence disambiguate(final AnalyzedSentence input) throws IOException {\n    AnalyzedSentence sentence = input;\n    if (disambiguationRules == null) {\n      final String disambiguationFile =\n        JLanguageTool.getDataBroker().getResourceDir() + \"/\" + language.getShortName() + \"/\" + DISAMBIGUATION_FILE;\n      try {\n        disambiguationRules = loadPatternRules(disambiguationFile);\n      } catch (final Exception e) {\n        throw new RuntimeException(\"Problems with loading disambiguation file: \" + disambiguationFile, e);\n      }\n    }\n    for (final DisambiguationPatternRule patternRule : disambiguationRules) {\n      sentence = patternRule.replace(sentence);\n    }\n    return sentence;\n  }","id":45281,"modified_method":"@Override\n  public AnalyzedSentence disambiguate(final AnalyzedSentence input) throws IOException {\n    AnalyzedSentence sentence = input;\n    for (final DisambiguationPatternRule patternRule : disambiguationRules) {\n      sentence = patternRule.replace(sentence);\n    }\n    return sentence;\n  }","commit_id":"44fc6137db6bf7726d873e772775f5787a5c1d45","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // ValueSource uses a rawtype\n    public FunctionValues getValues(Map context, LeafReaderContext leaf) throws IOException {\n        AtomicFieldData leafData = fieldData.load(leaf);\n        assert(leafData instanceof AtomicNumericFieldData);\n\n        return new CountMethodFunctionValues(this, (AtomicNumericFieldData)leafData);\n    }","id":45282,"modified_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // ValueSource uses a rawtype\n    public FunctionValues getValues(Map context, LeafReaderContext leaf) throws IOException {\n        AtomicNumericFieldData leafData = (AtomicNumericFieldData) fieldData.load(leaf);\n        final SortedNumericDoubleValues values = leafData.getDoubleValues();\n\n        return new DoubleDocValues(this) {\n          @Override\n          public double doubleVal(int doc) {\n            values.setDocument(doc);\n            return values.count();\n          }\n        };\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected CountMethodValueSource(IndexFieldData<?> fieldData) {\n        Objects.requireNonNull(fieldData);\n\n        this.fieldData = fieldData;\n    }","id":45283,"modified_method":"CountMethodValueSource(IndexFieldData<?> fieldData) {\n        Objects.requireNonNull(fieldData);\n\n        this.fieldData = fieldData;\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // ValueSource uses a rawtype\n    public FunctionValues getValues(Map context, LeafReaderContext leaf) throws IOException {\n        AtomicFieldData leafData = fieldData.load(leaf);\n        assert(leafData instanceof AtomicNumericFieldData);\n\n        return new DateMethodFunctionValues(this, multiValueMode, (AtomicNumericFieldData)leafData, calendarType);\n    }","id":45284,"modified_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // ValueSource uses a rawtype\n    public FunctionValues getValues(Map context, LeafReaderContext leaf) throws IOException {\n        AtomicNumericFieldData leafData = (AtomicNumericFieldData) fieldData.load(leaf);\n        final Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"), Locale.ROOT);\n        NumericDoubleValues docValues = multiValueMode.select(leafData.getDoubleValues(), 0d);\n        return new DoubleDocValues(this) {\n          @Override\n          public double doubleVal(int docId) {\n            long millis = (long)docValues.get(docId);\n            calendar.setTimeInMillis(millis);\n            return calendar.get(calendarType);\n          }\n        };\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected EmptyMemberValueSource(IndexFieldData<?> fieldData) {\n        this.fieldData = Objects.requireNonNull(fieldData);\n    }","id":45285,"modified_method":"EmptyMemberValueSource(IndexFieldData<?> fieldData) {\n        this.fieldData = Objects.requireNonNull(fieldData);\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SearchScript search(CompiledScript compiledScript, SearchLookup lookup, @Nullable Map<String, Object> vars) {\n        try {\n            Expression expr = (Expression)compiledScript.compiled();\n            MapperService mapper = lookup.doc().mapperService();\n            // NOTE: if we need to do anything complicated with bindings in the future, we can just extend Bindings,\n            // instead of complicating SimpleBindings (which should stay simple)\n            SimpleBindings bindings = new SimpleBindings();\n            ReplaceableConstValueSource specialValue = null;\n\n            for (String variable : expr.variables) {\n                if (variable.equals(\"_score\")) {\n                    bindings.add(new SortField(\"_score\", SortField.Type.SCORE));\n                } else if (variable.equals(\"_value\")) {\n                    specialValue = new ReplaceableConstValueSource();\n                    bindings.add(\"_value\", specialValue);\n                    // noop: _value is special for aggregations, and is handled in ExpressionScriptBindings\n                    // TODO: if some uses it in a scoring expression, they will get a nasty failure when evaluating...need a\n                    // way to know this is for aggregations and so _value is ok to have...\n\n                } else if (vars != null && vars.containsKey(variable)) {\n                    // TODO: document and/or error if vars contains _score?\n                    // NOTE: by checking for the variable in vars first, it allows masking document fields with a global constant,\n                    // but if we were to reverse it, we could provide a way to supply dynamic defaults for documents missing the field?\n                    Object value = vars.get(variable);\n                    if (value instanceof Number) {\n                        bindings.add(variable, new DoubleConstValueSource(((Number) value).doubleValue()));\n                    } else {\n                        throw new ScriptException(\"Parameter [\" + variable + \"] must be a numeric type\");\n                    }\n\n                } else {\n                    String fieldname = null;\n                    String methodname = null;\n                    String variablename = VALUE_VARIABLE; // .value is the default for doc['field'], its optional.\n                    VariableContext[] parts = VariableContext.parse(variable);\n                    if (parts[0].text.equals(\"doc\") == false) {\n                        throw new ScriptException(\"Unknown variable [\" + parts[0].text + \"] in expression\");\n                    }\n                    if (parts.length < 2 || parts[1].type != VariableContext.Type.STR_INDEX) {\n                        throw new ScriptException(\"Variable 'doc' in expression must be used with a specific field like: doc['myfield']\");\n                    } else {\n                        fieldname = parts[1].text;\n                    }\n                    if (parts.length == 3) {\n                        if (parts[2].type == VariableContext.Type.METHOD) {\n                            methodname = parts[2].text;\n                        } else if (parts[2].type == VariableContext.Type.MEMBER) {\n                            variablename = parts[2].text;\n                        } else {\n                            throw new ScriptException(\"Only member variables or member methods may be accessed on a field when not accessing the field directly\");\n                        }\n                    }\n                    if (parts.length > 3) {\n                        throw new ScriptException(\"Variable [\" + variable + \"] does not follow an allowed format of either doc['field'] or doc['field'].method()\");\n                    }\n\n                    MappedFieldType fieldType = mapper.fullName(fieldname);\n\n                    if (fieldType == null) {\n                        throw new ScriptException(\"Field [\" + fieldname + \"] used in expression does not exist in mappings\");\n                    }\n\n                    IndexFieldData<?> fieldData = lookup.doc().fieldDataService().getForField(fieldType);\n                    if (fieldData instanceof IndexNumericFieldData == false) {\n                        // TODO: more context (which expression?)\n                        throw new ScriptException(\"Field [\" + fieldname + \"] used in expression must be numeric\");\n                    }\n                    if (methodname == null) {\n                        bindings.add(variable, getVariableValueSource(fieldType, fieldData, fieldname, variablename));\n                    } else {\n                        bindings.add(variable, getMethodValueSource(fieldType, fieldData, fieldname, methodname));\n                    }\n                }\n            }\n\n            final boolean needsScores = expr.getSortField(bindings, false).needsScores();\n            return new ExpressionSearchScript(compiledScript, bindings, specialValue, needsScores);\n        } catch (Exception exception) {\n            throw new ScriptException(\"Error during search with \" + compiledScript, exception);\n        }\n    }","id":45286,"modified_method":"@Override\n    public SearchScript search(CompiledScript compiledScript, SearchLookup lookup, @Nullable Map<String, Object> vars) {\n        try {\n            Expression expr = (Expression)compiledScript.compiled();\n            MapperService mapper = lookup.doc().mapperService();\n            // NOTE: if we need to do anything complicated with bindings in the future, we can just extend Bindings,\n            // instead of complicating SimpleBindings (which should stay simple)\n            SimpleBindings bindings = new SimpleBindings();\n            ReplaceableConstValueSource specialValue = null;\n\n            for (String variable : expr.variables) {\n                if (variable.equals(\"_score\")) {\n                    bindings.add(new SortField(\"_score\", SortField.Type.SCORE));\n                } else if (variable.equals(\"_value\")) {\n                    specialValue = new ReplaceableConstValueSource();\n                    bindings.add(\"_value\", specialValue);\n                    // noop: _value is special for aggregations, and is handled in ExpressionScriptBindings\n                    // TODO: if some uses it in a scoring expression, they will get a nasty failure when evaluating...need a\n                    // way to know this is for aggregations and so _value is ok to have...\n\n                } else if (vars != null && vars.containsKey(variable)) {\n                    // TODO: document and/or error if vars contains _score?\n                    // NOTE: by checking for the variable in vars first, it allows masking document fields with a global constant,\n                    // but if we were to reverse it, we could provide a way to supply dynamic defaults for documents missing the field?\n                    Object value = vars.get(variable);\n                    if (value instanceof Number) {\n                        bindings.add(variable, new DoubleConstValueSource(((Number) value).doubleValue()));\n                    } else {\n                        throw new ScriptException(\"Parameter [\" + variable + \"] must be a numeric type\");\n                    }\n\n                } else {\n                    String fieldname = null;\n                    String methodname = null;\n                    String variablename = \"value\"; // .value is the default for doc['field'], its optional.\n                    VariableContext[] parts = VariableContext.parse(variable);\n                    if (parts[0].text.equals(\"doc\") == false) {\n                        throw new ScriptException(\"Unknown variable [\" + parts[0].text + \"] in expression\");\n                    }\n                    if (parts.length < 2 || parts[1].type != VariableContext.Type.STR_INDEX) {\n                        throw new ScriptException(\"Variable 'doc' in expression must be used with a specific field like: doc['myfield']\");\n                    } else {\n                        fieldname = parts[1].text;\n                    }\n                    if (parts.length == 3) {\n                        if (parts[2].type == VariableContext.Type.METHOD) {\n                            methodname = parts[2].text;\n                        } else if (parts[2].type == VariableContext.Type.MEMBER) {\n                            variablename = parts[2].text;\n                        } else {\n                            throw new ScriptException(\"Only member variables or member methods may be accessed on a field when not accessing the field directly\");\n                        }\n                    }\n                    if (parts.length > 3) {\n                        throw new ScriptException(\"Variable [\" + variable + \"] does not follow an allowed format of either doc['field'] or doc['field'].method()\");\n                    }\n\n                    MappedFieldType fieldType = mapper.fullName(fieldname);\n\n                    if (fieldType == null) {\n                        throw new ScriptException(\"Field [\" + fieldname + \"] used in expression does not exist in mappings\");\n                    }\n\n                    IndexFieldData<?> fieldData = lookup.doc().fieldDataService().getForField(fieldType);\n                    \n                    // delegate valuesource creation based on field's type\n                    // there are three types of \"fields\" to expressions, and each one has a different \"api\" of variables and methods.\n                    \n                    final ValueSource valueSource;\n                    if (fieldType instanceof BaseGeoPointFieldMapper.GeoPointFieldType) {\n                        // geo\n                        if (methodname == null) {\n                            valueSource = GeoField.getVariable(fieldData, fieldname, variablename);\n                        } else {\n                            valueSource = GeoField.getMethod(fieldData, fieldname, methodname);\n                        }\n                    } else if (fieldType instanceof LegacyDateFieldMapper.DateFieldType || \n                            fieldType instanceof DateFieldMapper.DateFieldType) {\n                        // date\n                        if (methodname == null) {\n                            valueSource = DateField.getVariable(fieldData, fieldname, variablename);\n                        } else {\n                            valueSource = DateField.getMethod(fieldData, fieldname, methodname);\n                        }\n                    } else if (fieldData instanceof IndexNumericFieldData) {\n                        // number\n                        if (methodname == null) {\n                            valueSource = NumericField.getVariable(fieldData, fieldname, variablename);\n                        } else {\n                            valueSource = NumericField.getMethod(fieldData, fieldname, methodname);\n                        }\n                    } else {\n                        throw new ScriptException(\"Field [\" + fieldname + \"] used in expression must be numeric, date, or geopoint\");\n                    }\n                    \n                    bindings.add(variable, valueSource);\n                }\n            }\n\n            final boolean needsScores = expr.getSortField(bindings, false).needsScores();\n            return new ExpressionSearchScript(compiledScript, bindings, specialValue, needsScores);\n        } catch (Exception exception) {\n            throw new ScriptException(\"Error during search with \" + compiledScript, exception);\n        }\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected FieldDataValueSource(IndexFieldData<?> d, MultiValueMode m) {\n        Objects.requireNonNull(d);\n        Objects.requireNonNull(m);\n\n        fieldData = d;\n        multiValueMode = m;\n    }","id":45287,"modified_method":"protected FieldDataValueSource(IndexFieldData<?> fieldData, MultiValueMode multiValueMode) {\n        this.fieldData = Objects.requireNonNull(fieldData);\n        this.multiValueMode = Objects.requireNonNull(multiValueMode);\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // ValueSource uses a rawtype\n    public FunctionValues getValues(Map context, LeafReaderContext leaf) throws IOException {\n        AtomicFieldData leafData = fieldData.load(leaf);\n        assert(leafData instanceof AtomicNumericFieldData);\n        return new FieldDataFunctionValues(this, multiValueMode, (AtomicNumericFieldData)leafData);\n    }","id":45288,"modified_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // ValueSource uses a rawtype\n    public FunctionValues getValues(Map context, LeafReaderContext leaf) throws IOException {\n        AtomicNumericFieldData leafData = (AtomicNumericFieldData) fieldData.load(leaf);\n        NumericDoubleValues docValues = multiValueMode.select(leafData.getDoubleValues(), 0d);\n        return new DoubleDocValues(this) {\n          @Override\n          public double doubleVal(int doc) {\n            return docValues.get(doc);\n          }\n        };\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testInvalidDateMethodCall() throws Exception {\n        ElasticsearchAssertions.assertAcked(prepareCreate(\"test\").addMapping(\"doc\", \"double\", \"type=double\"));\n        ensureGreen(\"test\");\n        indexRandom(true, client().prepareIndex(\"test\", \"doc\", \"1\").setSource(\"double\", \"178000000.0\"));\n        try {\n            buildRequest(\"doc['double'].getYear()\").get();\n            fail();\n        } catch (SearchPhaseExecutionException e) {\n            assertThat(e.toString() + \"should have contained IllegalArgumentException\",\n                    e.toString().contains(\"IllegalArgumentException\"), equalTo(true));\n            assertThat(e.toString() + \"should have contained can only be used with a date field type\",\n                    e.toString().contains(\"can only be used with a date field type\"), equalTo(true));\n        }\n    }","id":45289,"modified_method":"public void testInvalidDateMethodCall() throws Exception {\n        ElasticsearchAssertions.assertAcked(prepareCreate(\"test\").addMapping(\"doc\", \"double\", \"type=double\"));\n        ensureGreen(\"test\");\n        indexRandom(true, client().prepareIndex(\"test\", \"doc\", \"1\").setSource(\"double\", \"178000000.0\"));\n        try {\n            buildRequest(\"doc['double'].getYear()\").get();\n            fail();\n        } catch (SearchPhaseExecutionException e) {\n            assertThat(e.toString() + \"should have contained IllegalArgumentException\",\n                    e.toString().contains(\"IllegalArgumentException\"), equalTo(true));\n            assertThat(e.toString() + \"should have contained does not exist for numeric field\",\n                    e.toString().contains(\"does not exist for numeric field\"), equalTo(true));\n        }\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void setValue(double value) {\n        this.value = value;\n    }","id":45290,"modified_method":"void setValue(double value) {\n        this.value = value;\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ReplaceableConstValueSource() {\n        fv = new ReplaceableConstFunctionValues();\n    }","id":45291,"modified_method":"ReplaceableConstValueSource() {\n        fv = new ReplaceableConstFunctionValues();\n    }","commit_id":"693c1f667142f322e6faaf1abacee79c66660b37","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ClassLoaderScope export(ClassPath classPath) {\n        if (classPath.isEmpty()) {\n            return this;\n        }\n\n        assertNotLocked();\n        if (exportingClassLoader != null) {\n            exportingClassLoader.addParent(loader(id.exportId().getId(), classPath));\n        } else {\n            export = export.plus(classPath);\n        }\n\n        return this;\n    }","id":45292,"modified_method":"public ClassLoaderScope export(ClassPath classPath) {\n        if (classPath.isEmpty()) {\n            return this;\n        }\n\n        assertNotLocked();\n        if (exportingClassLoader != null) {\n            exportingClassLoader.addParent(loader(id.exportId(), classPath));\n        } else {\n            export = export.plus(classPath);\n        }\n\n        return this;\n    }","commit_id":"3a8925a3ae0dd28508459a22efa05df062833326","url":"https://github.com/gradle/gradle"},{"original_method":"private void buildEffectiveLoaders() {\n        if (effectiveLocalClassLoader == null) {\n            if (locked) {\n                if (local.isEmpty() && export.isEmpty()) {\n                    effectiveLocalClassLoader = parent.getExportClassLoader();\n                    effectiveExportClassLoader = parent.getExportClassLoader();\n                } else if (export.isEmpty()) {\n                    effectiveLocalClassLoader = buildLockedLoader(id.localId().getId(), local);\n                    effectiveExportClassLoader = parent.getExportClassLoader();\n                } else if (local.isEmpty()) {\n                    effectiveLocalClassLoader = buildLockedLoader(id.exportId().getId(), export);\n                    effectiveExportClassLoader = effectiveLocalClassLoader;\n                } else {\n                    effectiveExportClassLoader = buildLockedLoader(id.exportId().getId(), export);\n                    effectiveLocalClassLoader = buildLockedLoader(id.localId().getId(), effectiveExportClassLoader, local);\n                }\n            } else { // creating before locking, have to create the most flexible setup\n                if (Boolean.getBoolean(STRICT_MODE_PROPERTY)) {\n                    throw new IllegalStateException(\"Attempt to define scope class loader before scope is locked\");\n                }\n\n                exportingClassLoader = new MultiParentClassLoader(parent.getExportClassLoader(), loader(id.exportId().getId(), export));\n                effectiveExportClassLoader = new CachingClassLoader(exportingClassLoader);\n\n                localClassLoader = new MultiParentClassLoader(effectiveExportClassLoader, loader(id.localId().getId(), local));\n                effectiveLocalClassLoader = new CachingClassLoader(localClassLoader);\n            }\n\n            export = null;\n            local = null;\n        }\n    }","id":45293,"modified_method":"private void buildEffectiveLoaders() {\n        if (effectiveLocalClassLoader == null) {\n            if (locked) {\n                if (local.isEmpty() && export.isEmpty()) {\n                    effectiveLocalClassLoader = parent.getExportClassLoader();\n                    effectiveExportClassLoader = parent.getExportClassLoader();\n                } else if (export.isEmpty()) {\n                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), local);\n                    effectiveExportClassLoader = parent.getExportClassLoader();\n                } else if (local.isEmpty()) {\n                    effectiveLocalClassLoader = buildLockedLoader(id.exportId(), export);\n                    effectiveExportClassLoader = effectiveLocalClassLoader;\n                } else {\n                    effectiveExportClassLoader = buildLockedLoader(id.exportId(), export);\n                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), effectiveExportClassLoader, local);\n                }\n            } else { // creating before locking, have to create the most flexible setup\n                if (Boolean.getBoolean(STRICT_MODE_PROPERTY)) {\n                    throw new IllegalStateException(\"Attempt to define scope class loader before scope is locked\");\n                }\n\n                exportingClassLoader = new MultiParentClassLoader(parent.getExportClassLoader(), loader(id.exportId(), export));\n                effectiveExportClassLoader = new CachingClassLoader(exportingClassLoader);\n\n                localClassLoader = new MultiParentClassLoader(effectiveExportClassLoader, loader(id.localId(), local));\n                effectiveLocalClassLoader = new CachingClassLoader(localClassLoader);\n            }\n\n            export = null;\n            local = null;\n        }\n    }","commit_id":"3a8925a3ae0dd28508459a22efa05df062833326","url":"https://github.com/gradle/gradle"},{"original_method":"public ClassLoaderScope local(ClassPath classPath) {\n        if (classPath.isEmpty()) {\n            return this;\n        }\n\n        assertNotLocked();\n        if (localClassLoader != null) {\n            ClassLoader loader = loader(id.localId().getId(), classPath);\n            localClassLoader.addParent(loader);\n        } else {\n            local = local.plus(classPath);\n        }\n\n        return this;\n    }","id":45294,"modified_method":"public ClassLoaderScope local(ClassPath classPath) {\n        if (classPath.isEmpty()) {\n            return this;\n        }\n\n        assertNotLocked();\n        if (localClassLoader != null) {\n            ClassLoader loader = loader(id.localId(), classPath);\n            localClassLoader.addParent(loader);\n        } else {\n            local = local.plus(classPath);\n        }\n\n        return this;\n    }","commit_id":"3a8925a3ae0dd28508459a22efa05df062833326","url":"https://github.com/gradle/gradle"},{"original_method":"public ScopeNodeIdentifier newChild() {\n        return new ScopeNodeIdentifier(node + \":c\" + generator.generateId(), new LongIdGenerator());\n    }","id":45295,"modified_method":"/**\n     * creates new child node identifier\n     */\n    ScopeNodeIdentifier newChild() {\n        return new ScopeNodeIdentifier(node + \":c\" + generator.generateId(), new LongIdGenerator());\n    }","commit_id":"3a8925a3ae0dd28508459a22efa05df062833326","url":"https://github.com/gradle/gradle"},{"original_method":"public ScopeNodeIdentifier localId() {\n        return new ScopeNodeIdentifier(node.concat(\"-local\"), new LongIdGenerator());\n    }","id":45296,"modified_method":"/**\n     * local classloader id of this node\n     */\n    ClassLoaderId localId() {\n        return ClassLoaderIds.scopeNode(node.concat(\"-local\"));\n    }","commit_id":"3a8925a3ae0dd28508459a22efa05df062833326","url":"https://github.com/gradle/gradle"},{"original_method":"public ScopeNodeIdentifier exportId() {\n        return new ScopeNodeIdentifier(node.concat(\"-export\"), new LongIdGenerator());\n    }","id":45297,"modified_method":"/**\n     * export classloader id of this node\n     */\n    ClassLoaderId exportId() {\n        return ClassLoaderIds.scopeNode(node.concat(\"-export\"));\n    }","commit_id":"3a8925a3ae0dd28508459a22efa05df062833326","url":"https://github.com/gradle/gradle"},{"original_method":"public static boolean isNonNlsAnnotated(@Nullable PsiExpression expression) {\n        if (isReferenceToNonNlsAnnotatedElement(expression)) {\n            return true;\n        }\n        if (expression instanceof PsiMethodCallExpression) {\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression) expression;\n            final PsiMethod method = methodCallExpression.resolveMethod();\n            return isNonNlsAnnotatedModifierListOwner(method);\n        }\n        return false;\n    }","id":45298,"modified_method":"public static boolean isNonNlsAnnotated(@Nullable PsiExpression expression) {\n        if (isReferenceToNonNlsAnnotatedElement(expression)) {\n            return true;\n        }\n        if (expression instanceof PsiMethodCallExpression) {\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression) expression;\n            final PsiMethod method = methodCallExpression.resolveMethod();\n\t        if (isNonNlsAnnotatedModifierListOwner(method)) {\n\t\t        return true;\n\t        }\n\t        final PsiReferenceExpression methodExpression =\n\t\t\t        methodCallExpression.getMethodExpression();\n\t        final PsiExpression qualifier = methodExpression.getQualifierExpression();\n\t        return isNonNlsAnnotated(qualifier);\n        } else if (expression instanceof PsiArrayAccessExpression) {\n\t        final PsiArrayAccessExpression arrayAccessExpression =\n\t\t\t        (PsiArrayAccessExpression)expression;\n\t        final PsiExpression arrayExpression = arrayAccessExpression.getArrayExpression();\n\t        return isNonNlsAnnotated(arrayExpression);\n        }\n        return false;\n    }","commit_id":"081f2ea990282e84d3453cf0b9d0d384525861e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isNonNlsAnnotatedUse(\n            @Nullable PsiExpression expression) {\n        final PsiElement element =\n                PsiTreeUtil.getParentOfType(expression,\n                        PsiExpressionList.class,\n                        PsiAssignmentExpression.class,\n                        PsiVariable.class,\n                        PsiReturnStatement.class);\n        if (element instanceof PsiExpressionList) {\n            final PsiExpressionList expressionList = (PsiExpressionList) element;\n            return isNonNlsAnnotatedParameter(expression, expressionList);\n        } else if (element instanceof PsiVariable) {\n            return isNonNlsAnnotatedModifierListOwner(element);\n        } else if (element instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression assignmentExpression =\n                    (PsiAssignmentExpression) element;\n            return isAssignmentToNonNlsAnnotatedVariable(assignmentExpression);\n        } else if (element instanceof PsiReturnStatement) {\n            final PsiMethod method =\n                    PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n            return isNonNlsAnnotatedModifierListOwner(method);\n        }\n        return false;\n    }","id":45299,"modified_method":"public static boolean isNonNlsAnnotatedUse(\n            @Nullable PsiExpression expression) {\n        final PsiElement element =\n                PsiTreeUtil.getParentOfType(expression,\n                        PsiExpressionList.class,\n                        PsiAssignmentExpression.class,\n                        PsiVariable.class,\n                        PsiReturnStatement.class);\n        final PsiElement parent = expression.getParent();\n        if (parent instanceof PsiExpression) {\n            final PsiExpression parentExpression = (PsiExpression)parent;\n            final Boolean data = parentExpression.getUserData(KEY);\n            if (data != null) {\n                expression.putUserData(KEY, data);\n                return data.booleanValue();\n            }\n        }\n        final boolean result;\n        if (element instanceof PsiExpressionList) {\n            final PsiExpressionList expressionList = (PsiExpressionList) element;\n            result = isNonNlsAnnotatedParameter(expression, expressionList);\n        } else if (element instanceof PsiVariable) {\n            result = isNonNlsAnnotatedModifierListOwner(element);\n        } else if (element instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression assignmentExpression =\n                    (PsiAssignmentExpression) element;\n            result = isAssignmentToNonNlsAnnotatedVariable(assignmentExpression);\n        } else if (element instanceof PsiReturnStatement) {\n            final PsiMethod method =\n                    PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n            result = isNonNlsAnnotatedModifierListOwner(method);\n        } else {\n            result = false;\n        }\n        expression.putUserData(KEY, Boolean.valueOf(result));\n        return result;\n    }","commit_id":"20eee3283378ff00e48163dcaf075e43776aed47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Action to execute if confirm button is clicked\n     * @param mapping ActionMapping\n     * @param formIn ActionForm\n     * @param request ServletRequest\n     * @param response ServletResponse\n     * @return The ActionForward to go to next.\n     */\n    public ActionForward confirmPatch(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        User user = requestContext.getLoggedInUser();\n        Long sid = requestContext.getRequiredParam(\"sid\");\n        Server server = SystemManager.lookupByIdAndUser(sid, user);\n        RhnSet set = RhnSetDecl.PATCH_INSTALL.get(user);\n\n        int numPatches = set.size();\n\n        if (set != null) {\n             Action install = ActionManager.createPatchInstallAction(user, server, set);\n\n             ActionManager.storeAction(install); //commit action\n             RhnSetDecl.PATCH_INSTALL.clear(user);\n\n             ActionMessages msgs = new ActionMessages();\n\n             /**\n              * If there was only one action archived, display the \"action\" archived\n              * message, else display the \"actions\" archived message.\n              */\n             if (numPatches == 1) {\n                 msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                          new ActionMessage(\"message.patchinstall\",\n                                  LocalizationService.getInstance()\n                                      .formatNumber(new Integer(numPatches)),\n                                  install.getId().toString(),\n                                  sid.toString(),\n                                  server.getName()));\n             }\n             else {\n                 msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                          new ActionMessage(\"message.patchinstalls\",\n                                  LocalizationService.getInstance()\n                                  .formatNumber(new Integer(numPatches)),\n                              install.getId().toString(),\n                              sid.toString(),\n                              server.getName()));\n             }\n\n             strutsDelegate.saveMessages(request, msgs);\n\n             Map params = makeParamMap(request);\n             return strutsDelegate.forwardParams(mapping.findForward(\"installed\"), params);\n        }\n        /*\n         * Everything is not ok.\n         * TODO: error msg\n         */\n        Map params = makeParamMap(request);\n        return strutsDelegate.forwardParams(mapping.findForward(\"default\"), params);\n    }","id":45300,"modified_method":"/**\n     * Action to execute if confirm button is clicked\n     * @param mapping ActionMapping\n     * @param formIn ActionForm\n     * @param request ServletRequest\n     * @param response ServletResponse\n     * @return The ActionForward to go to next.\n     */\n    public ActionForward confirmPatch(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        User user = requestContext.getLoggedInUser();\n        Long sid = requestContext.getRequiredParam(\"sid\");\n        Server server = SystemManager.lookupByIdAndUser(sid, user);\n        RhnSet set = RhnSetDecl.PATCH_INSTALL.get(user);\n\n        int numPatches = set.size();\n\n         Action install = ActionManager.createPatchInstallAction(user, server, set);\n\n         ActionManager.storeAction(install); //commit action\n         RhnSetDecl.PATCH_INSTALL.clear(user);\n\n         ActionMessages msgs = new ActionMessages();\n\n         /**\n          * If there was only one action archived, display the \"action\" archived\n          * message, else display the \"actions\" archived message.\n          */\n         if (numPatches == 1) {\n             msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                      new ActionMessage(\"message.patchinstall\",\n                              LocalizationService.getInstance()\n                                  .formatNumber(new Integer(numPatches)),\n                              install.getId().toString(),\n                              sid.toString(),\n                              server.getName()));\n         }\n         else {\n             msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                      new ActionMessage(\"message.patchinstalls\",\n                              LocalizationService.getInstance()\n                              .formatNumber(new Integer(numPatches)),\n                          install.getId().toString(),\n                          sid.toString(),\n                          server.getName()));\n         }\n\n         strutsDelegate.saveMessages(request, msgs);\n\n         Map params = makeParamMap(request);\n         return strutsDelegate.forwardParams(mapping.findForward(\"installed\"), params);\n    }","commit_id":"4db0310c6a431c84498d288469a9f0f013e9e341","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Action to execute if confirm button is clicked\n     * @param mapping ActionMapping\n     * @param formIn ActionForm\n     * @param request ServletRequest\n     * @param response ServletResponse\n     * @return The ActionForward to go to next.\n     */\n    public ActionForward confirmPatch(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        User user = requestContext.getLoggedInUser();\n        Long sid = requestContext.getRequiredParam(\"sid\");\n        Server server = SystemManager.lookupByIdAndUser(sid, user);\n        RhnSet set = RhnSetDecl.PATCH_REMOVE.get(user);\n\n        int numPatches = set.size();\n\n        if (set != null) {\n             Action remove = ActionManager.createPatchRemoveAction(user, server, set);\n\n             ActionManager.storeAction(remove); //commit action\n             RhnSetDecl.PATCH_REMOVE.clear(user);\n\n             ActionMessages msgs = new ActionMessages();\n\n             /**\n              * If there was only one action archived, display the \"action\" archived\n              * message, else display the \"actions\" archived message.\n              */\n             if (numPatches == 1) {\n                 msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                          new ActionMessage(\"message.patchremoval\",\n                                  LocalizationService.getInstance()\n                                      .formatNumber(new Integer(numPatches)),\n                                  remove.getId().toString(),\n                                  sid.toString(),\n                                  server.getName()));\n             }\n             else {\n                 msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                          new ActionMessage(\"message.patchremovals\",\n                                  LocalizationService.getInstance()\n                                  .formatNumber(new Integer(numPatches)),\n                              remove.getId().toString(),\n                              sid.toString(),\n                              server.getName()));\n             }\n\n             strutsDelegate.saveMessages(request, msgs);\n\n             Map params = makeParamMap(request);\n             return strutsDelegate.forwardParams(mapping.findForward(\"confirmed\"), params);\n        }\n        /*\n         * Everything is not ok.\n         * TODO: error msg\n         */\n        Map params = makeParamMap(request);\n        return strutsDelegate.forwardParams(mapping.findForward(\"default\"), params);\n    }","id":45301,"modified_method":"/**\n     * Action to execute if confirm button is clicked\n     * @param mapping ActionMapping\n     * @param formIn ActionForm\n     * @param request ServletRequest\n     * @param response ServletResponse\n     * @return The ActionForward to go to next.\n     */\n    public ActionForward confirmPatch(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        User user = requestContext.getLoggedInUser();\n        Long sid = requestContext.getRequiredParam(\"sid\");\n        Server server = SystemManager.lookupByIdAndUser(sid, user);\n        RhnSet set = RhnSetDecl.PATCH_REMOVE.get(user);\n\n        int numPatches = set.size();\n\n         Action remove = ActionManager.createPatchRemoveAction(user, server, set);\n\n         ActionManager.storeAction(remove); //commit action\n         RhnSetDecl.PATCH_REMOVE.clear(user);\n\n         ActionMessages msgs = new ActionMessages();\n\n         /**\n          * If there was only one action archived, display the \"action\" archived\n          * message, else display the \"actions\" archived message.\n          */\n         if (numPatches == 1) {\n             msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                      new ActionMessage(\"message.patchremoval\",\n                              LocalizationService.getInstance()\n                                  .formatNumber(new Integer(numPatches)),\n                              remove.getId().toString(),\n                              sid.toString(),\n                              server.getName()));\n         }\n         else {\n             msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                      new ActionMessage(\"message.patchremovals\",\n                              LocalizationService.getInstance()\n                              .formatNumber(new Integer(numPatches)),\n                          remove.getId().toString(),\n                          sid.toString(),\n                          server.getName()));\n         }\n\n         strutsDelegate.saveMessages(request, msgs);\n\n         Map params = makeParamMap(request);\n         return strutsDelegate.forwardParams(mapping.findForward(\"confirmed\"), params);\n    }","commit_id":"7ae8cbc74f80aa207efdd894578ee4345bfdf794","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private ActionForward returnError(ActionMapping mapping,\n                                      HttpServletRequest request,\n                                      ActionErrors errors) {\n        addErrors(request, errors);\n        String accountType = request.getParameter(ACCOUNT_TYPE);\n\n        if (accountType != null && accountType.equals(TYPE_CREATE_SAT)) {\n            return getStrutsDelegate().forwardParam(mapping.findForward(FAILURE_SATELLITE),\n                             ACCOUNT_TYPE, TYPE_CREATE_SAT);\n        }\n        return mapping.findForward(FAILURE);\n    }","id":45302,"modified_method":"private ActionForward returnError(ActionMapping mapping,\n                                      HttpServletRequest request,\n                                      ActionErrors errors) {\n        addErrors(request, errors);\n        return mapping.findForward(FAILURE);\n    }","commit_id":"1ad0068a98e1d757f118db08edbbf392135968f8","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm formIn,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n\n        DynaActionForm form = (DynaActionForm)formIn;\n\n        /*\n         * If the usepam checkbox has been checked, the password fields aren't required.\n         * Since password is required in the db and since in all other cases it is required,\n         * we'll trick the validation by doing all of the manipulation before validating\n         * the form.\n         *\n         * Also, if the user for some reason does want to set a default password to stick\n         * in the db (even though it won't be used), we'll just validate it like a regular\n         * password and allow it.\n         */\n        if (form.get(\"usepam\") != null && ((Boolean) form.get(\"usepam\")).booleanValue()) {\n            String hash = MD5Crypt.crypt(\"\" + System.currentTimeMillis());\n            if (form.get(UserActionHelper.DESIRED_PASS) == null ||\n                    form.get(UserActionHelper.DESIRED_PASS).equals(\"\")) {\n                form.set(UserActionHelper.DESIRED_PASS, hash);\n            }\n            if (form.get(UserActionHelper.DESIRED_PASS_CONFIRM) == null ||\n                    form.get(UserActionHelper.DESIRED_PASS_CONFIRM).equals(\"\")) {\n                form.set(UserActionHelper.DESIRED_PASS_CONFIRM, hash);\n            }\n        }\n\n        // Validate the form\n        ActionErrors verrors = RhnValidationHelper.validateDynaActionForm(this, form);\n        if (!verrors.isEmpty()) {\n            RhnValidationHelper.setFailedValidation(request);\n            return returnError(mapping, request, verrors);\n        }\n\n        // Create the user and do some more validation\n        CreateUserCommand command = getCommand();\n        ActionErrors errors = populateCommand(form, command);\n        if (!errors.isEmpty()) {\n            return returnError(mapping, request, errors);\n        }\n\n        String accountType = (String)form.get(ACCOUNT_TYPE);\n        if (!validateAccountType(accountType)) {\n            return returnError(mapping, request, errors);\n        }\n\n        ActionMessages msgs = new ActionMessages();\n\n        if (accountType.equals(TYPE_INTO_ORG)) {\n            User user = createIntoOrg(requestContext, command,\n                    (String) form.get(UserActionHelper.DESIRED_PASS),\n                    msgs);\n            User orgAdmin = requestContext.getCurrentUser();\n            saveMessages(request, msgs);\n            command.publishNewUserEvent(orgAdmin, orgAdmin.getOrg().getActiveOrgAdmins(),\n                    request.getServerName(),\n                    (String) form.get(UserActionHelper.DESIRED_PASS));\n\n            user.setTimeZone(UserManager.getTimeZone(((Integer) form.get(\"timezone\"))\n                .intValue()));\n            String preferredLocale = form.getString(\"preferredLocale\");\n            if (preferredLocale != null && preferredLocale.equals(\"none\")) {\n                preferredLocale = null;\n            }\n            user.setPreferredLocale(preferredLocale);\n            user.setReadOnly(form.get(\"readonly\") != null ? true : false);\n            UserManager.storeUser(user);\n\n            return getStrutsDelegate().forwardParam(mapping.findForward(SUCCESS_INTO_ORG),\n                    \"uid\", String.valueOf(user.getId()));\n\n        }\n        else if (accountType.equals(TYPE_CREATE_SAT)) {\n            User user = createSatUser(requestContext, command, msgs);\n            saveMessages(request, msgs);\n            pxtDelegate.updateWebUserId(request, response, user.getId());\n            return mapping.findForward(SUCCESS_SAT);\n        }\n\n        // we're screwed if we get this far\n        return mapping.findForward(FAILURE);\n    }","id":45303,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm formIn,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n\n        DynaActionForm form = (DynaActionForm)formIn;\n\n        /*\n         * If the usepam checkbox has been checked, the password fields aren't required.\n         * Since password is required in the db and since in all other cases it is required,\n         * we'll trick the validation by doing all of the manipulation before validating\n         * the form.\n         *\n         * Also, if the user for some reason does want to set a default password to stick\n         * in the db (even though it won't be used), we'll just validate it like a regular\n         * password and allow it.\n         */\n        if (form.get(\"usepam\") != null && ((Boolean) form.get(\"usepam\")).booleanValue()) {\n            String hash = MD5Crypt.crypt(\"\" + System.currentTimeMillis());\n            if (form.get(UserActionHelper.DESIRED_PASS) == null ||\n                    form.get(UserActionHelper.DESIRED_PASS).equals(\"\")) {\n                form.set(UserActionHelper.DESIRED_PASS, hash);\n            }\n            if (form.get(UserActionHelper.DESIRED_PASS_CONFIRM) == null ||\n                    form.get(UserActionHelper.DESIRED_PASS_CONFIRM).equals(\"\")) {\n                form.set(UserActionHelper.DESIRED_PASS_CONFIRM, hash);\n            }\n        }\n\n        // Validate the form\n        ActionErrors verrors = RhnValidationHelper.validateDynaActionForm(this, form);\n        if (!verrors.isEmpty()) {\n            RhnValidationHelper.setFailedValidation(request);\n            return returnError(mapping, request, verrors);\n        }\n\n        // Create the user and do some more validation\n        CreateUserCommand command = getCommand();\n        ActionErrors errors = populateCommand(form, command);\n        if (!errors.isEmpty()) {\n            return returnError(mapping, request, errors);\n        }\n\n        ActionMessages msgs = new ActionMessages();\n\n        User user = createIntoOrg(requestContext, command,\n                (String) form.get(UserActionHelper.DESIRED_PASS),\n                msgs);\n        User orgAdmin = requestContext.getCurrentUser();\n        saveMessages(request, msgs);\n        command.publishNewUserEvent(orgAdmin, orgAdmin.getOrg().getActiveOrgAdmins(),\n                request.getServerName(),\n                (String) form.get(UserActionHelper.DESIRED_PASS));\n\n        user.setTimeZone(UserManager.getTimeZone(((Integer) form.get(\"timezone\"))\n            .intValue()));\n        String preferredLocale = form.getString(\"preferredLocale\");\n        if (preferredLocale != null && preferredLocale.equals(\"none\")) {\n            preferredLocale = null;\n        }\n        user.setPreferredLocale(preferredLocale);\n        user.setReadOnly(form.get(\"readonly\") != null ? true : false);\n        UserManager.storeUser(user);\n\n        return getStrutsDelegate().forwardParam(mapping.findForward(SUCCESS_INTO_ORG),\n                \"uid\", String.valueOf(user.getId()));\n    }","commit_id":"1ad0068a98e1d757f118db08edbbf392135968f8","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * @return Properly filled out user creation form.\n     */\n    private RhnMockDynaActionForm fillOutForm(String formName, String accountType) {\n        RhnMockDynaActionForm f = new RhnMockDynaActionForm(formName);\n        f.set(\"login\", \"testUser\" + TestUtils.randomString());\n        f.set(\"account_type\", accountType);\n        f.set(\"address1\", \"123 somewhere ln\");\n        f.set(\"address2\", \"\");\n        f.set(\"city\", \"Cincinnati\");\n        f.set(\"contact_email\", new Boolean(true));\n        f.set(\"contact_fax\", new Boolean(true));\n        f.set(\"contact_partner\", \"\");\n        f.set(\"company\", \"Red Hat\");\n        f.set(\"country\", \"US\");\n        f.set(\"email\", \"foobar@redhat.com\");\n        f.set(\"fax\", \"\");\n        f.set(\"firstNames\", \"CreateUserActionTest fname\");\n        f.set(\"lastName\", \"CreateUserActionTest lname\");\n        f.set(UserActionHelper.DESIRED_PASS, \"password\");\n        f.set(UserActionHelper.DESIRED_PASS_CONFIRM, \"password\");\n        f.set(\"phone\", \"123-123-1234\");\n        f.set(\"prefix\", \"Mr.\");\n        f.set(\"state\", \"OH\");\n        f.set(\"title\", \"Heavyweight\");\n        f.set(\"zip\", \"45241\");\n        f.set(\"timezone\", new Integer(7010));\n        f.set(\"preferredLocale\", \"en_US\");\n        return f;\n    }","id":45304,"modified_method":"/**\n     * @return Properly filled out user creation form.\n     */\n    private RhnMockDynaActionForm fillOutForm(String formName) {\n        RhnMockDynaActionForm f = new RhnMockDynaActionForm(formName);\n        f.set(\"login\", \"testUser\" + TestUtils.randomString());\n        f.set(\"address1\", \"123 somewhere ln\");\n        f.set(\"address2\", \"\");\n        f.set(\"city\", \"Cincinnati\");\n        f.set(\"contact_email\", new Boolean(true));\n        f.set(\"contact_fax\", new Boolean(true));\n        f.set(\"contact_partner\", \"\");\n        f.set(\"company\", \"Red Hat\");\n        f.set(\"country\", \"US\");\n        f.set(\"email\", \"foobar@redhat.com\");\n        f.set(\"fax\", \"\");\n        f.set(\"firstNames\", \"CreateUserActionTest fname\");\n        f.set(\"lastName\", \"CreateUserActionTest lname\");\n        f.set(UserActionHelper.DESIRED_PASS, \"password\");\n        f.set(UserActionHelper.DESIRED_PASS_CONFIRM, \"password\");\n        f.set(\"phone\", \"123-123-1234\");\n        f.set(\"prefix\", \"Mr.\");\n        f.set(\"state\", \"OH\");\n        f.set(\"title\", \"Heavyweight\");\n        f.set(\"zip\", \"45241\");\n        f.set(\"timezone\", new Integer(7010));\n        f.set(\"preferredLocale\", \"en_US\");\n        return f;\n    }","commit_id":"1ad0068a98e1d757f118db08edbbf392135968f8","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testNewUserIntoOrgSatellite() throws Exception {\n\n\n        setRequestPathInfo(\"/newlogin/CreateUserSubmit\");\n        RhnMockDynaActionForm form =\n            fillOutForm(\"createSatelliteForm\", CreateUserAction.TYPE_INTO_ORG);\n        setActionForm(form);\n        actionPerform();\n        String forwardPath = getActualForward();\n        assertNotNull(forwardPath);\n        assertTrue(forwardPath.startsWith(\"/users/ActiveList.do?uid=\"));\n    }","id":45305,"modified_method":"public void testNewUserIntoOrgSatellite() throws Exception {\n\n\n        setRequestPathInfo(\"/newlogin/CreateUserSubmit\");\n        RhnMockDynaActionForm form = fillOutForm(\"userCreateForm\");\n        setActionForm(form);\n        actionPerform();\n        String forwardPath = getActualForward();\n        assertNotNull(forwardPath);\n        assertTrue(forwardPath.startsWith(\"/users/ActiveList.do?uid=\"));\n    }","commit_id":"1ad0068a98e1d757f118db08edbbf392135968f8","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm formIn,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response) {\n        DynaActionForm form = (DynaActionForm)formIn;\n        RequestContext ctx = new RequestContext(request);\n        User currentUser = ctx.getCurrentUser();\n\n        // We have to set these on the Session because struts throws them away\n        // if we set them on the request itself and validation fails.\n        request.setAttribute(\"availablePrefixes\",\n                                  UserActionHelper.getPrefixes());\n        request.setAttribute(\"countries\",\n                                  UserActionHelper.getCountries());\n        if (AclManager.hasAcl(\"need_first_user()\", request, null)) {\n            request.setAttribute(\"schemaUpgradeRequired\",\n                    LoginHelper.isSchemaUpgradeRequired().toString());\n        }\n        if (UserManager.satelliteHasUsers()) {\n            request.setAttribute(\"firstUserMode\", Boolean.FALSE);\n        }\n        else {\n            request.setAttribute(\"firstUserMode\", Boolean.TRUE);\n        }\n\n        if (!RhnValidationHelper.getFailedValidation(request)) {\n            form.set(\"country\", \"US\");\n            form.set(\"contact_email\", Boolean.TRUE);\n            form.set(\"contact_partner\", Boolean.TRUE);\n            form.set(\"prefix\",\n                LocalizationService.getInstance().getMessage(\"user prefix Mr.\"));\n        }\n\n        //make sure we don't put the user's password on the form in cleartext\n        form.set(\"desiredpassword\", \"\");\n        form.set(\"desiredpasswordConfirm\", \"\");\n\n        /*\n         * If we are a sat, then we for sure want to display the PAM section\n         */\n        request.setAttribute(\"displaypam\", \"true\");\n        /*\n        * If we are a sat and we have setup pam authentication already, display the\n        * checkbox and instructions\n        */\n        String pamAuthService = Config.get().getString(ConfigDefaults.WEB_PAM_AUTH_SERVICE);\n        if (pamAuthService != null && pamAuthService.trim().length() > 0) {\n            request.setAttribute(\"displaypamcheckbox\", \"true\");\n        }\n\n        request.setAttribute(\"timezones\", getTimeZones());\n\n        // There's no currentUser when creating the very first user\n        if (currentUser != null && currentUser.getTimeZone() != null) {\n            request.setAttribute(\"default_tz\", new Integer(currentUser.getTimeZone()\n                .getTimeZoneId()));\n        }\n        else {\n            request.setAttribute(\"default_tz\", new Integer(UserManager\n                .getDefaultTimeZone().getTimeZoneId()));\n        }\n\n        request.setAttribute(\"noLocale\", buildNoneLocale());\n        request.setAttribute(\"supportedLocales\", buildImageMap());\n        // There's no currentUser when creating the very first user\n        if (currentUser != null) {\n            setCurrentLocale(ctx, currentUser);\n        }\n\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","id":45306,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm formIn,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response) {\n        DynaActionForm form = (DynaActionForm)formIn;\n        RequestContext ctx = new RequestContext(request);\n        User currentUser = ctx.getCurrentUser();\n\n        // We have to set these on the Session because struts throws them away\n        // if we set them on the request itself and validation fails.\n        request.setAttribute(\"availablePrefixes\",\n                                  UserActionHelper.getPrefixes());\n        request.setAttribute(\"countries\",\n                                  UserActionHelper.getCountries());\n\n        if (!RhnValidationHelper.getFailedValidation(request)) {\n            form.set(\"country\", \"US\");\n            form.set(\"contact_email\", Boolean.TRUE);\n            form.set(\"contact_partner\", Boolean.TRUE);\n            form.set(\"prefix\",\n                LocalizationService.getInstance().getMessage(\"user prefix Mr.\"));\n        }\n\n        //make sure we don't put the user's password on the form in cleartext\n        form.set(\"desiredpassword\", \"\");\n        form.set(\"desiredpasswordConfirm\", \"\");\n\n        /*\n         * If we are a sat, then we for sure want to display the PAM section\n         */\n        request.setAttribute(\"displaypam\", \"true\");\n        /*\n        * If we are a sat and we have setup pam authentication already, display the\n        * checkbox and instructions\n        */\n        String pamAuthService = Config.get().getString(ConfigDefaults.WEB_PAM_AUTH_SERVICE);\n        if (pamAuthService != null && pamAuthService.trim().length() > 0) {\n            request.setAttribute(\"displaypamcheckbox\", \"true\");\n        }\n\n        request.setAttribute(\"timezones\", getTimeZones());\n        if (currentUser.getTimeZone() != null) {\n            request.setAttribute(\"default_tz\", new Integer(currentUser.getTimeZone()\n                .getTimeZoneId()));\n        }\n        else {\n            request.setAttribute(\"default_tz\", new Integer(UserManager\n                .getDefaultTimeZone().getTimeZoneId()));\n        }\n        request.setAttribute(\"noLocale\", buildNoneLocale());\n        request.setAttribute(\"supportedLocales\", buildImageMap());\n        setCurrentLocale(ctx, currentUser);\n\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","commit_id":"1ad0068a98e1d757f118db08edbbf392135968f8","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private int cleanupSegmentsToMaintainSize(Log kafkaLog) {\n            final long retentionSize = kafkaLog.config().retentionSize();\n            if (retentionSize < 0 || kafkaLog.size() < retentionSize) {\n                return 0;\n            }\n            final long[] diff = {kafkaLog.size() - retentionSize};\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() { // sigh scala\n                @Override\n                public Object apply(LogSegment segment) {\n                    if (diff[0] - segment.size() >= 0) {\n                        diff[0] -= segment.size();\n                        loggerForCleaner.debug(\n                                \"[cleanup-size] Removing segment starting at offset {}, size {} bytes, to shrink log to new size {}, target size {}\",\n                                segment.baseOffset(),\n                                segment.size(),\n                                diff[0],\n                                retentionSize);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            });\n        }","id":45307,"modified_method":"private int cleanupSegmentsToMaintainSize(Log kafkaLog) {\n            final long retentionSize = kafkaLog.config().retentionSize();\n            final long currentSize = kafkaLog.size();\n            final double utilizationPercentage = retentionSize > 0 ? (currentSize * 100) / retentionSize : 0.0;\n            if (utilizationPercentage > KafkaJournal.NOTIFY_ON_UTILIZATION_PERCENTAGE) {\n                LOG.warn(\"Journal utilization ({}%) has gone over {}%.\", utilizationPercentage,\n                        KafkaJournal.NOTIFY_ON_UTILIZATION_PERCENTAGE);\n            }\n            if (retentionSize < 0 || currentSize < retentionSize) {\n                KafkaJournal.this.purgedSegmentsInLastRetention.set(0);\n                return 0;\n            }\n            final long[] diff = {currentSize - retentionSize};\n            int deletedSegments = kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() { // sigh scala\n                @Override\n                public Object apply(LogSegment segment) {\n                    if (diff[0] - segment.size() >= 0) {\n                        diff[0] -= segment.size();\n                        loggerForCleaner.debug(\n                                \"[cleanup-size] Removing segment starting at offset {}, size {} bytes, to shrink log to new size {}, target size {}\",\n                                segment.baseOffset(),\n                                segment.size(),\n                                diff[0],\n                                retentionSize);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            });\n            KafkaJournal.this.purgedSegmentsInLastRetention.set(deletedSegments);\n            return deletedSegments;\n        }","commit_id":"0150ea9d34337ea80ee87e1e8cc081f65ae89f83","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private int cleanupExpiredSegments(final Log kafkaLog) {\n            // don't run if nothing will be done\n            if (kafkaLog.size() == 0 && kafkaLog.numberOfSegments() < 1) {\n                return 0;\n            }\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() {\n                @Override\n                public Object apply(LogSegment segment) {\n                    final long segmentAge = JODA_TIME.milliseconds() - segment.lastModified();\n                    final boolean shouldDelete = segmentAge > kafkaLog.config().retentionMs();\n                    if (shouldDelete) {\n                        loggerForCleaner.debug(\n                                \"[cleanup-time] Removing segment with age {}s, older than then maximum retention age {}s\",\n                                MILLISECONDS.toSeconds(segmentAge),\n                                MILLISECONDS.toSeconds(kafkaLog.config().retentionMs()));\n                    }\n                    return shouldDelete;\n                }\n            });\n        }","id":45308,"modified_method":"private int cleanupExpiredSegments(final Log kafkaLog) {\n            // don't run if nothing will be done\n            if (kafkaLog.size() == 0 && kafkaLog.numberOfSegments() < 1) {\n                KafkaJournal.this.purgedSegmentsInLastRetention.set(0);\n                return 0;\n            }\n            int deletedSegments = kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() {\n                @Override\n                public Object apply(LogSegment segment) {\n                    final long segmentAge = JODA_TIME.milliseconds() - segment.lastModified();\n                    final boolean shouldDelete = segmentAge > kafkaLog.config().retentionMs();\n                    if (shouldDelete) {\n                        loggerForCleaner.debug(\n                                \"[cleanup-time] Removing segment with age {}s, older than then maximum retention age {}s\",\n                                MILLISECONDS.toSeconds(segmentAge),\n                                MILLISECONDS.toSeconds(kafkaLog.config().retentionMs()));\n                    }\n                    return shouldDelete;\n                }\n            });\n            KafkaJournal.this.purgedSegmentsInLastRetention.set(deletedSegments);\n            return deletedSegments;\n        }","commit_id":"0150ea9d34337ea80ee87e1e8cc081f65ae89f83","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void doRun() {\n        final ThrottleState throttleState = new ThrottleState();\n        final long committedOffset = journal.getCommittedOffset();\n\n        prevTs = currentTs;\n        currentTs = System.nanoTime();\n\n        previousLogEndOffset = logEndOffset;\n        previousReadOffset = currentReadOffset;\n        logStartOffset = journal.getLogStartOffset();\n        logEndOffset = journal.getLogEndOffset() - 1; // -1 because getLogEndOffset is the next offset that gets assigned\n        currentReadOffset = journal.getNextReadOffset() - 1; // just to make it clear which field we read\n\n        // for the first run, don't send an update, there's no previous data available to calc rates\n        if (firstRun) {\n            firstRun = false;\n            return;\n        }\n\n        throttleState.appendEventsPerSec = (long) Math.floor((logEndOffset - previousLogEndOffset) / ((currentTs - prevTs) / 1.0E09));\n        throttleState.readEventsPerSec = (long) Math.floor((currentReadOffset - previousReadOffset) / ((currentTs - prevTs) / 1.0E09));\n\n        throttleState.journalSize = journal.size();\n        throttleState.journalSizeLimit = retentionSize.toBytes();\n\n        throttleState.processBufferCapacity = processBuffer.getRemainingCapacity();\n\n        if (committedOffset == KafkaJournal.DEFAULT_COMMITTED_OFFSET) {\n            // nothing committed at all, the entire log is uncommitted, or completely empty.\n            throttleState.uncommittedJournalEntries = journal.size() == 0 ? 0 : logEndOffset - logStartOffset;\n        } else {\n            throttleState.uncommittedJournalEntries = logEndOffset - committedOffset;\n        }\n        log.debug(\"ThrottleState: {}\", throttleState);\n        \n        // the journal needs this to provide information to rest clients\n        journal.setThrottleState(throttleState);\n        \n        // publish to interested parties\n        eventBus.post(throttleState);\n\n    }","id":45309,"modified_method":"@Override\n    public void doRun() {\n        final ThrottleState throttleState = new ThrottleState();\n        final long committedOffset = journal.getCommittedOffset();\n\n        prevTs = currentTs;\n        currentTs = System.nanoTime();\n\n        previousLogEndOffset = logEndOffset;\n        previousReadOffset = currentReadOffset;\n        logStartOffset = journal.getLogStartOffset();\n        logEndOffset = journal.getLogEndOffset() - 1; // -1 because getLogEndOffset is the next offset that gets assigned\n        currentReadOffset = journal.getNextReadOffset() - 1; // just to make it clear which field we read\n\n        // for the first run, don't send an update, there's no previous data available to calc rates\n        if (firstRun) {\n            firstRun = false;\n            return;\n        }\n\n        throttleState.appendEventsPerSec = (long) Math.floor((logEndOffset - previousLogEndOffset) / ((currentTs - prevTs) / 1.0E09));\n        throttleState.readEventsPerSec = (long) Math.floor((currentReadOffset - previousReadOffset) / ((currentTs - prevTs) / 1.0E09));\n\n        throttleState.journalSize = journal.size();\n        throttleState.journalSizeLimit = retentionSize.toBytes();\n\n        throttleState.processBufferCapacity = processBuffer.getRemainingCapacity();\n\n        if (committedOffset == KafkaJournal.DEFAULT_COMMITTED_OFFSET) {\n            // nothing committed at all, the entire log is uncommitted, or completely empty.\n            throttleState.uncommittedJournalEntries = journal.size() == 0 ? 0 : logEndOffset - logStartOffset;\n        } else {\n            throttleState.uncommittedJournalEntries = logEndOffset - committedOffset;\n        }\n        log.debug(\"ThrottleState: {}\", throttleState);\n        \n        // the journal needs this to provide information to rest clients\n        journal.setThrottleState(throttleState);\n        \n        // publish to interested parties\n        eventBus.post(throttleState);\n\n        // Abusing the current thread to send notifications from KafkaJournal in the graylog2-shared module\n        final double journalUtilizationPercentage = throttleState.journalSizeLimit > 0 ? (throttleState.journalSize * 100) / throttleState.journalSizeLimit : 0.0;\n\n        if (journalUtilizationPercentage > KafkaJournal.NOTIFY_ON_UTILIZATION_PERCENTAGE) {\n            Notification notification = notificationService.buildNow()\n                    .addNode(serverStatus.getNodeId().toString())\n                    .addType(Notification.Type.JOURNAL_UTILIZATION_TOO_HIGH)\n                    .addSeverity(Notification.Severity.URGENT)\n                    .addDetail(\"journal_utilization_percentage\", journalUtilizationPercentage);\n            notificationService.publishIfFirst(notification);\n        }\n\n        if (journal.getPurgedSegmentsInLastRetention() > 0) {\n            Notification notification = notificationService.buildNow()\n                    .addNode(serverStatus.getNodeId().toString())\n                    .addType(Notification.Type.JOURNAL_UNCOMMITTED_MESSAGES_DELETED)\n                    .addSeverity(Notification.Severity.URGENT);\n            notificationService.publishIfFirst(notification);\n        }\n    }","commit_id":"0150ea9d34337ea80ee87e1e8cc081f65ae89f83","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private int cleanupExpiredSegments(Log kafkaLog) {\n            if (kafkaLog.config().retentionSize() < 0 || kafkaLog.size() < kafkaLog.config().retentionSize()) {\n                return 0;\n            }\n            final long[] diff = {kafkaLog.size() - kafkaLog.config().retentionSize()};\n            kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() { // sigh scala\n                @Override\n                public Object apply(LogSegment segment) {\n                    if(diff[0] - segment.size() >= 0) {\n                        diff[0] -= segment.size();\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            });\n\n            return 0;\n        }","id":45310,"modified_method":"private int cleanupExpiredSegments(final Log kafkaLog) {\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() {\n                @Override\n                public Object apply(LogSegment segment) {\n                    final long segmentAge = TIME.milliseconds() - segment.lastModified();\n                    final boolean shouldDelete = segmentAge > kafkaLog.config().retentionMs();\n                    if (shouldDelete) {\n                        log.debug(\"[time] Removing segment with age {}s, older than then maximum retention age {}s\",\n                                  MILLISECONDS.toSeconds(segmentAge), MILLISECONDS.toSeconds(kafkaLog.config().retentionMs()));\n                    }\n                    return shouldDelete;\n                }\n            });\n        }","commit_id":"01f6e6daed6884fc778ec66a5957fe8697859a84","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n        public void run() {\n            try {\n                log.debug(\"Beginning log cleanup\");\n                int total = 0;\n                final Timer.Context ctx = new Timer().time();\n                for (final Log kafkaLog : JavaConversions.asIterable(logManager.allLogs())) {\n                    if (kafkaLog.config().compact()) continue;\n                    log.debug(\"Garbage collecting {}\", kafkaLog.name());\n                    total += cleanupExpiredSegments(kafkaLog) + cleanupSegmentsToMaintainSize(kafkaLog);\n                }\n\n                log.debug(\"Log cleanup completed. {} files deleted in {} seconds\", total, TimeUnit.NANOSECONDS.toSeconds(ctx.stop()));\n            } catch (Exception e) {\n                log.error(\"Unable to delete expired segments. Will try again.\", e);\n            }\n        }","id":45311,"modified_method":"@Override\n        public void run() {\n            try {\n                log.debug(\"Beginning log cleanup\");\n                int total = 0;\n                final Timer.Context ctx = new Timer().time();\n                for (final Log kafkaLog : JavaConversions.asIterable(logManager.allLogs())) {\n                    if (kafkaLog.config().compact()) continue;\n                    log.debug(\"Garbage collecting {}\", kafkaLog.name());\n                    total += cleanupExpiredSegments(kafkaLog) + cleanupSegmentsToMaintainSize(kafkaLog);\n                }\n\n                log.debug(\"Log cleanup completed. {} files deleted in {} seconds\", total, NANOSECONDS.toSeconds(ctx.stop()));\n            } catch (Exception e) {\n                log.error(\"Unable to delete expired segments. Will try again.\", e);\n            }\n        }","commit_id":"01f6e6daed6884fc778ec66a5957fe8697859a84","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private int cleanupSegmentsToMaintainSize(final Log kafkaLog) {\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() {\n                @Override\n                public Object apply(LogSegment segment) {\n                    return (TIME.milliseconds() - segment.lastModified() > kafkaLog.config().retentionMs());\n                }\n            });\n        }","id":45312,"modified_method":"private int cleanupSegmentsToMaintainSize(Log kafkaLog) {\n            final long retentionSize = kafkaLog.config().retentionSize();\n            if (retentionSize < 0 || kafkaLog.size() < retentionSize) {\n                return 0;\n            }\n            final long[] diff = {kafkaLog.size() - retentionSize};\n            kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() { // sigh scala\n                @Override\n                public Object apply(LogSegment segment) {\n                    if(diff[0] - segment.size() >= 0) {\n                        diff[0] -= segment.size();\n                        log.debug(\"[size] Removing segment starting at offset {}, size {} bytes, to shrink log to new size {}, target size {}\",\n                                  segment.baseOffset(), segment.size(), diff[0], retentionSize);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            });\n\n            return 0;\n        }","commit_id":"01f6e6daed6884fc778ec66a5957fe8697859a84","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void startUp() throws Exception {\n        // do NOT let Kafka's LogManager create its management threads, we will run them ourselves.\n        // The problem is that we can't reliably decorate or subclass them, so we will peel the methods out and call\n        // them ourselves. it sucks, but i haven't found a better way yet.\n        // /* don't call */ logManager.startup();\n\n        // flush dirty logs regularly\n        scheduler.scheduleAtFixedRate(new DirtyLogFlusher(), TimeUnit.SECONDS.toMillis(30), logManager.flushCheckMs(), TimeUnit.MILLISECONDS);\n\n        // write recovery checkpoint files\n        scheduler.scheduleAtFixedRate(new RecoveryCheckpointFlusher(), TimeUnit.SECONDS.toMillis(30), logManager.flushCheckpointMs(), TimeUnit.MILLISECONDS);\n\n        // custom log retention cleaner\n        scheduler.scheduleAtFixedRate(new LogRetentionCleaner(), TimeUnit.SECONDS.toMillis(30), logManager.retentionCheckMs(), TimeUnit.MILLISECONDS);\n\n        // regularly write the currently committed read offset to disk\n        scheduler.scheduleAtFixedRate(offsetFlusher, 1, 1, TimeUnit.SECONDS); // TODO make configurable\n    }","id":45313,"modified_method":"@Override\n    protected void startUp() throws Exception {\n        // do NOT let Kafka's LogManager create its management threads, we will run them ourselves.\n        // The problem is that we can't reliably decorate or subclass them, so we will peel the methods out and call\n        // them ourselves. it sucks, but i haven't found a better way yet.\n        // /* don't call */ logManager.startup();\n\n        // flush dirty logs regularly\n        scheduler.scheduleAtFixedRate(new DirtyLogFlusher(), TimeUnit.SECONDS.toMillis(30), logManager.flushCheckMs(), MILLISECONDS);\n\n        // write recovery checkpoint files\n        scheduler.scheduleAtFixedRate(new RecoveryCheckpointFlusher(), TimeUnit.SECONDS.toMillis(30), logManager.flushCheckpointMs(), MILLISECONDS);\n\n        // custom log retention cleaner\n        scheduler.scheduleAtFixedRate(new LogRetentionCleaner(), TimeUnit.SECONDS.toMillis(30), logManager.retentionCheckMs(), MILLISECONDS);\n\n        // regularly write the currently committed read offset to disk\n        scheduler.scheduleAtFixedRate(offsetFlusher, 1, 1, TimeUnit.SECONDS); // TODO make configurable\n    }","commit_id":"01f6e6daed6884fc778ec66a5957fe8697859a84","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void startUp() throws Exception {\n        // do NOT let Kafka's LogManager create its management threads, we will run them ourselves.\n        // The problem is that we can't reliably decorate or subclass them, so we will peel the methods out and call\n        // them ourselves. it sucks, but i haven't found a better way yet.\n        // /* don't call */ logManager.startup();\n\n        // flush dirty logs regularly\n        scheduler.scheduleAtFixedRate(new DirtyLogFlusher(),\n                                      TimeUnit.SECONDS.toMillis(30),\n                                      logManager.flushCheckMs(),\n                                      MILLISECONDS);\n\n        // write recovery checkpoint files\n        scheduler.scheduleAtFixedRate(new RecoveryCheckpointFlusher(),\n                                      TimeUnit.SECONDS.toMillis(30),\n                                      logManager.flushCheckpointMs(),\n                                      MILLISECONDS);\n\n        // custom log retention cleaner\n        scheduler.scheduleAtFixedRate(new LogRetentionCleaner(),\n                                      TimeUnit.SECONDS.toMillis(30),\n                                      logManager.retentionCheckMs(),\n                                      MILLISECONDS);\n\n        // regularly write the currently committed read offset to disk\n        scheduler.scheduleAtFixedRate(offsetFlusher, 1, 1, TimeUnit.SECONDS); // TODO make configurable\n    }","id":45314,"modified_method":"@Override\n    protected void startUp() throws Exception {\n        // do NOT let Kafka's LogManager create its management threads, we will run them ourselves.\n        // The problem is that we can't reliably decorate or subclass them, so we will peel the methods out and call\n        // them ourselves. it sucks, but i haven't found a better way yet.\n        // /* don't call */ logManager.startup();\n\n        // flush dirty logs regularly\n        scheduler.scheduleAtFixedRate(dirtyLogFlusher,\n                                      TimeUnit.SECONDS.toMillis(30),\n                                      logManager.flushCheckMs(),\n                                      MILLISECONDS);\n\n        // write recovery checkpoint files\n        scheduler.scheduleAtFixedRate(recoveryCheckpointFlusher,\n                                      TimeUnit.SECONDS.toMillis(30),\n                                      logManager.flushCheckpointMs(),\n                                      MILLISECONDS);\n\n        // custom log retention cleaner\n        scheduler.scheduleAtFixedRate(logRetentionCleaner,\n                                      TimeUnit.SECONDS.toMillis(30),\n                                      logManager.retentionCheckMs(),\n                                      MILLISECONDS);\n\n        // regularly write the currently committed read offset to disk\n        scheduler.scheduleAtFixedRate(offsetFlusher, 1, 1, TimeUnit.SECONDS); // TODO make configurable\n    }","commit_id":"6b0a0ac936e333d1965b0fa5c1ad57810b8538a2","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n        public void run() {\n            try {\n                loggerForCleaner.debug(\"Beginning log cleanup\");\n                int total = 0;\n                final Timer.Context ctx = new Timer().time();\n                for (final Log kafkaLog : JavaConversions.asJavaIterable(logManager.allLogs())) {\n                    if (kafkaLog.config().compact()) continue;\n                    loggerForCleaner.debug(\"Garbage collecting {}\", kafkaLog.name());\n                    total += cleanupExpiredSegments(kafkaLog) +\n                            cleanupSegmentsToMaintainSize(kafkaLog) +\n                            cleanupSegmentsToRemoveCommitted(kafkaLog);\n                }\n\n                loggerForCleaner.debug(\"Log cleanup completed. {} files deleted in {} seconds\",\n                          total,\n                          NANOSECONDS.toSeconds(ctx.stop()));\n            } catch (Exception e) {\n                loggerForCleaner.error(\"Unable to delete expired segments. Will try again.\", e);\n            }\n        }","id":45315,"modified_method":"@Override\n        public void run() {\n            try {\n                call();\n            } catch (Exception e) {\n                loggerForCleaner.error(\"Unable to delete expired segments. Will try again.\", e);\n            }\n        }","commit_id":"6b0a0ac936e333d1965b0fa5c1ad57810b8538a2","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * A Java transliteration of what the scala implementation does, which unfortunately is declared as private\n     */\n    protected void flushDirtyLogs() {\n        log.debug(\"Checking for dirty logs to flush...\");\n\n        final Set<Map.Entry<TopicAndPartition, Log>> entries = JavaConversions.mapAsJavaMap(logManager.logsByTopicPartition()).entrySet();\n        for (final Map.Entry<TopicAndPartition, Log> topicAndPartitionLogEntry : entries) {\n            final TopicAndPartition topicAndPartition = topicAndPartitionLogEntry.getKey();\n            final Log kafkaLog = topicAndPartitionLogEntry.getValue();\n            final long timeSinceLastFlush = TIME.milliseconds() - kafkaLog.lastFlushTime();\n            try {\n                log.debug(\n                        \"Checking if flush is needed on {} flush interval {} last flushed {} time since last flush: {}\",\n                        topicAndPartition.topic(),\n                        kafkaLog.config().flushInterval(),\n                        kafkaLog.lastFlushTime(),\n                        timeSinceLastFlush);\n                if (timeSinceLastFlush >= kafkaLog.config().flushMs()) {\n                    kafkaLog.flush();\n                }\n            } catch (Exception e) {\n                log.error(\"Error flushing topic \" + topicAndPartition.topic(), e);\n            }\n        }\n    }","id":45316,"modified_method":"/**\n     * A Java transliteration of what the scala implementation does, which unfortunately is declared as private\n     */\n    protected void flushDirtyLogs() {\n        log.debug(\"Checking for dirty logs to flush...\");\n\n        final Set<Map.Entry<TopicAndPartition, Log>> entries = JavaConversions.mapAsJavaMap(logManager.logsByTopicPartition()).entrySet();\n        for (final Map.Entry<TopicAndPartition, Log> topicAndPartitionLogEntry : entries) {\n            final TopicAndPartition topicAndPartition = topicAndPartitionLogEntry.getKey();\n            final Log kafkaLog = topicAndPartitionLogEntry.getValue();\n            final long timeSinceLastFlush = JODA_TIME.milliseconds() - kafkaLog.lastFlushTime();\n            try {\n                log.debug(\n                        \"Checking if flush is needed on {} flush interval {} last flushed {} time since last flush: {}\",\n                        topicAndPartition.topic(),\n                        kafkaLog.config().flushInterval(),\n                        kafkaLog.lastFlushTime(),\n                        timeSinceLastFlush);\n                if (timeSinceLastFlush >= kafkaLog.config().flushMs()) {\n                    kafkaLog.flush();\n                }\n            } catch (Exception e) {\n                log.error(\"Error flushing topic \" + topicAndPartition.topic(), e);\n            }\n        }\n    }","commit_id":"6b0a0ac936e333d1965b0fa5c1ad57810b8538a2","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private int cleanupExpiredSegments(final Log kafkaLog) {\n            // don't run if nothing will be done\n            if (kafkaLog.size() == 0 && kafkaLog.numberOfSegments() < 1) {\n                return 0;\n            }\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() {\n                @Override\n                public Object apply(LogSegment segment) {\n                    final long segmentAge = TIME.milliseconds() - segment.lastModified();\n                    final boolean shouldDelete = segmentAge > kafkaLog.config().retentionMs();\n                    if (shouldDelete) {\n                        loggerForCleaner.debug(\n                                \"[cleanup-time] Removing segment with age {}s, older than then maximum retention age {}s\",\n                                MILLISECONDS.toSeconds(segmentAge),\n                                MILLISECONDS.toSeconds(kafkaLog.config().retentionMs()));\n                    }\n                    return shouldDelete;\n                }\n            });\n        }","id":45317,"modified_method":"private int cleanupExpiredSegments(final Log kafkaLog) {\n            // don't run if nothing will be done\n            if (kafkaLog.size() == 0 && kafkaLog.numberOfSegments() < 1) {\n                return 0;\n            }\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() {\n                @Override\n                public Object apply(LogSegment segment) {\n                    final long segmentAge = JODA_TIME.milliseconds() - segment.lastModified();\n                    final boolean shouldDelete = segmentAge > kafkaLog.config().retentionMs();\n                    if (shouldDelete) {\n                        loggerForCleaner.debug(\n                                \"[cleanup-time] Removing segment with age {}s, older than then maximum retention age {}s\",\n                                MILLISECONDS.toSeconds(segmentAge),\n                                MILLISECONDS.toSeconds(kafkaLog.config().retentionMs()));\n                    }\n                    return shouldDelete;\n                }\n            });\n        }","commit_id":"6b0a0ac936e333d1965b0fa5c1ad57810b8538a2","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private int cleanupSegmentsToMaintainSize(Log kafkaLog) {\n            final long retentionSize = kafkaLog.config().retentionSize();\n            if (retentionSize < 0 || kafkaLog.size() < retentionSize) {\n                return 0;\n            }\n            final long[] diff = {kafkaLog.size() - retentionSize};\n            kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() { // sigh scala\n                @Override\n                public Object apply(LogSegment segment) {\n                    if (diff[0] - segment.size() >= 0) {\n                        diff[0] -= segment.size();\n                        loggerForCleaner.debug(\n                                \"[cleanup-size] Removing segment starting at offset {}, size {} bytes, to shrink log to new size {}, target size {}\",\n                                segment.baseOffset(),\n                                segment.size(),\n                                diff[0],\n                                retentionSize);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            });\n\n            return 0;\n        }","id":45318,"modified_method":"private int cleanupSegmentsToMaintainSize(Log kafkaLog) {\n            final long retentionSize = kafkaLog.config().retentionSize();\n            if (retentionSize < 0 || kafkaLog.size() < retentionSize) {\n                return 0;\n            }\n            final long[] diff = {kafkaLog.size() - retentionSize};\n            return kafkaLog.deleteOldSegments(new AbstractFunction1<LogSegment, Object>() { // sigh scala\n                @Override\n                public Object apply(LogSegment segment) {\n                    if (diff[0] - segment.size() >= 0) {\n                        diff[0] -= segment.size();\n                        loggerForCleaner.debug(\n                                \"[cleanup-size] Removing segment starting at offset {}, size {} bytes, to shrink log to new size {}, target size {}\",\n                                segment.baseOffset(),\n                                segment.size(),\n                                diff[0],\n                                retentionSize);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            });\n        }","commit_id":"6b0a0ac936e333d1965b0fa5c1ad57810b8538a2","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Use the CLI to rollback a patch\n     *\n     * @param oneOffPatchID the ID of the patch that should be rolled back\n     * @throws Exception\n     */\n    public static void rollbackPatch(String oneOffPatchID) throws Exception {\n        rollbackPatch(oneOffPatchID, null);\n    }","id":45319,"modified_method":"/**\n     * Use the CLI to rollback a patch\n     *\n     * @param oneOffPatchID the ID of the patch that should be rolled back\n     * @throws Exception\n     */\n    public static boolean rollbackPatch(String oneOffPatchID) throws Exception {\n        return rollbackPatch(oneOffPatchID, null);\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Use the CLI to rollback a patch\n     *\n     * @param oneoffPatchID the ID of the patch that should be rolled back\n     * @param args          conflict resolution arguments, rollback arguments\n     * @throws Exception\n     */\n    public static void rollbackPatch(String oneoffPatchID, String... args) throws Exception {\n        CLIWrapper cli = null;\n        try {\n            cli = new CLIWrapper(true);\n            StringBuilder builder = new StringBuilder(\"patch rollback\");\n            if (args != null) {\n                for (String arg : args) {\n                    builder.append(\" \").append(arg);\n                }\n            }\n            builder.append(\" --patch-id=\").append(oneoffPatchID);\n            String command = builder.toString();\n            cli.sendLine(command);\n        } finally {\n            if (cli != null) {\n                cli.quit();\n            }\n        }\n\n    }","id":45320,"modified_method":"/**\n     * Use the CLI to rollback a patch\n     *\n     * @param oneoffPatchID the ID of the patch that should be rolled back\n     * @param args          conflict resolution arguments, rollback arguments\n     * @throws Exception\n     */\n    public static boolean rollbackPatch(String oneoffPatchID, String... args) throws Exception {\n        CLIWrapper cli = null;\n        try {\n            cli = new CLIWrapper(true);\n            StringBuilder builder = new StringBuilder(\"patch rollback\");\n            if (args != null) {\n                for (String arg : args) {\n                    builder.append(\" \").append(arg);\n                }\n            }\n            builder.append(\" --patch-id=\").append(oneoffPatchID);\n            String command = builder.toString();\n            return cli.sendLine(command, true);\n        } finally {\n            if (cli != null) {\n                cli.quit();\n            }\n        }\n\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Check if the server is in restart-required state, that means\n     * management operation return \"response-headers\" : {\"process-state\" : \"restart-required\"}\n     *\n     * @return true if the server is in \"restart-required\" state\n     * @throws Exception\n     */\n    public static boolean doesServerRequireRestart() throws Exception {\n        CLIWrapper cli = null;\n        try {\n            cli = new CLIWrapper(true);\n            cli.sendLine(\"patch info\");\n            String response = cli.readOutput();\n            ModelNode responseNode = ModelNode.fromJSONString(response);\n            ModelNode respHeaders = responseNode.get(\"response-headers\");\n            if (respHeaders != null && respHeaders.isDefined()) {\n                ModelNode processState = respHeaders.get(\"process-state\");\n                return processState != null && processState.isDefined() && processState.asString()\n                        .equals(ClientConstants.CONTROLLER_PROCESS_STATE_RESTART_REQUIRED);\n            } else {\n                return false;\n            }\n        } finally {\n            if (cli != null) {\n                cli.quit();\n            }\n        }\n    }","id":45321,"modified_method":"/**\n     * Check if the server is in restart-required state, that means\n     * management operation return \"response-headers\" : {\"process-state\" : \"restart-required\"}\n     *\n     * @return true if the server is in \"restart-required\" state\n     * @throws Exception\n     */\n    public static boolean doesServerRequireRestart() throws Exception {\n        CLIWrapper cli = null;\n        try {\n            cli = new CLIWrapper(true);\n            cli.sendLine(\"patch info\", true);\n            String response = cli.readOutput();\n            ModelNode responseNode = ModelNode.fromJSONString(response);\n            ModelNode respHeaders = responseNode.get(\"response-headers\");\n            if (respHeaders != null && respHeaders.isDefined()) {\n                ModelNode processState = respHeaders.get(\"process-state\");\n                return processState != null && processState.isDefined() && processState.asString()\n                        .equals(ClientConstants.CONTROLLER_PROCESS_STATE_RESTART_REQUIRED);\n            } else {\n                return false;\n            }\n        } finally {\n            if (cli != null) {\n                cli.quit();\n            }\n        }\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Use the CLI to apply a patch\n     *\n     * @param patchFilePath absolute path to the ZIP file containing the patch\n     * @param args          conflict resolution arguments or null\n     * @throws Exception\n     */\n    public static void applyPatch(String patchFilePath, String... args) throws Exception {\n        CLIWrapper cli = null;\n        try {\n            cli = new CLIWrapper(true);\n\n            StringBuilder builder = new StringBuilder(\"patch apply\");\n            if (args != null) {\n                for (String arg : args) {\n                    builder.append(\" \").append(arg);\n                }\n            }\n            builder.append(\" \").append(patchFilePath);\n            String command = builder.toString();\n            cli.sendLine(command);\n        } finally {\n            if (cli != null) {\n                cli.quit();\n            }\n        }\n    }","id":45322,"modified_method":"/**\n     * Use the CLI to apply a patch\n     *\n     * @param patchFilePath absolute path to the ZIP file containing the patch\n     * @param args          conflict resolution arguments or null\n     * @throws Exception\n     */\n    public static boolean applyPatch(String patchFilePath, String... args) throws Exception {\n        CLIWrapper cli = null;\n        try {\n            cli = new CLIWrapper(true);\n\n            StringBuilder builder = new StringBuilder(\"patch apply\");\n            if (args != null) {\n                for (String arg : args) {\n                    builder.append(\" \").append(arg);\n                }\n            }\n            builder.append(\" \").append(patchFilePath);\n            String command = builder.toString();\n            return cli.sendLine(command, true);\n        } finally {\n            if (cli != null) {\n                cli.quit();\n            }\n        }\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Use the CLI to apply a patch\n     *\n     * @param patchFilePath absolute path to the ZIP file containing the patch\n     * @throws Exception\n     */\n    public static void applyPatch(String patchFilePath) throws Exception {\n        applyPatch(patchFilePath, null);\n    }","id":45323,"modified_method":"/**\n     * Use the CLI to apply a patch\n     *\n     * @param patchFilePath absolute path to the ZIP file containing the patch\n     * @throws Exception\n     */\n    public static boolean applyPatch(String patchFilePath) throws Exception {\n        return applyPatch(patchFilePath, null);\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ContentModification modifyModule(File patchDir, String patchElementID, File existingModule, String newContent) throws IOException {\n        byte[] existingHash = hashFile(existingModule);\n        return modifyModule(patchDir, patchElementID, existingModule.getName(), existingHash, newContent);\n    }","id":45324,"modified_method":"public static ContentModification modifyModule(File patchDir, String patchElementID, File existingModule, ResourceItem resourceItem) throws IOException {\n        byte[] existingHash = hashFile(existingModule);\n        return modifyModule(patchDir, patchElementID, existingModule.getName(), existingHash, resourceItem);\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ContentModification modifyModule(File patchDir, String patchElementID, String moduleName, byte[] existingHash, String newContent) throws IOException {\n        File modulesDir = newFile(patchDir, patchElementID, MODULES);\n        File modifiedModule = createModule0(modulesDir, moduleName, newContent);\n        byte[] updatedHash = hashFile(modifiedModule);\n        ContentModification moduleUpdated = new ContentModification(new ModuleItem(moduleName, ModuleItem.MAIN_SLOT, updatedHash), existingHash, MODIFY);\n        return moduleUpdated;\n    }","id":45325,"modified_method":"public static ContentModification modifyModule(File patchDir, String patchElementID, String moduleName, byte[] existingHash, ResourceItem resourceItem) throws IOException {\n        File modulesDir = newFile(patchDir, patchElementID, MODULES);\n        File modifiedModule = createModule0(modulesDir, moduleName, resourceItem);\n        byte[] updatedHash = hashFile(modifiedModule);\n        ContentModification moduleUpdated = new ContentModification(new ModuleItem(moduleName, ModuleItem.MAIN_SLOT, updatedHash), existingHash, MODIFY);\n        return moduleUpdated;\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ContentModification addModule(File patchDir, String patchElementID, String moduleName, String... resourceContents) throws IOException {\n        File modulesDir = newFile(patchDir, patchElementID, MODULES);\n        File moduleDir = createModule0(modulesDir, moduleName, resourceContents);\n        byte[] newHash = hashFile(moduleDir);\n        ContentModification moduleAdded = new ContentModification(new ModuleItem(moduleName, ModuleItem.MAIN_SLOT, newHash), NO_CONTENT, ADD);\n        return moduleAdded;\n    }","id":45326,"modified_method":"public static ContentModification addModule(File patchDir, String patchElementID, String moduleName, ResourceItem... resourceItems) throws IOException {\n        File modulesDir = newFile(patchDir, patchElementID, MODULES);\n        File moduleDir = createModule0(modulesDir, moduleName, resourceItems);\n        byte[] newHash = hashFile(moduleDir);\n        ContentModification moduleAdded = new ContentModification(new ModuleItem(moduleName, ModuleItem.MAIN_SLOT, newHash), NO_CONTENT, ADD);\n        return moduleAdded;\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static File createModuleRoot(File baseDir, String moduleSpec) throws IOException {\n        final int c1 = moduleSpec.lastIndexOf(':');\n        final String name;\n        final String slot;\n        if (c1 != -1) {\n            name = moduleSpec.substring(0, c1);\n            slot = moduleSpec.substring(c1 + 1);\n        } else {\n            name = moduleSpec;\n            slot = \"main\";\n        }\n        assert slot.equals(ModuleItem.MAIN_SLOT); // update to support other slots too\n        final String[] segments = name.split(\"\\\\.\");\n        assert segments.length > 0;\n        File dir = baseDir;\n        for (String segment : segments) {\n            dir = new File(dir, segment);\n        }\n        dir = new File(dir, slot);\n        dir.mkdirs();\n        return dir;\n    }","id":45327,"modified_method":"public static File createModuleRoot(File baseDir, String moduleSpec) throws IOException {\n        final int c1 = moduleSpec.lastIndexOf(':');\n        final String name;\n        final String slot;\n        if (c1 != -1) {\n            name = moduleSpec.substring(0, c1);\n            slot = moduleSpec.substring(c1 + 1);\n        } else {\n            name = moduleSpec;\n            slot = \"main\";\n        }\n        final String[] segments = name.split(\"\\\\.\");\n        File dir = baseDir;\n        for (String segment : segments) {\n            dir = new File(dir, segment);\n        }\n        dir = new File(dir, slot);\n        dir.mkdirs();\n        return dir;\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static File createModule0(File baseDir, String moduleName, String... resourcesContents)\n            throws IOException {\n        File mainDir = createModuleRoot(baseDir, moduleName);\n        String resourceFilePrefix = randomString();\n        String[] resourceFileNames = new String[resourcesContents.length];\n        for (int i = 0; i < resourcesContents.length; i++) {\n            String content = resourcesContents[i];\n            String fileName = resourceFilePrefix + \"-\" + i;\n            resourceFileNames[i] = fileName;\n            File f = touch(mainDir, fileName);\n            dump(f, content);\n        }\n        createModuleXmlFile(mainDir, moduleName, resourceFileNames);\n        return mainDir.getParentFile();\n    }","id":45328,"modified_method":"public static File createModule0(File baseDir, String moduleName, ResourceItem... resourcesItems)\n            throws IOException {\n        File mainDir = createModuleRoot(baseDir, moduleName);\n        String[] resourceFileNames = new String[resourcesItems.length];\n        for (int i = 0; i < resourcesItems.length; i++) {\n            ResourceItem item = resourcesItems[i];\n            resourceFileNames[i] = item.getItemName();\n            File f = touch(mainDir, item.getItemName());\n            dump(f, item.getContent());\n        }\n        createModuleXmlFile(mainDir, moduleName, resourceFileNames);\n        return mainDir.getParentFile();\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static File createModuleXmlFile(File mainDir, String moduleName, String... resources)\n            throws IOException {\n        StringBuilder content = new StringBuilder(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n        content.append(\n                format(\"<module xmlns=\\\"urn:jboss:module:1.2\\\" name=\\\"%s\\\" slot=\\\"main\\\" />\\n\", moduleName));\n        content.append(\"  <resources>\\n\");\n        content.append(\"    resource-root path=\\\".\\\"/>\\n\");\n        for (String resource : resources) {\n            content.append(format(\"    <resource-root path=\\\"%s\\\"/>\\n\", resource));\n        }\n        content.append(\"  <\/resources>\\n\");\n        content.append(\"<\/module>\\n\");\n        ROOT_LOGGER.trace(content);\n        File moduleXMLFile = touch(mainDir, \"module.xml\");\n        dump(moduleXMLFile, content.toString());\n        return moduleXMLFile;\n    }","id":45329,"modified_method":"public static File createModuleXmlFile(File mainDir, String moduleName, String... resources)\n            throws IOException {\n        StringBuilder content = new StringBuilder(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n        content.append(\n                format(\"<module xmlns=\\\"urn:jboss:module:1.2\\\" name=\\\"%s\\\" slot=\\\"main\\\" />\\n\", moduleName));\n        content.append(\"  <resources>\\n\");\n        content.append(\"    <resource-root path=\\\".\\\"/>\\n\");\n        for (String resource : resources) {\n            content.append(format(\"    <resource-root path=\\\"%s\\\"/>\\n\", resource));\n        }\n        content.append(\"  <\/resources>\\n\");\n        content.append(\"<\/module>\\n\");\n        ROOT_LOGGER.trace(content);\n        File moduleXMLFile = touch(mainDir, \"module.xml\");\n        dump(moduleXMLFile, content.toString());\n        return moduleXMLFile;\n    }","commit_id":"a18a2777ba222731f0ffb1c15fe6cdc24913ff1b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testPersistentRestart() throws Exception {\n        //AS7-5929\n        cli.sendLine(\":server-set-restart-required\");        \n        CLIOpResult result = cli.readAllAsOpResult();\n        assertTrue(result.isIsOutcomeSuccess());\n        checkResponseHeadersForProcessState(result);\n        cli.sendLine(\":read-resource\");\n        assertTrue(result.isIsOutcomeSuccess());\n        result = cli.readAllAsOpResult();\n        checkResponseHeadersForProcessState(result);\n\n        \n        cli.sendLine(\":reload\");        \n        assertTrue(result.isIsOutcomeSuccess());\n        result = cli.readAllAsOpResult();\n        assertNoProcessState(result);\n        \n        TimeUnit.SECONDS.sleep(10);\n        cli.sendLine(\":read-resource\");        \n        assertTrue(result.isIsOutcomeSuccess());\n        result = cli.readAllAsOpResult();\n        checkResponseHeadersForProcessState(result);\n        \n    }","id":45330,"modified_method":"@Test\n    public void testPersistentRestart() throws Exception {\n        //AS7-5929\n        cli.sendLine(\":server-set-restart-required\");        \n        CLIOpResult result = cli.readAllAsOpResult();\n        assertTrue(result.isIsOutcomeSuccess());\n        checkResponseHeadersForProcessState(result);\n        cli.sendLine(\":read-resource\");\n        result = cli.readAllAsOpResult();\n        assertTrue(result.isIsOutcomeSuccess());\n        checkResponseHeadersForProcessState(result);\n\n        \n        boolean sendLineResult = cli.sendLine(\":reload\",true);\n        assertTrue(sendLineResult);\n        //null when comm is broken on :reload before answer is sent.\n        if (cli.readOutput() != null) {\n            result = cli.readAllAsOpResult();\n            assertTrue(result.isIsOutcomeSuccess());\n            assertNoProcessState(result);\n        }\n        \n        while(!cli.sendConnect()){\n            TimeUnit.SECONDS.sleep(2);\n        }\n\n        cli.sendLine(\":read-resource\");        \n        result = cli.readAllAsOpResult();\n        assertTrue(result.isIsOutcomeSuccess());\n        checkResponseHeadersForProcessState(result);\n        \n    }","commit_id":"b353839fd70887791579ca8cef0e88e20c92f17f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void test() throws Exception {\n        I2PAppContext context = I2PAppContext.getGlobalContext();\n        _log = context.logManager().getLog(ConnectTest.class);\n        _log.debug(\"creating server session\");\n        _server = createSession();\n        _log.debug(\"running server\");\n        runServer(context, _server);\n        _log.debug(\"creating client session\");\n        _client = createSession();\n        _log.debug(\"running client\");\n        runClient(context, _client);\n    }","id":45331,"modified_method":"@Test\n    public void test() throws Exception {\n        I2PAppContext context = I2PAppContext.getGlobalContext();\n        _log = context.logManager().getLog(ConnectTest.class);\n        _log.debug(\"creating server session\");\n        _server = createSession();\n        _log.debug(\"running server\");\n        Thread server = runServer(context, _server);\n        _log.debug(\"creating client session\");\n        _client = createSession();\n        _log.debug(\"running client\");\n        Thread client = runClient(context, _client);\n        client.join();\n    }","commit_id":"740b37b70cc63ad3082d7ddb88ea4d964827f238","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            try {\n                Properties opts = new Properties();\n                I2PSocketManager mgr = new I2PSocketManagerFull(_context, _session, opts, \"client\");\n                _log.debug(\"manager created\");\n                I2PSocket socket = mgr.connect(_server.getMyDestination());\n                _log.debug(\"socket created\");\n                InputStream in = socket.getInputStream();\n                OutputStream out = socket.getOutputStream();\n                for (int i = 0; i < 3; i++) {\n                    byte buf[] = new byte[128*1024];\n                    _context.random().nextBytes(buf);\n                    byte orig[] = new byte[buf.length];\n                    System.arraycopy(buf, 0, orig, 0, buf.length);\n                    out.write(buf);\n                    _log.debug(\"client wrote a buffer\");\n                    out.flush();\n                    _log.debug(\"client flushed\");\n                    \n                    byte rbuf[] = new byte[buf.length];\n                    for (int j = 0; j < buf.length; j++) {\n                        int c = in.read();\n                        if (c == -1) {\n                            buf = null;\n                            break;\n                        } else {                \n                            //_log.debug(\"client read: \" + ((char)c));\n                            if (c < 0) c += 256;\n                            rbuf[j] = (byte)(c & 0xFF);\n                        }\n                    }\n                    if (buf != null) {\n                        _log.debug(\"* client read a full buffer\");\n                        int firstOff = -1;\n                        for (int k = 0; k < orig.length; k++) {\n                            if (orig[k] != rbuf[k]) {\n                                firstOff = k;\n                                break;\n                            }\n                        }\n                        if (firstOff < 0) {\n                            System.out.println(\"** Read match\");\n                        } else {\n                            System.out.println(\"** Read does not match: first off = \" + firstOff);\n                            _log.error(\"read does not match (first off = \" + firstOff + \"): \\n\"\n                                        + Base64.encode(orig) + \"\\n\" \n                                        + Base64.encode(rbuf));\n                        }\n                    }\n                }\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Closing the client socket\");\n                socket.close();\n                _log.debug(\"socket closed\");\n                \n                Thread.sleep(5*1000);\n                System.exit(0);\n            } catch (Exception e) {\n                _log.error(\"error running\", e);\n            }\n        }","id":45332,"modified_method":"public void run() {\n            try {\n                Properties opts = new Properties();\n                I2PSocketManager mgr = new I2PSocketManagerFull(_context, _session, opts, \"client\");\n                _log.debug(\"manager created\");\n                I2PSocket socket = mgr.connect(_server.getMyDestination());\n                _log.debug(\"socket created\");\n                InputStream in = socket.getInputStream();\n                OutputStream out = socket.getOutputStream();\n                for (int i = 0; i < 3; i++) {\n                    byte buf[] = new byte[128*1024];\n                    _context.random().nextBytes(buf);\n                    byte orig[] = new byte[buf.length];\n                    System.arraycopy(buf, 0, orig, 0, buf.length);\n                    out.write(buf);\n                    _log.debug(\"client wrote a buffer\");\n                    out.flush();\n                    _log.debug(\"client flushed\");\n                    \n                    byte rbuf[] = new byte[buf.length];\n                    for (int j = 0; j < buf.length; j++) {\n                        int c = in.read();\n                        if (c == -1) {\n                            buf = null;\n                            break;\n                        } else {                \n                            //_log.debug(\"client read: \" + ((char)c));\n                            if (c < 0) c += 256;\n                            rbuf[j] = (byte)(c & 0xFF);\n                        }\n                    }\n                    if (buf != null) {\n                        _log.debug(\"* client read a full buffer\");\n                        int firstOff = -1;\n                        for (int k = 0; k < orig.length; k++) {\n                            if (orig[k] != rbuf[k]) {\n                                firstOff = k;\n                                break;\n                            }\n                        }\n                        assertTrue(firstOff < 0);\n                    }\n                }\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Closing the client socket\");\n                socket.close();\n                _log.debug(\"socket closed\");\n                \n                Thread.sleep(5*1000);\n            } catch (Exception e) {\n                _log.error(\"error running\", e);\n            }\n        }","commit_id":"740b37b70cc63ad3082d7ddb88ea4d964827f238","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            try {\n                I2PSocketManager mgr = I2PSocketManagerFactory.createManager(\"localhost\", 10001, getProperties());\n                _log.debug(\"manager created\");\n                _log.debug(\"options: \" + mgr.getDefaultOptions());\n                I2PSocket socket = mgr.connect(_serverDest);\n                _log.debug(\"socket created\");\n                socket.getOutputStream().write(\"you smell\".getBytes());\n                socket.getOutputStream().flush();\n                _log.error(\"wtf, shouldn't have flushed\");\n                socket.close();\n                _log.debug(\"socket closed\");\n            } catch (Exception e) {\n                _log.error(\"error running (yay!)\", e);\n            }\n        }","id":45333,"modified_method":"public void run() {\n            I2PSocketManager mgr = I2PSocketManagerFactory.createManager(\"localhost\", 10001, getProperties());\n            assertNull(mgr);\n        }","commit_id":"937404b39c6ea6e6fa6ce9ab65207aa6955d3d08","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Test\n    public void testNonexistant() throws Exception {\n        I2PAppContext context = I2PAppContext.getGlobalContext();\n        _log = context.logManager().getLog(ConnectTest.class);\n        _log.debug(\"creating server dest\");\n        _serverDest = I2PClientFactory.createClient().createDestination(new ByteArrayOutputStream());\n        _log.debug(\"creating client session\");\n        _client = createSession();\n        _log.debug(\"running client\");\n        runClient(context, _client);\n    }","id":45334,"modified_method":"@Test\n    public void testNonexistant() throws Exception {\n        I2PAppContext context = I2PAppContext.getGlobalContext();\n        _log = context.logManager().getLog(ConnectTest.class);\n        _log.debug(\"creating server dest\");\n        _serverDest = I2PClientFactory.createClient().createDestination(new ByteArrayOutputStream());\n        _log.debug(\"creating client session\");\n        _client = createSession();\n        _log.debug(\"running client\");\n        runClient(context, _client).join();\n    }","commit_id":"937404b39c6ea6e6fa6ce9ab65207aa6955d3d08","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    protected Properties getProperties() {\n        Properties p = new Properties();\n        p.setProperty(I2PSocketManagerFactory.PROP_MANAGER, I2PSocketManagerFull.class.getName());\n        p.setProperty(\"tunnels.depthInbound\", \"0\");\n        p.setProperty(I2PClient.PROP_TCP_HOST, \"localhost\");\n        p.setProperty(I2PClient.PROP_TCP_PORT, \"10001\");\n        p.setProperty(ConnectionOptions.PROP_CONNECT_TIMEOUT, \"30000\");\n        //p.setProperty(ConnectionOptions.PROP_CONNECT_DELAY, \"10000\");\n        p.setProperty(ConnectionOptions.PROP_CONNECT_DELAY, \"0\");\n        return p;\n    }","id":45335,"modified_method":"@Override\n    protected Properties getProperties() {\n        Properties p = new Properties();\n        p.setProperty(I2PSocketManagerFactory.PROP_MANAGER, I2PSocketManagerFull.class.getName());\n        p.setProperty(\"tunnels.depthInbound\", \"0\");\n        p.setProperty(ConnectionOptions.PROP_CONNECT_TIMEOUT, \"30000\");\n        //p.setProperty(ConnectionOptions.PROP_CONNECT_DELAY, \"10000\");\n        p.setProperty(ConnectionOptions.PROP_CONNECT_DELAY, \"0\");\n        return p;\n    }","commit_id":"937404b39c6ea6e6fa6ce9ab65207aa6955d3d08","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            try {\n                Properties opts = new Properties();\n                I2PSocketManager mgr = new I2PSocketManagerFull(_context, _session, opts, \"client\");\n                _log.debug(\"manager created\");\n                I2PServerSocket ssocket = mgr.getServerSocket();\n                _log.debug(\"server socket created\");\n                I2PSocket socket = ssocket.accept();\n                _log.debug(\"socket accepted: \" + socket);\n                try { Thread.sleep(10*60*1000); } catch (InterruptedException ie) {}\n                socket.close();\n                ssocket.close();\n                _session.destroySession();\n            } catch (Exception e) {\n                _log.error(\"error running\", e);\n            }\n        }","id":45336,"modified_method":"public void run() {\n            try {\n                Properties opts = new Properties();\n                I2PSocketManager mgr = new I2PSocketManagerFull(_context, _session, opts, \"client\");\n                _log.debug(\"manager created\");\n                I2PServerSocket ssocket = mgr.getServerSocket();\n                _log.debug(\"server socket created\");\n                I2PSocket socket = ssocket.accept();\n                sleep();\n                _log.debug(\"socket accepted: \" + socket);\n                socket.close();\n                ssocket.close();\n                _session.destroySession();\n            } catch (Exception e) {\n                fail(e.getMessage());\n                _log.error(\"error running\", e);\n            }\n        }","commit_id":"67f73d71985dbf5eb674ad4fdb2715ac598c9b3d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    protected Properties getProperties() {\n        Properties p = new Properties();\n        p.setProperty(I2PClient.PROP_TCP_HOST, \"localhost\");\n        p.setProperty(I2PClient.PROP_TCP_PORT, \"10001\");\n        return p;\n    }","id":45337,"modified_method":"@Override\n    protected Properties getProperties() {\n        Properties p = new Properties();\n//        p.setProperty(I2PClient.PROP_TCP_HOST, \"localhost\");\n//        p.setProperty(I2PClient.PROP_TCP_PORT, \"10001\");\n        return p;\n    }","commit_id":"67f73d71985dbf5eb674ad4fdb2715ac598c9b3d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            try {\n                Properties opts = new Properties();\n                I2PSocketManager mgr = new I2PSocketManagerFull(_context, _session, opts, \"client\");\n                _log.debug(\"manager created\");\n                I2PSocket socket = mgr.connect(_server.getMyDestination());\n                _log.debug(\"socket created\");\n                Thread.sleep(10*60*1000); \n                socket.close();\n                _log.debug(\"socket closed\");\n                //_session.destroySession();\n            } catch (Exception e) {\n                _log.error(\"error running\", e);\n            }\n        }","id":45338,"modified_method":"public void run() {\n            try {\n                Properties opts = new Properties();\n                I2PSocketManager mgr = new I2PSocketManagerFull(_context, _session, opts, \"client\");\n                _log.debug(\"manager created\");\n                I2PSocket socket = mgr.connect(_server.getMyDestination());\n                _log.debug(\"socket created\");\n                sleep();\n                socket.close();\n                _log.debug(\"socket closed\");\n                //_session.destroySession();\n            } catch (Exception e) {\n                fail(e.getMessage());\n                _log.error(\"error running\", e);\n            }\n        }","commit_id":"67f73d71985dbf5eb674ad4fdb2715ac598c9b3d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Test\n    public void test() throws Exception {\n        I2PAppContext context = I2PAppContext.getGlobalContext();\n        _log = context.logManager().getLog(ConnectTest.class);\n        _log.debug(\"creating server session\");\n        _server = createSession();\n        _log.debug(\"running server\");\n        runServer(context, _server);\n        _log.debug(\"creating client session\");\n        _client = createSession();\n        _log.debug(\"running client\");\n        runClient(context, _client);\n    }","id":45339,"modified_method":"@Test\n    public void test() throws Exception {\n        I2PAppContext context = I2PAppContext.getGlobalContext();\n        _log = context.logManager().getLog(ConnectTest.class);\n        _log.debug(\"creating server session\");\n        _server = createSession();\n        _log.debug(\"running server\");\n        runServer(context, _server);\n        _log.debug(\"creating client session\");\n        _client = createSession();\n        \n        _log.debug(\"running client\");\n        Thread client = runClient(context, _client);\n        client.join(LONG_TIME + 1000);\n    }","commit_id":"67f73d71985dbf5eb674ad4fdb2715ac598c9b3d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected VersionData getVersionData(String version) {\n        assertValid();\n        VersionData data = null;\n        try {\n            data = cachedVersions.get(version);\n        } catch (ExecutionException e) {\n            FabricException.launderThrowable(e);\n        }\n        return data;\n    }","id":45340,"modified_method":"protected VersionData getVersionData(String version) {\n        assertValid();\n        VersionData data = null;\n        try {\n            data = cachedVersions.get(version);\n        } catch (ExecutionException e) {\n            throw FabricException.launderThrowable(e);\n        }\n        return data;\n    }","commit_id":"cdc244527b189d32c2220a69d9327c789980ae6d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void registerServlet() {\n        try {\n            HttpContext base = httpService.get().createDefaultHttpContext();\n            HttpContext secure = new SecureHttpContext(base, realm, role);\n            String basePath = System.getProperty(\"karaf.data\") + File.separator + \"git\" + File.separator + \"servlet\" + File.separator;\n            String fabricGitPath = basePath + \"fabric\";\n            File fabricRoot = new File(fabricGitPath);\n\n            //Only need to clone once. If repo already exists, just skip.\n            if (!fabricRoot.exists()) {\n                Git localGit = gitService.get().get();\n                Git.cloneRepository()\n                        .setBare(true)\n                        .setNoCheckout(true)\n                        .setCloneAllBranches(true)\n                        .setDirectory(fabricRoot)\n                        .setURI(localGit.getRepository().getDirectory().toURI().toString())\n                        .call();\n            }\n\n            Dictionary<String, Object> initParams = new Hashtable<String, Object>();\n            initParams.put(\"base-path\", basePath);\n            initParams.put(\"repository-root\", basePath);\n            initParams.put(\"export-all\", \"true\");\n            httpService.get().registerServlet(\"/git\", gitServlet, initParams, secure);\n            activateComponent();\n        } catch (Exception e) {\n            FabricException.launderThrowable(e);\n        }\n    }","id":45341,"modified_method":"private void registerServlet() {\n        try {\n            HttpContext base = httpService.get().createDefaultHttpContext();\n            HttpContext secure = new SecureHttpContext(base, realm, role);\n            String basePath = System.getProperty(\"karaf.data\") + File.separator + \"git\" + File.separator + \"servlet\" + File.separator;\n            String fabricGitPath = basePath + \"fabric\";\n            File fabricRoot = new File(fabricGitPath);\n\n            //Only need to clone once. If repo already exists, just skip.\n            if (!fabricRoot.exists()) {\n                Git localGit = gitService.get().get();\n                Git.cloneRepository()\n                        .setBare(true)\n                        .setNoCheckout(true)\n                        .setCloneAllBranches(true)\n                        .setDirectory(fabricRoot)\n                        .setURI(localGit.getRepository().getDirectory().toURI().toString())\n                        .call();\n            }\n\n            Dictionary<String, Object> initParams = new Hashtable<String, Object>();\n            initParams.put(\"base-path\", basePath);\n            initParams.put(\"repository-root\", basePath);\n            initParams.put(\"export-all\", \"true\");\n            httpService.get().registerServlet(\"/git\", gitServlet, initParams, secure);\n            activateComponent();\n        } catch (Exception e) {\n            throw FabricException.launderThrowable(e);\n        }\n    }","commit_id":"cdc244527b189d32c2220a69d9327c789980ae6d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void waitForSuccessfulDeploymentOf(String containerName, long timeout) throws InterruptedException {\n        System.out.println(String.format(\"Waiting for container %s to provision.\", containerName));\n        FabricService fabric = fabricService.get();\n        long startedAt = System.currentTimeMillis();\n        while (!Thread.interrupted() && startedAt + timeout > System.currentTimeMillis()) {\n            try {\n                Container container = fabric != null ? fabric.getContainer(containerName) : null;\n                if (container != null && container.isAlive() && \"success\".equals(container.getProvisionStatus())) {\n                    return;\n                }\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } catch (Throwable t) {\n                FabricException.launderThrowable(t);\n            }\n        }\n    }","id":45342,"modified_method":"private void waitForSuccessfulDeploymentOf(String containerName, long timeout) throws InterruptedException {\n        System.out.println(String.format(\"Waiting for container %s to provision.\", containerName));\n        FabricService fabric = fabricService.get();\n        long startedAt = System.currentTimeMillis();\n        while (!Thread.interrupted() && startedAt + timeout > System.currentTimeMillis()) {\n            try {\n                Container container = fabric != null ? fabric.getContainer(containerName) : null;\n                if (container != null && container.isAlive() && \"success\".equals(container.getProvisionStatus())) {\n                    return;\n                }\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } catch (Throwable t) {\n                throw FabricException.launderThrowable(t);\n            }\n        }\n    }","commit_id":"cdc244527b189d32c2220a69d9327c789980ae6d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n\t * Imports the resources and writes them to the cms.\n\t */\n\tprivate void importResources() \n\t\tthrows CmsException {\n\t\t\n\t\tNodeList fileNodes, propertyNodes;\n\t\tElement currentElement, currentProperty;\n\t\tString source, destination, type, user, group, access;\n\t\tHashtable properties;\n\t\t\n\t\t// first lock the resource to import\n\t\tm_cms.lockResource(m_importPath);\n\t\t\n\t\ttry {\n\t\t\t// get all file-nodes\n\t\t\tfileNodes = m_docXml.getElementsByTagName(C_TAG_FILE);\n\t\t\t\n\t\t\t// walk through all files in manifest\n\t\t\tfor(int i = 0; i < fileNodes.getLength(); i++) {\n\t\t\t\tcurrentElement = (Element) fileNodes.item(i);\n\t\t\t\t\n\t\t\t\t// get all informations for a file-import\n\t\t\t\tsource = getTextNodeValue(currentElement, C_TAG_SOURCE);\n\t\t\t\tdestination = getTextNodeValue(currentElement, C_TAG_DESTINATION);\n\t\t\t\ttype = getTextNodeValue(currentElement, C_TAG_TYPE);\n\t\t\t\tuser = getTextNodeValue(currentElement, C_TAG_USER);\n\t\t\t\tgroup = getTextNodeValue(currentElement, C_TAG_GROUP);\n\t\t\t\taccess = getTextNodeValue(currentElement, C_TAG_ACCESS);\n\t\t\t\t\n\t\t\t\t// get all properties for this file\n\t\t\t\tpropertyNodes = currentElement.getElementsByTagName(C_TAG_PROPERTY);\n\t\t\t\t// clear all stores for propertyinformations\n\t\t\t\tproperties = new Hashtable();\n\t\t\t\t// walk through all properties\n\t\t\t\tfor(int j = 0; j < propertyNodes.getLength(); j++) {\n\t\t\t\t\tcurrentProperty = (Element) propertyNodes.item(j);\n\t\t\t\t\t// get all information for this property\n\t\t\t\t\tString name = getTextNodeValue(currentProperty, C_TAG_NAME);\n\t\t\t\t\tString propertyType = getTextNodeValue(currentProperty, C_TAG_TYPE);\n\t\t\t\t\tString value = getTextNodeValue(currentProperty, C_TAG_VALUE);\n\t\t\t\t\t// store these informations\n\t\t\t\t\tproperties.put(name, value);\n\t\t\t\t\tcreatePropertydefinition(name, propertyType, type);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// import the specified file\n\t\t\t\timportFile(source, destination, type, user, group, access, properties);\n\t\t\t}\n\t\t\t\n\t\t} catch(Exception exc) {\n\t\t\tthrow new CmsException(CmsException.C_UNKNOWN_EXCEPTION, exc);\n\t\t}\t\t\n\t\t// all is done, unlock the resource\n\t\tm_cms.unlockResource(m_importPath);\n\t}","id":45343,"modified_method":"/**\n\t * Imports the resources and writes them to the cms.\n\t */\n\tprivate void importResources() \n\t\tthrows CmsException {\n\t\t\n\t\tNodeList fileNodes, propertyNodes;\n\t\tElement currentElement, currentProperty;\n\t\tString source, destination, type, user, group, access;\n\t\tHashtable properties;\n\t\t\n\t\t// first lock the resource to import\n\t\tm_cms.lockResource(m_importPath);\n\t\t\n\t\ttry {\n\t\t\t// get all file-nodes\n\t\t\tfileNodes = m_docXml.getElementsByTagName(C_TAG_FILE);\n\t\t\t\n\t\t\t// walk through all files in manifest\n\t\t\tfor(int i = 0; i < fileNodes.getLength(); i++) {\n\t\t\t\tcurrentElement = (Element) fileNodes.item(i);\n\t\t\t\t\n\t\t\t\t// get all informations for a file-import\n\t\t\t\tsource = getTextNodeValue(currentElement, C_TAG_SOURCE);\n\t\t\t\tdestination = getTextNodeValue(currentElement, C_TAG_DESTINATION);\n\t\t\t\ttype = getTextNodeValue(currentElement, C_TAG_TYPE);\n\t\t\t\tuser = getTextNodeValue(currentElement, C_TAG_USER);\n\t\t\t\tgroup = getTextNodeValue(currentElement, C_TAG_GROUP);\n\t\t\t\taccess = getTextNodeValue(currentElement, C_TAG_ACCESS);\n\t\t\t\t\n\t\t\t\t// get all properties for this file\n\t\t\t\tpropertyNodes = currentElement.getElementsByTagName(C_TAG_PROPERTY);\n\t\t\t\t// clear all stores for propertyinformations\n\t\t\t\tproperties = new Hashtable();\n\t\t\t\t// walk through all properties\n\t\t\t\tfor(int j = 0; j < propertyNodes.getLength(); j++) {\n\t\t\t\t\tcurrentProperty = (Element) propertyNodes.item(j);\n\t\t\t\t\t// get all information for this property\n\t\t\t\t\tString name = getTextNodeValue(currentProperty, C_TAG_NAME);\n\t\t\t\t\tString propertyType = getTextNodeValue(currentProperty, C_TAG_TYPE);\n\t\t\t\t\tString value = getTextNodeValue(currentProperty, C_TAG_VALUE);\n\t\t\t\t\t// store these informations\n\t\t\t\t\tif( (name != null) && (value != null) ) {\n\t\t\t\t\t\tproperties.put(name, value);\n\t\t\t\t\t\tcreatePropertydefinition(name, propertyType, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// import the specified file\n\t\t\t\timportFile(source, destination, type, user, group, access, properties);\n\t\t\t}\n\t\t\t\n\t\t} catch(Exception exc) {\n\t\t\tthrow new CmsException(CmsException.C_UNKNOWN_EXCEPTION, exc);\n\t\t}\t\t\n\t\t// all is done, unlock the resource\n\t\tm_cms.unlockResource(m_importPath);\n\t}","commit_id":"eaa41a9ca668aae45dc6eada846e53df280a3408","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n\tpublic void handleMessage(String pattern, String channel, String message) {\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.FROM_VOICE_CONF_SYSTEM_CHAN)) {\n\t\t\tJsonParser parser = new JsonParser();\n\t\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\t\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\t\tif (header.has(\"name\")) {\n\t\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\n\t\t\t\t\tif (DeskShareStartedEventMessage.DESK_SHARE_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareStartedEventMessage msg = DeskShareStartedEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareEndedEventMessage.DESK_SHARE_ENDED_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareEndedEventMessage msg = DeskShareEndedEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareViewerJoinedEventMessage.DESK_SHARE_VIEWER_JOINED_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareViewerJoinedEventMessage msg = DeskShareViewerJoinedEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareViewerLeftEventMessage.DESK_SHARE_VIEWER_LEFT_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareViewerLeftEventMessage msg = DeskShareViewerLeftEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":45344,"modified_method":"@Override\n\tpublic void handleMessage(String pattern, String channel, String message) {\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.FROM_VOICE_CONF_SYSTEM_CHAN)) {\n\t\t\tJsonParser parser = new JsonParser();\n\t\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\t\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\t\tif (header.has(\"name\")) {\n\t\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\n\t\t\t\t\tif (DeskShareStartedEventMessage.DESKSHARE_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareStartedEventMessage msg = DeskShareStartedEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareEndedEventMessage.DESK_SHARE_ENDED_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareEndedEventMessage msg = DeskShareEndedEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareViewerJoinedEventMessage.DESK_SHARE_VIEWER_JOINED_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareViewerJoinedEventMessage msg = DeskShareViewerJoinedEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareViewerLeftEventMessage.DESK_SHARE_VIEWER_LEFT_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareViewerLeftEventMessage msg = DeskShareViewerLeftEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t} else if (DeskShareStartRecordingEventMessage.DESKSHARE_START_RECORDING_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareStartRecordingEventMessage msg = DeskShareStartRecordingEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tSystem.out.println(\"^^^^^^^START REC^^^^^^\");\n\t\t\t\t\t} else if (DeskShareStopRecordingEventMessage.DESKSHARE_STOP_RECORDING_MESSAGE.equals(messageName)) {\n\t\t\t\t\t\tDeskShareStopRecordingEventMessage msg = DeskShareStopRecordingEventMessage.fromJson(message);\n//\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tSystem.out.println(\"^^^^^^^STOP REC^^^^^^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"8b161e82172b9fc1f9e103a7537d2e4377da621c","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(CALLER_ID_NAME, callerIdName);\n\t\tpayload.put(CALLER_ID, callerId);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESK_SHARE_STARTED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","id":45345,"modified_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(CALLER_ID_NAME, callerIdName);\n\t\tpayload.put(CALLER_ID, callerId);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_STARTED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","commit_id":"8b161e82172b9fc1f9e103a7537d2e4377da621c","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public static DeskShareStartedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESK_SHARE_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(CALLER_ID)\n\t\t\t\t\t\t\t&& payload.has(CALLER_ID_NAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString callerId = payload.get(CALLER_ID_NAME).getAsString();\n\t\t\t\t\t\tString callerIdName = payload.get(CALLER_ID_NAME).getAsString();\n\n\t\t\t\t\t\treturn new DeskShareStartedEventMessage(conferenceName, callerId, callerIdName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","id":45346,"modified_method":"public static DeskShareStartedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(CALLER_ID)\n\t\t\t\t\t\t\t&& payload.has(CALLER_ID_NAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString callerId = payload.get(CALLER_ID_NAME).getAsString();\n\t\t\t\t\t\tString callerIdName = payload.get(CALLER_ID_NAME).getAsString();\n\n\t\t\t\t\t\treturn new DeskShareStartedEventMessage(conferenceName, callerId, callerIdName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"8b161e82172b9fc1f9e103a7537d2e4377da621c","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event) {\r\n    \tString action = event.getEventHeaders().get(\"Action\");\r\n    \t\r\n        if(action == null) {          \r\n            return;\r\n        }\r\n        \r\n    \tSystem.out.println(\"Handling conferenceEventRecord \" + action);\r\n    \t\r\n    \tif (action.equals(START_RECORDING_EVENT)) {\r\n            VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, true);\r\n            sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n            sre.setTimestamp(genTimestamp().toString());\r\n            \r\n            System.out.println(\"Voice conference recording started. file=[\" + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n            \r\n            conferenceEventListener.handleConferenceEvent(sre);    \t\t\r\n    \t} else if (action.equals(STOP_RECORDING_EVENT)) {\r\n        \tVoiceStartRecordingEvent srev = new VoiceStartRecordingEvent(confName, false);\r\n            srev.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n            srev.setTimestamp(genTimestamp().toString());\r\n            \r\n            System.out.println(\"Voice conference recording stopped. file=[\" + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");           \r\n            conferenceEventListener.handleConferenceEvent(srev);    \t\t\r\n    \t} else {\r\n    \t\tSystem.out.println(\"Processing UNKNOWN conference Action \" + action + \"]\");\r\n    \t}\r\n    }","id":45347,"modified_method":"public void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event) {\r\n        String action = event.getEventHeaders().get(\"Action\");\r\n\r\n        if(action == null) {\r\n            return;\r\n        }\r\n\r\n        System.out.println(\"Handling conferenceEventRecord \" + action);\r\n\r\n        if (action.equals(START_RECORDING_EVENT)) {\r\n            if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_LABEL)){\r\n                DeskShareRecordingEvent dssre = new DeskShareRecordingEvent(confName, true);\r\n                dssre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                dssre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"DeskShare conference recording started. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)dssre);\r\n            } else {\r\n                VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, true);\r\n                sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                sre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"Voice conference recording started. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent(sre);\r\n            }\r\n        } else if (action.equals(STOP_RECORDING_EVENT)) {\r\n            if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_LABEL)){\r\n            \tDeskShareRecordingEvent dssre = new DeskShareRecordingEvent(confName, false);\r\n                dssre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                dssre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"DeskShare conference recording stopped. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)dssre);\r\n            } else {\r\n                VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, false);\r\n                sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                sre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"Voice conference recording stopped. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent(sre);\r\n            }\r\n        } else {\r\n            System.out.println(\"Processing UNKNOWN conference Action \" + action + \"]\");\r\n        }\r\n    }","commit_id":"8b161e82172b9fc1f9e103a7537d2e4377da621c","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendMessageToFreeswitch(final FreeswitchCommand command) {\n\t\t\tRunnable task = new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (command instanceof GetAllUsersCommand) {\n\t\t\t\t\t\tGetAllUsersCommand cmd = (GetAllUsersCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending PopulateRoomCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.getUsers(cmd);\n\t\t\t\t\t} else if (command instanceof MuteUserCommand) {\n\t\t\t\t\t\tMuteUserCommand cmd = (MuteUserCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending MuteParticipantCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tSystem.out.println(\"Sending MuteParticipantCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.mute(cmd);\n\t\t\t\t\t} else if (command instanceof EjectUserCommand) {\n\t\t\t\t\t\tEjectUserCommand cmd = (EjectUserCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending EjectParticipantCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.eject(cmd);\n\t\t\t\t\t} else if (command instanceof EjectAllUsersCommand) {\n\t\t\t\t\t\tEjectAllUsersCommand cmd = (EjectAllUsersCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending EjectAllUsersCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.ejectAll(cmd);\n\t\t\t\t\t} else if (command instanceof RecordConferenceCommand) {\n\t\t\t\t\t\tmanager.record((RecordConferenceCommand) command);\n\t\t\t\t\t} else if (command instanceof BroadcastConferenceCommand) {\n\t\t\t\t\t\tmanager.broadcast((BroadcastConferenceCommand) command);\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\trunExec.execute(task);\t\n\t\t}","id":45348,"modified_method":"private void sendMessageToFreeswitch(final FreeswitchCommand command) {\n\t\t\tRunnable task = new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (command instanceof GetAllUsersCommand) {\n\t\t\t\t\t\tGetAllUsersCommand cmd = (GetAllUsersCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending PopulateRoomCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.getUsers(cmd);\n\t\t\t\t\t} else if (command instanceof MuteUserCommand) {\n\t\t\t\t\t\tMuteUserCommand cmd = (MuteUserCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending MuteParticipantCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tSystem.out.println(\"Sending MuteParticipantCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.mute(cmd);\n\t\t\t\t\t} else if (command instanceof EjectUserCommand) {\n\t\t\t\t\t\tEjectUserCommand cmd = (EjectUserCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending EjectParticipantCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.eject(cmd);\n\t\t\t\t\t} else if (command instanceof EjectAllUsersCommand) {\n\t\t\t\t\t\tEjectAllUsersCommand cmd = (EjectAllUsersCommand) command;\n\t\t\t\t\t\tSystem.out.println(\"Sending EjectAllUsersCommand for conference = [\" + cmd.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.ejectAll(cmd);\n\t\t\t\t\t} else if (command instanceof RecordConferenceCommand) {\n\t\t\t\t\t\tmanager.record((RecordConferenceCommand) command);\n\t\t\t\t\t} else if (command instanceof DeskShareRecordCommand) {\n\t\t\t\t\t\tSystem.out.println(\"Sending DeskShareRecordCommand for conference = [\" + command.getRoom() + \"]\");\n\t\t\t\t\t\tmanager.record((DeskShareRecordCommand)command);\n\t\t\t\t\t} else if (command instanceof BroadcastConferenceCommand) {\n\t\t\t\t\t\tmanager.broadcast((BroadcastConferenceCommand) command);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\trunExec.execute(task);\n\t\t}","commit_id":"8b161e82172b9fc1f9e103a7537d2e4377da621c","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendMessageToBigBlueButton(final VoiceConferenceEvent event) {\r\n\t\tRunnable task = new Runnable() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\tif (event instanceof VoiceUserJoinedEvent) {\r\n\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received voiceUserJoined \");\r\n\t\t\t\tVoiceUserJoinedEvent evt = (VoiceUserJoinedEvent) event;\r\n\t\t\t\tvcs.userJoinedVoiceConf(evt.getRoom(), evt.getVoiceUserId(), evt.getUserId(), evt.getCallerIdName(), \r\n\t\t\t\t\t\tevt.getCallerIdNum(), evt.getMuted(), evt.getSpeaking());\r\n\t\t\t\t} else if (event instanceof VoiceUserLeftEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received VoiceUserLeftEvent \");\r\n\t\t\t\t\tVoiceUserLeftEvent evt = (VoiceUserLeftEvent) event;\r\n\t\t\t\t\tvcs.userLeftVoiceConf(evt.getRoom(), evt.getUserId());\r\n\t\t\t\t} else if (event instanceof VoiceUserMutedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserMutedEvent \");\r\n\t\t\t\t\tVoiceUserMutedEvent evt = (VoiceUserMutedEvent) event;\r\n\t\t\t\t\tvcs.userMutedInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isMuted());\r\n\t\t\t\t} else if (event instanceof VoiceUserTalkingEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserTalkingEvent \");\r\n\t\t\t\t\tVoiceUserTalkingEvent evt = (VoiceUserTalkingEvent) event;\r\n\t\t\t\t\tvcs.userTalkingInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isTalking());\r\n\t\t\t\t} else if (event instanceof VoiceStartRecordingEvent) {\r\n\t\t\t\t\tVoiceStartRecordingEvent evt = (VoiceStartRecordingEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceStartRecordingEvent recording=[\" + evt.startRecord() + \"]\");\r\n\t\t\t\t\tvcs.voiceConfRecordingStarted(evt.getRoom(), evt.getRecordingFilename(), evt.startRecord(), evt.getTimestamp());\r\n\t\t\t\t} else if (event instanceof DeskShareStartedEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********START******\\n\\n\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareStartedEvent evt = (DeskShareStartedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareStartedEvent\");\r\n\t\t\t\t\tvcs.deskShareStarted(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareEndedEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********END******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareEndedEvent evt = (DeskShareEndedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareEndedEvent\");\r\n\t\t\t\t\tvcs.deskShareEnded(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareViewerJoinedEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********VIEWER JOINED******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareViewerJoinedEvent evt = (DeskShareViewerJoinedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerJoinedEvent\");\r\n\t\t\t\t\tvcs.deskShareViewerJoined(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareViewerLeftEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********VIEWER LEFT******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareViewerLeftEvent evt = (DeskShareViewerLeftEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerLeftEvent\");\r\n\t\t\t\t\tvcs.deskShareViewerLeft(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\trunExec.execute(task);\r\n\t}","id":45349,"modified_method":"private void sendMessageToBigBlueButton(final VoiceConferenceEvent event) {\r\n\t\tRunnable task = new Runnable() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\tif (event instanceof VoiceUserJoinedEvent) {\r\n\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received voiceUserJoined \");\r\n\t\t\t\tVoiceUserJoinedEvent evt = (VoiceUserJoinedEvent) event;\r\n\t\t\t\tvcs.userJoinedVoiceConf(evt.getRoom(), evt.getVoiceUserId(), evt.getUserId(), evt.getCallerIdName(), \r\n\t\t\t\t\t\tevt.getCallerIdNum(), evt.getMuted(), evt.getSpeaking());\r\n\t\t\t\t} else if (event instanceof VoiceUserLeftEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received VoiceUserLeftEvent \");\r\n\t\t\t\t\tVoiceUserLeftEvent evt = (VoiceUserLeftEvent) event;\r\n\t\t\t\t\tvcs.userLeftVoiceConf(evt.getRoom(), evt.getUserId());\r\n\t\t\t\t} else if (event instanceof VoiceUserMutedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserMutedEvent \");\r\n\t\t\t\t\tVoiceUserMutedEvent evt = (VoiceUserMutedEvent) event;\r\n\t\t\t\t\tvcs.userMutedInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isMuted());\r\n\t\t\t\t} else if (event instanceof VoiceUserTalkingEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserTalkingEvent \");\r\n\t\t\t\t\tVoiceUserTalkingEvent evt = (VoiceUserTalkingEvent) event;\r\n\t\t\t\t\tvcs.userTalkingInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isTalking());\r\n\t\t\t\t} else if (event instanceof VoiceStartRecordingEvent) {\r\n\t\t\t\t\tVoiceStartRecordingEvent evt = (VoiceStartRecordingEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceStartRecordingEvent recording=[\" + evt.startRecord() + \"]\");\r\n\t\t\t\t\tvcs.voiceConfRecordingStarted(evt.getRoom(), evt.getRecordingFilename(), evt.startRecord(), evt.getTimestamp());\r\n\t\t\t\t} else if (event instanceof DeskShareStartedEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********START******\\n\\n\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareStartedEvent evt = (DeskShareStartedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareStartedEvent\");\r\n\t\t\t\t\tvcs.deskShareStarted(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareEndedEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********END******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareEndedEvent evt = (DeskShareEndedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareEndedEvent\");\r\n\t\t\t\t\tvcs.deskShareEnded(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareViewerJoinedEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********VIEWER JOINED******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareViewerJoinedEvent evt = (DeskShareViewerJoinedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerJoinedEvent\");\r\n\t\t\t\t\tvcs.deskShareViewerJoined(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareViewerLeftEvent) {\r\n//\t\t\t\t\tSystem.out.println(\"********VIEWER LEFT******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareViewerLeftEvent evt = (DeskShareViewerLeftEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerLeftEvent\");\r\n\t\t\t\t\tvcs.deskShareViewerLeft(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareRecordingEvent) {\r\n\t\t\t\t\tSystem.out.println(\"******** RECORDING******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareRecordingEvent evt = (DeskShareRecordingEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRecordingEvent\");\r\n\t\t\t\t\tvcs.deskShareRecording(evt.getRoom(), evt.getRecordingFilename(), evt.getRecord(), evt.getTimestamp());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\trunExec.execute(task);\r\n\t}","commit_id":"8b161e82172b9fc1f9e103a7537d2e4377da621c","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public static DeskShareRTMPBroadcastStartedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RTMP_BROADCAST_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(STREAMNAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString streamname = payload.get(STREAMNAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\n\t\t\t\t\t\treturn new DeskShareRTMPBroadcastStartedEventMessage(conferenceName, streamname, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","id":45350,"modified_method":"public static DeskShareRTMPBroadcastStartedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RTMP_BROADCAST_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(CHANNELS)\n\t\t\t\t\t\t\t&& payload.has(SAMPLERATE)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_HEIGHT)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_WIDTH)\n\t\t\t\t\t\t\t&& payload.has(FRAMES_PER_SECOND)\n\t\t\t\t\t\t\t&& payload.has(STREAMNAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString streamname = payload.get(STREAMNAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\t\t\t\t\t\tint channels = payload.get(CHANNELS).getAsInt();\n\t\t\t\t\t\tint samplerate = payload.get(SAMPLERATE).getAsInt();\n\t\t\t\t\t\tint vh = payload.get(VIDEO_HEIGHT).getAsInt();\n\t\t\t\t\t\tint vw = payload.get(VIDEO_WIDTH).getAsInt();\n\t\t\t\t\t\tdouble fps = payload.get(FRAMES_PER_SECOND).getAsDouble();\n\n\t\t\t\t\t\treturn new DeskShareRTMPBroadcastStartedEventMessage(conferenceName, streamname, channels,\n\t\t\t\t\t\t\t\tsamplerate, vw, vh, fps, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(STREAMNAME, streamname);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RTMP_BROADCAST_STARTED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","id":45351,"modified_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(STREAMNAME, streamname);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\t\tpayload.put(CHANNELS, channels);\n\t\tpayload.put(SAMPLERATE, samplerate);\n\t\tpayload.put(VIDEO_HEIGHT, vh);\n\t\tpayload.put(VIDEO_WIDTH, vw);\n\t\tpayload.put(FRAMES_PER_SECOND, fps);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RTMP_BROADCAST_STARTED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public DeskShareRTMPBroadcastStartedEventMessage(String conferenceName, String streamname, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.streamname = streamname;\n\t\tthis.timestamp = timestamp;\n\t}","id":45352,"modified_method":"public DeskShareRTMPBroadcastStartedEventMessage(String conferenceName, String streamname, int channels,\n\t\t\tint samplerate, int vw, int vh, double fps, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.streamname = streamname;\n\t\tthis.timestamp = timestamp;\n\t\tthis.channels = channels;\n\t\tthis.samplerate = samplerate;\n\t\tthis.vw = vw;\n\t\tthis.vh = vh;\n\t\tthis.fps = fps;\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public static DeskShareRTMPBroadcastStoppedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RTMP_BROADCAST_STOPPED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(STREAMNAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString streamname = payload.get(STREAMNAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\n\t\t\t\t\t\treturn new DeskShareRTMPBroadcastStoppedEventMessage(conferenceName, streamname, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","id":45353,"modified_method":"public static DeskShareRTMPBroadcastStoppedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RTMP_BROADCAST_STOPPED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(CHANNELS)\n\t\t\t\t\t\t\t&& payload.has(SAMPLERATE)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_HEIGHT)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_WIDTH)\n\t\t\t\t\t\t\t&& payload.has(FRAMES_PER_SECOND)\n\t\t\t\t\t\t\t&& payload.has(STREAMNAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString streamname = payload.get(STREAMNAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\t\t\t\t\t\tint channels = payload.get(CHANNELS).getAsInt();\n\t\t\t\t\t\tint samplerate = payload.get(SAMPLERATE).getAsInt();\n\t\t\t\t\t\tint vh = payload.get(VIDEO_HEIGHT).getAsInt();\n\t\t\t\t\t\tint vw = payload.get(VIDEO_WIDTH).getAsInt();\n\t\t\t\t\t\tdouble fps = payload.get(FRAMES_PER_SECOND).getAsDouble();\n\n\t\t\t\t\t\treturn new DeskShareRTMPBroadcastStoppedEventMessage(conferenceName, streamname, channels,\n\t\t\t\t\t\t\t\tsamplerate, vw, vh, fps, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public DeskShareRTMPBroadcastStoppedEventMessage(String conferenceName, String streamname, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.streamname = streamname;\n\t\tthis.timestamp = timestamp;\n\t}","id":45354,"modified_method":"public DeskShareRTMPBroadcastStoppedEventMessage(String conferenceName, String streamname, int channels,\n\t\t\tint samplerate, int vw, int vh, double fps, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.streamname = streamname;\n\t\tthis.timestamp = timestamp;\n\t\tthis.channels = channels;\n\t\tthis.samplerate = samplerate;\n\t\tthis.vw = vw;\n\t\tthis.vh = vh;\n\t\tthis.fps = fps;\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(STREAMNAME, streamname);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RTMP_BROADCAST_STOPPED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","id":45355,"modified_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(STREAMNAME, streamname);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\t\tpayload.put(CHANNELS, channels);\n\t\tpayload.put(SAMPLERATE, samplerate);\n\t\tpayload.put(VIDEO_HEIGHT, vh);\n\t\tpayload.put(VIDEO_WIDTH, vw);\n\t\tpayload.put(FRAMES_PER_SECOND, fps);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RTMP_BROADCAST_STOPPED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(FILENAME, filename);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RECORDING_STARTED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","id":45356,"modified_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(FILENAME, filename);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\t\tpayload.put(CHANNELS, channels);\n\t\tpayload.put(SAMPLERATE, samplerate);\n\t\tpayload.put(VIDEO_HEIGHT, vh);\n\t\tpayload.put(VIDEO_WIDTH, vw);\n\t\tpayload.put(FRAMES_PER_SECOND, fps);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RECORDING_STARTED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public static DeskShareRecordingStartedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RECORDING_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(FILENAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString filename = payload.get(FILENAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\n\t\t\t\t\t\treturn new DeskShareRecordingStartedEventMessage(conferenceName, filename, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","id":45357,"modified_method":"public static DeskShareRecordingStartedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RECORDING_STARTED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(CHANNELS)\n\t\t\t\t\t\t\t&& payload.has(SAMPLERATE)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_HEIGHT)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_WIDTH)\n\t\t\t\t\t\t\t&& payload.has(FRAMES_PER_SECOND)\n\t\t\t\t\t\t\t&& payload.has(FILENAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString filename = payload.get(FILENAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\t\t\t\t\t\tint channels = payload.get(CHANNELS).getAsInt();\n\t\t\t\t\t\tint samplerate = payload.get(SAMPLERATE).getAsInt();\n\t\t\t\t\t\tint vh = payload.get(VIDEO_HEIGHT).getAsInt();\n\t\t\t\t\t\tint vw = payload.get(VIDEO_WIDTH).getAsInt();\n\t\t\t\t\t\tdouble fps = payload.get(FRAMES_PER_SECOND).getAsDouble();\n\n\t\t\t\t\t\treturn new DeskShareRecordingStartedEventMessage(conferenceName, filename, channels,\n\t\t\t\t\t\t\t\tsamplerate, vw, vh, fps, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public DeskShareRecordingStartedEventMessage(String conferenceName, String filename, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.filename = filename;\n\t\tthis.timestamp = timestamp;\n\t}","id":45358,"modified_method":"public DeskShareRecordingStartedEventMessage(String conferenceName, String filename, int channels,\n\t\t\tint samplerate, int vw, int vh, double fps, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.filename = filename;\n\t\tthis.timestamp = timestamp;\n\t\tthis.channels = channels;\n\t\tthis.samplerate = samplerate;\n\t\tthis.vw = vw;\n\t\tthis.vh = vh;\n\t\tthis.fps = fps;\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public DeskShareRecordingStoppedEventMessage(String conferenceName, String filename, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.filename = filename;\n\t\tthis.timestamp = timestamp;\n\t}","id":45359,"modified_method":"public DeskShareRecordingStoppedEventMessage(String conferenceName, String filename, int channels,\n\t\t\tint samplerate, int vw, int vh, double fps, String timestamp) {\n\t\tthis.conferenceName = conferenceName;\n\t\tthis.filename = filename;\n\t\tthis.timestamp = timestamp;\n\t\tthis.channels = channels;\n\t\tthis.samplerate = samplerate;\n\t\tthis.vw = vw;\n\t\tthis.vh = vh;\n\t\tthis.fps = fps;\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public static DeskShareRecordingStoppedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RECORDING_STOPPED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(FILENAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString filename = payload.get(FILENAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\n\t\t\t\t\t\treturn new DeskShareRecordingStoppedEventMessage(conferenceName, filename, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","id":45360,"modified_method":"public static DeskShareRecordingStoppedEventMessage fromJson(String message) {\n\t\tJsonParser parser = new JsonParser();\n\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\n\t\tif (obj.has(\"header\") && obj.has(\"payload\")) {\n\t\t\tJsonObject header = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payload = (JsonObject) obj.get(\"payload\");\n\n\t\t\tif (header.has(\"name\")) {\n\t\t\t\tString messageName = header.get(\"name\").getAsString();\n\t\t\t\tif (DESKSHARE_RECORDING_STOPPED_MESSAGE.equals(messageName)) {\n\t\t\t\t\tif (payload.has(CONFERENCE_NAME)\n\t\t\t\t\t\t\t&& payload.has(TIMESTAMP)\n\t\t\t\t\t\t\t&& payload.has(CHANNELS)\n\t\t\t\t\t\t\t&& payload.has(SAMPLERATE)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_HEIGHT)\n\t\t\t\t\t\t\t&& payload.has(VIDEO_WIDTH)\n\t\t\t\t\t\t\t&& payload.has(FRAMES_PER_SECOND)\n\t\t\t\t\t\t\t&& payload.has(FILENAME)) {\n\t\t\t\t\t\tString conferenceName = payload.get(CONFERENCE_NAME).getAsString();\n\t\t\t\t\t\tString filename = payload.get(FILENAME).getAsString();\n\t\t\t\t\t\tString timestamp = payload.get(TIMESTAMP).getAsString();\n\t\t\t\t\t\tint channels = payload.get(CHANNELS).getAsInt();\n\t\t\t\t\t\tint samplerate = payload.get(SAMPLERATE).getAsInt();\n\t\t\t\t\t\tint vh = payload.get(VIDEO_HEIGHT).getAsInt();\n\t\t\t\t\t\tint vw = payload.get(VIDEO_WIDTH).getAsInt();\n\t\t\t\t\t\tdouble fps = payload.get(FRAMES_PER_SECOND).getAsDouble();\n\n\t\t\t\t\t\treturn new DeskShareRecordingStoppedEventMessage(conferenceName, filename, channels,\n\t\t\t\t\t\t\t\tsamplerate, vw, vh, fps, timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(FILENAME, filename);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RECORDING_STOPPED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","id":45361,"modified_method":"public String toJson() {\n\t\tHashMap<String, Object> payload = new HashMap<String, Object>();\n\t\tpayload.put(CONFERENCE_NAME, conferenceName);\n\t\tpayload.put(FILENAME, filename);\n\t\tpayload.put(TIMESTAMP, timestamp);\n\t\tpayload.put(CHANNELS, channels);\n\t\tpayload.put(SAMPLERATE, samplerate);\n\t\tpayload.put(VIDEO_HEIGHT, vh);\n\t\tpayload.put(VIDEO_WIDTH, vw);\n\t\tpayload.put(FRAMES_PER_SECOND, fps);\n\n\t\tjava.util.HashMap<String, Object> header = MessageBuilder.buildHeader(DESKSHARE_RECORDING_STOPPED_MESSAGE, VERSION, null);\n\n\t\treturn MessageBuilder.buildJson(header, payload);\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private String getStreamUrl(EslEvent e) {\r\n        String path = e.getEventHeaders().get(\"Path\");\r\n        if (isRTMPStream(e)){\r\n        \treturn path.substring(path.indexOf(\"}\"));\r\n        } else {\r\n        \treturn \"\";\r\n        }\r\n\t}","id":45362,"modified_method":"private String getStreamUrl(EslEvent e) {\r\n        String path = e.getEventHeaders().get(\"Path\");\r\n        if (isRTMPStream(e)){\r\n            return path.substring(path.indexOf(\"}\") + 1);\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event) {\r\n        String action = event.getEventHeaders().get(\"Action\");\r\n\r\n        if(action == null) {\r\n            return;\r\n        }\r\n\r\n        System.out.println(\"Handling conferenceEventRecord \" + action);\r\n        System.out.println(\"\\n\\n\\nAAAAAAAAAAAAAAAAAAA \" + isRTMPStream(event) + \"\\n\\n\\n\");\r\n\r\n        if (action.equals(START_RECORDING_EVENT)) {\r\n            if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)){\r\n            \tif (isRTMPStream(event)) {\r\n            \t\tDeskShareRTMPBroadcastEvent rtmp = new DeskShareRTMPBroadcastEvent(confName, true);\r\n            \t\trtmp.setChannels(Integer.parseInt(getBroadcastParameter(event, \"channels\")));\r\n            \t\trtmp.setFramesPerSecond(Double.parseDouble(getBroadcastParameter(event, \"fps\")));\r\n            \t\trtmp.setVideoHeight(Integer.parseInt(getBroadcastParameter(event, \"vh\")));\r\n            \t\trtmp.setVideoWidth(Integer.parseInt(getBroadcastParameter(event, \"vw\")));\r\n            \t\trtmp.setSampleRate(Integer.parseInt(getBroadcastParameter(event, \"samplerate\")));\r\n            \t\trtmp.setRecordingStreamUrl(getStreamUrl(event));\r\n            \t\trtmp.setTimestamp(genTimestamp().toString());\r\n            \t\tSystem.out.println(\"DeskShare conference broadcast started. url=[\"\r\n            \t\t\t\t+ getStreamUrl(event) + \"], conf=[\" + confName + \"]\");\r\n            \t\tconferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)rtmp);\r\n            \t} else {\r\n            \t\tDeskShareRecordingEvent dssre = new DeskShareRecordingEvent(confName, true);\r\n            \t\tdssre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n            \t\tdssre.setTimestamp(genTimestamp().toString());\r\n            \t\tSystem.out.println(\"DeskShare conference recording started. file=[\"\r\n            \t\t\t\t+ getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n            \t\tconferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)dssre);\r\n            \t}\r\n            } else {\r\n                VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, true);\r\n                sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                sre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"Voice conference recording started. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent(sre);\r\n            }\r\n        } else if (action.equals(STOP_RECORDING_EVENT)) {\r\n            if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)){\r\n            \tif (isRTMPStream(event)) {\r\n            \t\tDeskShareRTMPBroadcastEvent rtmp = new DeskShareRTMPBroadcastEvent(confName, false);\r\n            \t\trtmp.setChannels(Integer.parseInt(getBroadcastParameter(event, \"channels\")));\r\n            \t\trtmp.setFramesPerSecond(Double.parseDouble(getBroadcastParameter(event, \"fps\")));\r\n            \t\trtmp.setVideoHeight(Integer.parseInt(getBroadcastParameter(event, \"vh\")));\r\n            \t\trtmp.setVideoWidth(Integer.parseInt(getBroadcastParameter(event, \"vw\")));\r\n            \t\trtmp.setSampleRate(Integer.parseInt(getBroadcastParameter(event, \"samplerate\")));\r\n            \t\trtmp.setRecordingStreamUrl(getStreamUrl(event));\r\n            \t\trtmp.setTimestamp(genTimestamp().toString());\r\n            \t\tSystem.out.println(\"DeskShare conference broadcast stopped. url=[\"\r\n            \t\t\t\t+ getStreamUrl(event) + \"], conf=[\" + confName + \"]\");\r\n            \t\tconferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)rtmp);\r\n            \t} else {\r\n\t            \tDeskShareRecordingEvent dssre = new DeskShareRecordingEvent(confName, false);\r\n\t                dssre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n\t                dssre.setTimestamp(genTimestamp().toString());\r\n\t                System.out.println(\"DeskShare conference recording stopped. file=[\"\r\n\t                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n\t                conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)dssre);\r\n            \t}\r\n            } else {\r\n                VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, false);\r\n                sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                sre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"Voice conference recording stopped. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent(sre);\r\n            }\r\n        } \r\n        \r\n        // TODO check if it's a rtmp broadcast event?\r\n        \r\n        else {\r\n            System.out.println(\"Processing UNKNOWN conference Action \" + action + \"]\");\r\n        }\r\n    }","id":45363,"modified_method":"public void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event) {\r\n        String action = event.getEventHeaders().get(\"Action\");\r\n\r\n        if(action == null) {\r\n            return;\r\n        }\r\n\r\n        if (action.equals(START_RECORDING_EVENT)) {\r\n            if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)){\r\n                if (isRTMPStream(event)) {\r\n                    DeskShareRTMPBroadcastEvent rtmp = new DeskShareRTMPBroadcastEvent(confName, true);\r\n                    rtmp.setChannels(Integer.parseInt(getBroadcastParameter(event, \"channels\")));\r\n                    rtmp.setFramesPerSecond(Double.parseDouble(getBroadcastParameter(event, \"fps\")));\r\n                    rtmp.setVideoHeight(Integer.parseInt(getBroadcastParameter(event, \"vh\")));\r\n                    rtmp.setVideoWidth(Integer.parseInt(getBroadcastParameter(event, \"vw\")));\r\n                    rtmp.setSampleRate(Integer.parseInt(getBroadcastParameter(event, \"samplerate\")));\r\n                    rtmp.setRecordingStreamUrl(getStreamUrl(event));\r\n                    rtmp.setTimestamp(genTimestamp().toString());\r\n\r\n                    System.out.println(\"DeskShare conference broadcast started. url=[\"\r\n                            + getStreamUrl(event) + \"], conf=[\" + confName + \"]\");\r\n                    conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)rtmp);\r\n                } else {\r\n                    DeskShareRecordingEvent dssre = new DeskShareRecordingEvent(confName, true);\r\n                    dssre.setRecordingFilename(getDeskShareRecordFilenameFromEvent(event));\r\n                    dssre.setTimestamp(genTimestamp().toString());\r\n                    dssre.setChannels(Integer.parseInt(getBroadcastParameter(event, \"channels\")));\r\n                    dssre.setFramesPerSecond(Double.parseDouble(getBroadcastParameter(event, \"fps\")));\r\n                    dssre.setVideoHeight(Integer.parseInt(getBroadcastParameter(event, \"vh\")));\r\n                    dssre.setVideoWidth(Integer.parseInt(getBroadcastParameter(event, \"vw\")));\r\n                    dssre.setSampleRate(Integer.parseInt(getBroadcastParameter(event, \"samplerate\")));\r\n\r\n                    System.out.println(\"DeskShare conference recording started. file=[\"\r\n                            + dssre.getRecordingFilename() + \"], conf=[\" + confName + \"]\");\r\n                    conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)dssre);\r\n                }\r\n            } else {\r\n                VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, true);\r\n                sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                sre.setTimestamp(genTimestamp().toString());\r\n\r\n                System.out.println(\"Voice conference recording started. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent(sre);\r\n            }\r\n        } else if (action.equals(STOP_RECORDING_EVENT)) {\r\n            if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)){\r\n                if (isRTMPStream(event)) {\r\n                    DeskShareRTMPBroadcastEvent rtmp = new DeskShareRTMPBroadcastEvent(confName, false);\r\n                    rtmp.setChannels(Integer.parseInt(getBroadcastParameter(event, \"channels\")));\r\n                    rtmp.setFramesPerSecond(Double.parseDouble(getBroadcastParameter(event, \"fps\")));\r\n                    rtmp.setVideoHeight(Integer.parseInt(getBroadcastParameter(event, \"vh\")));\r\n                    rtmp.setVideoWidth(Integer.parseInt(getBroadcastParameter(event, \"vw\")));\r\n                    rtmp.setSampleRate(Integer.parseInt(getBroadcastParameter(event, \"samplerate\")));\r\n                    rtmp.setRecordingStreamUrl(getStreamUrl(event));\r\n                    rtmp.setTimestamp(genTimestamp().toString());\r\n\r\n                    System.out.println(\"DeskShare conference broadcast stopped. url=[\"\r\n                            + getStreamUrl(event) + \"], conf=[\" + confName + \"]\");\r\n                    conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)rtmp);\r\n                } else {\r\n                    DeskShareRecordingEvent dssre = new DeskShareRecordingEvent(confName, false);\r\n                    dssre.setRecordingFilename(getDeskShareRecordFilenameFromEvent(event));\r\n                    dssre.setTimestamp(genTimestamp().toString());\r\n                    dssre.setChannels(Integer.parseInt(getBroadcastParameter(event, \"channels\")));\r\n                    dssre.setFramesPerSecond(Double.parseDouble(getBroadcastParameter(event, \"fps\")));\r\n                    dssre.setVideoHeight(Integer.parseInt(getBroadcastParameter(event, \"vh\")));\r\n                    dssre.setVideoWidth(Integer.parseInt(getBroadcastParameter(event, \"vw\")));\r\n                    dssre.setSampleRate(Integer.parseInt(getBroadcastParameter(event, \"samplerate\")));\r\n\r\n                    System.out.println(\"DeskShare conference recording stopped. file=[\"\r\n                     + dssre.getRecordingFilename() + \"], conf=[\" + confName + \"]\");\r\n                    conferenceEventListener.handleConferenceEvent( (VoiceConferenceEvent)dssre);\r\n                }\r\n            } else {\r\n                VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, false);\r\n                sre.setRecordingFilename(getRecordFilenameFromEvent(event));\r\n                sre.setTimestamp(genTimestamp().toString());\r\n                System.out.println(\"Voice conference recording stopped. file=[\"\r\n                 + getRecordFilenameFromEvent(event) + \"], conf=[\" + confName + \"]\");\r\n                conferenceEventListener.handleConferenceEvent(sre);\r\n            }\r\n        } \r\n\r\n        else {\r\n            System.out.println(\"Processing UNKNOWN conference Action \" + action + \"]\");\r\n        }\r\n    }","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n    public void conferenceEventLeave(String uniqueId, String confName, int confSize, EslEvent event) {   \t\r\n        Integer memberId = this.getMemberIdFromEvent(event);\r\n        System.out.println(\"User left voice conference, user=[\" + memberId.toString() + \"], conf=[\" + confName + \"]\");\r\n\r\n        // Deskstop sharing conferences have their name in the form 7dddd-DESKSHARE\r\n        if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)) {\r\n            String callerId = this.getCallerIdFromEvent(event);\r\n            String callerIdName = this.getCallerIdNameFromEvent(event);\r\n            // Deskstop sharing conferences have the user with the desktop video displayed in this way:\r\n            // username (Screen) and usernum (screen)\r\n            if (callerId.endsWith(DESKSHARE_CALLER_ID_SUFFIX) && callerIdName.endsWith(DESKSHARE_CALLER_NAME_SUFFIX)) {\r\n                DeskShareEndedEvent dsEnd = new DeskShareEndedEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsEnd);\r\n                return;//TODO do we need it?\r\n            } else {\r\n                DeskShareViewerLeftEvent dsLeft = new DeskShareViewerLeftEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsLeft);\r\n            }\r\n        }\r\n\r\n        VoiceUserLeftEvent pl = new VoiceUserLeftEvent(memberId.toString(), confName);\r\n        conferenceEventListener.handleConferenceEvent(pl);\r\n    }","id":45364,"modified_method":"@Override\r\n    public void conferenceEventLeave(String uniqueId, String confName, int confSize, EslEvent event) {      \r\n        Integer memberId = this.getMemberIdFromEvent(event);\r\n        System.out.println(\"User left voice conference, user=[\" + memberId.toString() + \"], conf=[\" + confName + \"]\");\r\n\r\n        // Deskstop sharing conferences have their name in the form 7dddd-DESKSHARE\r\n        if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)) {\r\n            String callerId = this.getCallerIdFromEvent(event);\r\n            String callerIdName = this.getCallerIdNameFromEvent(event);\r\n            // Deskstop sharing conferences have the user with the desktop video displayed in this way:\r\n            // username (Screen) and usernum (screen)\r\n            if (callerId.endsWith(DESKSHARE_CALLER_ID_SUFFIX) && callerIdName.endsWith(DESKSHARE_CALLER_NAME_SUFFIX)) {\r\n                DeskShareEndedEvent dsEnd = new DeskShareEndedEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsEnd);\r\n//                return;//TODO do we need it?\r\n            } else {\r\n                DeskShareViewerLeftEvent dsLeft = new DeskShareViewerLeftEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsLeft);\r\n            }\r\n        }\r\n\r\n        VoiceUserLeftEvent pl = new VoiceUserLeftEvent(memberId.toString(), confName);\r\n        conferenceEventListener.handleConferenceEvent(pl);\r\n    }","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n    public void conferenceEventJoin(String uniqueId, String confName, int confSize, EslEvent event) {\r\n\r\n        Integer memberId = this.getMemberIdFromEvent(event);\r\n        Map<String, String> headers = event.getEventHeaders();\r\n        String callerId = this.getCallerIdFromEvent(event);\r\n        String callerIdName = this.getCallerIdNameFromEvent(event);\r\n        boolean muted = headers.get(\"Speak\").equals(\"true\") ? false : true; //Was inverted which was causing a State issue\r\n        boolean speaking = headers.get(\"Talking\").equals(\"true\") ? true : false;\r\n\r\n        String voiceUserId = callerIdName;\r\n\r\n        System.out.println(\"User joined voice conference, user=[\" + callerIdName + \"], conf=[\" + confName + \"]\");\r\n\r\n        Matcher gapMatcher = GLOBAL_AUDION_PATTERN.matcher(callerIdName);\r\n        if (gapMatcher.matches()) {\r\n        \tSystem.out.println(\"Ignoring GLOBAL AUDIO USER [\" + callerIdName + \"]\");\r\n        \treturn;\r\n        }\r\n\r\n        // Deskstop sharing conferences have their name in the form 7dddd-DESKSHARE\r\n        if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)) {\r\n            // Deskstop sharing conferences have the user with the desktop video displayed in this way:\r\n            // username (Screen) and usernum (screen)\r\n            if (callerId.endsWith(DESKSHARE_CALLER_ID_SUFFIX) && callerIdName.endsWith(DESKSHARE_CALLER_NAME_SUFFIX)) {\r\n                DeskShareStartedEvent dsStart = new DeskShareStartedEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsStart);\r\n                return; //TODO do we need it?\r\n            } else {\r\n                DeskShareViewerJoinedEvent dsJoined = new DeskShareViewerJoinedEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsJoined);\r\n        \t}\r\n        }\r\n\r\n        Matcher matcher = CALLERNAME_PATTERN.matcher(callerIdName);\r\n        if (matcher.matches()) {\r\n            voiceUserId = matcher.group(1).trim();\r\n            callerIdName = matcher.group(2).trim();\r\n        }\r\n\r\n        VoiceUserJoinedEvent pj = new VoiceUserJoinedEvent(voiceUserId, memberId.toString(), confName, callerId, callerIdName, muted, speaking);\r\n        conferenceEventListener.handleConferenceEvent(pj);\r\n    }","id":45365,"modified_method":"@Override\r\n    public void conferenceEventJoin(String uniqueId, String confName, int confSize, EslEvent event) {\r\n\r\n        Integer memberId = this.getMemberIdFromEvent(event);\r\n        Map<String, String> headers = event.getEventHeaders();\r\n        String callerId = this.getCallerIdFromEvent(event);\r\n        String callerIdName = this.getCallerIdNameFromEvent(event);\r\n        boolean muted = headers.get(\"Speak\").equals(\"true\") ? false : true; //Was inverted which was causing a State issue\r\n        boolean speaking = headers.get(\"Talking\").equals(\"true\") ? true : false;\r\n\r\n        String voiceUserId = callerIdName;\r\n\r\n        System.out.println(\"User joined voice conference, user=[\" + callerIdName + \"], conf=[\" + confName + \"]\");\r\n\r\n        Matcher gapMatcher = GLOBAL_AUDION_PATTERN.matcher(callerIdName);\r\n        if (gapMatcher.matches()) {\r\n            System.out.println(\"Ignoring GLOBAL AUDIO USER [\" + callerIdName + \"]\");\r\n            return;\r\n        }\r\n\r\n        // Deskstop sharing conferences have their name in the form 7dddd-DESKSHARE\r\n        if (confName.endsWith(DESKSHARE_CONFERENCE_NAME_SUFFIX)) {\r\n            // Deskstop sharing conferences have the user with the desktop video displayed in this way:\r\n            // username (Screen) and usernum (screen)\r\n            if (callerId.endsWith(DESKSHARE_CALLER_ID_SUFFIX) && callerIdName.endsWith(DESKSHARE_CALLER_NAME_SUFFIX)) {\r\n                DeskShareStartedEvent dsStart = new DeskShareStartedEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsStart);\r\n//                return; //TODO do we need it?\r\n            } else {\r\n                DeskShareViewerJoinedEvent dsJoined = new DeskShareViewerJoinedEvent(confName, callerId, callerIdName);\r\n                conferenceEventListener.handleConferenceEvent(dsJoined);\r\n            }\r\n        }\r\n\r\n        Matcher matcher = CALLERNAME_PATTERN.matcher(callerIdName);\r\n        if (matcher.matches()) {\r\n            voiceUserId = matcher.group(1).trim();\r\n            callerIdName = matcher.group(2).trim();\r\n        }\r\n\r\n        VoiceUserJoinedEvent pj = new VoiceUserJoinedEvent(voiceUserId, memberId.toString(), confName, callerId, callerIdName, muted, speaking);\r\n        conferenceEventListener.handleConferenceEvent(pj);\r\n    }","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendMessageToBigBlueButton(final VoiceConferenceEvent event) {\r\n\t\tRunnable task = new Runnable() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\tif (event instanceof VoiceUserJoinedEvent) {\r\n\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received voiceUserJoined \");\r\n\t\t\t\tVoiceUserJoinedEvent evt = (VoiceUserJoinedEvent) event;\r\n\t\t\t\tvcs.userJoinedVoiceConf(evt.getRoom(), evt.getVoiceUserId(), evt.getUserId(), evt.getCallerIdName(), \r\n\t\t\t\t\t\tevt.getCallerIdNum(), evt.getMuted(), evt.getSpeaking());\r\n\t\t\t\t} else if (event instanceof VoiceUserLeftEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received VoiceUserLeftEvent \");\r\n\t\t\t\t\tVoiceUserLeftEvent evt = (VoiceUserLeftEvent) event;\r\n\t\t\t\t\tvcs.userLeftVoiceConf(evt.getRoom(), evt.getUserId());\r\n\t\t\t\t} else if (event instanceof VoiceUserMutedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserMutedEvent \");\r\n\t\t\t\t\tVoiceUserMutedEvent evt = (VoiceUserMutedEvent) event;\r\n\t\t\t\t\tvcs.userMutedInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isMuted());\r\n\t\t\t\t} else if (event instanceof VoiceUserTalkingEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserTalkingEvent \");\r\n\t\t\t\t\tVoiceUserTalkingEvent evt = (VoiceUserTalkingEvent) event;\r\n\t\t\t\t\tvcs.userTalkingInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isTalking());\r\n\t\t\t\t} else if (event instanceof VoiceStartRecordingEvent) {\r\n\t\t\t\t\tVoiceStartRecordingEvent evt = (VoiceStartRecordingEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceStartRecordingEvent recording=[\" + evt.startRecord() + \"]\");\r\n\t\t\t\t\tvcs.voiceConfRecordingStarted(evt.getRoom(), evt.getRecordingFilename(), evt.startRecord(), evt.getTimestamp());\r\n\t\t\t\t} else if (event instanceof DeskShareStartedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"********START******\\n\\n\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareStartedEvent evt = (DeskShareStartedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareStartedEvent\");\r\n\t\t\t\t\tvcs.deskShareStarted(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareEndedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"********END******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareEndedEvent evt = (DeskShareEndedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareEndedEvent\");\r\n\t\t\t\t\tvcs.deskShareEnded(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n//\t\t\t\t} else if (event instanceof DeskShareViewerJoinedEvent) {\r\n////\t\t\t\t\tSystem.out.println(\"********VIEWER JOINED******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n//\t\t\t\t\tDeskShareViewerJoinedEvent evt = (DeskShareViewerJoinedEvent) event;\r\n//\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerJoinedEvent\");\r\n//\t\t\t\t\tvcs.deskShareViewerJoined(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n//\t\t\t\t} else if (event instanceof DeskShareViewerLeftEvent) {\r\n////\t\t\t\t\tSystem.out.println(\"********VIEWER LEFT******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n//\t\t\t\t\tDeskShareViewerLeftEvent evt = (DeskShareViewerLeftEvent) event;\r\n//\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerLeftEvent\");\r\n//\t\t\t\t\tvcs.deskShareViewerLeft(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareRecordingEvent) {\r\n\t\t\t\t\tif (((DeskShareRecordingEvent) event).getRecord()) {\r\n\t\t\t\t\t\tSystem.out.println(\"******** Start RECORDING******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\t\tDeskShareRecordingEvent evt = (DeskShareRecordingEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRecordingEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRecordingStarted(evt.getRoom(), evt.getRecordingFilename(), evt.getTimestamp());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSystem.out.println(\"******** Stop RECORDING******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\t\tDeskShareRecordingEvent evt = (DeskShareRecordingEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRecordingEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRecordingStopped(evt.getRoom(), evt.getRecordingFilename(), evt.getTimestamp());\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event instanceof DeskShareRTMPBroadcastEvent) {\r\n\t\t\t\t\tif (((DeskShareRTMPBroadcastEvent) event).getRecord()) {\r\n\t\t\t\t\t\tSystem.out.println(\"******** Start RTMP Broadcast******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\t\tDeskShareRTMPBroadcastEvent evt = (DeskShareRTMPBroadcastEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRTMPBroadcastStartedEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRTMPBroadcastStarted(evt.getRoom(), evt.getRecordingStreamUrl(), evt.getTimestamp());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSystem.out.println(\"******** Stop RTMP Broadcast******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\t\tDeskShareRTMPBroadcastEvent evt = (DeskShareRTMPBroadcastEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRTMPBroadcastStoppedEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRTMPBroadcastStopped(evt.getRoom(), evt.getRecordingStreamUrl(), evt.getTimestamp());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\trunExec.execute(task);\r\n\t}","id":45366,"modified_method":"private void sendMessageToBigBlueButton(final VoiceConferenceEvent event) {\r\n\t\tRunnable task = new Runnable() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\tif (event instanceof VoiceUserJoinedEvent) {\r\n\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received voiceUserJoined \");\r\n\t\t\t\tVoiceUserJoinedEvent evt = (VoiceUserJoinedEvent) event;\r\n\t\t\t\tvcs.userJoinedVoiceConf(evt.getRoom(), evt.getVoiceUserId(), evt.getUserId(), evt.getCallerIdName(), \r\n\t\t\t\t\t\tevt.getCallerIdNum(), evt.getMuted(), evt.getSpeaking());\r\n\t\t\t\t} else if (event instanceof VoiceUserLeftEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener received VoiceUserLeftEvent \");\r\n\t\t\t\t\tVoiceUserLeftEvent evt = (VoiceUserLeftEvent) event;\r\n\t\t\t\t\tvcs.userLeftVoiceConf(evt.getRoom(), evt.getUserId());\r\n\t\t\t\t} else if (event instanceof VoiceUserMutedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserMutedEvent \");\r\n\t\t\t\t\tVoiceUserMutedEvent evt = (VoiceUserMutedEvent) event;\r\n\t\t\t\t\tvcs.userMutedInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isMuted());\r\n\t\t\t\t} else if (event instanceof VoiceUserTalkingEvent) {\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceUserTalkingEvent \");\r\n\t\t\t\t\tVoiceUserTalkingEvent evt = (VoiceUserTalkingEvent) event;\r\n\t\t\t\t\tvcs.userTalkingInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isTalking());\r\n\t\t\t\t} else if (event instanceof VoiceStartRecordingEvent) {\r\n\t\t\t\t\tVoiceStartRecordingEvent evt = (VoiceStartRecordingEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener VoiceStartRecordingEvent recording=[\" + evt.startRecord() + \"]\");\r\n\t\t\t\t\tvcs.voiceConfRecordingStarted(evt.getRoom(), evt.getRecordingFilename(), evt.startRecord(), evt.getTimestamp());\r\n\t\t\t\t} else if (event instanceof DeskShareStartedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"********START******\\n\\n\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareStartedEvent evt = (DeskShareStartedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareStartedEvent\");\r\n\t\t\t\t\tvcs.deskShareStarted(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareEndedEvent) {\r\n\t\t\t\t\tSystem.out.println(\"********END******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n\t\t\t\t\tDeskShareEndedEvent evt = (DeskShareEndedEvent) event;\r\n\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareEndedEvent\");\r\n\t\t\t\t\tvcs.deskShareEnded(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n//\t\t\t\t} else if (event instanceof DeskShareViewerJoinedEvent) {\r\n////\t\t\t\t\tSystem.out.println(\"********VIEWER JOINED******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n//\t\t\t\t\tDeskShareViewerJoinedEvent evt = (DeskShareViewerJoinedEvent) event;\r\n//\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerJoinedEvent\");\r\n//\t\t\t\t\tvcs.deskShareViewerJoined(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n//\t\t\t\t} else if (event instanceof DeskShareViewerLeftEvent) {\r\n////\t\t\t\t\tSystem.out.println(\"********VIEWER LEFT******\\n\\n\\n\\n\\n FreeswitchConferenceEventListener \");\r\n//\t\t\t\t\tDeskShareViewerLeftEvent evt = (DeskShareViewerLeftEvent) event;\r\n//\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareViewerLeftEvent\");\r\n//\t\t\t\t\tvcs.deskShareViewerLeft(evt.getRoom(), evt.getCallerIdNum(), evt.getCallerIdName());\r\n\t\t\t\t} else if (event instanceof DeskShareRecordingEvent) {\r\n\t\t\t\t\tif (((DeskShareRecordingEvent) event).getRecord()) {\r\n\t\t\t\t\t\tDeskShareRecordingEvent evt = (DeskShareRecordingEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShare(Start)RecordingEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRecordingStarted(evt.getRoom(), evt.getRecordingFilename(),\r\n\t\t\t\t\t\t\t\tevt.getChannels(), evt.getSampleRate(), evt.getVideoWidth(),\r\n\t\t\t\t\t\t\t\tevt.getVideoHeight(), evt.getFramesPerSecond(), evt.getTimestamp());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tDeskShareRecordingEvent evt = (DeskShareRecordingEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShare(Stop)RecordingEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRecordingStopped(evt.getRoom(), evt.getRecordingFilename(),\r\n\t\t\t\t\t\t\t\tevt.getChannels(), evt.getSampleRate(), evt.getVideoWidth(),\r\n\t\t\t\t\t\t\t\tevt.getVideoHeight(), evt.getFramesPerSecond(), evt.getTimestamp());\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event instanceof DeskShareRTMPBroadcastEvent) {\r\n\t\t\t\t\tif (((DeskShareRTMPBroadcastEvent) event).getRecord()) {\r\n\t\t\t\t\t\tDeskShareRTMPBroadcastEvent evt = (DeskShareRTMPBroadcastEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRTMPBroadcastStartedEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRTMPBroadcastStarted(evt.getRoom(), evt.getRecordingStreamUrl(),\r\n\t\t\t\t\t\t\t\tevt.getChannels(), evt.getSampleRate(), evt.getVideoWidth(),\r\n\t\t\t\t\t\t\t\tevt.getVideoHeight(), evt.getFramesPerSecond(), evt.getTimestamp());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tDeskShareRTMPBroadcastEvent evt = (DeskShareRTMPBroadcastEvent) event;\r\n\t\t\t\t\t\tSystem.out.println(\"************** FreeswitchConferenceEventListener DeskShareRTMPBroadcastStoppedEvent\");\r\n\t\t\t\t\t\tvcs.deskShareRTMPBroadcastStopped(evt.getRoom(), evt.getRecordingStreamUrl(),\r\n\t\t\t\t\t\t\t\tevt.getChannels(), evt.getSampleRate(), evt.getVideoWidth(),\r\n\t\t\t\t\t\t\t\tevt.getVideoHeight(), evt.getFramesPerSecond(), evt.getTimestamp());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\trunExec.execute(task);\r\n\t}","commit_id":"71920799776eee78b825e86cccde1a444dc473b4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Override\n    public int complete(String buffer, int cursor, List candidates) {\n\n        if(buffer.length() < 2)\n            return -1;\n        if(buffer.charAt(0) != '/')\n            return -1;\n\n        String start = buffer.substring(1);\n        for(String command : commands) {\n            if(command.startsWith(start))\n                candidates.add(command);\n        }\n        Collections.sort(candidates);\n        return 1;\n    }","id":45367,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Override\n    public int complete(String buffer, int cursor, List candidates) {\n\n        if(buffer.length() < 1)\n            return -1;\n        if(buffer.charAt(0) != '/')\n            return -1;\n\n        if(buffer.length() == 1) {\n            candidates.addAll(commands);\n        } else {\n            String start = buffer.substring(1);\n            for (String command : commands) {\n                if (command.startsWith(start))\n                    candidates.add(command);\n            }\n        }\n        Collections.sort(candidates);\n        return 1;\n    }","commit_id":"4751cd65f773e4dea1c91ab22eb07d9074731700","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public Prefix getPrefix() {\n            return prefix;\n        }","id":45368,"modified_method":"@Override\n        public OperationRequestAddress getPrefix() {\n            return prefix;\n        }","commit_id":"4751cd65f773e4dea1c91ab22eb07d9074731700","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void main(String[] args) throws Exception {\n\n        final jline.ConsoleReader console = new jline.ConsoleReader();\n        console.setUseHistory(true);\n        console.addCompletor(new CommandCompleter(handlers.keySet()));\n\n        final CommandContextImpl cmdCtx = new CommandContextImpl(console);\n        SecurityActions.addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                StreamUtils.safeClose(cmdCtx.client);\n                cmdCtx.log(\"closed\");\n            }\n        }));\n\n        cmdCtx.log(\"You are disconnected at the moment.\" +\n                \" Type /connect to connect to the server or\" +\n                \" /help for the list of supported commands.\");\n\n        while (!cmdCtx.terminate) {\n            String line = console.readLine(\"[\" + cmdCtx.getPrefixFormatter().format(cmdCtx.getPrefix()) + \"] \");\n\n            if (line.isEmpty()) {\n                // cmdCtx.log(\"Type /help for the list of supported commands.\");\n                continue;\n            }\n\n            if (line.charAt(0) == '/') {\n                String cmd = line.substring(1).toLowerCase();\n                cmdCtx.cmdArgs = null;\n                for (int i = 0; i < cmd.length(); ++i) {\n                    if (Character.isWhitespace(cmd.charAt(i))) {\n                        cmdCtx.cmdArgs = cmd.substring(i + 1).trim();\n                        cmd = cmd.substring(0, i);\n                    }\n                }\n\n                CommandHandler handler = handlers.get(cmd);\n                if (handler != null) {\n                    handler.handle(cmdCtx);\n                } else {\n                    cmdCtx.log(\"Unexpected command '\"\n                            + line\n                            + \"'. Type /help for the list of supported commands.\");\n                }\n            } else {\n                cmdCtx.cmdArgs = line;\n                operationHandler.handle(cmdCtx);\n            }\n        }\n    }","id":45369,"modified_method":"public static void main(String[] args) throws Exception {\n\n        final jline.ConsoleReader console = new jline.ConsoleReader();\n        console.setUseHistory(true);\n        console.addCompletor(new CommandCompleter(handlers.keySet()));\n\n        final CommandContextImpl cmdCtx = new CommandContextImpl(console);\n        SecurityActions.addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                StreamUtils.safeClose(cmdCtx.client);\n                cmdCtx.log(\"closed\");\n            }\n        }));\n        console.addCompletor(new OperationRequestCompleter(cmdCtx));\n\n        cmdCtx.log(\"You are disconnected at the moment.\" +\n                \" Type /connect to connect to the server or\" +\n                \" /help for the list of supported commands.\");\n\n        while (!cmdCtx.terminate) {\n            String line = console.readLine(\"[\" + cmdCtx.getPrefixFormatter().format(cmdCtx.getPrefix()) + \"] \");\n\n            if (line.isEmpty()) {\n                // cmdCtx.log(\"Type /help for the list of supported commands.\");\n                continue;\n            }\n\n            if (line.charAt(0) == '/') {\n                String cmd = line.substring(1).toLowerCase();\n                cmdCtx.cmdArgs = null;\n                for (int i = 0; i < cmd.length(); ++i) {\n                    if (Character.isWhitespace(cmd.charAt(i))) {\n                        cmdCtx.cmdArgs = cmd.substring(i + 1).trim();\n                        cmd = cmd.substring(0, i);\n                    }\n                }\n\n                CommandHandler handler = handlers.get(cmd);\n                if (handler != null) {\n                    handler.handle(cmdCtx);\n                } else {\n                    cmdCtx.log(\"Unexpected command '\"\n                            + line\n                            + \"'. Type /help for the list of supported commands.\");\n                }\n            } else {\n                cmdCtx.cmdArgs = line;\n                operationHandler.handle(cmdCtx);\n            }\n        }\n    }","commit_id":"4751cd65f773e4dea1c91ab22eb07d9074731700","url":"https://github.com/wildfly/wildfly"},{"original_method":"private CommandContextImpl(jline.ConsoleReader console) {\n            this.console = console;\n        }","id":45370,"modified_method":"private CommandContextImpl(jline.ConsoleReader console) {\n            this.console = console;\n            operationCandidatesProvider = new DefaultOperationCandidatesProvider(this);\n        }","commit_id":"4751cd65f773e4dea1c91ab22eb07d9074731700","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void handle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            ctx.log(\"You are disconnected at the moment.\" +\n                    \" Type /connect to connect to the server\" +\n                    \" or /help for the list of supported commands.\");\n            return;\n        }\n\n        OperationRequestBuilder reqBuilder = new DefaultOperationRequestBuilder();\n        ctx.getPrefix().apply(reqBuilder);\n        try {\n           OperationRequestParser parser = ctx.getOperationRequestParser();\n           parser.parse(ctx.getCommandArguments(), reqBuilder);\n           ModelNode request = reqBuilder.buildRequest();\n           ModelNode result = client.execute(ExecutionContextBuilder.Factory.create(request).build());\n           ctx.log(result.toString());\n        } catch(CommandFormatException e) {\n            ctx.log(e.getLocalizedMessage());\n        } catch(NoSuchElementException e) {\n            ctx.log(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            ctx.log(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.log(\"Communication error: \" + e.getLocalizedMessage());\n        }\n    }","id":45371,"modified_method":"@Override\n    public void handle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            ctx.log(\"You are disconnected at the moment.\" +\n                    \" Type /connect to connect to the server\" +\n                    \" or /help for the list of supported commands.\");\n            return;\n        }\n\n        DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder(ctx.getPrefix());\n        try {\n            ctx.getOperationRequestParser().parse(ctx.getCommandArguments(), builder);\n            ModelNode request = builder.buildRequest();\n            ModelNode result = client.execute(request);\n            ctx.log(result.toString());\n        } catch(CommandFormatException e) {\n            ctx.log(e.getLocalizedMessage());\n        } catch(NoSuchElementException e) {\n            ctx.log(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            ctx.log(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.log(\"Communication error: \" + e.getLocalizedMessage());\n        }\n    }","commit_id":"4751cd65f773e4dea1c91ab22eb07d9074731700","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void handle(CommandContext ctx) {\n\n        String args = ctx.getCommandArguments();\n        Prefix prefix = ctx.getPrefix();\n\n        if(args == null) {\n            ctx.log(ctx.getPrefixFormatter().format(prefix));\n            return;\n        }\n\n        args = args.trim();\n        if(args.isEmpty()) {\n            ctx.log(ctx.getPrefixFormatter().format(prefix));\n            return;\n        }\n\n        try {\n            ctx.getPrefixParser().parse(args, ctx.getPrefix());\n        } catch (CommandFormatException e) {\n            ctx.log(e.getLocalizedMessage());\n        }\n    }","id":45372,"modified_method":"@Override\n    public void handle(CommandContext ctx) {\n\n        String args = ctx.getCommandArguments();\n        OperationRequestAddress prefix = ctx.getPrefix();\n\n        if(args == null) {\n            ctx.log(ctx.getPrefixFormatter().format(prefix));\n            return;\n        }\n\n        args = args.trim();\n        if(args.isEmpty()) {\n            ctx.log(ctx.getPrefixFormatter().format(prefix));\n            return;\n        }\n\n        OperationRequestParser.CallbackHandler handler = new DefaultOperationCallbackHandler(ctx.getPrefix());\n        try {\n            ctx.getOperationRequestParser().parse(args, handler);\n        } catch (CommandFormatException e) {\n            ctx.log(e.getLocalizedMessage());\n        }\n    }","commit_id":"4751cd65f773e4dea1c91ab22eb07d9074731700","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Private helper method to validate the user's prefix. Puts errors into the\n     * errors list.\n     */\n    private void validatePrefix() {\n        if (user.getPrefix() != null) {\n            // Make sure whether prefix is valid, if it is set\n            SortedSet validPrefixes = LocalizationService.getInstance().availablePrefixes();\n            if (!validPrefixes.contains(user.getPrefix())) {\n                errors.add(new ValidatorError(\n                        \"Invalid prefix [\" + user.getPrefix() + \"]. Must be one of \" +\n                        validPrefixes.toString()));\n            }\n        }\n    }","id":45373,"modified_method":"/**\n     * Private helper method to validate the user's prefix. Puts errors into the\n     * errors list.\n     */\n    private void validatePrefix() {\n        if (user.getPrefix() != null) {\n            // Make sure whether prefix is valid, if it is set\n            SortedSet validPrefixes = LocalizationService.getInstance().availablePrefixes();\n            if (!validPrefixes.contains(user.getPrefix())) {\n                errors.add(new ValidatorError(\n                        \"error.user_invalid_prefix\", user.getPrefix(), validPrefixes.toString()));\n            }\n        }\n    }","commit_id":"8ce92515891c64b2e27e534377601add6c7bf17d","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private void updateModelInLoadingState(SModelDescriptor modelDescriptor, SModel model) {\n    boolean wasLoading = model.isLoading();\n    model.setLoading(true);\n    try {\n      updateModel(modelDescriptor, model);\n    } finally {\n      model.setLoading(wasLoading);\n    }\n  }","id":45374,"modified_method":"private void updateModelInLoadingState(SModelDescriptor modelDescriptor, SModel model) {\n    boolean wasLoading = model.isLoading();\n    model.setLoading(true);\n    try {\n      updateModel(myLocaion,modelDescriptor, model);\n    } finally {\n      model.setLoading(wasLoading);\n    }\n  }","commit_id":"12eaa4a9026d3cbd3d0dc09155b2b82436b9c675","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected abstract void updateModel(SModelDescriptor modelDescriptor, SModel model);","id":45375,"modified_method":"protected abstract void updateModel(StubLocation location, SModelDescriptor modelDescriptor, SModel model);","commit_id":"12eaa4a9026d3cbd3d0dc09155b2b82436b9c675","url":"https://github.com/JetBrains/MPS"},{"original_method":"public final void updateModels(@NotNull SModelRoot root, @NotNull IModule module) {\n    SModelRepository repository = SModelRepository.getInstance();\n\n    for (SModelDescriptor descriptor : getModelDescriptors(module, root.getPrefix())) {\n      if (repository.getModelDescriptor(descriptor.getSModelReference()) == null) {\n        repository.registerModelDescriptor(descriptor, module);\n\n        if (repository.getOwners(descriptor).size() > 1) {\n          LOG.warning(\"Loading the same java_stub package twice : \" + descriptor.getLongName() + \" from \" + repository.getOwners(descriptor));\n        }\n      } else {\n        if (!descriptor.isInitialized()) {\n          if (!myDescriptorsWithListener.contains(descriptor)) {\n            descriptor.addModelListener(myInitializationListener);\n            myDescriptorsWithListener.add(descriptor);\n          }\n        } else {\n          updateModelInLoadingState(descriptor, descriptor.getSModel());\n        }\n      }\n    }\n  }","id":45376,"modified_method":"public final void updateModels(@NotNull SModelRoot root, @NotNull IModule module) {\n    myLocaion = new StubLocation(root.getPath(), root.getPrefix(), module);\n\n    SModelRepository repository = SModelRepository.getInstance();\n\n    for (SModelDescriptor descriptor : getModelDescriptors(myLocaion)) {\n      if (repository.getModelDescriptor(descriptor.getSModelReference()) == null) {\n        repository.registerModelDescriptor(descriptor, module);\n\n        if (repository.getOwners(descriptor).size() > 1) {\n          LOG.warning(\"Loading the same java_stub package twice : \" + descriptor.getLongName() + \" from \" + repository.getOwners(descriptor));\n        }\n      } else {\n        if (!descriptor.isInitialized()) {\n          if (!myDescriptorsWithListener.contains(descriptor)) {\n            descriptor.addModelListener(myInitializationListener);\n            myDescriptorsWithListener.add(descriptor);\n          }\n        } else {\n          updateModelInLoadingState(descriptor, descriptor.getSModel());\n        }\n      }\n    }\n  }","commit_id":"12eaa4a9026d3cbd3d0dc09155b2b82436b9c675","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected abstract Set<SModelDescriptor> getModelDescriptors(IModule module, String pack);","id":45377,"modified_method":"protected abstract Set<SModelDescriptor> getModelDescriptors(StubLocation location);","commit_id":"12eaa4a9026d3cbd3d0dc09155b2b82436b9c675","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addJavaStubs(Set<SNodeDescriptor> result, IScope scope) {\n    for (IModule m : scope.getVisibleModules()) {\n      for (SModelRoot root : m.getSModelRoots()) {\n        IModelRootManager manager = root.getManager();\n        if (manager instanceof BaseStubModelRootManager) {\n          result.addAll(((BaseStubModelRootManager) manager).getRootNodeDescriptors());\n        }\n      }\n    }\n  }","id":45378,"modified_method":"private void addJavaStubs(Set<SNodeDescriptor> result, IScope scope) {\n    for (IModule m : scope.getVisibleModules()) {\n      for (SModelRoot root : m.getSModelRoots()) {\n        IModelRootManager manager = root.getManager();\n        if (manager instanceof BaseStubModelRootManager) {\n          result.addAll(((BaseStubModelRootManager) manager).getRootNodeDescriptors(new StubLocation(root.getPath(), root.getPrefix(), m)));\n        }\n      }\n    }\n  }","commit_id":"12eaa4a9026d3cbd3d0dc09155b2b82436b9c675","url":"https://github.com/JetBrains/MPS"},{"original_method":"private CommandContextImpl(jline.ConsoleReader console) {\n            this.console = console;\n\n            console.setUseHistory(true);\n            String userHome = SecurityActions.getSystemProperty(\"user.home\");\n            File historyFile = new File(userHome, \".jboss-cli-history\");\n            try {\n                console.getHistory().setHistoryFile(historyFile);\n            } catch (IOException e) {\n                System.err.println(\"Failed to setup the history file \" + historyFile.getAbsolutePath() + \": \" + e.getLocalizedMessage());\n            }\n\n            this.history = new HistoryImpl();\n            operationCandidatesProvider = new DefaultOperationCandidatesProvider(this);\n\n            operationHandler = new OperationRequestHandler();\n\n            cmdCompleter = new CommandCompleter(cmdRegistry, this);\n        }","id":45379,"modified_method":"/**\n         * Interactive mode\n         */\n        private CommandContextImpl(jline.ConsoleReader console) {\n            this.console = console;\n\n            console.setUseHistory(true);\n            String userHome = SecurityActions.getSystemProperty(\"user.home\");\n            File historyFile = new File(userHome, \".jboss-cli-history\");\n            try {\n                console.getHistory().setHistoryFile(historyFile);\n            } catch (IOException e) {\n                System.err.println(\"Failed to setup the history file \" + historyFile.getAbsolutePath() + \": \" + e.getLocalizedMessage());\n            }\n\n            this.history = new HistoryImpl();\n            operationCandidatesProvider = new DefaultOperationCandidatesProvider(this);\n\n            operationHandler = new OperationRequestHandler();\n\n            cmdCompleter = new CommandCompleter(cmdRegistry, this);\n        }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void disconnectController() {\n            if(this.client != null) {\n                StreamUtils.safeClose(client);\n                printLine(\"Closed connection to \" + this.controllerHost + ':' + this.controllerPort);\n                client = null;\n                this.controllerHost = null;\n                this.controllerPort = -1;\n                domainMode = false;\n            }\n            promptConnectPart = null;\n        }","id":45380,"modified_method":"@Override\n        public void disconnectController() {\n            disconnectController(true);\n        }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void connectController(String host, int port) {\n            if(host == null) {\n                host = defaultControllerHost;\n            }\n\n            if(port < 0) {\n                port = defaultControllerPort;\n            }\n\n            try {\n                ModelControllerClient newClient = ModelControllerClient.Factory.create(host, port);\n                if(this.client != null) {\n                    disconnectController();\n                }\n\n                List<String> nodeTypes = Util.getNodeTypes(newClient, new DefaultOperationRequestAddress());\n                if (!nodeTypes.isEmpty()) {\n                    domainMode = nodeTypes.contains(\"server-group\");\n                    printLine(\"Connected to \"\n                            + (domainMode ? \"domain controller at \" : \"standalone controller at \")\n                            + host + \":\" + port);\n                    client = newClient;\n                    this.controllerHost = host;\n                    this.controllerPort = port;\n                } else {\n                    printLine(\"The controller is not available at \" + host + \":\" + port);\n                }\n            } catch (UnknownHostException e) {\n                printLine(\"Failed to resolve host '\" + host + \"': \" + e.getLocalizedMessage());\n            }\n        }","id":45381,"modified_method":"@Override\n        public void connectController(String host, int port) {\n            connectController(host, port, true);\n        }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void printColumns(Collection<String> col) {\n            try {\n                console.printColumns(col);\n            } catch (IOException e) {\n                System.err.println(\"Failed to print columns '\" + col + \"' to the console: \" + e.getLocalizedMessage());\n            }\n        }","id":45382,"modified_method":"@Override\n        public void printColumns(Collection<String> col) {\n            if (console != null) {\n                try {\n                    console.printColumns(col);\n                } catch (IOException e) {\n                    System.err.println(\"Failed to print columns '\" + col + \"' to the console: \" + e.getLocalizedMessage());\n                }\n            } else { // non interactive mode\n                for(String item : col) {\n                    System.out.println(item);\n                }\n            }\n        }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void printLine(String message) {\n            try {\n                console.printString(message);\n                console.printNewline();\n            } catch (IOException e) {\n                System.err.println(\"Failed to print '\" + message + \"' to the console: \" + e.getLocalizedMessage());\n            }\n        }","id":45383,"modified_method":"@Override\n        public void printLine(String message) {\n            if (console != null) {\n                try {\n                    console.printString(message);\n                    console.printNewline();\n                } catch (IOException e) {\n                    System.err.println(\"Failed to print '\" + message + \"' to the console: \" + e.getLocalizedMessage());\n                }\n            } else { // non-interactive mode\n                System.out.println(message);\n            }\n        }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void main(String[] args) throws Exception {\n\n        final jline.ConsoleReader console = initConsoleReader();\n\n        final CommandContextImpl cmdCtx = new CommandContextImpl(console);\n        SecurityActions.addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                cmdCtx.disconnectController();\n            }\n        }));\n        console.addCompletor(cmdCtx.cmdCompleter);\n\n        String[] commands = null;\n        String fileName = null;\n        boolean connect = false;\n        for(String arg : args) {\n            if(arg.startsWith(\"controller=\")) {\n                String value = arg.substring(11);\n                String portStr = null;\n                int colonIndex = value.indexOf(':');\n                if(colonIndex < 0) {\n                    // default port\n                    cmdCtx.defaultControllerHost = value;\n                } else if(colonIndex == 0) {\n                    // default host\n                    portStr = value.substring(1);\n                } else {\n                    cmdCtx.defaultControllerHost = value.substring(0, colonIndex);\n                    portStr = value.substring(colonIndex + 1);\n                }\n\n                if(portStr != null) {\n                    int port = -1;\n                    try {\n                        port = Integer.parseInt(portStr);\n                        if(port < 0) {\n                            cmdCtx.printLine(\"The port must be a valid non-negative integer: '\" + args + \"'\");\n                        } else {\n                            cmdCtx.defaultControllerPort = port;\n                        }\n                    } catch(NumberFormatException e) {\n                        cmdCtx.printLine(\"The port must be a valid non-negative integer: '\" + arg + \"'\");\n                    }\n                }\n            } else if(\"--connect\".equals(arg)) {\n                connect = true;\n            } else if(arg.startsWith(\"file=\")) {\n                fileName = arg.substring(5);\n            } else if(arg.startsWith(\"commands=\")) {\n                commands = arg.substring(9).split(\",+\");\n            } else if(arg.startsWith(\"command=\")) {\n                commands = new String[]{arg.substring(8)};\n            }\n        }\n\n        if(connect) {\n            cmdCtx.connectController(null, -1);\n        } else {\n            cmdCtx.printLine(\"You are disconnected at the moment.\" +\n                \" Type 'connect' to connect to the server or\" +\n                \" 'help' for the list of supported commands.\");\n        }\n\n        if(fileName != null && !fileName.isEmpty()) {\n            File f = new File(fileName);\n            if(!f.exists()) {\n                cmdCtx.printLine(\"File \" + f.getAbsolutePath() + \" doesn't exist.\");\n            } else {\n                BufferedReader reader = new BufferedReader(new FileReader(f));\n                try {\n                    String line = reader.readLine();\n                    while(!cmdCtx.terminate && line != null) {\n                        processLine(cmdCtx, line.trim());\n                        line = reader.readLine();\n                    }\n                } finally {\n                    StreamUtils.safeClose(reader);\n                    if(!cmdCtx.terminate) {\n                        cmdCtx.terminateSession();\n                    }\n                    cmdCtx.disconnectController();\n                }\n                return;\n            }\n        }\n\n        if(commands != null) {\n            for(int i = 0; i < commands.length && !cmdCtx.terminate; ++i) {\n                processLine(cmdCtx, commands[i]);\n            }\n            if(!cmdCtx.terminate) {\n                cmdCtx.terminateSession();\n            }\n            cmdCtx.disconnectController();\n            return;\n        }\n\n        try {\n            while (!cmdCtx.terminate) {\n                String line = console.readLine(cmdCtx.getPrompt()).trim();\n                processLine(cmdCtx, line);\n            }\n        } finally {\n            cmdCtx.disconnectController();\n        }\n    }","id":45384,"modified_method":"public static void main(String[] args) throws Exception {\n\n        String argError = null;\n        String[] commands = null;\n        File file = null;\n        boolean connect = false;\n        String defaultControllerHost = null;\n        int defaultControllerPort = -1;\n        for(String arg : args) {\n            if(arg.startsWith(\"controller=\")) {\n                String value = arg.substring(11);\n                String portStr = null;\n                int colonIndex = value.indexOf(':');\n                if(colonIndex < 0) {\n                    // default port\n                    defaultControllerHost = value;\n                } else if(colonIndex == 0) {\n                    // default host\n                    portStr = value.substring(1);\n                } else {\n                    defaultControllerHost = value.substring(0, colonIndex);\n                    portStr = value.substring(colonIndex + 1);\n                }\n\n                if(portStr != null) {\n                    int port = -1;\n                    try {\n                        port = Integer.parseInt(portStr);\n                        if(port < 0) {\n                            argError = \"The port must be a valid non-negative integer: '\" + args + \"'\";\n                        } else {\n                            defaultControllerPort = port;\n                        }\n                    } catch(NumberFormatException e) {\n                        argError = \"The port must be a valid non-negative integer: '\" + arg + \"'\";\n                    }\n                }\n            } else if(\"--connect\".equals(arg)) {\n                connect = true;\n            } else if(arg.startsWith(\"file=\")) {\n                if(file != null) {\n                    argError = \"Duplicate argument 'file'.\";\n                    break;\n                }\n                if(commands != null) {\n                    argError = \"Only one of 'file', 'commands' or 'command' can appear as the argument at a time.\";\n                    break;\n                }\n\n                final String fileName = arg.substring(5);\n                if(!fileName.isEmpty()) {\n                    file = new File(fileName);\n                    if(!file.exists()) {\n                        argError = \"File \" + file.getAbsolutePath() + \" doesn't exist.\";\n                        break;\n                    }\n                } else {\n                    argError = \"Argument 'file' is missing value.\";\n                    break;\n                }\n            } else if(arg.startsWith(\"commands=\")) {\n                if(file != null) {\n                    argError = \"Only one of 'file', 'commands' or 'command' can appear as the argument at a time.\";\n                    break;\n                }\n                if(commands != null) {\n                    argError = \"Duplicate argument 'command'/'commands'.\";\n                    break;\n                }\n                commands = arg.substring(9).split(\",+\");\n            } else if(arg.startsWith(\"command=\")) {\n                if(file != null) {\n                    argError = \"Only one of 'file', 'commands' or 'command' can appear as the argument at a time.\";\n                    break;\n                }\n                if(commands != null) {\n                    argError = \"Duplicate argument 'command'/'commands'.\";\n                    break;\n                }\n                commands = new String[]{arg.substring(8)};\n            }\n        }\n\n        if(argError != null) {\n            System.err.println(argError);\n            return;\n        }\n\n        if(file != null) {\n            processFile(file, defaultControllerHost, defaultControllerPort, connect);\n            return;\n        }\n\n        if(commands != null) {\n            processCommands(commands, defaultControllerHost, defaultControllerPort, connect);\n            return;\n        }\n\n        // Interactive mode\n\n        final jline.ConsoleReader console = initConsoleReader();\n        final CommandContextImpl cmdCtx = new CommandContextImpl(console);\n        SecurityActions.addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                cmdCtx.disconnectController();\n            }\n        }));\n        console.addCompletor(cmdCtx.cmdCompleter);\n\n        if(defaultControllerHost != null) {\n            cmdCtx.defaultControllerHost = defaultControllerHost;\n        }\n        if(defaultControllerPort != -1) {\n            cmdCtx.defaultControllerPort = defaultControllerPort;\n        }\n\n        if(connect) {\n            cmdCtx.connectController(null, -1);\n        } else {\n            cmdCtx.printLine(\"You are disconnected at the moment.\" +\n                \" Type 'connect' to connect to the server or\" +\n                \" 'help' for the list of supported commands.\");\n        }\n\n        try {\n            while (!cmdCtx.terminate) {\n                String line = console.readLine(cmdCtx.getPrompt()).trim();\n                processLine(cmdCtx, line);\n            }\n        } finally {\n            cmdCtx.disconnectController();\n        }\n    }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) {\n\n        final String nodePath = this.nodePath.getValue(ctx.getParsedArguments());\n\n        final OperationRequestAddress address;\n        if (nodePath != null) {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n            OperationRequestParser.CallbackHandler handler = new DefaultOperationCallbackHandler(address);\n            try {\n                ctx.getOperationRequestParser().parse(nodePath, handler);\n            } catch (CommandFormatException e) {\n                ctx.printLine(e.getLocalizedMessage());\n            }\n        } else {\n            address = ctx.getPrefix();\n        }\n\n        final List<String> names;\n        if(address.endsOnType()) {\n            names = ctx.getOperationCandidatesProvider().getNodeNames(address);\n        } else {\n            names = ctx.getOperationCandidatesProvider().getNodeTypes(address);\n        }\n\n        printList(ctx, names, l.isPresent(ctx.getParsedArguments()));\n    }","id":45385,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) {\n\n        final String nodePath = this.nodePath.getValue(ctx.getParsedArguments());\n\n        final OperationRequestAddress address;\n        if (nodePath != null) {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n            OperationRequestParser.CallbackHandler handler = new DefaultOperationCallbackHandler(address);\n            try {\n                ctx.getOperationRequestParser().parse(nodePath, handler);\n            } catch (CommandFormatException e) {\n                ctx.printLine(e.getLocalizedMessage());\n            }\n        } else {\n            address = new DefaultOperationRequestAddress(ctx.getPrefix());\n        }\n\n        final List<String> names;\n        if(address.endsOnType()) {\n            final String type = address.getNodeType();\n            address.toParentNode();\n            names = Util.getNodeNames(ctx.getModelControllerClient(), address, type);\n        } else {\n            names = Util.getNodeTypes(ctx.getModelControllerClient(), address);\n        }\n\n        printList(ctx, names, l.isPresent(ctx.getParsedArguments()));\n    }","commit_id":"34c65e553a6c95dc5949287f3bfe9c1e1433d1f3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public CCNFileProxy(String filePrefix, String ccnxURI) throws MalformedContentNameStringException, ConfigurationException, IOException {\n\t\t_prefix = ContentName.fromURI(ccnxURI);\n\t\t_filePrefix = filePrefix;\n\t\t_rootDirectory = new File(filePrefix);\n\t\tif (!_rootDirectory.exists()) {\n\t\t\tLog.severe(\"Cannot serve files from directory {0}: directory does not exist!\", filePrefix);\n\t\t\tthrow new IOException(\"Cannot serve files from directory \" + filePrefix + \": directory does not exist!\");\n\t\t}\n\t\t_handle = CCNHandle.open();\n\t}","id":45386,"modified_method":"public CCNFileProxy(String filePrefix, String ccnxURI) throws MalformedContentNameStringException, ConfigurationException, IOException {\n\t\t_prefix = ContentName.fromURI(ccnxURI);\n\t\t_filePrefix = filePrefix;\n\t\t_rootDirectory = new File(filePrefix);\n\t\tif (!_rootDirectory.exists()) {\n\t\t\tLog.severe(\"Cannot serve files from directory {0}: directory does not exist!\", filePrefix);\n\t\t\tthrow new IOException(\"Cannot serve files from directory \" + filePrefix + \": directory does not exist!\");\n\t\t}\n\t\t_handle = CCNHandle.open();\n\t\t\n\t\t//set response name for NE requests\n\t\t_responseName = KeyProfile.keyName(null, _handle.keyManager().getDefaultKeyID());\n\t\t\n\t}","commit_id":"3814d55c1bea53daceb52bb1bea3f7099cd36465","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Handle name enumeration requests\n\t * \n\t * @param interest\n\t * @throws IOException \n\t */\n\tpublic void nameEnumeratorResponse(Interest interest) throws IOException {\n\t\t\n\t\tContentName neRequestPrefix = interest.name().cut(CommandMarkers.COMMAND_MARKER_BASIC_ENUMERATION);\n\t\t\n\t\tFile directoryToEnumerate = ccnNameToFilePath(neRequestPrefix);\n\t\t\n\t\tif (!directoryToEnumerate.exists() || !directoryToEnumerate.isDirectory()) {\n\t\t\t// nothing to enumerate\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNameEnumerationResponse ner = new NameEnumerationResponse();\n\t\tner.setPrefix(new ContentName(neRequestPrefix, CommandMarkers.COMMAND_MARKER_BASIC_ENUMERATION));\n\t\t\n\t\tLog.info(\"Directory to enumerate: {0}, last modified {1}\", directoryToEnumerate.getAbsolutePath(), new CCNTime(directoryToEnumerate.lastModified()));\n\t\t// stat() the directory to see when it last changed -- will change whenever\n\t\t// a file is added or removed, which is the only thing that will change the\n\t\t// list we return.\n\t\tner.setTimestamp(new CCNTime(directoryToEnumerate.lastModified()));\n\t\t// See if the resulting response is later than the previous one we released.\n\t    ContentName potentialCollectionName = VersioningProfile.addVersion(ner.getPrefix(), ner.getTimestamp());\n\t    potentialCollectionName = SegmentationProfile.segmentName(potentialCollectionName, SegmentationProfile.baseSegment());\n\t\t//check if we should respond...\n\t\tif (interest.matches(potentialCollectionName, null)) {\n\t\t\n\t\t\t// We want to set the version of the NE response to the time of the \n\t\t\t// last modified file in the directory. Unfortunately that requires us to\n\t\t\t// stat() all the files whether we are going to respond or not.\n\t\t\tString [] children = directoryToEnumerate.list();\n\t\t\t\n\t\t\tif ((null != children) && (children.length > 0)) {\n\t\t\t\tfor (int i = 0; i < children.length; ++i) {\n\t\t\t\t\tner.add(children[i]);\n\t\t\t\t}\n\n\t\t\t\tNameEnumerationResponseMessage nem = ner.getNamesForResponse();\n\t\t\t\tNameEnumerationResponseMessageObject neResponse = new NameEnumerationResponseMessageObject(ner.getPrefix(), nem, _handle);\n\t\t\t\tneResponse.save(ner.getTimestamp(), interest);\n\t\t\t\tLog.info(\"sending back name enumeration response {0}, timestamp (version) {1}.\", ner.getPrefix(), ner.getTimestamp());\n\t\t\t} else {\n\t\t\t\tLog.info(\"no children available: we are not sending back a response to the name enumeration interest (interest = {0}); our response would have been {1}\", interest, potentialCollectionName);\n\t\t\t}\n\t\t} else {\n\t\t\tLog.info(\"we are not sending back a response to the name enumeration interest (interest = {0}); our response would have been {1}\", interest, potentialCollectionName);\n\t\t\tExclude.Element el = interest.exclude().value(1);\n\t\t\tif ((null != el) && (el instanceof ExcludeComponent)) {\n\t\t\t\tLog.info(\"previous version: {0}\", VersioningProfile.getVersionComponentAsTimestamp(((ExcludeComponent)el).getBytes()));\n\t\t\t}\n\t\t}\n\t}","id":45387,"modified_method":"/**\n\t * Handle name enumeration requests\n\t * \n\t * @param interest\n\t * @throws IOException \n\t */\n\tpublic void nameEnumeratorResponse(Interest interest) throws IOException {\n\t\t\n\t\tContentName neRequestPrefix = interest.name().cut(CommandMarkers.COMMAND_MARKER_BASIC_ENUMERATION);\n\t\t\n\t\tFile directoryToEnumerate = ccnNameToFilePath(neRequestPrefix);\n\t\t\n\t\tif (!directoryToEnumerate.exists() || !directoryToEnumerate.isDirectory()) {\n\t\t\t// nothing to enumerate\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNameEnumerationResponse ner = new NameEnumerationResponse();\n\t\tner.setPrefix(new ContentName(neRequestPrefix, CommandMarkers.COMMAND_MARKER_BASIC_ENUMERATION));\n\t\t\n\t\tLog.info(\"Directory to enumerate: {0}, last modified {1}\", directoryToEnumerate.getAbsolutePath(), new CCNTime(directoryToEnumerate.lastModified()));\n\t\t// stat() the directory to see when it last changed -- will change whenever\n\t\t// a file is added or removed, which is the only thing that will change the\n\t\t// list we return.\n\t\tner.setTimestamp(new CCNTime(directoryToEnumerate.lastModified()));\n\t\t// See if the resulting response is later than the previous one we released.\n\t\t\n\t\t//now add the response id\n\t    ContentName prefixWithId = new ContentName(ner.getPrefix(), _responseName.components());\n\t    //now finish up with version and segment\n\t    ContentName potentialCollectionName = VersioningProfile.addVersion(prefixWithId, ner.getTimestamp());\n\t    \n\t    //switch to add response id to name enumeration objects\n\t\t//ContentName potentialCollectionName = VersioningProfile.addVersion(ner.getPrefix(), ner.getTimestamp());\n\t    \n\t    potentialCollectionName = SegmentationProfile.segmentName(potentialCollectionName, SegmentationProfile.baseSegment());\n\t\t//check if we should respond...\n\t\tif (interest.matches(potentialCollectionName, null)) {\n\t\t\n\t\t\t// We want to set the version of the NE response to the time of the \n\t\t\t// last modified file in the directory. Unfortunately that requires us to\n\t\t\t// stat() all the files whether we are going to respond or not.\n\t\t\tString [] children = directoryToEnumerate.list();\n\t\t\t\n\t\t\tif ((null != children) && (children.length > 0)) {\n\t\t\t\tfor (int i = 0; i < children.length; ++i) {\n\t\t\t\t\tner.add(children[i]);\n\t\t\t\t}\n\n\t\t\t\tNameEnumerationResponseMessage nem = ner.getNamesForResponse();\n\t\t\t\tNameEnumerationResponseMessageObject neResponse = new NameEnumerationResponseMessageObject(prefixWithId, nem, _handle);\n\t\t\t\tneResponse.save(ner.getTimestamp(), interest);\n\t\t\t\tLog.info(\"sending back name enumeration response {0}, timestamp (version) {1}.\", ner.getPrefix(), ner.getTimestamp());\n\t\t\t} else {\n\t\t\t\tLog.info(\"no children available: we are not sending back a response to the name enumeration interest (interest = {0}); our response would have been {1}\", interest, potentialCollectionName);\n\t\t\t}\n\t\t} else {\n\t\t\tLog.info(\"we are not sending back a response to the name enumeration interest (interest = {0}); our response would have been {1}\", interest, potentialCollectionName);\n\t\t\tif (interest.exclude().size() > 1) {\n\t\t\t\tExclude.Element el = interest.exclude().value(1);\n\t\t\t\tif ((null != el) && (el instanceof ExcludeComponent)) {\n\t\t\t\t\tLog.info(\"previous version: {0}\", VersioningProfile.getVersionComponentAsTimestamp(((ExcludeComponent)el).getBytes()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"3814d55c1bea53daceb52bb1bea3f7099cd36465","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void update0(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        nProcessedLoci += context.getSkippedBases() + 1;\n    }","id":45388,"modified_method":"public void update0(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        nProcessedLoci += context.getSkippedBases() + (ref == null ? 0 : 1);\n    }","commit_id":"f1189bac5a7332d24d7b0cfbaa253cc72e20d386","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String, VariantContext> getVariantContexts(RefMetaDataTracker tracker, AlignmentContext context) {\n        // todo -- we need to deal with dbSNP where there can be multiple records at the same start site.  A potential solution is to\n        // todo -- allow the variant evaluation to specify the type of variants it wants to see and only take the first such record at a site\n        Map<String, VariantContext> bindings = new HashMap<String, VariantContext>();\n        bindVariantContexts(bindings, evalNames, tracker, context, false);\n        bindVariantContexts(bindings, compNames, tracker, context, true);\n        return bindings;\n    }","id":45389,"modified_method":"private Map<String, VariantContext> getVariantContexts(RefMetaDataTracker tracker, AlignmentContext context) {\n        // todo -- we need to deal with dbSNP where there can be multiple records at the same start site.  A potential solution is to\n        // todo -- allow the variant evaluation to specify the type of variants it wants to see and only take the first such record at a site\n        Map<String, VariantContext> bindings = new HashMap<String, VariantContext>();\n        if ( tracker != null ) {\n            bindVariantContexts(bindings, evalNames, tracker, context, false);\n            bindVariantContexts(bindings, compNames, tracker, context, true);\n        }\n        return bindings;\n    }","commit_id":"f1189bac5a7332d24d7b0cfbaa253cc72e20d386","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        //System.out.printf(\"map at %s with %d skipped%n\", context.getLocation(), context.getSkippedBases());\n\n        if ( ref == null )\n            return 0;\n\n        Map<String, VariantContext> vcs = getVariantContexts(tracker, context);\n        //Collection<VariantContext> comps = getCompVariantContexts(tracker, context);\n\n        // to enable walking over pairs where eval or comps have no elements\n        for ( EvaluationContext group : contexts ) {\n            VariantContext vc = vcs.get(group.evalTrackName);\n\n            //logger.debug(String.format(\"Updating %s with variant\", vc));\n            Set<VariantEvaluator> evaluations = group.evaluations;\n            boolean evalWantsVC = applyVCtoEvaluation(vc, vcs, group);\n            List<String> interestingReasons = new ArrayList<String>();\n\n            for ( VariantEvaluator evaluation : evaluations ) {\n                if ( evaluation.enabled() ) {\n                    // we always call update0 in case the evaluation tracks things like number of bases covered\n                    evaluation.update0(tracker, ref, context);\n\n                    // now call the single or paired update function\n                    switch ( evaluation.getComparisonOrder() ) {\n                        case 1:\n                            if ( evalWantsVC && vc != null ) {\n                                String interesting = evaluation.update1(vc, tracker, ref, context);\n                                if ( interesting != null ) interestingReasons.add(interesting);\n                            }\n                            break;\n                        case 2:\n                            VariantContext comp = vcs.get(group.compTrackName);\n                            String interesting = evaluation.update2( evalWantsVC ? vc : null, comp, tracker, ref, context );\n                            if ( interesting != null ) interestingReasons.add(interesting);\n                            break;\n                        default:\n                            throw new StingException(\"BUG: Unexpected evaluation order \" + evaluation);\n                    }\n                }\n            }\n\n            if ( group.enableInterestingSiteCaptures && captureInterestingSitesOfEvalSet(group) )\n                writeInterestingSite(interestingReasons, vc, ref.getBase());\n        }\n\n        return 0;\n    }","id":45390,"modified_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        //System.out.printf(\"map at %s with %d skipped%n\", context.getLocation(), context.getSkippedBases());\n\n        Map<String, VariantContext> vcs = getVariantContexts(tracker, context);\n        //Collection<VariantContext> comps = getCompVariantContexts(tracker, context);\n\n        // to enable walking over pairs where eval or comps have no elements\n        for ( EvaluationContext group : contexts ) {\n            VariantContext vc = vcs.get(group.evalTrackName);\n\n            //logger.debug(String.format(\"Updating %s with variant\", vc));\n            Set<VariantEvaluator> evaluations = group.evaluations;\n            boolean evalWantsVC = applyVCtoEvaluation(vc, vcs, group);\n            List<String> interestingReasons = new ArrayList<String>();\n\n            for ( VariantEvaluator evaluation : evaluations ) {\n                if ( evaluation.enabled() ) {\n                    // we always call update0 in case the evaluation tracks things like number of bases covered\n                    evaluation.update0(tracker, ref, context);\n\n                    // the other updateN methods don't see a null context\n                    if ( tracker == null )\n                        continue;\n\n                    // now call the single or paired update function\n                    switch ( evaluation.getComparisonOrder() ) {\n                        case 1:\n                            if ( evalWantsVC && vc != null ) {\n                                String interesting = evaluation.update1(vc, tracker, ref, context);\n                                if ( interesting != null ) interestingReasons.add(interesting);\n                            }\n                            break;\n                        case 2:\n                            VariantContext comp = vcs.get(group.compTrackName);\n                            String interesting = evaluation.update2( evalWantsVC ? vc : null, comp, tracker, ref, context );\n                            if ( interesting != null ) interestingReasons.add(interesting);\n                            break;\n                        default:\n                            throw new StingException(\"BUG: Unexpected evaluation order \" + evaluation);\n                    }\n                }\n            }\n\n            if ( tracker != null && group.enableInterestingSiteCaptures && captureInterestingSitesOfEvalSet(group) )\n                writeInterestingSite(interestingReasons, vc, ref.getBase());\n        }\n\n        return 0;\n    }","commit_id":"f1189bac5a7332d24d7b0cfbaa253cc72e20d386","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void apply(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context, VariantContext comp, VariantContext eval) {\n        for ( VariantEvaluator evaluation : evaluationInstances.values() ) {\n            if ( evaluation.enabled() ) {\n                // we always call update0 in case the evaluation tracks things like number of bases covered\n                evaluation.update0(tracker, ref, context);\n\n                // the other updateN methods don't see a null context\n                if ( tracker == null )\n                    continue;\n\n                // now call the single or paired update function\n                switch ( evaluation.getComparisonOrder() ) {\n                    case 1:\n                        if (eval != null) {\n                            evaluation.update1(eval, tracker, ref, context);\n                        }\n\n                        break;\n                    case 2:\n                        if (eval != null && comp != null) {\n                            evaluation.update2(eval, comp, tracker, ref, context);\n                        }\n\n                        break;\n                    default:\n                        throw new ReviewedStingException(\"BUG: Unexpected evaluation order \" + evaluation);\n                }\n            }\n        }\n    }","id":45391,"modified_method":"public void apply(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context, VariantContext comp, VariantContext eval) {\n        for ( VariantEvaluator evaluation : evaluationInstances.values() ) {\n            // we always call update0 in case the evaluation tracks things like number of bases covered\n            //evaluation.update0(tracker, ref, context);\n\n            // the other updateN methods don't see a null context\n            if ( tracker == null )\n                continue;\n\n            // now call the single or paired update function\n            switch ( evaluation.getComparisonOrder() ) {\n                case 1:\n                    if (eval != null) {\n                        evaluation.update1(eval, tracker, ref, context);\n                    }\n\n                    break;\n                case 2:\n                    if (eval != null) {\n                        evaluation.update2(eval, comp, tracker, ref, context);\n                    }\n\n                    break;\n                default:\n                    throw new ReviewedStingException(\"BUG: Unexpected evaluation order \" + evaluation);\n            }\n        }\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private EnumSet<VariantContext.Type> getAllowableVariationTypes(RefMetaDataTracker tracker, ReferenceContext ref, Set<String> evalNames) {\n        EnumSet<VariantContext.Type> allowableTypes = EnumSet.of(VariantContext.Type.NO_VARIATION);\n\n        Collection<VariantContext> vcs = tracker.getVariantContexts(ref, evalNames, null, ref.getLocus(), true, false);\n\n        for ( VariantContext vc : vcs ) {\n            allowableTypes.add(vc.getType());\n        }\n\n        return allowableTypes;\n    }","id":45392,"modified_method":"/**\n     * Figure out what the allowable variation types are based on the eval context\n     *\n     * @param tracker    the reference metadata tracker\n     * @param ref        the reference context\n     * @param evalNames  the evaluation track names\n     * @return  the set of allowable variation types\n     */\n    private EnumSet<VariantContext.Type> getAllowableVariationTypes(RefMetaDataTracker tracker, ReferenceContext ref, Set<String> evalNames) {\n        EnumSet<VariantContext.Type> allowableTypes = EnumSet.of(VariantContext.Type.NO_VARIATION);\n\n        if (tracker != null) {\n            Collection<VariantContext> vcs = tracker.getVariantContexts(ref, evalNames, null, ref.getLocus(), true, false);\n\n            for ( VariantContext vc : vcs ) {\n                allowableTypes.add(vc.getType());\n            }\n        } else {\n            allowableTypes.add(VariantContext.Type.SNP);\n        }\n        return allowableTypes;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone(Integer result) {\n        for ( StateKey stateKey : evaluationContexts.keySet() ) {\n            NewEvaluationContext nec = evaluationContexts.get(stateKey);\n\n            for ( VariantEvaluator ve : nec.getEvaluationClassList().values() ) {\n                ve.finalizeEvaluation();\n\n                AnalysisModuleScanner scanner = new AnalysisModuleScanner(ve);\n                Map<Field, DataPoint> datamap = scanner.getData();\n\n                GATKReportTable table = report.getTable(ve.getClass().getSimpleName());\n\n                for ( VariantStratifier vs : stratificationObjects ) {\n                    String columnName = vs.getClass().getSimpleName();\n\n                    columnName = columnName.replace(\"Stratifier\", \"\");\n                    columnName = columnName.replace(\"Status\", \"\");\n\n                    table.set(stateKey.toString(), columnName, stateKey.get(vs.getClass().getSimpleName()));\n                }\n\n                for (Field field : datamap.keySet()) {\n                    try {\n                        field.setAccessible(true);\n                        table.set(stateKey.toString(), field.getName(), field.get(ve));\n                    } catch (IllegalAccessException e) {\n                        throw new ReviewedStingException(\"Unable to access a data field in a VariantEval analysis module: \" + e);\n                    }\n                }\n            }\n        }\n\n        report.print(out);\n    }","id":45393,"modified_method":"/**\n     * Output the finalized report\n     *\n     * @param result  an integer that doesn't get used for anything\n     */\n    public void onTraversalDone(Integer result) {\n        for ( StateKey stateKey : evaluationContexts.keySet() ) {\n            NewEvaluationContext nec = evaluationContexts.get(stateKey);\n\n            for ( VariantEvaluator ve : nec.getEvaluationClassList().values() ) {\n                ve.finalizeEvaluation();\n\n                AnalysisModuleScanner scanner = new AnalysisModuleScanner(ve);\n                Map<Field, DataPoint> datamap = scanner.getData();\n\n                GATKReportTable table = report.getTable(ve.getClass().getSimpleName());\n\n                for ( VariantStratifier vs : stratificationObjects ) {\n                    String columnName = vs.getClass().getSimpleName();\n\n                    table.set(stateKey.toString(), columnName, stateKey.get(vs.getClass().getSimpleName()));\n                }\n\n                for (Field field : datamap.keySet()) {\n                    try {\n                        field.setAccessible(true);\n                        table.set(stateKey.toString(), field.getName(), field.get(ve));\n                    } catch (IllegalAccessException e) {\n                        throw new ReviewedStingException(\"Unable to access a data field in a VariantEval analysis module: \" + e);\n                    }\n                }\n            }\n        }\n\n        report.print(out);\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * List all of the available evaluation modules, then exit successfully\n     */\n    private void listModulesAndExit() {\n        List<Class<? extends VariantStratifier>> vsClasses = new PluginManager<VariantStratifier>( VariantStratifier.class ).getPlugins();\n        List<Class<? extends VariantEvaluator>> veClasses = new PluginManager<VariantEvaluator>( VariantEvaluator.class ).getPlugins();\n\n        logger.info(\"Available stratifcation modules:\");\n        logger.info(\"(Standard modules are starred)\");\n        for (Class<? extends VariantStratifier> vsClass : vsClasses) {\n            logger.info(\"\\t\" + vsClass.getSimpleName() + (RequiredStratification.class.isAssignableFrom(vsClass) || StandardStratification.class.isAssignableFrom(vsClass) ? \"*\" : \"\"));\n        }\n        logger.info(\"\");\n\n        logger.info(\"Available eval modules:\");\n        logger.info(\"(Standard modules are starred)\");\n        for (Class<? extends VariantEvaluator> veClass : veClasses) {\n            logger.info(\"\\t\" + veClass.getSimpleName() + (StandardEval.class.isAssignableFrom(veClass) ? \"*\" : \"\"));\n        }\n        logger.info(\"\");\n\n        System.exit(0);\n    }","id":45394,"modified_method":"/**\n     * List all of the available evaluation modules, then exit successfully\n     */\n    private void listModulesAndExit() {\n        List<Class<? extends VariantStratifier>> vsClasses = new PluginManager<VariantStratifier>( VariantStratifier.class ).getPlugins();\n        List<Class<? extends VariantEvaluator>> veClasses = new PluginManager<VariantEvaluator>( VariantEvaluator.class ).getPlugins();\n\n        logger.info(\"Available stratification modules:\");\n        logger.info(\"(Standard modules are starred)\");\n        for (Class<? extends VariantStratifier> vsClass : vsClasses) {\n            logger.info(\"\\t\" + vsClass.getSimpleName() + (RequiredStratification.class.isAssignableFrom(vsClass) || StandardStratification.class.isAssignableFrom(vsClass) ? \"*\" : \"\"));\n        }\n        logger.info(\"\");\n\n        logger.info(\"Available evaluation modules:\");\n        logger.info(\"(Standard modules are starred)\");\n        for (Class<? extends VariantEvaluator> veClass : veClasses) {\n            logger.info(\"\\t\" + veClass.getSimpleName() + (StandardEval.class.isAssignableFrom(veClass) ? \"*\" : \"\"));\n        }\n        logger.info(\"\");\n\n        System.exit(0);\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For a list of track names, bind the variant contexts to a trackName->sampleName->VariantContext mapping.\n     * Additional variant contexts per sample are automatically generated and added to the map unless the\n     * sample name matches the ALL_SAMPLE_NAME constant.\n     *\n     * @param tracker         the metadata tracker\n     * @param ref             the reference context\n     * @param trackNames      the list of track names to process\n     * @param sampleNames     the list of samples to include\n     * @param allowableTypes  a set of allowable variation types\n     * @return  a mapping of track names to a list of VariantContext objects\n     */\n    private HashMap<String, HashMap<String, VariantContext>> bindVariantContexts(RefMetaDataTracker tracker, ReferenceContext ref, Set<String> trackNames, Set<String> sampleNames, EnumSet<VariantContext.Type> allowableTypes) {\n        HashMap<String, HashMap<String, VariantContext>> bindings = new HashMap<String, HashMap<String, VariantContext>>();\n\n        for ( String trackName : trackNames ) {\n            Collection<VariantContext> contexts = tracker.getVariantContexts(ref, trackName, allowableTypes, ref.getLocus(), true, true);\n\n            VariantContext vc = contexts.size() == 1 ? contexts.iterator().next() : null;\n\n            HashMap<String, VariantContext> vcs = new HashMap<String, VariantContext>();\n\n            if ( vc != null ) {\n                for ( String sample : sampleNames ) {\n                    VariantContext vcsub = vc;\n\n                    if (!sample.equals(ALL_SAMPLE_NAME)) {\n                        vcsub = vcsub.subContextFromGenotypes(vcsub.getGenotype(sample));\n\n                        HashMap<String,Object> newAts = new HashMap<String,Object>(vcsub.getAttributes());\n                        VariantContextUtils.calculateChromosomeCounts(vcsub,newAts,true);\n                        vcsub = VariantContext.modifyAttributes(vcsub,newAts);\n\n                        logger.debug(String.format(\"VC %s subset to %s AC%n\", vc.getSource(), vc.getAttributeAsString(VCFConstants.ALLELE_COUNT_KEY)));\n                    }\n\n                    vcs.put(sample, vcsub);\n                }\n\n                bindings.put(trackName, vcs);\n            }\n        }\n\n        return bindings;\n    }","id":45395,"modified_method":"/**\n     * For a list of track names, bind the variant contexts to a trackName->sampleName->VariantContext mapping.\n     * Additional variant contexts per sample are automatically generated and added to the map unless the\n     * sample name matches the ALL_SAMPLE_NAME constant.\n     *\n     * @param tracker         the metadata tracker\n     * @param ref             the reference context\n     * @param trackNames      the list of track names to process\n     * @param sampleNames     the list of samples to include\n     * @param allowableTypes  a set of allowable variation types\n     * @return  a mapping of track names to a list of VariantContext objects\n     */\n    private HashMap<String, HashMap<String, VariantContext>> bindVariantContexts(RefMetaDataTracker tracker, ReferenceContext ref, Set<String> trackNames, Set<String> sampleNames, EnumSet<VariantContext.Type> allowableTypes) {\n        HashMap<String, HashMap<String, VariantContext>> bindings = new HashMap<String, HashMap<String, VariantContext>>();\n\n        for ( String trackName : trackNames ) {\n            Collection<VariantContext> contexts = tracker == null ? null : tracker.getVariantContexts(ref, trackName, allowableTypes, ref.getLocus(), true, true);\n\n            VariantContext vc = contexts != null && contexts.size() == 1 ? contexts.iterator().next() : null;\n\n            HashMap<String, VariantContext> vcs = new HashMap<String, VariantContext>();\n\n            if ( vc != null ) {\n                for ( String sample : sampleNames ) {\n                    VariantContext vcsub = vc;\n\n                    if (!sample.equals(ALL_SAMPLE_NAME)) {\n                        vcsub = vcsub.subContextFromGenotypes(vcsub.getGenotype(sample));\n\n                        HashMap<String,Object> newAts = new HashMap<String,Object>(vcsub.getAttributes());\n                        VariantContextUtils.calculateChromosomeCounts(vcsub,newAts,true);\n                        vcsub = VariantContext.modifyAttributes(vcsub,newAts);\n\n                        logger.debug(String.format(\"VC %s subset to %s AC%n\", vc.getSource(), vc.getAttributeAsString(VCFConstants.ALLELE_COUNT_KEY)));\n                    }\n\n                    vcs.put(sample, vcsub);\n                }\n\n                bindings.put(trackName, vcs);\n            }\n        }\n\n        return bindings;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private ArrayList<StateKey> initializeStateKeys(HashMap<VariantStratifier, ArrayList<String>> stateMap, Stack<HashMap<VariantStratifier, ArrayList<String>>> stateStack, StateKey stateKey) {\n        ArrayList<StateKey> stateKeys = new ArrayList<StateKey>();\n\n        if (stateStack == null) {\n            stateStack = new Stack<HashMap<VariantStratifier, ArrayList<String>>>();\n\n            for ( VariantStratifier vs : stateMap.keySet() ) {\n                HashMap<VariantStratifier, ArrayList<String>> oneSetOfStates = new HashMap<VariantStratifier, ArrayList<String>>();\n                oneSetOfStates.put(vs, stateMap.get(vs));\n\n                stateStack.add(oneSetOfStates);\n            }\n        }\n\n        if (!stateStack.isEmpty()) {\n            Stack<HashMap<VariantStratifier, ArrayList<String>>> newStateStack = new Stack<HashMap<VariantStratifier, ArrayList<String>>>();\n            newStateStack.addAll(stateStack);\n\n            StateKey newStateKey = new StateKey();\n            if (stateKey != null) {\n                newStateKey.putAll(stateKey);\n            }\n\n            HashMap<VariantStratifier, ArrayList<String>> oneSetOfStates = newStateStack.pop();\n            VariantStratifier vs = oneSetOfStates.keySet().iterator().next();\n\n            for ( String state : oneSetOfStates.get(vs)) {\n                newStateKey.put(vs.getClass().getSimpleName(), state);\n\n                stateKeys.addAll(initializeStateKeys(stateMap, newStateStack, newStateKey));\n            }\n        } else {\n            ArrayList<StateKey> newStateKeys = new ArrayList<StateKey>();\n\n            newStateKeys.add(stateKey);\n\n            return newStateKeys;\n        }\n\n        return stateKeys;\n    }","id":45396,"modified_method":"/**\n     * Recursively initialize the state keys used to look up the right evaluation context based on the state of the variant context\n     *\n     * @param stateMap    the map of allowable states\n     * @param stateStack  a stack of the states\n     * @param stateKey    a state key object\n     * @param stateKeys   all the state keys\n     * @return  a list of state keys\n     */\n    private ArrayList<StateKey> initializeStateKeys(HashMap<VariantStratifier, ArrayList<String>> stateMap, Stack<HashMap<VariantStratifier, ArrayList<String>>> stateStack, StateKey stateKey, ArrayList<StateKey> stateKeys) {\n        if (stateStack == null) {\n            stateStack = new Stack<HashMap<VariantStratifier, ArrayList<String>>>();\n\n            for ( VariantStratifier vs : stateMap.keySet() ) {\n                HashMap<VariantStratifier, ArrayList<String>> oneSetOfStates = new HashMap<VariantStratifier, ArrayList<String>>();\n                oneSetOfStates.put(vs, stateMap.get(vs));\n\n                stateStack.add(oneSetOfStates);\n            }\n        }\n\n        if (!stateStack.isEmpty()) {\n            Stack<HashMap<VariantStratifier, ArrayList<String>>> newStateStack = new Stack<HashMap<VariantStratifier, ArrayList<String>>>();\n            newStateStack.addAll(stateStack);\n\n            HashMap<VariantStratifier, ArrayList<String>> oneSetOfStates = newStateStack.pop();\n            VariantStratifier vs = oneSetOfStates.keySet().iterator().next();\n\n            for ( String state : oneSetOfStates.get(vs)) {\n                StateKey newStateKey = new StateKey();\n                if (stateKey != null) {\n                    newStateKey.putAll(stateKey);\n                }\n\n                newStateKey.put(vs.getClass().getSimpleName(), state);\n\n                initializeStateKeys(stateMap, newStateStack, newStateKey, stateKeys);\n            }\n        } else {\n            stateKeys.add(stateKey);\n\n            return stateKeys;\n        }\n\n        return stateKeys;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Maps track names to sample name to VariantContext objects.  For eval tracks, VariantContexts per specified\n     * sample are also included.\n     *\n     * @param tracker      the metadata tracker\n     * @param ref          the reference context\n     * @param compNames    the list of comp names to process\n     * @param evalNames    the list of eval names to process\n     * @param sampleNames  the list of samples to include\n     * @return  a mapping of track names to a list of VariantContext objects\n     */\n    private HashMap<String, HashMap<String, VariantContext>> getVariantContexts(RefMetaDataTracker tracker, ReferenceContext ref, Set<String> compNames, Set<String> evalNames, Set<String> sampleNames) {\n        HashMap<String, HashMap<String, VariantContext>> vcs = new HashMap<String, HashMap<String, VariantContext>>();\n\n        Set<String> allSamplesList = new HashSet<String>();\n        allSamplesList.add(ALL_SAMPLE_NAME);\n\n        EnumSet<VariantContext.Type> allowableTypes = getAllowableVariationTypes(tracker, ref, evalNames);\n\n        HashMap<String, HashMap<String, VariantContext>> compBindings = bindVariantContexts(tracker, ref, compNames, allSamplesList, allowableTypes);\n        HashMap<String, HashMap<String, VariantContext>> evalBindings = bindVariantContexts(tracker, ref, evalNames, sampleNames, allowableTypes);\n\n        //HashMap<String, HashMap<String, VariantContext>> evalBindings;\n        //if (stratificationObjects.contains(SampleStratifier) {\n        //    evalBindings = bindVariantContexts(tracker, ref, evalNames, sampleNames, allowableTypes);\n        //} else {\n        //    evalBindings = bindVariantContexts(tracker, ref, evalNames, allSamplesList, allowableTypes);\n        //}\n\n        vcs.putAll(compBindings);\n        vcs.putAll(evalBindings);\n\n        return vcs;\n    }","id":45397,"modified_method":"/**\n     * Maps track names to sample name to VariantContext objects.  For eval tracks, VariantContexts per specified\n     * sample are also included.\n     *\n     * @param tracker      the metadata tracker\n     * @param ref          the reference context\n     * @param compNames    the list of comp names to process\n     * @param evalNames    the list of eval names to process\n     * @param sampleNames  the list of samples to include\n     * @return  a mapping of track names to a list of VariantContext objects\n     */\n    private HashMap<String, HashMap<String, VariantContext>> getVariantContexts(RefMetaDataTracker tracker, ReferenceContext ref, Set<String> compNames, Set<String> evalNames, Set<String> sampleNames) {\n        HashMap<String, HashMap<String, VariantContext>> vcs = new HashMap<String, HashMap<String, VariantContext>>();\n\n        Set<String> allSamplesList = new HashSet<String>();\n        allSamplesList.add(ALL_SAMPLE_NAME);\n\n        EnumSet<VariantContext.Type> allowableTypes = getAllowableVariationTypes(tracker, ref, evalNames);\n\n        HashMap<String, HashMap<String, VariantContext>> compBindings = bindVariantContexts(tracker, ref, compNames, allSamplesList, allowableTypes);\n\n        HashMap<String, HashMap<String, VariantContext>> evalBindings;\n\n        boolean perSampleIsEnabled = false;\n        for (VariantStratifier vs : stratificationObjects) {\n            if (vs.getClass().getSimpleName().equals(\"Sample\")) {\n                perSampleIsEnabled = true;\n                break;\n            }\n        }\n\n        if (perSampleIsEnabled) {\n            evalBindings = bindVariantContexts(tracker, ref, evalNames, sampleNames, allowableTypes);\n        } else {\n            evalBindings = bindVariantContexts(tracker, ref, evalNames, allSamplesList, allowableTypes);\n        }\n\n        vcs.putAll(compBindings);\n        vcs.putAll(evalBindings);\n\n        return vcs;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private GATKReport initializeGATKReport(Set<VariantStratifier> stratificationObjects, Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n        GATKReport report = new GATKReport();\n\n        for ( Class<? extends VariantEvaluator> ve : evaluationObjects ) {\n            String tableName = ve.getSimpleName();\n            String tableDesc = ve.getAnnotation(Analysis.class).description();\n\n            report.addTable(tableName, tableDesc);\n\n            GATKReportTable table = report.getTable(tableName);\n            table.addPrimaryKey(\"entry\", false);\n\n            for ( VariantStratifier vs : stratificationObjects ) {\n                String columnName = vs.getClass().getSimpleName();\n\n                columnName = columnName.replace(\"Stratifier\", \"\");\n                columnName = columnName.replace(\"Status\", \"\");\n\n                table.addColumn(columnName, \"unknown\");\n            }\n\n            AnalysisModuleScanner scanner = new AnalysisModuleScanner(ve);\n            Map<Field, DataPoint> datamap = scanner.getData();\n\n            for (Field field : datamap.keySet()) {\n                table.addColumn(field.getName(), 0.0);\n            }\n        }\n\n        return report;\n    }","id":45398,"modified_method":"/**\n     * Initialize the output report\n     *\n     * @param stratificationObjects  the stratifications to use\n     * @param evaluationObjects      the evaluations to use\n     * @return  an initialized report object\n     */\n    private GATKReport initializeGATKReport(Set<VariantStratifier> stratificationObjects, Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n        GATKReport report = new GATKReport();\n\n        for ( Class<? extends VariantEvaluator> ve : evaluationObjects ) {\n            String tableName = ve.getSimpleName();\n            String tableDesc = ve.getAnnotation(Analysis.class).description();\n\n            report.addTable(tableName, tableDesc);\n\n            GATKReportTable table = report.getTable(tableName);\n            table.addPrimaryKey(\"entry\", false);\n            table.addColumn(tableName, tableName);\n\n            for ( VariantStratifier vs : stratificationObjects ) {\n                String columnName = vs.getClass().getSimpleName();\n\n                table.addColumn(columnName, \"unknown\");\n            }\n\n            AnalysisModuleScanner scanner = new AnalysisModuleScanner(ve);\n            Map<Field, DataPoint> datamap = scanner.getData();\n\n            for (Field field : datamap.keySet()) {\n                table.addColumn(field.getName(), 0.0);\n            }\n        }\n\n        return report;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if (tracker != null) {\n            //      track           sample  vc\n            HashMap<String, HashMap<String, VariantContext>> vcs = getVariantContexts(tracker, ref, compNames, evalNames, sampleNames);\n\n            for ( String compName : compNames ) {\n                VariantContext comp = vcs.containsKey(compName) && vcs.get(compName) != null && vcs.get(compName).containsKey(ALL_SAMPLE_NAME) ? vcs.get(compName).get(ALL_SAMPLE_NAME) : null;\n\n                for ( String evalName : evalNames ) {\n                    for ( String sampleName : sampleNames ) {\n                        VariantContext eval = vcs.get(evalName) == null ? null : vcs.get(evalName).get(sampleName);\n\n                        HashMap<VariantStratifier, ArrayList<String>> stateMap = new HashMap<VariantStratifier, ArrayList<String>>();\n                        for ( VariantStratifier vs : stratificationObjects ) {\n                            ArrayList<String> states = vs.getRelevantStates(ref, comp, eval, sampleName);\n                            stateMap.put(vs, states);\n                        }\n\n                        ArrayList<StateKey> stateKeys = initializeStateKeys(stateMap, null, null);\n\n                        for ( StateKey stateKey : stateKeys ) {\n                            NewEvaluationContext nec = evaluationContexts.get(stateKey);\n\n                            nec.apply(tracker, ref, context, comp, eval);\n                        }\n\n                        //logger.info(ref.getLocus());\n                        //logger.info(\"\\tcomp: \" + comp);\n                        //logger.info(\"\\teval: \" + eval);\n                    }\n                }\n            }\n        }\n\n        return null;\n    }","id":45399,"modified_method":"/**\n     * Collect relevant information from each variant in the supplied VCFs\n     */\n    @Override\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        for ( NewEvaluationContext nec : evaluationContexts.values() ) {\n            nec.update0(tracker, ref, context);\n        }\n\n        //      track           sample  vc\n        HashMap<String, HashMap<String, VariantContext>> vcs = getVariantContexts(tracker, ref, compNames, evalNames, sampleNames);\n\n        for ( String compName : compNames ) {\n            VariantContext comp = vcs.containsKey(compName) && vcs.get(compName) != null && vcs.get(compName).containsKey(ALL_SAMPLE_NAME) ? vcs.get(compName).get(ALL_SAMPLE_NAME) : null;\n\n            for ( String evalName : evalNames ) {\n                for ( String sampleName : sampleNames ) {\n                    VariantContext eval = vcs.containsKey(evalName) && vcs.get(evalName) != null ? vcs.get(evalName).get(sampleName) : null;\n\n                    HashMap<VariantStratifier, ArrayList<String>> stateMap = new HashMap<VariantStratifier, ArrayList<String>>();\n                    for ( VariantStratifier vs : stratificationObjects ) {\n                        ArrayList<String> states = vs.getRelevantStates(ref, comp, compName, eval, sampleName);\n                        stateMap.put(vs, states);\n                    }\n\n                    ArrayList<StateKey> stateKeys = new ArrayList<StateKey>();\n                    initializeStateKeys(stateMap, null, null, stateKeys);\n\n                    HashSet<StateKey> stateKeysHash = new HashSet<StateKey>(stateKeys);\n\n                    for ( StateKey stateKey : stateKeysHash ) {\n                        NewEvaluationContext nec = evaluationContexts.get(stateKey);\n\n                        nec.apply(tracker, ref, context, comp, eval);\n                    }\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private HashMap<StateKey, NewEvaluationContext> initializeEvaluationContexts(Set<VariantStratifier> stratificationObjects,  Set<Class<? extends VariantEvaluator>> evaluationObjects, Stack<VariantStratifier> stratStack, NewEvaluationContext ec) {\n        HashMap<StateKey, NewEvaluationContext> ecs = new HashMap<StateKey, NewEvaluationContext>();\n\n        if (stratStack == null) {\n            stratStack = new Stack<VariantStratifier>();\n            stratStack.addAll(stratificationObjects);\n        }\n\n        if (!stratStack.isEmpty()) {\n            Stack<VariantStratifier> newStratStack = new Stack<VariantStratifier>();\n            newStratStack.addAll(stratStack);\n\n            NewEvaluationContext nec = new NewEvaluationContext();\n            if (ec != null) {\n                nec.putAll(ec);\n            }\n\n            VariantStratifier vs = newStratStack.pop();\n\n            for ( String state : vs.getAllStates() ) {\n                nec.put(vs, state);\n\n                ecs.putAll(initializeEvaluationContexts(stratificationObjects, evaluationObjects, newStratStack, nec));\n            }\n        } else {\n            HashMap<StateKey, NewEvaluationContext> necs = new HashMap<StateKey, NewEvaluationContext>();\n\n            StateKey statekey = new StateKey();\n            for ( VariantStratifier vs : ec.keySet() ) {\n                String state = ec.get(vs);\n\n                statekey.put(vs.getClass().getSimpleName(), state);\n            }\n\n            ec.addEvaluationClassList(evaluationObjects);\n\n            necs.put(statekey, ec);\n\n            return necs;\n        }\n\n        return ecs;\n    }","id":45400,"modified_method":"/**\n     * Recursively initialize the evaluation contexts\n     *\n     * @param stratificationObjects  the stratifications to use\n     * @param evaluationObjects      the evaluations to use\n     * @param stratStack             a stack of stratifications to apply\n     * @param ec                     evaluation context\n     * @return  a map of all the evaluation contexts\n     */\n    private HashMap<StateKey, NewEvaluationContext> initializeEvaluationContexts(Set<VariantStratifier> stratificationObjects,  Set<Class<? extends VariantEvaluator>> evaluationObjects, Stack<VariantStratifier> stratStack, NewEvaluationContext ec) {\n        HashMap<StateKey, NewEvaluationContext> ecs = new HashMap<StateKey, NewEvaluationContext>();\n\n        if (stratStack == null) {\n            stratStack = new Stack<VariantStratifier>();\n            stratStack.addAll(stratificationObjects);\n        }\n\n        if (!stratStack.isEmpty()) {\n            Stack<VariantStratifier> newStratStack = new Stack<VariantStratifier>();\n            newStratStack.addAll(stratStack);\n\n            NewEvaluationContext nec = new NewEvaluationContext();\n            if (ec != null) {\n                nec.putAll(ec);\n            }\n\n            VariantStratifier vs = newStratStack.pop();\n\n            for ( String state : vs.getAllStates() ) {\n                nec.put(vs, state);\n\n                ecs.putAll(initializeEvaluationContexts(stratificationObjects, evaluationObjects, newStratStack, nec));\n            }\n        } else {\n            HashMap<StateKey, NewEvaluationContext> necs = new HashMap<StateKey, NewEvaluationContext>();\n\n            StateKey statekey = new StateKey();\n            for ( VariantStratifier vs : ec.keySet() ) {\n                String state = ec.get(vs);\n\n                statekey.put(vs.getClass().getSimpleName(), state);\n            }\n\n            ec.addEvaluationClassList(evaluationObjects);\n\n            necs.put(statekey, ec);\n\n            return necs;\n        }\n\n        return ecs;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        // Just list the modules, and exit quickly.\n        if (LIST) { listModulesAndExit(); }\n\n        // Categorize each rod as an eval or a comp rod.\n        for ( ReferenceOrderedDataSource d : this.getToolkit().getRodDataSources() ) {\n            if ( d.getName().startsWith(\"eval\") ) {\n                evalNames.add(d.getName());\n            } else if ( d.getName().startsWith(\"comp\") || d.getName().startsWith(DbSNPHelper.STANDARD_DBSNP_TRACK_NAME) ) {\n                compNames.add(d.getName());\n            } else {\n                logger.info(String.format(\"Not evaluating ROD binding '%s' because the name did not start with %s, comp, or eval\", d.getName(), Utils.join(\", \", KNOWN_NAMES)));\n            }\n        }\n\n        // Set up set of known names\n        knownNames.addAll(Arrays.asList(KNOWN_NAMES));\n\n        // Now that we have all the rods categorized, determine the sample list from the eval rods.\n        Map<String, VCFHeader> vcfRods = VCFUtils.getVCFHeadersFromRods(getToolkit(), evalNames);\n        Set<String> vcfSamples = SampleUtils.getSampleList(vcfRods, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE);\n        sampleNames.addAll(SampleUtils.getSamplesFromCommandLineInput(vcfSamples, SAMPLE_EXPRESSIONS));\n\n        // Initialize select expressions\n        jexlExpressions.addAll(VariantContextUtils.initializeMatchExps(SELECT_NAMES, SELECT_EXPS));\n\n        // Initialize the set of stratifications and evaluations to use\n        stratificationObjects = initializeStratificationObjects(NO_STANDARD_STRATIFICATIONS, STRATIFICATIONS_TO_USE);\n        evaluationObjects = initializeEvaluationObjects(NO_STANDARD_MODULES, MODULES_TO_USE);\n\n        // Initialize the evaluation contexts\n        evaluationContexts = initializeEvaluationContexts(stratificationObjects, evaluationObjects, null, null);\n\n        // Initialize report table\n        report = initializeGATKReport(stratificationObjects, evaluationObjects);\n    }","id":45401,"modified_method":"/**\n     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n     */\n    public void initialize() {\n        // Just list the modules, and exit quickly.\n        if (LIST) { listModulesAndExit(); }\n\n        // Categorize each rod as an eval or a comp rod.\n        for ( ReferenceOrderedDataSource d : this.getToolkit().getRodDataSources() ) {\n            if ( d.getName().startsWith(\"eval\") ) {\n                evalNames.add(d.getName());\n            } else if ( d.getName().startsWith(\"comp\") || d.getName().startsWith(DbSNPHelper.STANDARD_DBSNP_TRACK_NAME) ) {\n                compNames.add(d.getName());\n            } else {\n                logger.info(String.format(\"Not evaluating ROD binding '%s' because the name did not start with %s, comp, or eval\", d.getName(), Utils.join(\", \", KNOWN_NAMES)));\n            }\n        }\n\n        // Set up set of known names\n        knownNames.addAll(Arrays.asList(KNOWN_NAMES));\n\n        // Now that we have all the rods categorized, determine the sample list from the eval rods.\n        Map<String, VCFHeader> vcfRods = VCFUtils.getVCFHeadersFromRods(getToolkit(), evalNames);\n        Set<String> vcfSamples = SampleUtils.getSampleList(vcfRods, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE);\n        sampleNames.add(ALL_SAMPLE_NAME);\n\n        // If we're not using the per-sample stratification, don't bother loading the sample list\n        if (Arrays.asList(STRATIFICATIONS_TO_USE).contains(\"Sample\")) {\n            sampleNames.addAll(SampleUtils.getSamplesFromCommandLineInput(vcfSamples, SAMPLE_EXPRESSIONS));\n        }\n\n        // Initialize select expressions\n        jexlExpressions.addAll(VariantContextUtils.initializeMatchExps(SELECT_NAMES, SELECT_EXPS));\n\n        // Initialize the set of stratifications and evaluations to use\n        stratificationObjects = initializeStratificationObjects(NO_STANDARD_STRATIFICATIONS, STRATIFICATIONS_TO_USE);\n        Set<Class<? extends VariantEvaluator>> evaluationObjects = initializeEvaluationObjects(NO_STANDARD_MODULES, MODULES_TO_USE);\n\n        // Initialize the evaluation contexts\n        evaluationContexts = initializeEvaluationContexts(stratificationObjects, evaluationObjects, null, null);\n\n        // Initialize report table\n        report = initializeGATKReport(stratificationObjects, evaluationObjects);\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Set<Class<? extends VariantEvaluator>> initializeEvaluationObjects(boolean noStandardEvals, String[] modulesToUse) {\n        Set<Class<? extends VariantEvaluator>> evals = new HashSet<Class<? extends VariantEvaluator>>();\n\n        // Create a map for all eval modules for easy lookup.\n        HashMap<String, Class<? extends VariantEvaluator>> classMap = new HashMap<String, Class<? extends VariantEvaluator>>();\n        for ( Class<? extends VariantEvaluator> c : new PluginManager<VariantEvaluator>( VariantEvaluator.class ).getPlugins() ) {\n            classMap.put(c.getSimpleName(), c);\n        }\n\n        // By default, use standard eval modules.\n        if ( !noStandardEvals ) {\n            for ( Class<? extends StandardEval> stdClass : new PluginManager<StandardEval>( StandardEval.class ).getPlugins() ) {\n                if ( classMap.containsKey(stdClass.getSimpleName()) ) {\n                    evals.add(classMap.get(stdClass.getSimpleName()));\n                }\n            }\n        }\n\n        // Get the specific classes provided.\n        for ( String module : modulesToUse ) {\n            if ( !classMap.containsKey(module) ) {\n                throw new UserException.CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n            }\n\n            if ( classMap.containsKey(module) ) {\n                evals.add(classMap.get(module));\n            }\n        }\n\n        return evals;\n    }","id":45402,"modified_method":"/**\n     * Initialize required, standard and user-specified evaluation objects\n     *\n     * @param noStandardEvals  don't use the standard evaluations\n     * @param modulesToUse     the list of evaluation modules to use\n     * @return  set of evaluations to use\n     */\n    private Set<Class<? extends VariantEvaluator>> initializeEvaluationObjects(boolean noStandardEvals, String[] modulesToUse) {\n        Set<Class<? extends VariantEvaluator>> evals = new HashSet<Class<? extends VariantEvaluator>>();\n\n        // Create a map for all eval modules for easy lookup.\n        HashMap<String, Class<? extends VariantEvaluator>> classMap = new HashMap<String, Class<? extends VariantEvaluator>>();\n        for ( Class<? extends VariantEvaluator> c : new PluginManager<VariantEvaluator>( VariantEvaluator.class ).getPlugins() ) {\n            classMap.put(c.getSimpleName(), c);\n        }\n\n        // By default, use standard eval modules.\n        if ( !noStandardEvals ) {\n            for ( Class<? extends StandardEval> stdClass : new PluginManager<StandardEval>( StandardEval.class ).getPlugins() ) {\n                if ( classMap.containsKey(stdClass.getSimpleName()) ) {\n                    evals.add(classMap.get(stdClass.getSimpleName()));\n                }\n            }\n        }\n\n        // Get the specific classes provided.\n        for ( String module : modulesToUse ) {\n            if ( !classMap.containsKey(module) ) {\n                throw new UserException.CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n            }\n\n            if ( classMap.containsKey(module) ) {\n                evals.add(classMap.get(module));\n            }\n        }\n\n        return evals;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private TreeSet<VariantStratifier> initializeStratificationObjects(boolean noStandardStrats, String[] modulesToUse) {\n        TreeSet<VariantStratifier> strats = new TreeSet<VariantStratifier>();\n        Set<String> stratsToUse = new HashSet<String>();\n\n        // Create a map for all stratification modules for easy lookup.\n        HashMap<String, Class<? extends VariantStratifier>> classMap = new HashMap<String, Class<? extends VariantStratifier>>();\n        for ( Class<? extends VariantStratifier> c : new PluginManager<VariantStratifier>( VariantStratifier.class ).getPlugins() ) {\n            classMap.put(c.getSimpleName(), c);\n        }\n\n        // We must use all required stratification modules.\n        for ( Class<? extends RequiredStratification> reqClass : new PluginManager<RequiredStratification>( RequiredStratification.class ).getPlugins() ) {\n            if ( classMap.containsKey(reqClass.getSimpleName()) ) {\n                stratsToUse.add(reqClass.getSimpleName());\n            }\n        }\n\n        // By default, use standard stratification modules.\n        if ( !noStandardStrats ) {\n            for ( Class<? extends StandardStratification> stdClass : new PluginManager<StandardStratification>( StandardStratification.class ).getPlugins() ) {\n                if ( classMap.containsKey(stdClass.getSimpleName()) ) {\n                    stratsToUse.add(stdClass.getSimpleName());\n                }\n            }\n        }\n\n        // Now add the user-selected modules\n        stratsToUse.addAll(Arrays.asList(modulesToUse));\n\n        // Instantiate the stratifications\n        for ( String module : stratsToUse ) {\n            if ( !classMap.containsKey(module) ) {\n                throw new UserException.CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n            }\n\n            if ( classMap.containsKey(module) ) {\n                Class<? extends VariantStratifier> c = classMap.get(module);\n\n                try {\n                    VariantStratifier vs = c.newInstance();\n                    vs.initialize(jexlExpressions, compNames, knownNames, evalNames, sampleNames);\n\n                    strats.add(vs);\n                } catch (InstantiationException e) {\n                    throw new StingException(\"Unable to instantiate stratification module '\" + c.getSimpleName() + \"'\");\n                } catch (IllegalAccessException e) {\n                    throw new StingException(\"Illegal access error when trying to instantiate stratification module '\" + c.getSimpleName() + \"'\");\n                }\n            }\n        }\n\n        return strats;\n    }","id":45403,"modified_method":"/**\n     * Initialize required, standard and user-specified stratification objects\n     *\n     * @param noStandardStrats  don't use the standard stratifications\n     * @param modulesToUse      the list of stratification modules to use\n     * @return  set of stratifications to use\n     */\n    private TreeSet<VariantStratifier> initializeStratificationObjects(boolean noStandardStrats, String[] modulesToUse) {\n        TreeSet<VariantStratifier> strats = new TreeSet<VariantStratifier>();\n        Set<String> stratsToUse = new HashSet<String>();\n\n        // Create a map for all stratification modules for easy lookup.\n        HashMap<String, Class<? extends VariantStratifier>> classMap = new HashMap<String, Class<? extends VariantStratifier>>();\n        for ( Class<? extends VariantStratifier> c : new PluginManager<VariantStratifier>( VariantStratifier.class ).getPlugins() ) {\n            classMap.put(c.getSimpleName(), c);\n        }\n\n        // We must use all required stratification modules.\n        for ( Class<? extends RequiredStratification> reqClass : new PluginManager<RequiredStratification>( RequiredStratification.class ).getPlugins() ) {\n            if ( classMap.containsKey(reqClass.getSimpleName()) ) {\n                stratsToUse.add(reqClass.getSimpleName());\n            }\n        }\n\n        // By default, use standard stratification modules.\n        if ( !noStandardStrats ) {\n            for ( Class<? extends StandardStratification> stdClass : new PluginManager<StandardStratification>( StandardStratification.class ).getPlugins() ) {\n                if ( classMap.containsKey(stdClass.getSimpleName()) ) {\n                    stratsToUse.add(stdClass.getSimpleName());\n                }\n            }\n        }\n\n        // Now add the user-selected modules\n        stratsToUse.addAll(Arrays.asList(modulesToUse));\n\n        // Instantiate the stratifications\n        for ( String module : stratsToUse ) {\n            if ( !classMap.containsKey(module) ) {\n                throw new UserException.CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n            }\n\n            if ( classMap.containsKey(module) ) {\n                Class<? extends VariantStratifier> c = classMap.get(module);\n\n                try {\n                    VariantStratifier vs = c.newInstance();\n                    vs.initialize(jexlExpressions, compNames, knownNames, evalNames, sampleNames);\n\n                    strats.add(vs);\n                } catch (InstantiationException e) {\n                    throw new StingException(\"Unable to instantiate stratification module '\" + c.getSimpleName() + \"'\");\n                } catch (IllegalAccessException e) {\n                    throw new StingException(\"Illegal access error when trying to instantiate stratification module '\" + c.getSimpleName() + \"'\");\n                }\n            }\n        }\n\n        return strats;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toString() {\n        String value = \"\";\n\n        for ( String key : this.keySet() ) {\n            value += \"\\tstate \" + key + \":\" + this.get(key) + \"\\n\";\n        }\n\n        return value;\n    }","id":45404,"modified_method":"public String toString() {\n        String value = \"\";\n\n        for ( String key : this.keySet() ) {\n            //value += \"\\tstate \" + key + \":\" + this.get(key) + \"\\n\";\n            value += String.format(\"%s:%s;\", key, this.get(key));\n        }\n\n        return value;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ArrayList<String> getRelevantStates(ReferenceContext ref, VariantContext comp, VariantContext eval, String sampleName) {\n        return null;\n    }","id":45405,"modified_method":"public ArrayList<String> getRelevantStates(ReferenceContext ref, VariantContext comp, String compName, VariantContext eval, String sampleName) {\n        return null;\n    }","commit_id":"73acfa654a3eb3d7e21e91945739fb8d1ab0452e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void uninstall(String uri, Map<String, Object> attributes) throws BundleException {\n        final Long longId = (Long)attributes.get(KEY_BUNDLE_ID);\n        if(longId == null) {\n            log.debug(\"No {} in metadata, bundle cannot be uninstalled\");\n        } else {\n            final Bundle b = ctx.getBundle(longId.longValue());\n            if(b == null) {\n                log.debug(\"Bundle having id {} not found, cannot uninstall\");\n            } else {\n                synchronized(pendingBundles) {\n                    pendingBundles.remove(new Long(b.getBundleId()));\n                }\n                b.uninstall();\n            }\n        }\n    }","id":45406,"modified_method":"public void uninstall(String uri, Map<String, Object> attributes) throws BundleException {\n        final Long longId = (Long)attributes.get(KEY_BUNDLE_ID);\n        if(longId == null) {\n            log.debug(\"No {} in metadata, bundle cannot be uninstalled\");\n        } else {\n            final Bundle b = ctx.getBundle(longId);\n            if(b == null) {\n                log.debug(\"Bundle having id {} not found, cannot uninstall\");\n            } else {\n                synchronized(pendingBundles) {\n                    pendingBundles.remove(b.getBundleId());\n                }\n                b.uninstall();\n            }\n        }\n    }","commit_id":"f911247b5e3ac01f0fc16003c95b32db45ff1dce","url":"https://github.com/apache/sling"},{"original_method":"public int installOrUpdate(String uri, Map<String, Object> attributes, InputStream data) throws Exception {\n        // Update if we already have a bundle id, else install\n        Bundle b = null;\n        boolean updated = false;\n\n        // check whether we know the bundle and it exists\n        final Long longId = (Long)attributes.get(KEY_BUNDLE_ID);\n        if(longId != null) {\n            b = ctx.getBundle(longId.longValue());\n        }\n\n        // either we don't know the bundle yet or it does not exist,\n        // so check whether the bundle can be found by its symbolic name\n        if (b == null) {\n            // ensure we can mark and reset to read the manifest\n            if (!data.markSupported()) {\n                data = new BufferedInputStream(data);\n            }\n            b = getMatchingBundle(data);\n        }\n        \n        if (b != null) {\n            b.update(data);\n            updated = true;\n        } else {\n            uri = OsgiControllerImpl.getResourceLocation(uri);\n            log.debug(\"No matching Bundle for uri {}, installing\", uri);\n            b = ctx.installBundle(uri, data);\n        }\n        \n        // ensure the bundle id in the attributes, this may be overkill\n        // in simple update situations, but is required for installations\n        // and updates where there are no attributes yet\n        attributes.put(KEY_BUNDLE_ID, new Long(b.getBundleId()));\n\n        synchronized(refreshLock) {\n            packageAdmin.resolveBundles(null);\n            packageAdmin.refreshPackages(null);\n        }\n        \n        synchronized(pendingBundles) {\n            pendingBundles.put(new Long(b.getBundleId()), b);\n        }\n        \n        return updated ? UPDATED : INSTALLED; \n    }","id":45407,"modified_method":"public int installOrUpdate(String uri, Map<String, Object> attributes, InputStream data) throws Exception {\n        // Update if we already have a bundle id, else install\n        Bundle b = null;\n        boolean updated = false;\n\n        // check whether we know the bundle and it exists\n        final Long longId = (Long)attributes.get(KEY_BUNDLE_ID);\n        if(longId != null) {\n            b = ctx.getBundle(longId);\n        }\n\n        // either we don't know the bundle yet or it does not exist,\n        // so check whether the bundle can be found by its symbolic name\n        if (b == null) {\n            // ensure we can mark and reset to read the manifest\n            if (!data.markSupported()) {\n                data = new BufferedInputStream(data);\n            }\n            b = getMatchingBundle(data);\n        }\n\n        if (b != null) {\n            b.update(data);\n            updated = true;\n        } else {\n            uri = OsgiControllerImpl.getResourceLocation(uri);\n            log.debug(\"No matching Bundle for uri {}, installing\", uri);\n            b = ctx.installBundle(uri, data);\n        }\n\n        // ensure the bundle id in the attributes, this may be overkill\n        // in simple update situations, but is required for installations\n        // and updates where there are no attributes yet\n        attributes.put(KEY_BUNDLE_ID, b.getBundleId());\n\n        synchronized(pendingBundles) {\n            pendingBundles.put(b.getBundleId(), b);\n        }\n\n        return updated ? UPDATED : INSTALLED;\n    }","commit_id":"f911247b5e3ac01f0fc16003c95b32db45ff1dce","url":"https://github.com/apache/sling"},{"original_method":"public void processResourceQueue() throws BundleException {\n        \n        if(pendingBundles.isEmpty()) {\n            return;\n        }\n        \n        final List<Long> toRemove = new LinkedList<Long>();\n        final List<Long> idList = new LinkedList<Long>();\n        synchronized(pendingBundles) {\n            for(Long id : pendingBundles.keySet()) {\n                idList.add(id);\n            }\n        }\n        \n        for(Long id : idList) {\n            final Bundle bundle = ctx.getBundle(id.longValue());\n            if(bundle == null) {\n                log.debug(\"Bundle id {} disappeared (bundle removed from framework?), removed from pending bundles queue\");\n                toRemove.add(id);\n                continue;\n            }\n            final int state = bundle.getState();\n            \n            if(bundle == null) {\n                log.debug(\"Bundle id {} not found in processResourceQueue(), removed from pending bundles queue\");\n                toRemove.add(id);\n                \n            } else if ((state & Bundle.ACTIVE) > 0) {\n                log.info(\"Bundle {} is active, removed from pending bundles queue\", bundle.getLocation());\n                toRemove.add(id);\n            \n            } else if ((state & Bundle.STARTING) > 0) {\n                log.info(\"Bundle {} is starting.\", bundle.getLocation());\n                \n            } else if ((state & Bundle.STOPPING) > 0) {\n                log.info(\"Bundle {} is stopping.\", bundle.getLocation());\n                \n            } else if ((state & Bundle.UNINSTALLED) > 0) {\n                log.info(\"Bundle {} is uninstalled, removed from pending bundles queue\", bundle.getLocation());\n                toRemove.add(id);\n                \n            } else if ((state & Bundle.RESOLVED) > 0) {\n                log.info(\"Bundle {} is resolved, trying to start it.\", bundle.getLocation());\n                bundle.start();\n                synchronized(refreshLock) {\n                    packageAdmin.resolveBundles(null);\n                    packageAdmin.refreshPackages(null);\n                }\n\n            } else if ((state & Bundle.INSTALLED) > 0) {\n                log.debug(\"Bundle {} is installed but not resolved.\", bundle.getLocation());\n            }\n        }\n        \n        synchronized(pendingBundles) {\n            for(Long id : toRemove) {\n                pendingBundles.remove(id);\n            }\n        }\n    }","id":45408,"modified_method":"public void processResourceQueue() {\n\n        if(pendingBundles.isEmpty()) {\n            return;\n        }\n\n        final List<Long> toRemove = new LinkedList<Long>();\n        final List<Long> idList = new LinkedList<Long>();\n        synchronized(pendingBundles) {\n            idList.addAll(pendingBundles.keySet());\n        }\n\n        for(Long id : idList) {\n            final Bundle bundle = ctx.getBundle(id);\n            if(bundle == null) {\n                log.debug(\"Bundle id {} disappeared (bundle removed from framework?), removed from pending bundles queue\");\n                toRemove.add(id);\n                continue;\n            }\n            final int state = bundle.getState();\n\n            switch ( state ) {\n                case Bundle.ACTIVE :\n                    log.info(\"Bundle {} is active, removed from pending bundles queue\", bundle.getLocation());\n                    toRemove.add(id);\n                    break;\n                case Bundle.STARTING :\n                    log.info(\"Bundle {} is starting.\", bundle.getLocation());\n                    break;\n                case Bundle.STOPPING :\n                    log.info(\"Bundle {} is stopping.\", bundle.getLocation());\n                    break;\n                case Bundle.UNINSTALLED :\n                    log.info(\"Bundle {} is uninstalled, removed from pending bundles queue\", bundle.getLocation());\n                    toRemove.add(id);\n                    break;\n                case Bundle.INSTALLED :\n                    log.debug(\"Bundle {} is installed but not resolved.\", bundle.getLocation());\n                    if ( !packageAdmin.resolveBundles(new Bundle[] {bundle}) ) {\n                        log.debug(\"Bundle {} is installed, failed to resolve.\", bundle.getLocation());\n                        break;\n                    }\n                    // fall through to RESOLVED to start the bundle\n                case Bundle.RESOLVED :\n                    log.info(\"Bundle {} is resolved, trying to start it.\", bundle.getLocation());\n                    try {\n                        bundle.start();\n                    } catch (BundleException e) {\n                        log.error(\"Exception during bundle start of Bundle \" + bundle.getLocation(), e);\n                    }\n                    break;\n            }\n        }\n\n        synchronized(refreshLock) {\n            packageAdmin.refreshPackages(null);\n        }\n\n        synchronized(pendingBundles) {\n            pendingBundles.keySet().removeAll(toRemove);\n        }\n    }","commit_id":"f911247b5e3ac01f0fc16003c95b32db45ff1dce","url":"https://github.com/apache/sling"},{"original_method":"public void serviceChanged(ServiceEvent event)\n    {\n        Bundle bundle = event.getServiceReference().getBundle();\n        if ((bundle != null)\n            && (bundle.getState() == Bundle.ACTIVE && event.getType() != ServiceEvent.MODIFIED))\n        {\n            synchronized (this)\n            {\n                removeBundle(bundle, m_logger);\n                addBundle(bundle, m_logger);\n                m_snapshotTimeStamp = System.currentTimeMillis();\n            }\n        }\n    }","id":45409,"modified_method":"public void serviceChanged(ServiceEvent event)\n    {\n        Bundle bundle = event.getServiceReference().getBundle();\n        if ((bundle != null)\n            && (bundle.getState() == Bundle.ACTIVE && event.getType() != ServiceEvent.MODIFIED))\n        {\n            synchronized (this)\n            {\n                removeBundle(bundle);\n                addBundle(bundle);\n                m_snapshotTimeStamp = System.currentTimeMillis();\n            }\n        }\n    }","commit_id":"dae07bfabca7c1c63b6a89ddfaa129e5c4054848","url":"https://github.com/apache/felix"},{"original_method":"public synchronized Resource[] getResources()\n    {\n        return (Resource[]) m_localResourceList.values().toArray(new Resource[m_localResourceList.size()]);\n    }","id":45410,"modified_method":"public synchronized Resource[] getResources()\n    {\n        return m_localResourceList.values().toArray(new Resource[m_localResourceList.size()]);\n    }","commit_id":"dae07bfabca7c1c63b6a89ddfaa129e5c4054848","url":"https://github.com/apache/felix"},{"original_method":"private void addBundle(Bundle bundle, Logger logger)\n    {\n        /*\n         * Concurrency note: This method MUST be called in a context which\n         * is synchronized on this instance to prevent data structure\n         * corruption.\n         */\n\n        // Ignore system bundle\n        if (bundle.getBundleId() == 0)\n        {\n            return;\n        }\n        try\n        {\n            m_localResourceList.put(new Long(bundle.getBundleId()), new LocalResourceImpl(bundle));\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // This should never happen since we are generating filters,\n            // but ignore the resource if it does occur.\n            m_logger.log(Logger.LOG_WARNING, ex.getMessage(), ex);\n        }\n    }","id":45411,"modified_method":"private void addBundle(Bundle bundle)\n    {\n        /*\n         * Concurrency note: This method MUST be called in a context which\n         * is synchronized on this instance to prevent data structure\n         * corruption.\n         */\n\n        // Ignore system bundle\n        if (bundle.getBundleId() == 0)\n        {\n            return;\n        }\n        m_localResourceList.put(bundle.getBundleId(), new LazyLocalResourceImpl(bundle, m_logger));\n    }","commit_id":"dae07bfabca7c1c63b6a89ddfaa129e5c4054848","url":"https://github.com/apache/felix"},{"original_method":"public void bundleChanged(BundleEvent event)\n    {\n        if (event.getType() == BundleEvent.INSTALLED)\n        {\n            synchronized (this)\n            {\n                addBundle(event.getBundle(), m_logger);\n                m_snapshotTimeStamp = System.currentTimeMillis();\n            }\n        }\n        else if (event.getType() == BundleEvent.UNINSTALLED)\n        {\n            synchronized (this)\n            {\n                removeBundle(event.getBundle(), m_logger);\n                m_snapshotTimeStamp = System.currentTimeMillis();\n            }\n        }\n    }","id":45412,"modified_method":"public void bundleChanged(BundleEvent event)\n    {\n        if (event.getType() == BundleEvent.INSTALLED)\n        {\n            synchronized (this)\n            {\n                addBundle(event.getBundle());\n                m_snapshotTimeStamp = System.currentTimeMillis();\n            }\n        }\n        else if (event.getType() == BundleEvent.UNINSTALLED)\n        {\n            synchronized (this)\n            {\n                removeBundle(event.getBundle());\n                m_snapshotTimeStamp = System.currentTimeMillis();\n            }\n        }\n    }","commit_id":"dae07bfabca7c1c63b6a89ddfaa129e5c4054848","url":"https://github.com/apache/felix"},{"original_method":"private void initialize()\n    {\n        // register for bundle and service events now\n        m_context.addBundleListener(this);\n        m_context.addServiceListener(this);\n\n        // Generate the resource list from the set of installed bundles.\n        // Lock so we can ensure that no bundle events arrive before we\n        // are done getting our state snapshot.\n        Bundle[] bundles;\n        synchronized (this)\n        {\n            // Create a local resource object for each bundle, which will\n            // convert the bundle headers to the appropriate resource metadata.\n            bundles = m_context.getBundles();\n            for (int i = 0; (bundles != null) && (i < bundles.length); i++)\n            {\n                addBundle(bundles[i], m_logger);\n            }\n\n            m_snapshotTimeStamp = System.currentTimeMillis();\n        }\n    }","id":45413,"modified_method":"private void initialize()\n    {\n        // register for bundle and service events now\n        m_context.addBundleListener(this);\n        m_context.addServiceListener(this);\n\n        // Generate the resource list from the set of installed bundles.\n        // Lock so we can ensure that no bundle events arrive before we\n        // are done getting our state snapshot.\n        Bundle[] bundles;\n        synchronized (this)\n        {\n            // Create a local resource object for each bundle, which will\n            // convert the bundle headers to the appropriate resource metadata.\n            bundles = m_context.getBundles();\n            for (int i = 0; (bundles != null) && (i < bundles.length); i++)\n            {\n                addBundle(bundles[i]);\n            }\n\n            m_snapshotTimeStamp = System.currentTimeMillis();\n        }\n    }","commit_id":"dae07bfabca7c1c63b6a89ddfaa129e5c4054848","url":"https://github.com/apache/felix"},{"original_method":"private void removeBundle(Bundle bundle, Logger logger)\n    {\n        /*\n         * Concurrency note: This method MUST be called in a context which\n         * is synchronized on this instance to prevent data structure\n         * corruption.\n         */\n\n        m_localResourceList.remove(new Long(bundle.getBundleId()));\n    }","id":45414,"modified_method":"private void removeBundle(Bundle bundle)\n    {\n        /*\n         * Concurrency note: This method MUST be called in a context which\n         * is synchronized on this instance to prevent data structure\n         * corruption.\n         */\n\n        m_localResourceList.remove(bundle.getBundleId());\n    }","commit_id":"dae07bfabca7c1c63b6a89ddfaa129e5c4054848","url":"https://github.com/apache/felix"},{"original_method":"public boolean pollerCheckingIn(int locationMonitorId, Date currentConfigurationVersion) {\n        OnmsLocationMonitor mon = m_locMonDao.get(locationMonitorId);\n        if (mon == null) {\n            return false;\n        }\n        mon.setLastCheckInTime(m_timeKeeper.getCurrentDate());\n        m_locMonDao.update(mon);\n        return m_configurationTimestamp.after(currentConfigurationVersion);\n    }","id":45415,"modified_method":"public boolean pollerCheckingIn(int locationMonitorId, Date currentConfigurationVersion) {\n        OnmsLocationMonitor mon = m_locMonDao.get(locationMonitorId);\n        if (mon == null) {\n            return false;\n        }\n        mon.setStatus(MonitorStatus.STARTED);\n        mon.setLastCheckInTime(m_timeKeeper.getCurrentDate());\n        m_locMonDao.update(mon);\n        return m_configurationTimestamp.after(currentConfigurationVersion);\n    }","commit_id":"dec74ad8b71acfcb91e870281b3ae609d9a3d6ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void main(String[] args) {\n        \n\t\tString[] configs = {\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-remotePollerBackEnd.xml\",\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-pollerFrontEnd.xml\"\n\t\t};\n\t\t\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(configs);\n        PollerFrontEnd frontEnd = (PollerFrontEnd) ctx.getBean(\"pollerFrontEnd\");\n\n        \n        if (frontEnd.isRegistered()) {\n            System.err.println(\"FrontEnd is registered\");\n        } else {\n            System.err.println(\"FrontEnd is NOT registered\");\n        }\n\n\t}","id":45416,"modified_method":"public static void main(String[] args) {\n        \n\t\tString[] configs = {\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-remotePollerBackEnd.xml\",\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-pollerFrontEnd.xml\"\n\t\t};\n\t\t\n        final ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(configs);\n        final PollerFrontEnd frontEnd = (PollerFrontEnd) ctx.getBean(\"pollerFrontEnd\");\n\n        \n        Thread shutdownHook = new Thread() {\n            public void run() {\n                frontEnd.stop();\n                ctx.close();\n            }\n        };\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n\n        if (!frontEnd.isRegistered()) {\n            System.err.println(\"FrontEnd is NOT registered\");\n            if (args.length < 1) {\n                usage();\n            }\n            \n            frontEnd.register(args[0]);\n        }    \n                \n\n\t}","commit_id":"dec74ad8b71acfcb91e870281b3ae609d9a3d6ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean pollerCheckingIn(int locationMonitorId, Date currentConfigurationVersion) {\n        OnmsLocationMonitor mon = m_locMonDao.get(locationMonitorId);\n        if (mon == null) {\n            return false;\n        }\n        mon.setLastCheckInTime(m_timeKeeper.getCurrentDate());\n        m_locMonDao.update(mon);\n        return m_configurationTimestamp.after(currentConfigurationVersion);\n    }","id":45417,"modified_method":"public boolean pollerCheckingIn(int locationMonitorId, Date currentConfigurationVersion) {\n        OnmsLocationMonitor mon = m_locMonDao.get(locationMonitorId);\n        if (mon == null) {\n            return false;\n        }\n        mon.setStatus(MonitorStatus.STARTED);\n        mon.setLastCheckInTime(m_timeKeeper.getCurrentDate());\n        m_locMonDao.update(mon);\n        return m_configurationTimestamp.after(currentConfigurationVersion);\n    }","commit_id":"4aa7fa2359ca5626a89ab47bb83832febc1d274e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void main(String[] args) {\n        \n\t\tString[] configs = {\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-remotePollerBackEnd.xml\",\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-pollerFrontEnd.xml\"\n\t\t};\n\t\t\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(configs);\n        PollerFrontEnd frontEnd = (PollerFrontEnd) ctx.getBean(\"pollerFrontEnd\");\n\n        \n        if (frontEnd.isRegistered()) {\n            System.err.println(\"FrontEnd is registered\");\n        } else {\n            System.err.println(\"FrontEnd is NOT registered\");\n        }\n\n\t}","id":45418,"modified_method":"public static void main(String[] args) {\n        \n\t\tString[] configs = {\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-remotePollerBackEnd.xml\",\n\t\t\t\t\"classpath:/META-INF/opennms/applicationContext-pollerFrontEnd.xml\"\n\t\t};\n\t\t\n        final ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(configs);\n        final PollerFrontEnd frontEnd = (PollerFrontEnd) ctx.getBean(\"pollerFrontEnd\");\n\n        \n        Thread shutdownHook = new Thread() {\n            public void run() {\n                frontEnd.stop();\n                ctx.close();\n            }\n        };\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n\n        if (!frontEnd.isRegistered()) {\n            System.err.println(\"FrontEnd is NOT registered\");\n            if (args.length < 1) {\n                usage();\n            }\n            \n            frontEnd.register(args[0]);\n        }    \n                \n\n\t}","commit_id":"4aa7fa2359ca5626a89ab47bb83832febc1d274e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Handles the un-registration of a <tt>ProtocolProviderService<\/tt>.\n     * Removes the given <tt>protocolProvider<\/tt> from the list of queried\n     * providers.\n     *\n     * @param protocolProvider the <tt>ProtocolProviderService<\/tt> to remove\n     */\n    private static void handleProviderRemoved(\n            ProtocolProviderService protocolProvider)\n    {\n        if (phoneProviders.contains(protocolProvider))\n            phoneProviders.remove(protocolProvider);\n    }","id":45419,"modified_method":"/**\n     * Handles the un-registration of a <tt>ProtocolProviderService<\/tt>.\n     * Removes the given <tt>protocolProvider<\/tt> from the list of queried\n     * providers.\n     *\n     * @param protocolProvider the <tt>ProtocolProviderService<\/tt> to remove\n     */\n    private static void handleProviderRemoved(\n            ProtocolProviderService protocolProvider)\n    {\n        if (phoneProviders.contains(protocolProvider))\n            phoneProviders.remove(protocolProvider);\n\n        protocolProvider.removeRegistrationStateChangeListener(ppRegListener);\n    }","commit_id":"3064b44caec3ed1a68bbe3459c58c21861fd8ff1","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the registration of a new <tt>ProtocolProviderService<\/tt>. Adds\n     * the given <tt>protocolProvider<\/tt> to the list of queried providers.\n     *\n     * @param protocolProvider the <tt>ProtocolProviderService<\/tt> to add\n     */\n    private static void handleProviderAdded(\n            ProtocolProviderService protocolProvider)\n    {\n        if (protocolProvider.getOperationSet(\n                OperationSetServerStoredContactInfo.class) != null\n            && protocolProvider.isRegistered()\n            && !phoneProviders.contains(protocolProvider))\n        {\n            phoneProviders.add(protocolProvider);\n        }\n    }","id":45420,"modified_method":"/**\n     * Handles the registration of a new <tt>ProtocolProviderService<\/tt>. Adds\n     * the given <tt>protocolProvider<\/tt> to the list of queried providers.\n     *\n     * @param protocolProvider the <tt>ProtocolProviderService<\/tt> to add\n     */\n    private static void handleProviderAdded(\n            ProtocolProviderService protocolProvider)\n    {\n        if (protocolProvider.getOperationSet(\n                OperationSetServerStoredContactInfo.class) != null\n            && !phoneProviders.contains(protocolProvider))\n        {\n            if(protocolProvider.isRegistered())\n            {\n                phoneProviders.add(protocolProvider);\n            }\n            else\n            {\n                protocolProvider.addRegistrationStateChangeListener(\n                    ppRegListener);\n            }\n        }\n    }","commit_id":"3064b44caec3ed1a68bbe3459c58c21861fd8ff1","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a list of all currently registered server stored contact info\n     * providers.\n     *\n     * @return a list of all currently registered server stored contact info\n     * providers\n     */\n    public static List<ProtocolProviderService> getPhoneNumberProviders()\n    {\n        if (phoneProviders != null)\n            return phoneProviders;\n\n        phoneProviders = new LinkedList<ProtocolProviderService>();\n\n        bundleContext.addServiceListener(new ProtocolProviderRegListener());\n\n        ServiceReference[] serRefs = null;\n        try\n        {\n            // get all registered provider factories\n            serRefs\n                = bundleContext.getServiceReferences(\n                        ProtocolProviderFactory.class.getName(),\n                        null);\n        }\n        catch (InvalidSyntaxException e)\n        {\n            logger.error(\"LoginManager : \" + e);\n        }\n\n        if (serRefs != null)\n        {\n            for (ServiceReference serRef : serRefs)\n            {\n                ProtocolProviderFactory providerFactory\n                    = (ProtocolProviderFactory)\n                        bundleContext.getService(serRef);\n\n                ProtocolProviderService protocolProvider;\n\n                for (AccountID accountID\n                        : providerFactory.getRegisteredAccounts())\n                {\n                    serRef = providerFactory.getProviderForAccount(accountID);\n\n                    protocolProvider\n                        = (ProtocolProviderService) bundleContext\n                            .getService(serRef);\n\n                    handleProviderAdded(protocolProvider);\n                }\n            }\n        }\n        return phoneProviders;\n    }","id":45421,"modified_method":"/**\n     * Returns a list of all currently registered server stored contact info\n     * providers.\n     *\n     * @return a list of all currently registered server stored contact info\n     * providers\n     */\n    public static List<ProtocolProviderService> getPhoneNumberProviders()\n    {\n        if (phoneProviders != null)\n            return phoneProviders;\n\n        phoneProviders = new LinkedList<ProtocolProviderService>();\n\n        ppRegListener = new ProtocolProviderRegistrationListener();\n\n        bundleContext.addServiceListener(\n            new ProtocolProviderServiceRegListener());\n\n        ServiceReference[] serRefs = null;\n        try\n        {\n            // get all registered provider factories\n            serRefs\n                = bundleContext.getServiceReferences(\n                        ProtocolProviderFactory.class.getName(),\n                        null);\n        }\n        catch (InvalidSyntaxException e)\n        {\n            logger.error(\"LoginManager : \" + e);\n        }\n\n        if (serRefs != null)\n        {\n            for (ServiceReference serRef : serRefs)\n            {\n                ProtocolProviderFactory providerFactory\n                    = (ProtocolProviderFactory)\n                        bundleContext.getService(serRef);\n\n                ProtocolProviderService protocolProvider;\n\n                for (AccountID accountID\n                        : providerFactory.getRegisteredAccounts())\n                {\n                    serRef = providerFactory.getProviderForAccount(accountID);\n\n                    protocolProvider\n                        = (ProtocolProviderService) bundleContext\n                            .getService(serRef);\n\n                    handleProviderAdded(protocolProvider);\n                }\n            }\n        }\n        return phoneProviders;\n    }","commit_id":"3064b44caec3ed1a68bbe3459c58c21861fd8ff1","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public void doRun() {\n        verifyIndices();\n\n        // Poll queue forever.\n        while(true) {\n            List<DeadLetter> items;\n            try {\n                items = messages.getDeadLetterQueue().take();\n            } catch (InterruptedException ignored) { continue; /* daemon thread */ }\n\n            for (DeadLetter item : items) {\n                boolean written = false;\n\n                // Try to write the failed message to MongoDB if enabled.\n                if (configuration.isDeadLettersEnabled()) {\n                    try {\n                        Message message = item.getMessage();\n\n                        Map<String, Object> doc = Maps.newHashMap();\n                        doc.put(\"letter_id\", item.getId());\n                        doc.put(\"timestamp\", Tools.iso8601());\n                        doc.put(\"message\", message.toElasticSearchObject());\n\n                        PersistedDeadLetter persistedDeadLetter = new PersistedDeadLetterImpl(doc);\n                        persistedDeadLetterService.saveWithoutValidation(persistedDeadLetter);\n                        written = true;\n                    } catch(Exception e) {\n                        LOG.error(\"Could not write message to dead letter queue.\", e);\n                    }\n                }\n\n                // Write failure to index_failures.\n                try {\n                    BulkItemResponse.Failure f = item.getFailure().getFailure();\n\n                    Map<String, Object> doc = Maps.newHashMap();\n                    doc.put(\"letter_id\", item.getId());\n                    doc.put(\"index\", f.getIndex());\n                    doc.put(\"type\", f.getType());\n                    doc.put(\"message\", f.getMessage());\n                    doc.put(\"timestamp\", item.getTimestamp());\n                    doc.put(\"written\", written);\n\n                    IndexFailure indexFailure = new IndexFailureImpl(doc);\n                    indexFailureService.saveWithoutValidation(indexFailure);\n                } catch(Exception e) {\n                    LOG.error(\"Could not persist index failure.\", e);\n                }\n            }\n        }\n    }","id":45422,"modified_method":"@Override\n    public void doRun() {\n        verifyIndices();\n\n        // Poll queue forever.\n        while(true) {\n            List<DeadLetter> items;\n            try {\n                items = messages.getDeadLetterQueue().take();\n            } catch (InterruptedException ignored) { continue; /* daemon thread */ }\n\n            for (DeadLetter item : items) {\n                boolean written = false;\n\n                // Try to write the failed message to MongoDB if enabled.\n                if (configuration.isDeadLettersEnabled()) {\n                    try {\n                        Message message = item.getMessage();\n                        PersistedDeadLetter persistedDeadLetter = persistedDeadLetterService.create(item.getId(), Tools.iso8601(), message.toElasticSearchObject());\n                        persistedDeadLetterService.saveWithoutValidation(persistedDeadLetter);\n                        written = true;\n                    } catch(Exception e) {\n                        LOG.error(\"Could not write message to dead letter queue.\", e);\n                    }\n                }\n\n                // Write failure to index_failures.\n                try {\n                    BulkItemResponse.Failure f = item.getFailure().getFailure();\n\n                    Map<String, Object> doc = Maps.newHashMap();\n                    doc.put(\"letter_id\", item.getId());\n                    doc.put(\"index\", f.getIndex());\n                    doc.put(\"type\", f.getType());\n                    doc.put(\"message\", f.getMessage());\n                    doc.put(\"timestamp\", item.getTimestamp());\n                    doc.put(\"written\", written);\n\n                    IndexFailure indexFailure = new IndexFailureImpl(doc);\n                    indexFailureService.saveWithoutValidation(indexFailure);\n                } catch(Exception e) {\n                    LOG.error(\"Could not persist index failure.\", e);\n                }\n            }\n        }\n    }","commit_id":"8a837f4cd5ebca11669297e2861f1577dd39132c","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static AlarmCallbackHistory create(String id,\n                                              AlarmCallbackConfiguration alarmCallbackConfiguration,\n                                              Alert alert,\n                                              AlertCondition alertCondition,\n                                              AlarmCallbackResult result,\n                                              DateTime createdAt) {\n        return new AutoValue_AlarmCallbackHistoryImpl(id, alarmCallbackConfiguration.getId(), alert.getId(), alertCondition.getId(), result, createdAt);\n    }","id":45423,"modified_method":"public static AlarmCallbackHistory create(String id,\n                                              AlarmCallbackConfiguration alarmCallbackConfiguration,\n                                              Alert alert,\n                                              AlertCondition alertCondition,\n                                              AlarmCallbackResult result,\n                                              DateTime createdAt) {\n        final AlarmCallbackSummary alarmCallbackSummary = AlarmCallbackSummary.create(\n                alarmCallbackConfiguration.getId(),\n                alarmCallbackConfiguration.getStreamId(),\n                alarmCallbackConfiguration.getType(),\n                alarmCallbackConfiguration.getConfiguration(),\n                alarmCallbackConfiguration.getCreatedAt(),\n                alarmCallbackConfiguration.getCreatorUserId()\n        );\n        return create(id, alarmCallbackSummary, alert.getId(), alertCondition.getId(), result, createdAt);\n    }","commit_id":"b733e97e72405e90b346b3a1bca1b3182547ad8c","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static AlarmCallbackHistory create(String id,\n                                              AlarmCallbackConfiguration alarmCallbackConfiguration,\n                                              Alert alert,\n                                              AlertCondition alertCondition,\n                                              AlarmCallbackResult result) {\n        return new AutoValue_AlarmCallbackHistoryImpl(id, alarmCallbackConfiguration.getId(), alert.getId(), alertCondition.getId(), result, Tools.iso8601());\n    }","id":45424,"modified_method":"public static AlarmCallbackHistory create(String id,\n                                              AlarmCallbackConfiguration alarmCallbackConfiguration,\n                                              Alert alert,\n                                              AlertCondition alertCondition,\n                                              AlarmCallbackResult result) {\n        return create(id, alarmCallbackConfiguration, alert, alertCondition, result, Tools.iso8601());\n    }","commit_id":"b733e97e72405e90b346b3a1bca1b3182547ad8c","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@JsonProperty(FIELD_ALARMCALLBACKCONFIGURATIONID)\n    @Override\n    public abstract String alarmcallbackConfigurationId();","id":45425,"modified_method":"@JsonProperty(FIELD_ALARMCALLBACKCONFIGURATIONID)\n    @Override\n    public abstract AlarmCallbackSummary alarmcallbackConfiguration();","commit_id":"b733e97e72405e90b346b3a1bca1b3182547ad8c","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@JsonProperty(\"alarmcallbackconfiguration_id\")\n    public abstract String alarmcallbackConfigurationId();","id":45426,"modified_method":"@JsonProperty(\"alarmcallbackconfiguration\")\n    public abstract AlarmCallbackSummary alarmcallbackConfiguration();","commit_id":"b733e97e72405e90b346b3a1bca1b3182547ad8c","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Long extractLongValue(Object value) {\n        Object extractedValue = expression.getValue(value);\n        setIndexType(extractedValue);\n        if (extractedValue == null) {\n            return Long.MIN_VALUE;\n        } else {\n            returnType = getIndexType(extractedValue.getClass());\n            if (!checkedStrength) {\n                if (extractedValue instanceof Boolean || extractedValue instanceof Number) {\n                    strong = true;\n                }\n                checkedStrength = true;\n            }\n            return getLongValueByType(extractedValue);\n        }\n    }","id":45427,"modified_method":"public Long extractLongValue(Object value) {\n        Object extractedValue = expression.getValue(value);\n        setReturnType(extractedValue);\n        if (extractedValue == null) {\n            return Long.MIN_VALUE;\n        } else {\n            setReturnType(getIndexType(extractedValue.getClass()));\n            if (!checkedStrength) {\n                if (extractedValue instanceof Boolean || extractedValue instanceof Number) {\n                    strong = true;\n                }\n                checkedStrength = true;\n            }\n            return getLongValueByType(extractedValue);\n        }\n    }","commit_id":"42627a464eac6fd373ab45cf8829640c57181ff9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void setIndexType(Object extractedValue) {\n        if (returnType == -1) {\n            if (expression instanceof Predicates.GetExpressionImpl) {\n                Predicates.GetExpressionImpl ex = (Predicates.GetExpressionImpl) expression;\n                returnType = getIndexType(ex.getter.getReturnType());\n            } else {\n                if (extractedValue == null) throw new RuntimeException(\"Indexed value cannot be null!\");\n                returnType = getIndexType(extractedValue.getClass());\n            }\n        }\n        System.out.println(\"return type is \" + returnType);\n    }","id":45428,"modified_method":"void setReturnType(Object extractedValue) {\n        if (returnType == -1) {\n            if (expression instanceof Predicates.GetExpressionImpl) {\n                Predicates.GetExpressionImpl ex = (Predicates.GetExpressionImpl) expression;\n                setReturnType(getIndexType(ex.getter.getReturnType()));\n            } else {\n                if (extractedValue == null) throw new RuntimeException(\"Indexed value cannot be null!\");\n                setReturnType(getIndexType(extractedValue.getClass()));\n            }\n        }\n    }","commit_id":"42627a464eac6fd373ab45cf8829640c57181ff9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void index(Long newValue, Record record) {\n        if (expression != null && returnType == -1) {\n            returnType = record.getIndexTypes()[attributeIndex];\n        }\n        final Long recordId = record.getId();\n        Long oldValue = recordValues.get(recordId);\n        if (record.isActive()) {\n            // add or update\n            if (oldValue == null) {\n                // record is new\n                newRecordIndex(newValue, record);\n            } else if (!oldValue.equals(newValue)) {\n                // record is updated\n                removeRecordIndex(oldValue, recordId);\n                newRecordIndex(newValue, record);\n            }\n        } else {\n            // remove the index\n            if (oldValue != null) {\n                removeRecordIndex(oldValue, recordId);\n            }\n            recordValues.remove(recordId);\n        }\n    }","id":45429,"modified_method":"public void index(Long newValue, Record record) {\n        if (expression != null && returnType == -1) {\n            setReturnType(record.getIndexTypes()[attributeIndex]);\n        }\n        final Long recordId = record.getId();\n        Long oldValue = recordValues.get(recordId);\n        if (record.isActive()) {\n            // add or update\n            if (oldValue == null) {\n                // record is new\n                newRecordIndex(newValue, record);\n            } else if (!oldValue.equals(newValue)) {\n                // record is updated\n                removeRecordIndex(oldValue, recordId);\n                newRecordIndex(newValue, record);\n            }\n        } else {\n            // remove the index\n            if (oldValue != null) {\n                removeRecordIndex(oldValue, recordId);\n            }\n            recordValues.remove(recordId);\n        }\n    }","commit_id":"42627a464eac6fd373ab45cf8829640c57181ff9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void getSubRecords(MultiResultSet results, PredicateType predicateType, Long searchedValue) {\n        Set<Long> values = mapRecords.keySet();\n        for (Long value : values) {\n            boolean valid = false;\n            if (doubleValue && (searchedValue < 0 && value < 0)) {\n                switch (predicateType) {\n                    case LESSER:\n                        valid = value > searchedValue;\n                        break;\n                    case LESSER_EQUAL:\n                        valid = value >= searchedValue;\n                        break;\n                    case GREATER:\n                        valid = value < searchedValue;\n                        break;\n                    case GREATER_EQUAL:\n                        valid = value <= searchedValue;\n                        break;\n                    case NOT_EQUAL:\n                        valid = value.longValue() != searchedValue.longValue();\n                        break;\n                }\n            } else {\n                switch (predicateType) {\n                    case LESSER:\n                        valid = value < searchedValue;\n                        break;\n                    case LESSER_EQUAL:\n                        valid = value <= searchedValue;\n                        break;\n                    case GREATER:\n                        valid = value > searchedValue;\n                        break;\n                    case GREATER_EQUAL:\n                        valid = value >= searchedValue;\n                        break;\n                    case NOT_EQUAL:\n                        valid = value.longValue() != searchedValue.longValue();\n                        break;\n                }\n            }\n            if (valid) {\n                ConcurrentMap<Long, Record> records = mapRecords.get(value);\n                if (records != null) {\n                    results.addResultSet(value, records.values());\n                }\n            }\n        }\n    }","id":45430,"modified_method":"public void getSubRecords(MultiResultSet results, PredicateType predicateType, Long searchedValue) {\n        Set<Long> values = mapRecords.keySet();\n        for (Long value : values) {\n            boolean valid = false;\n            if (doubleValue) {\n                double v = Double.longBitsToDouble(value);\n                double searchedV = Double.longBitsToDouble(searchedValue);\n                switch (predicateType) {\n                    case LESSER:\n                        valid = v < searchedV;\n                        break;\n                    case LESSER_EQUAL:\n                        valid = v <= searchedV;\n                        break;\n                    case GREATER:\n                        valid = v > searchedV;\n                        break;\n                    case GREATER_EQUAL:\n                        valid = v >= searchedV;\n                        break;\n                    case NOT_EQUAL:\n                        valid = v != searchedV;\n                        break;\n                }\n            }\n            switch (predicateType) {\n                case LESSER:\n                    valid = value < searchedValue;\n                    break;\n                case LESSER_EQUAL:\n                    valid = value <= searchedValue;\n                    break;\n                case GREATER:\n                    valid = value > searchedValue;\n                    break;\n                case GREATER_EQUAL:\n                    valid = value >= searchedValue;\n                    break;\n                case NOT_EQUAL:\n                    valid = value.longValue() != searchedValue.longValue();\n                    break;\n            }\n            if (valid) {\n                ConcurrentMap<Long, Record> records = mapRecords.get(value);\n                if (records != null) {\n                    results.addResultSet(value, records.values());\n                }\n            }\n        }\n    }","commit_id":"42627a464eac6fd373ab45cf8829640c57181ff9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@NotNull\n  @Override\n  public List<? extends VcsCommitMetadata> readFirstBlock(@NotNull VirtualFile root, boolean ordered, int commitCount) throws VcsException {\n    if (!isRepositoryReady(root)) {\n      return Collections.emptyList();\n    }\n\n    String[] params = ArrayUtil.mergeArrays(ArrayUtil.toStringArray(GitHistoryUtils.LOG_ALL), \"--encoding=UTF-8\", \"--full-history\",\n                                            \"--sparse\", \"--max-count=\" + commitCount);\n    if (ordered) {\n      params = ArrayUtil.append(params, \"--date-order\");\n    }\n    return GitHistoryUtils.loadMetadata(myProject, root, params);\n  }","id":45431,"modified_method":"@NotNull\n  @Override\n  public List<? extends VcsCommitMetadata> readFirstBlock(@NotNull VirtualFile root, @NotNull Requirements requirements) throws VcsException {\n    if (!isRepositoryReady(root)) {\n      return Collections.emptyList();\n    }\n\n    int commitCount = requirements.getCommitCount();\n    if (requirements.isOrdered()) {\n      commitCount *= 2; // need to query more to sort them manually; git log performance is equal for -1000 and -2000\n    }\n    String[] params = ArrayUtil.mergeArrays(ArrayUtil.toStringArray(GitHistoryUtils.LOG_ALL), \"--encoding=UTF-8\", \"--full-history\",\n                                            \"--sparse\", \"--max-count=\" + commitCount);\n\n    List<? extends VcsCommitMetadata> firstBlock = GitHistoryUtils.loadMetadata(myProject, root, params);\n    if (requirements.isOrdered()) {\n      firstBlock = VcsLogSorter.sortByDateTopoOrder(firstBlock);\n      firstBlock = new ArrayList<VcsCommitMetadata>(firstBlock.subList(0, Math.min(firstBlock.size(), requirements.getCommitCount())));\n    }\n    return firstBlock;\n  }","commit_id":"096155f75a67060ebf1aa180786b2f2ea6c0a3c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public List<? extends VcsCommitMetadata> readFirstBlock(@NotNull VirtualFile root,\n                                                          boolean ordered, int commitCount) throws VcsException {\n    return HgHistoryUtil.loadMetadata(myProject, root, commitCount,\n                                      ordered ? Collections.<String>emptyList() : Arrays.asList(\"-r\", \"0:tip\"));\n  }","id":45432,"modified_method":"@NotNull\n  @Override\n  public List<? extends VcsCommitMetadata> readFirstBlock(@NotNull VirtualFile root,\n                                                          @NotNull Requirements requirements) throws VcsException {\n    return HgHistoryUtil.loadMetadata(myProject, root, requirements.getCommitCount(),\n                                      requirements.isOrdered() ? Collections.<String>emptyList() : Arrays.asList(\"-r\", \"0:tip\"));\n  }","commit_id":"096155f75a67060ebf1aa180786b2f2ea6c0a3c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Queries the given number of commits (per each root) from the VCS, already sorted, and substitutes the \"top commits\" set by them.\n   * This is done initially, and when more commit details is needed.\n   * <p/>\n   * The whole log data is substituted with the retrieved part of the log only if it hasn't been loaded yet.\n   * Otherwise the previous log data is reused, and only top commits are substituted.\n   * <p/>\n   * This is not intended to be used for an ordinary refresh, because it assumes that no new commits have arrived, and therefore\n   * doesn't change the saved log skeleton.\n   */\n  private void loadFromVcs(int commitCount, ProgressIndicator indicator, final Consumer<DataPack> onSuccess) throws VcsException {\n    StopWatch methodSW = StopWatch.start(\"loadFromVcs\");\n    Map<VirtualFile, List<? extends TimedVcsCommit>> logsToBuild = ContainerUtil.newHashMap();\n    Map<VirtualFile, Collection<VcsRef>> refsByRoot = ContainerUtil.newHashMap();\n\n    for (Map.Entry<VirtualFile, RecentCommitsInfo> entry : collectInfoFromVcs(true, commitCount)) {\n      VirtualFile root = entry.getKey();\n      RecentCommitsInfo info = entry.getValue();\n\n      // in this case new commits won't be attached to the log, but will substitute existing ones.\n      List<TimedVcsCommit> firstBlockCommits = info.firstBlockCommits;\n      if (getLogProvider(root).supportsFastUnorderedCommits()) {\n        // => we requested unordered => have to order them ourselves\n        firstBlockCommits = new VcsLogSorter<TimedVcsCommit>().sortByDateTopoOrder(firstBlockCommits);\n        firstBlockCommits = new ArrayList<TimedVcsCommit>(firstBlockCommits.subList(0, Math.min(firstBlockCommits.size(), commitCount)));\n      }\n      logsToBuild.put(root, firstBlockCommits);\n      refsByRoot.put(root, info.newRefs);\n    }\n\n    StopWatch sw = StopWatch.start(\"multi-repo join\");\n    List<? extends TimedVcsCommit> compoundLog = myMultiRepoJoiner.join(logsToBuild.values());\n    sw.report();\n\n    // even if the full log was already loaded (and possibly presented to the user),\n    // build only the data that was retrieved from the VCS:\n    // if it is not one of the initial refreshes, then it is filtering, and then the DataPack will change anyway.\n    sw = StopWatch.start(\"DataPack.build\");\n    DataPack dataPack = DataPack.build(convertToGraphCommits(compoundLog), collectAllRefs(refsByRoot), indicator,\n                                       myIndexGetter, myHashGetter, myLogProviders);\n    sw.report();\n\n    if (myLogData != null && myLogData.isFullLogReady()) {\n      // reuse the skeleton, since it didn't change, because it is not a refresh\n      myLogData = new LogData(myLogData.getLogs(), myLogData.getRefs(), compoundLog, dataPack, true);\n    }\n    else {\n      // full skeleton was not retrieved yet => use commits that we've got from the VCS\n      myLogData = new LogData(logsToBuild, refsByRoot, compoundLog, dataPack, false);\n    }\n\n    myContainingBranchesGetter.clearCache();\n    handleOnSuccessInEdt(onSuccess, dataPack);\n    methodSW.report();\n  }","id":45433,"modified_method":"/**\n   * Queries the given number of commits (per each root) from the VCS, already sorted, and substitutes the \"top commits\" set by them.\n   * This is done initially, and when more commit details is needed.\n   * <p/>\n   * The whole log data is substituted with the retrieved part of the log only if it hasn't been loaded yet.\n   * Otherwise the previous log data is reused, and only top commits are substituted.\n   * <p/>\n   * This is not intended to be used for an ordinary refresh, because it assumes that no new commits have arrived, and therefore\n   * doesn't change the saved log skeleton.\n   */\n  private void loadFromVcs(int commitCount, ProgressIndicator indicator, final Consumer<DataPack> onSuccess) throws VcsException {\n    StopWatch methodSW = StopWatch.start(\"loadFromVcs\");\n    Map<VirtualFile, List<? extends TimedVcsCommit>> logsToBuild = ContainerUtil.newHashMap();\n    Map<VirtualFile, Collection<VcsRef>> refsByRoot = ContainerUtil.newHashMap();\n\n    for (Map.Entry<VirtualFile, RecentCommitsInfo> entry : collectInfoFromVcs(true, commitCount)) {\n      VirtualFile root = entry.getKey();\n      RecentCommitsInfo info = entry.getValue();\n\n      // in this case new commits won't be attached to the log, but will substitute existing ones.\n      logsToBuild.put(root, info.firstBlockCommits);\n      refsByRoot.put(root, info.newRefs);\n    }\n\n    StopWatch sw = StopWatch.start(\"multi-repo join\");\n    List<? extends TimedVcsCommit> compoundLog = myMultiRepoJoiner.join(logsToBuild.values());\n    sw.report();\n\n    // even if the full log was already loaded (and possibly presented to the user),\n    // build only the data that was retrieved from the VCS:\n    // if it is not one of the initial refreshes, then it is filtering, and then the DataPack will change anyway.\n    sw = StopWatch.start(\"DataPack.build\");\n    DataPack dataPack = DataPack.build(convertToGraphCommits(compoundLog), collectAllRefs(refsByRoot), indicator,\n                                       myIndexGetter, myHashGetter, myLogProviders);\n    sw.report();\n\n    if (myLogData != null && myLogData.isFullLogReady()) {\n      // reuse the skeleton, since it didn't change, because it is not a refresh\n      myLogData = new LogData(myLogData.getLogs(), myLogData.getRefs(), compoundLog, dataPack, true);\n    }\n    else {\n      // full skeleton was not retrieved yet => use commits that we've got from the VCS\n      myLogData = new LogData(logsToBuild, refsByRoot, compoundLog, dataPack, false);\n    }\n\n    myContainingBranchesGetter.clearCache();\n    handleOnSuccessInEdt(onSuccess, dataPack);\n    methodSW.report();\n  }","commit_id":"096155f75a67060ebf1aa180786b2f2ea6c0a3c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Set<Map.Entry<VirtualFile, RecentCommitsInfo>> collectInfoFromVcs(boolean ordered, int commitsCount) throws VcsException {\n    StopWatch methodTime = StopWatch.start(\"collectInfoFromVcs\");\n    Map<VirtualFile, RecentCommitsInfo> infoByRoot = ContainerUtil.newHashMap();\n    for (Map.Entry<VirtualFile, VcsLogProvider> entry : myLogProviders.entrySet()) {\n      VirtualFile root = entry.getKey();\n      VcsLogProvider logProvider = entry.getValue();\n\n      StopWatch sw = StopWatch.start(\"readFirstBlock for \" + root.getName());\n\n      boolean orderedForRepo = ordered && !logProvider.supportsFastUnorderedCommits(); // will order manually\n      int commitCountForRepo = orderedForRepo ? commitsCount : commitsCount * 2; // but need to request more commits\n\n      List<? extends VcsCommitMetadata> firstBlockDetails = logProvider.readFirstBlock(root, orderedForRepo, commitCountForRepo);\n      sw.report();\n      sw = StopWatch.start(\"readAllRefs for\" + root.getName());\n      Collection<VcsRef> newRefs = logProvider.readAllRefs(root);\n      sw.report();\n      storeTopCommitsDetailsInCache(firstBlockDetails);\n      storeUsers(firstBlockDetails);\n      List<TimedVcsCommit> firstBlockCommits = getCommitsFromDetails(firstBlockDetails);\n\n      infoByRoot.put(root, new RecentCommitsInfo(firstBlockCommits, newRefs));\n    }\n    methodTime.report();\n    return infoByRoot.entrySet();\n  }","id":45434,"modified_method":"private Set<Map.Entry<VirtualFile, RecentCommitsInfo>> collectInfoFromVcs(boolean ordered, int commitsCount) throws VcsException {\n    StopWatch methodTime = StopWatch.start(\"collectInfoFromVcs\");\n    Map<VirtualFile, RecentCommitsInfo> infoByRoot = ContainerUtil.newHashMap();\n    for (Map.Entry<VirtualFile, VcsLogProvider> entry : myLogProviders.entrySet()) {\n      VirtualFile root = entry.getKey();\n      VcsLogProvider logProvider = entry.getValue();\n\n      StopWatch sw = StopWatch.start(\"readFirstBlock for \" + root.getName());\n\n      List<? extends VcsCommitMetadata> firstBlockDetails = logProvider.readFirstBlock(root, new RequirementsImpl(commitsCount, ordered));\n      sw.report();\n      sw = StopWatch.start(\"readAllRefs for\" + root.getName());\n      Collection<VcsRef> newRefs = logProvider.readAllRefs(root);\n      sw.report();\n      storeTopCommitsDetailsInCache(firstBlockDetails);\n      storeUsers(firstBlockDetails);\n      List<TimedVcsCommit> firstBlockCommits = getCommitsFromDetails(firstBlockDetails);\n\n      infoByRoot.put(root, new RecentCommitsInfo(firstBlockCommits, newRefs));\n    }\n    methodTime.report();\n    return infoByRoot.entrySet();\n  }","commit_id":"096155f75a67060ebf1aa180786b2f2ea6c0a3c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  List<Commit> sortByDateTopoOrder(@NotNull List<Commit> commits) {\n    return new VcsLogJoiner.NewCommitIntegrator<Commit>(new ArrayList<Commit>(), commits).getResultList();\n  }","id":45435,"modified_method":"@NotNull\n  public static <Commit extends TimedVcsCommit> List<Commit> sortByDateTopoOrder(@NotNull List<Commit> commits) {\n    return new VcsLogJoiner.NewCommitIntegrator<Commit>(new ArrayList<Commit>(), commits).getResultList();\n  }","commit_id":"096155f75a67060ebf1aa180786b2f2ea6c0a3c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doTest(List<TimedVcsCommit> started, List<TimedVcsCommit> expected) {\n    List<TimedVcsCommit> sorted = new VcsLogSorter<TimedVcsCommit>().sortByDateTopoOrder(started);\n    assertEquals(toStr(expected), toStr(sorted));\n  }","id":45436,"modified_method":"private static void doTest(List<TimedVcsCommit> started, List<TimedVcsCommit> expected) {\n    List<TimedVcsCommit> sorted = VcsLogSorter.sortByDateTopoOrder(started);\n    assertEquals(toStr(expected), toStr(sorted));\n  }","commit_id":"096155f75a67060ebf1aa180786b2f2ea6c0a3c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), target.possibleTargets(null, playerId, game), target.isRequired(), options);\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null) {\n\t\t\t\tif (target instanceof TargetPermanent) {\n\t\t\t\t\tif (((TargetPermanent)target).canTarget(playerId, response.getUUID(), sourceId, game, false)) {\n\t\t\t\t\t\ttarget.add(response.getUUID(), game);\n\t\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (target.canTarget(response.getUUID(), game)) {\n\t\t\t\t\ttarget.add(response.getUUID(), game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!target.isRequired()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":45437,"modified_method":"@Override\n\tpublic boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n            Set<UUID> cards = target.possibleTargets(null, playerId, game);\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), cards, target.isRequired(), options);\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null) {\n\t\t\t\tif (target instanceof TargetPermanent) {\n\t\t\t\t\tif (((TargetPermanent)target).canTarget(playerId, response.getUUID(), sourceId, game, false)) {\n\t\t\t\t\t\ttarget.add(response.getUUID(), game);\n\t\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (target.canTarget(response.getUUID(), game)) {\n\t\t\t\t\ttarget.add(response.getUUID(), game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!target.isRequired()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n                if (cards == null || cards.isEmpty()) {\n                    return false;\n                }\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"3cadbeb68bff2b6affe3e7774a0581053adf0025","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n            Set<UUID> possibleTargets = target.possibleTargets(source==null?null:source.getId(), playerId, game);\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), possibleTargets, target.isRequired(), getOptions(target));\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null && possibleTargets.contains(response.getUUID())) {\n\t\t\t\tif (target instanceof TargetPermanent) {\n\t\t\t\t\tif (((TargetPermanent)target).canTarget(playerId, response.getUUID(), source, game)) {\n\t\t\t\t\t\ttarget.addTarget(response.getUUID(), source, game);\n\t\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (target.canTarget(response.getUUID(), source, game)) {\n\t\t\t\t\ttarget.addTarget(response.getUUID(), source, game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!target.isRequired()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":45438,"modified_method":"@Override\n\tpublic boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n            Set<UUID> possibleTargets = target.possibleTargets(source==null?null:source.getId(), playerId, game);\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), possibleTargets, target.isRequired(), getOptions(target));\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null && possibleTargets.contains(response.getUUID())) {\n\t\t\t\tif (target instanceof TargetPermanent) {\n\t\t\t\t\tif (((TargetPermanent)target).canTarget(playerId, response.getUUID(), source, game)) {\n\t\t\t\t\t\ttarget.addTarget(response.getUUID(), source, game);\n\t\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (target.canTarget(response.getUUID(), source, game)) {\n\t\t\t\t\ttarget.addTarget(response.getUUID(), source, game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!target.isRequired()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n                if (possibleTargets.size() == 0) {\n                    return false;\n                }\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"3cadbeb68bff2b6affe3e7774a0581053adf0025","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), cards, target.isRequired(), null);\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null) {\n\t\t\t\tif (target.canTarget(response.getUUID(), cards, game)) {\n\t\t\t\t\ttarget.addTarget(response.getUUID(), source, game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!target.isRequired()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":45439,"modified_method":"@Override\n\tpublic boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n            boolean required = target.isRequired();\n\t\t\t// if there is no cards to select from, then add possibility to cancel choosing action\n            if (cards == null) {\n\t\t\t\trequired = false;\n\t\t\t} else {\n\t\t\t\tint count = cards.count(target.getFilter(), game);\n\t\t\t\tif (count == 0) required = false;\n\t\t\t}\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), cards, target.isRequired(), null);\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null) {\n\t\t\t\tif (target.canTarget(response.getUUID(), cards, game)) {\n\t\t\t\t\ttarget.addTarget(response.getUUID(), source, game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!required) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"3cadbeb68bff2b6affe3e7774a0581053adf0025","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean choose(Outcome outcome, Cards cards, TargetCard target, Game game) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n\t\t\tboolean required = target.isRequired();\n\t\t\t// if there is no cards to select from, then add possibility to cancel choosing action\n\t\t\tif (cards == null) {\n\t\t\t\trequired = false;\n\t\t\t} else {\n\t\t\t\tint count = cards.count(target.getFilter(), game);\n\t\t\t\tif (count == 0) required = false;\n\t\t\t}\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), cards, required, getOptions(target));\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null) {\n\t\t\t\tif (target.canTarget(response.getUUID(), cards, game)) {\n\t\t\t\t\ttarget.add(response.getUUID(), game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!target.isRequired()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":45440,"modified_method":"@Override\n\tpublic boolean choose(Outcome outcome, Cards cards, TargetCard target, Game game) {\n\t\tgame.getState().setPriorityPlayerId(getId());\n\t\twhile (!abort) {\n\t\t\tboolean required = target.isRequired();\n\t\t\t// if there is no cards to select from, then add possibility to cancel choosing action\n            if (cards == null) {\n\t\t\t\trequired = false;\n\t\t\t} else {\n\t\t\t\tint count = cards.count(target.getFilter(), game);\n\t\t\t\tif (count == 0) required = false;\n\t\t\t}\n\t\t\tgame.fireSelectTargetEvent(playerId, target.getMessage(), cards, required, getOptions(target));\n\t\t\twaitForResponse();\n\t\t\tif (response.getUUID() != null) {\n\t\t\t\tif (target.canTarget(response.getUUID(), cards, game)) {\n\t\t\t\t\ttarget.add(response.getUUID(), game);\n\t\t\t\t\tif(target.doneChosing()){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target.getTargets().size() >= target.getNumberOfTargets()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!required) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"3cadbeb68bff2b6affe3e7774a0581053adf0025","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {\r\n        updateGameStatePriority(\"chooseTarget\", game);\r\n        while (!abort) {\r\n            Set<UUID> possibleTargets = target.possibleTargets(source==null?null:source.getSourceId(), playerId, game);\r\n            boolean required = possibleTargets.isEmpty() ? false : target.isRequired(source);\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), possibleTargets, required, getOptions(target));\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (possibleTargets.contains(response.getUUID())) {\r\n                    if (target instanceof TargetPermanent) {\r\n                        if (((TargetPermanent)target).canTarget(playerId, response.getUUID(), source, game)) {\r\n                            target.addTarget(response.getUUID(), source, game);\r\n                            if(target.doneChosing()){\r\n                                return true;\r\n                            }\r\n                        }\r\n                    } else if (target.canTarget(response.getUUID(), playerId, source, game)) {\r\n                        target.addTarget(response.getUUID(), source, game);\r\n                        if(target.doneChosing()){\r\n                            return true;\r\n                        }\r\n                    }\r\n                } // else do nothing - allow to pick another target\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!required) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":45441,"modified_method":"@Override\r\n    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {\r\n        updateGameStatePriority(\"chooseTarget\", game);\r\n        while (!abort) {\r\n            Set<UUID> possibleTargets = target.possibleTargets(source==null?null:source.getSourceId(), playerId, game);\r\n            boolean required = target.isRequired(source);\r\n            if (possibleTargets.isEmpty() || target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                required = false;\r\n            }\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), possibleTargets, required, getOptions(target));\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (possibleTargets.contains(response.getUUID())) {\r\n                    if (target instanceof TargetPermanent) {\r\n                        if (((TargetPermanent)target).canTarget(playerId, response.getUUID(), source, game)) {\r\n                            target.addTarget(response.getUUID(), source, game);\r\n                            if(target.doneChosing()){\r\n                                return true;\r\n                            }\r\n                        }\r\n                    } else if (target.canTarget(response.getUUID(), playerId, source, game)) {\r\n                        target.addTarget(response.getUUID(), source, game);\r\n                        if(target.doneChosing()){\r\n                            return true;\r\n                        }\r\n                    }\r\n                } // else do nothing - allow to pick another target\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!required) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\r\n        updateGameStatePriority(\"choose(5)\", game);\r\n        while (!abort) {\r\n            Set<UUID> cards = target.possibleTargets(null, playerId, game);\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), cards, target.isRequired(sourceId, game), options);\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (target instanceof TargetPermanent) {\r\n                    if (((TargetPermanent)target).canTarget(playerId, response.getUUID(), sourceId, game, false)) {\r\n                        target.add(response.getUUID(), game);\r\n                        if(target.doneChosing()){\r\n                            return true;\r\n                        }\r\n                    }\r\n                } else {\r\n                    MageObject object = game.getObject(sourceId);\r\n                    if (object instanceof Ability) {\r\n                        if (target.canTarget(response.getUUID(), (Ability) object, game)) {\r\n                            target.add(response.getUUID(), game);\r\n                            if (target.doneChosing()) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (target.canTarget(response.getUUID(), game)) {\r\n                            target.add(response.getUUID(), game);\r\n                            if (target.doneChosing()) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!target.isRequired(sourceId, game)) {\r\n                    return false;\r\n                }\r\n                if (cards == null || cards.isEmpty()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":45442,"modified_method":"@Override\r\n    public boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\r\n        updateGameStatePriority(\"choose(5)\", game);\r\n        while (!abort) {\r\n            Set<UUID> cards = target.possibleTargets(null, playerId, game);\r\n            boolean required = target.isRequired(sourceId, game);\r\n            if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                required = false;\r\n            }\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), cards, required, options);\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (target instanceof TargetPermanent) {\r\n                    if (((TargetPermanent)target).canTarget(playerId, response.getUUID(), sourceId, game, false)) {\r\n                        target.add(response.getUUID(), game);\r\n                        if(target.doneChosing()){\r\n                            return true;\r\n                        }\r\n                    }\r\n                } else {\r\n                    MageObject object = game.getObject(sourceId);\r\n                    if (object instanceof Ability) {\r\n                        if (target.canTarget(response.getUUID(), (Ability) object, game)) {\r\n                            target.add(response.getUUID(), game);\r\n                            if (target.doneChosing()) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (target.canTarget(response.getUUID(), game)) {\r\n                            target.add(response.getUUID(), game);\r\n                            if (target.doneChosing()) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!target.isRequired(sourceId, game)) {\r\n                    return false;\r\n                }\r\n                if (cards == null || cards.isEmpty()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"private Map<String, Serializable> getOptions(Target target) {\r\n        return target.getNumberOfTargets() != target.getMaxNumberOfTargets() ? staticOptions : null;\r\n    }","id":45443,"modified_method":"private Map<String, Serializable> getOptions(Target target) {\r\n        return target.getTargets().size() >= target.getNumberOfTargets() ? staticOptions : null;\r\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {\r\n        updateGameStatePriority(\"chooseTarget(5)\", game);\r\n        while (!abort) {\r\n            boolean required = target.isRequired(source);\r\n            // if there is no cards to select from, then add possibility to cancel choosing action\r\n            if (cards == null) {\r\n                required = false;\r\n            } else {\r\n                int count = cards.count(target.getFilter(), game);\r\n                if (count == 0) {\r\n                    required = false;\r\n                }\r\n            }\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), cards, target.isRequired(source), null);\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (target.canTarget(response.getUUID(), cards, game)) {\r\n                    target.addTarget(response.getUUID(), source, game);\r\n                    if(target.doneChosing()){\r\n                        return true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!required) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":45444,"modified_method":"@Override\r\n    public boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {\r\n        updateGameStatePriority(\"chooseTarget(5)\", game);\r\n        while (!abort) {\r\n            boolean required = target.isRequired(source);\r\n            // if there is no cards to select from, then add possibility to cancel choosing action\r\n            if (cards == null) {\r\n                required = false;\r\n            } else {\r\n                int count = cards.count(target.getFilter(), game);\r\n                if (count == 0) {\r\n                    required = false;\r\n                }\r\n            }\r\n            if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                required = false;\r\n            }\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), cards, required, null);\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (target.canTarget(response.getUUID(), cards, game)) {\r\n                    target.addTarget(response.getUUID(), source, game);\r\n                    if(target.doneChosing()){\r\n                        return true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!required) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean choose(Outcome outcome, Cards cards, TargetCard target, Game game) {\r\n        updateGameStatePriority(\"choose(4)\", game);\r\n        while (!abort) {\r\n            boolean required = target.isRequired();\r\n            // if there is no cards to select from, then add possibility to cancel choosing action\r\n            if (cards == null) {\r\n                required = false;\r\n            } else {\r\n                int count = cards.count(target.getFilter(), game);\r\n                if (count == 0) {\r\n                    required = false;\r\n                }\r\n            }\r\n            Map<String, Serializable> options = getOptions(target);\r\n            if (target.getTargets().size() > 0) {\r\n                if (options == null) {\r\n                    options = new HashMap<>(1);\r\n                }\r\n                List<UUID> chosen = (List<UUID>)target.getTargets();\r\n                options.put(\"chosen\", (Serializable)chosen);\r\n            }\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), cards, required, options);\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (target.canTarget(response.getUUID(), cards, game)) {\r\n                    target.add(response.getUUID(), game);\r\n                    if(target.doneChosing()){\r\n                        return true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!required) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":45445,"modified_method":"@Override\r\n    public boolean choose(Outcome outcome, Cards cards, TargetCard target, Game game) {\r\n        updateGameStatePriority(\"choose(4)\", game);\r\n        while (!abort) {\r\n            boolean required = target.isRequired();\r\n            // if there is no cards to select from, then add possibility to cancel choosing action\r\n            if (cards == null) {\r\n                required = false;\r\n            } else {\r\n                int count = cards.count(target.getFilter(), game);\r\n                if (count == 0) {\r\n                    required = false;\r\n                }\r\n            }\r\n            if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                required = false;\r\n            }\r\n            Map<String, Serializable> options = getOptions(target);\r\n            if (target.getTargets().size() > 0) {\r\n                if (options == null) {\r\n                    options = new HashMap<>(1);\r\n                }\r\n                List<UUID> chosen = (List<UUID>)target.getTargets();\r\n                options.put(\"chosen\", (Serializable)chosen);\r\n            }\r\n            game.fireSelectTargetEvent(playerId, target.getMessage(), cards, required, options);\r\n            waitForResponse(game);\r\n            if (response.getUUID() != null) {\r\n                if (target.canTarget(response.getUUID(), cards, game)) {\r\n                    target.add(response.getUUID(), game);\r\n                    if(target.doneChosing()){\r\n                        return true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (target.getTargets().size() >= target.getNumberOfTargets()) {\r\n                    return true;\r\n                }\r\n                if (!required) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"public TargetCardInLibrary(int minNumTargets, int maxNumTargets, FilterCard filter) {\n        super(minNumTargets, maxNumTargets, Zone.LIBRARY, filter);\n        this.setRequired(minNumTargets > 0 && !filter.hasPredicates());\n        this.librarySearchLimit = Integer.MAX_VALUE;\n    }","id":45446,"modified_method":"public TargetCardInLibrary(int minNumTargets, int maxNumTargets, FilterCard filter) {\n        super(minNumTargets, maxNumTargets, Zone.LIBRARY, filter);\n        this.setRequired(!filter.hasPredicates());\n        this.librarySearchLimit = Integer.MAX_VALUE;\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"public TargetObject(int minNumTargets, int maxNumTargets, Zone zone, boolean notTarget) {\n        this.minNumberOfTargets = minNumTargets;\n        this.maxNumberOfTargets = maxNumTargets;\n        if (minNumTargets == 0) {\n            setRequired(false);\n        }\n        this.zone = zone;\n        this.targetName = \"card\";\n        this.notTarget = notTarget;\n    }","id":45447,"modified_method":"public TargetObject(int minNumTargets, int maxNumTargets, Zone zone, boolean notTarget) {\n        this.minNumberOfTargets = minNumTargets;\n        this.maxNumberOfTargets = maxNumTargets;\n        this.zone = zone;\n        this.targetName = \"card\";\n        this.notTarget = notTarget;\n    }","commit_id":"13b8cad13100f6847d37d4066ce1879a50a925cd","url":"https://github.com/magefree/mage"},{"original_method":"/**\n\t * Defines a service with one required dependency that is not\n\t * available. Makes sure the service is not started.\n\t */\n\tpublic void testRequiredUnavailableDependency() throws Exception {\n\t\t// setup the mock objects\n\t\tIMocksControl ctrl = EasyMock.createControl();\n\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n\t\tDependency dependency = ctrl.createMock(Dependency.class);\n\t\tMyService svc = ctrl.createMock(MyService.class);\n\t\tctrl.checkOrder(false);\n\t\tEasyMock.expect(dependency.isRequired()).andReturn(Boolean.TRUE).anyTimes();\n\t\tEasyMock.expect(dependency.isAvailable()).andReturn(Boolean.FALSE).anyTimes();\n\t\tdependency.start((Service) EasyMock.anyObject());\n\t\tdependency.stop((Service) EasyMock.anyObject());\n\t\t// start the actual test\n\t\tctrl.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context)\n\t\t\t.setImplementation(svc)\n\t\t\t.add(dependency);\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tctrl.verify();\n\t}","id":45448,"modified_method":"/**\n\t * Defines a service with one required dependency that is not\n\t * available. Makes sure the service is not started.\n\t */\n\tpublic void testRequiredUnavailableDependency() throws Exception {\n\t\t// setup the mock objects\n        MockControl c1 = MockControl.createControl(BundleContext.class);\n        BundleContext context = (BundleContext) c1.getMock();\n        MockControl c2 = MockControl.createControl(MyService.class);\n        MyService svc = (MyService) c2.getMock();\n        MockControl c3 = MockControl.createControl(Dependency.class);\n        Dependency dependency = (Dependency) c3.getMock();\n\n        dependency.isRequired();\n        c3.setReturnValue(true, MockControl.ONE_OR_MORE);\n        dependency.isAvailable();\n        c3.setReturnValue(false, MockControl.ONE_OR_MORE);\n        \n\t\tdependency.start((Service) null);\n        c3.setMatcher(MockControl.ALWAYS_MATCHER);\n\t\tdependency.stop((Service) null);\n        c3.setMatcher(MockControl.ALWAYS_MATCHER);\n\t\t// start the actual test\n\t\tc1.replay();\n        c2.replay();\n        c3.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context)\n\t\t\t.setImplementation(svc)\n\t\t\t.add(dependency);\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tc1.verify();\n        c2.verify();\n        c3.verify();\n\t}","commit_id":"45ad81cf8e3f24e36c4c35c4a54f3429bb32be57","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Defines a service with an optional dependency that is not available.\n\t * Makes sure the service is started.\n\t */\n\tpublic void testOptionalDependency() throws Exception {\n\t\t// setup the mock objects\n\t\tIMocksControl ctrl = EasyMock.createControl();\n\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n\t\tDependency dependency = ctrl.createMock(Dependency.class);\n\t\tMyService svc = ctrl.createMock(MyService.class);\n\t\tctrl.checkOrder(false);\n\t\tEasyMock.expect(dependency.isRequired()).andReturn(Boolean.FALSE).anyTimes();\n\t\tEasyMock.expect(dependency.isAvailable()).andReturn(Boolean.FALSE).anyTimes();\n\t\tdependency.start((Service) EasyMock.anyObject());\n\t\tsvc.init();\n\t\tsvc.start();\n\t\tsvc.stop();\n\t\tsvc.destroy();\n\t\tdependency.stop((Service) EasyMock.anyObject());\n\t\t// start the actual test\n\t\tctrl.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context)\n\t\t\t.setImplementation(svc)\n\t\t\t.add(dependency);\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tctrl.verify();\n\t}","id":45449,"modified_method":"/**\n\t * Defines a service with an optional dependency that is not available.\n\t * Makes sure the service is started.\n\t */\n\tpublic void testOptionalDependency() throws Exception {\n//\t\t// setup the mock objects\n//\t\tIMocksControl ctrl = EasyMock.createControl();\n//\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n//\t\tDependency dependency = ctrl.createMock(Dependency.class);\n//\t\tMyService svc = ctrl.createMock(MyService.class);\n//\t\tctrl.checkOrder(false);\n//\t\tEasyMock.expect(dependency.isRequired()).andReturn(Boolean.FALSE).anyTimes();\n//\t\tEasyMock.expect(dependency.isAvailable()).andReturn(Boolean.FALSE).anyTimes();\n//\t\tdependency.start((Service) EasyMock.anyObject());\n//\t\tsvc.init();\n//\t\tsvc.start();\n//\t\tsvc.stop();\n//\t\tsvc.destroy();\n//\t\tdependency.stop((Service) EasyMock.anyObject());\n//\t\t// start the actual test\n//\t\tctrl.replay();\n//\t\tDependencyManager dm = new DependencyManager(context);\n//\t\tService service = new ServiceImpl(context)\n//\t\t\t.setImplementation(svc)\n//\t\t\t.add(dependency);\n//\t\tdm.add(service);\n//\t\tdm.remove(service);\n//\t\t// verify the results\n//\t\tctrl.verify();\n\t}","commit_id":"45ad81cf8e3f24e36c4c35c4a54f3429bb32be57","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Defines a service with one required dependency that is\n\t * available. Makes sure the service is started.\n\t */\n\tpublic void testRequiredAvailableDependency() throws Exception {\n\t\t// setup the mock objects\n\t\tIMocksControl ctrl = EasyMock.createControl();\n\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n\t\tDependency dependency = ctrl.createMock(Dependency.class);\n\t\tMyService svc = ctrl.createMock(MyService.class);\n\t\tctrl.checkOrder(false);\n\t\tEasyMock.expect(dependency.isRequired()).andReturn(Boolean.TRUE).anyTimes();\n\t\tEasyMock.expect(dependency.isAvailable()).andReturn(Boolean.TRUE).anyTimes();\n\t\tdependency.start((Service) EasyMock.anyObject());\n\t\tsvc.init();\n\t\tsvc.start();\n\t\tsvc.stop();\n\t\tsvc.destroy();\n\t\tdependency.stop((Service) EasyMock.anyObject());\n\t\t// start the actual test\n\t\tctrl.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context)\n\t\t\t.setImplementation(svc)\n\t\t\t.add(dependency);\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tctrl.verify();\n\t}","id":45450,"modified_method":"/**\n\t * Defines a service with one required dependency that is\n\t * available. Makes sure the service is started.\n\t */\n\tpublic void testRequiredAvailableDependency() throws Exception {\n//\t\t// setup the mock objects\n//\t\tIMocksControl ctrl = EasyMock.createControl();\n//\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n//\t\tDependency dependency = ctrl.createMock(Dependency.class);\n//\t\tMyService svc = ctrl.createMock(MyService.class);\n//\t\tctrl.checkOrder(false);\n//\t\tEasyMock.expect(dependency.isRequired()).andReturn(Boolean.TRUE).anyTimes();\n//\t\tEasyMock.expect(dependency.isAvailable()).andReturn(Boolean.TRUE).anyTimes();\n//\t\tdependency.start((Service) EasyMock.anyObject());\n//\t\tsvc.init();\n//\t\tsvc.start();\n//\t\tsvc.stop();\n//\t\tsvc.destroy();\n//\t\tdependency.stop((Service) EasyMock.anyObject());\n//\t\t// start the actual test\n//\t\tctrl.replay();\n//\t\tDependencyManager dm = new DependencyManager(context);\n//\t\tService service = new ServiceImpl(context)\n//\t\t\t.setImplementation(svc)\n//\t\t\t.add(dependency);\n//\t\tdm.add(service);\n//\t\tdm.remove(service);\n//\t\t// verify the results\n//\t\tctrl.verify();\n\t}","commit_id":"45ad81cf8e3f24e36c4c35c4a54f3429bb32be57","url":"https://github.com/apache/felix"},{"original_method":"public void XtestRequiredAvailableServiceDependency() throws Exception {\n\t\t// setup the mock objects\n\t\tIMocksControl ctrl = EasyMock.createControl();\n\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n\t\tFilter filter = ctrl.createMock(Filter.class);\n\t\tMyService svc = ctrl.createMock(MyService.class);\n\t\tctrl.checkOrder(false);\n\t\tEasyMock.expect(context.createFilter(\"(objectClass=org.apache.felix.dependencymanager.DummyService)\")).andReturn(filter);\n\t\tcontext.addServiceListener((ServiceListener) EasyMock.anyObject());\n\t\tEasyMock.expect(context.getServiceReferences(null, \"EasyMock for interface org.osgi.framework.Filter\")).andReturn(new ServiceReference[] {});\n\t\tcontext.removeServiceListener((ServiceListener) EasyMock.anyObject());\n\t\tsvc.init();\n\t\tsvc.start();\n\t\tsvc.stop();\n\t\tsvc.destroy();\n\t\t// start the actual test\n\t\tctrl.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context)\n\t\t\t.setImplementation(svc)\n\t\t\t.add(new ServiceDependency(context)\n\t\t\t\t.setRequired(true)\n\t\t\t\t.setService(DummyService.class));\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tctrl.verify();\n\t}","id":45451,"modified_method":"public void XtestRequiredAvailableServiceDependency() throws Exception {\n//\t\t// setup the mock objects\n//\t\tIMocksControl ctrl = EasyMock.createControl();\n//\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n//\t\tFilter filter = ctrl.createMock(Filter.class);\n//\t\tMyService svc = ctrl.createMock(MyService.class);\n//\t\tctrl.checkOrder(false);\n//\t\tEasyMock.expect(context.createFilter(\"(objectClass=org.apache.felix.dependencymanager.DummyService)\")).andReturn(filter);\n//\t\tcontext.addServiceListener((ServiceListener) EasyMock.anyObject());\n//\t\tEasyMock.expect(context.getServiceReferences(null, \"EasyMock for interface org.osgi.framework.Filter\")).andReturn(new ServiceReference[] {});\n//\t\tcontext.removeServiceListener((ServiceListener) EasyMock.anyObject());\n//\t\tsvc.init();\n//\t\tsvc.start();\n//\t\tsvc.stop();\n//\t\tsvc.destroy();\n//\t\t// start the actual test\n//\t\tctrl.replay();\n//\t\tDependencyManager dm = new DependencyManager(context);\n//\t\tService service = new ServiceImpl(context)\n//\t\t\t.setImplementation(svc)\n//\t\t\t.add(new ServiceDependency(context)\n//\t\t\t\t.setRequired(true)\n//\t\t\t\t.setService(DummyService.class));\n//\t\tdm.add(service);\n//\t\tdm.remove(service);\n//\t\t// verify the results\n//\t\tctrl.verify();\n\t}","commit_id":"45ad81cf8e3f24e36c4c35c4a54f3429bb32be57","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Checks the basic life-cycle of a service that has no dependencies.\n\t * Makes sure that the init, start, stop and destroy callbacks are\n\t * invoked on the implementation.\n\t */\n\tpublic void testStandaloneService() throws Exception {\n\t\t// setup the mock objects\n\t\tIMocksControl ctrl = EasyMock.createControl();\n\t\tBundleContext context = ctrl.createMock(BundleContext.class);\n\t\tMyService svc = ctrl.createMock(MyService.class);\n\t\tctrl.checkOrder(true);\n\t\tsvc.init();\n\t\tsvc.start();\n\t\tsvc.stop();\n\t\tsvc.destroy();\n\t\t// start the actual test\n\t\tctrl.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context).setImplementation(svc);\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tctrl.verify();\n\t}","id":45452,"modified_method":"/**\n\t * Checks the basic life-cycle of a service that has no dependencies.\n\t * Makes sure that the init, start, stop and destroy callbacks are\n\t * invoked on the implementation.\n\t */\n\tpublic void testStandaloneService() throws Exception {\n\t\t// setup the mock objects\n\t    MockControl c1 = MockControl.createControl(BundleContext.class);\n\t\tBundleContext context = (BundleContext) c1.getMock();\n        MockControl c2 = MockControl.createControl(MyService.class);\n\t\tMyService svc = (MyService) c2.getMock();\n\t\tsvc.init();\n\t\tsvc.start();\n\t\tsvc.stop();\n\t\tsvc.destroy();\n\t\t// start the actual test\n\t\tc1.replay();\n        c2.replay();\n\t\tDependencyManager dm = new DependencyManager(context);\n\t\tService service = new ServiceImpl(context).setImplementation(svc);\n\t\tdm.add(service);\n\t\tdm.remove(service);\n\t\t// verify the results\n\t\tc1.verify();\n        c2.verify();\n\t}","commit_id":"45ad81cf8e3f24e36c4c35c4a54f3429bb32be57","url":"https://github.com/apache/felix"},{"original_method":"public int compare(OperationResourceInfo e1, OperationResourceInfo e2) {\n        \n        if (rc != null) {\n            int result = rc.compare(e1, e2, message);\n            if (result != 0) {\n                return result;\n            }\n        }\n        \n        if (!getMethod && HttpMethod.HEAD.equals(httpMethod)) {\n            if (HttpMethod.HEAD.equals(e1.getHttpMethod())) {\n                return -1;\n            } else if (HttpMethod.HEAD.equals(e2.getHttpMethod())) {\n                return 1;\n            }\n        }\n            \n        int result = URITemplate.compareTemplates(\n                          e1.getURITemplate(),\n                          e2.getURITemplate());\n        \n        if (result == 0 && (e1.getHttpMethod() != null && e2.getHttpMethod() == null\n                || e1.getHttpMethod() == null && e2.getHttpMethod() != null)) {\n            // resource method takes precedence over a subresource locator\n            return e1.getHttpMethod() != null ? -1 : 1;\n        }\n        \n        if (result == 0 && !getMethod) {\n            result = JAXRSUtils.compareSortedConsumesMediaTypes(\n                          e1.getConsumeTypes(), \n                          e2.getConsumeTypes(),\n                          contentType);\n        }\n        \n        if (result == 0) {\n            //use the media type of output data as the secondary key.\n            result = JAXRSUtils.compareSortedAcceptMediaTypes(e1.getProduceTypes(), \n                                                              e2.getProduceTypes(),\n                                                              acceptTypes);\n        }\n        \n        return result;\n    }","id":45453,"modified_method":"public int compare(OperationResourceInfo e1, OperationResourceInfo e2) {\n        if (e1 == e2) {\n            return 0;\n        }\n        if (rc != null) {\n            int result = rc.compare(e1, e2, message);\n            if (result != 0) {\n                return result;\n            }\n        }\n        String e1HttpMethod = e1.getHttpMethod();\n        String e2HttpMethod = e2.getHttpMethod();\n        \n        int result = 0;\n        if (!getMethod && HttpMethod.HEAD.equals(httpMethod)) {\n            result = compareWithHead(e1HttpMethod, e2HttpMethod);\n            if (result != 0) {\n                return result;\n            }\n        }\n            \n        result = URITemplate.compareTemplates(\n                          e1.getURITemplate(),\n                          e2.getURITemplate());\n        \n        if (result == 0 && (e1HttpMethod != null && e2HttpMethod == null\n                || e1HttpMethod == null && e2HttpMethod != null)) {\n            // resource method takes precedence over a subresource locator\n            return e1.getHttpMethod() != null ? -1 : 1;\n        }\n        \n        if (result == 0 && !getMethod) {\n            result = JAXRSUtils.compareSortedConsumesMediaTypes(\n                          e1.getConsumeTypes(), \n                          e2.getConsumeTypes(),\n                          contentType);\n        }\n        \n        if (result == 0) {\n            //use the media type of output data as the secondary key.\n            result = JAXRSUtils.compareSortedAcceptMediaTypes(e1.getProduceTypes(), \n                                                              e2.getProduceTypes(),\n                                                              acceptTypes);\n        }\n        \n        if (result == 0 && e1HttpMethod != null && e2HttpMethod != null) {\n            boolean e1IsDefault = DefaultMethod.class.getSimpleName().equals(e1HttpMethod);\n            boolean e2IsDefault = DefaultMethod.class.getSimpleName().equals(e2HttpMethod);\n            if (e1IsDefault && !e2IsDefault) {\n                result = 1;\n            } else if (!e1IsDefault && e2IsDefault) {\n                result = -1;\n            } \n        }\n        \n        return result;\n    }","commit_id":"10db3b5ce912ad4bda2662764dde584d179e8e83","url":"https://github.com/apache/cxf"},{"original_method":"private void initToolWindow() {\n    // TODO den don't show tool window if no gradle project is associated with the current project.\n    if (!Boolean.getBoolean(\"gradle.show.tool.window\")) {\n      return;\n    }\n    final ToolWindowManagerEx manager = ToolWindowManagerEx.getInstanceEx(myProject);\n    ToolWindow toolWindow = manager.registerToolWindow(GRADLE_TOOL_WINDOW_ID, false, ToolWindowAnchor.RIGHT);\n    toolWindow.setIcon(GradleIcons.GRADLE_ICON);\n    String syncTitle = GradleBundle.message(\"gradle.sync.title.tab\");\n    toolWindow.getContentManager().addContent(new ContentImpl(new GradleProjectStructureChangesPanel(myChangesModel), syncTitle, true)); \n  }","id":45454,"modified_method":"private void initToolWindow() {\n    // TODO den don't show tool window if no gradle project is associated with the current project.\n    if (!Boolean.getBoolean(\"gradle.show.tool.window\")) {\n      return;\n    }\n    final ToolWindowManagerEx manager = ToolWindowManagerEx.getInstanceEx(myProject);\n    ToolWindow toolWindow = manager.registerToolWindow(GRADLE_TOOL_WINDOW_ID, false, ToolWindowAnchor.RIGHT);\n    toolWindow.setIcon(GradleConstants.GRADLE_ICON);\n    String syncTitle = GradleBundle.message(\"gradle.sync.title.tab\");\n    toolWindow.getContentManager().addContent(new ContentImpl(new GradleProjectStructureChangesPanel(myChangesModel), syncTitle, true)); \n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Icon getIcon() {\n    return GradleIcons.GRADLE_ICON;\n  }","id":45455,"modified_method":"public Icon getIcon() {\n    return GradleConstants.GRADLE_ICON;\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Icon getIcon() {\n    return GradleIcons.GRADLE_ICON;\n  }","id":45456,"modified_method":"@NotNull\n  @Override\n  public Icon getIcon() {\n    return GradleConstants.GRADLE_ICON;\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Icon getIcon() {\n    return GradleIcons.GRADLE_ICON;\n  }","id":45457,"modified_method":"@Override\n  public Icon getIcon() {\n    return GradleConstants.GRADLE_ICON;\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GradleScriptType() {\n    super(\"gradle\");    \n  }","id":45458,"modified_method":"private GradleScriptType() {\n    super(GradleConstants.EXTENSION);    \n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Icon getScriptIcon() {\n    return GradleIcons.GRADLE_ICON;\n  }","id":45459,"modified_method":"@NotNull\n  @Override\n  public Icon getScriptIcon() {\n    return GradleConstants.GRADLE_ICON;\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GroovyScriptRunner getRunner() {\n    return new GroovyScriptRunner() {\n      @Override\n      public boolean isValidModule(@NotNull Module module) {\n        GradleLibraryManager libraryManager = ServiceManager.getService(GradleLibraryManager.class);\n        return libraryManager.isGradleSdk(OrderEnumerator.orderEntries(module).getAllLibrariesAndSdkClassesRoots());\n      }\n\n      @Override\n      public boolean ensureRunnerConfigured(@Nullable Module module, RunProfile profile, Executor executor, final Project project) throws ExecutionException {\n        final GradleLibraryManager libraryManager = ServiceManager.getService(GradleLibraryManager.class);\n        if (libraryManager.getGradleHome(module, project) == null) {\n          // TODO den internationalise\n          int result = Messages.showOkCancelDialog(\n            \"Gradle is not configured. Do you want to configure it?\",\n            \"Configure Gradle SDK\",\n            GradleIcons.GRADLE_ICON\n          );\n          if (result == 0) {\n            ShowSettingsUtil.getInstance().editConfigurable(project, new GradleConfigurable(project));\n          }\n          if (libraryManager.getGradleHome(module, project) == null) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      @Override\n      public void configureCommandLine(JavaParameters params,\n                                       @Nullable Module module,\n                                       boolean tests,\n                                       VirtualFile script, GroovyScriptRunConfiguration configuration)\n        throws CantRunException\n      {\n        final Project project = configuration.getProject();\n        final GradleLibraryManager libraryManager = ServiceManager.getService(GradleLibraryManager.class);\n        final VirtualFile gradleHome = libraryManager.getGradleHome(module, project);\n        assert gradleHome != null;\n\n        params.setMainClass(findMainClass(gradleHome, script, project));\n\n        final File[] groovyJars = GroovyUtils.getFilesInDirectoryByPattern(gradleHome.getPath() + \"/lib/\", GroovyConfigUtils.GROOVY_ALL_JAR_PATTERN);\n        if (groovyJars.length > 0) {\n          params.getClassPath().add(groovyJars[0].getAbsolutePath());\n        } else if (module != null) {\n          final VirtualFile groovyJar = findGroovyJar(module);\n          if (groovyJar != null) {\n            params.getClassPath().add(groovyJar);\n          }\n        }\n\n        final String userDefinedClasspath = System.getProperty(\"gradle.launcher.classpath\");\n        if (StringUtil.isNotEmpty(userDefinedClasspath)) {\n          params.getClassPath().add(userDefinedClasspath);\n        } else {\n          final Collection<VirtualFile> roots = libraryManager.getClassRoots(project);\n          if (roots != null) {\n            params.getClassPath().addVirtualFiles(roots);\n          }\n        }\n\n        params.getVMParametersList().addParametersString(configuration.getVMParameters());\n\n\n        params.getVMParametersList().add(\"-Dgradle.home=\" + FileUtil.toSystemDependentName(gradleHome.getPath()));\n\n        setToolsJar(params);\n        \n        final String scriptPath = configuration.getScriptPath();\n        if (scriptPath == null) {\n          throw new CantRunException(\"Target script is undefined\");\n        } \n        params.getProgramParametersList().add(\"--build-file\");\n        params.getProgramParametersList().add(FileUtil.toSystemDependentName(scriptPath));\n        params.getProgramParametersList().addParametersString(configuration.getProgramParameters());\n        params.getProgramParametersList().addParametersString(configuration.getScriptParameters());\n      }\n    };\n  }","id":45460,"modified_method":"@Override\n  public GroovyScriptRunner getRunner() {\n    return new GroovyScriptRunner() {\n      @Override\n      public boolean isValidModule(@NotNull Module module) {\n        GradleLibraryManager libraryManager = ServiceManager.getService(GradleLibraryManager.class);\n        return libraryManager.isGradleSdk(OrderEnumerator.orderEntries(module).getAllLibrariesAndSdkClassesRoots());\n      }\n\n      @Override\n      public boolean ensureRunnerConfigured(@Nullable Module module, RunProfile profile, Executor executor, final Project project) throws ExecutionException {\n        final GradleLibraryManager libraryManager = ServiceManager.getService(GradleLibraryManager.class);\n        if (libraryManager.getGradleHome(module, project) == null) {\n          // TODO den internationalise\n          int result = Messages.showOkCancelDialog(\n            \"Gradle is not configured. Do you want to configure it?\",\n            \"Configure Gradle SDK\",\n            GradleConstants.GRADLE_ICON\n          );\n          if (result == 0) {\n            ShowSettingsUtil.getInstance().editConfigurable(project, new GradleConfigurable(project));\n          }\n          if (libraryManager.getGradleHome(module, project) == null) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      @Override\n      public void configureCommandLine(JavaParameters params,\n                                       @Nullable Module module,\n                                       boolean tests,\n                                       VirtualFile script, GroovyScriptRunConfiguration configuration)\n        throws CantRunException\n      {\n        final Project project = configuration.getProject();\n        final GradleLibraryManager libraryManager = ServiceManager.getService(GradleLibraryManager.class);\n        final VirtualFile gradleHome = libraryManager.getGradleHome(module, project);\n        assert gradleHome != null;\n\n        params.setMainClass(findMainClass(gradleHome, script, project));\n\n        final File[] groovyJars = GroovyUtils.getFilesInDirectoryByPattern(gradleHome.getPath() + \"/lib/\", GroovyConfigUtils.GROOVY_ALL_JAR_PATTERN);\n        if (groovyJars.length > 0) {\n          params.getClassPath().add(groovyJars[0].getAbsolutePath());\n        } else if (module != null) {\n          final VirtualFile groovyJar = findGroovyJar(module);\n          if (groovyJar != null) {\n            params.getClassPath().add(groovyJar);\n          }\n        }\n\n        final String userDefinedClasspath = System.getProperty(\"gradle.launcher.classpath\");\n        if (StringUtil.isNotEmpty(userDefinedClasspath)) {\n          params.getClassPath().add(userDefinedClasspath);\n        } else {\n          final Collection<VirtualFile> roots = libraryManager.getClassRoots(project);\n          if (roots != null) {\n            params.getClassPath().addVirtualFiles(roots);\n          }\n        }\n\n        params.getVMParametersList().addParametersString(configuration.getVMParameters());\n\n\n        params.getVMParametersList().add(\"-Dgradle.home=\" + FileUtil.toSystemDependentName(gradleHome.getPath()));\n\n        setToolsJar(params);\n        \n        final String scriptPath = configuration.getScriptPath();\n        if (scriptPath == null) {\n          throw new CantRunException(\"Target script is undefined\");\n        } \n        params.getProgramParametersList().add(\"--build-file\");\n        params.getProgramParametersList().add(FileUtil.toSystemDependentName(scriptPath));\n        params.getProgramParametersList().addParametersString(configuration.getProgramParameters());\n        params.getProgramParametersList().addParametersString(configuration.getScriptParameters());\n      }\n    };\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isSpecificScriptFile(@NotNull GroovyFile script) {\n    return GRADLE_EXTENSION.equals(script.getViewProvider().getVirtualFile().getExtension());\n  }","id":45461,"modified_method":"@Override\n  public boolean isSpecificScriptFile(@NotNull GroovyFile script) {\n    return GradleConstants.EXTENSION.equals(script.getViewProvider().getVirtualFile().getExtension());\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleScriptTypeDetector() {\n    super(GradleScriptType.INSTANCE, GRADLE_EXTENSION);\n  }","id":45462,"modified_method":"public GradleScriptTypeDetector() {\n    super(GradleScriptType.INSTANCE, GradleConstants.EXTENSION);\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleSelectProjectStep(@NotNull WizardContext context) {\n    super(context);\n\n    myLabelConstraints.anchor = GridBagConstraints.WEST;\n    JLabel label = new JLabel(GradleBundle.message(\"gradle.import.label.select.project\"));\n    myComponent.add(label, myLabelConstraints);\n\n    myControlConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    myControlConstraints.weightx = 1;\n    myControlConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n    myProjectPathComponent = new TextFieldWithBrowseButton();\n    myProjectPathComponent.addBrowseFolderListener(\n      \"\",\n      GradleBundle.message(\"gradle.import.title.select.project\"),\n      null,\n      new FileTypeDescriptor(GradleBundle.message(\"gradle.import.label.select.project\"), \"gradle\")\n    );\n    myComponent.add(myProjectPathComponent, myControlConstraints);\n  }","id":45463,"modified_method":"public GradleSelectProjectStep(@NotNull WizardContext context) {\n    super(context);\n\n    myLabelConstraints.anchor = GridBagConstraints.WEST;\n    JLabel label = new JLabel(GradleBundle.message(\"gradle.import.label.select.project\"));\n    myComponent.add(label, myLabelConstraints);\n\n    myControlConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    myControlConstraints.weightx = 1;\n    myControlConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n    myProjectPathComponent = new TextFieldWithBrowseButton();\n    myProjectPathComponent.addBrowseFolderListener(\n      \"\",\n      GradleBundle.message(\"gradle.import.title.select.project\"),\n      null,\n      new OpenProjectFileChooserDescriptor(true) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          return GradleConstants.DEFAULT_SCRIPT_NAME.equals(file.getName());\n        }\n\n        @Override\n        public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n          if (!super.isFileVisible(file, showHiddenFiles)) {\n            return false;\n          }\n          return file.isDirectory() || GradleConstants.EXTENSION.equals(file.getExtension());\n        }\n      }\n    );\n    myComponent.add(myProjectPathComponent, myControlConstraints);\n  }","commit_id":"3d9ca382eac608429aa7348ee92cd9e7309c58fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private RunProfileState createRunProfileState() {\n    return new CommandLineState(null) {\n      private SimpleJavaParameters createJavaParameters() throws ExecutionException {\n        Collection<File> gradleLibraries = myGradleLibraryManager.getAllLibraries(null);\n        GradleLog.LOG.assertTrue(gradleLibraries != null, GradleBundle.message(\"gradle.generic.text.error.sdk.undefined\"));\n        if (gradleLibraries == null) {\n          throw new ExecutionException(\"Can't find gradle libraries\");\n        } \n\n        final SimpleJavaParameters params = new SimpleJavaParameters();\n        params.setJdk(new SimpleJavaSdkType().createJdk(\"tmp\", SystemProperties.getJavaHome()));\n\n        params.setWorkingDirectory(PathManager.getBinPath());\n        final ArrayList<String> classPath = new ArrayList<String>();\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(NotNull.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(StringUtil.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(THashSet.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(LanguageLevel.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(PsiBundle.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(Alarm.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(DependencyScope.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(JavaSdkVersion.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(ExtensionPointName.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(getClass()), classPath);\n        for (File library : gradleLibraries) {\n          classPath.add(library.getAbsolutePath());\n        }\n        params.getClassPath().addAll(classPath);\n        params.getClassPath().add(PathManager.getResourceRoot(getClass(), \"/messages/CommonBundle.properties\"));\n\n        params.setMainClass(MAIN_CLASS_NAME);\n        \n        params.getVMParametersList().addParametersString(\"-Djava.awt.headless=true -Xmx512m\");\n        \n        // It may take a while for gradle api to resolve external dependencies. Default RMI timeout\n        // is 15 seconds (http://download.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html#connectionTimeout),\n        // we don't want to get EOFException because of that.\n        params.getVMParametersList().addParametersString(\n          \"-Dsun.rmi.transport.connectionTimeout=\" + String.valueOf(TimeUnit.HOURS.toMillis(1))\n        );\n        //params.getVMParametersList().addParametersString(\"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5009\");\n        return params;\n      }\n\n      @Override\n      public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n        ProcessHandler processHandler = startProcess();\n        return new DefaultExecutionResult(null, processHandler, AnAction.EMPTY_ARRAY);\n      }\n\n      @NotNull\n      protected OSProcessHandler startProcess() throws ExecutionException {\n        SimpleJavaParameters params = createJavaParameters();\n        Sdk sdk = params.getJdk();\n        if (sdk == null) {\n          throw new ExecutionException(\"No sdk is defined. Params: \" + params);\n        } \n\n        final GeneralCommandLine commandLine = JdkUtil.setupJVMCommandLine(\n          ((JavaSdkType)sdk.getSdkType()).getVMExecutablePath(sdk),\n          params,\n          false // TODO den check\n        );\n        final OSProcessHandler processHandler = new OSProcessHandler(commandLine.createProcess(), commandLine.getCommandLineString()) {\n          @Override\n          public Charset getCharset() {\n            return commandLine.getCharset();\n          }\n        };\n        ProcessTerminatedListener.attach(processHandler);\n        return processHandler;\n      }\n    };\n  }","id":45464,"modified_method":"private RunProfileState createRunProfileState() {\n    return new CommandLineState(null) {\n      private SimpleJavaParameters createJavaParameters() throws ExecutionException {\n        Collection<File> gradleLibraries = myGradleLibraryManager.getAllLibraries(null);\n        GradleLog.LOG.assertTrue(gradleLibraries != null, GradleBundle.message(\"gradle.generic.text.error.sdk.undefined\"));\n        if (gradleLibraries == null) {\n          throw new ExecutionException(\"Can't find gradle libraries\");\n        } \n\n        final SimpleJavaParameters params = new SimpleJavaParameters();\n        params.setJdk(new SimpleJavaSdkType().createJdk(\"tmp\", SystemProperties.getJavaHome()));\n\n        params.setWorkingDirectory(PathManager.getBinPath());\n        final ArrayList<String> classPath = new ArrayList<String>();\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(NotNull.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(StringUtil.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(THashSet.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(LanguageLevel.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(PsiBundle.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(Alarm.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(DependencyScope.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(JavaSdkVersion.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(ExtensionPointName.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(OpenProjectFileChooserDescriptor.class), classPath);\n        ContainerUtil.addIfNotNull(PathUtil.getJarPathForClass(getClass()), classPath);\n        for (File library : gradleLibraries) {\n          classPath.add(library.getAbsolutePath());\n        }\n        params.getClassPath().addAll(classPath);\n        params.getClassPath().add(PathManager.getResourceRoot(getClass(), \"/messages/CommonBundle.properties\"));\n\n        params.setMainClass(MAIN_CLASS_NAME);\n        \n        params.getVMParametersList().addParametersString(\"-Djava.awt.headless=true -Xmx512m\");\n        \n        // It may take a while for gradle api to resolve external dependencies. Default RMI timeout\n        // is 15 seconds (http://download.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html#connectionTimeout),\n        // we don't want to get EOFException because of that.\n        params.getVMParametersList().addParametersString(\n          \"-Dsun.rmi.transport.connectionTimeout=\" + String.valueOf(TimeUnit.HOURS.toMillis(1))\n        );\n        //params.getVMParametersList().addParametersString(\"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5009\");\n        return params;\n      }\n\n      @Override\n      public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n        ProcessHandler processHandler = startProcess();\n        return new DefaultExecutionResult(null, processHandler, AnAction.EMPTY_ARRAY);\n      }\n\n      @NotNull\n      protected OSProcessHandler startProcess() throws ExecutionException {\n        SimpleJavaParameters params = createJavaParameters();\n        Sdk sdk = params.getJdk();\n        if (sdk == null) {\n          throw new ExecutionException(\"No sdk is defined. Params: \" + params);\n        } \n\n        final GeneralCommandLine commandLine = JdkUtil.setupJVMCommandLine(\n          ((JavaSdkType)sdk.getSdkType()).getVMExecutablePath(sdk),\n          params,\n          false // TODO den check\n        );\n        final OSProcessHandler processHandler = new OSProcessHandler(commandLine.createProcess(), commandLine.getCommandLineString()) {\n          @Override\n          public Charset getCharset() {\n            return commandLine.getCharset();\n          }\n        };\n        ProcessTerminatedListener.attach(processHandler);\n        return processHandler;\n      }\n    };\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initToolWindow() {\n    // TODO den don't show tool window if no gradle project is associated with the current project.\n    if (!Boolean.getBoolean(\"gradle.show.tool.window\")) {\n      return;\n    }\n    final ToolWindowManagerEx manager = ToolWindowManagerEx.getInstanceEx(myProject);\n    ToolWindow toolWindow = manager.registerToolWindow(GRADLE_TOOL_WINDOW_ID, false, ToolWindowAnchor.RIGHT);\n    toolWindow.setIcon(GradleConstants.GRADLE_ICON);\n    String syncTitle = GradleBundle.message(\"gradle.sync.title.tab\");\n    toolWindow.getContentManager().addContent(new ContentImpl(new GradleProjectStructureChangesPanel(myChangesModel), syncTitle, true)); \n  }","id":45465,"modified_method":"private void initToolWindow() {\n    // TODO den don't show tool window if no gradle project is associated with the current project.\n    if (!Boolean.getBoolean(\"gradle.show.tool.window\")) {\n      return;\n    }\n    final ToolWindowManagerEx manager = ToolWindowManagerEx.getInstanceEx(myProject);\n    ToolWindow toolWindow = manager.registerToolWindow(GRADLE_TOOL_WINDOW_ID, false, ToolWindowAnchor.RIGHT);\n    toolWindow.setIcon(GradleConstants.GRADLE_ICON);\n    String syncTitle = GradleBundle.message(\"gradle.sync.title.tab\");\n    final GradleProjectStructureChangesPanel projectStructureChanges = new GradleProjectStructureChangesPanel(myProject, myChangesModel);\n    toolWindow.getContentManager().addContent(new ContentImpl(projectStructureChanges, syncTitle, true)); \n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    // TODO den implement\n    System.out.println(\"action performed\");\n  }","id":45466,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) {\n      return;\n    }\n    final VirtualFile file = FileChooser.chooseFile(project, GradleUtil.getFileChooserDescriptor());\n    if (file == null) {\n      return;\n    }\n    GradleSettings.setLinkedProjectPath(file.getPath(), project);\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public List<Module> commit(final Project project,\n                             ModifiableModuleModel model,\n                             ModulesProvider modulesProvider,\n                             ModifiableArtifactModel artifactModel)\n  {\n    // TODO den uncomment\n    //if (!project.isInitialized()) {\n    //  StartupManager.getInstance(project).registerPostStartupActivity(new Runnable() {\n    //    @Override\n    //    public void run() {\n    //      final GradleProjectState state = project.getComponent(GradleProjectState.class);\n    //      if (state != null) {\n    //        state.GRADLE_PROJECT_FILE_PATH = myProjectFile.getAbsolutePath();\n    //      }\n    //    }\n    //  });\n    //}\n    GradleModulesImporter importer = new GradleModulesImporter();\n    Map<GradleModule, Module> mappings =\n      importer.importModules(myModuleMappings.values(), project, model, myProjectFile.getAbsolutePath(), myProgressManager);\n    return new ArrayList<Module>(mappings.values());\n  }","id":45467,"modified_method":"@Override\n  public List<Module> commit(final Project project,\n                             ModifiableModuleModel model,\n                             ModulesProvider modulesProvider,\n                             ModifiableArtifactModel artifactModel)\n  {\n    if (!project.isInitialized()) {\n      StartupManager.getInstance(project).registerPostStartupActivity(new Runnable() {\n        @Override\n        public void run() {\n          GradleSettings.setLinkedProjectPath(myProjectFile.getAbsolutePath(), project);\n        }\n      });\n    }\n    GradleModulesImporter importer = new GradleModulesImporter();\n    Map<GradleModule, Module> mappings =\n      importer.importModules(myModuleMappings.values(), project, model, myProjectFile.getAbsolutePath(), myProgressManager);\n    return new ArrayList<Module>(mappings.values());\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleProjectStructureChangesPanel(@NotNull GradleProjectStructureChangesModel model) {\n    super(GradleConstants.TOOL_WINDOW_TOOLBAR_PLACE);\n    myModel = model;\n  }","id":45468,"modified_method":"public GradleProjectStructureChangesPanel(@NotNull Project project, @NotNull GradleProjectStructureChangesModel model) {\n    super(project, GradleConstants.TOOL_WINDOW_TOOLBAR_PLACE);\n    myModel = model;\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleSelectProjectStep(@NotNull WizardContext context) {\n    super(context);\n\n    myLabelConstraints.anchor = GridBagConstraints.WEST;\n    JLabel label = new JLabel(GradleBundle.message(\"gradle.import.label.select.project\"));\n    myComponent.add(label, myLabelConstraints);\n\n    myControlConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    myControlConstraints.weightx = 1;\n    myControlConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n    myProjectPathComponent = new TextFieldWithBrowseButton();\n    myProjectPathComponent.addBrowseFolderListener(\n      \"\",\n      GradleBundle.message(\"gradle.import.title.select.project\"),\n      null,\n      new OpenProjectFileChooserDescriptor(true) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          return GradleConstants.DEFAULT_SCRIPT_NAME.equals(file.getName());\n        }\n\n        @Override\n        public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n          if (!super.isFileVisible(file, showHiddenFiles)) {\n            return false;\n          }\n          return file.isDirectory() || GradleConstants.EXTENSION.equals(file.getExtension());\n        }\n      }\n    );\n    myComponent.add(myProjectPathComponent, myControlConstraints);\n  }","id":45469,"modified_method":"public GradleSelectProjectStep(@NotNull WizardContext context) {\n    super(context);\n\n    myLabelConstraints.anchor = GridBagConstraints.WEST;\n    JLabel label = new JLabel(GradleBundle.message(\"gradle.import.label.select.project\"));\n    myComponent.add(label, myLabelConstraints);\n\n    myControlConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    myControlConstraints.weightx = 1;\n    myControlConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n    myProjectPathComponent = new TextFieldWithBrowseButton();\n    myProjectPathComponent.addBrowseFolderListener(\n      \"\",\n      GradleBundle.message(\"gradle.import.title.select.project\"),\n      null,\n      GradleUtil.getFileChooserDescriptor()\n    );\n    myComponent.add(myProjectPathComponent, myControlConstraints);\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return \"home: \" + GRADLE_HOME;\n  }","id":45470,"modified_method":"@Override\n  public String toString() {\n    return \"home: \" + GRADLE_HOME + \", path: \" + LINKED_PROJECT_FILE_PATH;\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected GradleToolWindowPanel(@NotNull String place) {\n    super(true);\n    final ActionManager actionManager = ActionManager.getInstance();\n    final ActionGroup actionGroup = (ActionGroup)actionManager.getAction(TOOL_WINDOW_TOOLBAR_ID);\n    ActionToolbar actionToolbar = actionManager.createActionToolbar(place, actionGroup, true);\n    setToolbar(actionToolbar.getComponent());\n    myNonLinkedInfoPanel = initContent();\n    setContent(myContent);\n  }","id":45471,"modified_method":"protected GradleToolWindowPanel(@NotNull Project project, @NotNull String place) {\n    super(true);\n    myProject = project;\n    final ActionManager actionManager = ActionManager.getInstance();\n    final ActionGroup actionGroup = (ActionGroup)actionManager.getAction(TOOL_WINDOW_TOOLBAR_ID);\n    ActionToolbar actionToolbar = actionManager.createActionToolbar(place, actionGroup, true);\n    setToolbar(actionToolbar.getComponent());\n    initContent();\n    setContent(myContent);\n    update();\n\n    MessageBusConnection connection = project.getMessageBus().connect(project);\n    connection.subscribe(GradleConfigNotifier.TOPIC, new GradleConfigNotifier() {\n      @Override\n      public void onLinkedProjectPathChange(@Nullable String oldPath, @Nullable String newPath) {\n        update();\n      }\n    });\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent initContent() {\n    final JComponent payloadControl = buildContent();\n    myContent.add(ScrollPaneFactory.createScrollPane(payloadControl), CONTENT_CARD_NAME);\n    RichTextControlBuilder builder = new RichTextControlBuilder();\n    builder.setBackgroundColor(payloadControl.getBackground());\n    builder.setForegroundColor(payloadControl.getForeground());\n    builder.setFont(payloadControl.getFont());\n    builder.setText(GradleBundle.message(\"gradle.toolwindow.text.no.linked.project\"));\n    final JComponent result = builder.build();\n    myContent.add(result, NON_LINKED_CARD_NAME);\n    myLayout.show(myContent, NON_LINKED_CARD_NAME);\n    return result;\n  }","id":45472,"modified_method":"private void initContent() {\n    final JComponent payloadControl = buildContent();\n    myContent.add(ScrollPaneFactory.createScrollPane(payloadControl), CONTENT_CARD_NAME);\n    RichTextControlBuilder builder = new RichTextControlBuilder();\n    builder.setBackgroundColor(payloadControl.getBackground());\n    builder.setForegroundColor(payloadControl.getForeground());\n    builder.setFont(payloadControl.getFont());\n    builder.setText(GradleBundle.message(\"gradle.toolwindow.text.no.linked.project\"));\n    final JComponent noLinkedProjectControl = builder.build();\n    myContent.add(noLinkedProjectControl, NON_LINKED_CARD_NAME);\n  }","commit_id":"5380fa72f7eea8ad70ca71c24e8eccc6efc934d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public HTMLWrapperParameters getHTMLWrapperParameters() {\n    if (!myHtmlWrapperTypeComboBox.isEnabled()) {\n      // it means that module and/or SDK are not selected properly yet\n      return null;\n    }\n\n    // HTML wrapper root dir\n    final VirtualFile htmlWrapperRootDir = (VirtualFile)myHtmlWrapperTypeComboBox.getSelectedItem();\n    if (htmlWrapperRootDir == null) {\n      myCurrentErrorMessage = \"Select HTML wrapper type\";\n      return null;\n    }\n\n    // HTML wrapper file name\n    final String htmlWrapperFileName = myHtmlWrapperFileNameTextField.getText();\n    if (htmlWrapperFileName.length() == 0) {\n      myCurrentErrorMessage = \"Specify HTML wrapper file name\";\n      return null;\n    }\n    if (!VirtualFile.isValidName(htmlWrapperFileName)) {\n      myCurrentErrorMessage = \"Invalid HTML wrapper file name\";\n      return null;\n    }\n\n    // HTML wrapper file location\n    final String htmlWrapperLocationPath = myHtmlWrapperFileLocationTextWithBrowse.getText();\n    final VirtualFile htmlWrapperFileLocation = LocalFileSystem.getInstance().refreshAndFindFileByPath(htmlWrapperLocationPath);\n    if (htmlWrapperLocationPath.trim().length() == 0 || htmlWrapperFileLocation == null) {\n      myCurrentErrorMessage = \"Choose existing directory for HTML wrapper\";\n      return null;\n    }\n\n    // HTML page title\n    final String htmlPageTitle = myHTMLPageTitleTextField.getText();\n\n    // Flex application name\n    final String flexAppName = myFlexApplicationNameTextField.getText().trim();\n    if (flexAppName.length() == 0) {\n      myCurrentErrorMessage = \"Specify Flex application name\";\n      return null;\n    }\n\n    // SWF file which is wrapped\n    final String swfFileName = mySWFFileNameTextField.getText();\n    if (swfFileName.length() == 0) {\n      myCurrentErrorMessage = \"Specify SWF file to wrap\";\n      return null;\n    }\n    if (swfFileName.length() < 5 || !swfFileName.endsWith(\".swf\")) {\n      myCurrentErrorMessage = \"SWF file must have '.swf' extension\";\n      return null;\n    }\n    final String swfFileNameWithoutExtension = swfFileName.substring(0, swfFileName.lastIndexOf('.'));\n\n    // application width and height\n    final String width = myWidthTextField.getText();\n    final String height = myHeightTextField.getText();\n\n    // background color\n    final String bgColor = myBgColorTextField.getText();\n\n    // minimal flash player version\n    int playerVersionMajor = 0;\n    int playerVersionMinor = 0;\n    int playerVersionRevision = 0;\n\n    if (myFlashPlayerVersionForm.isEnabled()) {\n      try {\n        playerVersionMajor = Integer.parseInt(myFlashPlayerVersionForm.getPlayerVersionMajor());\n        playerVersionMinor = Integer.parseInt(myFlashPlayerVersionForm.getPlayerVersionMinor());\n        playerVersionRevision = Integer.parseInt(myFlashPlayerVersionForm.getPlayerVersionRevision());\n      }\n      catch (NumberFormatException e) {\n        myCurrentErrorMessage = \"Flash player version is invalid\";\n        return null;\n      }\n    }\n\n    myCurrentErrorMessage = null;\n    return new HTMLWrapperParameters(htmlWrapperRootDir, htmlWrapperFileName, htmlWrapperFileLocation, htmlPageTitle, flexAppName,\n                                     swfFileNameWithoutExtension, width, height, bgColor, playerVersionMajor, playerVersionMinor,\n                                     playerVersionRevision);\n  }","id":45473,"modified_method":"@Nullable\n  public HTMLWrapperParameters getHTMLWrapperParameters() {\n    if (!myHtmlWrapperTypeComboBox.isEnabled()) {\n      // it means that module and/or SDK are not selected properly yet\n      return null;\n    }\n\n    // HTML wrapper root dir\n    final VirtualFile htmlWrapperRootDir = (VirtualFile)myHtmlWrapperTypeComboBox.getSelectedItem();\n    if (htmlWrapperRootDir == null) {\n      myCurrentErrorMessage = \"Select HTML wrapper type\";\n      return null;\n    }\n\n    // HTML wrapper file name\n    final String htmlWrapperFileName = myHtmlWrapperFileNameTextField.getText();\n    if (htmlWrapperFileName.length() == 0) {\n      myCurrentErrorMessage = \"Specify HTML wrapper file name\";\n      return null;\n    }\n    if (!VirtualFile.isValidName(htmlWrapperFileName)) {\n      myCurrentErrorMessage = \"Invalid HTML wrapper file name\";\n      return null;\n    }\n\n    // HTML wrapper file location\n    final String htmlWrapperLocationPath = myHtmlWrapperFileLocationTextWithBrowse.getText().trim();\n    if (htmlWrapperLocationPath.isEmpty()) {\n      myCurrentErrorMessage = \"Choose folder to place generated HTML wrapper\";\n      return null;\n    }\n    final VirtualFile htmlWrapperFileLocation = LocalFileSystem.getInstance().findFileByPath(htmlWrapperLocationPath);\n    if (htmlWrapperFileLocation == null) {\n      myCurrentErrorMessage = \"Choose existing directory for HTML wrapper\";\n      return null;\n    }\n\n    // HTML page title\n    final String htmlPageTitle = myHTMLPageTitleTextField.getText();\n\n    // Flex application name\n    final String flexAppName = myFlexApplicationNameTextField.getText().trim();\n    if (flexAppName.length() == 0) {\n      myCurrentErrorMessage = \"Specify Flex application name\";\n      return null;\n    }\n\n    // SWF file which is wrapped\n    final String swfFileName = mySWFFileNameTextField.getText();\n    if (swfFileName.length() == 0) {\n      myCurrentErrorMessage = \"Specify SWF file to wrap\";\n      return null;\n    }\n    if (swfFileName.length() < 5 || !swfFileName.endsWith(\".swf\")) {\n      myCurrentErrorMessage = \"SWF file must have '.swf' extension\";\n      return null;\n    }\n    final String swfFileNameWithoutExtension = swfFileName.substring(0, swfFileName.lastIndexOf('.'));\n\n    // application width and height\n    final String width = myWidthTextField.getText();\n    final String height = myHeightTextField.getText();\n\n    // background color\n    final String bgColor = myBgColorTextField.getText();\n\n    // minimal flash player version\n    int playerVersionMajor = 0;\n    int playerVersionMinor = 0;\n    int playerVersionRevision = 0;\n\n    if (myFlashPlayerVersionForm.isEnabled()) {\n      try {\n        playerVersionMajor = Integer.parseInt(myFlashPlayerVersionForm.getPlayerVersionMajor());\n        playerVersionMinor = Integer.parseInt(myFlashPlayerVersionForm.getPlayerVersionMinor());\n        playerVersionRevision = Integer.parseInt(myFlashPlayerVersionForm.getPlayerVersionRevision());\n      }\n      catch (NumberFormatException e) {\n        myCurrentErrorMessage = \"Flash player version is invalid\";\n        return null;\n      }\n    }\n\n    myCurrentErrorMessage = null;\n    return new HTMLWrapperParameters(htmlWrapperRootDir, htmlWrapperFileName, htmlWrapperFileLocation, htmlPageTitle, flexAppName,\n                                     swfFileNameWithoutExtension, width, height, bgColor, playerVersionMajor, playerVersionMinor,\n                                     playerVersionRevision);\n  }","commit_id":"02569a73e258507b23cdbfb70c3ca08c9749d012","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void setupHtmlWrapperFileLocationTextField(final Project project) {\n    myHtmlWrapperFileLocationTextWithBrowse.addBrowseFolderListener(\"Choose location for HTML wrapper\", \"\", project,\n                                                                    FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                                    new TextComponentAccessor<JTextField>() {\n                                                                      public String getText(final JTextField textField) {\n                                                                        return textField.getText();\n                                                                      }\n\n                                                                      public void setText(final JTextField textField, final String text) {\n                                                                        textField.setText(text.replace('\\\\', '/'));\n                                                                      }\n                                                                    });\n    myHtmlWrapperFileLocationTextWithBrowse.getTextField().getDocument().addDocumentListener(documentListener);\n  }","id":45474,"modified_method":"private void setupHtmlWrapperFileLocationTextField(final Project project) {\n    myHtmlWrapperFileLocationTextWithBrowse.addBrowseFolderListener(\"Choose folder to place generated HTML wrapper\", null, project,\n                                                                    FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    myHtmlWrapperFileLocationTextWithBrowse.getTextField().getDocument().addDocumentListener(documentListener);\n  }","commit_id":"02569a73e258507b23cdbfb70c3ca08c9749d012","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void setModuleAndSdkAndWrapperLocation(final Module module, final Sdk flexSdk, final String htmlWrapperFileLocation) {\n    myModuleComboBox.setModel(new DefaultComboBoxModel(new Module[]{module}));\n    myFlexSdkComboWithBrowse.setSelectedSdkRaw(flexSdk.getName());\n    updateSdkAndSubsequentControls();\n    myHtmlWrapperFileLocationTextWithBrowse.setText(htmlWrapperFileLocation);\n    fireStateChanged();\n  }","id":45475,"modified_method":"public void setModuleAndSdkAndWrapperLocation(final Module module, final Sdk flexSdk, final String htmlWrapperFileLocation) {\n    myModuleComboBox.setModel(new DefaultComboBoxModel(new Module[]{module}));\n    myFlexSdkComboWithBrowse.setSelectedSdkRaw(flexSdk.getName());\n    updateSdkAndSubsequentControls();\n    myHtmlWrapperFileLocationTextWithBrowse.setText(FileUtil.toSystemDependentName(htmlWrapperFileLocation));\n    fireStateChanged();\n  }","commit_id":"02569a73e258507b23cdbfb70c3ca08c9749d012","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void suggestHTMLWrapperProperties(final Module module) {\n    // suggest HTML wrapper file name\n    myHtmlWrapperFileNameTextField.setText(module.getName().replaceAll(\"[^\\\\p{Alnum}]\", \"_\") + \".html\");\n\n    // suggest HTML wrapper file location\n    final VirtualFile[] srcRoots = ModuleRootManager.getInstance(module).getSourceRoots();\n    if (srcRoots.length > 0) {\n      myHtmlWrapperFileLocationTextWithBrowse.setText(srcRoots[0].getPath());\n    }\n    else {\n      final VirtualFile moduleFile = module.getModuleFile();\n      if (moduleFile != null) {\n        myHtmlWrapperFileLocationTextWithBrowse.setText(moduleFile.getParent().getPath());\n      }\n    }\n\n    // suggest HTML page title, application name and swf file name\n    String outputFileName = \"\";\n    for (FlexBuildConfiguration config : FlexBuildConfiguration.getConfigForFlexModuleOrItsFlexFacets(module)) {\n      if (!config.USE_CUSTOM_CONFIG_FILE && config.OUTPUT_FILE_NAME.endsWith(\".swf\")) {\n        outputFileName = config.OUTPUT_FILE_NAME;\n        break;\n      }\n    }\n\n    final String htmlPageAndFlexAppName;\n    if (outputFileName.length() > 0) {\n      if (outputFileName.indexOf('.') > 0) {\n        htmlPageAndFlexAppName = outputFileName.substring(0, outputFileName.indexOf('.'));\n      }\n      else {\n        htmlPageAndFlexAppName = outputFileName;\n      }\n    }\n    else {\n      htmlPageAndFlexAppName = module.getName();\n    }\n    myHTMLPageTitleTextField.setText(htmlPageAndFlexAppName);\n    myFlexApplicationNameTextField.setText(htmlPageAndFlexAppName);\n    mySWFFileNameTextField.setText(outputFileName);\n\n    final Sdk flexSdk = FlexUtils.getFlexSdkForFlexModuleOrItsFlexFacets(module);\n    suggestPlayerVersion(flexSdk);\n  }","id":45476,"modified_method":"private void suggestHTMLWrapperProperties(final Module module) {\n    // suggest HTML wrapper file name\n    myHtmlWrapperFileNameTextField.setText(module.getName().replaceAll(\"[^\\\\p{Alnum}]\", \"_\") + \".html\");\n\n    // suggest HTML wrapper file location\n    final VirtualFile[] srcRoots = ModuleRootManager.getInstance(module).getSourceRoots();\n    if (srcRoots.length > 0) {\n      myHtmlWrapperFileLocationTextWithBrowse.setText(FileUtil.toSystemDependentName(srcRoots[0].getPath()));\n    }\n    else {\n      final VirtualFile moduleFile = module.getModuleFile();\n      if (moduleFile != null) {\n        myHtmlWrapperFileLocationTextWithBrowse.setText(FileUtil.toSystemDependentName(moduleFile.getParent().getPath()));\n      }\n    }\n\n    // suggest HTML page title, application name and swf file name\n    String outputFileName = \"\";\n    for (FlexBuildConfiguration config : FlexBuildConfiguration.getConfigForFlexModuleOrItsFlexFacets(module)) {\n      if (!config.USE_CUSTOM_CONFIG_FILE && config.OUTPUT_FILE_NAME.endsWith(\".swf\")) {\n        outputFileName = config.OUTPUT_FILE_NAME;\n        break;\n      }\n    }\n\n    final String htmlPageAndFlexAppName;\n    if (outputFileName.length() > 0) {\n      if (outputFileName.indexOf('.') > 0) {\n        htmlPageAndFlexAppName = outputFileName.substring(0, outputFileName.indexOf('.'));\n      }\n      else {\n        htmlPageAndFlexAppName = outputFileName;\n      }\n    }\n    else {\n      htmlPageAndFlexAppName = module.getName();\n    }\n    myHTMLPageTitleTextField.setText(htmlPageAndFlexAppName);\n    myFlexApplicationNameTextField.setText(htmlPageAndFlexAppName);\n    mySWFFileNameTextField.setText(outputFileName);\n\n    final Sdk flexSdk = FlexUtils.getFlexSdkForFlexModuleOrItsFlexFacets(module);\n    suggestPlayerVersion(flexSdk);\n  }","commit_id":"02569a73e258507b23cdbfb70c3ca08c9749d012","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected boolean shouldInclude(Declaration decl){\n        return includeNonShared || decl.isShared();\n    }","id":45477,"modified_method":"protected boolean shouldInclude(Declaration decl) {\n        if (!includeNonShared && !decl.isShared()) {\n            return false;\n        }\n        if (decl.isNative() && !decl.isNativeHeader()) {\n            return false;\n        }\n        return true;\n    }","commit_id":"33f5b9384850bd350146672183a569825408d856","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= Decl.isShared(cdecl) ? PUBLIC : 0;\n        result |= (cdecl.isAbstract() || cdecl.isFormal()) && (cdecl instanceof Class) ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() && (cdecl instanceof Class) ? FINAL : 0;\n\n        return result;\n    }","id":45478,"modified_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= Decl.isShared(cdecl) && !Decl.isAncestorLocal(cdecl) ? PUBLIC : 0;\n        result |= (cdecl.isAbstract() || cdecl.isFormal()) && (cdecl instanceof Class) ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() && (cdecl instanceof Class) ? FINAL : 0;\n\n        return result;\n    }","commit_id":"30d80826e9a7f5be5d9e9f73d790f2907d7104c4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int transformObjectDeclFlags(Tree.ObjectDefinition cdecl) {\n        int result = 0;\n\n        result |= FINAL;\n        result |= Decl.isShared(cdecl) ? PUBLIC : 0;\n\n        return result;\n    }","id":45479,"modified_method":"private int transformObjectDeclFlags(Tree.ObjectDefinition cdecl) {\n        int result = 0;\n\n        result |= FINAL;\n        result |= !Decl.isAncestorLocal(cdecl) && Decl.isShared(cdecl) ? PUBLIC : 0;\n\n        return result;\n    }","commit_id":"89d3a065248ff813abe3dc6ed35383fa0eca6de9","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter addFilter, MapZooms mapZooms,\n\t\t\tMapRenderingTypes renderingTypes) throws IOException, SAXException, SQLException {\n\t\tif (renderingTypes == null) {\n\t\t\trenderingTypes = MapRenderingTypes.getDefault();\n\t\t}\n\t\tif (mapZooms == null) {\n\t\t\tmapZooms = MapZooms.getDefault();\n\t\t}\n\n\t\t// clear previous results and setting variables\n\t\tif (readFile != null && regionName == null) {\n\t\t\tint i = readFile.getName().indexOf('.');\n\t\t\tif (i > -1) {\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(readFile.getName().substring(0, i));\n\t\t\t}\n\t\t}\n\t\tthis.indexTransportCreator = new IndexTransportCreator();\n\t\tthis.indexPoiCreator = new IndexPoiCreator();\n\t\tthis.indexAddressCreator = new IndexAddressCreator();\n\t\tthis.indexMapCreator = new IndexVectorMapCreator();\n\t\tthis.accessor = new OsmDbAccessor();\n\t\t\n\n\t\tindexMapCreator.initSettings(mapZooms, renderingTypes, zoomWaySmothness);\n\n\t\t// init address\n\t\tString[] normalizeDefaultSuffixes = null;\n\t\tString[] normalizeSuffixes = null;\n\t\tif (normalizeStreets) {\n\t\t\tnormalizeDefaultSuffixes = DataExtractionSettings.getSettings().getDefaultSuffixesToNormalizeStreets();\n\t\t\tnormalizeSuffixes = DataExtractionSettings.getSettings().getSuffixesToNormalizeStreets();\n\t\t}\n\t\tindexAddressCreator.initSettings(normalizeStreets, normalizeDefaultSuffixes, normalizeSuffixes, saveAddressWays, cityAdminLevel);\n\n\t\t// Main generation method\n\t\ttry {\n\t\t\t// ////////////////////////////////////////////////////////////////////////\n\t\t\t// 1. creating nodes db to fast access for all nodes and simply import all relations, ways, nodes to it\n\t\t\tboolean loadFromExistingFile = createPlainOsmDb(progress, readFile, addFilter);\n\t\t\t\n\t\t\t// do not create temp map file and rtree files\n\t\t\tif (recreateOnlyBinaryFile) {\n\t\t\t\tmapFile = new File(workingDir, getMapFileName());\n\t\t\t\tFile tempDBMapFile = new File(workingDir, getTempMapDBFileName());\n\t\t\t\tmapConnection = getDatabaseConnection(tempDBMapFile.getAbsolutePath());\n\t\t\t\tmapConnection.setAutoCommit(false);\n\t\t\t\ttry {\n\t\t\t\t\tif (indexMap) {\n\t\t\t\t\t\tindexMapCreator.createRTreeFiles(getRTreeMapIndexPackFileName());\n\t\t\t\t\t}\n\t\t\t\t\tif (indexTransport) {\n\t\t\t\t\t\tindexTransportCreator.createRTreeFile(getRTreeTransportStopsPackFileName());\n\t\t\t\t\t}\n\t\t\t\t} catch (RTreeException e) {\n\t\t\t\t\tlog.error(\"Error flushing\", e); //$NON-NLS-1$\n\t\t\t\t\tthrow new IOException(e);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// 2. Create index connections and index structure\n\t\t\t\tcreateDatabaseIndexesStructure();\n\n\t\t\t\t// 3. Processing all entries\n\t\t\t\t\n\t\t\t\t// 3.1 write all cities\n\t\t\t\tif (indexAddress) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_CITIES\"), accessor.getAllNodes()); //$NON-NLS-1$\n\t\t\t\t\tif (loadFromExistingFile) {\n\t\t\t\t\t\t// load cities names\n\t\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.NODE,  new OsmDbVisitor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) {\n\t\t\t\t\t\t\t\tindexAddressCreator.registerCityIfNeeded(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tindexAddressCreator.writeCitiesIntoDb();\n\t\t\t\t}\n\n\t\t\t\t// 3.2 index address relations\n\t\t\t\tif (indexAddress || indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[30 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PREINDEX_ADRESS_MAP\"), accessor.getAllRelations()); //$NON-NLS-1$\n\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.RELATION, new OsmDbVisitor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\tif (indexAddress) {\n\t\t\t\t\t\t\t\tindexAddressCreator.indexAddressRelation((Relation) e, ctx);\n\t\t\t\t\t\t\t\tindexAddressCreator.indexBoundariesRelation((Relation) e, ctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (indexMap) {\n\t\t\t\t\t\t\t\tindexMapCreator.indexMapRelationsAndMultiPolygons(e, ctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (indexAddress) {\n\t\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PREINDEX_ADRESS_MAP\"), accessor.getAllWays()); //$NON-NLS-1$\n\t\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.WAY, new OsmDbVisitor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\t\tindexAddressCreator.indexBoundariesRelation(e, ctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tindexAddressCreator.commitToPutAllCities();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 3.3 MAIN iterate over all entities\n\t\t\t\tif (indexPOI || indexAddress || indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[50 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_NODES\"), accessor.getAllNodes());\n\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.NODE, new OsmDbVisitor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\titerateMainEntity(e, ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tprogress.setGeneralProgress(\"[70 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_WAYS\"), accessor.getAllWays());\n\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.WAY, new OsmDbVisitor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\titerateMainEntity(e, ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tprogress.setGeneralProgress(\"[85 / 100]\");\n\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_REL\"), accessor.getAllRelations());\n\t\t\t\taccessor.iterateOverEntities(progress, EntityType.RELATION, new OsmDbVisitor() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\titerateMainEntity(e, ctx);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// 3.4 combine all low level ways and simplify them\n\t\t\t\tif (indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_LO_LEVEL_WAYS\"), indexMapCreator.getLowLevelWays());\n\t\t\t\t\tindexMapCreator.processingLowLevelWays(progress);\n\t\t\t\t}\n\n\t\t\t\t// 3.5 update all postal codes from relations\n\t\t\t\tif (indexAddress) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.REGISTER_PCODES\"), -1);\n\t\t\t\t\tindexAddressCreator.processingPostcodes();\n\t\t\t\t}\n\n\t\t\t\t// 4. packing map rtree indexes\n\t\t\t\tif (indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_MAP\"), -1); //$NON-NLS-1$\n\t\t\t\t\tindexMapCreator.packRtreeFiles(getRTreeMapIndexNonPackFileName(), getRTreeMapIndexPackFileName());\n\t\t\t\t}\n\n\t\t\t\tif (indexTransport) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_TRANSP\"), -1); //$NON-NLS-1$\n\t\t\t\t\tindexTransportCreator.packRTree(getRTreeTransportStopsFileName(), getRTreeTransportStopsPackFileName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 5. Writing binary file\n\t\t\tif (indexMap || indexAddress || indexTransport) {\n\t\t\t\tif (mapFile.exists()) {\n\t\t\t\t\tmapFile.delete();\n\t\t\t\t}\n\t\t\t\tmapRAFile = new RandomAccessFile(mapFile, \"rw\");\n\t\t\t\tBinaryMapIndexWriter writer = new BinaryMapIndexWriter(mapRAFile);\n\t\t\t\tif (indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\n\t\t\t\t\tprogress.startTask(\"Writing map index to binary file...\", -1);\n\t\t\t\t\tindexMapCreator.writeBinaryMapIndex(writer, regionName);\n\t\t\t\t}\n\n\t\t\t\tif (indexAddress) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\n\t\t\t\t\tprogress.startTask(\"Writing address index to binary file...\", -1);\n\t\t\t\t\tindexAddressCreator.writeBinaryAddressIndex(writer, regionName, progress);\n\t\t\t\t}\n\n\t\t\t\tif (indexTransport) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\n\t\t\t\t\tprogress.startTask(\"Writing transport index to binary file...\", -1);\n\t\t\t\t\tindexTransportCreator.writeBinaryTransportIndex(writer, regionName, mapConnection);\n\t\t\t\t}\n\t\t\t\tprogress.finishTask();\n\t\t\t\twriter.close();\n\t\t\t\tmapRAFile.close();\n\t\t\t\tlog.info(\"Finish writing binary file\"); //$NON-NLS-1$\n\t\t\t}\n\t\t} catch (RuntimeException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} catch (SQLException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} catch (SAXException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\taccessor.closeReadingConnection();\n\n\t\t\t\tindexPoiCreator.commitAndClosePoiFile(lastModifiedDate);\n\t\t\t\tindexAddressCreator.closeAllPreparedStatements();\n\t\t\t\tindexTransportCreator.commitAndCloseFiles(getRTreeTransportStopsFileName(), getRTreeTransportStopsPackFileName(),\n\t\t\t\t\t\tdeleteDatabaseIndexes);\n\t\t\t\tindexMapCreator.commitAndCloseFiles(getRTreeMapIndexNonPackFileName(), getRTreeMapIndexPackFileName(),\n\t\t\t\t\t\tdeleteDatabaseIndexes);\n\n\t\t\t\tif (mapConnection != null) {\n\t\t\t\t\tmapConnection.commit();\n\t\t\t\t\tmapConnection.close();\n\t\t\t\t\tmapConnection = null;\n\t\t\t\t\tFile tempDBFile = new File(workingDir, getTempMapDBFileName());\n\t\t\t\t\tif (dialect.databaseFileExists(tempDBFile) && deleteDatabaseIndexes) {\n\t\t\t\t\t\t// do not delete it for now\n\t\t\t\t\t\tdialect.removeDatabase(tempDBFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// do not delete first db connection\n\t\t\t\tif (dbConn != null) {\n\t\t\t\t\tif (DBDialect.H2 == dialect) {\n\t\t\t\t\t\tdbConn.createStatement().execute(\"SHUTDOWN COMPACT\"); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tdbConn.close();\n\t\t\t\t}\n\t\t\t\tif (deleteOsmDB) {\n\t\t\t\t\tif (DBDialect.DERBY == dialect) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tDriverManager.getConnection(\"jdbc:derby:;shutdown=true\"); //$NON-NLS-1$\n\t\t\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\t\t// ignore exception\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdialect.removeDatabase(dbFile);\n\t\t\t\t}\n\t\t\t} catch (SQLException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":45480,"modified_method":"public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter addFilter, MapZooms mapZooms,\n\t\t\tMapRenderingTypes renderingTypes) throws IOException, SAXException, SQLException {\n\t\tif (renderingTypes == null) {\n\t\t\trenderingTypes = MapRenderingTypes.getDefault();\n\t\t}\n\t\tif (mapZooms == null) {\n\t\t\tmapZooms = MapZooms.getDefault();\n\t\t}\n\n\t\t// clear previous results and setting variables\n\t\tif (readFile != null && regionName == null) {\n\t\t\tint i = readFile.getName().indexOf('.');\n\t\t\tif (i > -1) {\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(readFile.getName().substring(0, i));\n\t\t\t}\n\t\t}\n\t\tthis.indexTransportCreator = new IndexTransportCreator();\n\t\tthis.indexPoiCreator = new IndexPoiCreator();\n\t\tthis.indexAddressCreator = new IndexAddressCreator();\n\t\tthis.indexMapCreator = new IndexVectorMapCreator();\n\t\tthis.accessor = new OsmDbAccessor();\n\t\t\n\n\t\tindexMapCreator.initSettings(mapZooms, renderingTypes, zoomWaySmothness);\n\n\t\t// init address\n\t\tString[] normalizeDefaultSuffixes = null;\n\t\tString[] normalizeSuffixes = null;\n\t\tif (normalizeStreets) {\n\t\t\tnormalizeDefaultSuffixes = DataExtractionSettings.getSettings().getDefaultSuffixesToNormalizeStreets();\n\t\t\tnormalizeSuffixes = DataExtractionSettings.getSettings().getSuffixesToNormalizeStreets();\n\t\t}\n\t\tindexAddressCreator.initSettings(normalizeStreets, normalizeDefaultSuffixes, normalizeSuffixes, saveAddressWays, cityAdminLevel);\n\n\t\t// Main generation method\n\t\ttry {\n\t\t\t// ////////////////////////////////////////////////////////////////////////\n\t\t\t// 1. creating nodes db to fast access for all nodes and simply import all relations, ways, nodes to it\n\t\t\tboolean loadFromExistingFile = createPlainOsmDb(progress, readFile, addFilter);\n\t\t\t\n\t\t\t// do not create temp map file and rtree files\n\t\t\tif (recreateOnlyBinaryFile) {\n\t\t\t\tmapFile = new File(workingDir, getMapFileName());\n\t\t\t\tFile tempDBMapFile = new File(workingDir, getTempMapDBFileName());\n\t\t\t\tmapConnection = (Connection) getDatabaseConnection(tempDBMapFile.getAbsolutePath(), mapDBDialect);\n\t\t\t\tmapConnection.setAutoCommit(false);\n\t\t\t\ttry {\n\t\t\t\t\tif (indexMap) {\n\t\t\t\t\t\tindexMapCreator.createRTreeFiles(getRTreeMapIndexPackFileName());\n\t\t\t\t\t}\n\t\t\t\t\tif (indexTransport) {\n\t\t\t\t\t\tindexTransportCreator.createRTreeFile(getRTreeTransportStopsPackFileName());\n\t\t\t\t\t}\n\t\t\t\t} catch (RTreeException e) {\n\t\t\t\t\tlog.error(\"Error flushing\", e); //$NON-NLS-1$\n\t\t\t\t\tthrow new IOException(e);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// 2. Create index connections and index structure\n\t\t\t\tcreateDatabaseIndexesStructure();\n\n\t\t\t\t// 3. Processing all entries\n\t\t\t\t\n\t\t\t\t// 3.1 write all cities\n\t\t\t\tif (indexAddress) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_CITIES\"), accessor.getAllNodes()); //$NON-NLS-1$\n\t\t\t\t\tif (loadFromExistingFile) {\n\t\t\t\t\t\t// load cities names\n\t\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.NODE,  new OsmDbVisitor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) {\n\t\t\t\t\t\t\t\tindexAddressCreator.registerCityIfNeeded(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tindexAddressCreator.writeCitiesIntoDb();\n\t\t\t\t}\n\n\t\t\t\t// 3.2 index address relations\n\t\t\t\tif (indexAddress || indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[30 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PREINDEX_ADRESS_MAP\"), accessor.getAllRelations()); //$NON-NLS-1$\n\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.RELATION, new OsmDbVisitor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\tif (indexAddress) {\n\t\t\t\t\t\t\t\tindexAddressCreator.indexAddressRelation((Relation) e, ctx);\n\t\t\t\t\t\t\t\tindexAddressCreator.indexBoundariesRelation((Relation) e, ctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (indexMap) {\n\t\t\t\t\t\t\t\tindexMapCreator.indexMapRelationsAndMultiPolygons(e, ctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (indexAddress) {\n\t\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PREINDEX_ADRESS_MAP\"), accessor.getAllWays()); //$NON-NLS-1$\n\t\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.WAY, new OsmDbVisitor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\t\tindexAddressCreator.indexBoundariesRelation(e, ctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tindexAddressCreator.commitToPutAllCities();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 3.3 MAIN iterate over all entities\n\t\t\t\tif (indexPOI || indexAddress || indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[50 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_NODES\"), accessor.getAllNodes());\n\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.NODE, new OsmDbVisitor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\titerateMainEntity(e, ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tprogress.setGeneralProgress(\"[70 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_WAYS\"), accessor.getAllWays());\n\t\t\t\t\taccessor.iterateOverEntities(progress, EntityType.WAY, new OsmDbVisitor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\t\titerateMainEntity(e, ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tprogress.setGeneralProgress(\"[85 / 100]\");\n\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_REL\"), accessor.getAllRelations());\n\t\t\t\taccessor.iterateOverEntities(progress, EntityType.RELATION, new OsmDbVisitor() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void iterateEntity(Entity e, OsmDbAccessorContext ctx) throws SQLException {\n\t\t\t\t\t\titerateMainEntity(e, ctx);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// 3.4 combine all low level ways and simplify them\n\t\t\t\tif (indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_LO_LEVEL_WAYS\"), indexMapCreator.getLowLevelWays());\n\t\t\t\t\tindexMapCreator.processingLowLevelWays(progress);\n\t\t\t\t}\n\n\t\t\t\t// 3.5 update all postal codes from relations\n\t\t\t\tif (indexAddress) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\");\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.REGISTER_PCODES\"), -1);\n\t\t\t\t\tindexAddressCreator.processingPostcodes();\n\t\t\t\t}\n\n\t\t\t\t// 4. packing map rtree indexes\n\t\t\t\tif (indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_MAP\"), -1); //$NON-NLS-1$\n\t\t\t\t\tindexMapCreator.packRtreeFiles(getRTreeMapIndexNonPackFileName(), getRTreeMapIndexPackFileName());\n\t\t\t\t}\n\n\t\t\t\tif (indexTransport) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_TRANSP\"), -1); //$NON-NLS-1$\n\t\t\t\t\tindexTransportCreator.packRTree(getRTreeTransportStopsFileName(), getRTreeTransportStopsPackFileName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 5. Writing binary file\n\t\t\tif (indexMap || indexAddress || indexTransport) {\n\t\t\t\tif (mapFile.exists()) {\n\t\t\t\t\tmapFile.delete();\n\t\t\t\t}\n\t\t\t\tmapRAFile = new RandomAccessFile(mapFile, \"rw\");\n\t\t\t\tBinaryMapIndexWriter writer = new BinaryMapIndexWriter(mapRAFile);\n\t\t\t\tif (indexMap) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\n\t\t\t\t\tprogress.startTask(\"Writing map index to binary file...\", -1);\n\t\t\t\t\tindexMapCreator.writeBinaryMapIndex(writer, regionName);\n\t\t\t\t}\n\n\t\t\t\tif (indexAddress) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\n\t\t\t\t\tprogress.startTask(\"Writing address index to binary file...\", -1);\n\t\t\t\t\tindexAddressCreator.writeBinaryAddressIndex(writer, regionName, progress);\n\t\t\t\t}\n\n\t\t\t\tif (indexTransport) {\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\n\t\t\t\t\tprogress.startTask(\"Writing transport index to binary file...\", -1);\n\t\t\t\t\tindexTransportCreator.writeBinaryTransportIndex(writer, regionName, mapConnection);\n\t\t\t\t}\n\t\t\t\tprogress.finishTask();\n\t\t\t\twriter.close();\n\t\t\t\tmapRAFile.close();\n\t\t\t\tlog.info(\"Finish writing binary file\"); //$NON-NLS-1$\n\t\t\t}\n\t\t} catch (RuntimeException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} catch (SQLException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} catch (SAXException e) {\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\taccessor.closeReadingConnection();\n\n\t\t\t\tindexPoiCreator.commitAndClosePoiFile(lastModifiedDate);\n\t\t\t\tindexAddressCreator.closeAllPreparedStatements();\n\t\t\t\tindexTransportCreator.commitAndCloseFiles(getRTreeTransportStopsFileName(), getRTreeTransportStopsPackFileName(),\n\t\t\t\t\t\tdeleteDatabaseIndexes);\n\t\t\t\tindexMapCreator.commitAndCloseFiles(getRTreeMapIndexNonPackFileName(), getRTreeMapIndexPackFileName(),\n\t\t\t\t\t\tdeleteDatabaseIndexes);\n\n\t\t\t\tif (mapConnection != null) {\n\t\t\t\t\tmapConnection.commit();\n\t\t\t\t\tmapConnection.close();\n\t\t\t\t\tmapConnection = null;\n\t\t\t\t\tFile tempDBFile = new File(workingDir, getTempMapDBFileName());\n\t\t\t\t\tif (mapDBDialect.databaseFileExists(tempDBFile) && deleteDatabaseIndexes) {\n\t\t\t\t\t\t// do not delete it for now\n\t\t\t\t\t\tmapDBDialect.removeDatabase(tempDBFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// do not delete first db connection\n\t\t\t\tif (dbConn != null) {\n\t\t\t\t\tdialect.commitDatabase(dbConn);\n\t\t\t\t}\n\t\t\t\tif (deleteOsmDB) {\n\t\t\t\t\tif (DBDialect.DERBY == dialect) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tDriverManager.getConnection(\"jdbc:derby:;shutdown=true\"); //$NON-NLS-1$\n\t\t\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\t\t// ignore exception\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdialect.removeDatabase(dbFile);\n\t\t\t\t}\n\t\t\t} catch (SQLException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void main(String[] args) throws IOException, SAXException, SQLException {\n\t\t\n\t\tlong time = System.currentTimeMillis();\n\t\tIndexCreator creator = new IndexCreator(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/\")); //$NON-NLS-1$\n\t\tcreator.setIndexMap(true);\n//\t\tcreator.setIndexAddress(true);\n//\t\tcreator.setIndexPOI(true);\n//\t\tcreator.setIndexTransport(true);\n\t\t// for NL\n//\t\tcreator.setCityAdminLevel(\"10\");\n\n\t\tcreator.recreateOnlyBinaryFile = false;\n\t\tcreator.deleteDatabaseIndexes = true;\n//\t\tcreator.deleteOsmDB = true;\n\t\t\t\t\n\t\tcreator.setZoomWaySmothness(2);\n\t\tMapRenderingTypes rt = new MapRenderingTypes(\"/home/victor/projects/OsmAnd/data/testdata/roads_rendering_types.xml\");\n\t\tMapZooms zooms = MapZooms.parseZooms(\"15-\");\n\t\tcreator.setNodesDBFile(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/nodes.tmp.odb\"));\n\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/data/belarus-osm/belarus.osm.pbf\"),\n\t\t\t\tnew ConsoleProgressImplementation(1), null, zooms, rt);\n\t\t\n//\t\tcreator.setNodesDBFile(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/nodes3.tmp.odb\"));\n//\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/data/osm-maps/stadion-dynamo.osm\"),\n//\t\t\t\tnew ConsoleProgressImplementation(1), null, MapZooms.getDefault(), null);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t// world generation\n//\t\tMapZooms mapZooms = new MapZooms();\n//\t\tMapZoomPair pair1 = new MapZooms.MapZoomPair(1, 3);\n//\t\tMapZoomPair pair2 = new MapZooms.MapZoomPair(4, 5);\n//\t\tMapZoomPair pair3 = new MapZooms.MapZoomPair(6, 7);\n//\t\t\n//\t\tmapZooms.setLevels(Arrays.asList(pair1, pair2, pair3));\n//\t\t// for coastline\n//\t\tcreator.setZoomWaySmothness(2);\n//\t\tcreator.generateIndexes(new File(\n//\t\t\t\t\"/home/victor/projects/OsmAnd/download/basemap/basemap_1.osm\"\n//\t\t\t\t), \n//\t\t\t\tnew ConsoleProgressImplementation(1), null, mapZooms, null);\n\t\t\n\t\t\n\n\t\tSystem.out.println(\"WHOLE GENERATION TIME :  \" + (System.currentTimeMillis() - time)); //$NON-NLS-1$\n\t\t System.out.println(\"COORDINATES_SIZE \" + BinaryMapIndexWriter.COORDINATES_SIZE + \" count \" + BinaryMapIndexWriter.COORDINATES_COUNT); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tSystem.out.println(\"TYPES_SIZE \" + BinaryMapIndexWriter.TYPES_SIZE); //$NON-NLS-1$\n\t\tSystem.out.println(\"ID_SIZE \" + BinaryMapIndexWriter.ID_SIZE); //$NON-NLS-1$\n\t\t System.out.println(\"- COORD_TYPES_ID SIZE \" + (BinaryMapIndexWriter.COORDINATES_SIZE + BinaryMapIndexWriter.TYPES_SIZE + BinaryMapIndexWriter.ID_SIZE)); //$NON-NLS-1$\n\t\tSystem.out.println(\"- MAP_DATA_SIZE \" + BinaryMapIndexWriter.MAP_DATA_SIZE); //$NON-NLS-1$\n\t\tSystem.out.println(\"- STRING_TABLE_SIZE \" + BinaryMapIndexWriter.STRING_TABLE_SIZE); //$NON-NLS-1$\n\t\tSystem.out.println(\"-- MAP_DATA_AND_STRINGS SIZE \" + (BinaryMapIndexWriter.MAP_DATA_SIZE + BinaryMapIndexWriter.STRING_TABLE_SIZE)); //$NON-NLS-1$\n\n\t}","id":45481,"modified_method":"public static void main(String[] args) throws IOException, SAXException, SQLException {\n\t\t\n\t\tlong time = System.currentTimeMillis();\n\t\tIndexCreator creator = new IndexCreator(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/\")); //$NON-NLS-1$\n\t\tcreator.setIndexMap(true);\n\t\tcreator.setIndexAddress(true);\n\t\tcreator.setIndexPOI(true);\n\t\tcreator.setIndexTransport(true);\n\t\t// for NL\n//\t\tcreator.setCityAdminLevel(\"10\");\n\n\t\tcreator.recreateOnlyBinaryFile = false;\n\t\tcreator.deleteDatabaseIndexes = true;\n//\t\tcreator.deleteOsmDB = true;\n\t\t\t\t\n\t\tcreator.setZoomWaySmothness(2);\n\t\tMapRenderingTypes rt = MapRenderingTypes.getDefault();// new MapRenderingTypes(\"/home/victor/projects/OsmAnd/data/testdata/roads_rendering_types.xml\");\n\t\tMapZooms zooms = MapZooms.getDefault(); // MapZooms.parseZooms(\"15-\");\n//\t\tcreator.setNodesDBFile(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/nodes.tmp.odb\"));\n\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/data/belarus-osm/belarus.osm.pbf\"),\n\t\t\t\tnew ConsoleProgressImplementation(1), null, zooms, rt);\n\t\t\n//\t\tcreator.setNodesDBFile(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/nodes3.tmp.odb\"));\n//\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/data/osm-maps/stadion-dynamo.osm\"),\n//\t\t\t\tnew ConsoleProgressImplementation(1), null, MapZooms.getDefault(), null);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t// world generation\n//\t\tMapZooms mapZooms = new MapZooms();\n//\t\tMapZoomPair pair1 = new MapZooms.MapZoomPair(1, 3);\n//\t\tMapZoomPair pair2 = new MapZooms.MapZoomPair(4, 5);\n//\t\tMapZoomPair pair3 = new MapZooms.MapZoomPair(6, 7);\n//\t\t\n//\t\tmapZooms.setLevels(Arrays.asList(pair1, pair2, pair3));\n//\t\t// for coastline\n//\t\tcreator.setZoomWaySmothness(2);\n//\t\tcreator.generateIndexes(new File(\n//\t\t\t\t\"/home/victor/projects/OsmAnd/download/basemap/basemap_1.osm\"\n//\t\t\t\t), \n//\t\t\t\tnew ConsoleProgressImplementation(1), null, mapZooms, null);\n\t\t\n\t\t\n\n\t\tSystem.out.println(\"WHOLE GENERATION TIME :  \" + (System.currentTimeMillis() - time)); //$NON-NLS-1$\n\t\t System.out.println(\"COORDINATES_SIZE \" + BinaryMapIndexWriter.COORDINATES_SIZE + \" count \" + BinaryMapIndexWriter.COORDINATES_COUNT); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tSystem.out.println(\"TYPES_SIZE \" + BinaryMapIndexWriter.TYPES_SIZE); //$NON-NLS-1$\n\t\tSystem.out.println(\"ID_SIZE \" + BinaryMapIndexWriter.ID_SIZE); //$NON-NLS-1$\n\t\t System.out.println(\"- COORD_TYPES_ID SIZE \" + (BinaryMapIndexWriter.COORDINATES_SIZE + BinaryMapIndexWriter.TYPES_SIZE + BinaryMapIndexWriter.ID_SIZE)); //$NON-NLS-1$\n\t\tSystem.out.println(\"- MAP_DATA_SIZE \" + BinaryMapIndexWriter.MAP_DATA_SIZE); //$NON-NLS-1$\n\t\tSystem.out.println(\"- STRING_TABLE_SIZE \" + BinaryMapIndexWriter.STRING_TABLE_SIZE); //$NON-NLS-1$\n\t\tSystem.out.println(\"-- MAP_DATA_AND_STRINGS SIZE \" + (BinaryMapIndexWriter.MAP_DATA_SIZE + BinaryMapIndexWriter.STRING_TABLE_SIZE)); //$NON-NLS-1$\n\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private Connection getDatabaseConnection(String fileName) throws SQLException {\n\t\treturn dialect.getDatabaseConnection(fileName, log);\n\t}","id":45482,"modified_method":"private Object getDatabaseConnection(String fileName, DBDialect dialect) throws SQLException {\n\t\treturn dialect.getDatabaseConnection(fileName, log);\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void createDatabaseIndexesStructure() throws SQLException, IOException {\n\t\t// 2.1 create temporary sqlite database to put temporary results to it\n\t\tif (indexMap || indexAddress || indexTransport) {\n\t\t\tmapFile = new File(workingDir, getMapFileName());\n\t\t\t// to save space\n\t\t\tmapFile.getParentFile().mkdirs();\n\t\t\tFile tempDBMapFile = new File(workingDir, getTempMapDBFileName());\n\t\t\tdialect.removeDatabase(tempDBMapFile);\n\t\t\tmapConnection = getDatabaseConnection(tempDBMapFile.getAbsolutePath());\n\t\t\tmapConnection.setAutoCommit(false);\n\t\t}\n\n\t\t// 2.2 create rtree map\n\t\tif (indexMap) {\n\t\t\tindexMapCreator.createDatabaseStructure(mapConnection, dialect, getRTreeMapIndexNonPackFileName());\n\t\t}\n\t\tif (indexAddress) {\n\t\t\tindexAddressCreator.createDatabaseStructure(mapConnection, dialect);\n\t\t}\n\t\tif (indexPOI) {\n\t\t\tindexPoiCreator.createDatabaseStructure(new File(workingDir, getPoiFileName()));\n\t\t}\n\t\tif (indexTransport) {\n\t\t\tindexTransportCreator.createDatabaseStructure(mapConnection, dialect, getRTreeTransportStopsFileName());\n\t\t}\n\t}","id":45483,"modified_method":"private void createDatabaseIndexesStructure() throws SQLException, IOException {\n\t\t// 2.1 create temporary sqlite database to put temporary results to it\n\t\tif (indexMap || indexAddress || indexTransport) {\n\t\t\tmapFile = new File(workingDir, getMapFileName());\n\t\t\t// to save space\n\t\t\tmapFile.getParentFile().mkdirs();\n\t\t\tFile tempDBMapFile = new File(workingDir, getTempMapDBFileName());\n\t\t\tmapDBDialect.removeDatabase(tempDBMapFile);\n\t\t\tmapConnection = (Connection) getDatabaseConnection(tempDBMapFile.getAbsolutePath(), mapDBDialect);\n\t\t\tmapConnection.setAutoCommit(false);\n\t\t}\n\n\t\t// 2.2 create rtree map\n\t\tif (indexMap) {\n\t\t\tindexMapCreator.createDatabaseStructure(mapConnection, mapDBDialect, getRTreeMapIndexNonPackFileName());\n\t\t}\n\t\tif (indexAddress) {\n\t\t\tindexAddressCreator.createDatabaseStructure(mapConnection, mapDBDialect);\n\t\t}\n\t\tif (indexPOI) {\n\t\t\tindexPoiCreator.createDatabaseStructure(new File(workingDir, getPoiFileName()));\n\t\t}\n\t\tif (indexTransport) {\n\t\t\tindexTransportCreator.createDatabaseStructure(mapConnection, mapDBDialect, getRTreeTransportStopsFileName());\n\t\t}\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private boolean createPlainOsmDb(IProgress progress, File readFile, IOsmStorageFilter addFilter) throws SQLException, FileNotFoundException, IOException, SAXException{\n\t\t// initialize db file\n\t\tboolean loadFromExistingFile = dbFile != null && dialect.databaseFileExists(dbFile);\n\t\tif (dbFile == null) {\n\t\t\tdbFile = new File(workingDir, TEMP_NODES_DB);\n\t\t\t// to save space\n\t\t\tif (dialect.databaseFileExists(dbFile)) {\n\t\t\t\tdialect.removeDatabase(dbFile);\n\t\t\t}\n\t\t}\n\t\tdbConn = getDatabaseConnection(dbFile.getAbsolutePath());\n\t\tint allRelations = 100000;\n\t\tint allWays = 1000000;\n\t\tint allNodes = 10000000;\n\t\tif (!loadFromExistingFile) {\n\t\t\tOsmDbCreator dbCreator = extractOsmToNodesDB(readFile, progress, addFilter);\n\t\t\tif (dbCreator != null) {\n\t\t\t\tallNodes = dbCreator.getAllNodes();\n\t\t\t\tallWays = dbCreator.getAllWays();\n\t\t\t\tallRelations = dbCreator.getAllRelations();\n\t\t\t}\n\t\t}\n\t\taccessor.initDatabase(dbConn, allNodes, allWays, allRelations);\n\t\treturn loadFromExistingFile;\n\t}","id":45484,"modified_method":"private boolean createPlainOsmDb(IProgress progress, File readFile, IOsmStorageFilter addFilter) throws SQLException, FileNotFoundException, IOException, SAXException{\n\t\t// initialize db file\n\t\tboolean loadFromExistingFile = dbFile != null && dialect.databaseFileExists(dbFile);\n\t\tif (dbFile == null) {\n\t\t\tdbFile = new File(workingDir, TEMP_NODES_DB);\n\t\t\t// to save space\n\t\t\tif (dialect.databaseFileExists(dbFile)) {\n\t\t\t\tdialect.removeDatabase(dbFile);\n\t\t\t}\n\t\t}\n\t\tdbConn = getDatabaseConnection(dbFile.getAbsolutePath(), dialect);\n\t\tint allRelations = 100000;\n\t\tint allWays = 1000000;\n\t\tint allNodes = 10000000;\n\t\tif (!loadFromExistingFile) {\n\t\t\tOsmDbCreator dbCreator = extractOsmToNodesDB(readFile, progress, addFilter);\n\t\t\tif (dbCreator != null) {\n\t\t\t\tallNodes = dbCreator.getAllNodes();\n\t\t\t\tallWays = dbCreator.getAllWays();\n\t\t\t\tallRelations = dbCreator.getAllRelations();\n\t\t\t}\n\t\t}\n\t\taccessor.initDatabase(dbConn, dialect, allNodes, allWays, allRelations);\n\t\treturn loadFromExistingFile;\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private OsmDbCreator extractOsmToNodesDB(File readFile, IProgress progress, IOsmStorageFilter addFilter) throws FileNotFoundException,\n\t\t\tIOException, SQLException, SAXException {\n\t\tboolean pbfFile = false;\n\t\tInputStream stream = new BufferedInputStream(new FileInputStream(readFile), 8192 * 4);\n\t\tInputStream streamFile = stream;\n\t\tlong st = System.currentTimeMillis();\n\t\tif (readFile.getName().endsWith(\".bz2\")) { //$NON-NLS-1$\n\t\t\tif (stream.read() != 'B' || stream.read() != 'Z') {\n\t\t\t\tthrow new RuntimeException(\"The source stream must start with the characters BZ if it is to be read as a BZip2 stream.\"); //$NON-NLS-1$\n\t\t\t} else {\n\t\t\t\tstream = new CBZip2InputStream(stream);\n\t\t\t}\n\t\t} else if (readFile.getName().endsWith(\".pbf\")) { //$NON-NLS-1$\n\t\t\tpbfFile = true;\n\t\t}\n\n\t\tOsmBaseStorage storage = new OsmBaseStorage();\n\t\tstorage.setSupressWarnings(DataExtractionSettings.getSettings().isSupressWarningsForDuplicatedId());\n\t\tif (addFilter != null) {\n\t\t\tstorage.getFilters().add(addFilter);\n\t\t}\n\t\t\n\t\tstorage.getFilters().add(new IOsmStorageFilter() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean acceptEntityToLoad(OsmBaseStorage storage, EntityId entityId, Entity entity) {\n\t\t\t\tindexAddressCreator.registerCityIfNeeded(entity);\n\t\t\t\t// accept to allow db creator parse it\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\t// 1. Loading osm file\n\t\tOsmDbCreator dbCreator = new OsmDbCreator(this);\n\t\ttry {\n\t\t\tprogress.setGeneralProgress(\"[35 / 100]\"); //$NON-NLS-1$\n\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.LOADING_FILE\") + readFile.getAbsolutePath(), -1); //$NON-NLS-1$\n\t\t\t// 1 init database to store temporary data\n\t\t\tdbCreator.initDatabase(dialect, dbConn);\n\t\t\tstorage.getFilters().add(dbCreator);\n\t\t\tif (pbfFile) {\n\t\t\t\tstorage.parseOSMPbf(stream, progress, false);\n\t\t\t} else {\n\t\t\t\tstorage.parseOSM(stream, progress, streamFile, false);\n\t\t\t}\n\t\t\tdbCreator.finishLoading();\n\t\t\tdbConn.commit();\n\n\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\tlog.info(\"File parsed : \" + (System.currentTimeMillis() - st)); //$NON-NLS-1$\n\t\t\t}\n\t\t\tprogress.finishTask();\n\t\t\treturn dbCreator;\n\t\t} finally {\n\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\tlog.info(\"File indexed : \" + (System.currentTimeMillis() - st)); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t}","id":45485,"modified_method":"private OsmDbCreator extractOsmToNodesDB(File readFile, IProgress progress, IOsmStorageFilter addFilter) throws FileNotFoundException,\n\t\t\tIOException, SQLException, SAXException {\n\t\tboolean pbfFile = false;\n\t\tInputStream stream = new BufferedInputStream(new FileInputStream(readFile), 8192 * 4);\n\t\tInputStream streamFile = stream;\n\t\tlong st = System.currentTimeMillis();\n\t\tif (readFile.getName().endsWith(\".bz2\")) { //$NON-NLS-1$\n\t\t\tif (stream.read() != 'B' || stream.read() != 'Z') {\n\t\t\t\tthrow new RuntimeException(\"The source stream must start with the characters BZ if it is to be read as a BZip2 stream.\"); //$NON-NLS-1$\n\t\t\t} else {\n\t\t\t\tstream = new CBZip2InputStream(stream);\n\t\t\t}\n\t\t} else if (readFile.getName().endsWith(\".pbf\")) { //$NON-NLS-1$\n\t\t\tpbfFile = true;\n\t\t}\n\n\t\tOsmBaseStorage storage = new OsmBaseStorage();\n\t\tstorage.setSupressWarnings(DataExtractionSettings.getSettings().isSupressWarningsForDuplicatedId());\n\t\tif (addFilter != null) {\n\t\t\tstorage.getFilters().add(addFilter);\n\t\t}\n\t\t\n\t\tstorage.getFilters().add(new IOsmStorageFilter() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean acceptEntityToLoad(OsmBaseStorage storage, EntityId entityId, Entity entity) {\n\t\t\t\tindexAddressCreator.registerCityIfNeeded(entity);\n\t\t\t\t// accept to allow db creator parse it\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\t// 1. Loading osm file\n\t\tOsmDbCreator dbCreator = new OsmDbCreator(this);\n\t\ttry {\n\t\t\tprogress.setGeneralProgress(\"[35 / 100]\"); //$NON-NLS-1$\n\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.LOADING_FILE\") + readFile.getAbsolutePath(), -1); //$NON-NLS-1$\n\t\t\t// 1 init database to store temporary data\n\t\t\tdbCreator.initDatabase(dialect, dbConn);\n\t\t\tstorage.getFilters().add(dbCreator);\n\t\t\tif (pbfFile) {\n\t\t\t\tstorage.parseOSMPbf(stream, progress, false);\n\t\t\t} else {\n\t\t\t\tstorage.parseOSM(stream, progress, streamFile, false);\n\t\t\t}\n\t\t\tdbCreator.finishLoading();\n\t\t\tdialect.commitDatabase(dbConn);\n\n\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\tlog.info(\"File parsed : \" + (System.currentTimeMillis() - st)); //$NON-NLS-1$\n\t\t\t}\n\t\t\tprogress.finishTask();\n\t\t\treturn dbCreator;\n\t\t} finally {\n\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\tlog.info(\"File indexed : \" + (System.currentTimeMillis() - st)); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void createDatabaseStructure(File poiIndexFile) throws SQLException {\n\t\tthis.poiIndexFile = poiIndexFile;\n\t\t// delete previous file to save space\n\t\tif (poiIndexFile.exists()) {\n\t\t\tAlgoritms.removeAllFiles(poiIndexFile);\n\t\t}\n\t\tpoiIndexFile.getParentFile().mkdirs();\n\t\t// creating connection\n\t\tpoiConnection = DBDialect.SQLITE.getDatabaseConnection(poiIndexFile.getAbsolutePath(), log);\n\t\t\n\t\t// create database structure\n\t\tStatement stat = poiConnection.createStatement();\n        stat.executeUpdate(\"create table \" + IndexConstants.POI_TABLE +  //$NON-NLS-1$\n        \t\t\"(id bigint, x int, y int, name_en varchar(255), name varchar(255), \" +\n        \t\t\"type varchar(255), subtype varchar(255), opening_hours varchar(255), phone varchar(255), site varchar(255),\" +\n        \t\t\"primary key(id, type, subtype))\");\n        stat.executeUpdate(\"create index poi_loc on poi (x, y, type, subtype)\");\n        stat.executeUpdate(\"create index poi_id on poi (id, type, subtype)\");\n        stat.execute(\"PRAGMA user_version = \" + IndexConstants.POI_TABLE_VERSION); //$NON-NLS-1$\n        stat.close();\n        \n        // create prepared statment\n\t\tpoiPreparedStatement = poiConnection\n\t\t\t\t.prepareStatement(\"INSERT INTO \" + IndexConstants.POI_TABLE + \"(id, x, y, name_en, name, type, subtype, opening_hours, site, phone) \" + //$NON-NLS-1$//$NON-NLS-2$\n\t\t\t\t\t\t\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n\t\tpStatements.put(poiPreparedStatement, 0);\n\t\t\n\t\t\n\t\tpoiConnection.setAutoCommit(false);\n\t}","id":45486,"modified_method":"public void createDatabaseStructure(File poiIndexFile) throws SQLException {\n\t\tthis.poiIndexFile = poiIndexFile;\n\t\t// delete previous file to save space\n\t\tif (poiIndexFile.exists()) {\n\t\t\tAlgoritms.removeAllFiles(poiIndexFile);\n\t\t}\n\t\tpoiIndexFile.getParentFile().mkdirs();\n\t\t// creating connection\n\t\tpoiConnection = (Connection) DBDialect.SQLITE.getDatabaseConnection(poiIndexFile.getAbsolutePath(), log);\n\t\t\n\t\t// create database structure\n\t\tStatement stat = poiConnection.createStatement();\n        stat.executeUpdate(\"create table \" + IndexConstants.POI_TABLE +  //$NON-NLS-1$\n        \t\t\"(id bigint, x int, y int, name_en varchar(255), name varchar(255), \" +\n        \t\t\"type varchar(255), subtype varchar(255), opening_hours varchar(255), phone varchar(255), site varchar(255),\" +\n        \t\t\"primary key(id, type, subtype))\");\n        stat.executeUpdate(\"create index poi_loc on poi (x, y, type, subtype)\");\n        stat.executeUpdate(\"create index poi_id on poi (id, type, subtype)\");\n        stat.execute(\"PRAGMA user_version = \" + IndexConstants.POI_TABLE_VERSION); //$NON-NLS-1$\n        stat.close();\n        \n        // create prepared statment\n\t\tpoiPreparedStatement = poiConnection\n\t\t\t\t.prepareStatement(\"INSERT INTO \" + IndexConstants.POI_TABLE + \"(id, x, y, name_en, name, type, subtype, opening_hours, site, phone) \" + //$NON-NLS-1$//$NON-NLS-2$\n\t\t\t\t\t\t\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n\t\tpStatements.put(poiPreparedStatement, 0);\n\t\t\n\t\t\n\t\tpoiConnection.setAutoCommit(false);\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void loadEntityData(Entity e, boolean loadTags) throws SQLException {\n\t\tif (e instanceof Node || (e instanceof Way && !((Way) e).getNodes().isEmpty())) {\n\t\t\t// do not load tags for nodes inside way\n\t\t\treturn;\n\t\t}\n\t\tMap<EntityId, Entity> map = new LinkedHashMap<EntityId, Entity>();\n\t\tif (e instanceof Relation && ((Relation) e).getMemberIds().isEmpty()) {\n\t\t\tpselectRelation.setLong(1, e.getId());\n\t\t\tif (pselectRelation.execute()) {\n\t\t\t\tResultSet rs = pselectRelation.getResultSet();\n\t\t\t\tboolean first = true;\n\t\t\t\twhile (rs.next()) {\n\t\t\t\t\tint ord = rs.getInt(4);\n\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t((Relation) e).addMember(rs.getLong(1), EntityType.values()[rs.getInt(2)], rs.getString(3));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t}\n\t\t} else if (e instanceof Way && ((Way) e).getEntityIds().isEmpty()) {\n\t\t\tpselectWay.setLong(1, e.getId());\n\t\t\tif (pselectWay.execute()) {\n\t\t\t\tResultSet rs = pselectWay.getResultSet();\n\t\t\t\tboolean first = true;\n\t\t\t\twhile (rs.next()) {\n\t\t\t\t\tint ord = rs.getInt(2);\n\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t((Way) e).addNode(new Node(rs.getDouble(5), rs.getDouble(6), rs.getLong(1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t}\n\t\t}\n\t\tCollection<EntityId> ids = e instanceof Relation ? ((Relation) e).getMemberIds() : ((Way) e).getEntityIds();\n\n\t\tfor (EntityId i : ids) {\n\t\t\t// pselectNode = dbConn.prepareStatement(\"select n.latitude, n.longitude, t.skeys, t.value from node n left join tags t on n.id = t.id and t.type = 0 where n.id = ?\");\n\t\t\tif (i.getType() == EntityType.NODE) {\n\t\t\t\tpselectNode.setLong(1, i.getId());\n\t\t\t\tif (pselectNode.execute()) {\n\t\t\t\t\tResultSet rs = pselectNode.getResultSet();\n\t\t\t\t\tNode n = null;\n\t\t\t\t\twhile (rs.next()) {\n\t\t\t\t\t\tif (n == null) {\n\t\t\t\t\t\t\tn = new Node(rs.getDouble(1), rs.getDouble(2), i.getId());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rs.getObject(3) != null) {\n\t\t\t\t\t\t\tn.putTag(rs.getString(3), rs.getString(4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmap.put(i, n);\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t} else if (i.getType() == EntityType.WAY) {\n\t\t\t\t// pselectWay = dbConn.prepareStatement(\"select w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" +\n\t\t\t\t// \"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" +\n\t\t\t\t// \"where w.id = ? order by w.ord\");\n\t\t\t\tpselectWay.setLong(1, i.getId());\n\t\t\t\tif (pselectWay.execute()) {\n\t\t\t\t\tResultSet rs = pselectWay.getResultSet();\n\t\t\t\t\tWay way = new Way(i.getId());\n\t\t\t\t\tmap.put(i, way);\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\twhile (rs.next()) {\n\t\t\t\t\t\tint ord = rs.getInt(2);\n\t\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\tway.addNode(new Node(rs.getDouble(5), rs.getDouble(6), rs.getLong(1)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ord == 0 && rs.getObject(3) != null) {\n\t\t\t\t\t\t\tway.putTag(rs.getString(3), rs.getString(4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t} else if (i.getType() == EntityType.RELATION) {\n\t\t\t\tpselectRelation.setLong(1, i.getId());\n\t\t\t\t// pselectRelation = dbConn.prepareStatement(\"select r.member, r.type, r.role, r.ord, t.skeys, t.value\" +\n\t\t\t\t// \"from relations r left join tags t on r.id = t.id and t.type = 2 and r.ord = 0 \" +\n\t\t\t\t// \"where r.id = ? order by r.ord\");\n\t\t\t\tif (pselectRelation.execute()) {\n\t\t\t\t\tResultSet rs = pselectRelation.getResultSet();\n\t\t\t\t\tRelation rel = new Relation(i.getId());\n\t\t\t\t\tmap.put(i, rel);\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\twhile (rs.next()) {\n\t\t\t\t\t\tint ord = rs.getInt(4);\n\t\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\trel.addMember(rs.getLong(1), EntityType.values()[rs.getInt(2)], rs.getString(3));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ord == 0 && rs.getObject(5) != null) {\n\t\t\t\t\t\t\trel.putTag(rs.getString(5), rs.getString(6));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// do not load relation members recursively ? It is not needed for transport, address, poi before\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\te.initializeLinks(map);\n\t}","id":45487,"modified_method":"public void loadEntityData(Entity e, boolean loadTags) throws SQLException {\n\t\tif (e instanceof Node || (e instanceof Way && !((Way) e).getNodes().isEmpty())) {\n\t\t\t// do not load tags for nodes inside way\n\t\t\treturn;\n\t\t}\n\t\tif(dialect == DBDialect.NOSQL){\n\t\t\tloadEntityDataNoSQL(e, loadTags);\n\t\t}\n\t\t\n\t\tMap<EntityId, Entity> map = new LinkedHashMap<EntityId, Entity>();\n\t\tif (e instanceof Relation && ((Relation) e).getMemberIds().isEmpty()) {\n\t\t\tpselectRelation.setLong(1, e.getId());\n\t\t\tif (pselectRelation.execute()) {\n\t\t\t\tResultSet rs = pselectRelation.getResultSet();\n\t\t\t\tboolean first = true;\n\t\t\t\twhile (rs.next()) {\n\t\t\t\t\tint ord = rs.getInt(4);\n\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t((Relation) e).addMember(rs.getLong(1), EntityType.values()[rs.getInt(2)], rs.getString(3));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t}\n\t\t} else if (e instanceof Way && ((Way) e).getEntityIds().isEmpty()) {\n\t\t\tpselectWay.setLong(1, e.getId());\n\t\t\tif (pselectWay.execute()) {\n\t\t\t\tResultSet rs = pselectWay.getResultSet();\n\t\t\t\tboolean first = true;\n\t\t\t\twhile (rs.next()) {\n\t\t\t\t\tint ord = rs.getInt(2);\n\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t((Way) e).addNode(new Node(rs.getDouble(5), rs.getDouble(6), rs.getLong(1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t}\n\t\t}\n\t\tCollection<EntityId> ids = e instanceof Relation ? ((Relation) e).getMemberIds() : ((Way) e).getEntityIds();\n\n\t\tfor (EntityId i : ids) {\n\t\t\t// pselectNode = dbConn.prepareStatement(\"select n.latitude, n.longitude, t.skeys, t.value from node n left join tags t on n.id = t.id and t.type = 0 where n.id = ?\");\n\t\t\tif (i.getType() == EntityType.NODE) {\n\t\t\t\tpselectNode.setLong(1, i.getId());\n\t\t\t\tif (pselectNode.execute()) {\n\t\t\t\t\tResultSet rs = pselectNode.getResultSet();\n\t\t\t\t\tNode n = null;\n\t\t\t\t\twhile (rs.next()) {\n\t\t\t\t\t\tif (n == null) {\n\t\t\t\t\t\t\tn = new Node(rs.getDouble(1), rs.getDouble(2), i.getId());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rs.getObject(3) != null) {\n\t\t\t\t\t\t\tn.putTag(rs.getString(3), rs.getString(4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmap.put(i, n);\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t} else if (i.getType() == EntityType.WAY) {\n\t\t\t\t// pselectWay = dbConn.prepareStatement(\"select w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" +\n\t\t\t\t// \"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" +\n\t\t\t\t// \"where w.id = ? order by w.ord\");\n\t\t\t\tpselectWay.setLong(1, i.getId());\n\t\t\t\tif (pselectWay.execute()) {\n\t\t\t\t\tResultSet rs = pselectWay.getResultSet();\n\t\t\t\t\tWay way = new Way(i.getId());\n\t\t\t\t\tmap.put(i, way);\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\twhile (rs.next()) {\n\t\t\t\t\t\tint ord = rs.getInt(2);\n\t\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\tway.addNode(new Node(rs.getDouble(5), rs.getDouble(6), rs.getLong(1)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ord == 0 && rs.getObject(3) != null) {\n\t\t\t\t\t\t\tway.putTag(rs.getString(3), rs.getString(4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t} else if (i.getType() == EntityType.RELATION) {\n\t\t\t\tpselectRelation.setLong(1, i.getId());\n\t\t\t\t// pselectRelation = dbConn.prepareStatement(\"select r.member, r.type, r.role, r.ord, t.skeys, t.value\" +\n\t\t\t\t// \"from relations r left join tags t on r.id = t.id and t.type = 2 and r.ord = 0 \" +\n\t\t\t\t// \"where r.id = ? order by r.ord\");\n\t\t\t\tif (pselectRelation.execute()) {\n\t\t\t\t\tResultSet rs = pselectRelation.getResultSet();\n\t\t\t\t\tRelation rel = new Relation(i.getId());\n\t\t\t\t\tmap.put(i, rel);\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\twhile (rs.next()) {\n\t\t\t\t\t\tint ord = rs.getInt(4);\n\t\t\t\t\t\tif (ord > 0 || first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\trel.addMember(rs.getLong(1), EntityType.values()[rs.getInt(2)], rs.getString(3));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ord == 0 && rs.getObject(5) != null) {\n\t\t\t\t\t\t\trel.putTag(rs.getString(5), rs.getString(6));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// do not load relation members recursively ? It is not needed for transport, address, poi before\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\te.initializeLinks(map);\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public int iterateOverEntities(IProgress progress, EntityType type, OsmDbVisitor visitor) throws SQLException {\n\t\tStatement statement = dbConn.createStatement();\n\t\tString select;\n\t\tint count = 0;\n\n\t\t// stat.executeUpdate(\"create table tags (id \"+longType+\", type smallint, skeys varchar(255), value varchar(255))\");\n\t\t// stat.executeUpdate(\"create table ways (id \"+longType+\", node \"+longType+\", ord smallint)\");\n//\t\tstat.executeUpdate(\"create table relations (id \"+longType+\", member \"+longType+\", type smallint, role varchar(255), ord smallint)\");\n\t\tif (type == EntityType.NODE) {\n\t\t\t// filter out all nodes without tags\n\t\t\tselect = \"select n.id, n.latitude, n.longitude, t.skeys, t.value from node n inner join tags t on n.id = t.id and t.type = 0 order by n.id\"; //$NON-NLS-1$\n\t\t} else if (type == EntityType.WAY) {\n\t\t\tselect = \"select w.id, w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" + //$NON-NLS-1$\n\t\t\t\t\t\"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" + //$NON-NLS-1$\n\t\t\t\t\t\"order by w.id, w.ord\"; //$NON-NLS-1$\n\t\t} else {\n\t\t\tselect = \"select r.id, t.skeys, t.value  from relations r inner join tags t on t.id = r.id and t.type = 2 and r.ord = 0\"; //$NON-NLS-1$\n\t\t}\n\n\t\tResultSet rs = statement.executeQuery(select);\n\t\tEntity prevEntity = null;\n\n\t\tlong prevId = -1;\n\t\twhile (rs.next()) {\n\t\t\tlong curId = rs.getLong(1);\n\t\t\tboolean newEntity = curId != prevId;\n\t\t\tEntity e = prevEntity;\n\t\t\tif (type == EntityType.NODE) {\n\t\t\t\tif (newEntity) {\n\t\t\t\t\te = new Node(rs.getDouble(2), rs.getDouble(3), curId);\n\t\t\t\t}\n\t\t\t\te.putTag(rs.getString(4), rs.getString(5));\n\t\t\t} else if (type == EntityType.WAY) {\n\t\t\t\tif (newEntity) {\n\t\t\t\t\te = new Way(curId);\n\t\t\t\t}\n\t\t\t\tint ord = rs.getInt(3);\n\t\t\t\tif (ord == 0 && rs.getObject(4) != null) {\n\t\t\t\t\te.putTag(rs.getString(4), rs.getString(5));\n\t\t\t\t}\n\t\t\t\tif (newEntity || ord > 0) {\n\t\t\t\t\t((Way) e).addNode(new Node(rs.getDouble(6), rs.getDouble(7), rs.getLong(2)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (newEntity) {\n\t\t\t\t\te = new Relation(curId);\n\t\t\t\t}\n\t\t\t\te.putTag(rs.getString(2), rs.getString(3));\n\t\t\t}\n\t\t\tif (newEntity) {\n\t\t\t\tcount++;\n\t\t\t\tif (progress != null) {\n\t\t\t\t\tprogress.progress(1);\n\t\t\t\t}\n\t\t\t\tif (prevEntity != null) {\n\t\t\t\t\tvisitor.iterateEntity(prevEntity, this);\n\t\t\t\t}\n\t\t\t\tprevEntity = e;\n\t\t\t}\n\t\t\tprevId = curId;\n\t\t}\n\t\tif (prevEntity != null) {\n\t\t\tcount++;\n\t\t\tvisitor.iterateEntity(prevEntity, this);\n\t\t}\n\t\trs.close();\n\t\tif(EntityType.NODE == type){\n\t\t\tallNodes = count;\n\t\t} else if(EntityType.WAY == type){\n\t\t\tallWays = count;\n\t\t} else if(EntityType.RELATION == type){\n\t\t\tallRelations = count;\n\t\t}\n\t\treturn count;\n\t}","id":45488,"modified_method":"public int iterateOverEntities(IProgress progress, EntityType type, OsmDbVisitor visitor) throws SQLException {\n\t\tif(dialect == DBDialect.NOSQL){\n\t\t\titerateOverEntitiesNoSQL(progress, type, visitor);\n\t\t}\n\t\tStatement statement = dbConn.createStatement();\n\t\tString select;\n\t\tint count = 0;\n\n\t\t// stat.executeUpdate(\"create table tags (id \"+longType+\", type smallint, skeys varchar(255), value varchar(255))\");\n\t\t// stat.executeUpdate(\"create table ways (id \"+longType+\", node \"+longType+\", ord smallint)\");\n//\t\tstat.executeUpdate(\"create table relations (id \"+longType+\", member \"+longType+\", type smallint, role varchar(255), ord smallint)\");\n\t\tif (type == EntityType.NODE) {\n\t\t\t// filter out all nodes without tags\n\t\t\tselect = \"select n.id, n.latitude, n.longitude, t.skeys, t.value from node n inner join tags t on n.id = t.id and t.type = 0 order by n.id\"; //$NON-NLS-1$\n\t\t} else if (type == EntityType.WAY) {\n\t\t\tselect = \"select w.id, w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" + //$NON-NLS-1$\n\t\t\t\t\t\"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" + //$NON-NLS-1$\n\t\t\t\t\t\"order by w.id, w.ord\"; //$NON-NLS-1$\n\t\t} else {\n\t\t\tselect = \"select r.id, t.skeys, t.value  from relations r inner join tags t on t.id = r.id and t.type = 2 and r.ord = 0\"; //$NON-NLS-1$\n\t\t}\n\n\t\tResultSet rs = statement.executeQuery(select);\n\t\tEntity prevEntity = null;\n\n\t\tlong prevId = -1;\n\t\twhile (rs.next()) {\n\t\t\tlong curId = rs.getLong(1);\n\t\t\tboolean newEntity = curId != prevId;\n\t\t\tEntity e = prevEntity;\n\t\t\tif (type == EntityType.NODE) {\n\t\t\t\tif (newEntity) {\n\t\t\t\t\te = new Node(rs.getDouble(2), rs.getDouble(3), curId);\n\t\t\t\t}\n\t\t\t\te.putTag(rs.getString(4), rs.getString(5));\n\t\t\t} else if (type == EntityType.WAY) {\n\t\t\t\tif (newEntity) {\n\t\t\t\t\te = new Way(curId);\n\t\t\t\t}\n\t\t\t\tint ord = rs.getInt(3);\n\t\t\t\tif (ord == 0 && rs.getObject(4) != null) {\n\t\t\t\t\te.putTag(rs.getString(4), rs.getString(5));\n\t\t\t\t}\n\t\t\t\tif (newEntity || ord > 0) {\n\t\t\t\t\t((Way) e).addNode(new Node(rs.getDouble(6), rs.getDouble(7), rs.getLong(2)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (newEntity) {\n\t\t\t\t\te = new Relation(curId);\n\t\t\t\t}\n\t\t\t\te.putTag(rs.getString(2), rs.getString(3));\n\t\t\t}\n\t\t\tif (newEntity) {\n\t\t\t\tcount++;\n\t\t\t\tif (progress != null) {\n\t\t\t\t\tprogress.progress(1);\n\t\t\t\t}\n\t\t\t\tif (prevEntity != null) {\n\t\t\t\t\tvisitor.iterateEntity(prevEntity, this);\n\t\t\t\t}\n\t\t\t\tprevEntity = e;\n\t\t\t}\n\t\t\tprevId = curId;\n\t\t}\n\t\tif (prevEntity != null) {\n\t\t\tcount++;\n\t\t\tvisitor.iterateEntity(prevEntity, this);\n\t\t}\n\t\trs.close();\n\t\tif(EntityType.NODE == type){\n\t\t\tallNodes = count;\n\t\t} else if(EntityType.WAY == type){\n\t\t\tallWays = count;\n\t\t} else if(EntityType.RELATION == type){\n\t\t\tallRelations = count;\n\t\t}\n\t\treturn count;\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void initDatabase(Connection dbConn, int allNodes, int allWays, int allRelations) throws SQLException {\n\t\tthis.dbConn = dbConn;\n\t\tthis.allNodes = allNodes;\n\t\tthis.allWays = allWays;\n\t\tthis.allRelations = allRelations;\n\t\tpselectNode = dbConn.prepareStatement(\"select n.latitude, n.longitude, t.skeys, t.value from node n left join tags t on n.id = t.id and t.type = 0 where n.id = ?\"); //$NON-NLS-1$\n\t\tpselectWay = dbConn.prepareStatement(\"select w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" + //$NON-NLS-1$\n\t\t\t\t\"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" + //$NON-NLS-1$\n\t\t\t\t\"where w.id = ? order by w.ord\"); //$NON-NLS-1$\n\t\tpselectRelation = dbConn.prepareStatement(\"select r.member, r.type, r.role, r.ord, t.skeys, t.value \" + //$NON-NLS-1$\n\t\t\t\t\"from relations r left join tags t on r.id = t.id and t.type = 2 and r.ord = 0 \" + //$NON-NLS-1$\n\t\t\t\t\"where r.id = ? order by r.ord\"); //$NON-NLS-1$\n\t\tpselectTags = dbConn.prepareStatement(\"select skeys, value from tags where id = ? and type = ?\"); //$NON-NLS-1$\n\t}","id":45489,"modified_method":"public void initDatabase(Object dbConnection, DBDialect dialect, int allNodes, int allWays, int allRelations) throws SQLException {\n\t\t\n\t\tthis.dialect = dialect;\n\t\tif(this.dialect == DBDialect.NOSQL){\n\t\t\topts = new ReadOptions();\n\t\t\taccessor = (DBAccessor) dbConnection;\n\t\t} else {\n\t\t\tthis.dbConn = (Connection) dbConnection;\n\t\t\tthis.allNodes = allNodes;\n\t\t\tthis.allWays = allWays;\n\t\t\tthis.allRelations = allRelations;\n\t\t\tpselectNode = dbConn.prepareStatement(\"select n.latitude, n.longitude, t.skeys, t.value from node n left join tags t on n.id = t.id and t.type = 0 where n.id = ?\"); //$NON-NLS-1$\n\t\t\tpselectWay = dbConn.prepareStatement(\"select w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" + //$NON-NLS-1$\n\t\t\t\t\t\"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" + //$NON-NLS-1$\n\t\t\t\t\t\"where w.id = ? order by w.ord\"); //$NON-NLS-1$\n\t\t\tpselectRelation = dbConn.prepareStatement(\"select r.member, r.type, r.role, r.ord, t.skeys, t.value \" + //$NON-NLS-1$\n\t\t\t\t\t\"from relations r left join tags t on r.id = t.id and t.type = 2 and r.ord = 0 \" + //$NON-NLS-1$\n\t\t\t\t\t\"where r.id = ? order by r.ord\"); //$NON-NLS-1$\n\t\t\tpselectTags = dbConn.prepareStatement(\"select skeys, value from tags where id = ? and type = ?\"); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void closeReadingConnection() throws SQLException {\n\t\tif (pselectNode != null) {\n\t\t\tpselectNode.close();\n\t\t}\n\t\tif (pselectWay != null) {\n\t\t\tpselectWay.close();\n\t\t}\n\t\tif (pselectRelation != null) {\n\t\t\tpselectRelation.close();\n\t\t}\n\t\tif (pselectTags != null) {\n\t\t\tpselectTags.close();\n\t\t}\n\t\t\n\t}","id":45490,"modified_method":"public void closeReadingConnection() throws SQLException {\n\t\tif (dialect != DBDialect.NOSQL) {\n\t\t\tif (pselectNode != null) {\n\t\t\t\tpselectNode.close();\n\t\t\t}\n\t\t\tif (pselectWay != null) {\n\t\t\t\tpselectWay.close();\n\t\t\t}\n\t\t\tif (pselectRelation != null) {\n\t\t\t\tpselectRelation.close();\n\t\t\t}\n\t\t\tif (pselectTags != null) {\n\t\t\t\tpselectTags.close();\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean acceptEntityToLoad(OsmBaseStorage storage, EntityId entityId, Entity e) {\n\t\t// put all nodes into temporary db to get only required nodes after loading all data\n\t\ttry {\n\t\t\tif (e instanceof Node) {\n\t\t\t\tcurrentCountNode++;\n\t\t\t\tif (!e.getTags().isEmpty()) {\n\t\t\t\t\tallNodes++;\n\t\t\t\t}\n\t\t\t\tprepNode.setLong(1, e.getId());\n\t\t\t\tprepNode.setDouble(2, ((Node) e).getLatitude());\n\t\t\t\tprepNode.setDouble(3, ((Node) e).getLongitude());\n\t\t\t\tprepNode.addBatch();\n\t\t\t\tif (currentCountNode >= BATCH_SIZE_OSM) {\n\t\t\t\t\tprepNode.executeBatch();\n\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\tcurrentCountNode = 0;\n\t\t\t\t}\n\t\t\t} else if (e instanceof Way) {\n\t\t\t\tallWays++;\n\t\t\t\tshort ord = 0;\n\t\t\t\tfor (Long i : ((Way) e).getNodeIds()) {\n\t\t\t\t\tcurrentWaysCount++;\n\t\t\t\t\tprepWays.setLong(1, e.getId());\n\t\t\t\t\tprepWays.setLong(2, i);\n\t\t\t\t\tprepWays.setLong(3, ord++);\n\t\t\t\t\tprepWays.addBatch();\n\t\t\t\t}\n\t\t\t\tif (currentWaysCount >= BATCH_SIZE_OSM) {\n\t\t\t\t\tprepWays.executeBatch();\n\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\tcurrentWaysCount = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tallRelations++;\n\t\t\t\tshort ord = 0;\n\t\t\t\tfor (Entry<EntityId, String> i : ((Relation) e).getMembersMap().entrySet()) {\n\t\t\t\t\tcurrentRelationsCount++;\n\t\t\t\t\tprepRelations.setLong(1, e.getId());\n\t\t\t\t\tprepRelations.setLong(2, i.getKey().getId());\n\t\t\t\t\tprepRelations.setLong(3, i.getKey().getType().ordinal());\n\t\t\t\t\tprepRelations.setString(4, i.getValue());\n\t\t\t\t\tprepRelations.setLong(5, ord++);\n\t\t\t\t\tprepRelations.addBatch();\n\t\t\t\t}\n\t\t\t\tif (currentRelationsCount >= BATCH_SIZE_OSM) {\n\t\t\t\t\tprepRelations.executeBatch();\n\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\tcurrentRelationsCount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Entry<String, String> i : e.getTags().entrySet()) {\n\t\t\t\tcurrentTagsCount++;\n\t\t\t\tprepTags.setLong(1, e.getId());\n\t\t\t\tprepTags.setLong(2, EntityType.valueOf(e).ordinal());\n\t\t\t\tprepTags.setString(3, i.getKey());\n\t\t\t\tprepTags.setString(4, i.getValue());\n\t\t\t\tprepTags.addBatch();\n\t\t\t}\n\t\t\tif (currentTagsCount >= BATCH_SIZE_OSM) {\n\t\t\t\tprepTags.executeBatch();\n\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\tcurrentTagsCount = 0;\n\t\t\t}\n\t\t} catch (SQLException ex) {\n\t\t\tlog.error(\"Could not save in db\", ex); //$NON-NLS-1$\n\t\t}\n\t\t// do not add to storage\n\t\treturn false;\n\t}","id":45491,"modified_method":"@Override\n\tpublic boolean acceptEntityToLoad(OsmBaseStorage storage, EntityId entityId, Entity e) {\n\t\t// put all nodes into temporary db to get only required nodes after loading all data\n\t\tif(dialect == DBDialect.NOSQL){\n\t\t\tbatch.Put(e.getId()+\"\", e.getTags() +\"\");\n\t\t\t\n\t\t\tcurrentCountNode++;\n\t\t\tif (e instanceof Node) {\n\t\t\t\tif (!e.getTags().isEmpty()) {\n\t\t\t\t\tallNodes++;\n\t\t\t\t}\n\t\t\t} else if (e instanceof Way) {\n\t\t\t\tallWays++;\n\t\t\t} else {\n\t\t\t\tallRelations ++;\n\t\t\t}\n\t\t\tif(currentCountNode > BATCH_SIZE_OSM){\n\t\t\t\tdatabase.Write(options, batch);\n\t\t\t\tbatch = new DBWriteBatch();\n\t\t\t\tlong usedMemory = Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory();\n\t\t\t\tSystem.out.println(\"\"+Runtime.getRuntime().totalMemory()/(1024*1024) +\" MB Total \" + \n\t\t\t\t\t\t(usedMemory  / (1024*1024)) + \" MB used memory\");\n\t\t\t\tcurrentCountNode = 0;\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tif (e instanceof Node) {\n\t\t\t\t\tcurrentCountNode++;\n\t\t\t\t\tif (!e.getTags().isEmpty()) {\n\t\t\t\t\t\tallNodes++;\n\t\t\t\t\t}\n\t\t\t\t\tprepNode.setLong(1, e.getId());\n\t\t\t\t\tprepNode.setDouble(2, ((Node) e).getLatitude());\n\t\t\t\t\tprepNode.setDouble(3, ((Node) e).getLongitude());\n\t\t\t\t\tprepNode.addBatch();\n\t\t\t\t\tif (currentCountNode >= BATCH_SIZE_OSM) {\n\t\t\t\t\t\tprepNode.executeBatch();\n\t\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\t\tcurrentCountNode = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (e instanceof Way) {\n\t\t\t\t\tallWays++;\n\t\t\t\t\tshort ord = 0;\n\t\t\t\t\tfor (Long i : ((Way) e).getNodeIds()) {\n\t\t\t\t\t\tcurrentWaysCount++;\n\t\t\t\t\t\tprepWays.setLong(1, e.getId());\n\t\t\t\t\t\tprepWays.setLong(2, i);\n\t\t\t\t\t\tprepWays.setLong(3, ord++);\n\t\t\t\t\t\tprepWays.addBatch();\n\t\t\t\t\t}\n\t\t\t\t\tif (currentWaysCount >= BATCH_SIZE_OSM) {\n\t\t\t\t\t\tprepWays.executeBatch();\n\t\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\t\tcurrentWaysCount = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tallRelations++;\n\t\t\t\t\tshort ord = 0;\n\t\t\t\t\tfor (Entry<EntityId, String> i : ((Relation) e).getMembersMap().entrySet()) {\n\t\t\t\t\t\tcurrentRelationsCount++;\n\t\t\t\t\t\tprepRelations.setLong(1, e.getId());\n\t\t\t\t\t\tprepRelations.setLong(2, i.getKey().getId());\n\t\t\t\t\t\tprepRelations.setLong(3, i.getKey().getType().ordinal());\n\t\t\t\t\t\tprepRelations.setString(4, i.getValue());\n\t\t\t\t\t\tprepRelations.setLong(5, ord++);\n\t\t\t\t\t\tprepRelations.addBatch();\n\t\t\t\t\t}\n\t\t\t\t\tif (currentRelationsCount >= BATCH_SIZE_OSM) {\n\t\t\t\t\t\tprepRelations.executeBatch();\n\t\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\t\tcurrentRelationsCount = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Entry<String, String> i : e.getTags().entrySet()) {\n\t\t\t\t\tcurrentTagsCount++;\n\t\t\t\t\tprepTags.setLong(1, e.getId());\n\t\t\t\t\tprepTags.setLong(2, EntityType.valueOf(e).ordinal());\n\t\t\t\t\tprepTags.setString(3, i.getKey());\n\t\t\t\t\tprepTags.setString(4, i.getValue());\n\t\t\t\t\tprepTags.addBatch();\n\t\t\t\t}\n\t\t\t\tif (currentTagsCount >= BATCH_SIZE_OSM) {\n\t\t\t\t\tprepTags.executeBatch();\n\t\t\t\t\tdbConn.commit(); // clear memory\n\t\t\t\t\tcurrentTagsCount = 0;\n\t\t\t\t}\n\t\t\t} catch (SQLException ex) {\n\t\t\t\tlog.error(\"Could not save in db\", ex); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t// do not add to storage\n\t\treturn false;\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void finishLoading() throws SQLException {\n\t\tif (currentCountNode > 0) {\n\t\t\tprepNode.executeBatch();\n\t\t}\n\t\tprepNode.close();\n\t\tif (currentWaysCount > 0) {\n\t\t\tprepWays.executeBatch();\n\t\t}\n\t\tprepWays.close();\n\t\tif (currentRelationsCount > 0) {\n\t\t\tprepRelations.executeBatch();\n\t\t}\n\t\tprepRelations.close();\n\t\tif (currentTagsCount > 0) {\n\t\t\tprepTags.executeBatch();\n\t\t}\n\t\tprepTags.close();\n\t}","id":45492,"modified_method":"public void finishLoading() throws SQLException {\n\t\tif (dialect != DBDialect.NOSQL) {\n\t\t\tif (currentCountNode > 0) {\n\t\t\t\tprepNode.executeBatch();\n\t\t\t}\n\t\t\tprepNode.close();\n\t\t\tif (currentWaysCount > 0) {\n\t\t\t\tprepWays.executeBatch();\n\t\t\t}\n\t\t\tprepWays.close();\n\t\t\tif (currentRelationsCount > 0) {\n\t\t\t\tprepRelations.executeBatch();\n\t\t\t}\n\t\t\tprepRelations.close();\n\t\t\tif (currentTagsCount > 0) {\n\t\t\t\tprepTags.executeBatch();\n\t\t\t}\n\t\t\tprepTags.close();\n\t\t} else {\n\t\t\tdatabase.Write(options, batch);\n\t\t}\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void initDatabase(DBDialect dialect, Connection dbConn) throws SQLException {\n\t\tthis.dbConn = dbConn;\n\t\tthis.dialect = dialect;\n\t\t// prepare tables\n\t\tStatement stat = dbConn.createStatement();\n\t\tdialect.deleteTableIfExists(\"node\", stat);\n\t\tstat.executeUpdate(\"create table node (id bigint primary key, latitude double, longitude double)\"); //$NON-NLS-1$\n\t\tstat.executeUpdate(\"create index IdIndex ON node (id)\"); //$NON-NLS-1$\n\t\tdialect.deleteTableIfExists(\"ways\", stat);\n\t\tstat.executeUpdate(\"create table ways (id bigint, node bigint, ord smallint, primary key (id, ord))\"); //$NON-NLS-1$\n\t\tstat.executeUpdate(\"create index IdWIndex ON ways (id)\"); //$NON-NLS-1$\n\t\tdialect.deleteTableIfExists(\"relations\", stat);\n\t\tstat.executeUpdate(\"create table relations (id bigint, member bigint, type smallint, role varchar(255), ord smallint, primary key (id, ord))\"); //$NON-NLS-1$\n\t\tstat.executeUpdate(\"create index IdRIndex ON relations (id)\"); //$NON-NLS-1$\n\t\tdialect.deleteTableIfExists(\"tags\", stat);\n\t\tstat.executeUpdate(\"create table tags (id bigint, type smallint, skeys varchar(255), value varchar(255), primary key (id, type, skeys))\"); //$NON-NLS-1$\n\t\tstat.executeUpdate(\"create index IdTIndex ON tags (id, type)\"); //$NON-NLS-1$\n\t\tstat.close();\n\n\t\tprepNode = dbConn.prepareStatement(\"insert into node values (?, ?, ?)\"); //$NON-NLS-1$\n\t\tprepWays = dbConn.prepareStatement(\"insert into ways values (?, ?, ?)\"); //$NON-NLS-1$\n\t\tprepRelations = dbConn.prepareStatement(\"insert into relations values (?, ?, ?, ?, ?)\"); //$NON-NLS-1$\n\t\tprepTags = dbConn.prepareStatement(\"insert into tags values (?, ?, ?, ?)\"); //$NON-NLS-1$\n\t\tdbConn.setAutoCommit(false);\n\t}","id":45493,"modified_method":"public void initDatabase(DBDialect dialect, Object databaseConn) throws SQLException {\n\t\t\n\t\tthis.dialect = dialect;\n\t\tif(dialect == DBDialect.NOSQL){\n\t\t\tdatabase = (DBAccessor) databaseConn;\n\t\t\tbatch = new DBWriteBatch();\n\t\t\toptions = new WriteOptions();\n\t\t} else {\n\t\t\tthis.dbConn = (Connection) databaseConn;\n\t\t\t// prepare tables\n\t\t\tStatement stat = dbConn.createStatement();\n\t\t\tdialect.deleteTableIfExists(\"node\", stat);\n\t\t\tstat.executeUpdate(\"create table node (id bigint primary key, latitude double, longitude double)\"); //$NON-NLS-1$\n\t\t\tstat.executeUpdate(\"create index IdIndex ON node (id)\"); //$NON-NLS-1$\n\t\t\tdialect.deleteTableIfExists(\"ways\", stat);\n\t\t\tstat.executeUpdate(\"create table ways (id bigint, node bigint, ord smallint, primary key (id, ord))\"); //$NON-NLS-1$\n\t\t\tstat.executeUpdate(\"create index IdWIndex ON ways (id)\"); //$NON-NLS-1$\n\t\t\tdialect.deleteTableIfExists(\"relations\", stat);\n\t\t\tstat.executeUpdate(\"create table relations (id bigint, member bigint, type smallint, role varchar(255), ord smallint, primary key (id, ord))\"); //$NON-NLS-1$\n\t\t\tstat.executeUpdate(\"create index IdRIndex ON relations (id)\"); //$NON-NLS-1$\n\t\t\tdialect.deleteTableIfExists(\"tags\", stat);\n\t\t\tstat.executeUpdate(\"create table tags (id bigint, type smallint, skeys varchar(255), value varchar(255), primary key (id, type, skeys))\"); //$NON-NLS-1$\n\t\t\tstat.executeUpdate(\"create index IdTIndex ON tags (id, type)\"); //$NON-NLS-1$\n\t\t\tstat.close();\n\n\t\t\tprepNode = dbConn.prepareStatement(\"insert into node values (?, ?, ?)\"); //$NON-NLS-1$\n\t\t\tprepWays = dbConn.prepareStatement(\"insert into ways values (?, ?, ?)\"); //$NON-NLS-1$\n\t\t\tprepRelations = dbConn.prepareStatement(\"insert into relations values (?, ?, ?, ?, ?)\"); //$NON-NLS-1$\n\t\t\tprepTags = dbConn.prepareStatement(\"insert into tags values (?, ?, ?, ?)\"); //$NON-NLS-1$\n\t\t\tdbConn.setAutoCommit(false);\n\t\t}\n\t}","commit_id":"56208ea712e2dba4b7edb9c13cce31d57a075edd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static Document read(DocumentBuilder builder, XMLStreamReader reader, boolean repairing) \n        throws XMLStreamException {\n        Document doc = builder.newDocument();\n        doc.setDocumentURI(reader.getLocation().getSystemId());\n        readDocElements(doc, reader, repairing);\n        return doc;\n    }","id":45494,"modified_method":"public static Document read(DocumentBuilder builder, XMLStreamReader reader, boolean repairing) \n        throws XMLStreamException {\n        Document doc = builder.newDocument();\n        doc.setDocumentURI(new String(reader.getLocation().getSystemId()));\n        readDocElements(doc, reader, repairing);\n        return doc;\n    }","commit_id":"7ce6c7559e346fb03d83e2a704d0e3e01d5313a5","url":"https://github.com/apache/cxf"},{"original_method":"public static Document read(XMLStreamReader reader, boolean recordLoc) throws XMLStreamException {\n        Document doc = DOMUtils.createDocument();\n        doc.setDocumentURI(reader.getLocation().getSystemId());\n        readDocElements(doc, doc, reader, true, recordLoc);\n        return doc;\n    }","id":45495,"modified_method":"public static Document read(XMLStreamReader reader, boolean recordLoc) throws XMLStreamException {\n        Document doc = DOMUtils.createDocument();\n        doc.setDocumentURI(new String(reader.getLocation().getSystemId()));\n        readDocElements(doc, doc, reader, true, recordLoc);\n        return doc;\n    }","commit_id":"7ce6c7559e346fb03d83e2a704d0e3e01d5313a5","url":"https://github.com/apache/cxf"},{"original_method":"private static void addLocation(final Document doc, Node node, \n                                    XMLStreamReader reader, boolean recordLoc) {\n        if (recordLoc) {\n            final Location loc = reader.getLocation();\n            if (loc != null && (loc.getColumnNumber() != 0 || loc.getLineNumber() != 0)) {\n                Location loc2 = new Location() {\n                    public int getCharacterOffset() {\n                        return loc.getCharacterOffset();\n                    }\n                    public int getColumnNumber() {\n                        return loc.getColumnNumber();\n                    }\n                    public int getLineNumber() {\n                        return loc.getLineNumber();\n                    }\n                    public String getPublicId() {\n                        if (loc.getPublicId() == null) {\n                            return doc.getDocumentURI();\n                        }\n                        return loc.getPublicId();\n                    }\n                    public String getSystemId() {\n                        if (loc.getSystemId() == null) {\n                            return doc.getDocumentURI();\n                        }\n                        return loc.getSystemId();\n                    }\n                    \n                };\n                node.setUserData(\"location\", loc2, new UserDataHandler() {\n                    public void handle(short operation, String key, Object data, Node src, Node dst) {\n                        if (operation == NODE_CLONED) {\n                            dst.setUserData(key, data, this);\n                        }\n                    }\n                });\n            }\n        }\n    }","id":45496,"modified_method":"private static void addLocation(Document doc, Node node, \n                                    XMLStreamReader reader,\n                                    boolean recordLoc) {\n        if (recordLoc) {\n            Location loc = reader.getLocation();\n            if (loc != null && (loc.getColumnNumber() != 0 || loc.getLineNumber() != 0)) {\n                final int charOffset = loc.getCharacterOffset();\n                final int colNum = loc.getColumnNumber();\n                final int linNum = loc.getLineNumber();\n                final String pubId = loc.getPublicId() == null ? doc.getDocumentURI() : loc.getPublicId();\n                final String sysId = loc.getSystemId() == null ? doc.getDocumentURI() : loc.getSystemId();\n                Location loc2 = new Location() {\n                    public int getCharacterOffset() {\n                        return charOffset;\n                    }\n                    public int getColumnNumber() {\n                        return colNum;\n                    }\n                    public int getLineNumber() {\n                        return linNum;\n                    }\n                    public String getPublicId() {\n                        return pubId;\n                    }\n                    public String getSystemId() {\n                        return sysId;\n                    }\n                };\n                node.setUserData(\"location\", loc2, new UserDataHandler() {\n                    public void handle(short operation, String key, Object data, Node src, Node dst) {\n                        if (operation == NODE_CLONED) {\n                            dst.setUserData(key, data, this);\n                        }\n                    }\n                });\n            }\n        }\n    }","commit_id":"7ce6c7559e346fb03d83e2a704d0e3e01d5313a5","url":"https://github.com/apache/cxf"},{"original_method":"private Definition loadDefinition(String url) throws WSDLException {\n        WSDLReader reader = factory.newWSDLReader();\n        reader.setFeature(\"javax.wsdl.verbose\", false);\n        reader.setFeature(\"javax.wsdl.importDocuments\", true);\n        reader.setExtensionRegistry(registry);\n        CatalogWSDLLocator catLocator = new CatalogWSDLLocator(url, bus);\n        ResourceManagerWSDLLocator wsdlLocator = new ResourceManagerWSDLLocator(url,\n                                                                                catLocator,\n                                                                                bus);\n        InputSource src = wsdlLocator.getBaseInputSource();\n        Document doc;\n        try {\n            doc = StaxUtils.read(StaxUtils.createXMLStreamReader(src), true);\n            doc.setDocumentURI(src.getSystemId());\n        } catch (Exception e) {\n            throw new WSDLException(WSDLException.PARSER_ERROR, e.getMessage(), e);\n        }\n        \n        Definition def = reader.readWSDL(wsdlLocator, doc.getDocumentElement());\n        synchronized (definitionsMap) {\n            definitionsMap.put(url, def);\n        }\n        return def;\n    }","id":45497,"modified_method":"private Definition loadDefinition(String url) throws WSDLException {\n        WSDLReader reader = factory.newWSDLReader();\n        reader.setFeature(\"javax.wsdl.verbose\", false);\n        reader.setFeature(\"javax.wsdl.importDocuments\", true);\n        reader.setExtensionRegistry(registry);\n        CatalogWSDLLocator catLocator = new CatalogWSDLLocator(url, bus);\n        ResourceManagerWSDLLocator wsdlLocator = new ResourceManagerWSDLLocator(url,\n                                                                                catLocator,\n                                                                                bus);\n        InputSource src = wsdlLocator.getBaseInputSource();\n        Document doc;\n        try {\n            doc = StaxUtils.read(StaxUtils.createXMLStreamReader(src), true);\n            doc.setDocumentURI(new String(src.getSystemId()));\n        } catch (Exception e) {\n            throw new WSDLException(WSDLException.PARSER_ERROR, e.getMessage(), e);\n        }\n        \n        Definition def = reader.readWSDL(wsdlLocator, doc.getDocumentElement());\n        synchronized (definitionsMap) {\n            definitionsMap.put(url, def);\n        }\n        return def;\n    }","commit_id":"7ce6c7559e346fb03d83e2a704d0e3e01d5313a5","url":"https://github.com/apache/cxf"},{"original_method":"public static XMLStreamReader createXMLStreamReader(InputSource src) {\n        if (src.getByteStream() != null) {\n            if (src.getEncoding() == null) {\n                StreamSource ss = new StreamSource(src.getByteStream(), src.getSystemId());\n                ss.setPublicId(src.getPublicId());\n                return createXMLStreamReader(ss);\n            }\n            return createXMLStreamReader(src.getByteStream(), src.getEncoding());\n        } else if (src.getCharacterStream() != null) {\n            StreamSource ss = new StreamSource(src.getCharacterStream(), src.getSystemId());\n            ss.setPublicId(src.getPublicId());\n            return createXMLStreamReader(ss);\n        }\n        throw new IllegalArgumentException(\"InputSource must have a ByteStream or CharacterStream\");\n    }","id":45498,"modified_method":"public static XMLStreamReader createXMLStreamReader(InputSource src) {\n        String sysId = src.getSystemId() == null ? null : new String(src.getSystemId());\n        String pubId = src.getPublicId() == null ? null : new String(src.getPublicId());\n        if (src.getByteStream() != null) {\n            if (src.getEncoding() == null) {\n                StreamSource ss = new StreamSource(src.getByteStream(), sysId);\n                ss.setPublicId(pubId);\n                return createXMLStreamReader(ss);\n            }\n            return createXMLStreamReader(src.getByteStream(), src.getEncoding());\n        } else if (src.getCharacterStream() != null) {\n            StreamSource ss = new StreamSource(src.getCharacterStream(), sysId);\n            ss.setPublicId(pubId);\n            return createXMLStreamReader(ss);\n        }\n        throw new IllegalArgumentException(\"InputSource must have a ByteStream or CharacterStream\");\n    }","commit_id":"954128c80854bc166fd30cace425e1270265c7e4","url":"https://github.com/apache/cxf"},{"original_method":"public static Document read(XMLStreamReader reader, boolean recordLoc) throws XMLStreamException {\n        Document doc = DOMUtils.createDocument();\n        doc.setDocumentURI(new String(reader.getLocation().getSystemId()));\n        readDocElements(doc, doc, reader, true, recordLoc);\n        return doc;\n    }","id":45499,"modified_method":"public static Document read(XMLStreamReader reader, boolean recordLoc) throws XMLStreamException {\n        Document doc = DOMUtils.createDocument();\n        if (reader.getLocation().getSystemId() != null) {\n            doc.setDocumentURI(new String(reader.getLocation().getSystemId()));\n        }\n        readDocElements(doc, doc, reader, true, recordLoc);\n        return doc;\n    }","commit_id":"954128c80854bc166fd30cace425e1270265c7e4","url":"https://github.com/apache/cxf"},{"original_method":"public static Document read(DocumentBuilder builder, XMLStreamReader reader, boolean repairing) \n        throws XMLStreamException {\n        Document doc = builder.newDocument();\n        doc.setDocumentURI(new String(reader.getLocation().getSystemId()));\n        readDocElements(doc, reader, repairing);\n        return doc;\n    }","id":45500,"modified_method":"public static Document read(DocumentBuilder builder, XMLStreamReader reader, boolean repairing) \n        throws XMLStreamException {\n        Document doc = builder.newDocument();\n        if (reader.getLocation().getSystemId() != null) {\n            doc.setDocumentURI(new String(reader.getLocation().getSystemId()));\n        }\n        readDocElements(doc, reader, repairing);\n        return doc;\n    }","commit_id":"954128c80854bc166fd30cace425e1270265c7e4","url":"https://github.com/apache/cxf"},{"original_method":"private Definition loadDefinition(String url) throws WSDLException {\n        WSDLReader reader = factory.newWSDLReader();\n        reader.setFeature(\"javax.wsdl.verbose\", false);\n        reader.setFeature(\"javax.wsdl.importDocuments\", true);\n        reader.setExtensionRegistry(registry);\n        CatalogWSDLLocator catLocator = new CatalogWSDLLocator(url, bus);\n        ResourceManagerWSDLLocator wsdlLocator = new ResourceManagerWSDLLocator(url,\n                                                                                catLocator,\n                                                                                bus);\n        InputSource src = wsdlLocator.getBaseInputSource();\n        Document doc;\n        try {\n            doc = StaxUtils.read(StaxUtils.createXMLStreamReader(src), true);\n            doc.setDocumentURI(new String(src.getSystemId()));\n        } catch (Exception e) {\n            throw new WSDLException(WSDLException.PARSER_ERROR, e.getMessage(), e);\n        }\n        \n        Definition def = reader.readWSDL(wsdlLocator, doc.getDocumentElement());\n        synchronized (definitionsMap) {\n            definitionsMap.put(url, def);\n        }\n        return def;\n    }","id":45501,"modified_method":"private Definition loadDefinition(String url) throws WSDLException {\n        WSDLReader reader = factory.newWSDLReader();\n        reader.setFeature(\"javax.wsdl.verbose\", false);\n        reader.setFeature(\"javax.wsdl.importDocuments\", true);\n        reader.setExtensionRegistry(registry);\n        CatalogWSDLLocator catLocator = new CatalogWSDLLocator(url, bus);\n        ResourceManagerWSDLLocator wsdlLocator = new ResourceManagerWSDLLocator(url,\n                                                                                catLocator,\n                                                                                bus);\n        InputSource src = wsdlLocator.getBaseInputSource();\n        Document doc;\n        try {\n            doc = StaxUtils.read(StaxUtils.createXMLStreamReader(src), true);\n            if (src.getSystemId() != null) {\n                doc.setDocumentURI(new String(src.getSystemId()));\n            }\n        } catch (Exception e) {\n            throw new WSDLException(WSDLException.PARSER_ERROR, e.getMessage(), e);\n        }\n        \n        Definition def = reader.readWSDL(wsdlLocator, doc.getDocumentElement());\n        synchronized (definitionsMap) {\n            definitionsMap.put(url, def);\n        }\n        return def;\n    }","commit_id":"954128c80854bc166fd30cace425e1270265c7e4","url":"https://github.com/apache/cxf"},{"original_method":"public boolean upgrade() {\n    boolean modified = false;\n\n    for (String c : getClusterNames()) {\n      if (getServers(c) == null) {\n        final ODocument clusterConfig = getClusterConfiguration(c);\n\n        // if (clusterConfig.removeField(\"replication\") != null)\n        // modified = true;\n\n        final ODocument partitioning = clusterConfig.field(\"partitioning\");\n        if (partitioning != null) {\n          final Collection partitions = partitioning.field(\"partitions\");\n          if (partitions != null) {\n            OLogManager.instance().warn(this, \"Migrating distributed configuration to the new format for cluster '%s'...\", c);\n            final List<String> servers = new ArrayList<String>();\n            for (Object p : partitions) {\n              for (String node : (Collection<String>) p) {\n                servers.add(node);\n              }\n            }\n            clusterConfig.field(\"servers\", servers, OType.EMBEDDEDLIST);\n          }\n          clusterConfig.removeField(\"partitioning\");\n          modified = true;\n        }\n      }\n    }\n    return modified;\n  }","id":45502,"modified_method":"public boolean upgrade() {\n    boolean modified = false;\n\n    for (String c : getClusterNames()) {\n      if (getOriginalServers(c) == null) {\n        final ODocument clusterConfig = getClusterConfiguration(c);\n\n        // if (clusterConfig.removeField(\"replication\") != null)\n        // modified = true;\n\n        final ODocument partitioning = (ODocument) clusterConfig.removeField(\"partitioning\");\n        if (partitioning != null) {\n          final Collection partitions = partitioning.field(\"partitions\");\n          if (partitions != null) {\n            OLogManager.instance().warn(this, \"Migrating distributed configuration to the new format for cluster '%s'...\", c);\n            final List<String> servers = new ArrayList<String>();\n            for (Object p : partitions) {\n              for (String node : (Collection<String>) p) {\n                servers.add(node);\n              }\n            }\n            clusterConfig.field(\"servers\", servers, OType.EMBEDDEDLIST);\n          }\n          modified = true;\n        }\n      }\n    }\n    return modified;\n  }","commit_id":"315eab169dfabd510d0f4c014e9f533a09d69460","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Returns the server list for the requested cluster cluster excluding any tags like <NEW_NODES>.\n   * \n   * @param iClusterName\n   *          Cluster name, or null for *\n   */\n  public Collection<String> getServers(final String iClusterName) {\n    synchronized (configuration) {\n      final ODocument partition = getClusterConfiguration(iClusterName);\n      if (partition == null)\n        return null;\n\n      final List<String> serverList = partition.field(\"servers\");\n      if (serverList != null)\n        serverList.remove(NEW_NODE_TAG);\n\n      return serverList;\n    }\n  }","id":45503,"modified_method":"/**\n   * Returns the server list for the requested cluster cluster excluding any tags like <NEW_NODES>.\n   * \n   * @param iClusterName\n   *          Cluster name, or null for *\n   */\n  public Collection<String> getServers(final String iClusterName) {\n    synchronized (configuration) {\n      final ODocument partition = getClusterConfiguration(iClusterName);\n      if (partition == null)\n        return null;\n\n      List<String> serverList = partition.field(\"servers\");\n      if (serverList != null) {\n        // COPY AND REMOVE ANY NEW_NODE_TAG\n        serverList = new ArrayList<String>(serverList);\n        serverList.remove(NEW_NODE_TAG);\n      }\n\n      return serverList;\n    }\n  }","commit_id":"315eab169dfabd510d0f4c014e9f533a09d69460","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Returns the server list for the default (*) cluster excluding any tags like <NEW_NODES>.\n   */\n  public Collection<String> getServers() {\n    synchronized (configuration) {\n      final ODocument partition = getClusterConfiguration(null);\n      if (partition == null)\n        return null;\n\n      final List<String> serverList = partition.field(\"servers\");\n      if (serverList != null)\n        serverList.remove(NEW_NODE_TAG);\n\n      return serverList;\n    }\n  }","id":45504,"modified_method":"/**\n   * Returns the server list for the default (*) cluster excluding any tags like <NEW_NODES>.\n   */\n  public Collection<String> getServers() {\n    return getServers((String) null);\n  }","commit_id":"315eab169dfabd510d0f4c014e9f533a09d69460","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Update current record.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean result(final Object iRecord) {\r\n\t\tODocument record = (ODocument) iRecord;\r\n\r\n\t\t// BIND VALUES TO UPDATE\r\n\t\tObject v;\r\n\t\tfor (Map.Entry<String, Object> entry : setEntries.entrySet()) {\r\n\t\t\tv = entry.getValue();\r\n\r\n\t\t\tif (v instanceof OSQLFilterItem)\r\n\t\t\t\tv = ((OSQLFilterItem) v).getValue(record);\r\n\r\n\t\t\trecord.field(entry.getKey(), v);\r\n\t\t}\r\n\r\n\t\t// BIND VALUES TO ADD\r\n\t\tCollection<Object> coll;\r\n\t\tObject fieldValue;\r\n\t\tfor (Map.Entry<String, Object> entry : addEntries.entrySet()) {\r\n\t\t\tcoll = null;\r\n\t\t\tif (!record.containsField(entry.getKey())) {\r\n\t\t\t\t// GET THE TYPE IF ANY\r\n\t\t\t\tif (record.getSchemaClass() != null) {\r\n\t\t\t\t\tOProperty prop = record.getSchemaClass().getProperty(entry.getKey());\r\n\t\t\t\t\tif (prop != null && prop.getType() == OType.LINKSET)\r\n\t\t\t\t\t\t// SET TYPE\r\n\t\t\t\t\t\tcoll = new HashSet<Object>();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (coll == null)\r\n\t\t\t\t\t// IN ALL OTHER CASES USE A LIST\r\n\t\t\t\t\tcoll = new ArrayList<Object>();\r\n\r\n\t\t\t\trecord.field(entry.getKey(), coll);\r\n\t\t\t} else {\r\n\t\t\t\tfieldValue = record.field(entry.getKey());\r\n\r\n\t\t\t\tif (fieldValue instanceof Collection<?>)\r\n\t\t\t\t\tcoll = (Collection<Object>) fieldValue;\r\n\t\t\t\telse\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tv = entry.getValue();\r\n\r\n\t\t\tif (v instanceof OSQLFilterItem)\r\n\t\t\t\tv = ((OSQLFilterItem) v).getValue(record);\r\n\t\t\telse if (v instanceof OSQLFunctionRuntime)\r\n\t\t\t\tv = ((OSQLFunctionRuntime) v).execute(record);\r\n\r\n\t\t\tcoll.add(v);\r\n\t\t\trecord.setDirty();\r\n\t\t}\r\n\r\n\t\t// BIND VALUES TO PUT (AS MAP)\r\n\t\tMap<String, Object> map;\r\n\t\tOPair<String, Object> pair;\r\n\t\tfor (Entry<String, OPair<String, Object>> entry : putEntries.entrySet()) {\r\n\t\t\tfieldValue = record.field(entry.getKey());\r\n\r\n\t\t\tif (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\tmap = (Map<String, Object>) fieldValue;\r\n\r\n\t\t\t\tpair = entry.getValue();\r\n\r\n\t\t\t\tif (pair.getValue() instanceof OSQLFilterItem)\r\n\t\t\t\t\tpair.setValue(((OSQLFilterItem) pair.getValue()).getValue(record));\r\n\t\t\t\telse if (pair.getValue() instanceof OSQLFunctionRuntime)\r\n\t\t\t\t\tv = ((OSQLFunctionRuntime) pair.getValue()).execute(record);\r\n\r\n\t\t\t\tmap.put(pair.getKey(), pair.getValue());\r\n\t\t\t\trecord.setDirty();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// REMOVE FIELD IF ANY\r\n\t\tfor (Map.Entry<String, Object> entry : removeEntries.entrySet()) {\r\n\t\t\tv = entry.getValue();\r\n\t\t\tif (v == EMPTY_VALUE)\r\n\t\t\t\trecord.removeField(entry.getKey());\r\n\t\t\telse {\r\n\t\t\t\tfieldValue = record.field(entry.getKey());\r\n\r\n\t\t\t\tif (fieldValue instanceof Collection<?>) {\r\n\t\t\t\t\tcoll = (Collection<Object>) fieldValue;\r\n\t\t\t\t\tcoll.remove(v);\r\n\t\t\t\t\trecord.setDirty();\r\n\t\t\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\t\tmap = (Map<String, Object>) fieldValue;\r\n\t\t\t\t\tmap.remove(v);\r\n\t\t\t\t\trecord.setDirty();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trecord.save();\r\n\t\trecordCount++;\r\n\t\treturn true;\r\n\t}","id":45505,"modified_method":"/**\r\n\t * Update current record.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean result(final Object iRecord) {\r\n\t\tODocument record = (ODocument) iRecord;\r\n\r\n\t\tboolean recordUpdated = false;\r\n\r\n\t\t// BIND VALUES TO UPDATE\r\n\t\tObject v;\r\n\t\tfor (Map.Entry<String, Object> entry : setEntries.entrySet()) {\r\n\t\t\tv = entry.getValue();\r\n\r\n\t\t\tif (v instanceof OSQLFilterItem)\r\n\t\t\t\tv = ((OSQLFilterItem) v).getValue(record);\r\n\r\n\t\t\trecord.field(entry.getKey(), v);\r\n\t\t\trecordUpdated = true;\r\n\t\t}\r\n\r\n\t\t// BIND VALUES TO ADD\r\n\t\tCollection<Object> coll;\r\n\t\tObject fieldValue;\r\n\t\tfor (Map.Entry<String, Object> entry : addEntries.entrySet()) {\r\n\t\t\tcoll = null;\r\n\t\t\tif (!record.containsField(entry.getKey())) {\r\n\t\t\t\t// GET THE TYPE IF ANY\r\n\t\t\t\tif (record.getSchemaClass() != null) {\r\n\t\t\t\t\tOProperty prop = record.getSchemaClass().getProperty(entry.getKey());\r\n\t\t\t\t\tif (prop != null && prop.getType() == OType.LINKSET)\r\n\t\t\t\t\t\t// SET TYPE\r\n\t\t\t\t\t\tcoll = new HashSet<Object>();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (coll == null)\r\n\t\t\t\t\t// IN ALL OTHER CASES USE A LIST\r\n\t\t\t\t\tcoll = new ArrayList<Object>();\r\n\r\n\t\t\t\trecord.field(entry.getKey(), coll);\r\n\t\t\t} else {\r\n\t\t\t\tfieldValue = record.field(entry.getKey());\r\n\r\n\t\t\t\tif (fieldValue instanceof Collection<?>)\r\n\t\t\t\t\tcoll = (Collection<Object>) fieldValue;\r\n\t\t\t\telse\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tv = entry.getValue();\r\n\r\n\t\t\tif (v instanceof OSQLFilterItem)\r\n\t\t\t\tv = ((OSQLFilterItem) v).getValue(record);\r\n\t\t\telse if (v instanceof OSQLFunctionRuntime)\r\n\t\t\t\tv = ((OSQLFunctionRuntime) v).execute(record);\r\n\r\n\t\t\tcoll.add(v);\r\n\t\t\trecordUpdated = true;\r\n\t\t}\r\n\r\n\t\t// BIND VALUES TO PUT (AS MAP)\r\n\t\tMap<String, Object> map;\r\n\t\tOPair<String, Object> pair;\r\n\t\tfor (Entry<String, OPair<String, Object>> entry : putEntries.entrySet()) {\r\n\t\t\tfieldValue = record.field(entry.getKey());\r\n\r\n\t\t\tif (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\tmap = (Map<String, Object>) fieldValue;\r\n\r\n\t\t\t\tpair = entry.getValue();\r\n\r\n\t\t\t\tif (pair.getValue() instanceof OSQLFilterItem)\r\n\t\t\t\t\tpair.setValue(((OSQLFilterItem) pair.getValue()).getValue(record));\r\n\t\t\t\telse if (pair.getValue() instanceof OSQLFunctionRuntime)\r\n\t\t\t\t\tv = ((OSQLFunctionRuntime) pair.getValue()).execute(record);\r\n\r\n\t\t\t\tmap.put(pair.getKey(), pair.getValue());\r\n\t\t\t\trecordUpdated = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// REMOVE FIELD IF ANY\r\n\t\tfor (Map.Entry<String, Object> entry : removeEntries.entrySet()) {\r\n\t\t\tv = entry.getValue();\r\n\t\t\tif (v == EMPTY_VALUE) {\r\n\t\t\t\trecord.removeField(entry.getKey());\r\n\t\t\t\trecordUpdated = true;\r\n\t\t\t} else {\r\n\t\t\t\tfieldValue = record.field(entry.getKey());\r\n\r\n\t\t\t\tif (fieldValue instanceof Collection<?>) {\r\n\t\t\t\t\tcoll = (Collection<Object>) fieldValue;\r\n\t\t\t\t\tif (coll.remove(v))\r\n\t\t\t\t\t\trecordUpdated = true;\r\n\t\t\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\t\tmap = (Map<String, Object>) fieldValue;\r\n\t\t\t\t\tif (map.remove(v) != null)\r\n\t\t\t\t\t\trecordUpdated = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (recordUpdated) {\r\n\t\t\trecord.setDirty();\r\n\t\t\trecord.save();\r\n\t\t\trecordCount++;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}","commit_id":"ba03122746be32efd4f2adbf24293c7dd6ed259d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private MongoNode getStoredNode(String path) {\n        MongoNode node = pathNodeMap.get(path);\n        if (node != null) {\n            return node;\n        }\n\n        // First need to check that the path is indeed valid.\n        NodeExistsCommand existCommand = new NodeExistsCommand(nodeStore,\n                path, headRevisionId);\n        existCommand.setBranchId(branchId);\n        existCommand.setValidCommits(validCommits);\n        boolean exists = false;\n        try {\n            exists = existCommand.execute();\n        } catch (Exception ignore) {}\n\n        if (!exists) {\n            throw new NotFoundException(path + \" @rev\" + headRevisionId);\n        }\n\n        // Fetch the node without its descendants.\n        FetchNodesAction query = new FetchNodesAction(nodeStore,\n                path, false /*fetchDescendants*/, headRevisionId);\n        query.setBranchId(branchId);\n        query.setValidCommits(validCommits);\n        Map<String, MongoNode> nodes = query.execute();\n\n        if (nodes.containsKey(path)) {\n            node = nodes.get(path);\n            node.removeField(\"_id\");\n            pathNodeMap.put(path, node);\n        }\n\n        return node;\n    }","id":45506,"modified_method":"private MongoNode getStoredNode(String path) {\n        MongoNode node = pathNodeMap.get(path);\n        if (node != null) {\n            return node;\n        }\n\n        // First need to check that the path is indeed valid.\n        NodeExistsCommand existCommand = new NodeExistsCommand(nodeStore,\n                path, headRevisionId);\n        existCommand.setBranchId(branchId);\n        existCommand.setValidCommits(validCommits);\n        boolean exists = false;\n        try {\n            exists = existCommand.execute();\n        } catch (Exception ignore) {}\n\n        if (!exists) {\n            throw new NotFoundException(path + \" @rev\" + headRevisionId);\n        }\n        node = existCommand.getNode();\n        node.removeField(\"_id\");\n        pathNodeMap.put(path, node);\n        return node;\n    }","commit_id":"78fe87c1fe940dabb4f04e51154fbfb18ce85b6f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Boolean execute() throws Exception {\n        if (PathUtils.denotesRoot(path)) {\n            return true;\n        }\n\n        // Check that all the paths up to the root actually exist.\n        return pathExists();\n    }","id":45507,"modified_method":"@Override\n    public Boolean execute() throws Exception {\n        // To check a path really exists, all the paths from root need to be checked.\n        Set<String> paths = new HashSet<String>();\n        char[] path = this.path.toCharArray();\n        StringBuilder current = new StringBuilder();\n        for (int i = 0; i < path.length; i++) {\n            if (i == 0) {\n                paths.add(\"/\");\n            } else if (path[i] == '/') {\n                paths.add(current.toString());\n            }\n            current.append(path[i]);\n        }\n        paths.add(current.toString());\n\n        if (revisionId == null) {\n            revisionId = new GetHeadRevisionCommand(nodeStore).execute();\n        }\n\n        FetchNodesAction action = new FetchNodesAction(nodeStore, paths, revisionId);\n        action.setBranchId(branchId);\n        action.setValidCommits(validCommits);\n\n        Map<String, MongoNode> pathAndNodeMap = action.execute();\n        String currentPath = this.path;\n        while (!PathUtils.denotesRoot(currentPath)) {\n            String childName = PathUtils.getName(currentPath);\n            String parentPath = PathUtils.getParentPath(currentPath);\n            MongoNode parentNode = pathAndNodeMap.get(parentPath);\n            if (parentNode == null || !parentNode.childExists(childName)) {\n                node = null;\n                return false;\n            }\n            currentPath = PathUtils.getParentPath(currentPath);\n        }\n        node = pathAndNodeMap.get(this.path);\n        return true;\n    }","commit_id":"78fe87c1fe940dabb4f04e51154fbfb18ce85b6f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,\n\t\t\tServerWebExchange exchange) {\n\n\t\tClass<?> bodyType = ResolvableType.forMethodParameter(bodyParameter).resolve();\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapterTo(bodyType);\n\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(bodyParameter);\n\t\tif (adapter != null) {\n\t\t\telementType = elementType.getGeneric(0);\n\t\t}\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tMediaType mediaType = request.getHeaders().getContentType();\n\t\tif (mediaType == null) {\n\t\t\tmediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tfor (HttpMessageReader<?> reader : getMessageReaders()) {\n\t\t\tif (reader.canRead(elementType, mediaType, Collections.emptyMap())) {\n\t\t\t\tif (adapter != null && adapter.getDescriptor().isMultiValue()) {\n\t\t\t\t\tFlux<?> flux = reader.read(elementType, request, Collections.emptyMap())\n\t\t\t\t\t\t\t.onErrorResumeWith(ex -> Flux.error(getReadError(ex, bodyParameter)));\n\t\t\t\t\tif (checkRequired(adapter, isBodyRequired)) {\n\t\t\t\t\t\tflux = flux.switchIfEmpty(Flux.error(getRequiredBodyError(bodyParameter)));\n\t\t\t\t\t}\n\t\t\t\t\tif (this.validator != null) {\n\t\t\t\t\t\tflux = flux.map(applyValidationIfApplicable(bodyParameter));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.just(adapter.fromPublisher(flux));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMono<?> mono = reader.readMono(elementType, request, Collections.emptyMap())\n\t\t\t\t\t\t\t.otherwise(ex -> Mono.error(getReadError(ex, bodyParameter)));\n\t\t\t\t\tif (checkRequired(adapter, isBodyRequired)) {\n\t\t\t\t\t\tmono = mono.otherwiseIfEmpty(Mono.error(getRequiredBodyError(bodyParameter)));\n\t\t\t\t\t}\n\t\t\t\t\tif (this.validator != null) {\n\t\t\t\t\t\tmono = mono.map(applyValidationIfApplicable(bodyParameter));\n\t\t\t\t\t}\n\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\treturn Mono.just(adapter.fromPublisher(mono));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn Mono.from(mono);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes));\n\t}","id":45508,"modified_method":"protected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,\n\t\t\tServerWebExchange exchange) {\n\n\t\tResolvableType bodyType = ResolvableType.forMethodParameter(bodyParameter);\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapterTo(bodyType.resolve());\n\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(bodyParameter);\n\t\tif (adapter != null) {\n\t\t\telementType = elementType.getGeneric(0);\n\t\t}\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tMediaType mediaType = request.getHeaders().getContentType();\n\t\tif (mediaType == null) {\n\t\t\tmediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tfor (HttpMessageReader<?> reader : getMessageReaders()) {\n\n\t\t\tMap<String, Object> hints = (reader instanceof ServerHttpMessageReader ?\n\t\t\t\t\t\t((ServerHttpMessageReader<?>)reader).resolveReadHints(bodyType, elementType,\n\t\t\t\t\t\t\t\tmediaType, exchange.getRequest()) : Collections.emptyMap());\n\n\t\t\tif (reader.canRead(elementType, mediaType, hints)) {\n\n\t\t\t\tif (adapter != null && adapter.getDescriptor().isMultiValue()) {\n\t\t\t\t\tFlux<?> flux = reader.read(elementType, request, hints)\n\t\t\t\t\t\t\t.onErrorResumeWith(ex -> Flux.error(getReadError(ex, bodyParameter)));\n\t\t\t\t\tif (checkRequired(adapter, isBodyRequired)) {\n\t\t\t\t\t\tflux = flux.switchIfEmpty(Flux.error(getRequiredBodyError(bodyParameter)));\n\t\t\t\t\t}\n\t\t\t\t\tif (this.validator != null) {\n\t\t\t\t\t\tflux = flux.map(applyValidationIfApplicable(bodyParameter));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.just(adapter.fromPublisher(flux));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMono<?> mono = reader.readMono(elementType, request, hints)\n\t\t\t\t\t\t\t.otherwise(ex -> Mono.error(getReadError(ex, bodyParameter)));\n\t\t\t\t\tif (checkRequired(adapter, isBodyRequired)) {\n\t\t\t\t\t\tmono = mono.otherwiseIfEmpty(Mono.error(getRequiredBodyError(bodyParameter)));\n\t\t\t\t\t}\n\t\t\t\t\tif (this.validator != null) {\n\t\t\t\t\t\tmono = mono.map(applyValidationIfApplicable(bodyParameter));\n\t\t\t\t\t}\n\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\treturn Mono.just(adapter.fromPublisher(mono));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn Mono.from(mono);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes));\n\t}","commit_id":"e74c59bf301ed18eb52fe79df03f1c3cef230a7e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprotected Mono<Void> writeBody(Object body, MethodParameter bodyType, ServerWebExchange exchange) {\n\n\t\tClass<?> bodyClass = bodyType.getParameterType();\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapterFrom(bodyClass, body);\n\n\t\tPublisher<?> publisher;\n\t\tResolvableType elementType;\n\t\tif (adapter != null) {\n\t\t\tpublisher = adapter.toPublisher(body);\n\t\t\telementType = adapter.getDescriptor().isNoValue() ?\n\t\t\t\t\tResolvableType.forClass(Void.class) :\n\t\t\t\t\tResolvableType.forMethodParameter(bodyType).getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher = Mono.justOrEmpty(body);\n\t\t\telementType = ResolvableType.forMethodParameter(bodyType);\n\t\t}\n\n\t\tif (void.class == elementType.getRawClass() || Void.class == elementType.getRawClass()) {\n\t\t\treturn Mono.from((Publisher<Void>) publisher);\n\t\t}\n\n\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(elementType);\n\t\tif (producibleTypes.isEmpty()) {\n\t\t\treturn Mono.error(new IllegalStateException(\n\t\t\t\t\t\"No converter for return value type: \" + elementType));\n\t\t}\n\n\t\tMediaType bestMediaType = selectMediaType(exchange, producibleTypes);\n\n\t\tif (bestMediaType != null) {\n\t\t\tfor (HttpMessageWriter<?> messageWriter : getMessageWriters()) {\n\t\t\t\tif (messageWriter.canWrite(elementType, bestMediaType, Collections.emptyMap())) {\n\t\t\t\t\tServerHttpResponse response = exchange.getResponse();\n\t\t\t\t\treturn messageWriter.write((Publisher) publisher, elementType,\n\t\t\t\t\t\t\tbestMediaType, response, Collections.emptyMap());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n\t}","id":45509,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprotected Mono<Void> writeBody(Object body, MethodParameter bodyParameter, ServerWebExchange exchange) {\n\n\t\tResolvableType bodyType = ResolvableType.forMethodParameter(bodyParameter);\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapterFrom(bodyType.resolve(), body);\n\n\t\tPublisher<?> publisher;\n\t\tResolvableType elementType;\n\t\tif (adapter != null) {\n\t\t\tpublisher = adapter.toPublisher(body);\n\t\t\telementType = adapter.getDescriptor().isNoValue() ?\n\t\t\t\t\tResolvableType.forClass(Void.class) :\n\t\t\t\t\tbodyType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher = Mono.justOrEmpty(body);\n\t\t\telementType = bodyType;\n\t\t}\n\n\t\tif (void.class == elementType.getRawClass() || Void.class == elementType.getRawClass()) {\n\t\t\treturn Mono.from((Publisher<Void>) publisher);\n\t\t}\n\n\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(elementType);\n\t\tif (producibleTypes.isEmpty()) {\n\t\t\treturn Mono.error(new IllegalStateException(\n\t\t\t\t\t\"No converter for return value type: \" + elementType));\n\t\t}\n\n\t\tMediaType bestMediaType = selectMediaType(exchange, producibleTypes);\n\n\t\tif (bestMediaType != null) {\n\t\t\tfor (HttpMessageWriter<?> messageWriter : getMessageWriters()) {\n\t\t\t\tMap<String, Object> hints = (messageWriter instanceof ServerHttpMessageWriter ?\n\t\t\t\t\t\t((ServerHttpMessageWriter<?>)messageWriter).resolveWriteHints(bodyType, elementType,\n\t\t\t\t\t\t\t\tbestMediaType, exchange.getRequest()) : Collections.emptyMap());\n\t\t\t\tif (messageWriter.canWrite(elementType, bestMediaType, hints)) {\n\n\t\t\t\t\tServerHttpResponse response = exchange.getResponse();\n\t\t\t\t\treturn messageWriter.write((Publisher) publisher, elementType,\n\t\t\t\t\t\t\tbestMediaType, response, hints);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n\t}","commit_id":"e74c59bf301ed18eb52fe79df03f1c3cef230a7e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param methodParam the method argument\n\t * @param targetType the type of object to create, not necessarily the same as\n\t * the method parameter type (e.g. for {@code HttpEntity<String>} method\n\t * parameter the target type is String)\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage,\n\t\t\tMethodParameter methodParam, Type targetType) throws IOException, HttpMediaTypeNotSupportedException {\n\n\t\tMediaType contentType;\n\t\ttry {\n\t\t\tcontentType = inputMessage.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage());\n\t\t}\n\t\tif (contentType == null) {\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tClass<?> contextClass = methodParam.getContainingClass();\n\n\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\tif (converter instanceof GenericHttpMessageConverter) {\n\t\t\t\tGenericHttpMessageConverter<?> genericConverter = (GenericHttpMessageConverter<?>) converter;\n\t\t\t\tif (genericConverter.canRead(targetType, contextClass, contentType)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Reading [\" + targetType + \"] as \\\"\" +\n\t\t\t\t\t\t\t\tcontentType + \"\\\" using [\" + converter + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn genericConverter.read(targetType, contextClass, inputMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\tClass<T> targetClass = (Class<T>)\n\t\t\t\t\tResolvableType.forMethodParameter(methodParam, targetType).resolve(Object.class);\n\t\t\tif (converter.canRead(targetClass, contentType)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Reading [\" + targetClass.getName() + \"] as \\\"\" +\n\t\t\t\t\t\t\tcontentType + \"\\\" using [\" + converter + \"]\");\n\t\t\t\t}\n\t\t\t\treturn ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);\n\t\t\t}\n\t\t}\n\n\t\tthrow new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes);\n\t}","id":45510,"modified_method":"/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param methodParam the method parameter descriptor (may be {@code null})\n\t * @param targetType the type of object to create, not necessarily the same as\n\t * the method parameter type (e.g. for {@code HttpEntity<String>} method\n\t * parameter the target type is String)\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter methodParam,\n\t\t\tType targetType) throws IOException, HttpMediaTypeNotSupportedException {\n\n\t\tMediaType contentType;\n\t\ttry {\n\t\t\tcontentType = inputMessage.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage());\n\t\t}\n\t\tif (contentType == null) {\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tClass<?> contextClass = (methodParam != null ? methodParam.getContainingClass() : null);\n\t\tClass<T> targetClass = (targetType instanceof Class<?> ? (Class<T>) targetType : null);\n\t\tif (targetClass == null) {\n\t\t\tResolvableType resolvableType = (methodParam != null ?\n\t\t\t\t\tResolvableType.forMethodParameter(methodParam) : ResolvableType.forType(targetType));\n\t\t\ttargetClass = (Class<T>) resolvableType.resolve();\n\t\t}\n\n\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\tif (converter instanceof GenericHttpMessageConverter) {\n\t\t\t\tGenericHttpMessageConverter<?> genericConverter = (GenericHttpMessageConverter<?>) converter;\n\t\t\t\tif (genericConverter.canRead(targetType, contextClass, contentType)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Reading [\" + targetType + \"] as \\\"\" +\n\t\t\t\t\t\t\t\tcontentType + \"\\\" using [\" + converter + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn genericConverter.read(targetType, contextClass, inputMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (targetClass != null) {\n\t\t\t\tif (converter.canRead(targetClass, contentType)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Reading [\" + targetClass.getName() + \"] as \\\"\" +\n\t\t\t\t\t\t\t\tcontentType + \"\\\" using [\" + converter + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes);\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Class<?> getNestedParameterType() {\n\t\tif (this.nestingLevel > 1) {\n\t\t\tType type = getGenericParameterType();\n\t\t\tfor (int i = 2; i <= this.nestingLevel; i++) {\n\t\t\t\tif (type instanceof ParameterizedType) {\n\t\t\t\t\tType[] args = ((ParameterizedType) type).getActualTypeArguments();\n\t\t\t\t\tInteger index = getTypeIndexForLevel(i);\n\t\t\t\t\ttype = args[index != null ? index : args.length - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type instanceof Class) {\n\t\t\t\treturn (Class<?>) type;\n\t\t\t}\n\t\t\telse if (type instanceof ParameterizedType) {\n\t\t\t\tType arg = ((ParameterizedType) type).getRawType();\n\t\t\t\tif (arg instanceof Class) {\n\t\t\t\t\treturn (Class<?>) arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Object.class;\n\t\t}\n\t\telse {\n\t\t\treturn getParameterType();\n\t\t}\n\t}","id":45511,"modified_method":"/**\n\t * Return the nested type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @see #getNestingLevel()\n\t * @since 3.1\n\t */\n\tpublic Class<?> getNestedParameterType() {\n\t\tif (this.nestingLevel > 1) {\n\t\t\tType type = getGenericParameterType();\n\t\t\tfor (int i = 2; i <= this.nestingLevel; i++) {\n\t\t\t\tif (type instanceof ParameterizedType) {\n\t\t\t\t\tType[] args = ((ParameterizedType) type).getActualTypeArguments();\n\t\t\t\t\tInteger index = getTypeIndexForLevel(i);\n\t\t\t\t\ttype = args[index != null ? index : args.length - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type instanceof Class) {\n\t\t\t\treturn (Class<?>) type;\n\t\t\t}\n\t\t\telse if (type instanceof ParameterizedType) {\n\t\t\t\tType arg = ((ParameterizedType) type).getRawType();\n\t\t\t\tif (arg instanceof Class) {\n\t\t\t\t\treturn (Class<?>) arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Object.class;\n\t\t}\n\t\telse {\n\t\t\treturn getParameterType();\n\t\t}\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Class<?> getCollectionParameterType(MethodParameter parameter) {\n\t\tClass<?> paramType = parameter.getParameterType();\n\t\tif (Collection.class.equals(paramType) || List.class.isAssignableFrom(paramType)){\n\t\t\tClass<?> valueType = GenericCollectionTypeResolver.getCollectionParameterType(parameter);\n\t\t\tif (valueType != null) {\n\t\t\t\treturn valueType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":45512,"modified_method":"private Class<?> getCollectionParameterType(MethodParameter param) {\n\t\tClass<?> paramType = param.getNestedParameterType();\n\t\tif (Collection.class.equals(paramType) || List.class.isAssignableFrom(paramType)){\n\t\t\tClass<?> valueType = GenericCollectionTypeResolver.getCollectionParameterType(param);\n\t\t\tif (valueType != null) {\n\t\t\t\treturn valueType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isMultipartFileCollection(MethodParameter parameter) {\n\t\tClass<?> collectionType = getCollectionParameterType(parameter);\n\t\treturn (collectionType != null && collectionType.equals(MultipartFile.class));\n\t}","id":45513,"modified_method":"private boolean isMultipartFileCollection(MethodParameter param) {\n\t\tClass<?> collectionType = getCollectionParameterType(param);\n\t\treturn (collectionType != null && collectionType.equals(MultipartFile.class));\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isMultipartFileArray(MethodParameter parameter) {\n\t\tClass<?> paramType = parameter.getParameterType().getComponentType();\n\t\treturn (paramType != null && MultipartFile.class.equals(paramType));\n\t}","id":45514,"modified_method":"private boolean isMultipartFileArray(MethodParameter param) {\n\t\tClass<?> paramType = param.getNestedParameterType().getComponentType();\n\t\treturn (paramType != null && MultipartFile.class.equals(paramType));\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isPartCollection(MethodParameter parameter) {\n\t\tClass<?> collectionType = getCollectionParameterType(parameter);\n\t\treturn (collectionType != null && \"javax.servlet.http.Part\".equals(collectionType.getName()));\n\t}","id":45515,"modified_method":"private boolean isPartCollection(MethodParameter param) {\n\t\tClass<?> collectionType = getCollectionParameterType(param);\n\t\treturn (collectionType != null && \"javax.servlet.http.Part\".equals(collectionType.getName()));\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isPartArray(MethodParameter parameter) {\n\t\tClass<?> paramType = parameter.getParameterType().getComponentType();\n\t\treturn (paramType != null && \"javax.servlet.http.Part\".equals(paramType.getName()));\n\t}","id":45516,"modified_method":"private boolean isPartArray(MethodParameter param) {\n\t\tClass<?> paramType = param.getNestedParameterType().getComponentType();\n\t\treturn (paramType != null && \"javax.servlet.http.Part\".equals(paramType.getName()));\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private String getPartName(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tString partName = (annot != null ? annot.value() : \"\");\n\t\tif (partName.length() == 0) {\n\t\t\tpartName = parameter.getParameterName();\n\t\t\tAssert.notNull(partName, \"Request part name for argument type [\" + parameter.getParameterType().getName() +\n\t\t\t\t\t\"] not specified, and parameter name information not found in class file either.\");\n\t\t}\n\t\treturn partName;\n\t}","id":45517,"modified_method":"private String getPartName(MethodParameter param) {\n\t\tRequestPart annot = param.getParameterAnnotation(RequestPart.class);\n\t\tString partName = (annot != null ? annot.value() : \"\");\n\t\tif (partName.length() == 0) {\n\t\t\tpartName = param.getParameterName();\n\t\t\tif (partName == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Request part name for argument type [\" +\n\t\t\t\t\t\tparam.getNestedParameterType().getName() +\n\t\t\t\t\t\t\"] not specified, and parameter name information not found in class file either.\");\n\t\t\t}\n\t\t}\n\t\treturn partName;\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest request, WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\tassertIsMultipartRequest(servletRequest);\n\n\t\tMultipartHttpServletRequest multipartRequest =\n\t\t\tWebUtils.getNativeRequest(servletRequest, MultipartHttpServletRequest.class);\n\n\t\tString partName = getPartName(parameter);\n\t\tObject arg;\n\n\t\tif (MultipartFile.class.equals(parameter.getParameterType())) {\n\t\t\tAssert.notNull(multipartRequest, \"Expected MultipartHttpServletRequest: is a MultipartResolver configured?\");\n\t\t\targ = multipartRequest.getFile(partName);\n\t\t}\n\t\telse if (isMultipartFileCollection(parameter)) {\n\t\t\tAssert.notNull(multipartRequest, \"Expected MultipartHttpServletRequest: is a MultipartResolver configured?\");\n\t\t\targ = multipartRequest.getFiles(partName);\n\t\t}\n\t\telse if (isMultipartFileArray(parameter)) {\n\t\t\tAssert.notNull(multipartRequest, \"Expected MultipartHttpServletRequest: is a MultipartResolver configured?\");\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(partName);\n\t\t\targ = files.toArray(new MultipartFile[files.size()]);\n\t\t}\n\t\telse if (\"javax.servlet.http.Part\".equals(parameter.getParameterType().getName())) {\n\t\t\tassertIsMultipartRequest(servletRequest);\n\t\t\targ = servletRequest.getPart(partName);\n\t\t}\n\t\telse if (isPartCollection(parameter)) {\n\t\t\tassertIsMultipartRequest(servletRequest);\n\t\t\targ = new ArrayList<Object>(servletRequest.getParts());\n\t\t}\n\t\telse if (isPartArray(parameter)) {\n\t\t\tassertIsMultipartRequest(servletRequest);\n\t\t\targ = RequestPartResolver.resolvePart(servletRequest);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tHttpInputMessage inputMessage = new RequestPartServletServerHttpRequest(servletRequest, partName);\n\t\t\t\targ = readWithMessageConverters(inputMessage, parameter, parameter.getParameterType());\n\t\t\t\tWebDataBinder binder = binderFactory.createBinder(request, arg, partName);\n\t\t\t\tif (arg != null) {\n\t\t\t\t\tvalidate(binder, parameter);\n\t\t\t\t}\n\t\t\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + partName, binder.getBindingResult());\n\t\t\t}\n\t\t\tcatch (MissingServletRequestPartException ex) {\n\t\t\t\t// handled below\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isRequired = (annot == null || annot.required());\n\n\t\tif (arg == null && isRequired) {\n\t\t\tthrow new MissingServletRequestPartException(partName);\n\t\t}\n\n\t\treturn arg;\n\t}","id":45518,"modified_method":"@Override\n\tpublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest request, WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\tassertIsMultipartRequest(servletRequest);\n\n\t\tMultipartHttpServletRequest multipartRequest =\n\t\t\t\tWebUtils.getNativeRequest(servletRequest, MultipartHttpServletRequest.class);\n\n\t\tClass<?> paramType = parameter.getParameterType();\n\t\tboolean optional = paramType.getName().equals(\"java.util.Optional\");\n\t\tif (optional) {\n\t\t\tparameter.increaseNestingLevel();\n\t\t\tparamType = parameter.getNestedParameterType();\n\t\t}\n\n\t\tString partName = getPartName(parameter);\n\t\tObject arg;\n\n\t\tif (MultipartFile.class.equals(paramType)) {\n\t\t\tAssert.notNull(multipartRequest, \"Expected MultipartHttpServletRequest: is a MultipartResolver configured?\");\n\t\t\targ = multipartRequest.getFile(partName);\n\t\t}\n\t\telse if (isMultipartFileCollection(parameter)) {\n\t\t\tAssert.notNull(multipartRequest, \"Expected MultipartHttpServletRequest: is a MultipartResolver configured?\");\n\t\t\targ = multipartRequest.getFiles(partName);\n\t\t}\n\t\telse if (isMultipartFileArray(parameter)) {\n\t\t\tAssert.notNull(multipartRequest, \"Expected MultipartHttpServletRequest: is a MultipartResolver configured?\");\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(partName);\n\t\t\targ = files.toArray(new MultipartFile[files.size()]);\n\t\t}\n\t\telse if (\"javax.servlet.http.Part\".equals(paramType.getName())) {\n\t\t\tassertIsMultipartRequest(servletRequest);\n\t\t\targ = servletRequest.getPart(partName);\n\t\t}\n\t\telse if (isPartCollection(parameter)) {\n\t\t\tassertIsMultipartRequest(servletRequest);\n\t\t\targ = new ArrayList<Object>(servletRequest.getParts());\n\t\t}\n\t\telse if (isPartArray(parameter)) {\n\t\t\tassertIsMultipartRequest(servletRequest);\n\t\t\targ = RequestPartResolver.resolvePart(servletRequest);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tHttpInputMessage inputMessage = new RequestPartServletServerHttpRequest(servletRequest, partName);\n\t\t\t\targ = readWithMessageConverters(inputMessage, parameter, parameter.getNestedGenericParameterType());\n\t\t\t\tWebDataBinder binder = binderFactory.createBinder(request, arg, partName);\n\t\t\t\tif (arg != null) {\n\t\t\t\t\tvalidate(binder, parameter);\n\t\t\t\t}\n\t\t\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + partName, binder.getBindingResult());\n\t\t\t}\n\t\t\tcatch (MissingServletRequestPartException ex) {\n\t\t\t\t// handled below\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isRequired = ((annot == null || annot.required()) && !optional);\n\n\t\tif (arg == null && isRequired) {\n\t\t\tthrow new MissingServletRequestPartException(partName);\n\t\t}\n\t\tif (optional) {\n\t\t\targ = Optional.ofNullable(arg);\n\t\t}\n\n\t\treturn arg;\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Validate the request part if applicable.\n\t * <p>The default implementation checks for {@code @javax.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter\n\t * @throws MethodArgumentNotValidException in case of a binding error which\n\t * is meant to be fatal (i.e. without a declared {@link Errors} parameter)\n\t * @see #isBindingErrorFatal\n\t */\n\tprotected void validate(WebDataBinder binder, MethodParameter parameter) throws MethodArgumentNotValidException {\n\t\tAnnotation[] annotations = parameter.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\t\tif (isBindingErrorFatal(parameter)) {\n\t\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, bindingResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":45519,"modified_method":"/**\n\t * Validate the request part if applicable.\n\t * <p>The default implementation checks for {@code @javax.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param param the method parameter\n\t * @throws MethodArgumentNotValidException in case of a binding error which\n\t * is meant to be fatal (i.e. without a declared {@link Errors} parameter)\n\t * @see #isBindingErrorFatal\n\t */\n\tprotected void validate(WebDataBinder binder, MethodParameter param) throws MethodArgumentNotValidException {\n\t\tAnnotation[] annotations = param.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\t\tif (isBindingErrorFatal(param)) {\n\t\t\t\t\t\tthrow new MethodArgumentNotValidException(param, bindingResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveRequestPartRequired() throws Exception {\n\t\ttry {\n\t\t\ttestResolveArgument(null, paramValidRequestPart);\n\t\t\tfail(\"Expected exception\");\n\t\t} catch (MissingServletRequestPartException e) {\n\t\t\tassertEquals(\"requestPart\", e.getRequestPartName());\n\t\t}\n\t}","id":45520,"modified_method":"@Test\n\tpublic void resolveRequestPartRequired() throws Exception {\n\t\ttry {\n\t\t\ttestResolveArgument(null, paramValidRequestPart);\n\t\t\tfail(\"Expected exception\");\n\t\t}\n\t\tcatch (MissingServletRequestPartException ex) {\n\t\t\tassertEquals(\"requestPart\", ex.getRequestPartName());\n\t\t}\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveRequestPartNotValid() throws Exception {\n\t\ttry {\n\t\t\ttestResolveArgument(new SimpleBean(null), paramValidRequestPart);\n\t\t\tfail(\"Expected exception\");\n\t\t} catch (MethodArgumentNotValidException e) {\n\t\t\tassertEquals(\"requestPart\", e.getBindingResult().getObjectName());\n\t\t\tassertEquals(1, e.getBindingResult().getErrorCount());\n\t\t\tassertNotNull(e.getBindingResult().getFieldError(\"name\"));\n\t\t}\n\t}","id":45521,"modified_method":"@Test\n\tpublic void resolveRequestPartNotValid() throws Exception {\n\t\ttry {\n\t\t\ttestResolveArgument(new SimpleBean(null), paramValidRequestPart);\n\t\t\tfail(\"Expected exception\");\n\t\t}\n\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\tassertEquals(\"requestPart\", ex.getBindingResult().getObjectName());\n\t\t\tassertEquals(1, ex.getBindingResult().getErrorCount());\n\t\t\tassertNotNull(ex.getBindingResult().getFieldError(\"name\"));\n\t\t}\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void testResolveArgument(SimpleBean argValue, MethodParameter parameter) throws IOException, Exception {\n\t\tMediaType contentType = MediaType.TEXT_PLAIN;\n\n\t\tgiven(messageConverter.canRead(SimpleBean.class, contentType)).willReturn(true);\n\t\tgiven(messageConverter.read(eq(SimpleBean.class), isA(RequestPartServletServerHttpRequest.class))).willReturn(argValue);\n\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tObject actualValue = resolver.resolveArgument(parameter, mavContainer, webRequest, new ValidatingBinderFactory());\n\n\t\tassertEquals(\"Invalid argument value\", argValue, actualValue);\n\t\tassertFalse(\"The requestHandled flag shouldn't change\", mavContainer.isRequestHandled());\n\t}","id":45522,"modified_method":"private void testResolveArgument(SimpleBean argValue, MethodParameter parameter) throws Exception {\n\t\tgiven(messageConverter.canRead(SimpleBean.class, MediaType.TEXT_PLAIN)).willReturn(true);\n\t\tgiven(messageConverter.read(eq(SimpleBean.class), isA(RequestPartServletServerHttpRequest.class))).willReturn(argValue);\n\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tObject actualValue = resolver.resolveArgument(parameter, mavContainer, webRequest, new ValidatingBinderFactory());\n\n\t\tassertEquals(\"Invalid argument value\", argValue, actualValue);\n\t\tassertFalse(\"The requestHandled flag shouldn't change\", mavContainer.isRequestHandled());\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supportsParameter() {\n\t\tassertTrue(\"RequestPart parameter not supported\", resolver.supportsParameter(paramRequestPart));\n\t\tassertTrue(\"MultipartFile parameter not supported\", resolver.supportsParameter(paramMultipartFileNotAnnot));\n\t\tassertTrue(\"Part parameter not supported\", resolver.supportsParameter(paramPart));\n\t\tassertTrue(\"List<Part> parameter not supported\", resolver.supportsParameter(paramPartList));\n\t\tassertTrue(\"Part[] parameter not supported\", resolver.supportsParameter(paramPartArray));\n\t\tassertTrue(\"MultipartFile parameter not supported\", resolver.supportsParameter(paramMultipartFile));\n\t\tassertTrue(\"List<MultipartFile> parameter not supported\", resolver.supportsParameter(paramMultipartFileList));\n\t\tassertTrue(\"MultipartFile[] parameter not supported\", resolver.supportsParameter(paramMultipartFileArray));\n\t\tassertFalse(\"non-RequestPart parameter supported\", resolver.supportsParameter(paramInt));\n\t\tassertFalse(\"@RequestParam args not supported\", resolver.supportsParameter(paramRequestParamAnnot));\n\t}","id":45523,"modified_method":"@Test\n\tpublic void supportsParameter() {\n\t\tassertTrue(\"RequestPart parameter not supported\", resolver.supportsParameter(paramRequestPart));\n\t\tassertTrue(\"MultipartFile parameter not supported\", resolver.supportsParameter(paramMultipartFileNotAnnot));\n\t\tassertTrue(\"Part parameter not supported\", resolver.supportsParameter(paramPart));\n\t\tassertTrue(\"List<Part> parameter not supported\", resolver.supportsParameter(paramPartList));\n\t\tassertTrue(\"Part[] parameter not supported\", resolver.supportsParameter(paramPartArray));\n\t\tassertTrue(\"MultipartFile parameter not supported\", resolver.supportsParameter(paramMultipartFile));\n\t\tassertTrue(\"List<MultipartFile> parameter not supported\", resolver.supportsParameter(paramMultipartFileList));\n\t\tassertTrue(\"MultipartFile[] parameter not supported\", resolver.supportsParameter(paramMultipartFileArray));\n\t\tassertFalse(\"non-RequestPart parameter should not be supported\", resolver.supportsParameter(paramInt));\n\t\tassertFalse(\"@RequestParam args should not be supported\", resolver.supportsParameter(paramRequestParamAnnot));\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(expected=MultipartException.class)\n\tpublic void isMultipartRequest() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tresolver.resolveArgument(paramMultipartFile, new ModelAndViewContainer(), new ServletWebRequest(request), null);\n\t\tfail(\"Expected exception\");\n\t}","id":45524,"modified_method":"@Test(expected = MultipartException.class)\n\tpublic void isMultipartRequest() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tresolver.resolveArgument(paramMultipartFile, new ModelAndViewContainer(), new ServletWebRequest(request), null);\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t@Before\n\tpublic void setUp() throws Exception {\n\n\t\tMethod method = getClass().getMethod(\"handle\", SimpleBean.class, SimpleBean.class,\n\t\t\t\tSimpleBean.class, MultipartFile.class, List.class, MultipartFile[].class,\n\t\t\t\tInteger.TYPE, MultipartFile.class, Part.class, List.class,\n\t\t\t\tPart[].class, MultipartFile.class);\n\n\t\tparamRequestPart = new MethodParameter(method, 0);\n\t\tparamRequestPart.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\tparamNamedRequestPart = new MethodParameter(method, 1);\n\t\tparamValidRequestPart = new MethodParameter(method, 2);\n\t\tparamMultipartFile = new MethodParameter(method, 3);\n\t\tparamMultipartFileList = new MethodParameter(method, 4);\n\t\tparamMultipartFileArray = new MethodParameter(method, 5);\n\t\tparamInt = new MethodParameter(method, 6);\n\t\tparamMultipartFileNotAnnot = new MethodParameter(method, 7);\n\t\tparamMultipartFileNotAnnot.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\tparamPart = new MethodParameter(method, 8);\n\t\tparamPart.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\tparamPartList = new MethodParameter(method, 9);\n\t\tparamPartArray = new MethodParameter(method, 10);\n\t\tparamRequestParamAnnot = new MethodParameter(method, 11);\n\n\t\tmessageConverter = mock(HttpMessageConverter.class);\n\t\tgiven(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));\n\n\t\tresolver = new RequestPartMethodArgumentResolver(Collections.<HttpMessageConverter<?>>singletonList(messageConverter));\n\t\treset(messageConverter);\n\n\t\tmultipartFile1 = new MockMultipartFile(\"requestPart\", \"\", \"text/plain\", (byte[]) null);\n\t\tmultipartFile2 = new MockMultipartFile(\"requestPart\", \"\", \"text/plain\", (byte[]) null);\n\t\tmultipartRequest = new MockMultipartHttpServletRequest();\n\t\tmultipartRequest.addFile(multipartFile1);\n\t\tmultipartRequest.addFile(multipartFile2);\n\t\tservletResponse = new MockHttpServletResponse();\n\t\twebRequest = new ServletWebRequest(multipartRequest, servletResponse);\n\t}","id":45525,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tMethod method = getClass().getMethod(\"handle\", SimpleBean.class, SimpleBean.class,\n\t\t\t\tSimpleBean.class, MultipartFile.class, List.class, MultipartFile[].class,\n\t\t\t\tInteger.TYPE, MultipartFile.class, Part.class, List.class, Part[].class,\n\t\t\t\tMultipartFile.class, Optional.class, Optional.class, Optional.class);\n\n\t\tparamRequestPart = new MethodParameter(method, 0);\n\t\tparamRequestPart.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\tparamNamedRequestPart = new MethodParameter(method, 1);\n\t\tparamValidRequestPart = new MethodParameter(method, 2);\n\t\tparamMultipartFile = new MethodParameter(method, 3);\n\t\tparamMultipartFileList = new MethodParameter(method, 4);\n\t\tparamMultipartFileArray = new MethodParameter(method, 5);\n\t\tparamInt = new MethodParameter(method, 6);\n\t\tparamMultipartFileNotAnnot = new MethodParameter(method, 7);\n\t\tparamMultipartFileNotAnnot.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\tparamPart = new MethodParameter(method, 8);\n\t\tparamPart.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\tparamPartList = new MethodParameter(method, 9);\n\t\tparamPartArray = new MethodParameter(method, 10);\n\t\tparamRequestParamAnnot = new MethodParameter(method, 11);\n\t\toptionalMultipartFile = new MethodParameter(method, 12);\n\t\toptionalMultipartFile.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\toptionalPart = new MethodParameter(method, 13);\n\t\toptionalPart.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());\n\t\toptionalRequestPart = new MethodParameter(method, 14);\n\n\t\tmessageConverter = mock(HttpMessageConverter.class);\n\t\tgiven(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));\n\n\t\tresolver = new RequestPartMethodArgumentResolver(Collections.<HttpMessageConverter<?>>singletonList(messageConverter));\n\t\treset(messageConverter);\n\n\t\tmultipartFile1 = new MockMultipartFile(\"requestPart\", \"\", \"text/plain\", (byte[]) null);\n\t\tmultipartFile2 = new MockMultipartFile(\"requestPart\", \"\", \"text/plain\", (byte[]) null);\n\t\tmultipartRequest = new MockMultipartHttpServletRequest();\n\t\tmultipartRequest.addFile(multipartFile1);\n\t\tmultipartRequest.addFile(multipartFile2);\n\t\tservletResponse = new MockHttpServletResponse();\n\t\twebRequest = new ServletWebRequest(multipartRequest, servletResponse);\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void isMultipartRequestPut() throws Exception {\n\t\tthis.multipartRequest.setMethod(\"PUT\");\n\t\tObject actual = resolver.resolveArgument(paramMultipartFile, null, webRequest, null);\n\t\tassertNotNull(actual);\n\t\tassertSame(multipartFile1, actual);\n\t}","id":45526,"modified_method":"@Test  // SPR-9079\n\tpublic void isMultipartRequestPut() throws Exception {\n\t\tthis.multipartRequest.setMethod(\"PUT\");\n\t\tObject actual = resolver.resolveArgument(paramMultipartFile, null, webRequest, null);\n\t\tassertSame(multipartFile1, actual);\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveRequestPartValid() throws Exception {\n\t\ttestResolveArgument(new SimpleBean(\"foo\"), paramNamedRequestPart);\n\t}","id":45527,"modified_method":"@Test\n\tpublic void resolveRequestPartValid() throws Exception {\n\t\ttestResolveArgument(new SimpleBean(\"foo\"), paramValidRequestPart);\n\t}","commit_id":"6ebac00f32907c668b778ffeb474731d1264a71b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\r\n\t * Send the request. The objects id will be replaced if it was 0 before\r\n\t * (on add requests).\r\n\t *\r\n\t * @param requestMethod The http method used when talking with the server.\r\n\t * @param urlSuffix The suffix to add at the server url.\r\n\t * @param osm The primitive to encode to the server.\r\n\t * @param addBody <code>true<\/code>, if the whole primitive body should be added.\r\n\t * \t\t<code>false<\/code>, if only the id is encoded.\r\n\t */\r\n\tprivate void sendRequestRetry(String requestMethod, String urlSuffix,\r\n\t\t\tOsmPrimitive osm, boolean addBody, int retries) {\r\n\t\ttry {\r\n\t\t\tif (cancel)\r\n\t\t\t\treturn; // assume cancel\r\n\t\t\tString version = Main.pref.get(\"osm-server.version\", \"0.5\");\r\n\t\t\tURL url = new URL(\r\n\t\t\t\t\tMain.pref.get(\"osm-server.url\") +\r\n\t\t\t\t\t\"/\" + version +\r\n\t\t\t\t\t\"/\" + urlSuffix + \r\n\t\t\t\t\t\"/\" + (osm.id==0 ? \"create\" : osm.id));\r\n\t\t\tSystem.out.print(\"upload to: \"+url+ \"...\" );\r\n\t\t\tactiveConnection = (HttpURLConnection)url.openConnection();\r\n\t\t\tactiveConnection.setConnectTimeout(15000);\r\n\t\t\tactiveConnection.setRequestMethod(requestMethod);\r\n\t\t\tif (addBody)\r\n\t\t\t\tactiveConnection.setDoOutput(true);\r\n\t\t\tactiveConnection.connect();\r\n\t\t\tSystem.out.println(\"connected\");\n\t\t\tif (addBody) {\r\n\t\t\t\tOutputStream out = activeConnection.getOutputStream();\r\n\t\t\t\tOsmWriter.output(out, new OsmWriter.Single(osm, true));\r\n\t\t\t\tout.close();\r\n\t\t\t}\r\n\r\n\t\t\tint retCode = activeConnection.getResponseCode();\r\n\t\t\tif (retCode == 200 && osm.id == 0)\r\n\t\t\t\tosm.id = readId(activeConnection.getInputStream());\r\n\t\t\tSystem.out.println(\"got return: \"+retCode+\" with id \"+osm.id);\r\n\t\t\tString retMsg = activeConnection.getResponseMessage();\r\n\t\t\tactiveConnection.disconnect();\r\n\t\t\tif (retCode == 410 && requestMethod.equals(\"DELETE\"))\r\n\t\t\t\treturn; // everything fine.. was already deleted.\r\n\t\t\tif (retCode != 200 && retCode != 412) {\r\n\t\t\t\tif (retries >= 0) {\n\t\t\t\t\tretries--;\n\t\t\t\t\tSystem.out.print(\"backing off for 10 seconds...\");\n\t\t\t\t\tThread.sleep(10000);\n\t\t\t\t\tSystem.out.println(\"retrying (\"+retries+\" left)\");\r\n\t\t\t\t\tsendRequestRetry(requestMethod, urlSuffix, osm, addBody, retries);\n\t\t\t\t} else { \n\t\t\t\t\t// Look for a detailed error message from the server\r\n\t\t\t\t\tif (activeConnection.getHeaderField(\"Error\") != null)\r\n\t\t\t\t\t\tretMsg += \"\\n\" + activeConnection.getHeaderField(\"Error\");\r\n\r\n\t\t\t\t\t// Report our error\r\n\t\t\t\t\tByteArrayOutputStream o = new ByteArrayOutputStream();\r\n\t\t\t\t\tOsmWriter.output(o, new OsmWriter.Single(osm, true));\r\n\t\t\t\t\tSystem.out.println(new String(o.toByteArray(), \"UTF-8\").toString());\r\n\t\t\t\t\tthrow new RuntimeException(retCode+\" \"+retMsg);\r\n\t\t\t\t}\n\t\t\t}\r\n\t\t} catch (UnknownHostException e) {\r\n\t\t\tthrow new RuntimeException(tr(\"Unknown host\")+\": \"+e.getMessage(), e);\r\n\t\t} catch(SocketTimeoutException e) {\n\t\t\tSystem.out.println(\" timed out, retries left: \" + retries);\n\t\t\tif (cancel)\r\n\t\t\t\treturn; // assume cancel\r\n\t\t\tif (retries-- > 0)\n\t\t\t\tsendRequestRetry(requestMethod, urlSuffix, osm, addBody, retries);\n\t\t\telse\n\t\t\t\tthrow new RuntimeException(e.getMessage()+ \" \" + e.getClass().getCanonicalName(), e);\n\t\t} catch (Exception e) {\r\n\t\t\tif (cancel)\r\n\t\t\t\treturn; // assume cancel\r\n\t\t\tif (e instanceof RuntimeException)\r\n\t\t\t\tthrow (RuntimeException)e;\r\n\t\t\tthrow new RuntimeException(e.getMessage()+ \" \" + e.getClass().getCanonicalName(), e);\r\n\t\t}\r\n\t}","id":45528,"modified_method":"/**\r\n\t * Send the request. The objects id will be replaced if it was 0 before\r\n\t * (on add requests).\r\n\t *\r\n\t * @param requestMethod The http method used when talking with the server.\r\n\t * @param urlSuffix The suffix to add at the server url.\r\n\t * @param osm The primitive to encode to the server.\r\n\t * @param addBody <code>true<\/code>, if the whole primitive body should be added.\r\n\t * \t\t<code>false<\/code>, if only the id is encoded.\r\n\t */\r\n\tprivate void sendRequestRetry(String requestMethod, String urlSuffix,\r\n\t\t\tOsmPrimitive osm, boolean addBody, int retries) {\r\n\t\ttry {\r\n\t\t\tif (cancel)\r\n\t\t\t\treturn; // assume cancel\r\n\t\t\tString version = Main.pref.get(\"osm-server.version\", \"0.5\");\r\n\t\t\tURL url = new URL(\r\n\t\t\t\t\tMain.pref.get(\"osm-server.url\") +\r\n\t\t\t\t\t\"/\" + version +\r\n\t\t\t\t\t\"/\" + urlSuffix + \r\n\t\t\t\t\t\"/\" + (osm.id==0 ? \"create\" : osm.id));\r\n\t\t\tSystem.out.print(\"upload to: \"+url+ \"...\" );\r\n\t\t\tactiveConnection = (HttpURLConnection)url.openConnection();\r\n\t\t\tactiveConnection.setConnectTimeout(15000);\r\n\t\t\tactiveConnection.setRequestMethod(requestMethod);\r\n            addAuth(activeConnection);\n\t\t\tif (addBody) {\n\t\t\t\tactiveConnection.setDoOutput(true);\r\n\t\t\t\tOutputStream out = activeConnection.getOutputStream();\r\n\t\t\t\tOsmWriter.output(out, new OsmWriter.Single(osm, true));\r\n\t\t\t\tout.close();\r\n            }\n\t\t\tactiveConnection.connect();\r\n\t\t\tSystem.out.println(\"connected\");\n\r\n\t\t\tint retCode = activeConnection.getResponseCode();\r\n\t\t\tif (retCode == 200 && osm.id == 0)\r\n\t\t\t\tosm.id = readId(activeConnection.getInputStream());\r\n\t\t\tSystem.out.println(\"got return: \"+retCode+\" with id \"+osm.id);\r\n\t\t\tString retMsg = activeConnection.getResponseMessage();\r\n\t\t\tactiveConnection.disconnect();\r\n\t\t\tif (retCode == 410 && requestMethod.equals(\"DELETE\"))\r\n\t\t\t\treturn; // everything fine.. was already deleted.\r\n\t\t\tif (retCode != 200 && retCode != 412) {\r\n\t\t\t\tif (retries >= 0) {\n\t\t\t\t\tretries--;\n\t\t\t\t\tSystem.out.print(\"backing off for 10 seconds...\");\n\t\t\t\t\tThread.sleep(10000);\n\t\t\t\t\tSystem.out.println(\"retrying (\"+retries+\" left)\");\r\n\t\t\t\t\tsendRequestRetry(requestMethod, urlSuffix, osm, addBody, retries);\n\t\t\t\t} else { \n\t\t\t\t\t// Look for a detailed error message from the server\r\n\t\t\t\t\tif (activeConnection.getHeaderField(\"Error\") != null)\r\n\t\t\t\t\t\tretMsg += \"\\n\" + activeConnection.getHeaderField(\"Error\");\r\n\r\n\t\t\t\t\t// Report our error\r\n\t\t\t\t\tByteArrayOutputStream o = new ByteArrayOutputStream();\r\n\t\t\t\t\tOsmWriter.output(o, new OsmWriter.Single(osm, true));\r\n\t\t\t\t\tSystem.out.println(new String(o.toByteArray(), \"UTF-8\").toString());\r\n\t\t\t\t\tthrow new RuntimeException(retCode+\" \"+retMsg);\r\n\t\t\t\t}\n\t\t\t}\r\n\t\t} catch (UnknownHostException e) {\r\n\t\t\tthrow new RuntimeException(tr(\"Unknown host\")+\": \"+e.getMessage(), e);\r\n\t\t} catch(SocketTimeoutException e) {\n\t\t\tSystem.out.println(\" timed out, retries left: \" + retries);\n\t\t\tif (cancel)\r\n\t\t\t\treturn; // assume cancel\r\n\t\t\tif (retries-- > 0)\n\t\t\t\tsendRequestRetry(requestMethod, urlSuffix, osm, addBody, retries);\n\t\t\telse\n\t\t\t\tthrow new RuntimeException(e.getMessage()+ \" \" + e.getClass().getCanonicalName(), e);\n\t\t} catch (Exception e) {\r\n\t\t\tif (cancel)\r\n\t\t\t\treturn; // assume cancel\r\n\t\t\tif (e instanceof RuntimeException)\r\n\t\t\t\tthrow (RuntimeException)e;\r\n\t\t\tthrow new RuntimeException(e.getMessage()+ \" \" + e.getClass().getCanonicalName(), e);\r\n\t\t}\r\n\t}","commit_id":"3c32b2574e6074091a4fa0595c0f32b74b0f13df","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Run command and place the result to a remote Hudson installation\n     */\n    public static int remotePost(String[] args) throws Exception {\n        String projectName = args[0];\n\n        String home = getHudsonHome();\n        if(!home.endsWith(\"/\"))     home = home + '/';  // make sure it ends with '/'\n\n        {// check if the home is set correctly\n            HttpURLConnection con = (HttpURLConnection)new URL(home).openConnection();\n            con.connect();\n            if(con.getResponseCode()!=200\n            || con.getHeaderField(\"X-Hudson\")==null) {\n                System.err.println(home+\" is not Hudson (\"+con.getResponseMessage()+\")\");\n                return -1;\n            }\n        }\n\n        String projectNameEnc = URLEncoder.encode(projectName,\"UTF-8\").replaceAll(\"\\\\+\",\"%20\");\n\n        {// check if the job name is correct\n            HttpURLConnection con = (HttpURLConnection)new URL(home+\"job/\"+projectNameEnc+\"/acceptBuildResult\").openConnection();\n            con.connect();\n            if(con.getResponseCode()!=200) {\n                System.err.println(projectName+\" is not a valid job name on \"+home+\" (\"+con.getResponseMessage()+\")\");\n                return -1;\n            }\n        }\n\n        // start a remote connection\n        HttpURLConnection con = (HttpURLConnection) new URL(home+\"job/\"+projectNameEnc+\"/postBuildResult\").openConnection();\n        con.setDoOutput(true);\n        con.connect();\n        OutputStream os = con.getOutputStream();\n        Writer w = new OutputStreamWriter(os,\"UTF-8\");\n        w.write(\"<?xml version='1.0' encoding='UTF-8'?>\");\n        w.write(\"<run><log encoding='hexBinary'>\");\n        w.flush();\n\n        // run the command\n        long start = System.currentTimeMillis();\n\n        List<String> cmd = new ArrayList<String>();\n        for( int i=1; i<args.length; i++ )\n            cmd.add(args[i]);\n        Proc proc = new Proc.LocalProc(cmd.toArray(new String[0]),(String[])null,System.in,\n            new DualOutputStream(System.out,new EncodingStream(os)));\n\n        int ret = proc.join();\n\n        w.write(\"<\/log><result>\"+ret+\"<\/result><duration>\"+(System.currentTimeMillis()-start)+\"<\/duration><\/run>\");\n        w.close();\n\n        if(con.getResponseCode()!=200) {\n            Util.copyStream(con.getErrorStream(),System.err);\n        }\n\n        return ret;\n    }","id":45529,"modified_method":"/**\n     * Run command and place the result to a remote Hudson installation\n     */\n    public static int remotePost(String[] args) throws Exception {\n        String projectName = args[0];\n\n        String home = getHudsonHome();\n        if(!home.endsWith(\"/\"))     home = home + '/';  // make sure it ends with '/'\n\n        {// check if the home is set correctly\n            HttpURLConnection con = (HttpURLConnection)new URL(home).openConnection();\n            con.connect();\n            if(con.getResponseCode()!=200\n            || con.getHeaderField(\"X-Hudson\")==null) {\n                System.err.println(home+\" is not Hudson (\"+con.getResponseMessage()+\")\");\n                return -1;\n            }\n        }\n\n        String projectNameEnc = URLEncoder.encode(projectName,\"UTF-8\").replaceAll(\"\\\\+\",\"%20\");\n\n        {// check if the job name is correct\n            HttpURLConnection con = (HttpURLConnection)new URL(home+\"job/\"+projectNameEnc+\"/acceptBuildResult\").openConnection();\n            con.connect();\n            if(con.getResponseCode()!=200) {\n                System.err.println(projectName+\" is not a valid job name on \"+home+\" (\"+con.getResponseMessage()+\")\");\n                return -1;\n            }\n        }\n\n        // write the output to a temporary file first.\n        File tmpFile = File.createTempFile(\"hudson\",\"log\");\n        tmpFile.deleteOnExit();\n        FileOutputStream os = new FileOutputStream(tmpFile);\n\n        Writer w = new OutputStreamWriter(os,\"UTF-8\");\n        w.write(\"<?xml version='1.0' encoding='UTF-8'?>\");\n        w.write(\"<run><log encoding='hexBinary'>\");\n        w.flush();\n\n        // run the command\n        long start = System.currentTimeMillis();\n\n        List<String> cmd = new ArrayList<String>();\n        for( int i=1; i<args.length; i++ )\n            cmd.add(args[i]);\n        Proc proc = new Proc.LocalProc(cmd.toArray(new String[0]),(String[])null,System.in,\n            new DualOutputStream(System.out,new EncodingStream(os)));\n\n        int ret = proc.join();\n\n        w.write(\"<\/log><result>\"+ret+\"<\/result><duration>\"+(System.currentTimeMillis()-start)+\"<\/duration><\/run>\");\n        w.close();\n\n        String location = home+\"job/\"+projectNameEnc+\"/postBuildResult\";\n        while(true) {\n            try {\n                // start a remote connection\n                HttpURLConnection con = (HttpURLConnection) new URL(location).openConnection();\n                con.setDoOutput(true);\n                // this tells HttpURLConnection not to buffer the whole thing\n                con.setFixedLengthStreamingMode((int)tmpFile.length());\n                con.connect();\n                // send the data\n                FileInputStream in = new FileInputStream(tmpFile);\n                Util.copyStream(in,con.getOutputStream());\n                in.close();\n\n                if(con.getResponseCode()!=200) {\n                    Util.copyStream(con.getErrorStream(),System.err);\n                }\n\n                return ret;\n            } catch (HttpRetryException e) {\n                if(e.getLocation()!=null) {\n                    // retry with the new location\n                    location = e.getLocation();\n                    continue;\n                }\n                // otherwise failed for reasons beyond us.\n                throw e;\n            }\n        }\n    }","commit_id":"0e244a6935704105c7bb8b8352f65406247c3a24","url":"https://github.com/kohsuke/hudson"},{"original_method":"@BeforeClass\n\tpublic static void startJettyServer() throws Exception {\n\t\tjettyServer = new Server(8889);\n\t\tContext jettyContext = new Context(jettyServer, \"/\");\n\t\tjettyContext.addServlet(new ServletHolder(new EchoServlet()), \"/echo\");\n\t\tjettyContext.addServlet(new ServletHolder(new ErrorServlet(404)), \"/errors/notfound\");\n\t\tjettyServer.start();\n\t}","id":45530,"modified_method":"@BeforeClass\n\tpublic static void startJettyServer() throws Exception {\n\t\tjettyServer = new Server(8889);\n\t\tContext jettyContext = new Context(jettyServer, \"/\");\n\t\tjettyContext.addServlet(new ServletHolder(new EchoServlet()), \"/echo\");\n\t\tjettyContext.addServlet(new ServletHolder(new ErrorServlet(404)), \"/errors/notfound\");\n\t\tjettyContext.addServlet(new ServletHolder(new MethodServlet(\"DELETE\")), \"/methods/delete\");\n\t\tjettyContext.addServlet(new ServletHolder(new MethodServlet(\"GET\")), \"/methods/get\");\n\t\tjettyContext.addServlet(new ServletHolder(new MethodServlet(\"HEAD\")), \"/methods/head\");\n\t\tjettyContext.addServlet(new ServletHolder(new MethodServlet(\"OPTIONS\")), \"/methods/options\");\n\t\tjettyContext.addServlet(new ServletHolder(new MethodServlet(\"POST\")), \"/methods/post\");\n\t\tjettyContext.addServlet(new ServletHolder(new MethodServlet(\"PUT\")), \"/methods/put\");\n\t\tjettyServer.start();\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(expected = IllegalStateException.class)\n\tpublic void multipleWrites() throws Exception {\n\t\tClientHttpRequest request = factory.createRequest(new URI(\"http://localhost:8889/echo\"), HttpMethod.POST);\n\t\tbyte[] body = \"Hello World\".getBytes(\"UTF-8\");\n\t\tFileCopyUtils.copy(body, request.getBody());\n\t\trequest.execute();\n\t\tFileCopyUtils.copy(body, request.getBody());\n\t}","id":45531,"modified_method":"@Test(expected = IllegalStateException.class)\n\tpublic void multipleWrites() throws Exception {\n\t\tClientHttpRequest request = factory.createRequest(new URI(\"http://localhost:8889/echo\"), HttpMethod.POST);\n\t\tbyte[] body = \"Hello World\".getBytes(\"UTF-8\");\n\t\tFileCopyUtils.copy(body, request.getBody());\n\t\tClientHttpResponse response = request.execute();\n\t\ttry {\n\t\t\tFileCopyUtils.copy(body, request.getBody());\n\t\t}\n\t\tfinally {\n\t\t\tresponse.close();\n\t\t}\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(expected = IllegalStateException.class)\n\tpublic void headersAfterExecute() throws Exception {\n\t\tClientHttpRequest request = factory.createRequest(new URI(\"http://localhost:8889/echo\"), HttpMethod.POST);\n\t\trequest.getHeaders().add(\"MyHeader\", \"value\");\n\t\tbyte[] body = \"Hello World\".getBytes(\"UTF-8\");\n\t\tFileCopyUtils.copy(body, request.getBody());\n\t\trequest.execute();\n\t\trequest.getHeaders().add(\"MyHeader\", \"value\");\n\t}","id":45532,"modified_method":"@Test(expected = IllegalStateException.class)\n\tpublic void headersAfterExecute() throws Exception {\n\t\tClientHttpRequest request = factory.createRequest(new URI(\"http://localhost:8889/echo\"), HttpMethod.POST);\n\t\trequest.getHeaders().add(\"MyHeader\", \"value\");\n\t\tbyte[] body = \"Hello World\".getBytes(\"UTF-8\");\n\t\tFileCopyUtils.copy(body, request.getBody());\n\t\tClientHttpResponse response = request.execute();\n\t\ttry {\n\t\t\trequest.getHeaders().add(\"MyHeader\", \"value\");\n\t\t}\n\t\tfinally {\n\t\t\tresponse.close();\n\t\t}\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public CommonsClientHttpRequest(HttpClient httpClient, HttpMethodBase httpMethod) {\n\t\tthis.httpClient = httpClient;\n\t\tthis.httpMethod = httpMethod;\n\t}","id":45533,"modified_method":"CommonsClientHttpRequest(HttpClient httpClient, HttpMethodBase httpMethod) {\n\t\tthis.httpClient = httpClient;\n\t\tthis.httpMethod = httpMethod;\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {\n\t\tfor (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n\t\t\tString headerName = entry.getKey();\n\t\t\tfor (String headerValue : entry.getValue()) {\n\t\t\t\tthis.connection.addRequestProperty(headerName, headerValue);\n\t\t\t}\n\t\t}\n\t\tthis.connection.connect();\n\t\tFileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream());\n\t\treturn new SimpleClientHttpResponse(this.connection);\n\t}","id":45534,"modified_method":"@Override\n\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {\n\t\tfor (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n\t\t\tString headerName = entry.getKey();\n\t\t\tfor (String headerValue : entry.getValue()) {\n\t\t\t\tthis.connection.addRequestProperty(headerName, headerValue);\n\t\t\t}\n\t\t}\n\t\tthis.connection.connect();\n\t\tif (bufferedOutput.length > 0) {\n\t\t\tFileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream());\n\t\t}\n\t\treturn new SimpleClientHttpResponse(this.connection);\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public SimpleClientHttpRequest(HttpURLConnection connection) {\n\t\tthis.connection = connection;\n\t}","id":45535,"modified_method":"SimpleClientHttpRequest(HttpURLConnection connection) {\n\t\tthis.connection = connection;\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Template method for preparing the given {@link HttpURLConnection}.\n\t * <p>The default implementation prepares the connection for input and output, and sets the HTTP method.\n\t * @param connection the connection to prepare\n\t * @param httpMethod the HTTP request method ({@code GET}, {@code POST}, etc.)\n\t * @throws IOException in case of I/O errors\n\t */\n\tprotected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\t\tconnection.setDoInput(true);\n\t\tconnection.setDoOutput(true);\n\t\tconnection.setRequestMethod(httpMethod);\n\t}","id":45536,"modified_method":"/**\n\t * Template method for preparing the given {@link HttpURLConnection}.\n\t * <p>The default implementation prepares the connection for input and output, and sets the HTTP method.\n\t * @param connection the connection to prepare\n\t * @param httpMethod the HTTP request method ({@code GET}, {@code POST}, etc.)\n\t * @throws IOException in case of I/O errors\n\t */\n\tprotected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\t\tconnection.setDoInput(true);\n\t\tif (\"PUT\".equals(httpMethod) || \"POST\".equals(httpMethod)) {\n\t\t\tconnection.setDoOutput(true);\n\t\t} else {\n\t\t\tconnection.setDoOutput(false);\n\t\t}\n\t\tconnection.setRequestMethod(httpMethod);\n\t}","commit_id":"b08ad44230269a2a8717c3c8a25a9b5539a55a22","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n   *  We made this one synchronized in the JVM because otherwise, this is not thread safe.\n   *  In that case if (on an application server for example) several HTTP's are running at the same time,\n   *  you get into problems because the System.setProperty() calls are system wide!\n   */\n  public synchronized Result execute(Result previousResult, int nr)\n  {\n    Result result = previousResult;\n    result.setResult(false);\n\n    logBasic(BaseMessages.getString(PKG, \"JobHTTP.StartJobEntry\"));\n\n    // Get previous result rows...\n    List<RowMetaAndData> resultRows;\n    String urlFieldnameToUse;\n\n    if (Const.isEmpty(urlFieldname))\n      urlFieldnameToUse = URL_FIELDNAME;\n    else\n      urlFieldnameToUse = urlFieldname;\n\n    if (runForEveryRow)\n    {\n      resultRows = previousResult.getRows();\n      if (resultRows == null)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.UnableGetResultPrevious\"));\n        return result;\n      }\n    } else\n    {\n      resultRows = new ArrayList<RowMetaAndData>();\n      RowMetaAndData row = new RowMetaAndData();\n      row.addValue(new ValueMeta(urlFieldnameToUse, ValueMetaInterface.TYPE_STRING), environmentSubstitute(url));\n      resultRows.add(row);\n    }\n\n    URL server = null;\n\n    String beforeProxyHost = System.getProperty(\"http.proxyHost\");\n    String beforeProxyPort = System.getProperty(\"http.proxyPort\");\n    String beforeNonProxyHosts = System.getProperty(\"http.nonProxyHosts\");\n\n    for (int i = 0; i < resultRows.size() && result.getNrErrors() == 0; i++)\n    {\n      RowMetaAndData row = (RowMetaAndData) resultRows.get(i);\n\n      OutputStream outputFile = null;\n      OutputStream uploadStream = null;\n      BufferedInputStream fileStream = null;\n      InputStream input = null;\n\n      try\n      {\n        String urlToUse = environmentSubstitute(row.getString(urlFieldnameToUse, \"\"));\n\n        logBasic(BaseMessages.getString(PKG, \"JobHTTP.Log.ConnectingURL\", urlToUse));\n\n        if (!Const.isEmpty(proxyHostname))\n        {\n          System.setProperty(\"http.proxyHost\", environmentSubstitute(proxyHostname));\n          System.setProperty(\"http.proxyPort\", environmentSubstitute(proxyPort));\n          if (nonProxyHosts != null)\n            System.setProperty(\"http.nonProxyHosts\", environmentSubstitute(nonProxyHosts));\n        }\n\n        if (!Const.isEmpty(username))\n        {\n          Authenticator.setDefault(new Authenticator()\n          {\n            protected PasswordAuthentication getPasswordAuthentication()\n            {\n              String realPassword = environmentSubstitute(password);\n              return new PasswordAuthentication(environmentSubstitute(username), realPassword != null ? realPassword\n                  .toCharArray() : new char[]\n              {});\n            }\n          });\n        }\n\n        String realTargetFile = environmentSubstitute(targetFilename);\n        if (dateTimeAdded)\n        {\n          SimpleDateFormat daf = new SimpleDateFormat();\n          Date now = new Date();\n\n          daf.applyPattern(\"yyyMMdd\");\n          realTargetFile += \"_\" + daf.format(now);\n          daf.applyPattern(\"HHmmss\");\n          realTargetFile += \"_\" + daf.format(now);\n\n          if (!Const.isEmpty(targetFilenameExtention))\n          {\n            realTargetFile += \".\" + environmentSubstitute(targetFilenameExtention);\n          }\n        }\n\n        // Create the output File...\n        outputFile = KettleVFS.getOutputStream(realTargetFile, this, fileAppended);\n\n        // Get a stream for the specified URL\n        server = new URL(urlToUse);\n        URLConnection connection = server.openConnection();\n\n        // See if we need to send a file over?\n        String realUploadFilename = environmentSubstitute(uploadFilename);\n        if (!Const.isEmpty(realUploadFilename))\n        {\n          if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JobHTTP.Log.SendingFile\", realUploadFilename));\n\n          connection.setDoOutput(true);\n\n          // Grab an output stream to upload data to web server\n          uploadStream = connection.getOutputStream();\n          fileStream = new BufferedInputStream(new FileInputStream(new File(realUploadFilename)));\r\n          try {\n            int c;\n            while ((c = fileStream.read()) >= 0)\n            {\n              uploadStream.write(c);\n            }\n          } finally {\n            // Close upload and file\r\n            if (uploadStream != null) {\n              uploadStream.close();\n              uploadStream = null;\r\n            }\r\n            if (fileStream != null) {\n              fileStream.close();\n              fileStream = null;\r\n            }\n          }\n          if(log.isDetailed()) logDetailed(BaseMessages.getString(\"JobHTTP.Log.FinishedSendingFile\"));\n        }\n\n        if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JobHTTP.Log.StartReadingReply\"));\n\n        // Read the result from the server...\n        input = server.openStream();\n        Date date = new Date(connection.getLastModified());\n        logBasic(BaseMessages.getString(PKG, \"JobHTTP.Log.ReplayInfo\", connection.getContentType(),date));\n\n        int oneChar;\n        long bytesRead = 0L;\n        while ((oneChar = input.read()) != -1)\n        {\n          outputFile.write(oneChar);\n          bytesRead++;\n        }\n\n        logBasic(BaseMessages.getString(PKG, \"JobHTTP.Log.FinisedWritingReply\", bytesRead, realTargetFile));\n\r\n        if(addfilenameresult) {\n\t        // Add to the result files...\n\t        ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(realTargetFile, this),\n\t            parentJob.getJobname(), toString());\n\t        result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n        }\n\n        result.setResult(true);\n      } catch (MalformedURLException e)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.NotValidURL\", url, e.getMessage()));\n        logError(Const.getStackTracker(e));\n      } catch (IOException e)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.CanNotSaveHTTPResult\",e.getMessage()));\n        logError(Const.getStackTracker(e));\n      } catch (Exception e)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.ErrorGettingFromHTTP\",e.getMessage()));\n        logError(Const.getStackTracker(e));\n      } finally\n      {\n        // Close it all\n        try\n        {\n          if (uploadStream != null)\n            uploadStream.close(); // just to make sure\n          if (fileStream != null)\n            fileStream.close(); // just to make sure\n\n          if (input != null)\n            input.close();\n          if (outputFile != null)\n            outputFile.close();\n        } catch (Exception e)\n        {\n          logError(BaseMessages.getString(PKG, \"JobHTTP.Error.CanNotCloseStream\", e.getMessage()));\n          result.setNrErrors(1);\n        }\n\n        // Set the proxy settings back as they were on the system!\n        System.setProperty(\"http.proxyHost\", Const.NVL(beforeProxyHost, \"\"));\n        System.setProperty(\"http.proxyPort\", Const.NVL(beforeProxyPort, \"\"));\n        System.setProperty(\"http.nonProxyHosts\", Const.NVL(beforeNonProxyHosts, \"\"));\n      }\n\n    }\n\n    return result;\n  }","id":45537,"modified_method":"/**\n   *  We made this one synchronized in the JVM because otherwise, this is not thread safe.\n   *  In that case if (on an application server for example) several HTTP's are running at the same time,\n   *  you get into problems because the System.setProperty() calls are system wide!\n   */\n  public synchronized Result execute(Result previousResult, int nr)\n  {\n    Result result = previousResult;\n    result.setResult(false);\n\n    logBasic(BaseMessages.getString(PKG, \"JobHTTP.StartJobEntry\"));\n\n    // Get previous result rows...\n    List<RowMetaAndData> resultRows;\n    String urlFieldnameToUse;\n\n    if (Const.isEmpty(urlFieldname))\n      urlFieldnameToUse = URL_FIELDNAME;\n    else\n      urlFieldnameToUse = urlFieldname;\n\n    if (runForEveryRow)\n    {\n      resultRows = previousResult.getRows();\n      if (resultRows == null)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.UnableGetResultPrevious\"));\n        return result;\n      }\n    } else\n    {\n      resultRows = new ArrayList<RowMetaAndData>();\n      RowMetaAndData row = new RowMetaAndData();\n      row.addValue(new ValueMeta(urlFieldnameToUse, ValueMetaInterface.TYPE_STRING), environmentSubstitute(url));\n      resultRows.add(row);\n    }\n\n    URL server = null;\n\n    String beforeProxyHost = System.getProperty(\"http.proxyHost\");\n    String beforeProxyPort = System.getProperty(\"http.proxyPort\");\n    String beforeNonProxyHosts = System.getProperty(\"http.nonProxyHosts\");\n\n    for (int i = 0; i < resultRows.size() && result.getNrErrors() == 0; i++)\n    {\n      RowMetaAndData row = (RowMetaAndData) resultRows.get(i);\n\n      OutputStream outputFile = null;\n      OutputStream uploadStream = null;\n      BufferedInputStream fileStream = null;\n      InputStream input = null;\n\n      try\n      {\n        String urlToUse = environmentSubstitute(row.getString(urlFieldnameToUse, \"\"));\n\n        logBasic(BaseMessages.getString(PKG, \"JobHTTP.Log.ConnectingURL\", urlToUse));\n\n        if (!Const.isEmpty(proxyHostname))\n        {\n          System.setProperty(\"http.proxyHost\", environmentSubstitute(proxyHostname));\n          System.setProperty(\"http.proxyPort\", environmentSubstitute(proxyPort));\n          if (nonProxyHosts != null)\n            System.setProperty(\"http.nonProxyHosts\", environmentSubstitute(nonProxyHosts));\n        }\n\n        if (!Const.isEmpty(username))\n        {\n          Authenticator.setDefault(new Authenticator()\n          {\n            protected PasswordAuthentication getPasswordAuthentication()\n            {\n              String realPassword = environmentSubstitute(password);\n              return new PasswordAuthentication(environmentSubstitute(username), realPassword != null ? realPassword\n                  .toCharArray() : new char[]\n              {});\n            }\n          });\n        }\n\n        String realTargetFile = environmentSubstitute(targetFilename);\n        if (dateTimeAdded)\n        {\n          SimpleDateFormat daf = new SimpleDateFormat();\n          Date now = new Date();\n\n          daf.applyPattern(\"yyyMMdd\");\n          realTargetFile += \"_\" + daf.format(now);\n          daf.applyPattern(\"HHmmss\");\n          realTargetFile += \"_\" + daf.format(now);\n\n          if (!Const.isEmpty(targetFilenameExtention))\n          {\n            realTargetFile += \".\" + environmentSubstitute(targetFilenameExtention);\n          }\n        }\n\n        // Create the output File...\n        outputFile = KettleVFS.getOutputStream(realTargetFile, this, fileAppended);\n\n        // Get a stream for the specified URL\n        server = new URL(urlToUse);\n        URLConnection connection = server.openConnection();\r\n        connection.setDoOutput(true);\r\n\n        // See if we need to send a file over?\n        String realUploadFilename = environmentSubstitute(uploadFilename);\n        if (!Const.isEmpty(realUploadFilename))\n        {\n          if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JobHTTP.Log.SendingFile\", realUploadFilename));\n\r\n          // Grab an output stream to upload data to web server\n          uploadStream = connection.getOutputStream();\n          fileStream = new BufferedInputStream(new FileInputStream(new File(realUploadFilename)));\r\n          try {\n            int c;\n            while ((c = fileStream.read()) >= 0)\n            {\n              uploadStream.write(c);\n            }\n          } finally {\n            // Close upload and file\r\n            if (uploadStream != null) {\n              uploadStream.close();\n              uploadStream = null;\r\n            }\r\n            if (fileStream != null) {\n              fileStream.close();\n              fileStream = null;\r\n            }\n          }\n          if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JobHTTP.Log.FinishedSendingFile\"));\n        }\n\n        if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JobHTTP.Log.StartReadingReply\"));\n\n        // Read the result from the server...\n        input = connection.getInputStream();\n        Date date = new Date(connection.getLastModified());\n        logBasic(BaseMessages.getString(PKG, \"JobHTTP.Log.ReplayInfo\", connection.getContentType(),date));\n\n        int oneChar;\n        long bytesRead = 0L;\n        while ((oneChar = input.read()) != -1)\n        {\n          outputFile.write(oneChar);\n          bytesRead++;\n        }\n\n        logBasic(BaseMessages.getString(PKG, \"JobHTTP.Log.FinisedWritingReply\", bytesRead, realTargetFile));\n\r\n        if(addfilenameresult) {\n\t        // Add to the result files...\n\t        ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(realTargetFile, this),\n\t            parentJob.getJobname(), toString());\n\t        result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n        }\n\n        result.setResult(true);\n      } catch (MalformedURLException e)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.NotValidURL\", url, e.getMessage()));\n        logError(Const.getStackTracker(e));\n      } catch (IOException e)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.CanNotSaveHTTPResult\",e.getMessage()));\n        logError(Const.getStackTracker(e));\n      } catch (Exception e)\n      {\n        result.setNrErrors(1);\n        logError(BaseMessages.getString(PKG, \"JobHTTP.Error.ErrorGettingFromHTTP\",e.getMessage()));\n        logError(Const.getStackTracker(e));\n      } finally\n      {\n        // Close it all\n        try\n        {\n          if (uploadStream != null)\n            uploadStream.close(); // just to make sure\n          if (fileStream != null)\n            fileStream.close(); // just to make sure\n\n          if (input != null)\n            input.close();\n          if (outputFile != null)\n            outputFile.close();\n        } catch (Exception e)\n        {\n          logError(BaseMessages.getString(PKG, \"JobHTTP.Error.CanNotCloseStream\", e.getMessage()));\n          result.setNrErrors(1);\n        }\n\n        // Set the proxy settings back as they were on the system!\n        System.setProperty(\"http.proxyHost\", Const.NVL(beforeProxyHost, \"\"));\n        System.setProperty(\"http.proxyPort\", Const.NVL(beforeProxyPort, \"\"));\n        System.setProperty(\"http.nonProxyHosts\", Const.NVL(beforeNonProxyHosts, \"\"));\n      }\n\n    }\n\n    return result;\n  }","commit_id":"e8ffd95c04de3741f638493de99761b1adcdff02","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        jointCompilationOptions.put(\"stubDir\", spec.getGroovyCompileOptions().getStubDir());\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        // The most accurate class loader setup would be the following:\n        // 1. One class loader for compile dependencies that loads everything on spec.getClasspath()\n        // 2. Another class loader for AST transforms that delegates loading of compiler classes to\n        // getClass().getClassLoader(), and delegates everything else to 1.\n        //\n        // However, JavaAwareCompilationUnit doesn't provide a way to set a separate class loader for transforms\n        // like CompilationUnit does. One cannot even set CompilationUnit.transformLoader reflectively because it's\n        // already used in the constructor. Therefore, we pass a single class loader to the Groovy compiler that's\n        // used both for the compile class path and AST transforms. This class loader is a combination of 1. and 2. above.\n\n        // The purpose of groovyCompilerClassLoader is to share Groovy compiler classes\n        // between the compiler and AST transforms. This is required for AST transforms to work correctly.\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(getClass().getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n\n        // As we found out the hard way, the following allowances will lead to problems:\n\n        // compiling code that makes use of GroovyTestCase (more generally, code that makes use of a Groovy class\n        // that depends on a class that's not on the 'groovy' configuration) leads to a NoClassDefFoundError in the compiler\n        // groovyCompilerClassLoader.allowPackage(\"groovy\");\n\n        // compiler finds some global transform descriptors (e.g. Spock) whose corresponding\n        // transform implementation classes it fails to load\n        //groovyCompilerClassLoader.allowResources(\"META-INF/services\");\n\n        // Necessary for Groovy compilation to pick up output of regular and joint Java compilation,\n        // and for joint Java compilation to pick up the output of regular Java compilation.\n        // Assumes that output of regular Java compilation (which is not under this task's control) also goes\n        // into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()\n        // would end up on the compile class path of every compile task for that source set, which may not be desirable.\n        spec.setClasspath(Iterables.concat(spec.getClasspath(), Collections.singleton(spec.getDestinationDir())));\n\n        GroovyClassLoader compilationUnitClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        for (File file : spec.getClasspath()) {\n            compilationUnitClassLoader.addClasspath(file.getPath());\n        }\n\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compilationUnitClassLoader);\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new org.codehaus.groovy.tools.javac.JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n                        spec.getCompileOptions().getCompilerArgs().add(\"-sourcepath\");\n                        spec.getCompileOptions().getCompilerArgs().add(((File) config.getJointCompilationOptions().get(\"stubDir\")).getAbsolutePath());\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            throw new CompilationFailedException(e.getMessage());\n        }\n\n        return new SimpleWorkResult(true);\n    }","id":45538,"modified_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        jointCompilationOptions.put(\"stubDir\", spec.getGroovyCompileOptions().getStubDir());\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        // Necessary for Groovy compilation to pick up output of regular and joint Java compilation,\n        // and for joint Java compilation to pick up the output of regular Java compilation.\n        // Assumes that output of regular Java compilation (which is not under this task's control) also goes\n        // into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()\n        // would end up on the compile class path of every compile task for that source set, which may not be desirable.\n        spec.setClasspath(Iterables.concat(spec.getClasspath(), Collections.singleton(spec.getDestinationDir())));\n\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(null, null);\n        for (File file : spec.getClasspath()) {\n            compileClasspathClassLoader.addClasspath(file.getPath());\n        }\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(getClass().getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n\n        JavaAwareGroovyCompilationUnit unit = new JavaAwareGroovyCompilationUnit(configuration, compileClasspathClassLoader, astTransformClassLoader);\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new org.codehaus.groovy.tools.javac.JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n                        spec.getCompileOptions().getCompilerArgs().add(\"-sourcepath\");\n                        spec.getCompileOptions().getCompilerArgs().add(((File) config.getJointCompilationOptions().get(\"stubDir\")).getAbsolutePath());\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            throw new CompilationFailedException(e.getMessage());\n        }\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"715d40d754c411180187baa184730646de0f7cd2","url":"https://github.com/gradle/gradle"},{"original_method":"private Project loadProject(String projectPath) {\n    final Project project = new Project();\n    // setup JDKs and global libraries\n    final MethodClosure fakeClosure = new MethodClosure(new Object(), \"hashCode\");\n    for (GlobalLibrary library : myGlobalLibraries) {\n      if (library instanceof SdkLibrary) {\n        final SdkLibrary sdk = (SdkLibrary)library;\n        Node additionalData = null;\n        final String additionalXml = sdk.getAdditionalDataXml();\n        if (additionalXml != null) {\n          try {\n            additionalData = new XmlParser(false, false).parseText(additionalXml);\n          }\n          catch (Exception e) {\n            LOG.info(e);\n          }\n        }\n        final Sdk jdk = project.createSdk(/*\"JavaSDK\"*/sdk.getTypeName(), sdk.getName(), sdk.getHomePath(), additionalData);\n        jdk.setClasspath(sdk.getPaths());\n      }\n      else {\n        final Library lib = project.createGlobalLibrary(library.getName(), fakeClosure);\n        lib.setClasspath(library.getPaths());\n      }\n    }\n\n    final File projectFile = new File(projectPath);\n\n    //String root = dirBased ? projectPath : projectFile.getParent();\n\n    final String loadPath = isDirectoryBased(projectFile) ? new File(projectFile, IDEA_PROJECT_DIRNAME).getPath() : projectPath;\n    IdeaProjectLoader.loadFromPath(project, loadPath, myPathVariables, getStartupScript());\n    final String globalEncoding = myGlobalEncoding;\n    if (globalEncoding != null && project.getProjectCharset() == null) {\n      project.setProjectCharset(globalEncoding);\n    }\n    return project;\n  }","id":45539,"modified_method":"private Project loadProject(String projectPath) {\n    final Project project = new Project();\n    // setup JDKs and global libraries\n    final MethodClosure fakeClosure = new MethodClosure(new Object(), \"hashCode\");\n    for (GlobalLibrary library : myGlobalLibraries) {\n      if (library instanceof SdkLibrary) {\n        final SdkLibrary sdk = (SdkLibrary)library;\n        Node additionalData = null;\n        final String additionalXml = sdk.getAdditionalDataXml();\n        if (additionalXml != null) {\n          try {\n            additionalData = new XmlParser(false, false).parseText(additionalXml);\n          }\n          catch (Exception e) {\n            LOG.info(e);\n          }\n        }\n        final Sdk jdk = project.createSdk(/*\"JavaSDK\"*/sdk.getTypeName(), sdk.getName(), sdk.getHomePath(), additionalData);\n        if (jdk != null) {\n          jdk.setClasspath(sdk.getPaths());\n        }\n        else {\n          LOG.info(\"Failed to load SDK \" + sdk.getName() + \", type: \" + sdk.getTypeName());\n        }\n      }\n      else {\n        final Library lib = project.createGlobalLibrary(library.getName(), fakeClosure);\n        if (lib != null) {\n          lib.setClasspath(library.getPaths());\n        }\n        else {\n          LOG.info(\"Failed to load global library \" + lib.getName());\n        }\n      }\n    }\n\n    final File projectFile = new File(projectPath);\n\n    //String root = dirBased ? projectPath : projectFile.getParent();\n\n    final String loadPath = isDirectoryBased(projectFile) ? new File(projectFile, IDEA_PROJECT_DIRNAME).getPath() : projectPath;\n    IdeaProjectLoader.loadFromPath(project, loadPath, myPathVariables, getStartupScript());\n    final String globalEncoding = myGlobalEncoding;\n    if (globalEncoding != null && project.getProjectCharset() == null) {\n      project.setProjectCharset(globalEncoding);\n    }\n    return project;\n  }","commit_id":"0a864b89b1ac28a2817a71881b678597ca264437","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Builds the .jar file for the given module.\n   */\n  public void build(@NotNull File bndFile, @NotNull File moduleOutput, @NotNull File outputFile) throws OsgiBuildException {\n    try {\n      Builder builder = new ReportingBuilder(myReporter);\n      builder.setPedantic(false);\n      builder.setProperties(bndFile);\n      builder.setClasspath(new File[]{moduleOutput});\n\n      // check if the manifest version is missing (IDEADEV-41174)\n      String manifest = builder.getProperty(aQute.bnd.osgi.Constants.MANIFEST);\n      if (manifest != null) {\n        File manifestFile = builder.getFile(manifest);\n        if (manifestFile != null) {\n          try {\n            FileInputStream stream = new FileInputStream(manifestFile);\n            try {\n              Properties p = new Properties();\n              p.load(stream);\n              String value = p.getProperty(Attributes.Name.MANIFEST_VERSION.toString());\n              if (StringUtil.isEmptyOrSpaces(value)) {\n                String message = \"Manifest misses a Manifest-Version entry. This may produce an empty manifest in the resulting bundle.\";\n                myReporter.warning(message, null, manifest);\n              }\n            }\n            finally {\n              stream.close();\n            }\n          }\n          catch (Exception e) {\n            myReporter.warning(\"Can't read manifest: \" + e.getMessage(), e, manifest);\n          }\n        }\n      }\n\n      Jar jar = builder.build();\n      jar.setName(outputFile.getName());\n      jar.write(outputFile);\n      builder.close();\n    }\n    catch (Exception e) {\n      throw new OsgiBuildException(\"Unexpected build error\", e, null);\n    }\n  }","id":45540,"modified_method":"/**\n   * Builds the .jar file for the given module.\n   */\n  public void build(@NotNull File bndFile, @NotNull File classPath, @NotNull File[] srcPath, @NotNull File outputFile) throws OsgiBuildException {\n    try {\n      Builder builder;\n\n      Workspace workspace = Workspace.findWorkspace(bndFile);\n      if (workspace != null) {\n        Project project = new Project(workspace, null, bndFile);\n        builder = new ReportingProjectBuilder(myReporter, project);\n      }\n      else {\n        builder = new ReportingBuilder(myReporter);\n        builder.setProperties(bndFile);\n        builder.setPedantic(false);\n        builder.setClasspath(new File[]{classPath});\n        builder.setSourcepath(srcPath);\n      }\n\n      // check if the manifest version is missing (IDEADEV-41174)\n      String manifest = builder.getProperty(aQute.bnd.osgi.Constants.MANIFEST);\n      if (manifest != null) {\n        File manifestFile = builder.getFile(manifest);\n        if (manifestFile != null) {\n          try {\n            FileInputStream stream = new FileInputStream(manifestFile);\n            try {\n              Properties p = new Properties();\n              p.load(stream);\n              String value = p.getProperty(Attributes.Name.MANIFEST_VERSION.toString());\n              if (StringUtil.isEmptyOrSpaces(value)) {\n                String message = \"Manifest misses a Manifest-Version entry. This may produce an empty manifest in the resulting bundle.\";\n                myReporter.warning(message, null, manifest);\n              }\n            }\n            finally {\n              stream.close();\n            }\n          }\n          catch (Exception e) {\n            myReporter.warning(\"Can't read manifest: \" + e.getMessage(), e, manifest);\n          }\n        }\n      }\n\n      Jar jar = builder.build();\n      jar.setName(outputFile.getName());\n      jar.write(outputFile);\n      builder.close();\n    }\n    catch (Exception e) {\n      throw new OsgiBuildException(\"Unexpected build error\", e, null);\n    }\n  }","commit_id":"a9164dcb138795e620156ebc5a0a5148512235ba","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void prepare() throws OsgiBuildException {\n    String jarFileLocation = myExtension.getJarFileLocation();\n    if (jarFileLocation.isEmpty()) {\n      throw new OsgiBuildException(\"Bundle path is empty - please check OSGi facet settings.\");\n    }\n\n    myOutputJarFile = new File(jarFileLocation);\n    if (!FileUtil.delete(myOutputJarFile)) {\n      throw new OsgiBuildException(\"Can't delete bundle file '\" + myOutputJarFile + \"'.\");\n    }\n    if (!FileUtil.createParentDirs(myOutputJarFile)) {\n      throw new OsgiBuildException(\"Cannot create directory for bundle file '\" + myOutputJarFile + \"'.\");\n    }\n\n    String moduleOutputUrl = JpsJavaExtensionService.getInstance().getOutputUrl(myModule, false);\n    if (moduleOutputUrl == null) {\n      throw new OsgiBuildException(\"Unable to determine the compiler output path for the module.\");\n    }\n    myModuleOutputDir = JpsPathUtil.urlToFile(moduleOutputUrl);\n\n    myOutputDir = BndWrapper.getOutputDir(myModuleOutputDir);\n\n    myBndWrapper = new BndWrapper(this);\n  }","id":45541,"modified_method":"private void prepare() throws OsgiBuildException {\n    String jarFileLocation = myExtension.getJarFileLocation();\n    if (jarFileLocation.isEmpty()) {\n      throw new OsgiBuildException(\"Bundle path is empty - please check OSGi facet settings.\");\n    }\n\n    myOutputJarFile = new File(jarFileLocation);\n    if (!FileUtil.delete(myOutputJarFile)) {\n      throw new OsgiBuildException(\"Can't delete bundle file '\" + myOutputJarFile + \"'.\");\n    }\n    if (!FileUtil.createParentDirs(myOutputJarFile)) {\n      throw new OsgiBuildException(\"Cannot create directory for bundle file '\" + myOutputJarFile + \"'.\");\n    }\n\n    String moduleOutputUrl = JpsJavaExtensionService.getInstance().getOutputUrl(myModule, false);\n    if (moduleOutputUrl == null) {\n      throw new OsgiBuildException(\"Unable to determine the compiler output path for the module.\");\n    }\n\n    mySources = ContainerUtil.map2Array(myModule.getSourceRoots(), File.class, new Function<JpsModuleSourceRoot, File>() {\n      @Override\n      public File fun(JpsModuleSourceRoot root) {\n        return root.getFile();\n      }\n    });\n\n    myModuleOutputDir = JpsPathUtil.urlToFile(moduleOutputUrl);\n    myOutputDir = BndWrapper.getOutputDir(myModuleOutputDir);\n    myBndWrapper = new BndWrapper(this);\n  }","commit_id":"a9164dcb138795e620156ebc5a0a5148512235ba","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void doBuild() throws OsgiBuildException {\n    progress(\"Running Bnd to build the bundle\");\n\n    File bndFile = getBndFile();\n\n    if (!myExtension.isUseBundlorFile()) {\n      mySourceToReport = getSourceFileToReport(bndFile);\n      myBndWrapper.build(bndFile, myModuleOutputDir, myOutputJarFile);\n      mySourceToReport = null;\n    }\n    else {\n      File tempFile = new File(myOutputJarFile.getAbsolutePath() + \".tmp.jar\");\n      mySourceToReport = getSourceFileToReport(bndFile);\n      myBndWrapper.build(bndFile, myModuleOutputDir, tempFile);\n      mySourceToReport = null;\n\n      progress(\"Running Bundlor to calculate the manifest\");\n\n      String bundlorPath = myExtension.getBundlorFileLocation();\n      File bundlorFile = OsgiBuildUtil.findFileInModuleContentRoots(myModule, bundlorPath);\n      if (bundlorFile == null) {\n        throw new OsgiBuildException(\"Bundlor file missing '\" + bundlorPath + \"' - please check OSGi facet settings.\");\n      }\n\n      try {\n        Properties properties = OsgiBuildUtil.getMavenProjectProperties(myContext, myModule);\n        List<String> warnings = new BundlorWrapper().wrapModule(properties, tempFile, myOutputJarFile, bundlorFile);\n        for (String warning : warnings) {\n          warning(warning, null, bundlorFile.getPath());\n        }\n      }\n      finally {\n        if (!FileUtil.delete(tempFile)) {\n          warning(\"Can't delete temporary file '\" + tempFile + \"'\", null, null);\n        }\n      }\n    }\n\n    if (!myExtension.isUseBndFile() && !myExtension.isUseBundlorFile()) {\n      progress(\"Bundling non-OSGi libraries\");\n      bundlifyLibraries();\n    }\n  }","id":45542,"modified_method":"private void doBuild() throws OsgiBuildException {\n    progress(\"Running Bnd to build the bundle\");\n\n    File bndFile = getBndFile();\n\n    if (!myExtension.isUseBundlorFile()) {\n      mySourceToReport = getSourceFileToReport(bndFile);\n      myBndWrapper.build(bndFile, myModuleOutputDir, mySources, myOutputJarFile);\n      mySourceToReport = null;\n    }\n    else {\n      File tempFile = new File(myOutputJarFile.getAbsolutePath() + \".tmp.jar\");\n      mySourceToReport = getSourceFileToReport(bndFile);\n      myBndWrapper.build(bndFile, myModuleOutputDir, mySources, tempFile);\n      mySourceToReport = null;\n\n      progress(\"Running Bundlor to calculate the manifest\");\n\n      String bundlorPath = myExtension.getBundlorFileLocation();\n      File bundlorFile = OsgiBuildUtil.findFileInModuleContentRoots(myModule, bundlorPath);\n      if (bundlorFile == null) {\n        throw new OsgiBuildException(\"Bundlor file missing '\" + bundlorPath + \"' - please check OSGi facet settings.\");\n      }\n\n      try {\n        Properties properties = OsgiBuildUtil.getMavenProjectProperties(myContext, myModule);\n        List<String> warnings = new BundlorWrapper().wrapModule(properties, tempFile, myOutputJarFile, bundlorFile);\n        for (String warning : warnings) {\n          warning(warning, null, bundlorFile.getPath());\n        }\n      }\n      finally {\n        if (!FileUtil.delete(tempFile)) {\n          warning(\"Can't delete temporary file '\" + tempFile + \"'\", null, null);\n        }\n      }\n    }\n\n    if (!myExtension.isUseBndFile() && !myExtension.isUseBundlorFile()) {\n      progress(\"Bundling non-OSGi libraries\");\n      bundlifyLibraries();\n    }\n  }","commit_id":"a9164dcb138795e620156ebc5a0a5148512235ba","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        jointCompilationOptions.put(\"stubDir\", spec.getGroovyCompileOptions().getStubDir());\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        // The most accurate class loader setup would be the following:\n        // 1. One class loader for compile dependencies that loads everything on spec.getClasspath()\n        // 2. Another class loader for AST transforms that delegates loading of compiler classes to\n        // getClass().getClassLoader(), and delegates everything else to 1.\n        //\n        // However, JavaAwareCompilationUnit doesn't provide a way to set a separate class loader for transforms\n        // like CompilationUnit does. One cannot even set CompilationUnit.transformLoader reflectively because it's\n        // already used in the constructor. Therefore, we pass a single class loader to the Groovy compiler that's\n        // used both for the compile class path and AST transforms. This class loader is a combination of 1. and 2. above.\n\n        // The purpose of groovyCompilerClassLoader is to share Groovy compiler classes\n        // between the compiler and AST transforms. This is required for AST transforms to work correctly.\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(getClass().getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n\n        // As we found out the hard way, the following allowances will lead to problems:\n\n        // compiling code that makes use of GroovyTestCase (more generally, code that makes use of a Groovy class\n        // that depends on a class that's not on the 'groovy' configuration) leads to a NoClassDefFoundError in the compiler\n        // groovyCompilerClassLoader.allowPackage(\"groovy\");\n\n        // compiler finds some global transform descriptors (e.g. Spock) whose corresponding\n        // transform implementation classes it fails to load\n        //groovyCompilerClassLoader.allowResources(\"META-INF/services\");\n\n        // Necessary for Groovy compilation to pick up output of regular and joint Java compilation,\n        // and for joint Java compilation to pick up the output of regular Java compilation.\n        // Assumes that output of regular Java compilation (which is not under this task's control) also goes\n        // into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()\n        // would end up on the compile class path of every compile task for that source set, which may not be desirable.\n        spec.setClasspath(Iterables.concat(spec.getClasspath(), Collections.singleton(spec.getDestinationDir())));\n\n        GroovyClassLoader compilationUnitClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        for (File file : spec.getClasspath()) {\n            compilationUnitClassLoader.addClasspath(file.getPath());\n        }\n\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compilationUnitClassLoader);\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new org.codehaus.groovy.tools.javac.JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n                        spec.getCompileOptions().getCompilerArgs().add(\"-sourcepath\");\n                        spec.getCompileOptions().getCompilerArgs().add(((File) config.getJointCompilationOptions().get(\"stubDir\")).getAbsolutePath());\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            throw new CompilationFailedException(e.getMessage());\n        }\n\n        return new SimpleWorkResult(true);\n    }","id":45543,"modified_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        jointCompilationOptions.put(\"stubDir\", spec.getGroovyCompileOptions().getStubDir());\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        // Necessary for Groovy compilation to pick up output of regular and joint Java compilation,\n        // and for joint Java compilation to pick up the output of regular Java compilation.\n        // Assumes that output of regular Java compilation (which is not under this task's control) also goes\n        // into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()\n        // would end up on the compile class path of every compile task for that source set, which may not be desirable.\n        spec.setClasspath(Iterables.concat(spec.getClasspath(), Collections.singleton(spec.getDestinationDir())));\n\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(null, null);\n        for (File file : spec.getClasspath()) {\n            compileClasspathClassLoader.addClasspath(file.getPath());\n        }\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(getClass().getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n\n        JavaAwareGroovyCompilationUnit unit = new JavaAwareGroovyCompilationUnit(configuration, compileClasspathClassLoader, astTransformClassLoader);\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new org.codehaus.groovy.tools.javac.JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n                        spec.getCompileOptions().getCompilerArgs().add(\"-sourcepath\");\n                        spec.getCompileOptions().getCompilerArgs().add(((File) config.getJointCompilationOptions().get(\"stubDir\")).getAbsolutePath());\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            throw new CompilationFailedException(e.getMessage());\n        }\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"a4d1483792d6b8f85e983749e9f17d9385bd325d","url":"https://github.com/gradle/gradle"},{"original_method":"protected void parseAdminObjects(final XMLExtendedStreamReader reader, final Map<String,ModelNode> map, final Map<String,HashMap<String, ModelNode>> configMap)\n            throws XMLStreamException, ParserException, ValidateException {\n\n\n        final ModelNode adminObjectNode = new ModelNode();\n        adminObjectNode.get(OP).set(ADD);\n        int attributeSize = reader.getAttributeCount();\n\n\n        String poolName = null;\n        String jndiName = null;\n        for (int i = 0; i < attributeSize; i++) {\n            CommonAdminObject.Attribute attribute = CommonAdminObject.Attribute.forName(reader\n                    .getAttributeLocalName(i));\n            switch (attribute) {\n                case ENABLED: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, ENABLED.getXmlName());\n                    ENABLED.parseAndSetParameter(value, adminObjectNode, location);\n                    break;\n                }\n                case JNDI_NAME: {\n                    final Location location = reader.getLocation();\n                    jndiName = rawAttributeText(reader, JNDINAME.getXmlName());\n                    JNDINAME.parseAndSetParameter(jndiName, adminObjectNode, location);\n                    break;\n                }\n                case POOL_NAME: {\n                    final Location location = reader.getLocation();\n                    poolName = rawAttributeText(reader, POOL_NAME_NAME);\n                    break;\n                }\n                case USE_JAVA_CONTEXT: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, USE_JAVA_CONTEXT.getXmlName());\n                    USE_JAVA_CONTEXT.parseAndSetParameter(value, adminObjectNode, location);\n                    break;\n                }\n                case CLASS_NAME: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, CLASS_NAME.getXmlName());\n                    CLASS_NAME.parseAndSetParameter(value, adminObjectNode, location);\n                    break;\n                }\n                default:\n                    throw new ParserException(bundle.unexpectedAttribute(attribute.getLocalName(), reader.getLocalName()));\n            }\n        }\n        if (poolName == null || poolName.trim().equals(\"\")) {\n            if (jndiName != null && jndiName.trim().length() != 0) {\n                if (jndiName.contains(\"/\")) {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\"/\") + 1 );\n                } else {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\":\") + 1);\n                }\n            } else {\n               throw new ParserException(bundle.missingValue(JNDINAME.getXmlName()));\n            }\n        }\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (ResourceAdapter.Tag.forName(reader.getLocalName()) == ResourceAdapter.Tag.ADMIN_OBJECT) {\n\n                        map.put(poolName, adminObjectNode);\n                        return;\n                    } else {\n                        if (CommonAdminObject.Tag.forName(reader.getLocalName()) == CommonAdminObject.Tag.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    switch (CommonAdminObject.Tag.forName(reader.getLocalName())) {\n                        case CONFIG_PROPERTY: {\n                            if (! configMap.containsKey(poolName)) {\n                                configMap.put(poolName, new HashMap<String, ModelNode>(0));\n                            }\n                            parseConfigProperties(reader, configMap.get(poolName));\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n    }","id":45544,"modified_method":"protected void parseAdminObjects(final XMLExtendedStreamReader reader, final Map<String,ModelNode> map, final Map<String,HashMap<String, ModelNode>> configMap)\n            throws XMLStreamException, ParserException, ValidateException {\n\n\n        final ModelNode adminObjectNode = new ModelNode();\n        adminObjectNode.get(OP).set(ADD);\n        int attributeSize = reader.getAttributeCount();\n\n\n        String poolName = null;\n        String jndiName = null;\n        for (int i = 0; i < attributeSize; i++) {\n            CommonAdminObject.Attribute attribute = CommonAdminObject.Attribute.forName(reader\n                    .getAttributeLocalName(i));\n            switch (attribute) {\n                case ENABLED: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, ENABLED.getXmlName());\n                    if (value != null) {\n                        ENABLED.parseAndSetParameter(value, adminObjectNode, location);\n                    }\n                    break;\n                }\n                case JNDI_NAME: {\n                    final Location location = reader.getLocation();\n                    jndiName = rawAttributeText(reader, JNDINAME.getXmlName());\n                    if (jndiName != null) {\n                        JNDINAME.parseAndSetParameter(jndiName, adminObjectNode, location);\n                    }\n                    break;\n                }\n                case POOL_NAME: {\n                    final Location location = reader.getLocation();\n                    poolName = rawAttributeText(reader, POOL_NAME_NAME);\n                    break;\n                }\n                case USE_JAVA_CONTEXT: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, USE_JAVA_CONTEXT.getXmlName());\n                    if (value != null) {\n                        USE_JAVA_CONTEXT.parseAndSetParameter(value, adminObjectNode, location);\n                    }\n                    break;\n                }\n                case CLASS_NAME: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, CLASS_NAME.getXmlName());\n                    if (value != null) {\n                        CLASS_NAME.parseAndSetParameter(value, adminObjectNode, location);\n                    }\n                    break;\n                }\n                default:\n                    throw new ParserException(bundle.unexpectedAttribute(attribute.getLocalName(), reader.getLocalName()));\n            }\n        }\n        if (poolName == null || poolName.trim().equals(\"\")) {\n            if (jndiName != null && jndiName.trim().length() != 0) {\n                if (jndiName.contains(\"/\")) {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\"/\") + 1 );\n                } else {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\":\") + 1);\n                }\n            } else {\n               throw new ParserException(bundle.missingValue(JNDINAME.getXmlName()));\n            }\n        }\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (ResourceAdapter.Tag.forName(reader.getLocalName()) == ResourceAdapter.Tag.ADMIN_OBJECT) {\n\n                        map.put(poolName, adminObjectNode);\n                        return;\n                    } else {\n                        if (CommonAdminObject.Tag.forName(reader.getLocalName()) == CommonAdminObject.Tag.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    switch (CommonAdminObject.Tag.forName(reader.getLocalName())) {\n                        case CONFIG_PROPERTY: {\n                            if (! configMap.containsKey(poolName)) {\n                                configMap.put(poolName, new HashMap<String, ModelNode>(0));\n                            }\n                            parseConfigProperties(reader, configMap.get(poolName));\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n    }","commit_id":"b8ea8ddf23e58a94b0b7f3c131eda5a187d53e2a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * parse a single connection-definition tag\n     *\n     * @param reader the reader\n     * @return the parse {@link org.jboss.jca.common.api.metadata.common.CommonConnDef} object\n     * @throws javax.xml.stream.XMLStreamException\n     *          XMLStreamException\n     * @throws org.jboss.jca.common.metadata.ParserException\n     *          ParserException\n     * @throws org.jboss.jca.common.api.validator.ValidateException\n     *          ValidateException\n     */\n    protected void parseConnectionDefinitions(final XMLExtendedStreamReader reader, final Map<String,ModelNode> map, final Map<String,HashMap<String, ModelNode>> configMap)\n            throws XMLStreamException, ParserException, ValidateException {\n\n\n        final ModelNode connectionDefinitionNode = new ModelNode();\n        connectionDefinitionNode.get(OP).set(ADD);\n\n        String poolName = null;\n        String jndiName = null;\n        int attributeSize = reader.getAttributeCount();\n        boolean isXa = Boolean.FALSE;\n        boolean poolDefined = Boolean.FALSE;\n\n        for (int i = 0; i < attributeSize; i++) {\n            CommonConnDef.Attribute attribute = CommonConnDef.Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n\n                case ENABLED: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, ENABLED.getXmlName());\n                    ENABLED.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    break;\n                }\n                case JNDI_NAME: {\n                    final Location location = reader.getLocation();\n                    jndiName = rawAttributeText(reader, JNDINAME.getXmlName());\n                    JNDINAME.parseAndSetParameter(jndiName, connectionDefinitionNode, location);\n                    break;\n                }\n                case POOL_NAME: {\n                    final Location location = reader.getLocation();\n                    poolName = rawAttributeText(reader, POOL_NAME_NAME);\n                    break;\n                }\n                case USE_JAVA_CONTEXT: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, USE_JAVA_CONTEXT.getXmlName());\n                    USE_JAVA_CONTEXT.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    break;\n                }\n\n                case USE_CCM: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, USE_CCM.getXmlName());\n                    USE_CCM.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    break;\n                }\n\n                case CLASS_NAME: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, CLASS_NAME.getXmlName());\n                    CLASS_NAME.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        if (poolName == null || poolName.trim().equals(\"\")) {\n            if (jndiName != null && jndiName.trim().length() != 0) {\n                if (jndiName.contains(\"/\")) {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\"/\") + 1);\n                } else {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\":\") + 1);\n                }\n            } else {\n               throw new ParserException(bundle.missingValue(JNDINAME.getXmlName()));\n            }\n        }\n\n\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (ResourceAdapter.Tag.forName(reader.getLocalName()) == ResourceAdapter.Tag.CONNECTION_DEFINITION) {\n\n                        map.put(poolName, connectionDefinitionNode);\n                        return;\n                    } else {\n                        if (CommonConnDef.Tag.forName(reader.getLocalName()) == CommonConnDef.Tag.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    switch (CommonConnDef.Tag.forName(reader.getLocalName())) {\n                        case CONFIG_PROPERTY: {\n                            if (! configMap.containsKey(poolName)) {\n                                configMap.put(poolName, new HashMap<String, ModelNode>(0));\n                            }\n                            parseConfigProperties(reader, configMap.get(poolName));\n                            break;\n                        }\n                        case SECURITY: {\n                            parseSecuritySettings(reader, connectionDefinitionNode);\n                            break;\n                        }\n                        case TIMEOUT: {\n                            parseTimeOut(reader, isXa, connectionDefinitionNode);\n                            break;\n                        }\n                        case VALIDATION: {\n                            parseValidation(reader, connectionDefinitionNode);\n                            break;\n                        }\n                        case XA_POOL: {\n                            if (poolDefined)\n                                throw new ParserException(bundle.multiplePools());\n                            parseXaPool(reader, connectionDefinitionNode);\n                            isXa = true;\n                            poolDefined = true;\n                            break;\n                        }\n                        case POOL: {\n                            if (poolDefined)\n                                throw new ParserException(bundle.multiplePools());\n                            parsePool(reader, connectionDefinitionNode);\n                            poolDefined = true;\n                            break;\n                        }\n                        case RECOVERY: {\n                            parseRecovery(reader, connectionDefinitionNode);\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n\n    }","id":45545,"modified_method":"/**\n     * parse a single connection-definition tag\n     *\n     * @param reader the reader\n     * @return the parse {@link org.jboss.jca.common.api.metadata.common.CommonConnDef} object\n     * @throws javax.xml.stream.XMLStreamException\n     *          XMLStreamException\n     * @throws org.jboss.jca.common.metadata.ParserException\n     *          ParserException\n     * @throws org.jboss.jca.common.api.validator.ValidateException\n     *          ValidateException\n     */\n    protected void parseConnectionDefinitions(final XMLExtendedStreamReader reader, final Map<String,ModelNode> map, final Map<String,HashMap<String, ModelNode>> configMap)\n            throws XMLStreamException, ParserException, ValidateException {\n\n\n        final ModelNode connectionDefinitionNode = new ModelNode();\n        connectionDefinitionNode.get(OP).set(ADD);\n\n        String poolName = null;\n        String jndiName = null;\n        int attributeSize = reader.getAttributeCount();\n        boolean isXa = Boolean.FALSE;\n        boolean poolDefined = Boolean.FALSE;\n\n        for (int i = 0; i < attributeSize; i++) {\n            CommonConnDef.Attribute attribute = CommonConnDef.Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n\n                case ENABLED: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, ENABLED.getXmlName());\n                    if (value != null) {\n                        ENABLED.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    }\n                    break;\n                }\n                case JNDI_NAME: {\n                    final Location location = reader.getLocation();\n                    jndiName = rawAttributeText(reader, JNDINAME.getXmlName());\n                    if(jndiName != null) {\n                        JNDINAME.parseAndSetParameter(jndiName, connectionDefinitionNode, location);\n                    }\n                    break;\n                }\n                case POOL_NAME: {\n                    final Location location = reader.getLocation();\n                    poolName = rawAttributeText(reader, POOL_NAME_NAME);\n                    break;\n                }\n                case USE_JAVA_CONTEXT: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, USE_JAVA_CONTEXT.getXmlName());\n                    if (value != null) {\n                        USE_JAVA_CONTEXT.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    }\n                    break;\n                }\n\n                case USE_CCM: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, USE_CCM.getXmlName());\n                    if (value != null) {\n                        USE_CCM.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    }\n                    break;\n                }\n\n                case CLASS_NAME: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, CLASS_NAME.getXmlName());\n                    if (value != null) {\n                        CLASS_NAME.parseAndSetParameter(value, connectionDefinitionNode, location);\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        if (poolName == null || poolName.trim().equals(\"\")) {\n            if (jndiName != null && jndiName.trim().length() != 0) {\n                if (jndiName.contains(\"/\")) {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\"/\") + 1);\n                } else {\n                    poolName = jndiName.substring(jndiName.lastIndexOf(\":\") + 1);\n                }\n            } else {\n               throw new ParserException(bundle.missingValue(JNDINAME.getXmlName()));\n            }\n        }\n\n\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (ResourceAdapter.Tag.forName(reader.getLocalName()) == ResourceAdapter.Tag.CONNECTION_DEFINITION) {\n\n                        map.put(poolName, connectionDefinitionNode);\n                        return;\n                    } else {\n                        if (CommonConnDef.Tag.forName(reader.getLocalName()) == CommonConnDef.Tag.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    switch (CommonConnDef.Tag.forName(reader.getLocalName())) {\n                        case CONFIG_PROPERTY: {\n                            if (! configMap.containsKey(poolName)) {\n                                configMap.put(poolName, new HashMap<String, ModelNode>(0));\n                            }\n                            parseConfigProperties(reader, configMap.get(poolName));\n                            break;\n                        }\n                        case SECURITY: {\n                            parseSecuritySettings(reader, connectionDefinitionNode);\n                            break;\n                        }\n                        case TIMEOUT: {\n                            parseTimeOut(reader, isXa, connectionDefinitionNode);\n                            break;\n                        }\n                        case VALIDATION: {\n                            parseValidation(reader, connectionDefinitionNode);\n                            break;\n                        }\n                        case XA_POOL: {\n                            if (poolDefined)\n                                throw new ParserException(bundle.multiplePools());\n                            parseXaPool(reader, connectionDefinitionNode);\n                            isXa = true;\n                            poolDefined = true;\n                            break;\n                        }\n                        case POOL: {\n                            if (poolDefined)\n                                throw new ParserException(bundle.multiplePools());\n                            parsePool(reader, connectionDefinitionNode);\n                            poolDefined = true;\n                            break;\n                        }\n                        case RECOVERY: {\n                            parseRecovery(reader, connectionDefinitionNode);\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n\n    }","commit_id":"b8ea8ddf23e58a94b0b7f3c131eda5a187d53e2a","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseRecovery(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException, ParserException,\n            ValidateException {\n\n\n        for (Recovery.Attribute attribute : Recovery.Attribute.values()) {\n            switch (attribute) {\n                case NO_RECOVERY: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, NO_RECOVERY.getXmlName());\n                    NO_RECOVERY.parseAndSetParameter(value, node, location);\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (XaDataSource.Tag.forName(reader.getLocalName()) == XaDataSource.Tag.RECOVERY) {\n                        return;\n                    } else {\n                        if (Recovery.Tag.forName(reader.getLocalName()) == Recovery.Tag.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    Recovery.Tag tag = Recovery.Tag.forName(reader.getLocalName());\n                    switch (tag) {\n                        case RECOVER_CREDENTIAL: {\n                            parseRecoveryCredential(reader, node);\n                            break;\n                        }\n                        case RECOVER_PLUGIN: {\n                            parseExtension(reader, tag.getLocalName(), node, RECOVERLUGIN_CLASSNAME, RECOVERLUGIN_PROPERTIES);\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n    }","id":45546,"modified_method":"protected void parseRecovery(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException, ParserException,\n            ValidateException {\n\n\n        for (Recovery.Attribute attribute : Recovery.Attribute.values()) {\n            switch (attribute) {\n                case NO_RECOVERY: {\n                    final Location location = reader.getLocation();\n                    String value = rawAttributeText(reader, NO_RECOVERY.getXmlName());\n                    if (value != null) {\n                        NO_RECOVERY.parseAndSetParameter(value, node, location);\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (XaDataSource.Tag.forName(reader.getLocalName()) == XaDataSource.Tag.RECOVERY) {\n                        return;\n                    } else {\n                        if (Recovery.Tag.forName(reader.getLocalName()) == Recovery.Tag.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    Recovery.Tag tag = Recovery.Tag.forName(reader.getLocalName());\n                    switch (tag) {\n                        case RECOVER_CREDENTIAL: {\n                            parseRecoveryCredential(reader, node);\n                            break;\n                        }\n                        case RECOVER_PLUGIN: {\n                            parseExtension(reader, tag.getLocalName(), node, RECOVERLUGIN_CLASSNAME, RECOVERLUGIN_PROPERTIES);\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n    }","commit_id":"b8ea8ddf23e58a94b0b7f3c131eda5a187d53e2a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeAdminObject(XMLExtendedStreamWriter streamWriter, ModelNode adminObject, final String poolName) throws XMLStreamException {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.ADMIN_OBJECT.getLocalName());\n            CLASS_NAME.marshallAsAttribute(adminObject, false, streamWriter);\n            JNDINAME.marshallAsAttribute(adminObject, false, streamWriter);\n            ENABLED.marshallAsAttribute(adminObject, false, streamWriter);\n            USE_JAVA_CONTEXT.marshallAsAttribute(adminObject, false, streamWriter);\n            streamWriter.writeAttribute(\"pool-name\", poolName);\n\n            writeNewConfigProperties(streamWriter, adminObject);\n            streamWriter.writeEndElement();\n\n        }","id":45547,"modified_method":"private void writeAdminObject(XMLExtendedStreamWriter streamWriter, ModelNode adminObject, final String poolName) throws XMLStreamException {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.ADMIN_OBJECT.getLocalName());\n            CLASS_NAME.marshallAsAttribute(adminObject, streamWriter);\n            JNDINAME.marshallAsAttribute(adminObject, streamWriter);\n            ENABLED.marshallAsAttribute(adminObject, streamWriter);\n            USE_JAVA_CONTEXT.marshallAsAttribute(adminObject, streamWriter);\n            streamWriter.writeAttribute(\"pool-name\", poolName);\n\n            writeNewConfigProperties(streamWriter, adminObject);\n            streamWriter.writeEndElement();\n\n        }","commit_id":"b8ea8ddf23e58a94b0b7f3c131eda5a187d53e2a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeRaElement(XMLExtendedStreamWriter streamWriter, ModelNode ra) throws XMLStreamException {\n            streamWriter.writeStartElement(ResourceAdapters.Tag.RESOURCE_ADAPTER.getLocalName());\n\n            ARCHIVE.marshallAsElement(ra, false, streamWriter);\n\n            if (ra.hasDefined(BEANVALIDATIONGROUPS.getName())) {\n                for (ModelNode bvg : ra.get(BEANVALIDATIONGROUPS.getName()).asList()) {\n                    BEANVALIDATIONGROUPS.marshallAsElement(bvg, false, streamWriter);\n                }\n            }\n\n            BOOTSTRAPCONTEXT.marshallAsElement(ra, false, streamWriter);\n            TRANSACTIONSUPPORT.marshallAsElement(ra, false, streamWriter);\n            writeNewConfigProperties(streamWriter, ra);\n            TransactionSupportEnum transactionSupport = ra.hasDefined(TRANSACTIONSUPPORT.getName()) ? TransactionSupportEnum\n                .valueOf(ra.get(TRANSACTIONSUPPORT.getName()).asString()) : null;\n            boolean isXa = false;\n            if (transactionSupport == TransactionSupportEnum.XATransaction) {\n                isXa = true;\n            }\n            if (ra.hasDefined(CONNECTIONDEFINITIONS_NAME)) {\n                streamWriter.writeStartElement(ResourceAdapter.Tag.CONNECTION_DEFINITIONS.getLocalName());\n                for (Property conDef : ra.get(CONNECTIONDEFINITIONS_NAME).asPropertyList()) {\n                    writeConDef(streamWriter, conDef.getValue(), conDef.getName(), isXa);\n                }\n                streamWriter.writeEndElement();\n            }\n\n            if (ra.hasDefined(ADMIN_OBJECTS_NAME)) {\n                streamWriter.writeStartElement(ResourceAdapter.Tag.ADMIN_OBJECTS.getLocalName());\n                for (Property adminObject : ra.get(ADMIN_OBJECTS_NAME).asPropertyList()) {\n                    writeAdminObject(streamWriter, adminObject.getValue(), adminObject.getName());\n                }\n                streamWriter.writeEndElement();\n            }\n            streamWriter.writeEndElement();\n\n        }","id":45548,"modified_method":"private void writeRaElement(XMLExtendedStreamWriter streamWriter, ModelNode ra) throws XMLStreamException {\n            streamWriter.writeStartElement(ResourceAdapters.Tag.RESOURCE_ADAPTER.getLocalName());\n\n            ARCHIVE.marshallAsElement(ra, streamWriter);\n\n            if (ra.hasDefined(BEANVALIDATIONGROUPS.getName())) {\n                for (ModelNode bvg : ra.get(BEANVALIDATIONGROUPS.getName()).asList()) {\n                    BEANVALIDATIONGROUPS.marshallAsElement(bvg, streamWriter);\n                }\n            }\n\n            BOOTSTRAPCONTEXT.marshallAsElement(ra, streamWriter);\n            TRANSACTIONSUPPORT.marshallAsElement(ra, streamWriter);\n            writeNewConfigProperties(streamWriter, ra);\n            TransactionSupportEnum transactionSupport = ra.hasDefined(TRANSACTIONSUPPORT.getName()) ? TransactionSupportEnum\n                .valueOf(ra.get(TRANSACTIONSUPPORT.getName()).asString()) : null;\n            boolean isXa = false;\n            if (transactionSupport == TransactionSupportEnum.XATransaction) {\n                isXa = true;\n            }\n            if (ra.hasDefined(CONNECTIONDEFINITIONS_NAME)) {\n                streamWriter.writeStartElement(ResourceAdapter.Tag.CONNECTION_DEFINITIONS.getLocalName());\n                for (Property conDef : ra.get(CONNECTIONDEFINITIONS_NAME).asPropertyList()) {\n                    writeConDef(streamWriter, conDef.getValue(), conDef.getName(), isXa);\n                }\n                streamWriter.writeEndElement();\n            }\n\n            if (ra.hasDefined(ADMIN_OBJECTS_NAME)) {\n                streamWriter.writeStartElement(ResourceAdapter.Tag.ADMIN_OBJECTS.getLocalName());\n                for (Property adminObject : ra.get(ADMIN_OBJECTS_NAME).asPropertyList()) {\n                    writeAdminObject(streamWriter, adminObject.getValue(), adminObject.getName());\n                }\n                streamWriter.writeEndElement();\n            }\n            streamWriter.writeEndElement();\n\n        }","commit_id":"b8ea8ddf23e58a94b0b7f3c131eda5a187d53e2a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeConDef(XMLExtendedStreamWriter streamWriter, ModelNode conDef, final String poolName, final boolean isXa) throws XMLStreamException {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.CONNECTION_DEFINITION.getLocalName());\n            CLASS_NAME.marshallAsAttribute(conDef, false, streamWriter);\n            JNDINAME.marshallAsAttribute(conDef, false, streamWriter);\n            ENABLED.marshallAsAttribute(conDef, false, streamWriter);\n            USE_JAVA_CONTEXT.marshallAsAttribute(conDef, false, streamWriter);\n            streamWriter.writeAttribute(\"pool-name\", poolName);\n            USE_CCM.marshallAsAttribute(conDef, false, streamWriter);\n\n\n            writeNewConfigProperties(streamWriter, conDef);\n\n            if (conDef.hasDefined(MAX_POOL_SIZE.getName()) || conDef.hasDefined(MIN_POOL_SIZE.getName()) ||\n                conDef.hasDefined(POOL_USE_STRICT_MIN.getName()) || conDef.hasDefined(POOL_PREFILL.getName()) ||\n                conDef.hasDefined(POOL_FLUSH_STRATEGY.getName())) {\n                if (isXa) {\n\n                    streamWriter.writeStartElement(CommonConnDef.Tag.XA_POOL.getLocalName());\n                    MIN_POOL_SIZE.marshallAsElement(conDef, false, streamWriter);\n                    MAX_POOL_SIZE.marshallAsElement(conDef, false, streamWriter);\n                    POOL_PREFILL.marshallAsElement(conDef, false, streamWriter);\n                    POOL_USE_STRICT_MIN.marshallAsElement(conDef, false, streamWriter);\n                    POOL_FLUSH_STRATEGY.marshallAsElement(conDef, false, streamWriter);\n\n                    SAME_RM_OVERRIDE.marshallAsElement(conDef, false, streamWriter);\n                    INTERLEAVING.marshallAsElement(conDef, false, streamWriter);\n                    NOTXSEPARATEPOOL.marshallAsElement(conDef, false, streamWriter);\n                    PAD_XID.marshallAsElement(conDef, false, streamWriter);\n                    WRAP_XA_RESOURCE.marshallAsElement(conDef, false, streamWriter);\n\n                    streamWriter.writeEndElement();\n                } else {\n                    streamWriter.writeStartElement(CommonConnDef.Tag.POOL.getLocalName());\n                    MIN_POOL_SIZE.marshallAsElement(conDef, false, streamWriter);\n                    MAX_POOL_SIZE.marshallAsElement(conDef, false, streamWriter);\n                    POOL_PREFILL.marshallAsElement(conDef, false, streamWriter);\n                    POOL_USE_STRICT_MIN.marshallAsElement(conDef, false, streamWriter);\n                    POOL_FLUSH_STRATEGY.marshallAsElement(conDef, false, streamWriter);\n                    streamWriter.writeEndElement();\n                }\n            }\n\n            if (conDef.hasDefined(APPLICATION.getName()) || conDef.hasDefined(SECURITY_DOMAIN.getName())\n                    || conDef.hasDefined(SECURITY_DOMAIN_AND_APPLICATION.getName())) {\n                streamWriter.writeStartElement(CommonConnDef.Tag.SECURITY.getLocalName());\n                APPLICATION.marshallAsElement(conDef, false, streamWriter);\n                SECURITY_DOMAIN.marshallAsElement(conDef, false, streamWriter);\n                SECURITY_DOMAIN_AND_APPLICATION.marshallAsElement(conDef, false, streamWriter);\n\n                streamWriter.writeEndElement();\n            }\n\n            if (conDef.hasDefined(BLOCKING_TIMEOUT_WAIT_MILLIS.getName()) || conDef.hasDefined(IDLETIMEOUTMINUTES.getName()) || conDef.hasDefined(ALLOCATION_RETRY.getName())\n                    || conDef.hasDefined(ALLOCATION_RETRY_WAIT_MILLIS.getName()) || conDef.hasDefined(XA_RESOURCE_TIMEOUT.getName())) {\n                streamWriter.writeStartElement(CommonConnDef.Tag.TIMEOUT.getLocalName());\n                BLOCKING_TIMEOUT_WAIT_MILLIS.marshallAsElement(conDef, false, streamWriter);\n                IDLETIMEOUTMINUTES.marshallAsElement(conDef, false, streamWriter);\n                ALLOCATION_RETRY.marshallAsElement(conDef, false, streamWriter);\n                ALLOCATION_RETRY_WAIT_MILLIS.marshallAsElement(conDef, false, streamWriter);\n                XA_RESOURCE_TIMEOUT.marshallAsElement(conDef, false, streamWriter);\n                streamWriter.writeEndElement();\n            }\n\n            if (conDef.hasDefined(BACKGROUNDVALIDATION.getName()) || conDef.hasDefined(BACKGROUNDVALIDATIONMILLIS.getName()) || conDef.hasDefined(USE_FAST_FAIL.getName()) ) {\n                streamWriter.writeStartElement(CommonConnDef.Tag.VALIDATION.getLocalName());\n                BACKGROUNDVALIDATION.marshallAsElement(conDef, false, streamWriter);\n                BACKGROUNDVALIDATIONMILLIS.marshallAsElement(conDef, false, streamWriter);\n                USE_FAST_FAIL.marshallAsElement(conDef, false, streamWriter);\n                streamWriter.writeEndElement();\n            }\n\n            if (conDef.hasDefined(RECOVERY_USERNAME.getName()) || conDef.hasDefined(RECOVERY_PASSWORD.getName())\n                    || conDef.hasDefined(RECOVERY_SECURITY_DOMAIN.getName()) || conDef.hasDefined(RECOVERLUGIN_CLASSNAME.getName())\n                    || conDef.hasDefined(RECOVERLUGIN_PROPERTIES.getName()) || conDef.hasDefined(NO_RECOVERY.getName())) {\n\n                streamWriter.writeStartElement(CommonConnDef.Tag.RECOVERY.getLocalName());\n                if (conDef.hasDefined(RECOVERY_USERNAME.getName()) || conDef.hasDefined(RECOVERY_PASSWORD.getName())\n                        || conDef.hasDefined(RECOVERY_SECURITY_DOMAIN.getName())) {\n                    streamWriter.writeStartElement(Recovery.Tag.RECOVER_CREDENTIAL.getLocalName());\n                    RECOVERY_USERNAME.marshallAsElement(conDef, false, streamWriter);\n                    RECOVERY_PASSWORD.marshallAsElement(conDef, false, streamWriter);\n                    RECOVERY_SECURITY_DOMAIN.marshallAsElement(conDef, false, streamWriter);\n                    streamWriter.writeEndElement();\n                }\n                if (conDef.hasDefined(RECOVERLUGIN_CLASSNAME.getName()) || conDef.hasDefined(RECOVERLUGIN_PROPERTIES.getName())) {\n                    streamWriter.writeStartElement(Recovery.Tag.RECOVER_PLUGIN.getLocalName());\n                    RECOVERLUGIN_CLASSNAME.marshallAsAttribute(conDef, false, streamWriter);\n                    if (conDef.hasDefined(RECOVERLUGIN_PROPERTIES.getName())) {\n                        for (Property property : conDef.get(RECOVERLUGIN_PROPERTIES.getName()).asPropertyList()) {\n                            writeProperty(streamWriter, conDef, property.getName(), property\n                                        .getValue().asString(), org.jboss.jca.common.api.metadata.common.Extension.Tag.CONFIG_PROPERTY.getLocalName());\n                        }\n                    }\n                    streamWriter.writeEndElement();\n                }\n                NO_RECOVERY.marshallAsAttribute(conDef, false, streamWriter);\n\n            }\n\n            streamWriter.writeEndElement();\n\n        }","id":45549,"modified_method":"private void writeConDef(XMLExtendedStreamWriter streamWriter, ModelNode conDef, final String poolName, final boolean isXa) throws XMLStreamException {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.CONNECTION_DEFINITION.getLocalName());\n            CLASS_NAME.marshallAsAttribute(conDef, streamWriter);\n            JNDINAME.marshallAsAttribute(conDef, streamWriter);\n            ENABLED.marshallAsAttribute(conDef, streamWriter);\n            USE_JAVA_CONTEXT.marshallAsAttribute(conDef, streamWriter);\n            streamWriter.writeAttribute(\"pool-name\", poolName);\n            USE_CCM.marshallAsAttribute(conDef, streamWriter);\n\n\n            writeNewConfigProperties(streamWriter, conDef);\n\n            if (conDef.hasDefined(MAX_POOL_SIZE.getName()) || conDef.hasDefined(MIN_POOL_SIZE.getName()) ||\n                conDef.hasDefined(POOL_USE_STRICT_MIN.getName()) || conDef.hasDefined(POOL_PREFILL.getName()) ||\n                conDef.hasDefined(POOL_FLUSH_STRATEGY.getName())) {\n                if (isXa) {\n\n                    streamWriter.writeStartElement(CommonConnDef.Tag.XA_POOL.getLocalName());\n                    MIN_POOL_SIZE.marshallAsElement(conDef, streamWriter);\n                    MAX_POOL_SIZE.marshallAsElement(conDef, streamWriter);\n                    POOL_PREFILL.marshallAsElement(conDef, streamWriter);\n                    POOL_USE_STRICT_MIN.marshallAsElement(conDef, streamWriter);\n                    POOL_FLUSH_STRATEGY.marshallAsElement(conDef, streamWriter);\n\n                    SAME_RM_OVERRIDE.marshallAsElement(conDef, streamWriter);\n                    INTERLEAVING.marshallAsElement(conDef, streamWriter);\n                    NOTXSEPARATEPOOL.marshallAsElement(conDef, streamWriter);\n                    PAD_XID.marshallAsElement(conDef, streamWriter);\n                    WRAP_XA_RESOURCE.marshallAsElement(conDef, streamWriter);\n\n                    streamWriter.writeEndElement();\n                } else {\n                    streamWriter.writeStartElement(CommonConnDef.Tag.POOL.getLocalName());\n                    MIN_POOL_SIZE.marshallAsElement(conDef, streamWriter);\n                    MAX_POOL_SIZE.marshallAsElement(conDef, streamWriter);\n                    POOL_PREFILL.marshallAsElement(conDef, streamWriter);\n                    POOL_USE_STRICT_MIN.marshallAsElement(conDef, streamWriter);\n                    POOL_FLUSH_STRATEGY.marshallAsElement(conDef, streamWriter);\n                    streamWriter.writeEndElement();\n                }\n            }\n\n            if (conDef.hasDefined(APPLICATION.getName()) || conDef.hasDefined(SECURITY_DOMAIN.getName())\n                    || conDef.hasDefined(SECURITY_DOMAIN_AND_APPLICATION.getName())) {\n                streamWriter.writeStartElement(CommonConnDef.Tag.SECURITY.getLocalName());\n                APPLICATION.marshallAsElement(conDef, streamWriter);\n                SECURITY_DOMAIN.marshallAsElement(conDef, streamWriter);\n                SECURITY_DOMAIN_AND_APPLICATION.marshallAsElement(conDef, streamWriter);\n\n                streamWriter.writeEndElement();\n            }\n\n            if (conDef.hasDefined(BLOCKING_TIMEOUT_WAIT_MILLIS.getName()) || conDef.hasDefined(IDLETIMEOUTMINUTES.getName()) || conDef.hasDefined(ALLOCATION_RETRY.getName())\n                    || conDef.hasDefined(ALLOCATION_RETRY_WAIT_MILLIS.getName()) || conDef.hasDefined(XA_RESOURCE_TIMEOUT.getName())) {\n                streamWriter.writeStartElement(CommonConnDef.Tag.TIMEOUT.getLocalName());\n                BLOCKING_TIMEOUT_WAIT_MILLIS.marshallAsElement(conDef, streamWriter);\n                IDLETIMEOUTMINUTES.marshallAsElement(conDef, streamWriter);\n                ALLOCATION_RETRY.marshallAsElement(conDef, streamWriter);\n                ALLOCATION_RETRY_WAIT_MILLIS.marshallAsElement(conDef, streamWriter);\n                XA_RESOURCE_TIMEOUT.marshallAsElement(conDef, streamWriter);\n                streamWriter.writeEndElement();\n            }\n\n            if (conDef.hasDefined(BACKGROUNDVALIDATION.getName()) || conDef.hasDefined(BACKGROUNDVALIDATIONMILLIS.getName()) || conDef.hasDefined(USE_FAST_FAIL.getName()) ) {\n                streamWriter.writeStartElement(CommonConnDef.Tag.VALIDATION.getLocalName());\n                BACKGROUNDVALIDATION.marshallAsElement(conDef, streamWriter);\n                BACKGROUNDVALIDATIONMILLIS.marshallAsElement(conDef, streamWriter);\n                USE_FAST_FAIL.marshallAsElement(conDef, streamWriter);\n                streamWriter.writeEndElement();\n            }\n\n            if (conDef.hasDefined(RECOVERY_USERNAME.getName()) || conDef.hasDefined(RECOVERY_PASSWORD.getName())\n                    || conDef.hasDefined(RECOVERY_SECURITY_DOMAIN.getName()) || conDef.hasDefined(RECOVERLUGIN_CLASSNAME.getName())\n                    || conDef.hasDefined(RECOVERLUGIN_PROPERTIES.getName()) || conDef.hasDefined(NO_RECOVERY.getName())) {\n\n                streamWriter.writeStartElement(CommonConnDef.Tag.RECOVERY.getLocalName());\n                if (conDef.hasDefined(RECOVERY_USERNAME.getName()) || conDef.hasDefined(RECOVERY_PASSWORD.getName())\n                        || conDef.hasDefined(RECOVERY_SECURITY_DOMAIN.getName())) {\n                    streamWriter.writeStartElement(Recovery.Tag.RECOVER_CREDENTIAL.getLocalName());\n                    RECOVERY_USERNAME.marshallAsElement(conDef, streamWriter);\n                    RECOVERY_PASSWORD.marshallAsElement(conDef, streamWriter);\n                    RECOVERY_SECURITY_DOMAIN.marshallAsElement(conDef, streamWriter);\n                    streamWriter.writeEndElement();\n                }\n                if (conDef.hasDefined(RECOVERLUGIN_CLASSNAME.getName()) || conDef.hasDefined(RECOVERLUGIN_PROPERTIES.getName())) {\n                    streamWriter.writeStartElement(Recovery.Tag.RECOVER_PLUGIN.getLocalName());\n                    RECOVERLUGIN_CLASSNAME.marshallAsAttribute(conDef, streamWriter);\n                    if (conDef.hasDefined(RECOVERLUGIN_PROPERTIES.getName())) {\n                        for (Property property : conDef.get(RECOVERLUGIN_PROPERTIES.getName()).asPropertyList()) {\n                            writeProperty(streamWriter, conDef, property.getName(), property\n                                        .getValue().asString(), org.jboss.jca.common.api.metadata.common.Extension.Tag.CONFIG_PROPERTY.getLocalName());\n                        }\n                    }\n                    streamWriter.writeEndElement();\n                }\n                NO_RECOVERY.marshallAsAttribute(conDef, streamWriter);\n\n            }\n\n            streamWriter.writeEndElement();\n\n        }","commit_id":"b8ea8ddf23e58a94b0b7f3c131eda5a187d53e2a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        // FIXME check that we actually have data for this resource\n        \n        return m_nodeResourceType.createChildResource(node);\n    }","id":45550,"modified_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        OnmsResource resource = m_nodeResourceType.createChildResource(node);\n        if (resource.getAttributes().size() > 0 || resource.getChildResources().size() > 0) {\n            return resource;\n        } else {\n            return null;\n        }\n    }","commit_id":"989688fef32dd89c3b0d053c313bd68eeea7c451","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        \n        Assert.notNull(ipInterface.getNode(), \"getNode() on ipInterface must not return null\");\n        OnmsResource nodeResource = getResourceForNode(ipInterface.getNode());\n        List<OnmsResource> childResources = nodeResource.getChildResources();\n\n        for (OnmsResource childResource : childResources) {\n            if (!\"responseTime\".equals(childResource.getResourceType().getName())) {\n                continue;\n            }\n            \n            if (ipInterface.getIpAddress().equals(childResource.getName())) {\n                return childResource;\n            }\n        }\n\n        return null;\n    }","id":45551,"modified_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        \n        OnmsNode node = ipInterface.getNode();\n        Assert.notNull(node, \"getNode() on ipInterface must not return null\");\n        \n        OnmsResource nodeResource = getResourceForNode(node);\n        if (nodeResource == null) {\n            return null;\n        }\n        \n        List<OnmsResource> childResources = nodeResource.getChildResources();\n\n        for (OnmsResource childResource : childResources) {\n            if (!\"responseTime\".equals(childResource.getResourceType().getName())) {\n                continue;\n            }\n            \n            if (ipInterface.getIpAddress().equals(childResource.getName())) {\n                return childResource;\n            }\n        }\n\n        return null;\n    }","commit_id":"989688fef32dd89c3b0d053c313bd68eeea7c451","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetResourceForNode() {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceForNode(node);\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","id":45552,"modified_method":"public void testGetResourceForNode() throws Exception {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        \n        expect(m_nodeDao.get(node.getId())).andReturn(node);\n        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(node.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));\n        \n        File responseDir = m_fileAnticipator.tempDir(\"snmp\");\n        File nodeDir = m_fileAnticipator.tempDir(responseDir, node.getId().toString());\n        m_fileAnticipator.tempFile(nodeDir, \"foo\" + RrdUtils.getExtension());\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceForNode(node);\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","commit_id":"989688fef32dd89c3b0d053c313bd68eeea7c451","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetTopLevelResourceNodeExists() {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node);\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getTopLevelResource(\"node\", \"1\");\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","id":45553,"modified_method":"public void testGetTopLevelResourceNodeExists() throws Exception {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node).times(2);\n        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(node.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));\n        \n        File responseDir = m_fileAnticipator.tempDir(\"snmp\");\n        File nodeDir = m_fileAnticipator.tempDir(responseDir, node.getId().toString());\n        m_fileAnticipator.tempFile(nodeDir, \"foo\" + RrdUtils.getExtension());\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getTopLevelResource(\"node\", node.getId().toString());\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","commit_id":"989688fef32dd89c3b0d053c313bd68eeea7c451","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetResourceByIdNewTopLevelOnly() {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node);\n        \n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceById(\"node[1]\");\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"resource should not be null\", resource);\n    }","id":45554,"modified_method":"public void testGetResourceByIdNewTopLevelOnly() throws Exception {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node).times(2);\n        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(node.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));\n        \n        File responseDir = m_fileAnticipator.tempDir(\"snmp\");\n        File nodeDir = m_fileAnticipator.tempDir(responseDir, node.getId().toString());\n        m_fileAnticipator.tempFile(nodeDir, \"foo\" + RrdUtils.getExtension());\n        \n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceById(\"node[1]\");\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"resource should not be null\", resource);\n    }","commit_id":"989688fef32dd89c3b0d053c313bd68eeea7c451","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        \n        OnmsNode node = ipInterface.getNode();\n        Assert.notNull(node, \"getNode() on ipInterface must not return null\");\n        \n        OnmsResource nodeResource = getResourceForNode(node);\n        if (nodeResource == null) {\n            return null;\n        }\n        \n        List<OnmsResource> childResources = nodeResource.getChildResources();\n\n        for (OnmsResource childResource : childResources) {\n            if (!\"responseTime\".equals(childResource.getResourceType().getName())) {\n                continue;\n            }\n            \n            if (ipInterface.getIpAddress().equals(childResource.getName())) {\n                return childResource;\n            }\n        }\n\n        return null;\n    }","id":45555,"modified_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        Assert.notNull(ipInterface.getNode(), \"getNode() on ipInterface must not return null\");\n        \n        return getChildResourceForNode(ipInterface.getNode(), \"responseTime\", ipInterface.getIpAddress());\n    }","commit_id":"047cb344d5542095a64c50d03a92d074589bf611","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        OnmsResource resource = m_nodeResourceType.createChildResource(node);\n//        if (resource.getAttributes().size() > 0 || resource.getChildResources().size() > 0) {\n//            return resource;\n//        } else {\n//            return null;\n//        }\n        return resource;\n    }","id":45556,"modified_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        return m_nodeResourceType.createChildResource(node);\n    }","commit_id":"047cb344d5542095a64c50d03a92d074589bf611","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        \n        Assert.notNull(ipInterface.getNode(), \"getNode() on ipInterface must not return null\");\n        OnmsResource nodeResource = getResourceForNode(ipInterface.getNode());\n        List<OnmsResource> childResources = nodeResource.getChildResources();\n\n        for (OnmsResource childResource : childResources) {\n            if (!\"responseTime\".equals(childResource.getResourceType().getName())) {\n                continue;\n            }\n            \n            if (ipInterface.getIpAddress().equals(childResource.getName())) {\n                return childResource;\n            }\n        }\n\n        return null;\n    }","id":45557,"modified_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        \n        OnmsNode node = ipInterface.getNode();\n        Assert.notNull(node, \"getNode() on ipInterface must not return null\");\n        \n        OnmsResource nodeResource = getResourceForNode(node);\n        if (nodeResource == null) {\n            return null;\n        }\n        \n        List<OnmsResource> childResources = nodeResource.getChildResources();\n\n        for (OnmsResource childResource : childResources) {\n            if (!\"responseTime\".equals(childResource.getResourceType().getName())) {\n                continue;\n            }\n            \n            if (ipInterface.getIpAddress().equals(childResource.getName())) {\n                return childResource;\n            }\n        }\n\n        return null;\n    }","commit_id":"ccf47b3c4d8333042f73768534bcde634af0655e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        // FIXME check that we actually have data for this resource\n        \n        return m_nodeResourceType.createChildResource(node);\n    }","id":45558,"modified_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        OnmsResource resource = m_nodeResourceType.createChildResource(node);\n        if (resource.getAttributes().size() > 0 || resource.getChildResources().size() > 0) {\n            return resource;\n        } else {\n            return null;\n        }\n    }","commit_id":"ccf47b3c4d8333042f73768534bcde634af0655e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetTopLevelResourceNodeExists() {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node);\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getTopLevelResource(\"node\", \"1\");\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","id":45559,"modified_method":"public void testGetTopLevelResourceNodeExists() throws Exception {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node).times(2);\n        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(node.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));\n        \n        File responseDir = m_fileAnticipator.tempDir(\"snmp\");\n        File nodeDir = m_fileAnticipator.tempDir(responseDir, node.getId().toString());\n        m_fileAnticipator.tempFile(nodeDir, \"foo\" + RrdUtils.getExtension());\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getTopLevelResource(\"node\", node.getId().toString());\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","commit_id":"ccf47b3c4d8333042f73768534bcde634af0655e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetResourceForNode() {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceForNode(node);\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","id":45560,"modified_method":"public void testGetResourceForNode() throws Exception {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        \n        expect(m_nodeDao.get(node.getId())).andReturn(node);\n        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(node.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));\n        \n        File responseDir = m_fileAnticipator.tempDir(\"snmp\");\n        File nodeDir = m_fileAnticipator.tempDir(responseDir, node.getId().toString());\n        m_fileAnticipator.tempFile(nodeDir, \"foo\" + RrdUtils.getExtension());\n\n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceForNode(node);\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"Resource should not be null\", resource);\n    }","commit_id":"ccf47b3c4d8333042f73768534bcde634af0655e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetResourceByIdNewTopLevelOnly() {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node);\n        \n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceById(\"node[1]\");\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"resource should not be null\", resource);\n    }","id":45561,"modified_method":"public void testGetResourceByIdNewTopLevelOnly() throws Exception {\n        OnmsNode node = new OnmsNode();\n        node.setId(1);\n        expect(m_nodeDao.get(node.getId())).andReturn(node).times(2);\n        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(node.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));\n        \n        File responseDir = m_fileAnticipator.tempDir(\"snmp\");\n        File nodeDir = m_fileAnticipator.tempDir(responseDir, node.getId().toString());\n        m_fileAnticipator.tempFile(nodeDir, \"foo\" + RrdUtils.getExtension());\n        \n        m_easyMockUtils.replayAll();\n        OnmsResource resource = m_resourceDao.getResourceById(\"node[1]\");\n        m_easyMockUtils.verifyAll();\n        \n        assertNotNull(\"resource should not be null\", resource);\n    }","commit_id":"ccf47b3c4d8333042f73768534bcde634af0655e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        \n        OnmsNode node = ipInterface.getNode();\n        Assert.notNull(node, \"getNode() on ipInterface must not return null\");\n        \n        OnmsResource nodeResource = getResourceForNode(node);\n        if (nodeResource == null) {\n            return null;\n        }\n        \n        List<OnmsResource> childResources = nodeResource.getChildResources();\n\n        for (OnmsResource childResource : childResources) {\n            if (!\"responseTime\".equals(childResource.getResourceType().getName())) {\n                continue;\n            }\n            \n            if (ipInterface.getIpAddress().equals(childResource.getName())) {\n                return childResource;\n            }\n        }\n\n        return null;\n    }","id":45562,"modified_method":"public OnmsResource getResourceForIpInterface(OnmsIpInterface ipInterface) {\n        Assert.notNull(ipInterface, \"ipInterface argument must not be null\");\n        Assert.notNull(ipInterface.getNode(), \"getNode() on ipInterface must not return null\");\n        \n        return getChildResourceForNode(ipInterface.getNode(), \"responseTime\", ipInterface.getIpAddress());\n    }","commit_id":"6a24730db4e1ef241c5ad7ffbc4fb8298132fb92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        OnmsResource resource = m_nodeResourceType.createChildResource(node);\n//        if (resource.getAttributes().size() > 0 || resource.getChildResources().size() > 0) {\n//            return resource;\n//        } else {\n//            return null;\n//        }\n        return resource;\n    }","id":45563,"modified_method":"public OnmsResource getResourceForNode(OnmsNode node) {\n        Assert.notNull(node, \"node argument must not be null\");\n        \n        return m_nodeResourceType.createChildResource(node);\n    }","commit_id":"6a24730db4e1ef241c5ad7ffbc4fb8298132fb92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n  public void insert() throws Exception {\n    dao.insert(new FileSourceDto().setProjectUuid(\"prj\").setFileUuid(\"file\").setData(\"bla bla\")\n      .setDataHash(\"hash2\")\n      .setLineHashes(\"foo\\nbar\")\n      .setCreatedAt(DateUtils.parseDateTime(\"2014-10-31T16:44:02+0100\").getTime())\n      .setUpdatedAt(DateUtils.parseDateTime(\"2014-10-31T16:44:02+0100\").getTime()));\n\n    checkTable(\"insert\", \"file_sources\");\n  }","id":45564,"modified_method":"@Test\n  public void insert() throws Exception {\n    dao.insert(new FileSourceDto().setProjectUuid(\"prj\").setFileUuid(\"file\").setData(\"bla bla\")\n      .setDataHash(\"hash2\")\n      .setLineHashes(\"foo\\nbar\")\n      .setSrcHash(\"hache\")\n      .setCreatedAt(DateUtils.parseDateTime(\"2014-10-31T16:44:02+0100\").getTime())\n      .setUpdatedAt(DateUtils.parseDateTime(\"2014-10-31T16:44:02+0100\").getTime()));\n\n    checkTable(\"insert\", \"file_sources\");\n  }","commit_id":"462a8d985a9c0320e7eb3764a346b92f1ec1b824","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update() throws Exception {\n    dao.update(new FileSourceDto().setId(101L).setProjectUuid(\"prj\").setFileUuid(\"file\")\n      .setData(\"updated data\")\n      .setDataHash(\"hash2\")\n      .setLineHashes(\"foo2\\nbar2\")\n      .setUpdatedAt(DateUtils.parseDateTime(\"2014-10-31T16:44:02+0100\").getTime()));\n\n    checkTable(\"update\", \"file_sources\");\n  }","id":45565,"modified_method":"@Test\n  public void update() throws Exception {\n    dao.update(new FileSourceDto().setId(101L).setProjectUuid(\"prj\").setFileUuid(\"file\")\n      .setData(\"updated data\")\n      .setDataHash(\"hash2\")\n      .setSrcHash(\"123456\")\n      .setLineHashes(\"foo2\\nbar2\")\n      .setUpdatedAt(DateUtils.parseDateTime(\"2014-10-31T16:44:02+0100\").getTime()));\n\n    checkTable(\"update\", \"file_sources\");\n  }","commit_id":"462a8d985a9c0320e7eb3764a346b92f1ec1b824","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void persist(DbSession session, FileSourceMapper mapper, InputPath inputPath, Map<String, FileSourceDto> fileSourceDtoByFileUuid) {\n    DefaultInputFile inputFile = (DefaultInputFile) inputPath;\n    LOG.debug(\"Processing {}\", inputFile.absolutePath());\n    org.sonar.api.resources.File file = (org.sonar.api.resources.File) resourceCache.get(inputFile.key()).resource();\n    String fileUuid = file.getUuid();\n    FileSourceDto previous = fileSourceDtoByFileUuid.get(fileUuid);\n    String newData = getSourceData(inputFile);\n    String newDataHash = newData != null ? DigestUtils.md5Hex(newData) : \"0\";\n    Date now = system2.newDate();\n    if (previous == null) {\n      FileSourceDto newFileSource = new FileSourceDto()\n        .setProjectUuid(projectTree.getRootProject().getUuid())\n        .setFileUuid(fileUuid)\n        .setData(newData)\n        .setDataHash(newDataHash)\n        .setLineHashes(lineHashesAsMd5Hex(inputFile))\n        .setCreatedAt(now.getTime())\n        .setUpdatedAt(now.getTime());\n      mapper.insert(newFileSource);\n      session.commit();\n    } else {\n      if (!newDataHash.equals(previous.getDataHash())) {\n        previous\n          .setData(newData)\n          .setLineHashes(lineHashesAsMd5Hex(inputFile))\n          .setDataHash(newDataHash)\n          .setUpdatedAt(now.getTime());\n        mapper.update(previous);\n        session.commit();\n      }\n    }\n  }","id":45566,"modified_method":"private void persist(DbSession session, FileSourceMapper mapper, InputPath inputPath, Map<String, FileSourceDto> fileSourceDtoByFileUuid) {\n    DefaultInputFile inputFile = (DefaultInputFile) inputPath;\n    LOG.debug(\"Processing {}\", inputFile.absolutePath());\n    org.sonar.api.resources.File file = (org.sonar.api.resources.File) resourceCache.get(inputFile.key()).resource();\n    String fileUuid = file.getUuid();\n    FileSourceDto previous = fileSourceDtoByFileUuid.get(fileUuid);\n    String newData = getSourceData(inputFile);\n    String newDataHash = newData != null ? DigestUtils.md5Hex(newData) : \"0\";\n    Date now = system2.newDate();\n    if (previous == null) {\n      FileSourceDto newFileSource = new FileSourceDto()\n        .setProjectUuid(projectTree.getRootProject().getUuid())\n        .setFileUuid(fileUuid)\n        .setData(newData)\n        .setDataHash(newDataHash)\n        .setSrcHash(inputFile.hash())\n        .setLineHashes(lineHashesAsMd5Hex(inputFile))\n        .setCreatedAt(now.getTime())\n        .setUpdatedAt(now.getTime());\n      mapper.insert(newFileSource);\n      session.commit();\n    } else {\n      if (!newDataHash.equals(previous.getDataHash())) {\n        previous\n          .setData(newData)\n          .setLineHashes(lineHashesAsMd5Hex(inputFile))\n          .setDataHash(newDataHash)\n          .setSrcHash(inputFile.hash())\n          .setUpdatedAt(now.getTime());\n        mapper.update(previous);\n        session.commit();\n      }\n    }\n  }","commit_id":"462a8d985a9c0320e7eb3764a346b92f1ec1b824","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testPersistEmptyFile() throws Exception {\n    setupData(\"file_sources\");\n    when(system2.newDate()).thenReturn(DateUtils.parseDateTime(\"2014-10-29T16:44:02+0100\"));\n\n    String relativePathEmpty = \"src/empty.java\";\n    DefaultInputFile inputFileEmpty = new DefaultInputFile(PROJECT_KEY, relativePathEmpty)\n      .setLines(0)\n      .setLineHashes(new byte[][] {});\n    when(inputPathCache.all()).thenReturn(Arrays.<InputPath>asList(inputFileEmpty));\n\n    mockResourceCache(relativePathEmpty, PROJECT_KEY, \"uuidempty\");\n\n    sourcePersister.persist();\n    checkTables(\"testPersistEmptyFile\", \"file_sources\");\n  }","id":45567,"modified_method":"@Test\n  public void testPersistEmptyFile() throws Exception {\n    setupData(\"file_sources\");\n    when(system2.newDate()).thenReturn(DateUtils.parseDateTime(\"2014-10-29T16:44:02+0100\"));\n\n    String relativePathEmpty = \"src/empty.java\";\n    DefaultInputFile inputFileEmpty = new DefaultInputFile(PROJECT_KEY, relativePathEmpty)\n      .setLines(0)\n      .setHash(\"\")\n      .setLineHashes(new byte[][] {});\n    when(inputPathCache.all()).thenReturn(Arrays.<InputPath>asList(inputFileEmpty));\n\n    mockResourceCache(relativePathEmpty, PROJECT_KEY, \"uuidempty\");\n\n    sourcePersister.persist();\n    checkTables(\"testPersistEmptyFile\", \"file_sources\");\n  }","commit_id":"462a8d985a9c0320e7eb3764a346b92f1ec1b824","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testPersistUpdateChanged() throws Exception {\n    setupData(\"file_sources\");\n    Date now = DateUtils.parseDateTime(\"2014-10-29T16:44:02+0100\");\n    when(system2.newDate()).thenReturn(now);\n\n    String relativePathSame = \"src/changed.java\";\n    java.io.File sameFile = new java.io.File(basedir, relativePathSame);\n    FileUtils.write(sameFile, \"changed\\ncontent\");\n    DefaultInputFile inputFileNew = new DefaultInputFile(PROJECT_KEY, relativePathSame).setLines(2)\n      .setAbsolutePath(sameFile.getAbsolutePath())\n      .setLineHashes(new byte[][] {md5(\"changed\"), md5(\"content\")});\n    when(inputPathCache.all()).thenReturn(Arrays.<InputPath>asList(inputFileNew));\n\n    mockResourceCache(relativePathSame, PROJECT_KEY, \"uuidsame\");\n\n    sourcePersister.persist();\n\n    FileSourceDto fileSourceDto = new FileSourceDao(getMyBatis()).select(\"uuidsame\");\n    assertThat(fileSourceDto.getCreatedAt()).isEqualTo(DateUtils.parseDateTime(\"2014-10-10T16:44:02+0200\").getTime());\n    assertThat(fileSourceDto.getUpdatedAt()).isEqualTo(now.getTime());\n    assertThat(fileSourceDto.getData()).isEqualTo(\n      \",,,,,,,,,,,,,,,changed\\r\\n,,,,,,,,,,,,,,,content\\r\\n\");\n    assertThat(fileSourceDto.getLineHashes()).isEqualTo(md5Hex(\"changed\") + \"\\n\" + md5Hex(\"content\"));\n    assertThat(fileSourceDto.getDataHash()).isEqualTo(\"d1a4dd62422639f665a8d80b37c59f8d\");\n  }","id":45568,"modified_method":"@Test\n  public void testPersistUpdateChanged() throws Exception {\n    setupData(\"file_sources\");\n    Date now = DateUtils.parseDateTime(\"2014-10-29T16:44:02+0100\");\n    when(system2.newDate()).thenReturn(now);\n\n    String relativePathSame = \"src/changed.java\";\n    java.io.File sameFile = new java.io.File(basedir, relativePathSame);\n    FileUtils.write(sameFile, \"changed\\ncontent\");\n    DefaultInputFile inputFileNew = new DefaultInputFile(PROJECT_KEY, relativePathSame).setLines(2)\n      .setAbsolutePath(sameFile.getAbsolutePath())\n      .setHash(\"123456\")\n      .setLineHashes(new byte[][] {md5(\"changed\"), md5(\"content\")});\n    when(inputPathCache.all()).thenReturn(Arrays.<InputPath>asList(inputFileNew));\n\n    mockResourceCache(relativePathSame, PROJECT_KEY, \"uuidsame\");\n\n    sourcePersister.persist();\n\n    FileSourceDto fileSourceDto = new FileSourceDao(getMyBatis()).select(\"uuidsame\");\n    assertThat(fileSourceDto.getCreatedAt()).isEqualTo(DateUtils.parseDateTime(\"2014-10-10T16:44:02+0200\").getTime());\n    assertThat(fileSourceDto.getUpdatedAt()).isEqualTo(now.getTime());\n    assertThat(fileSourceDto.getData()).isEqualTo(\n      \",,,,,,,,,,,,,,,changed\\r\\n,,,,,,,,,,,,,,,content\\r\\n\");\n    assertThat(fileSourceDto.getLineHashes()).isEqualTo(md5Hex(\"changed\") + \"\\n\" + md5Hex(\"content\"));\n    assertThat(fileSourceDto.getDataHash()).isEqualTo(\"d1a4dd62422639f665a8d80b37c59f8d\");\n    assertThat(fileSourceDto.getSrcHash()).isEqualTo(\"123456\");\n  }","commit_id":"462a8d985a9c0320e7eb3764a346b92f1ec1b824","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void parseHeaders()\n\t{\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-mm-dd HH:mm\");\n\t\tDateFormat localDateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);\n\t\tDateFormat longLocalDateFormatter = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);\n\t\t// the router sets the JVM time zone to UTC but saves the original here so we can get it\n\t\tString systemTimeZone = I2PAppContext.getGlobalContext().getProperty(\"i2p.systemTimeZone\");\n\t\tif (systemTimeZone != null) {\n\t\t\tTimeZone tz = TimeZone.getTimeZone(systemTimeZone);\n\t\t\tlocalDateFormatter.setTimeZone(tz);\n\t\t\tlongLocalDateFormatter.setTimeZone(tz);\n\t\t}\n\t\tDateFormat mailDateFormatter = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH );\n\t\t\n\t\terror = \"\";\n\t\tif( header != null ) {\n\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tEncoding html = EncodingFactory.getEncoding( \"HTML\" );\n\t\t\t\n\t\t\tif( html == null ) {\n\t\t\t\terror += \"HTML encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\t\n\t\t\tEncoding hl = EncodingFactory.getEncoding( \"HEADERLINE\" );\n\n\t\t\tif( hl == null ) {\n\t\t\t\terror += \"Header line encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif( ok ) {\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tReadBuffer decoded = hl.decode( header );\n\t\t\t\t\tBufferedReader reader = new BufferedReader( new InputStreamReader( new ByteArrayInputStream( decoded.content, decoded.offset, decoded.length ), \"UTF-8\" ) );\n\t\t\t\t\tString line;\n\t\t\t\t\twhile( ( line = reader.readLine() ) != null ) {\n\t\t\t\t\t\tif( line.length() == 0 )\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tif( line.startsWith( \"From:\" ) ) {\n\t\t\t\t\t\t\tsender = line.substring( 5 ).trim();\n\t\t\t\t\t\t\tformattedSender = getAddress( sender );\n\t\t\t\t\t\t\tshortSender = formattedSender.trim();\n\t\t\t\t\t\t\tif( shortSender.length() > 40 ) {\n\t\t\t\t\t\t\t\tshortSender = shortSender.substring( 0, 37 ).trim() + \"&hellip;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshortSender = html.encode( shortSender );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Date:\" ) ) {\n\t\t\t\t\t\t\tdateString = line.substring( 5 ).trim();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdate = mailDateFormatter.parse( dateString );\n\t\t\t\t\t\t\t\tformattedDate = dateFormatter.format( date );\n\t\t\t\t\t\t\t\tlocalFormattedDate = localDateFormatter.format( date );\n\t\t\t\t\t\t\t\t//quotedDate = html.encode( dateString );\n\t\t\t\t\t\t\t\tquotedDate = longLocalDateFormatter.format(date);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (ParseException e) {\n\t\t\t\t\t\t\t\tdate = null;\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Subject:\" ) ) {\n\t\t\t\t\t\t\tsubject = line.substring( 8 ).trim();\n\t\t\t\t\t\t\tformattedSubject = subject;\n\t\t\t\t\t\t\tshortSubject = formattedSubject;\n\t\t\t\t\t\t\tif( formattedSubject.length() > 60 )\n\t\t\t\t\t\t\t\tshortSubject = formattedSubject.substring( 0, 57 ).trim() + \"&hellip;\";\n\t\t\t\t\t\t\tshortSubject = html.encode( shortSubject );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.toLowerCase(Locale.US).startsWith( \"reply-to:\" ) ) {\n\t\t\t\t\t\t\treply = getAddress( line.substring( 9 ).trim() );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"To:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tgetRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tto = list.toArray();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Cc:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tgetRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tcc = list.toArray();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch( Exception e ) {\n\t\t\t\t\terror += \"Error parsing mail header: \" + e.getClass().getName() + \"<br>\";\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t}","id":45569,"modified_method":"public void parseHeaders()\n\t{\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-mm-dd HH:mm\");\n\t\tDateFormat localDateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);\n\t\tDateFormat longLocalDateFormatter = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);\n\t\t// the router sets the JVM time zone to UTC but saves the original here so we can get it\n\t\tString systemTimeZone = I2PAppContext.getGlobalContext().getProperty(\"i2p.systemTimeZone\");\n\t\tif (systemTimeZone != null) {\n\t\t\tTimeZone tz = TimeZone.getTimeZone(systemTimeZone);\n\t\t\tlocalDateFormatter.setTimeZone(tz);\n\t\t\tlongLocalDateFormatter.setTimeZone(tz);\n\t\t}\n\t\tDateFormat mailDateFormatter = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH );\n\t\t\n\t\terror = \"\";\n\t\tif( header != null ) {\n\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tEncoding html = EncodingFactory.getEncoding( \"HTML\" );\n\t\t\t\n\t\t\tif( html == null ) {\n\t\t\t\terror += \"HTML encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\t\n\t\t\tEncoding hl = EncodingFactory.getEncoding( \"HEADERLINE\" );\n\n\t\t\tif( hl == null ) {\n\t\t\t\terror += \"Header line encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif( ok ) {\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tReadBuffer decoded = hl.decode( header );\n\t\t\t\t\tBufferedReader reader = new BufferedReader( new InputStreamReader( new ByteArrayInputStream( decoded.content, decoded.offset, decoded.length ), \"UTF-8\" ) );\n\t\t\t\t\tString line;\n\t\t\t\t\twhile( ( line = reader.readLine() ) != null ) {\n\t\t\t\t\t\tif( line.length() == 0 )\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tif( line.startsWith( \"From:\" ) ) {\n\t\t\t\t\t\t\tsender = line.substring( 5 ).trim();\n\t\t\t\t\t\t\tformattedSender = getAddress( sender );\n\t\t\t\t\t\t\tshortSender = formattedSender.trim();\n\t\t\t\t\t\t\tif( shortSender.length() > 40 ) {\n\t\t\t\t\t\t\t\tshortSender = shortSender.substring( 0, 37 ).trim() + \"&hellip;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshortSender = html.encode( shortSender );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Date:\" ) ) {\n\t\t\t\t\t\t\tdateString = line.substring( 5 ).trim();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdate = mailDateFormatter.parse( dateString );\n\t\t\t\t\t\t\t\tformattedDate = dateFormatter.format( date );\n\t\t\t\t\t\t\t\tlocalFormattedDate = localDateFormatter.format( date );\n\t\t\t\t\t\t\t\t//quotedDate = html.encode( dateString );\n\t\t\t\t\t\t\t\tquotedDate = longLocalDateFormatter.format(date);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (ParseException e) {\n\t\t\t\t\t\t\t\tdate = null;\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Subject:\" ) ) {\n\t\t\t\t\t\t\tsubject = line.substring( 8 ).trim();\n\t\t\t\t\t\t\tformattedSubject = subject;\n\t\t\t\t\t\t\tshortSubject = formattedSubject;\n\t\t\t\t\t\t\tif( formattedSubject.length() > 60 )\n\t\t\t\t\t\t\t\tshortSubject = formattedSubject.substring( 0, 57 ).trim() + \"&hellip;\";\n\t\t\t\t\t\t\tshortSubject = html.encode( shortSubject );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.toLowerCase(Locale.US).startsWith( \"reply-to:\" ) ) {\n\t\t\t\t\t\t\treply = getAddress( line.substring( 9 ).trim() );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"To:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tgetRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tto = list.toArray(new String[list.size()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Cc:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tgetRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tcc = list.toArray(new String[list.size()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch( Exception e ) {\n\t\t\t\t\terror += \"Error parsing mail header: \" + e.getClass().getName() + \"<br>\";\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Fetch any needed data from pop3 server.\n\t * \n\t * @param uidl message id to get\n\t * @param headerOnly fetch only header lines?\n\t * @return An e-mail or null\n\t */\n\tpublic Mail getMail( String uidl, boolean headerOnly ) {\n\t\t\n\t\tMail mail = null, newMail = null;\n\n\t\tif( mailbox != null ) {\n\t\t\t/*\n\t\t\t * synchronize update to hashtable\n\t\t\t */\n\t\t\tsynchronized(mails) {\n\t\t\t\tmail = mails.get( uidl );\n\t\t\t\tif( mail == null ) {\n\t\t\t\t\tnewMail = new Mail();\n\t\t\t\t\tmails.put( uidl, newMail );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( mail == null ) {\n\t\t\t\tmail = newMail;\n\t\t\t\tmail.uidl = uidl;\n\t\t\t\tmail.size = mailbox.getSize( uidl );\n\t\t\t}\n\t\t\tif( mail.size < 1024 )\n\t\t\t\theaderOnly = false;\n\t\t\t\n\t\t\tboolean parseHeaders = mail.header == null;\n\t\t\t\n\t\t\tif( headerOnly ) {\n\t\t\t\tif( mail.header == null )\n\t\t\t\t\tmail.header = mailbox.getHeader( uidl );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif( mail.body == null ) {\n\t\t\t\t\tmail.body = mailbox.getBody( uidl );\n\t\t\t\t\tif( mail.body != null ) {\n\t\t\t\t\t\tmail.header = mail.body;\n\t\t\t\t\t\tMailPart.parse( mail );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( parseHeaders && mail.header != null )\n\t\t\t\tmail.parseHeaders();\n\t\t}\n\t\tif( mail != null && mail.deleted )\n\t\t\tmail = null;\n\t\treturn mail;\n\t}","id":45570,"modified_method":"/**\n\t * Fetch any needed data from pop3 server.\n\t * \n\t * @param uidl message id to get\n\t * @param headerOnly fetch only header lines?\n\t * @return An e-mail or null\n\t */\n\tpublic Mail getMail( String uidl, boolean headerOnly ) {\n\t\t\n\t\tMail mail = null, newMail = null;\n\n\t\tif( mailbox != null ) {\n\t\t\t/*\n\t\t\t * synchronize update to hashtable\n\t\t\t */\n\t\t\tsynchronized(mails) {\n\t\t\t\tmail = mails.get( uidl );\n\t\t\t\tif( mail == null ) {\n\t\t\t\t\tnewMail = new Mail();\n\t\t\t\t\tmails.put( uidl, newMail );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( mail == null ) {\n\t\t\t\tmail = newMail;\n\t\t\t\tmail.uidl = uidl;\n\t\t\t\tmail.size = mailbox.getSize( uidl );\n\t\t\t}\n\t\t\tif( mail.size <= FETCH_ALL_SIZE)\n\t\t\t\theaderOnly = false;\n\t\t\t\n\t\t\tboolean parseHeaders = mail.header == null;\n\t\t\t\n\t\t\tif( headerOnly ) {\n\t\t\t\tif( mail.header == null )\n\t\t\t\t\tmail.header = mailbox.getHeader( uidl );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif( mail.body == null ) {\n\t\t\t\t\tmail.body = mailbox.getBody( uidl );\n\t\t\t\t\tif( mail.body != null ) {\n\t\t\t\t\t\tmail.header = mail.body;\n\t\t\t\t\t\tMailPart.parse( mail );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( parseHeaders && mail.header != null )\n\t\t\t\tmail.parseHeaders();\n\t\t}\n\t\tif( mail != null && mail.deleted )\n\t\t\tmail = null;\n\t\treturn mail;\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public boolean sendMail( String host, int port, String user, String pass, String sender, Object[] recipients, String body )\r\n\t{\r\n\t\tboolean mailSent = false;\r\n\t\tboolean ok = true;\r\n\t\t\r\n\t\ttry {\r\n\t\t\tsocket = new Socket( host, port );\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t\terror += \"Cannot connect: \" + e.getMessage() + \"<br>\";\r\n\t\t\tok = false;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tif( ok && sendCmd( null ) == 220 &&\r\n\t\t\t\t\tsendCmd( \"EHLO localhost\" ) == 250 &&\r\n\t\t\t\t\tsendCmd( \"AUTH LOGIN\" ) == 334 &&\r\n\t\t\t\t\tsendCmd( base64.encode( user ) ) == 334 &&\r\n\t\t\t\t\tsendCmd( base64.encode( pass ) ) == 235 &&\r\n\t\t\t\t\tsendCmd( \"MAIL FROM: \" + sender ) == 250 ) {\r\n\t\t\t\t\r\n\t\t\t\tfor( int i = 0; i < recipients.length; i++ ) {\r\n\t\t\t\t\tif( sendCmd( \"RCPT TO: \" + recipients[i] ) != 250 ) {\r\n\t\t\t\t\t\tok = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( ok ) {\r\n\t\t\t\t\tif( sendCmd( \"DATA\" ) == 354 ) {\r\n\t\t\t\t\t\tif( body.indexOf( \"\\r\\n.\\r\\n\" ) != -1 )\r\n\t\t\t\t\t\t\tbody = body.replaceAll( \"\\r\\n.\\r\\n\", \"\\r\\n..\\r\\n\" );\r\n\t\t\t\t\t\tbody += \"\\r\\n.\\r\\n\";\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tsocket.getOutputStream().write( body.getBytes() );\r\n\t\t\t\t\t\t\tif( sendCmd( null ) == 250 ) {\r\n\t\t\t\t\t\t\t\tmailSent = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch (Exception e) {\r\n\t\t\t\t\t\t\tok = false;\r\n\t\t\t\t\t\t\terror += \"Error while sending mail: \" + e.getMessage() + \"<br>\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (EncodingException e) {\r\n\t\t\tok = false;\r\n\t\t\terror += e.getMessage();\r\n\t\t}\r\n\t\tif( !mailSent && lastResponse.length() > 0 ) {\r\n\t\t\tString[] lines = lastResponse.split( \"\\r\\n\" );\r\n\t\t\tfor( int i = 0; i < lines.length; i++ )\r\n\t\t\t\terror += lines[i] + \"<br>\";\t\t\t\r\n\t\t}\r\n\t\tsendCmd( \"QUIT\" );\r\n\t\tif( socket != null ) {\r\n\t\t\ttry {\r\n\t\t\t\tsocket.close();\r\n\t\t\t}\r\n\t\t\tcatch (IOException e1) {\r\n\t\t\t\t// ignore\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn mailSent;\r\n\t}","id":45571,"modified_method":"/**\r\n\t *  @return success\r\n\t */\r\n\tpublic boolean sendMail( String host, int port, String user, String pass, String sender, Object[] recipients, String body )\r\n\t{\r\n\t\tboolean mailSent = false;\r\n\t\tboolean ok = true;\r\n\t\t\r\n\t\ttry {\r\n\t\t\tsocket = new Socket( host, port );\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t\terror += \"Cannot connect: \" + e.getMessage() + \"<br>\";\r\n\t\t\tok = false;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tif( ok && sendCmd( null ) == 220 &&\r\n\t\t\t\t\tsendCmd( \"EHLO localhost\" ) == 250 &&\r\n\t\t\t\t\tsendCmd( \"AUTH LOGIN\" ) == 334 &&\r\n\t\t\t\t\tsendCmd( base64.encode( user ) ) == 334 &&\r\n\t\t\t\t\tsendCmd( base64.encode( pass ) ) == 235 &&\r\n\t\t\t\t\tsendCmd( \"MAIL FROM: \" + sender ) == 250 ) {\r\n\t\t\t\t\r\n\t\t\t\tfor( int i = 0; i < recipients.length; i++ ) {\r\n\t\t\t\t\tif( sendCmd( \"RCPT TO: \" + recipients[i] ) != 250 ) {\r\n\t\t\t\t\t\tok = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( ok ) {\r\n\t\t\t\t\tif( sendCmd( \"DATA\" ) == 354 ) {\r\n\t\t\t\t\t\tif( body.indexOf( \"\\r\\n.\\r\\n\" ) != -1 )\r\n\t\t\t\t\t\t\tbody = body.replaceAll( \"\\r\\n.\\r\\n\", \"\\r\\n..\\r\\n\" );\r\n\t\t\t\t\t\tbody += \"\\r\\n.\\r\\n\";\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tsocket.getOutputStream().write( body.getBytes() );\r\n\t\t\t\t\t\t\tif( sendCmd( null ) == 250 ) {\r\n\t\t\t\t\t\t\t\tmailSent = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch (Exception e) {\r\n\t\t\t\t\t\t\tok = false;\r\n\t\t\t\t\t\t\terror += \"Error while sending mail: \" + e.getMessage() + \"<br>\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (EncodingException e) {\r\n\t\t\tok = false;\r\n\t\t\terror += e.getMessage();\r\n\t\t}\r\n\t\tif( !mailSent && lastResponse.length() > 0 ) {\r\n\t\t\tString[] lines = lastResponse.split( \"\\r\\n\" );\r\n\t\t\tfor( int i = 0; i < lines.length; i++ )\r\n\t\t\t\terror += lines[i] + \"<br>\";\t\t\t\r\n\t\t}\r\n\t\tsendCmd( \"QUIT\" );\r\n\t\tif( socket != null ) {\r\n\t\t\ttry {\r\n\t\t\t\tsocket.close();\r\n\t\t\t}\r\n\t\t\tcatch (IOException e1) {\r\n\t\t\t\t// ignore\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn mailSent;\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int sendCmd( String cmd )\r\n\t{\r\n\t\tDebug.debug( Debug.DEBUG, \"sendCmd(\" + cmd +\")\" );\r\n\t\t\r\n\t\tif( socket == null )\r\n\t\t\treturn 0;\r\n\r\n\t\tint result = 0;\r\n\t\tlastResponse = \"\";\r\n\t\t\r\n\t\ttry {\r\n\t\t\tInputStream in = socket.getInputStream();\r\n\t\t\tOutputStream out = socket.getOutputStream();\r\n\t\t\r\n\t\t\tif( cmd != null ) {\r\n\t\t\t\tcmd += \"\\r\\n\";\r\n\t\t\t\tout.write( cmd.getBytes() );\r\n\t\t\t}\r\n\t\t\tString str = \"\";\r\n\t\t\tboolean doContinue = true;\r\n\t\t\twhile( doContinue ) {\r\n\t\t\t\tif( in.available() > 0 ) {\r\n\t\t\t\t\tint read = in.read( buffer );\r\n\t\t\t\t\tstr += new String( buffer, 0, read );\r\n\t\t\t\t\tlastResponse += str;\r\n\t\t\t\t\twhile( true ) {\r\n\t\t\t\t\t\tint i = str.indexOf( \"\\r\\n\" );\r\n\t\t\t\t\t\tif( i == -1 )\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tif( result == 0 ) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tresult = Integer.parseInt( str.substring( 0, 3 ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\t\t\t\t\tresult = 0;\r\n\t\t\t\t\t\t\t\tdoContinue = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( str.substring( 3, 4 ).compareTo( \" \" ) == 0 ) {\r\n\t\t\t\t\t\t\tdoContinue = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstr = str.substring( i + 2 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (IOException e) {\r\n\t\t\terror += \"IOException occured.<br>\";\r\n\t\t\tresult = 0;\r\n\t\t}\r\n\t\treturn result;\r\n\t}","id":45572,"modified_method":"/**\r\n\t *  @param cmd may be null\r\n\t *  @return result code or 0 for failure\r\n\t */\r\n\tprivate int sendCmd( String cmd )\r\n\t{\r\n\t\tDebug.debug( Debug.DEBUG, \"SMTP sendCmd(\" + cmd +\")\" );\r\n\t\t\r\n\t\tif( socket == null )\r\n\t\t\treturn 0;\r\n\r\n\t\tint result = 0;\r\n\t\tlastResponse = \"\";\r\n\t\t\r\n\t\ttry {\r\n\t\t\tInputStream in = socket.getInputStream();\r\n\t\t\tOutputStream out = socket.getOutputStream();\r\n\t\t\r\n\t\t\tif( cmd != null ) {\r\n\t\t\t\tcmd += \"\\r\\n\";\r\n\t\t\t\tout.write( cmd.getBytes() );\r\n\t\t\t}\r\n\t\t\tString str = \"\";\r\n\t\t\tboolean doContinue = true;\r\n\t\t\twhile( doContinue ) {\r\n\t\t\t\tif( in.available() > 0 ) {\r\n\t\t\t\t\tint read = in.read( buffer );\r\n\t\t\t\t\tstr += new String( buffer, 0, read );\r\n\t\t\t\t\tlastResponse += str;\r\n\t\t\t\t\twhile( true ) {\r\n\t\t\t\t\t\tint i = str.indexOf( \"\\r\\n\" );\r\n\t\t\t\t\t\tif( i == -1 )\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tif( result == 0 ) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tresult = Integer.parseInt( str.substring( 0, 3 ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\t\t\t\t\tresult = 0;\r\n\t\t\t\t\t\t\t\tdoContinue = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( str.substring( 3, 4 ).compareTo( \" \" ) == 0 ) {\r\n\t\t\t\t\t\t\tdoContinue = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstr = str.substring( i + 2 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (IOException e) {\r\n\t\t\terror += \"IOException occured.<br>\";\r\n\t\t\tresult = 0;\r\n\t\t}\r\n\t\treturn result;\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * process buttons of folder view\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processFolderButtons(SessionObject sessionObject, RequestWrapper request)\r\n\t{\r\n\t\t/*\r\n\t\t * process paging buttons\r\n\t\t */\r\n\t\tString str = request.getParameter( PAGESIZE );\r\n\t\tif( str != null && str.length() > 0 ) {\r\n\t\t\ttry {\r\n\t\t\t\tint pageSize = Integer.parseInt( str );\r\n\t\t\t\tint oldPageSize = sessionObject.folder.getPageSize();\r\n\t\t\t\tif( pageSize != oldPageSize )\r\n\t\t\t\t\tsessionObject.folder.setPageSize( pageSize );\r\n\t\t\t}\r\n\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\tsessionObject.error += _(\"Invalid pagesize number, resetting to default value.\") + \"<br>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( buttonPressed( request, PREVPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.previousPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, NEXTPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.nextPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, FIRSTPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.firstPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, LASTPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.lastPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, DELETE ) ) {\r\n\t\t\tint m = getCheckedMessage( request );\r\n\t\t\tif( m != -1 )\r\n\t\t\t\tsessionObject.reallyDelete = true;\r\n\t\t\telse\r\n\t\t\t\tsessionObject.error += _(\"No messages marked for deletion.\") + \"<br>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint numberDeleted = 0;\r\n\t\t\tif( buttonPressed( request, REALLYDELETE ) ) {\r\n\t\t\t\tfor( Enumeration<String> e = request.getParameterNames(); e.hasMoreElements(); ) {\r\n\t\t\t\t\tString parameter = e.nextElement();\r\n\t\t\t\t\tif( parameter.startsWith( \"check\" ) && request.getParameter( parameter ).compareTo( \"1\" ) == 0 ) {\r\n\t\t\t\t\t\tString number = parameter.substring( 5 );\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tint n = Integer.parseInt( number );\r\n\t\t\t\t\t\t\tString uidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( n );\r\n\t\t\t\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\t\t\t\t\t\tif( mail != null ) {\r\n\t\t\t\t\t\t\t\t\tif( sessionObject.mailbox.delete( uidl ) ) {\r\n\t\t\t\t\t\t\t\t\t\tmail.markForDeletion = true;\r\n\t\t\t\t\t\t\t\t\t\tnumberDeleted++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tsessionObject.error += _(\"Error deleting message: {0}\", sessionObject.mailbox.lastError()) + \"<br>\";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsessionObject.mailbox.performDelete();\r\n\t\t\t\tsessionObject.folder.setElements( sessionObject.mailbox.getUIDLs() );\r\n\t\t\t\tsessionObject.pageChanged = true;\r\n\t\t\t\tsessionObject.info += ngettext(\"1 message deleted.\", \"{0} messages deleted.\", numberDeleted);\r\n\t\t\t}\r\n\t\t\tsessionObject.reallyDelete = false;\r\n\t\t}\r\n\t\t\r\n\t\tsessionObject.markAll = buttonPressed( request, MARKALL );\r\n\t\tsessionObject.clear = buttonPressed( request, CLEAR );\r\n\t\tsessionObject.invert = buttonPressed( request, INVERT );\r\n\r\n\t\t/*\r\n\t\t * process sorting buttons\r\n\t\t */\r\n\t\tprocessSortingButton( sessionObject, request, SORT_ID );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_SENDER );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_SUBJECT );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_DATE );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_SIZE );\t\t\r\n\t}","id":45573,"modified_method":"/**\r\n\t * process buttons of folder view\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processFolderButtons(SessionObject sessionObject, RequestWrapper request)\r\n\t{\r\n\t\t/*\r\n\t\t * process paging buttons\r\n\t\t */\r\n\t\tString str = request.getParameter( PAGESIZE );\r\n\t\tif( str != null && str.length() > 0 ) {\r\n\t\t\ttry {\r\n\t\t\t\tint pageSize = Integer.parseInt( str );\r\n\t\t\t\tint oldPageSize = sessionObject.folder.getPageSize();\r\n\t\t\t\tif( pageSize != oldPageSize )\r\n\t\t\t\t\tsessionObject.folder.setPageSize( pageSize );\r\n\t\t\t}\r\n\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\tsessionObject.error += _(\"Invalid pagesize number, resetting to default value.\") + \"<br>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( buttonPressed( request, PREVPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.previousPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, NEXTPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.nextPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, FIRSTPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.firstPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, LASTPAGE ) ) {\r\n\t\t\tsessionObject.pageChanged = true;\r\n\t\t\tsessionObject.folder.lastPage();\r\n\t\t}\r\n\t\telse if( buttonPressed( request, DELETE ) ) {\r\n\t\t\tint m = getCheckedMessage( request );\r\n\t\t\tif( m != -1 )\r\n\t\t\t\tsessionObject.reallyDelete = true;\r\n\t\t\telse\r\n\t\t\t\tsessionObject.error += _(\"No messages marked for deletion.\") + \"<br>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint numberDeleted = 0;\r\n\t\t\tif( buttonPressed( request, REALLYDELETE ) ) {\r\n\t\t\t\tfor( Enumeration<String> e = request.getParameterNames(); e.hasMoreElements(); ) {\r\n\t\t\t\t\tString parameter = e.nextElement();\r\n\t\t\t\t\tif( parameter.startsWith( \"check\" ) && request.getParameter( parameter ).compareTo( \"1\" ) == 0 ) {\r\n\t\t\t\t\t\tString number = parameter.substring( 5 );\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tint n = Integer.parseInt( number );\r\n\t\t\t\t\t\t\tString uidl = sessionObject.folder.getElementAtPosXonCurrentPage( n );\r\n\t\t\t\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\t\t\t\t\t\tif( mail != null ) {\r\n\t\t\t\t\t\t\t\t\tif( sessionObject.mailbox.delete( uidl ) ) {\r\n\t\t\t\t\t\t\t\t\t\tmail.markForDeletion = true;\r\n\t\t\t\t\t\t\t\t\t\tnumberDeleted++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tsessionObject.error += _(\"Error deleting message: {0}\", sessionObject.mailbox.lastError()) + \"<br>\";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsessionObject.mailbox.performDelete();\r\n\t\t\t\tsessionObject.folder.setElements( sessionObject.mailbox.getUIDLs() );\r\n\t\t\t\tsessionObject.pageChanged = true;\r\n\t\t\t\tsessionObject.info += ngettext(\"1 message deleted.\", \"{0} messages deleted.\", numberDeleted);\r\n\t\t\t}\r\n\t\t\tsessionObject.reallyDelete = false;\r\n\t\t}\r\n\t\t\r\n\t\tsessionObject.markAll = buttonPressed( request, MARKALL );\r\n\t\tsessionObject.clear = buttonPressed( request, CLEAR );\r\n\t\tsessionObject.invert = buttonPressed( request, INVERT );\r\n\r\n\t\t/*\r\n\t\t * process sorting buttons\r\n\t\t */\r\n\t\tprocessSortingButton( sessionObject, request, SORT_ID );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_SENDER );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_SUBJECT );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_DATE );\r\n\t\tprocessSortingButton( sessionObject, request, SORT_SIZE );\t\t\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t */\r\n\tprivate static void showLogin( PrintWriter out )\r\n\t{\r\n\t\tString fixedPorts = Config.getProperty( CONFIG_PORTS_FIXED, \"true\" );\r\n\t\tboolean fixed = fixedPorts.compareToIgnoreCase( \"false\" ) != 0;\r\n\t\tString host = Config.getProperty( CONFIG_HOST, DEFAULT_HOST );\r\n\t\tString pop3 = Config.getProperty( CONFIG_PORTS_POP3, \"\" + DEFAULT_POP3PORT );\r\n\t\tString smtp = Config.getProperty( CONFIG_PORTS_SMTP, \"\" + DEFAULT_SMTPPORT );\r\n\t\t\r\n\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t// current postman hq length limits 16/12, new postman version 32/32\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"User\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"32\\\" name=\\\"\" + USER + \"\\\" value=\\\"\" + ( RELEASE ? \"\" : \"test\") + \"\\\"> @mail.i2p<\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"Password\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"password\\\" size=\\\"32\\\" name=\\\"pass\\\" value=\\\"\" + ( RELEASE ? \"\" : \"test\") + \"\\\"><\/td><\/tr>\\n\");\r\n\t\t// which is better?\r\n\t\t//if (!fixed) {\r\n\t\tif (true) {\r\n\t\t    out.println(\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"Host\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"32\\\" name=\\\"\" + HOST +\"\\\" value=\\\"\" + host + \"\\\"\" + ( fixed ? \" disabled\" : \"\" ) + \"><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"POP3-Port\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"5\\\" name=\\\"\" + POP3 +\"\\\" value=\\\"\" + pop3 + \"\\\"\" + ( fixed ? \" disabled\" : \"\" ) + \"><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"SMTP-Port\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"5\\\" name=\\\"\" + SMTP +\"\\\" value=\\\"\" + smtp + \"\\\"\" + ( fixed ? \" disabled\" : \"\" ) + \"><\/td><\/tr>\\n\");\r\n\t\t}\r\n\t\tout.println(\r\n\t\t\t\"<tr><td><\/td><td align=\\\"left\\\">\" + button( LOGIN, _(\"Login\") ) + \" <input class=\\\"cancel\\\" type=\\\"reset\\\" value=\\\"\" + _(\"Reset\") + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td><\/td><td align=\\\"left\\\"><a href=\\\"http://hq.postman.i2p/?page_id=14\\\">\" + _(\"Learn about I2P mail\") + \"<\/a><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td><\/td><td align=\\\"left\\\"><a href=\\\"http://hq.postman.i2p/?page_id=16\\\">\" + _(\"Create Account\") + \"<\/a><\/td><\/tr>\\n\" +\r\n\t\t\t\"<\/table>\");\r\n\t}","id":45574,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t */\r\n\tprivate static void showLogin( PrintWriter out )\r\n\t{\r\n\t\tString fixedPorts = Config.getProperty( CONFIG_PORTS_FIXED, \"true\" );\r\n\t\tboolean fixed = fixedPorts.compareToIgnoreCase( \"false\" ) != 0;\r\n\t\tString host = Config.getProperty( CONFIG_HOST, DEFAULT_HOST );\r\n\t\tString pop3 = Config.getProperty( CONFIG_PORTS_POP3, \"\" + DEFAULT_POP3PORT );\r\n\t\tString smtp = Config.getProperty( CONFIG_PORTS_SMTP, \"\" + DEFAULT_SMTPPORT );\r\n\t\t\r\n\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t// current postman hq length limits 16/12, new postman version 32/32\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"User\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"32\\\" name=\\\"\" + USER + \"\\\" value=\\\"\" + \"\\\"> @mail.i2p<\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"Password\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"password\\\" size=\\\"32\\\" name=\\\"pass\\\" value=\\\"\" + \"\\\"><\/td><\/tr>\\n\");\r\n\t\t// which is better?\r\n\t\t//if (!fixed) {\r\n\t\tif (true) {\r\n\t\t    out.println(\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"Host\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"32\\\" name=\\\"\" + HOST +\"\\\" value=\\\"\" + host + \"\\\"\" + ( fixed ? \" disabled\" : \"\" ) + \"><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"POP3 Port\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" style=\\\"text-align: right;\\\" size=\\\"5\\\" name=\\\"\" + POP3 +\"\\\" value=\\\"\" + pop3 + \"\\\"\" + ( fixed ? \" disabled\" : \"\" ) + \"><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td align=\\\"right\\\" width=\\\"30%\\\">\" + _(\"SMTP Port\") + \"<\/td><td width=\\\"40%\\\" align=\\\"left\\\"><input type=\\\"text\\\" style=\\\"text-align: right;\\\" size=\\\"5\\\" name=\\\"\" + SMTP +\"\\\" value=\\\"\" + smtp + \"\\\"\" + ( fixed ? \" disabled\" : \"\" ) + \"><\/td><\/tr>\\n\");\r\n\t\t}\r\n\t\tout.println(\r\n\t\t\t\"<tr><td><\/td><td align=\\\"left\\\">\" + button( LOGIN, _(\"Login\") ) + \" <input class=\\\"cancel\\\" type=\\\"reset\\\" value=\\\"\" + _(\"Reset\") + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td><\/td><td align=\\\"left\\\"><a href=\\\"http://hq.postman.i2p/?page_id=14\\\">\" + _(\"Learn about I2P mail\") + \"<\/a><\/td><\/tr>\\n\" +\r\n\t\t\t\"<tr><td><\/td><td align=\\\"left\\\"><a href=\\\"http://hq.postman.i2p/?page_id=16\\\">\" + _(\"Create Account\") + \"<\/a><\/td><\/tr>\\n\" +\r\n\t\t\t\"<\/table>\");\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * Process all buttons, which possibly change internal state.\r\n\t * \r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processStateChangeButtons(SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\t/*\r\n\t\t * LOGIN/LOGOUT\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\tprocessLogin( sessionObject, request );\r\n\r\n\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\tprocessLogout( sessionObject, request );\r\n\r\n\t\t/*\r\n\t\t *  compose dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_NEW ) {\r\n\t\t\tif( buttonPressed( request, CANCEL ) )\r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\r\n\t\t\telse if( buttonPressed( request, SEND ) )\r\n\t\t\t\tif( sendMail( sessionObject, request ) )\r\n\t\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t}\r\n\t\t/*\r\n\t\t * message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW ) {\r\n\t\t\tif( buttonPressed( request, LIST ) ) { \r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * buttons on both folder and message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW || sessionObject.state == STATE_LIST ) {\r\n\t\t\tif( buttonPressed( request, NEW ) ) {\r\n\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tboolean reply = false;\r\n\t\t\tboolean replyAll = false;\r\n\t\t\tboolean forward = false;\r\n\t\t\tsessionObject.replyTo = null;\r\n\t\t\tsessionObject.replyCC = null;\r\n\t\t\tsessionObject.body = null;\r\n\t\t\tsessionObject.subject = null;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLY ) )\r\n\t\t\t\treply = true;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLYALL ) ) {\r\n\t\t\t\treplyAll = true;\r\n\t\t\t}\r\n\t\t\tif( buttonPressed( request, FORWARD ) ) {\r\n\t\t\t\tforward = true;\r\n\t\t\t}\r\n\t\t\tif( reply || replyAll || forward ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * try to find message\r\n\t\t\t\t */\r\n\t\t\t\tString uidl = null;\r\n\t\t\t\tif( sessionObject.state == STATE_LIST ) {\r\n\t\t\t\t\tint pos = getCheckedMessage( request );\r\n\t\t\t\t\tuidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( pos );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tuidl = sessionObject.showUIDL;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_ALL );\r\n\t\t\t\t\tif( mail.part == null ) {\r\n\t\t\t\t\t\tmail.part = new MailPart();\r\n\t\t\t\t\t\tmail.part.parse( mail.body );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * extract original sender from Reply-To: or From:\r\n\t\t\t\t\t */\r\n\t\t\t\t\tif( mail.part != null ) {\r\n\t\t\t\t\t\tif( reply || replyAll ) {\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\tsessionObject.subject = \"Re: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println( _(\"On {0} {1} wrote:\", mail.formattedDate + \" UTC\", sessionObject.replyTo) );\r\n\t\t\t\t\t\t\tStringWriter text2 = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw2 = new PrintWriter( text2 );\r\n\t\t\t\t\t\t\tshowPart( pw2, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw2.flush();\r\n\t\t\t\t\t\t\tString[] lines = text2.toString().split( \"\\r\\n\" );\r\n\t\t\t\t\t\t\tfor( int i = 0; i < lines.length; i++ )\r\n\t\t\t\t\t\t\t\tpw.println( \"> \" + lines[i] );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( replyAll ) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * extract additional recipients\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\tStringBuilder buf = new StringBuilder();\r\n\t\t\t\t\t\t\tString pad = \"\";\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append( (String)mail.to[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append( (String)mail.cc[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( buf.length() > 0 )\r\n\t\t\t\t\t\t\t\tsessionObject.replyCC = buf.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( forward ) {\r\n\t\t\t\t\t\t\tsessionObject.subject = \"FWD: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tString sender = null;\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println( \"---- \" + _(\"begin forwarded mail\") + \" ----\" );\r\n\t\t\t\t\t\t\tpw.println( \"From: \" + sender );\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"To: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println( (String)mail.to[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"Cc: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println( (String)mail.cc[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.dateString != null )\r\n\t\t\t\t\t\t\t\tpw.print( \"Date: \" + mail.dateString );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tshowPart( pw, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw.println( \"----  \" + _(\"end forwarded mail\") + \"  ----\" );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsessionObject.error += _(\"Could not fetch mail body.\") + \"<br>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * folder view\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_LIST || sessionObject.state == STATE_SHOW) {\r\n\t\t\t/*\r\n\t\t\t * check if user wants to view a message\r\n\t\t\t */\r\n\t\t\tString show = request.getParameter( SHOW );\r\n\t\t\tif( show != null && show.length() > 0 ) {\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tint id = Integer.parseInt( show );\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( id >= 0 && id < sessionObject.folder.getPageSize() ) {\r\n\t\t\t\t\t\tString uidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( id );\r\n\t\t\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\t\t\tsessionObject.state = STATE_SHOW;\r\n\t\t\t\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch( NumberFormatException nfe )\r\n\t\t\t\t{\r\n\t\t\t\t\tsessionObject.error += _(\"Message id not valid.\") + \"<br>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":45575,"modified_method":"/**\r\n\t * Process all buttons, which possibly change internal state.\r\n\t * \r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processStateChangeButtons(SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\t/*\r\n\t\t * LOGIN/LOGOUT\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\tprocessLogin( sessionObject, request );\r\n\r\n\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\tprocessLogout( sessionObject, request );\r\n\r\n\t\t/*\r\n\t\t *  compose dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_NEW ) {\r\n\t\t\tif (buttonPressed( request, CANCEL ) ||\r\n\t\t\t    buttonPressed( request, LIST )) {      // LIST button not shown but we could be lost\r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t} else if( buttonPressed( request, SEND ) ) {\r\n\t\t\t\tif( sendMail( sessionObject, request ) )\r\n\t\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW ) {\r\n\t\t\tif( buttonPressed( request, LIST ) ) { \r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * buttons on both folder and message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW || sessionObject.state == STATE_LIST ) {\r\n\t\t\tif( buttonPressed( request, NEW ) ) {\r\n\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tboolean reply = false;\r\n\t\t\tboolean replyAll = false;\r\n\t\t\tboolean forward = false;\r\n\t\t\tsessionObject.replyTo = null;\r\n\t\t\tsessionObject.replyCC = null;\r\n\t\t\tsessionObject.body = null;\r\n\t\t\tsessionObject.subject = null;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLY ) )\r\n\t\t\t\treply = true;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLYALL ) ) {\r\n\t\t\t\treplyAll = true;\r\n\t\t\t}\r\n\t\t\tif( buttonPressed( request, FORWARD ) ) {\r\n\t\t\t\tforward = true;\r\n\t\t\t}\r\n\t\t\tif( reply || replyAll || forward ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * try to find message\r\n\t\t\t\t */\r\n\t\t\t\tString uidl = null;\r\n\t\t\t\tif( sessionObject.state == STATE_LIST ) {\r\n\t\t\t\t\tint pos = getCheckedMessage( request );\r\n\t\t\t\t\tuidl = sessionObject.folder.getElementAtPosXonCurrentPage( pos );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tuidl = sessionObject.showUIDL;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_ALL );\r\n\t\t\t\t\tif( mail.part == null ) {\r\n\t\t\t\t\t\tmail.part = new MailPart();\r\n\t\t\t\t\t\tmail.part.parse( mail.body );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * extract original sender from Reply-To: or From:\r\n\t\t\t\t\t */\r\n\t\t\t\t\tif( mail.part != null ) {\r\n\t\t\t\t\t\tif( reply || replyAll ) {\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\tsessionObject.subject = \"Re: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println( _(\"On {0} {1} wrote:\", mail.formattedDate + \" UTC\", sessionObject.replyTo) );\r\n\t\t\t\t\t\t\tStringWriter text2 = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw2 = new PrintWriter( text2 );\r\n\t\t\t\t\t\t\tshowPart( pw2, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw2.flush();\r\n\t\t\t\t\t\t\tString[] lines = text2.toString().split( \"\\r\\n\" );\r\n\t\t\t\t\t\t\tfor( int i = 0; i < lines.length; i++ )\r\n\t\t\t\t\t\t\t\tpw.println( \"> \" + lines[i] );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( replyAll ) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * extract additional recipients\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\tStringBuilder buf = new StringBuilder();\r\n\t\t\t\t\t\t\tString pad = \"\";\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append(mail.to[i]);\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append(mail.cc[i]);\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( buf.length() > 0 )\r\n\t\t\t\t\t\t\t\tsessionObject.replyCC = buf.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( forward ) {\r\n\t\t\t\t\t\t\tsessionObject.subject = \"FWD: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tString sender = null;\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println( \"---- \" + _(\"begin forwarded mail\") + \" ----\" );\r\n\t\t\t\t\t\t\tpw.println( \"From: \" + sender );\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"To: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println(mail.to[i]);\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"Cc: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println(mail.cc[i]);\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.dateString != null )\r\n\t\t\t\t\t\t\t\tpw.print( \"Date: \" + mail.dateString );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tshowPart( pw, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw.println( \"----  \" + _(\"end forwarded mail\") + \"  ----\" );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsessionObject.error += _(\"Could not fetch mail body.\") + \"<br>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * folder view\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_LIST || sessionObject.state == STATE_SHOW) {\r\n\t\t\t/*\r\n\t\t\t * check if user wants to view a message\r\n\t\t\t */\r\n\t\t\tString show = request.getParameter( SHOW );\r\n\t\t\tif( show != null && show.length() > 0 ) {\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tint id = Integer.parseInt( show );\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( id >= 0 && id < sessionObject.folder.getPageSize() ) {\r\n\t\t\t\t\t\tString uidl = sessionObject.folder.getElementAtPosXonCurrentPage( id );\r\n\t\t\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\t\t\tsessionObject.state = STATE_SHOW;\r\n\t\t\t\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch( NumberFormatException nfe )\r\n\t\t\t\t{\r\n\t\t\t\t\tsessionObject.error += _(\"Message id not valid.\") + \"<br>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void showFolder( PrintWriter out, SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete the marked messages?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete them!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\tbutton( REFRESH, _(\"Check Mail\") ) + spacer);\r\n\t\tif (Config.hasConfigFile())\r\n\t\t\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\tout.println(button( LOGOUT, _(\"Logout\") ) + \"<table id=\\\"mailbox\\\" cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<tr>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SENDER, _(\"Sender\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SUBJECT, _(\"Subject\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_DATE, _(\"Date\"), sessionObject.imgPath ) +\r\n\t\t\t//sortHeader( SORT_ID, \"\", sessionObject.imgPath ) +\r\n\t\t\t\"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SIZE, _(\"Size\"), sessionObject.imgPath ) + \"<\/th><\/tr>\" );\r\n\t\tint bg = 0;\r\n\t\tint i = 0;\r\n\t\tfor( Iterator<String> it = sessionObject.folder.currentPageIterator(); it != null && it.hasNext(); ) {\r\n\t\t\tString uidl = it.next();\r\n\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\tString link = \"<a href=\\\"\" + myself + \"?\" + SHOW + \"=\" + i + \"\\\">\";\r\n\t\t\t\r\n\t\t\tboolean idChecked = false;\r\n\t\t\tString checkId = sessionObject.pageChanged ? null : (String)request.getParameter( \"check\" + i );\r\n\t\t\t\r\n\t\t\tif( checkId != null && checkId.compareTo( \"1\" ) == 0 )\r\n\t\t\t\tidChecked = true;\r\n\t\t\t\r\n\t\t\tif( sessionObject.markAll )\r\n\t\t\t\tidChecked = true;\r\n\t\t\tif( sessionObject.invert )\r\n\t\t\t\tidChecked = !idChecked;\r\n\t\t\tif( sessionObject.clear )\r\n\t\t\t\tidChecked = false;\r\n\r\n\t\t\tDebug.debug( Debug.DEBUG, \"check\" + i + \": checkId=\" + checkId + \", idChecked=\" + idChecked + \", pageChanged=\" + sessionObject.pageChanged +\r\n\t\t\t\t\t\", markAll=\" + sessionObject.markAll +\r\n\t\t\t\t\t\", invert=\" + sessionObject.invert +\r\n\t\t\t\t\t\", clear=\" + sessionObject.clear );\r\n\t\t\tout.println( \"<tr class=\\\"list\" + bg + \"\\\"><td><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"check\" + i + \"\\\" value=\\\"1\\\"\" + \r\n\t\t\t\t\t( idChecked ? \"checked\" : \"\" ) + \">\" + ( RELEASE ? \"\" : \"\" + i ) + \"<\/td><td>\" +\r\n\t\t\t\t\tlink + mail.shortSender + \"<\/a><\/td><td>&nbsp;<\/td><td>\" + link + mail.shortSubject + \"<\/a><\/td><td>&nbsp;<\/td><td>\" +\r\n\t\t\t\t\t mail.localFormattedDate + \"<\/td><td>&nbsp;<\/td><td>\" + ngettext(\"1 Byte\", \"{0} Bytes\", mail.size) + \"<\/td><\/tr>\" );\r\n\t\t\tbg = 1 - bg;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<\/table>\" +\r\n\t\t\t\tbutton( MARKALL, _(\"Mark All\") ) +\r\n\t\t\t\tbutton( INVERT, _(\"Invert Selection\") ) +\r\n\t\t\t\tbutton( CLEAR, _(\"Clear\") ) +\r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t( sessionObject.folder.isFirstPage() ?\r\n\t\t\t\t\t\t\t\t\t\t button2( FIRSTPAGE, _(\"First\") ) + button2( PREVPAGE, _(\"Previous\") ) :\r\n \t\t\t\t\t\t\t\t\t\t button( FIRSTPAGE, _(\"First\") ) + button( PREVPAGE, _(\"Previous\") ) ) +\r\n\t\t\t\t\" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" + _(\"Page {0} of {1}\", sessionObject.folder.getCurrentPage(), sessionObject.folder.getPages()) + \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" +\r\n\t\t\t\t( sessionObject.folder.isLastPage() ? \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   button2( NEXTPAGE, _(\"Next\") ) + button2( LASTPAGE, _(\"Last\") ) :\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   button( NEXTPAGE, _(\"Next\") ) + button( LASTPAGE, _(\"Last\") ) ) +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t_(\"Pagesize:\") + \"&nbsp;<input type=\\\"text\\\" name=\\\"\" + PAGESIZE + \"\\\" size=\\\"4\\\" value=\\\"\" +  sessionObject.folder.getPageSize() + \"\\\">\" +\r\n\t\t\t\tbutton( SETPAGESIZE, _(\"Set\") ) );\r\n\t}","id":45576,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void showFolder( PrintWriter out, SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete the marked messages?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete them!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\t// In theory, these are valid and will apply to the first checked message,\r\n\t\t\t// but that's not obvious and did it work?\r\n\t\t\t//button( REPLY, _(\"Reply\") ) +\r\n\t\t\t//button( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\t//button( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\tbutton( REFRESH, _(\"Check Mail\") ) + spacer);\r\n\t\tif (Config.hasConfigFile())\r\n\t\t\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\tout.println(button( LOGOUT, _(\"Logout\") ));\r\n\r\n\t\tif (sessionObject.folder.getPages() > 1) {\r\n\t\t\tout.println(\r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t( sessionObject.folder.isFirstPage() ?\r\n\t\t\t\t\t\t\t\t\tbutton2( FIRSTPAGE, _(\"First\") ) + button2( PREVPAGE, _(\"Previous\") ) :\r\n\t\t\t\t\t\t\t\t\tbutton( FIRSTPAGE, _(\"First\") ) + button( PREVPAGE, _(\"Previous\") ) ) +\r\n\t\t\t\t\" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" +\r\n\t\t\t\t_(\"Page {0} of {1}\", sessionObject.folder.getCurrentPage(), sessionObject.folder.getPages()) +\r\n\t\t\t\t\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" +\r\n\t\t\t\t( sessionObject.folder.isLastPage() ? \r\n\t\t\t\t\t\t\t\t\tbutton2( NEXTPAGE, _(\"Next\") ) + button2( LASTPAGE, _(\"Last\") ) :\r\n\t\t\t\t\t\t\t\t\tbutton( NEXTPAGE, _(\"Next\") ) + button( LASTPAGE, _(\"Last\") ) )\r\n\t\t\t\t);\r\n\t\t}\r\n\r\n\t\tout.println(\"<table id=\\\"mailbox\\\" cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<tr>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SENDER, _(\"Sender\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SUBJECT, _(\"Subject\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_DATE, _(\"Date\"), sessionObject.imgPath ) +\r\n\t\t\t//sortHeader( SORT_ID, \"\", sessionObject.imgPath ) +\r\n\t\t\t\"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SIZE, _(\"Size\"), sessionObject.imgPath ) + \"<\/th><\/tr>\" );\r\n\t\tint bg = 0;\r\n\t\tint i = 0;\r\n\t\tfor( Iterator<String> it = sessionObject.folder.currentPageIterator(); it != null && it.hasNext(); ) {\r\n\t\t\tString uidl = it.next();\r\n\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\tString link = \"<a href=\\\"\" + myself + \"?\" + SHOW + \"=\" + i + \"\\\">\";\r\n\t\t\t\r\n\t\t\tboolean idChecked = false;\r\n\t\t\tString checkId = sessionObject.pageChanged ? null : request.getParameter( \"check\" + i );\r\n\t\t\t\r\n\t\t\tif( checkId != null && checkId.compareTo( \"1\" ) == 0 )\r\n\t\t\t\tidChecked = true;\r\n\t\t\t\r\n\t\t\tif( sessionObject.markAll )\r\n\t\t\t\tidChecked = true;\r\n\t\t\tif( sessionObject.invert )\r\n\t\t\t\tidChecked = !idChecked;\r\n\t\t\tif( sessionObject.clear )\r\n\t\t\t\tidChecked = false;\r\n\r\n\t\t\t//Debug.debug( Debug.DEBUG, \"check\" + i + \": checkId=\" + checkId + \", idChecked=\" + idChecked + \", pageChanged=\" + sessionObject.pageChanged +\r\n\t\t\t//\t\t\", markAll=\" + sessionObject.markAll +\r\n\t\t\t//\t\t\", invert=\" + sessionObject.invert +\r\n\t\t\t//\t\t\", clear=\" + sessionObject.clear );\r\n\t\t\tout.println( \"<tr class=\\\"list\" + bg + \"\\\"><td><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"check\" + i + \"\\\" value=\\\"1\\\"\" + \r\n\t\t\t\t\t( idChecked ? \"checked\" : \"\" ) + \">\" + \"<\/td><td>\" +\r\n\t\t\t\t\tlink + mail.shortSender + \"<\/a><\/td><td>&nbsp;<\/td><td>\" + link + mail.shortSubject + \"<\/a><\/td><td>&nbsp;<\/td><td>\" +\r\n\t\t\t\t\t mail.localFormattedDate + \"<\/td><td>&nbsp;<\/td><td>\" + ngettext(\"1 Byte\", \"{0} Bytes\", mail.size) + \"<\/td><\/tr>\" );\r\n\t\t\tbg = 1 - bg;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<\/table>\" +\r\n\t\t\t\tbutton( MARKALL, _(\"Mark All\") ) +\r\n\t\t\t\tbutton( INVERT, _(\"Invert Selection\") ) +\r\n\t\t\t\tbutton( CLEAR, _(\"Clear\") ) +\r\n\t\t\t\t\"<br>\");\r\n\t\tout.println(\r\n\t\t\t\t_(\"Page Size:\") + \"&nbsp;<input type=\\\"text\\\" style=\\\"text-align: right;\\\" name=\\\"\" + PAGESIZE + \"\\\" size=\\\"4\\\" value=\\\"\" +  sessionObject.folder.getPageSize() + \"\\\">\" +\r\n\t\t\t\tbutton( SETPAGESIZE, _(\"Set\") ) );\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * process buttons of message view\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processMessageButtons(SessionObject sessionObject, RequestWrapper request)\r\n\t{\r\n\t\tif( buttonPressed( request, PREV ) ) {\r\n\t\t\tString uidl = (String)sessionObject.folder.getPreviousElement( sessionObject.showUIDL );\r\n\t\t\tif( uidl != null )\r\n\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t}\r\n\t\tif( buttonPressed( request, NEXT ) ) {\r\n\t\t\tString uidl = (String)sessionObject.folder.getNextElement( sessionObject.showUIDL );\r\n\t\t\tif( uidl != null )\r\n\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t}\r\n\t\t\r\n\t\tsessionObject.reallyDelete = buttonPressed( request, DELETE );\r\n\t\t\r\n\t\tif( buttonPressed( request, REALLYDELETE ) ) {\r\n\t\t\t/*\r\n\t\t\t * first find the next message\r\n\t\t\t */\r\n\t\t\tString nextUIDL = (String)sessionObject.folder.getNextElement( sessionObject.showUIDL );\r\n\t\t\tif( nextUIDL == null ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * nothing found? then look for the previous one\r\n\t\t\t\t */\r\n\t\t\t\tnextUIDL = (String)sessionObject.folder.getPreviousElement( sessionObject.showUIDL );\r\n\t\t\t\tif( nextUIDL == null )\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * still nothing found? then this was the last message, so go back to the folder\r\n\t\t\t\t\t */\r\n\t\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t\tsessionObject.mailbox.delete( sessionObject.showUIDL );\r\n\t\t\tsessionObject.mailbox.performDelete();\r\n\t\t\tsessionObject.folder.setElements( sessionObject.mailbox.getUIDLs() );\r\n\t\t\tsessionObject.showUIDL = nextUIDL;\r\n\t\t}\r\n\t\t\r\n\t\tString str = request.getParameter( DOWNLOAD );\r\n\t\tif( str != null ) {\r\n\t\t\ttry {\r\n\t\t\t\tint hashCode = Integer.parseInt( str );\r\n\t\t\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\t\t\tMailPart part = getMailPartFromHashCode( mail.part, hashCode );\r\n\t\t\t\tif( part != null )\r\n\t\t\t\t\tsessionObject.showAttachment = part;\r\n\t\t\t}\r\n\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\tsessionObject.error += _(\"Error parsing download parameter.\");\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":45577,"modified_method":"/**\r\n\t * process buttons of message view\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processMessageButtons(SessionObject sessionObject, RequestWrapper request)\r\n\t{\r\n\t\tif( buttonPressed( request, PREV ) ) {\r\n\t\t\tString uidl = sessionObject.folder.getPreviousElement( sessionObject.showUIDL );\r\n\t\t\tif( uidl != null )\r\n\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t}\r\n\t\tif( buttonPressed( request, NEXT ) ) {\r\n\t\t\tString uidl = sessionObject.folder.getNextElement( sessionObject.showUIDL );\r\n\t\t\tif( uidl != null )\r\n\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t}\r\n\t\t\r\n\t\tsessionObject.reallyDelete = buttonPressed( request, DELETE );\r\n\t\t\r\n\t\tif( buttonPressed( request, REALLYDELETE ) ) {\r\n\t\t\t/*\r\n\t\t\t * first find the next message\r\n\t\t\t */\r\n\t\t\tString nextUIDL = sessionObject.folder.getNextElement( sessionObject.showUIDL );\r\n\t\t\tif( nextUIDL == null ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * nothing found? then look for the previous one\r\n\t\t\t\t */\r\n\t\t\t\tnextUIDL = sessionObject.folder.getPreviousElement( sessionObject.showUIDL );\r\n\t\t\t\tif( nextUIDL == null )\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * still nothing found? then this was the last message, so go back to the folder\r\n\t\t\t\t\t */\r\n\t\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t\tsessionObject.mailbox.delete( sessionObject.showUIDL );\r\n\t\t\tsessionObject.mailbox.performDelete();\r\n\t\t\tsessionObject.folder.setElements( sessionObject.mailbox.getUIDLs() );\r\n\t\t\tsessionObject.showUIDL = nextUIDL;\r\n\t\t}\r\n\t\t\r\n\t\tString str = request.getParameter( DOWNLOAD );\r\n\t\tif( str != null ) {\r\n\t\t\ttry {\r\n\t\t\t\tint hashCode = Integer.parseInt( str );\r\n\t\t\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\t\t\tMailPart part = getMailPartFromHashCode( mail.part, hashCode );\r\n\t\t\t\tif( part != null )\r\n\t\t\t\t\tsessionObject.showAttachment = part;\r\n\t\t\t}\r\n\t\t\tcatch( NumberFormatException nfe ) {\r\n\t\t\t\tsessionObject.error += _(\"Error parsing download parameter.\");\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t */\r\n\tprivate static void showMessage( PrintWriter out, SessionObject sessionObject )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete this message?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete it!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\tif( mail != null && mail.body != null && mail.part == null ) {\r\n\t\t\tmail.part = new MailPart();\r\n\t\t\tmail.part.parse( mail.body );\r\n\t\t}\r\n\t\tif(!RELEASE && mail != null && mail.body != null) {\r\n\t\t\tout.println( \"<!--\" );\r\n\t\t\t// FIXME encoding, escaping --, etc... but disabled.\r\n\t\t\tout.println( quoteHTML( new String( mail.body.content, mail.body.offset, mail.body.length ) ) );\r\n\t\t\tout.println( \"-->\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\t( sessionObject.folder.isFirstElement( sessionObject.showUIDL ) ? button2( PREV, _(\"Previous\") ) : button( PREV, _(\"Previous\") ) ) +\r\n\t\t\t( sessionObject.folder.isLastElement( sessionObject.showUIDL ) ? button2( NEXT, _(\"Next\") ) : button( NEXT, _(\"Next\") ) ) + spacer +\r\n\t\t\tbutton( LIST, _(\"Back to Folder\") ) + spacer);\r\n\t\t//if (Config.hasConfigFile())\r\n\t\t//\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\t//out.println(button( LOGOUT, _(\"Logout\") ) );\r\n\t\tif( mail != null ) {\r\n\t\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"From:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.sender ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Subject:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSubject ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Date:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + mail.quotedDate + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\" );\r\n\t\t\tif( mail.body != null ) {\r\n\t\t\t\tshowPart( out, mail.part, 0, SHOW_HTML );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail body.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n<\/table>\" );\r\n\t}","id":45578,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t */\r\n\tprivate static void showMessage( PrintWriter out, SessionObject sessionObject )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete this message?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete it!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\tif( mail != null && mail.body != null && mail.part == null ) {\r\n\t\t\tmail.part = new MailPart();\r\n\t\t\tmail.part.parse( mail.body );\r\n\t\t}\r\n\t\tif(!RELEASE && mail != null && mail.body != null) {\r\n\t\t\tout.println( \"<!--\" );\r\n\t\t\t// FIXME encoding, escaping --, etc... but disabled.\r\n\t\t\tout.println( quoteHTML( new String( mail.body.content, mail.body.offset, mail.body.length ) ) );\r\n\t\t\tout.println( \"-->\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\t\"<br>\" +\r\n\t\t\t( sessionObject.folder.isFirstElement( sessionObject.showUIDL ) ? button2( PREV, _(\"Previous\") ) : button( PREV, _(\"Previous\") ) ) + spacer +\r\n\t\t\tbutton( LIST, _(\"Back to Folder\") ) + spacer +\r\n\t\t\t( sessionObject.folder.isLastElement( sessionObject.showUIDL ) ? button2( NEXT, _(\"Next\") ) : button( NEXT, _(\"Next\") ) ));\r\n\t\t//if (Config.hasConfigFile())\r\n\t\t//\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\t//out.println(button( LOGOUT, _(\"Logout\") ) );\r\n\t\tif( mail != null ) {\r\n\t\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"From:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.sender ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Subject:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSubject ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Date:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + mail.quotedDate + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\" );\r\n\t\t\tif( mail.body != null ) {\r\n\t\t\t\tshowPart( out, mail.part, 0, SHOW_HTML );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail body.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n<\/table>\" );\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t * @return success\r\n\t */\r\n\tprivate static boolean sendMail( SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tboolean ok = true;\r\n\t\t\r\n\t\tString from = request.getParameter( NEW_FROM );\r\n\t\tString to = request.getParameter( NEW_TO );\r\n\t\tString cc = request.getParameter( NEW_CC );\r\n\t\tString bcc = request.getParameter( NEW_BCC );\r\n\t\tString subject = request.getParameter( NEW_SUBJECT, _(\"no subject\") );\r\n\t\tString text = request.getParameter( NEW_TEXT, \"\" );\r\n\r\n\t\tString prop = Config.getProperty( CONFIG_SENDER_FIXED, \"true\" );\r\n\t\tString domain = Config.getProperty( CONFIG_SENDER_DOMAIN, \"mail.i2p\" );\r\n\t\tif( prop.compareToIgnoreCase( \"false\" ) != 0 ) {\r\n\t\t\tfrom = \"<\" + sessionObject.user + \"@\" + domain + \">\";\r\n\t\t}\r\n\t\tArrayList<String> toList = new ArrayList<String>();\r\n\t\tArrayList<String> ccList = new ArrayList<String>();\r\n\t\tArrayList<String> bccList = new ArrayList<String>();\r\n\t\tArrayList<String> recipients = new ArrayList<String>();\r\n\t\t\r\n\t\tString sender = null;\r\n\t\t\r\n\t\tif( from == null || !Mail.validateAddress( from ) ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"Found no valid sender address.\") + \"<br>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsender = Mail.getAddress( from );\r\n\t\t\tif( sender == null || sender.length() == 0 ) {\r\n\t\t\t\tok = false;\r\n\t\t\t\tsessionObject.error += _(\"Found no valid address in \\\\''{0}\\\\''.\", quoteHTML( from )) + \"<br>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tok = Mail.getRecipientsFromList( toList, to, ok );\r\n\t\tok = Mail.getRecipientsFromList( ccList, cc, ok );\r\n\t\tok = Mail.getRecipientsFromList( bccList, bcc, ok );\r\n\r\n\t\trecipients.addAll( toList );\r\n\t\trecipients.addAll( ccList );\r\n\t\trecipients.addAll( bccList );\r\n\t\t\r\n\t\tString bccToSelf = request.getParameter( NEW_BCC_TO_SELF );\r\n\t\t\r\n\t\tif( bccToSelf != null && bccToSelf.compareTo( \"1\" ) == 0 )\r\n\t\t\trecipients.add( sender );\r\n\t\t\r\n\t\tif( recipients.isEmpty() ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"No recipients found.\") + \"<br>\";\r\n\t\t}\r\n\t\tEncoding qp = EncodingFactory.getEncoding( \"quoted-printable\" );\r\n\t\tEncoding hl = EncodingFactory.getEncoding( \"HEADERLINE\" );\r\n\t\t\r\n\t\tif( qp == null ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"Quoted printable encoder not available.\");\r\n\t\t}\r\n\t\t\r\n\t\tif( hl == null ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"Header line encoder not available.\");\r\n\t\t}\r\n\r\n\t\tif( ok ) {\r\n\t\t\tStringBuilder body = new StringBuilder();\r\n\t\t\tbody.append( \"From: \" + from + \"\\r\\n\" );\r\n\t\t\tMail.appendRecipients( body, toList, \"To: \" );\r\n\t\t\tMail.appendRecipients( body, ccList, \"To: \" );\r\n\t\t\tbody.append( \"Subject: \" );\r\n\t\t\ttry {\r\n\t\t\t\tbody.append( hl.encode( subject ) );\r\n\t\t\t} catch (EncodingException e) {\r\n\t\t\t\tok = false;\r\n\t\t\t\tsessionObject.error += e.getMessage();\r\n\t\t\t}\r\n\t\t\tString boundary = \"_=\"+(int)(Math.random()*Integer.MAX_VALUE)+\"\"+(int)(Math.random()*Integer.MAX_VALUE);\r\n\t\t\tboolean multipart = false;\r\n\t\t\tif( sessionObject.attachments != null && !sessionObject.attachments.isEmpty() ) {\r\n\t\t\t\tmultipart = true;\r\n\t\t\t\tbody.append( \"\\r\\nMIME-Version: 1.0\\r\\nContent-type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\\r\\n\\r\\n\" );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbody.append( \"\\r\\nMIME-Version: 1.0\\r\\nContent-type: text/plain; charset=\\\"utf-8\\\"\\r\\nContent-Transfer-Encoding: quoted-printable\\r\\n\\r\\n\" );\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tif( multipart )\r\n\t\t\t\t\tbody.append( \"--\" + boundary + \"\\r\\nContent-type: text/plain; charset=\\\"utf-8\\\"\\r\\nContent-Transfer-Encoding: quoted-printable\\r\\n\\r\\n\" );\r\n\t\t\t\tbody.append( qp.encode( text ) );\r\n\t\t\t} catch (EncodingException e) {\r\n\t\t\t\tok = false;\r\n\t\t\t\tsessionObject.error += e.getMessage();\r\n\t\t\t}\r\n\r\n\t\t\tif( multipart ) {\r\n\t\t\t\tfor( Attachment attachment : sessionObject.attachments ) {\r\n\t\t\t\t\tbody.append( \"\\r\\n--\" + boundary + \"\\r\\nContent-type: \" + attachment.getContentType() + \"\\r\\nContent-Disposition: attachment; filename=\\\"\" + attachment.getFileName() + \"\\\"\\r\\nContent-Transfer-Encoding: \" + attachment.getTransferEncoding() + \"\\r\\n\\r\\n\" );\r\n\t\t\t\t\tbody.append( attachment.getData() );\r\n\t\t\t\t}\r\n\t\t\t\tbody.append( \"\\r\\n--\" + boundary + \"--\\r\\n\" );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsessionObject.sentMail = body.toString();\t\r\n\t\t\t\r\n\t\t\tSMTPClient relay = new SMTPClient();\r\n\t\t\t\r\n\t\t\tif( ok ) {\r\n\t\t\t\tif( relay.sendMail( sessionObject.host, sessionObject.smtpPort,\r\n\t\t\t\t\t\tsessionObject.user, sessionObject.pass,\r\n\t\t\t\t\t\tsender, recipients.toArray(), body.toString() ) ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tsessionObject.info += _(\"Mail sent.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( sessionObject.attachments != null )\r\n\t\t\t\t\t\tsessionObject.attachments.clear();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t\tok = false;\r\n\t\t\t\t\t\tsessionObject.error += relay.error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ok;\r\n\t}","id":45579,"modified_method":"/**\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t * @return success\r\n\t */\r\n\tprivate static boolean sendMail( SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tboolean ok = true;\r\n\t\t\r\n\t\tString from = request.getParameter( NEW_FROM );\r\n\t\tString to = request.getParameter( NEW_TO );\r\n\t\tString cc = request.getParameter( NEW_CC );\r\n\t\tString bcc = request.getParameter( NEW_BCC );\r\n\t\tString subject = request.getParameter( NEW_SUBJECT, _(\"no subject\") );\r\n\t\tString text = request.getParameter( NEW_TEXT, \"\" );\r\n\r\n\t\tString prop = Config.getProperty( CONFIG_SENDER_FIXED, \"true\" );\r\n\t\tString domain = Config.getProperty( CONFIG_SENDER_DOMAIN, \"mail.i2p\" );\r\n\t\tif( prop.compareToIgnoreCase( \"false\" ) != 0 ) {\r\n\t\t\tfrom = \"<\" + sessionObject.user + \"@\" + domain + \">\";\r\n\t\t}\r\n\t\tArrayList<String> toList = new ArrayList<String>();\r\n\t\tArrayList<String> ccList = new ArrayList<String>();\r\n\t\tArrayList<String> bccList = new ArrayList<String>();\r\n\t\tArrayList<String> recipients = new ArrayList<String>();\r\n\t\t\r\n\t\tString sender = null;\r\n\t\t\r\n\t\tif( from == null || !Mail.validateAddress( from ) ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"Found no valid sender address.\") + \"<br>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsender = Mail.getAddress( from );\r\n\t\t\tif( sender == null || sender.length() == 0 ) {\r\n\t\t\t\tok = false;\r\n\t\t\t\tsessionObject.error += _(\"Found no valid address in \\\\''{0}\\\\''.\", quoteHTML( from )) + \"<br>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tok = Mail.getRecipientsFromList( toList, to, ok );\r\n\t\tok = Mail.getRecipientsFromList( ccList, cc, ok );\r\n\t\tok = Mail.getRecipientsFromList( bccList, bcc, ok );\r\n\r\n\t\trecipients.addAll( toList );\r\n\t\trecipients.addAll( ccList );\r\n\t\trecipients.addAll( bccList );\r\n\t\t\r\n\t\tString bccToSelf = request.getParameter( NEW_BCC_TO_SELF );\r\n\t\t\r\n\t\tif( bccToSelf != null && bccToSelf.compareTo( \"1\" ) == 0 )\r\n\t\t\trecipients.add( sender );\r\n\t\t\r\n\t\tif( toList.isEmpty() ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"No recipients found.\") + \"<br>\";\r\n\t\t}\r\n\t\tEncoding qp = EncodingFactory.getEncoding( \"quoted-printable\" );\r\n\t\tEncoding hl = EncodingFactory.getEncoding( \"HEADERLINE\" );\r\n\t\t\r\n\t\tif( qp == null ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"Internal error\") + \": Quoted printable encoder not available.\";\r\n\t\t}\r\n\t\t\r\n\t\tif( hl == null ) {\r\n\t\t\tok = false;\r\n\t\t\tsessionObject.error += _(\"Internal error\") + \": Header line encoder not available.\";\r\n\t\t}\r\n\r\n\t\tif( ok ) {\r\n\t\t\tStringBuilder body = new StringBuilder();\r\n\t\t\tbody.append( \"From: \" + from + \"\\r\\n\" );\r\n\t\t\tMail.appendRecipients( body, toList, \"To: \" );\r\n\t\t\tMail.appendRecipients( body, ccList, \"To: \" );\r\n\t\t\tbody.append( \"Subject: \" );\r\n\t\t\ttry {\r\n\t\t\t\tbody.append( hl.encode( subject ) );\r\n\t\t\t} catch (EncodingException e) {\r\n\t\t\t\tok = false;\r\n\t\t\t\tsessionObject.error += e.getMessage();\r\n\t\t\t}\r\n\t\t\tString boundary = \"_=\"+(int)(Math.random()*Integer.MAX_VALUE)+\"\"+(int)(Math.random()*Integer.MAX_VALUE);\r\n\t\t\tboolean multipart = false;\r\n\t\t\tif( sessionObject.attachments != null && !sessionObject.attachments.isEmpty() ) {\r\n\t\t\t\tmultipart = true;\r\n\t\t\t\tbody.append( \"\\r\\nMIME-Version: 1.0\\r\\nContent-type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\\r\\n\\r\\n\" );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbody.append( \"\\r\\nMIME-Version: 1.0\\r\\nContent-type: text/plain; charset=\\\"utf-8\\\"\\r\\nContent-Transfer-Encoding: quoted-printable\\r\\n\\r\\n\" );\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tif( multipart )\r\n\t\t\t\t\tbody.append( \"--\" + boundary + \"\\r\\nContent-type: text/plain; charset=\\\"utf-8\\\"\\r\\nContent-Transfer-Encoding: quoted-printable\\r\\n\\r\\n\" );\r\n\t\t\t\tbody.append( qp.encode( text ) );\r\n\t\t\t} catch (EncodingException e) {\r\n\t\t\t\tok = false;\r\n\t\t\t\tsessionObject.error += e.getMessage();\r\n\t\t\t}\r\n\r\n\t\t\tif( multipart ) {\r\n\t\t\t\tfor( Attachment attachment : sessionObject.attachments ) {\r\n\t\t\t\t\tbody.append( \"\\r\\n--\" + boundary + \"\\r\\nContent-type: \" + attachment.getContentType() + \"\\r\\nContent-Disposition: attachment; filename=\\\"\" + attachment.getFileName() + \"\\\"\\r\\nContent-Transfer-Encoding: \" + attachment.getTransferEncoding() + \"\\r\\n\\r\\n\" );\r\n\t\t\t\t\tbody.append( attachment.getData() );\r\n\t\t\t\t}\r\n\t\t\t\tbody.append( \"\\r\\n--\" + boundary + \"--\\r\\n\" );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsessionObject.sentMail = body.toString();\t\r\n\t\t\t\r\n\t\t\tSMTPClient relay = new SMTPClient();\r\n\t\t\t\r\n\t\t\tif( ok ) {\r\n\t\t\t\tif( relay.sendMail( sessionObject.host, sessionObject.smtpPort,\r\n\t\t\t\t\t\tsessionObject.user, sessionObject.pass,\r\n\t\t\t\t\t\tsender, recipients.toArray(), body.toString() ) ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tsessionObject.info += _(\"Mail sent.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( sessionObject.attachments != null )\r\n\t\t\t\t\t\tsessionObject.attachments.clear();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t\tok = false;\r\n\t\t\t\t\t\tsessionObject.error += relay.error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ok;\r\n\t}","commit_id":"6ecfedba3761465501eea1e1ce237850d5f9a6a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void execute() throws CFGBuilderException, DataflowAnalysisException {\n\t\tif (AnalysisContext.currentAnalysisContext().getBoolProperty(AnalysisFeatures.CONSERVE_SPACE))\n\t\t\tthrow new IllegalStateException(\"This should not happen\");\n\n\t\tSet<Edge> deletedEdgeSet = new HashSet<Edge>();\n\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(\"PruneUnconditionalExceptionThrowerEdges: examining \" +\n\t\t\t        SignatureConverter.convertMethodSignature(methodGen));\n\t\t Subtypes subtypes = AnalysisContext.currentAnalysisContext()\n\t\t\t.getSubtypes();\n\t\tfor (Iterator<BasicBlock> i = cfg.blockIterator(); i.hasNext();) {\n\t\t\tBasicBlock basicBlock = i.next();\n\t\t\tif (!basicBlock.isExceptionThrower())\n\t\t\t\tcontinue;\n\n\t\t\tInstruction exceptionThrower = basicBlock.getExceptionThrower().getInstruction();\n\t\t\tif (!(exceptionThrower instanceof InvokeInstruction))\n\t\t\t\tcontinue;\n\n\t\t\tInvokeInstruction inv = (InvokeInstruction) exceptionThrower;\n\t\t\ttry {\n\t\t\t\tString className = inv.getClassName(cpg);\n\t\t\t\tif (className.startsWith(\"[\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tString methodSig = inv.getSignature(cpg);\n\t\t\t\tif (!methodSig.endsWith(\"V\")) \n\t\t\t\t\tcontinue;\n\t\t\t\tJavaClass javaClass = Repository.lookupClass(className);\n\t\t\t\tClassContext classContext = analysisContext.getClassContext(javaClass);\n\n\t\t\t\tif (DEBUG) System.out.println(\"\\tlooking up method for \" + basicBlock.getExceptionThrower());\n\t\t\t\tJavaClassAndMethod classAndMethod = Hierarchy.findExactMethod(inv, cpg);\n\t\t\t\tif (classAndMethod == null) {\n\t\t\t\t\tif (DEBUG) System.out.println(\"\\tNOT FOUND\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tMethod method = classAndMethod.getMethod();\n\t\t\t\tXMethod xMethod = XFactory.createXMethod(javaClass, method);\n\t\t\t\tif (DEBUG) System.out.println(\"\\tFound \" + method);\n\n\t\t\t\t// FIXME: for now, only allow static and private methods.\n\t\t\t\t// Could also allow final methods (but would require class hierarchy\n\t\t\t\t// search).\n\t\t\t\tif (!(method.isStatic() || method.isPrivate() || method.isFinal() || javaClass.isFinal() || !subtypes.hasSubtypes(javaClass)))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t// Ignore abstract and native methods\n\t\t\t\tif (method.getCode() == null) continue;\n\t\t\t\t\n\t\t\t\tBitSet bytecodeSet = classContext.getBytecodeSet(method);\n\t\t\t\t\n\t\t\t\tBoolean result = cachedResults.get(xMethod);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = bytecodeSet.intersects(RETURN_OPCODE_SET);\n\t\t\t\t\tcachedResults.put(xMethod, result);\n\t\t\t\t}\n\t\t\t\tif (false && result.booleanValue()) {\n\t\t\t\t    MethodGen calledMethodGen = classContext.getMethodGen(method);\n\t\t\t\t\t// Ignore abstract and native methods\n\n\t\t\t\t\tif (calledMethodGen == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// Analyze exception paths of called method\n\t\t\t\t\t// to see if it always throws an unhandled exception.\n\t\t\t\t\tCFG calledCFG = classContext.getCFG(method);\n\t\t\t\t\tReturnPathDataflow pathDataflow = classContext\n\t\t\t\t\t\t\t.getReturnPathDataflow(method);\n\t\t\t\t\tReturnPath pathValue = pathDataflow.getStartFact(calledCFG\n\t\t\t\t\t\t\t.getExit());\n\n\t\t\t\t\tresult = pathValue.getKind() != ReturnPath.RETURNS;\n\t\t\t\t\t// System.out.println(\"isThrower: \" + result + \" \" + method.getCode().getLength() + \" \" + method);\n\t\t\t\t\tif (true) cachedResults.put(xMethod, result);\n\t\t\t\t}\n\n\t\t\t\tif (result.booleanValue()) {\n\t\t\t\t\t// Method always throws an unhandled exception\n\t\t\t\t\t// Remove the normal control flow edge from the CFG.\n\t\t\t\t\tEdge fallThrough = cfg.getOutgoingEdgeWithType(basicBlock,\n\t\t\t\t\t\t\tFALL_THROUGH_EDGE);\n\t\t\t\t\tif (fallThrough != null) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"\\tREMOVING normal return for: \" + xMethod);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeletedEdgeSet.add(fallThrough);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tanalysisContext.getLookupFailureCallback().reportMissingClass(e);\n\t\t\t}\n\t\t}\n\n\t\t// Remove all edges marked for deletion\n\t\tfor (Edge edge : deletedEdgeSet) {\n\t\t\tcfg.removeEdge(edge);\n\t\t}\n\t}","id":45580,"modified_method":"public void execute() throws CFGBuilderException, DataflowAnalysisException {\n\t\tif (AnalysisContext.currentAnalysisContext().getBoolProperty(AnalysisFeatures.CONSERVE_SPACE))\n\t\t\tthrow new IllegalStateException(\"This should not happen\");\n\n\t\tSet<Edge> deletedEdgeSet = new HashSet<Edge>();\n\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(\"PruneUnconditionalExceptionThrowerEdges: examining \" +\n\t\t\t        SignatureConverter.convertMethodSignature(methodGen));\n\t\t Subtypes subtypes = AnalysisContext.currentAnalysisContext()\n\t\t\t.getSubtypes();\n\t\tfor (Iterator<BasicBlock> i = cfg.blockIterator(); i.hasNext();) {\n\t\t\tBasicBlock basicBlock = i.next();\n\t\t\tif (!basicBlock.isExceptionThrower())\n\t\t\t\tcontinue;\n\n\t\t\tInstruction exceptionThrower = basicBlock.getExceptionThrower().getInstruction();\n\t\t\tif (!(exceptionThrower instanceof InvokeInstruction))\n\t\t\t\tcontinue;\n\n\t\t\tInvokeInstruction inv = (InvokeInstruction) exceptionThrower;\n\t\t\ttry {\n\t\t\t\tString className = inv.getClassName(cpg);\n\t\t\t\tif (className.startsWith(\"[\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tString methodSig = inv.getSignature(cpg);\n\t\t\t\tif (!methodSig.endsWith(\"V\")) \n\t\t\t\t\tcontinue;\n\t\t\t\tJavaClass javaClass = Repository.lookupClass(className);\n\t\t\t\tClassContext classContext = analysisContext.getClassContext(javaClass);\n\n\t\t\t\tif (DEBUG) System.out.println(\"\\tlooking up method for \" + basicBlock.getExceptionThrower());\n\t\t\t\tJavaClassAndMethod classAndMethod = Hierarchy.findExactMethod(inv, cpg);\n\t\t\t\tif (classAndMethod == null) {\n\t\t\t\t\tif (DEBUG) System.out.println(\"\\tNOT FOUND\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tMethod method = classAndMethod.getMethod();\n\t\t\t\tXMethod xMethod = XFactory.createXMethod(javaClass, method);\n\t\t\t\tif (DEBUG) System.out.println(\"\\tFound \" + xMethod);\n\n\t\t\t\t// FIXME: for now, only allow static and private methods.\n\t\t\t\t// Could also allow final methods (but would require class hierarchy\n\t\t\t\t// search).\n\t\t\t\tif (!(method.isStatic() || method.isPrivate() || method.isFinal() || javaClass.isFinal() || !subtypes.hasSubtypes(javaClass)))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t// Ignore abstract and native methods\n\t\t\t\tif (method.getCode() == null) continue;\n\t\t\t\t\n\t\t\t\tBitSet bytecodeSet = classContext.getBytecodeSet(method);\n\t\t\t\t\n\t\t\t\tBoolean isUnconditionalThrower = cachedResults.get(xMethod);\n\t\t\t\tif (isUnconditionalThrower == null) {\n\t\t\t\t\tif (DEBUG) System.out.println(\"\\tChecking \" + xMethod);\n\t\t\t\t\tisUnconditionalThrower = !bytecodeSet.intersects(RETURN_OPCODE_SET);\n\t\t\t\t\tif (DEBUG && isUnconditionalThrower) {\n\t\t\t\t\t\tSystem.out.println(\"Return opcode set: \" + RETURN_OPCODE_SET);\n\t\t\t\t\t\tSystem.out.println(\"Code opcode set: \" + bytecodeSet);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcachedResults.put(xMethod, isUnconditionalThrower);\n\t\t\t\t}\n\t\t\t\tif (false && isUnconditionalThrower.booleanValue()) {\n\t\t\t\t    MethodGen calledMethodGen = classContext.getMethodGen(method);\n\t\t\t\t\t// Ignore abstract and native methods\n\n\t\t\t\t\tif (calledMethodGen == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// Analyze exception paths of called method\n\t\t\t\t\t// to see if it always throws an unhandled exception.\n\t\t\t\t\tCFG calledCFG = classContext.getCFG(method);\n\t\t\t\t\tReturnPathDataflow pathDataflow = classContext\n\t\t\t\t\t\t\t.getReturnPathDataflow(method);\n\t\t\t\t\tReturnPath pathValue = pathDataflow.getStartFact(calledCFG\n\t\t\t\t\t\t\t.getExit());\n\n\t\t\t\t\tisUnconditionalThrower = pathValue.getKind() != ReturnPath.RETURNS;\n\t\t\t\t\t// System.out.println(\"isThrower: \" + result + \" \" + method.getCode().getLength() + \" \" + method);\n\t\t\t\t\tif (true) cachedResults.put(xMethod, isUnconditionalThrower);\n\t\t\t\t}\n\n\t\t\t\tif (isUnconditionalThrower.booleanValue()) {\n\t\t\t\t\t// Method always throws an unhandled exception\n\t\t\t\t\t// Remove the normal control flow edge from the CFG.\n\t\t\t\t\tEdge fallThrough = cfg.getOutgoingEdgeWithType(basicBlock,\n\t\t\t\t\t\t\tFALL_THROUGH_EDGE);\n\t\t\t\t\tif (fallThrough != null) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"\\tREMOVING normal return for: \" + xMethod);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeletedEdgeSet.add(fallThrough);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tanalysisContext.getLookupFailureCallback().reportMissingClass(e);\n\t\t\t}\n\t\t}\n\n\t\t// Remove all edges marked for deletion\n\t\tfor (Edge edge : deletedEdgeSet) {\n\t\t\tcfg.removeEdge(edge);\n\t\t}\n\t}","commit_id":"ab988b8f0039fb05c2db8db180007ff0bd16173e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n  public TextRange processText(@NotNull PsiFile source, @NotNull TextRange rangeToReformat, @NotNull CodeStyleSettings settings) {\n    if (!(source instanceof PyFile)) {\n      return rangeToReformat;\n    }\n    final PsiWhiteSpace lastWhitespace = findLastWhitespace(source);\n    final TextRange oldWhitespaceRange = lastWhitespace != null ? lastWhitespace.getTextRange() : TextRange.from(source.getTextLength(), 0);\n    if (lastWhitespace != null && rangeToReformat.intersects(oldWhitespaceRange)) {\n      final PsiWhiteSpace newWhitespace = replaceOrDeleteTrailingWhitespace((PyFile)source, lastWhitespace);\n      final TextRange newWhitespaceRange;\n      if (newWhitespace != null) {\n        newWhitespaceRange = newWhitespace.getTextRange();\n      }\n      else {\n        newWhitespaceRange = TextRange.from(oldWhitespaceRange.getStartOffset(), 0);\n      }\n\n      final int delta = newWhitespaceRange.getLength() - oldWhitespaceRange.getLength();\n      if (newWhitespaceRange.contains(oldWhitespaceRange)) {\n        return newWhitespaceRange;\n      }\n      else if (rangeToReformat.contains(oldWhitespaceRange)) {\n        return rangeToReformat.grown(delta);\n      }\n      else if (oldWhitespaceRange.getEndOffset() > rangeToReformat.getEndOffset()) {\n        return new TextRange(rangeToReformat.getStartOffset(),\n                             Math.min(rangeToReformat.getEndOffset(), newWhitespaceRange.getEndOffset()));\n      }\n      else if (oldWhitespaceRange.getStartOffset() < rangeToReformat.getStartOffset()) {\n        final int unionLength = rangeToReformat.getEndOffset() - oldWhitespaceRange.getStartOffset();\n        return TextRange.from(Math.max(oldWhitespaceRange.getStartOffset(), rangeToReformat.getStartOffset() + delta),\n                              Math.min(rangeToReformat.getLength(), unionLength + delta));\n      }\n    }\n    return rangeToReformat;\n  }","id":45581,"modified_method":"@Override\n  public TextRange processText(@NotNull PsiFile source, @NotNull TextRange rangeToReformat, @NotNull CodeStyleSettings settings) {\n    if (!(source instanceof PyFile)) {\n      return rangeToReformat;\n    }\n    final Couple<PsiWhiteSpace> range = findTrailingWhitespaces(source);\n    final TextRange oldWhitespaceRange;\n    oldWhitespaceRange = range != null ? unionRange(range) : TextRange.from(source.getTextLength(), 0);\n    if (rangeToReformat.intersects(oldWhitespaceRange)) {\n      final TextRange newWhitespaceRange = replaceOrDeleteTrailingWhitespaces((PyFile)source, range);;\n      final int delta = newWhitespaceRange.getLength() - oldWhitespaceRange.getLength();\n      if (newWhitespaceRange.contains(oldWhitespaceRange)) {\n        return newWhitespaceRange;\n      }\n      else if (rangeToReformat.contains(oldWhitespaceRange)) {\n        return rangeToReformat.grown(delta);\n      }\n      else if (oldWhitespaceRange.getEndOffset() > rangeToReformat.getEndOffset()) {\n        return new TextRange(rangeToReformat.getStartOffset(),\n                             Math.min(rangeToReformat.getEndOffset(), newWhitespaceRange.getEndOffset()));\n      }\n      else if (oldWhitespaceRange.getStartOffset() < rangeToReformat.getStartOffset()) {\n        final int unionLength = rangeToReformat.getEndOffset() - oldWhitespaceRange.getStartOffset();\n        return TextRange.from(Math.max(oldWhitespaceRange.getStartOffset(), rangeToReformat.getStartOffset() + delta),\n                              Math.min(rangeToReformat.getLength(), unionLength + delta));\n      }\n    }\n    return rangeToReformat;\n  }","commit_id":"aa43e476c22ea53eecaff67987662b8f8cda9ba3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiWhiteSpace findLastWhitespace(@NotNull PsiFile file) {\n    // TODO support ranges of whitespaces with backslashes between them\n    return as(PsiTreeUtil.lastChild(file), PsiWhiteSpace.class);\n  }","id":45582,"modified_method":"@Nullable\n  private static Couple<PsiWhiteSpace> findTrailingWhitespaces(@NotNull PsiFile file) {\n    final PsiWhiteSpace lastWhitespace = as(PsiTreeUtil.lastChild(file), PsiWhiteSpace.class);\n    if (lastWhitespace == null) {\n      return null;\n    }\n    PsiWhiteSpace firstWhitespace = lastWhitespace;\n    for (PsiElement prev = lastWhitespace.getPrevSibling(); prev instanceof PsiWhiteSpace; prev = prev.getPrevSibling()) {\n      firstWhitespace = (PsiWhiteSpace)prev;\n    }\n    return Couple.of(firstWhitespace, lastWhitespace);\n  }","commit_id":"aa43e476c22ea53eecaff67987662b8f8cda9ba3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiWhiteSpace replaceOrDeleteTrailingWhitespace(@NotNull final PyFile pyFile, @Nullable final PsiWhiteSpace whitespace) {\n    final Project project = pyFile.getProject();\n    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    final Document document = documentManager.getDocument(pyFile);\n    if (document != null) {\n      documentManager.doPostponedOperationsAndUnblockDocument(document);\n      final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n      int numLineFeedsAtEnd = CodeStyleSettingsManager.getSettings(project).getCustomSettings(PyCodeStyleSettings.class).NEW_LINE_AT_FILE_END;\n      if (numLineFeedsAtEnd <= 0 && EditorSettingsExternalizable.getInstance().isEnsureNewLineAtEOF()) {\n        numLineFeedsAtEnd = 1;\n      }\n      if (numLineFeedsAtEnd > 0) {\n        final PyElementGenerator generator = PyElementGenerator.getInstance(project);\n        final String text = StringUtil.repeat(\"\\n\", numLineFeedsAtEnd);\n        final LanguageLevel language = LanguageLevel.forElement(pyFile);\n        final PsiWhiteSpace lineFeeds = generator.createFromText(language, PsiWhiteSpace.class, \"(\" + text + \")\", new int[]{0, 0, 1});\n        codeStyleManager.performActionWithFormatterDisabled(new Computable<PsiWhiteSpace>() {\n          @Override\n          public PsiWhiteSpace compute() {\n            if (whitespace != null) {\n              return (PsiWhiteSpace)whitespace.replace(lineFeeds);\n            }\n            else {\n              return (PsiWhiteSpace)pyFile.add(lineFeeds);\n            }\n          }\n        });\n      }\n      else if (whitespace != null) {\n        codeStyleManager.performActionWithFormatterDisabled(new Runnable() {\n          @Override\n          public void run() {\n            whitespace.delete();\n          }\n        });\n        return null;\n      }\n    }\n    return whitespace;\n  }","id":45583,"modified_method":"@NotNull\n  private static TextRange replaceOrDeleteTrailingWhitespaces(@NotNull final PyFile pyFile,\n                                                              @Nullable final Couple<PsiWhiteSpace> whitespaces) {\n    final Project project = pyFile.getProject();\n    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    final Document document = documentManager.getDocument(pyFile);\n    if (document != null) {\n      final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n      int numLineFeedsAtEnd = CodeStyleSettingsManager.getSettings(project).getCustomSettings(PyCodeStyleSettings.class).NEW_LINE_AT_FILE_END;\n      if (numLineFeedsAtEnd <= 0 && EditorSettingsExternalizable.getInstance().isEnsureNewLineAtEOF()) {\n        numLineFeedsAtEnd = 1;\n      }\n      if (numLineFeedsAtEnd > 0) {\n        documentManager.doPostponedOperationsAndUnblockDocument(document);\n        final PyElementGenerator generator = PyElementGenerator.getInstance(project);\n        final String text = StringUtil.repeat(\"\\n\", numLineFeedsAtEnd);\n        final LanguageLevel language = LanguageLevel.forElement(pyFile);\n        // Wrapping whitespaces in parenthesis guarantees that they won't be splitted in several PSI element\n        // (while Python's formatter operates this awkward way)\n        final PsiWhiteSpace lineFeeds = generator.createFromText(language, PsiWhiteSpace.class, \"(\" + text + \")\", new int[]{0, 0, 1});\n        return codeStyleManager.performActionWithFormatterDisabled(new Computable<TextRange>() {\n          @Override\n          public TextRange compute() {\n            if (whitespaces != null) {\n              return replaceOrDeletePsiRange(whitespaces, lineFeeds).getTextRange();\n            }\n            else {\n              return pyFile.add(lineFeeds).getTextRange();\n            }\n          }\n        });\n      }\n      else if (whitespaces != null) {\n        return codeStyleManager.performActionWithFormatterDisabled(new Computable<TextRange>() {\n          @Override\n          public TextRange compute() {\n            replaceOrDeletePsiRange(whitespaces, null);\n            return TextRange.from(pyFile.getTextLength(), 0);\n          }\n        });\n      }\n    }\n    return whitespaces == null ? TextRange.from(pyFile.getTextLength(), 0) : unionRange(whitespaces);\n  }","commit_id":"aa43e476c22ea53eecaff67987662b8f8cda9ba3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement processElement(@NotNull PsiElement source, @NotNull CodeStyleSettings settings) {\n    if (source instanceof PyFile) {\n      final PyFile pyFile = (PyFile)source;\n      final PsiWhiteSpace lastWhitespace = findLastWhitespace(pyFile);\n      if (lastWhitespace != null && PsiTreeUtil.isAncestor(source, lastWhitespace, false)) {\n        replaceOrDeleteTrailingWhitespace(pyFile, lastWhitespace);\n      }\n    }\n    return source;\n  }","id":45584,"modified_method":"@Override\n  public PsiElement processElement(@NotNull PsiElement source, @NotNull CodeStyleSettings settings) {\n    if (source instanceof PyFile) {\n      final PyFile pyFile = (PyFile)source;\n      final Couple<PsiWhiteSpace> range = findTrailingWhitespaces(pyFile);\n      if (range != null && PsiTreeUtil.isAncestor(source, range.getFirst(), false)) {\n        replaceOrDeleteTrailingWhitespaces(pyFile, range);\n      }\n    }\n    return source;\n  }","commit_id":"aa43e476c22ea53eecaff67987662b8f8cda9ba3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LWComponent duplicate()\n    {\n        LWContainer containerCopy = (LWContainer) super.duplicate();\n        \n        Iterator i = getChildIterator();\n        while (i.hasNext()) {\n            LWComponent c = (LWComponent) i.next();\n            LWComponent childCopy = c.duplicate();\n            containerCopy.children.add(childCopy);\n            childCopy.setParent(containerCopy);\n        }\n        return containerCopy;\n    }","id":45585,"modified_method":"/**\n     * Be sure to duplicate all children and set parent/child references,\n     * and if we weren't given a LinkPatcher, to patch up any links\n     * among our children.\n     */\n    public LWComponent duplicate(LinkPatcher linkPatcher)\n    {\n        boolean isPatcherOwner = false;\n        \n        if (linkPatcher == null && hasChildren()) {\n\n            // Normally VUE Actions (e.g. Duplicate, Copy, Paste)\n            // provide a patcher for duplicating a selection of\n            // objects, but anyone else may not have provided one.\n            // This will take care of arbitrary single instances of\n            // duplication, including duplicating an entire Map.\n            \n            linkPatcher = new LinkPatcher();\n            isPatcherOwner = true;\n        }\n        \n        LWContainer containerCopy = (LWContainer) super.duplicate(linkPatcher);\n        \n        Iterator i = getChildIterator();\n        while (i.hasNext()) {\n            LWComponent c = (LWComponent) i.next();\n            LWComponent childCopy = c.duplicate(linkPatcher);\n            containerCopy.children.add(childCopy);\n            childCopy.setParent(containerCopy);\n        }\n\n        if (isPatcherOwner)\n            linkPatcher.reconnectLinks();\n            \n        return containerCopy;\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"public void drawChildren(DrawContext dc)\n    {\n        int nodes = 0;\n        int links = 0;\n        int images = 0;\n        \n        if (this.children.size() > 0) {\n\n            Rectangle clipBounds = dc.g.getClipBounds();\n\n            // fudge clip bounds to deal with anti-aliasing\n            // edges that are being missed.\n            // TODO: so this is growing every time we descend into\n            // a container?  We only want to do this at the LWMap level...\n            clipBounds.grow(1,1);\n            \n            /*if (false) {\n                System.out.println(\"DRAWING \" + this);\n                System.out.println(\"clipBounds=\"+clipBounds);\n                System.out.println(\"      mvrr=\"+MapViewer.RepaintRegion);\n                }*/\n                \n            LWComponent focused = null;\n            java.util.Iterator i = getChildIterator();\n            while (i.hasNext()) {\n                LWComponent c = (LWComponent) i.next();\n\n                // make sure the rollover is painted on top\n                // a bit of a hack to do this here -- better MapViewer\n                //if (c.isRollover() && c.getParent() instanceof LWNode) {\n                if (c.isZoomedFocus()) {\n                    focused = c;\n                    continue;\n                }\n                \n                //-------------------------------------------------------\n                // This is a huge speed optimzation.  Eliminating all\n                // the Graphics2D calls that would end up having to\n                // check the clipBounds internally makes a giant\n                // difference.\n                // -------------------------------------------------------\n                \n                // if filtered, don't draw, unless has children, in which case\n                // we need to draw just in case any of the children are NOT filtered.\n                if (c.isVisible() && (!c.isFiltered() || c.hasChildren()) && c.intersects(clipBounds)) {\n                    _drawChild(dc, c);\n                    if (DEBUG.PAINT) {\n                             if (c instanceof LWLink) links++;\n                        else if (c instanceof LWNode) nodes++;\n                        else if (c instanceof LWImage) images++;\n                    }\n                }\n            }\n\n            if (focused != null) {\n                setFocusComponent(focused);\n                _drawChild(dc, focused);\n            } else\n                setFocusComponent(null);\n                \n            if (DEBUG.PAINT) \n                out(this + \" painted \" + links + \" links, \" + nodes + \" nodes, \" + images + \" images\");\n        }\n        /*\n        if (DEBUG.CONTAINMENT) {\n            dc.g.setColor(java.awt.Color.green);\n            dc.g.setStroke(STROKE_ONE);\n            dc.g.draw(getBounds());\n        }\n        */\n    }","id":45586,"modified_method":"public void drawChildren(DrawContext dc)\n    {\n        int nodes = 0;\n        int links = 0;\n        int images = 0;\n        \n        if (this.children.size() > 0) {\n\n            Rectangle clipBounds = dc.g.getClipBounds();\n\n            // fudge clip bounds to deal with anti-aliasing\n            // edges that are being missed.\n            // TODO: so this is growing every time we descend into\n            // a container?  We only want to do this at the LWMap level...\n            if (clipBounds != null)\n                clipBounds.grow(1,1);\n            \n            /*if (false) {\n                System.out.println(\"DRAWING \" + this);\n                System.out.println(\"clipBounds=\"+clipBounds);\n                System.out.println(\"      mvrr=\"+MapViewer.RepaintRegion);\n                }*/\n                \n            LWComponent focused = null;\n            java.util.Iterator i = getChildIterator();\n            while (i.hasNext()) {\n                LWComponent c = (LWComponent) i.next();\n\n                // make sure the rollover is painted on top\n                // a bit of a hack to do this here -- better MapViewer\n                //if (c.isRollover() && c.getParent() instanceof LWNode) {\n                if (c.isZoomedFocus()) {\n                    focused = c;\n                    continue;\n                }\n                \n                //-------------------------------------------------------\n                // This is a huge speed optimzation.  Eliminating all\n                // the Graphics2D calls that would end up having to\n                // check the clipBounds internally makes a giant\n                // difference.\n                // -------------------------------------------------------\n                \n                // if filtered, don't draw, unless has children, in which case\n                // we need to draw just in case any of the children are NOT filtered.\n                if (c.isVisible()\n                    && (!c.isFiltered() || c.hasChildren())\n                    && (clipBounds == null || c.intersects(clipBounds)))\n                {\n                    _drawChild(dc, c);\n                    if (DEBUG.PAINT) {\n                             if (c instanceof LWLink) links++;\n                        else if (c instanceof LWNode) nodes++;\n                        else if (c instanceof LWImage) images++;\n                    }\n                }\n            }\n\n            if (focused != null) {\n                setFocusComponent(focused);\n                _drawChild(dc, focused);\n            } else\n                setFocusComponent(null);\n                \n            if (DEBUG.PAINT) \n                out(this + \" painted \" + links + \" links, \" + nodes + \" nodes, \" + images + \" images\");\n        }\n        /*\n        if (DEBUG.CONTAINMENT) {\n            dc.g.setColor(java.awt.Color.green);\n            dc.g.setStroke(STROKE_ONE);\n            dc.g.draw(getBounds());\n        }\n        */\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"private void _drawChild(DrawContext _dc, LWComponent c)\n    {\n        // todo opt: don't create all these GC's?\n        // todo: if selection going to draw in map, consolodate it here!\n        // todo: same goes for pathway decorations!\n        DrawContext dc = _dc.create();\n        try {\n            if (c.doesRelativeDrawing())\n                dc.g.translate(c.getX(), c.getY());\n            drawChild(c, dc);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"*** Exception drawing: \" + c);\n            System.err.println(\"***         In parent: \" + this);\n            System.err.println(\"***    Graphics-start: \" + _dc.g);\n            System.err.println(\"***      Graphics-end: \" + dc.g);\n            System.err.println(\"***   Transform-start: \" + _dc.g.getTransform());\n            System.err.println(\"***     Transform-end: \" + dc.g.getTransform());\n        } finally {\n            dc.g.dispose();\n        }\n    }","id":45587,"modified_method":"private void _drawChild(DrawContext _dc, LWComponent c)\n    {\n        // todo opt: don't create all these GC's?\n        // todo: if selection going to draw in map, consolodate it here!\n        // todo: same goes for pathway decorations!\n        DrawContext dc = _dc.create();\n        try {\n            if (c.doesRelativeDrawing())\n                dc.g.translate(c.getX(), c.getY());\n            drawChild(c, dc);\n        } catch (Throwable t) {\n            synchronized (System.err) {\n                tufts.Util.printStackTrace(t);\n                System.err.println(\"*** Exception drawing: \" + c);\n                System.err.println(\"***         In parent: \" + this);\n                System.err.println(\"***    Graphics-start: \" + _dc.g);\n                System.err.println(\"***      Graphics-end: \" + dc.g);\n                System.err.println(\"***   Transform-start: \" + _dc.g.getTransform());\n                System.err.println(\"***     Transform-end: \" + dc.g.getTransform());\n                System.err.println(\"***              clip: \" + dc.g.getClip());\n                System.err.println(\"***        clipBounds: \" + dc.g.getClipBounds());\n            }\n        } finally {\n            dc.g.dispose();\n        }\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Delete a child and PERMANENTLY remove it from the model.\n     * Differs from removeChild / removeChildren, which just\n     * de-parent the nodes, tho leave any listeners & links to it in place.\n     */\n    public void deleteChildPermanently(LWComponent c)\n    {\n        if (true||DEBUG.PARENTING) System.out.println(\"[\"+getLabel() + \"] DELETING PERMANENTLY \" + c);\n\n        // We did the \"deleting\" notification first, so anybody\n        // listening can still see the node in it's full current state\n        // before anything changes.  But children now keep their\n        // parent reference until their removed from the model, so the\n        // only thing different when removeFromModel issues it's\n        // LWKey.Deleting event is the parent won't list it as a\n        // child, but since it still has the parent ref, event\n        // up-notification will still work, which is good enough.\n        // (It's probably not safe to deliver more than one\n        // LWKey.Deleting event -- if need to put it back here, have\n        // to be able to tell removeFromModel optionally not to issue\n        // the event).\n\n        //c.notify(LWKey.Deleting);\n        \n        removeChild(c);\n        c.removeFromModel();\n    }","id":45588,"modified_method":"/**\n     * Delete a child and PERMANENTLY remove it from the model.\n     * Differs from removeChild / removeChildren, which just\n     * de-parent the nodes, tho leave any listeners & links to it in place.\n     */\n    public void deleteChildPermanently(LWComponent c)\n    {\n        if (DEBUG.UNDO || DEBUG.PARENTING) System.out.println(\"[\"+getLabel() + \"] DELETING PERMANENTLY \" + c);\n\n        // We did the \"deleting\" notification first, so anybody listening can still see\n        // the node in it's full current state before anything changes.  But children\n        // now keep their parent reference until their removed from the model, so the\n        // only thing different when removeFromModel issues it's LWKey.Deleting event is\n        // the parent won't list it as a child, but since it still has the parent ref,\n        // event up-notification will still work, which is good enough.  (It's probably\n        // not safe to deliver more than one LWKey.Deleting event -- if need to put it\n        // back here, have to be able to tell removeFromModel optionally not to issue\n        // the event).\n\n        //c.notify(LWKey.Deleting);\n        \n        removeChild(c);\n        c.removeFromModel();\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean isEmpty() {\n        return !hasChildren();\n    }","id":45589,"modified_method":"public boolean isEmpty() {\n        return children == null || children.size() < 1;\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * @param possibleChildren should contain at least one child of this container\n     * to be reparented.  Children not in this container are ignored.\n     * @param newParent is the new parent for any children of ours found in possibleChildren\n     */\n    public void reparentTo(LWContainer newParent, Iterator possibleChildren)\n    {\n        notify(LWKey.HierarchyChanging);\n\n        List reparenting = new ArrayList();\n        while (possibleChildren.hasNext()) {\n            LWComponent c = (LWComponent) possibleChildren.next();\n            if (c.getParent() == this)\n                reparenting.add(c);\n        }\n        removeChildren(reparenting.iterator());\n        newParent.addChildren(reparenting.iterator());\n    }","id":45590,"modified_method":"/**\n     * @param possibleChildren should contain at least one child of this container\n     * to be reparented.  Children not in this container are ignored.\n     * @param newParent is the new parent for any children of ours found in possibleChildren\n     */\n    public void reparentTo(LWContainer newParent, Iterator possibleChildren)\n    {\n        notify(LWKey.HierarchyChanging);\n\n        List reparenting = new ArrayList();\n        while (possibleChildren.hasNext()) {\n            LWComponent c = (LWComponent) possibleChildren.next();\n            if (c.getParent() == this)\n                reparenting.add(c);\n        }\n        removeChildren(reparenting.iterator());\n        newParent.addChildren(reparenting);\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Make sure this LWComponent has an ID -- will have an effect on\n     * on any brand new LWComponent exactly once per VM instance.\n     */\n    private void ensureID(LWComponent c)\n    {\n        if (c.getID() == null)\n            c.setID(getNextUniqueID());\n\n        if (c instanceof LWContainer) {\n            Iterator i = ((LWContainer)c).getChildIterator();\n            while (i.hasNext())\n                ensureID((LWComponent) i.next());\n        }\n    }","id":45591,"modified_method":"/**\n     * Make sure this LWComponent has an ID -- will have an effect on\n     * on any brand new LWComponent exactly once per VM instance.\n     */\n    private void ensureID(LWComponent c)\n    {\n        if (c.getID() == null) {\n            String id = getNextUniqueID();\n            // no ID may be available if we're an orphan: it will be\n            // patched up when we eventually get added to to a map\n            if (id != null)\n                c.setID(id);\n        }\n\n        if (c instanceof LWContainer) {\n            Iterator i = ((LWContainer)c).getChildIterator();\n            while (i.hasNext())\n                ensureID((LWComponent) i.next());\n        }\n    }","commit_id":"3cc8a6a897f39b690bd5a3cecda95d287bca5619","url":"https://github.com/VUE/VUE"},{"original_method":"protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\", extras);\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertTrue(app.getChildren().iterator().hasNext(), \"Expected app to have child entity\");\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        \n        return (TestEntity)entity;\n    }","id":45592,"modified_method":"protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\", extras));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertTrue(app.getChildren().iterator().hasNext(), \"Expected app to have child entity\");\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        \n        return (TestEntity)entity;\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testPropogateChildSensor() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",\n                    \"  brooklyn.config:\",\n                    \"    test.confName: parent entity\",\n                    \"  id: parentId\",\n                    \"  brooklyn.enrichers:\",\n                    \"  - enricherType: brooklyn.enricher.basic.Propagator\",\n                    \"    brooklyn.config:\",\n                    \"      enricher.producer: $brooklyn:component(\\\"childId\\\")\",\n                    \"      enricher.propagating.propagatingAll: true\",\n                    \"  brooklyn.children:\",\n                    \"  - serviceType: brooklyn.test.entity.TestEntity\",\n                    \"    id: childId\",\n                    \"    brooklyn.config:\",\n                    \"      test.confName: Child Name\");\n        waitForApplicationTasks(app);\n        \n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        final Entity parentEntity = app.getChildren().iterator().next();\n        Assert.assertTrue(parentEntity instanceof TestEntity, \"Expected parent entity to be TestEntity, found:\" + parentEntity);\n        Assert.assertEquals(parentEntity.getChildren().size(), 1);\n        Entity childEntity = parentEntity.getChildren().iterator().next();\n        Assert.assertTrue(childEntity instanceof TestEntity, \"Expected child entity to be TestEntity, found:\" + childEntity);\n        Asserts.eventually(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                return parentEntity.getEnrichers().size();\n            }\n        }, Predicates.<Integer>equalTo(1));\n        Enricher enricher = parentEntity.getEnrichers().iterator().next();\n        Asserts.assertTrue(enricher instanceof Propagator, \"Expected enricher to be Propagator, found:\" + enricher);\n        final Propagator propagator = (Propagator)enricher;\n        Entity producer = ((EntityInternal)parentEntity).getExecutionContext().submit(MutableMap.of(), new Callable<Entity>() {\n            public Entity call() {\n                return propagator.getConfig(Propagator.PRODUCER);\n            }}).get();\n        Assert.assertEquals(producer, childEntity);\n        Asserts.assertTrue(Boolean.valueOf(propagator.getConfig(Propagator.PROPAGATING_ALL)), \"Expected Propagator.PROPAGATING_ALL to be true\");\n        ((TestEntity)childEntity).setAttribute(TestEntity.NAME, \"New Name\");\n        Asserts.eventually(Entities.attributeSupplier(parentEntity, TestEntity.NAME), Predicates.<String>equalTo(\"New Name\"));\n    }","id":45593,"modified_method":"@Test\n    public void testPropogateChildSensor() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",\n                    \"  brooklyn.config:\",\n                    \"    test.confName: parent entity\",\n                    \"  id: parentId\",\n                    \"  brooklyn.enrichers:\",\n                    \"  - enricherType: brooklyn.enricher.basic.Propagator\",\n                    \"    brooklyn.config:\",\n                    \"      enricher.producer: $brooklyn:component(\\\"childId\\\")\",\n                    \"      enricher.propagating.propagatingAll: true\",\n                    \"  brooklyn.children:\",\n                    \"  - serviceType: brooklyn.test.entity.TestEntity\",\n                    \"    id: childId\",\n                    \"    brooklyn.config:\",\n                    \"      test.confName: Child Name\"));\n        waitForApplicationTasks(app);\n        \n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        final Entity parentEntity = app.getChildren().iterator().next();\n        Assert.assertTrue(parentEntity instanceof TestEntity, \"Expected parent entity to be TestEntity, found:\" + parentEntity);\n        Assert.assertEquals(parentEntity.getChildren().size(), 1);\n        Entity childEntity = parentEntity.getChildren().iterator().next();\n        Assert.assertTrue(childEntity instanceof TestEntity, \"Expected child entity to be TestEntity, found:\" + childEntity);\n        Asserts.eventually(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                return parentEntity.getEnrichers().size();\n            }\n        }, Predicates.<Integer>equalTo(1));\n        Enricher enricher = parentEntity.getEnrichers().iterator().next();\n        Asserts.assertTrue(enricher instanceof Propagator, \"Expected enricher to be Propagator, found:\" + enricher);\n        final Propagator propagator = (Propagator)enricher;\n        Entity producer = ((EntityInternal)parentEntity).getExecutionContext().submit(MutableMap.of(), new Callable<Entity>() {\n            public Entity call() {\n                return propagator.getConfig(Propagator.PRODUCER);\n            }}).get();\n        Assert.assertEquals(producer, childEntity);\n        Asserts.assertTrue(Boolean.valueOf(propagator.getConfig(Propagator.PROPAGATING_ALL)), \"Expected Propagator.PROPAGATING_ALL to be true\");\n        ((TestEntity)childEntity).setAttribute(TestEntity.NAME, \"New Name\");\n        Asserts.eventually(Entities.attributeSupplier(parentEntity, TestEntity.NAME), Predicates.<String>equalTo(\"New Name\"));\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithAppEnricher() throws Exception {\n        Entity app = createAndStartApplication(\"test-app-with-enricher.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-app-with-enricher\");\n        \n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertEquals(app.getEnrichers().size(), 1);\n        final Enricher enricher = app.getEnrichers().iterator().next();\n        Assert.assertTrue(enricher instanceof TestEnricher, \"enricher=\"+enricher);\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        \n        Entity target = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Entity>() {\n            public Entity call() {\n                return enricher.getConfig(TestEnricher.TARGET_ENTITY);\n            }}).get();\n        Assert.assertNotNull(target);\n        Assert.assertEquals(target.getDisplayName(), \"testentity\");\n        Assert.assertEquals(target, app.getChildren().iterator().next());\n        Entity targetFromFlag = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Entity>() {\n            public Entity call() {\n                return enricher.getConfig(TestEnricher.TARGET_ENTITY_FROM_FLAG);\n            }}).get();\n        Assert.assertEquals(targetFromFlag, target);\n        Map<?, ?> leftoverProperties = ((TestEnricher) enricher).getLeftoverProperties();\n        Assert.assertEquals(leftoverProperties.get(\"enricherLiteralValue1\"), \"Hello\");\n        Assert.assertEquals(leftoverProperties.get(\"enricherLiteralValue2\"), \"World\");\n        Assert.assertEquals(leftoverProperties.size(), 2);\n    }","id":45594,"modified_method":"@Test\n    public void testWithAppEnricher() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-app-with-enricher.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-app-with-enricher\");\n        \n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertEquals(app.getEnrichers().size(), 1);\n        final Enricher enricher = app.getEnrichers().iterator().next();\n        Assert.assertTrue(enricher instanceof TestEnricher, \"enricher=\"+enricher);\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        \n        Entity target = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Entity>() {\n            public Entity call() {\n                return enricher.getConfig(TestEnricher.TARGET_ENTITY);\n            }}).get();\n        Assert.assertNotNull(target);\n        Assert.assertEquals(target.getDisplayName(), \"testentity\");\n        Assert.assertEquals(target, app.getChildren().iterator().next());\n        Entity targetFromFlag = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Entity>() {\n            public Entity call() {\n                return enricher.getConfig(TestEnricher.TARGET_ENTITY_FROM_FLAG);\n            }}).get();\n        Assert.assertEquals(targetFromFlag, target);\n        Map<?, ?> leftoverProperties = ((TestEnricher) enricher).getLeftoverProperties();\n        Assert.assertEquals(leftoverProperties.get(\"enricherLiteralValue1\"), \"Hello\");\n        Assert.assertEquals(leftoverProperties.get(\"enricherLiteralValue2\"), \"World\");\n        Assert.assertEquals(leftoverProperties.size(), 2);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testPropagatingEnricher() throws Exception {\n        Entity app = createAndStartApplication(\"test-propagating-enricher.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-propagating-enricher\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        TestEntity entity = (TestEntity)app.getChildren().iterator().next();\n        entity.setAttribute(TestEntity.NAME, \"New Name\");\n        Asserts.eventually(Entities.attributeSupplier(app, TestEntity.NAME), Predicates.<String>equalTo(\"New Name\"));\n    }","id":45595,"modified_method":"@Test\n    public void testPropagatingEnricher() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-propagating-enricher.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-propagating-enricher\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        TestEntity entity = (TestEntity)app.getChildren().iterator().next();\n        entity.setAttribute(TestEntity.NAME, \"New Name\");\n        Asserts.eventually(Entities.attributeSupplier(app, TestEntity.NAME), Predicates.<String>equalTo(\"New Name\"));\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testMultipleEnricherReferences() throws Exception {\n        final Entity app = createAndStartApplication(\"test-referencing-enrichers.yaml\");\n        waitForApplicationTasks(app);\n        \n        Entity entity1 = null, entity2 = null, child1 = null, child2 = null, grandchild1 = null, grandchild2 = null;\n        \n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity child : app.getChildren()) {\n            if (child.getDisplayName().equals(\"entity 1\"))\n                entity1 = child;\n            if (child.getDisplayName().equals(\"entity 2\"))\n                entity2 = child;\n        }\n        Assert.assertNotNull(entity1);\n        Assert.assertNotNull(entity2);\n        \n        Assert.assertEquals(entity1.getChildren().size(), 2);\n        for (Entity child : entity1.getChildren()) {\n            if (child.getDisplayName().equals(\"child 1\"))\n                child1 = child;\n            if (child.getDisplayName().equals(\"child 2\"))\n                child2 = child;\n        }\n        Assert.assertNotNull(child1);\n        Assert.assertNotNull(child2);\n        \n        Assert.assertEquals(child1.getChildren().size(), 2);\n        for (Entity child : child1.getChildren()) {\n            if (child.getDisplayName().equals(\"grandchild 1\"))\n               grandchild1 = child;\n            if (child.getDisplayName().equals(\"grandchild 2\"))\n                grandchild2 = child;\n        }\n        Assert.assertNotNull(grandchild1);\n        Assert.assertNotNull(grandchild2);\n        \n        ImmutableSet<Enricher> enrichers = new ImmutableSet.Builder<Enricher>()\n                .add(getEnricher(app))\n                .add(getEnricher(entity1))\n                .add(getEnricher(entity2))\n                .add(getEnricher(child1))\n                .add(getEnricher(child2))\n                .add(getEnricher(grandchild1))\n                .add(getEnricher(grandchild2))\n                .build();\n        \n        Map<ConfigKey<Entity>, Entity> keyToEntity = new ImmutableMap.Builder<ConfigKey<Entity>, Entity>()\n                .put(TestReferencingEnricher.TEST_APPLICATION, app)\n                .put(TestReferencingEnricher.TEST_ENTITY_1, entity1)\n                .put(TestReferencingEnricher.TEST_ENTITY_2, entity2)\n                .put(TestReferencingEnricher.TEST_CHILD_1, child1)\n                .put(TestReferencingEnricher.TEST_CHILD_2, child2)\n                .put(TestReferencingEnricher.TEST_GRANDCHILD_1, grandchild1)\n                .put(TestReferencingEnricher.TEST_GRANDCHILD_2, grandchild2)\n                .build();\n        \n        for (Enricher enricher : enrichers)\n            checkReferences(enricher, keyToEntity);\n    }","id":45596,"modified_method":"@Test\n    public void testMultipleEnricherReferences() throws Exception {\n        final Entity app = createAndStartApplication(loadYaml(\"test-referencing-enrichers.yaml\"));\n        waitForApplicationTasks(app);\n        \n        Entity entity1 = null, entity2 = null, child1 = null, child2 = null, grandchild1 = null, grandchild2 = null;\n        \n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity child : app.getChildren()) {\n            if (child.getDisplayName().equals(\"entity 1\"))\n                entity1 = child;\n            if (child.getDisplayName().equals(\"entity 2\"))\n                entity2 = child;\n        }\n        Assert.assertNotNull(entity1);\n        Assert.assertNotNull(entity2);\n        \n        Assert.assertEquals(entity1.getChildren().size(), 2);\n        for (Entity child : entity1.getChildren()) {\n            if (child.getDisplayName().equals(\"child 1\"))\n                child1 = child;\n            if (child.getDisplayName().equals(\"child 2\"))\n                child2 = child;\n        }\n        Assert.assertNotNull(child1);\n        Assert.assertNotNull(child2);\n        \n        Assert.assertEquals(child1.getChildren().size(), 2);\n        for (Entity child : child1.getChildren()) {\n            if (child.getDisplayName().equals(\"grandchild 1\"))\n               grandchild1 = child;\n            if (child.getDisplayName().equals(\"grandchild 2\"))\n                grandchild2 = child;\n        }\n        Assert.assertNotNull(grandchild1);\n        Assert.assertNotNull(grandchild2);\n        \n        ImmutableSet<Enricher> enrichers = new ImmutableSet.Builder<Enricher>()\n                .add(getEnricher(app))\n                .add(getEnricher(entity1))\n                .add(getEnricher(entity2))\n                .add(getEnricher(child1))\n                .add(getEnricher(child2))\n                .add(getEnricher(grandchild1))\n                .add(getEnricher(grandchild2))\n                .build();\n        \n        Map<ConfigKey<Entity>, Entity> keyToEntity = new ImmutableMap.Builder<ConfigKey<Entity>, Entity>()\n                .put(TestReferencingEnricher.TEST_APPLICATION, app)\n                .put(TestReferencingEnricher.TEST_ENTITY_1, entity1)\n                .put(TestReferencingEnricher.TEST_ENTITY_2, entity2)\n                .put(TestReferencingEnricher.TEST_CHILD_1, child1)\n                .put(TestReferencingEnricher.TEST_CHILD_2, child2)\n                .put(TestReferencingEnricher.TEST_GRANDCHILD_1, grandchild1)\n                .put(TestReferencingEnricher.TEST_GRANDCHILD_2, grandchild2)\n                .build();\n        \n        for (Enricher enricher : enrichers)\n            checkReferences(enricher, keyToEntity);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithEntityEnricher() throws Exception {\n        final Entity app = createAndStartApplication(\"test-entity-with-enricher.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-with-enricher\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Assert.assertEquals(app.getEnrichers().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        final Entity child = app.getChildren().iterator().next();\n        Asserts.eventually(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                return child.getEnrichers().size();\n            }\n        }, Predicates.<Integer> equalTo(1));        \n        final Enricher enricher = child.getEnrichers().iterator().next();\n        Assert.assertNotNull(enricher);\n        Assert.assertTrue(enricher instanceof TestEnricher, \"enricher=\" + enricher + \"; type=\" + enricher.getClass());\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        \n        Assert.assertEquals(((TestEnricher) enricher).getLeftoverProperties(),\n                ImmutableMap.of(\"enricherLiteralValue1\", \"Hello\", \"enricherLiteralValue2\", \"World\"));\n    }","id":45597,"modified_method":"@Test\n    public void testWithEntityEnricher() throws Exception {\n        final Entity app = createAndStartApplication(loadYaml(\"test-entity-with-enricher.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-with-enricher\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Assert.assertEquals(app.getEnrichers().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        final Entity child = app.getChildren().iterator().next();\n        Asserts.eventually(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                return child.getEnrichers().size();\n            }\n        }, Predicates.<Integer> equalTo(1));        \n        final Enricher enricher = child.getEnrichers().iterator().next();\n        Assert.assertNotNull(enricher);\n        Assert.assertTrue(enricher instanceof TestEnricher, \"enricher=\" + enricher + \"; type=\" + enricher.getClass());\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(enricher.getConfig(TestEnricher.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        \n        Assert.assertEquals(((TestEnricher) enricher).getLeftoverProperties(),\n                ImmutableMap.of(\"enricherLiteralValue1\", \"Hello\", \"enricherLiteralValue2\", \"World\"));\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\")\n    public void testStartTomcatCluster() throws Exception {\n        Entity app = createAndStartApplication(\"test-tomcat-cluster.yaml\");\n        waitForApplicationTasks(app);\n\n        assertNotNull(app);\n        assertEquals(app.getChildren().size(), 1);\n        final Entity entity = Iterables.getOnlyElement(app.getChildren());\n        assertTrue(entity instanceof ControlledDynamicWebAppCluster, \"entity=\"+entity);\n        ControlledDynamicWebAppCluster cluster = (ControlledDynamicWebAppCluster) entity;\n\n        assertTrue(cluster.getController() instanceof NginxController, \"controller=\"+cluster.getController());\n        Iterable<TomcatServer> tomcats = FluentIterable.from(cluster.getCluster().getMembers()).filter(TomcatServer.class);\n        assertEquals(Iterables.size(tomcats), 2);\n        for (TomcatServer tomcat : tomcats) {\n            assertTrue(tomcat.getAttribute(TomcatServer.SERVICE_UP), \"serviceup\");\n        }\n\n        EntitySpec<?> spec = entity.getConfig(DynamicCluster.MEMBER_SPEC);\n        assertNotNull(spec);\n        assertEquals(spec.getType(), TomcatServer.class);\n        assertEquals(spec.getConfig().get(DynamicCluster.QUARANTINE_FAILED_ENTITIES), Boolean.FALSE);\n        assertEquals(spec.getConfig().get(DynamicCluster.INITIAL_QUORUM_SIZE), 2);\n    }","id":45598,"modified_method":"@Test(groups = \"Integration\")\n    public void testStartTomcatCluster() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-tomcat-cluster.yaml\"));\n        waitForApplicationTasks(app);\n\n        assertNotNull(app);\n        assertEquals(app.getChildren().size(), 1);\n        final Entity entity = Iterables.getOnlyElement(app.getChildren());\n        assertTrue(entity instanceof ControlledDynamicWebAppCluster, \"entity=\"+entity);\n        ControlledDynamicWebAppCluster cluster = (ControlledDynamicWebAppCluster) entity;\n\n        assertTrue(cluster.getController() instanceof NginxController, \"controller=\"+cluster.getController());\n        Iterable<TomcatServer> tomcats = FluentIterable.from(cluster.getCluster().getMembers()).filter(TomcatServer.class);\n        assertEquals(Iterables.size(tomcats), 2);\n        for (TomcatServer tomcat : tomcats) {\n            assertTrue(tomcat.getAttribute(TomcatServer.SERVICE_UP), \"serviceup\");\n        }\n\n        EntitySpec<?> spec = entity.getConfig(DynamicCluster.MEMBER_SPEC);\n        assertNotNull(spec);\n        assertEquals(spec.getType(), TomcatServer.class);\n        assertEquals(spec.getConfig().get(DynamicCluster.QUARANTINE_FAILED_ENTITIES), Boolean.FALSE);\n        assertEquals(spec.getConfig().get(DynamicCluster.INITIAL_QUORUM_SIZE), 2);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithAppAndEntityLocations() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",  \n            \"  location: localhost:(name=localhost name)\",\n            \"location: byon:(hosts=\\\"1.1.1.1\\\", name=byon name)\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 1);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        \n        Assert.assertEquals(entity.getLocations().size(), 2);\n        Iterator<Location> entityLocationIterator = entity.getLocations().iterator();\n        Assert.assertEquals(entityLocationIterator.next().getDisplayName(), \"localhost name\");\n        Assert.assertEquals(entityLocationIterator.next().getDisplayName(), \"byon name\");\n        \n        Location appLocation = app.getLocations().iterator().next();\n        Assert.assertEquals(appLocation.getDisplayName(), \"byon name\");\n    }","id":45599,"modified_method":"@Test\n    public void testWithAppAndEntityLocations() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",  \n            \"  location: localhost:(name=localhost name)\",\n            \"location: byon:(hosts=\\\"1.1.1.1\\\", name=byon name)\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 1);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        \n        Assert.assertEquals(entity.getLocations().size(), 2);\n        Iterator<Location> entityLocationIterator = entity.getLocations().iterator();\n        Assert.assertEquals(entityLocationIterator.next().getDisplayName(), \"localhost name\");\n        Assert.assertEquals(entityLocationIterator.next().getDisplayName(), \"byon name\");\n        \n        Location appLocation = app.getLocations().iterator().next();\n        Assert.assertEquals(appLocation.getDisplayName(), \"byon name\");\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testComponent() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",\n            \"  brooklyn.config:\",\n            \"    test.confName: first entity\",\n            \"  id: te1\",\n            \"- serviceType: brooklyn.test.entity.TestEntity\",\n            \"  name: second entity\",\n            \"  brooklyn.config:\",\n            \"    test.confObject: $brooklyn:component(\\\"te1\\\")\");\n        waitForApplicationTasks(app);\n        Entity firstEntity = null;\n        Entity secondEntity = null;\n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity entity : app.getChildren()) {\n            if (entity.getDisplayName().equals(\"testentity\"))\n                firstEntity = entity;\n            else if (entity.getDisplayName().equals(\"second entity\"))\n                secondEntity = entity;\n        }\n        final Entity[] entities = {firstEntity, secondEntity};\n        Assert.assertNotNull(entities[0], \"Expected app to contain child named 'testentity'\");\n        Assert.assertNotNull(entities[1], \"Expected app to contain child named 'second entity'\");\n        Object object = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Object>() {\n            public Object call() {\n                return entities[1].getConfig(TestEntity.CONF_OBJECT);\n            }}).get();\n        Assert.assertNotNull(object);\n        Assert.assertEquals(object, firstEntity, \"Expected second entity's test.confObject to contain first entity\");\n    }","id":45600,"modified_method":"@Test\n    public void testComponent() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",\n            \"  brooklyn.config:\",\n            \"    test.confName: first entity\",\n            \"  id: te1\",\n            \"- serviceType: brooklyn.test.entity.TestEntity\",\n            \"  name: second entity\",\n            \"  brooklyn.config:\",\n            \"    test.confObject: $brooklyn:component(\\\"te1\\\")\"));\n        waitForApplicationTasks(app);\n        Entity firstEntity = null;\n        Entity secondEntity = null;\n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity entity : app.getChildren()) {\n            if (entity.getDisplayName().equals(\"testentity\"))\n                firstEntity = entity;\n            else if (entity.getDisplayName().equals(\"second entity\"))\n                secondEntity = entity;\n        }\n        final Entity[] entities = {firstEntity, secondEntity};\n        Assert.assertNotNull(entities[0], \"Expected app to contain child named 'testentity'\");\n        Assert.assertNotNull(entities[1], \"Expected app to contain child named 'second entity'\");\n        Object object = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Object>() {\n            public Object call() {\n                return entities[1].getConfig(TestEntity.CONF_OBJECT);\n            }}).get();\n        Assert.assertNotNull(object);\n        Assert.assertEquals(object, firstEntity, \"Expected second entity's test.confObject to contain first entity\");\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testMultipleReferences() throws Exception {\n        final Entity app = createAndStartApplication(\"test-referencing-entities.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-referencing-entities\");\n\n        Entity entity1 = null, entity2 = null, child1 = null, child2 = null, grandchild1 = null, grandchild2 = null;\n\n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity child : app.getChildren()) {\n            if (child.getDisplayName().equals(\"entity 1\"))\n                entity1 = child;\n            if (child.getDisplayName().equals(\"entity 2\"))\n                entity2 = child;\n        }\n        Assert.assertNotNull(entity1);\n        Assert.assertNotNull(entity2);\n\n        Assert.assertEquals(entity1.getChildren().size(), 2);\n        for (Entity child : entity1.getChildren()) {\n            if (child.getDisplayName().equals(\"child 1\"))\n                child1 = child;\n            if (child.getDisplayName().equals(\"child 2\"))\n                child2 = child;\n        }\n        Assert.assertNotNull(child1);\n        Assert.assertNotNull(child2);\n\n        Assert.assertEquals(child1.getChildren().size(), 2);\n        for (Entity child : child1.getChildren()) {\n            if (child.getDisplayName().equals(\"grandchild 1\"))\n                grandchild1 = child;\n            if (child.getDisplayName().equals(\"grandchild 2\"))\n                grandchild2 = child;\n        }\n        Assert.assertNotNull(grandchild1);\n        Assert.assertNotNull(grandchild2);\n\n        Map<ConfigKey<Entity>, Entity> keyToEntity = new ImmutableMap.Builder<ConfigKey<Entity>, Entity>()\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_APP, app)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY1, entity1)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY2, entity2)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD1, child1)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD2, child2)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD1, grandchild1)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD2, grandchild2)\n            .build();\n\n        Iterable<Entity> entitiesInApp = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Iterable<Entity>>() {\n            @Override\n            public Iterable<Entity> call() throws Exception {\n                return ((EntityManagerInternal)((EntityInternal)app).getManagementContext().getEntityManager()).getAllEntitiesInApplication((Application)app);\n            }\n        }).get();\n\n        for (Entity entityInApp : entitiesInApp)\n            checkReferences(entityInApp, keyToEntity);\n    }","id":45601,"modified_method":"@Test\n    public void testMultipleReferences() throws Exception {\n        final Entity app = createAndStartApplication(loadYaml(\"test-referencing-entities.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-referencing-entities\");\n\n        Entity entity1 = null, entity2 = null, child1 = null, child2 = null, grandchild1 = null, grandchild2 = null;\n\n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity child : app.getChildren()) {\n            if (child.getDisplayName().equals(\"entity 1\"))\n                entity1 = child;\n            if (child.getDisplayName().equals(\"entity 2\"))\n                entity2 = child;\n        }\n        Assert.assertNotNull(entity1);\n        Assert.assertNotNull(entity2);\n\n        Assert.assertEquals(entity1.getChildren().size(), 2);\n        for (Entity child : entity1.getChildren()) {\n            if (child.getDisplayName().equals(\"child 1\"))\n                child1 = child;\n            if (child.getDisplayName().equals(\"child 2\"))\n                child2 = child;\n        }\n        Assert.assertNotNull(child1);\n        Assert.assertNotNull(child2);\n\n        Assert.assertEquals(child1.getChildren().size(), 2);\n        for (Entity child : child1.getChildren()) {\n            if (child.getDisplayName().equals(\"grandchild 1\"))\n                grandchild1 = child;\n            if (child.getDisplayName().equals(\"grandchild 2\"))\n                grandchild2 = child;\n        }\n        Assert.assertNotNull(grandchild1);\n        Assert.assertNotNull(grandchild2);\n\n        Map<ConfigKey<Entity>, Entity> keyToEntity = new ImmutableMap.Builder<ConfigKey<Entity>, Entity>()\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_APP, app)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY1, entity1)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY2, entity2)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD1, child1)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD2, child2)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD1, grandchild1)\n            .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD2, grandchild2)\n            .build();\n\n        Iterable<Entity> entitiesInApp = ((EntityInternal)app).getExecutionContext().submit(MutableMap.of(), new Callable<Iterable<Entity>>() {\n            @Override\n            public Iterable<Entity> call() throws Exception {\n                return ((EntityManagerInternal)((EntityInternal)app).getManagementContext().getEntityManager()).getAllEntitiesInApplication((Application)app);\n            }\n        }).get();\n\n        for (Entity entityInApp : entitiesInApp)\n            checkReferences(entityInApp, keyToEntity);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithInitConfig() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-with-init-config.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-with-init-config\");\n        TestEntityWithInitConfig testWithConfigInit = null;\n        TestEntity testEntity = null;\n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity entity : app.getChildren()) {\n            if (entity instanceof TestEntity)\n                testEntity = (TestEntity) entity;\n            if (entity instanceof TestEntityWithInitConfig)\n                testWithConfigInit = (TestEntityWithInitConfig) entity;\n        }\n        Assert.assertNotNull(testEntity, \"Expected app to contain TestEntity child\");\n        Assert.assertNotNull(testWithConfigInit, \"Expected app to contain TestEntityWithInitConfig child\");\n        Assert.assertEquals(testWithConfigInit.getEntityCachedOnInit(), testEntity);\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n    }","id":45602,"modified_method":"@Test\n    public void testWithInitConfig() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-with-init-config.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-with-init-config\");\n        TestEntityWithInitConfig testWithConfigInit = null;\n        TestEntity testEntity = null;\n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity entity : app.getChildren()) {\n            if (entity instanceof TestEntity)\n                testEntity = (TestEntity) entity;\n            if (entity instanceof TestEntityWithInitConfig)\n                testWithConfigInit = (TestEntityWithInitConfig) entity;\n        }\n        Assert.assertNotNull(testEntity, \"Expected app to contain TestEntity child\");\n        Assert.assertNotNull(testWithConfigInit, \"Expected app to contain TestEntityWithInitConfig child\");\n        Assert.assertEquals(testWithConfigInit.getEntityCachedOnInit(), testEntity);\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testSensor() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\", \n            \"  brooklyn.config:\",\n            \"    test.confObject: $brooklyn:sensor(\\\"brooklyn.test.entity.TestEntity\\\", \\\"test.sequence\\\")\");\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity, \"Expected app to have child entity\");\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        TestEntity testEntity = (TestEntity) entity;\n        Object object = testEntity.getConfig(TestEntity.CONF_OBJECT);\n        Assert.assertNotNull(object);\n        Assert.assertTrue(object instanceof AttributeSensor, \"attributeSensor=\"+object);\n        Assert.assertEquals(object, TestEntity.SEQUENCE);\n    }","id":45603,"modified_method":"@Test\n    public void testSensor() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\", \n            \"  brooklyn.config:\",\n            \"    test.confObject: $brooklyn:sensor(\\\"brooklyn.test.entity.TestEntity\\\", \\\"test.sequence\\\")\"));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity, \"Expected app to have child entity\");\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        TestEntity testEntity = (TestEntity) entity;\n        Object object = testEntity.getConfig(TestEntity.CONF_OBJECT);\n        Assert.assertNotNull(object);\n        Assert.assertTrue(object instanceof AttributeSensor, \"attributeSensor=\"+object);\n        Assert.assertEquals(object, TestEntity.SEQUENCE);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\", extras);\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertTrue(app.getChildren().iterator().hasNext(), \"Expected app to have child entity\");\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        \n        return (TestEntity)entity;\n    }","id":45604,"modified_method":"protected Entity setupAndCheckTestEntityInBasicYamlWith(String ...extras) throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\", extras));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertTrue(app.getChildren().iterator().hasNext(), \"Expected app to have child entity\");\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        \n        return (TestEntity)entity;\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWith2EntityLocations() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",  \n            \"  locations:\",\n            \"  - localhost:(name=localhost name)\",\n            \"  - byon:(hosts=\\\"1.1.1.1\\\", name=byon name)\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertEquals(entity.getLocations().size(), 2);\n        Location localhostLocation = null, byonLocation = null; \n        for (Location location : entity.getLocations()) {\n            if (location.getDisplayName().equals(\"localhost name\"))\n                localhostLocation = location;\n            else if (location.getDisplayName().equals(\"byon name\"))\n                byonLocation = location;\n        }\n        Assert.assertNotNull(localhostLocation);\n        Assert.assertNotNull(byonLocation);\n    }","id":45605,"modified_method":"@Test\n    public void testWith2EntityLocations() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",  \n            \"  locations:\",\n            \"  - localhost:(name=localhost name)\",\n            \"  - byon:(hosts=\\\"1.1.1.1\\\", name=byon name)\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertEquals(entity.getLocations().size(), 2);\n        Location localhostLocation = null, byonLocation = null; \n        for (Location location : entity.getLocations()) {\n            if (location.getDisplayName().equals(\"localhost name\"))\n                localhostLocation = location;\n            else if (location.getDisplayName().equals(\"byon name\"))\n                byonLocation = location;\n        }\n        Assert.assertNotNull(localhostLocation);\n        Assert.assertNotNull(byonLocation);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testGrandchildEntities() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\", \n            \"  brooklyn.config:\",\n            \"    test.confName: first entity\",\n            \"  brooklyn.children:\",\n            \"  - serviceType: brooklyn.test.entity.TestEntity\",\n            \"    name: Child Entity\",\n            \"    brooklyn.config:\",\n            \"      test.confName: Name of the first Child\",\n            \"    brooklyn.children:\",\n            \"    - serviceType: brooklyn.test.entity.TestEntity\",\n            \"      name: Grandchild Entity\",\n            \"      brooklyn.config:\",\n            \"        test.confName: Name of the Grandchild\",\n            \"  - serviceType: brooklyn.test.entity.TestEntity\",\n            \"    name: Second Child\",\n            \"    brooklyn.config:\",\n            \"      test.confName: Name of the second Child\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity firstEntity = app.getChildren().iterator().next();\n        Assert.assertEquals(firstEntity.getConfig(TestEntity.CONF_NAME), \"first entity\");\n        Assert.assertEquals(firstEntity.getChildren().size(), 2);\n        Entity firstChild = null;\n        Entity secondChild = null;\n        for (Entity entity : firstEntity.getChildren()) {\n            if (entity.getConfig(TestEntity.CONF_NAME).equals(\"Name of the first Child\"))\n                firstChild = entity;\n            if (entity.getConfig(TestEntity.CONF_NAME).equals(\"Name of the second Child\"))\n                secondChild = entity;\n        }\n        Assert.assertNotNull(firstChild, \"Expected a child of 'first entity' with the name 'Name of the first Child'\");\n        Assert.assertNotNull(secondChild, \"Expected a child of 'first entity' with the name 'Name of the second Child'\");\n        Assert.assertEquals(firstChild.getChildren().size(), 1);\n        Entity grandchild = firstChild.getChildren().iterator().next();\n        Assert.assertEquals(grandchild.getConfig(TestEntity.CONF_NAME), \"Name of the Grandchild\");\n        Assert.assertEquals(secondChild.getChildren().size(), 0);\n    }","id":45606,"modified_method":"@Test\n    public void testGrandchildEntities() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\", \n            \"  brooklyn.config:\",\n            \"    test.confName: first entity\",\n            \"  brooklyn.children:\",\n            \"  - serviceType: brooklyn.test.entity.TestEntity\",\n            \"    name: Child Entity\",\n            \"    brooklyn.config:\",\n            \"      test.confName: Name of the first Child\",\n            \"    brooklyn.children:\",\n            \"    - serviceType: brooklyn.test.entity.TestEntity\",\n            \"      name: Grandchild Entity\",\n            \"      brooklyn.config:\",\n            \"        test.confName: Name of the Grandchild\",\n            \"  - serviceType: brooklyn.test.entity.TestEntity\",\n            \"    name: Second Child\",\n            \"    brooklyn.config:\",\n            \"      test.confName: Name of the second Child\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity firstEntity = app.getChildren().iterator().next();\n        Assert.assertEquals(firstEntity.getConfig(TestEntity.CONF_NAME), \"first entity\");\n        Assert.assertEquals(firstEntity.getChildren().size(), 2);\n        Entity firstChild = null;\n        Entity secondChild = null;\n        for (Entity entity : firstEntity.getChildren()) {\n            if (entity.getConfig(TestEntity.CONF_NAME).equals(\"Name of the first Child\"))\n                firstChild = entity;\n            if (entity.getConfig(TestEntity.CONF_NAME).equals(\"Name of the second Child\"))\n                secondChild = entity;\n        }\n        Assert.assertNotNull(firstChild, \"Expected a child of 'first entity' with the name 'Name of the first Child'\");\n        Assert.assertNotNull(secondChild, \"Expected a child of 'first entity' with the name 'Name of the second Child'\");\n        Assert.assertEquals(firstChild.getChildren().size(), 1);\n        Entity grandchild = firstChild.getChildren().iterator().next();\n        Assert.assertEquals(grandchild.getConfig(TestEntity.CONF_NAME), \"Name of the Grandchild\");\n        Assert.assertEquals(secondChild.getChildren().size(), 0);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void testEmptyStructuredConfig() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",\n            \"  brooklyn.config:\",\n            \"    test.confName: \\\"\\\"\",\n            \"    test.confListThing: !!seq []\",\n            \"    test.confSetThing: !!set {}\",\n            \"    test.confMapThing: !!map {}\");\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity, \"Expected app to have child entity\");\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        TestEntity testEntity = (TestEntity) entity;\n        List<String> thingList = (List<String>)testEntity.getConfig(TestEntity.CONF_LIST_THING);\n        Set<String> thingSet = (Set<String>)testEntity.getConfig(TestEntity.CONF_SET_THING);\n        Map<String, String> thingMap = (Map<String, String>)testEntity.getConfig(TestEntity.CONF_MAP_THING);\n        Assert.assertEquals(thingList, Lists.newArrayList());\n        Assert.assertEquals(thingSet, ImmutableSet.of());\n        Assert.assertEquals(thingMap, ImmutableMap.of());\n    }","id":45607,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void testEmptyStructuredConfig() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",\n            \"  brooklyn.config:\",\n            \"    test.confName: \\\"\\\"\",\n            \"    test.confListThing: !!seq []\",\n            \"    test.confSetThing: !!set {}\",\n            \"    test.confMapThing: !!map {}\"));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity, \"Expected app to have child entity\");\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        TestEntity testEntity = (TestEntity) entity;\n        List<String> thingList = (List<String>)testEntity.getConfig(TestEntity.CONF_LIST_THING);\n        Set<String> thingSet = (Set<String>)testEntity.getConfig(TestEntity.CONF_SET_THING);\n        Map<String, String> thingMap = (Map<String, String>)testEntity.getConfig(TestEntity.CONF_MAP_THING);\n        Assert.assertEquals(thingList, Lists.newArrayList());\n        Assert.assertEquals(thingSet, ImmutableSet.of());\n        Assert.assertEquals(thingMap, ImmutableMap.of());\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWith2AppLocations() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",  \n            \"locations:\",\n            \"- localhost:(name=localhost name)\",\n            \"- byon:(hosts=\\\"1.1.1.1\\\", name=byon name)\");\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getLocations().size(), 2);\n        Location localhostLocation = null, byonLocation = null; \n        for (Location location : app.getLocations()) {\n            if (location.getDisplayName().equals(\"localhost name\"))\n                localhostLocation = location;\n            else if (location.getDisplayName().equals(\"byon name\"))\n                byonLocation = location;\n        }\n        Assert.assertNotNull(localhostLocation);\n        Assert.assertNotNull(byonLocation);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity);\n        Assert.assertEquals(entity.getLocations().size(), 2);\n    }","id":45608,"modified_method":"@Test\n    public void testWith2AppLocations() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",  \n            \"locations:\",\n            \"- localhost:(name=localhost name)\",\n            \"- byon:(hosts=\\\"1.1.1.1\\\", name=byon name)\"));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getLocations().size(), 2);\n        Location localhostLocation = null, byonLocation = null; \n        for (Location location : app.getLocations()) {\n            if (location.getDisplayName().equals(\"localhost name\"))\n                localhostLocation = location;\n            else if (location.getDisplayName().equals(\"byon name\"))\n                byonLocation = location;\n        }\n        Assert.assertNotNull(localhostLocation);\n        Assert.assertNotNull(byonLocation);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity);\n        Assert.assertEquals(entity.getLocations().size(), 2);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void testWithAppLocation() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",  \n            \"location: localhost:(name=yaml name)\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 1);\n        Location location = app.getLocations().iterator().next();\n        Assert.assertNotNull(location);\n        Assert.assertEquals(location.getDisplayName(), \"yaml name\");\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity);\n        Assert.assertEquals(entity.getLocations().size(), 1);\n    }","id":45609,"modified_method":"public void testWithAppLocation() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",  \n            \"location: localhost:(name=yaml name)\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 1);\n        Location location = app.getLocations().iterator().next();\n        Assert.assertNotNull(location);\n        Assert.assertEquals(location.getDisplayName(), \"yaml name\");\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity);\n        Assert.assertEquals(entity.getLocations().size(), 1);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithEntityLocation() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",  \n            \"  location: localhost:(name=yaml name)\\n\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertEquals(entity.getLocations().size(), 1);\n        Location location = entity.getLocations().iterator().next();\n        Assert.assertNotNull(location);\n        Assert.assertEquals(location.getDisplayName(), \"yaml name\");\n        Assert.assertNotNull(entity);\n    }","id":45610,"modified_method":"@Test\n    public void testWithEntityLocation() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",  \n            \"  location: localhost:(name=yaml name)\\n\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getLocations().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertEquals(entity.getLocations().size(), 1);\n        Location location = entity.getLocations().iterator().next();\n        Assert.assertNotNull(location);\n        Assert.assertEquals(location.getDisplayName(), \"yaml name\");\n        Assert.assertNotNull(entity);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testEmptyConfig() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",\n            \"  brooklyn.config:\",\n            \"    test.confName: \\\"\\\"\",\n            \"    test.confListPlain: !!seq []\",\n            \"    test.confMapPlain: !!map {}\",\n            \"    test.confSetPlain: !!set {}\",\n            \"    test.confObject: \\\"\\\"\");\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity, \"Expected app to have child entity\");\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        TestEntity testEntity = (TestEntity) entity;\n        Assert.assertEquals(testEntity.getConfig(TestEntity.CONF_NAME), \"\");\n        List<String> list = testEntity.getConfig(TestEntity.CONF_LIST_PLAIN);\n        Assert.assertEquals(list, ImmutableList.of());\n        Map<String, String> map = testEntity.getConfig(TestEntity.CONF_MAP_PLAIN);\n        Assert.assertEquals(map, ImmutableMap.of());\n        // TODO: CONF_SET_PLAIN is being set to an empty ArrayList - may be a snakeyaml issue?\n        //        Set<String> plainSet = (Set<String>)testEntity.getConfig(TestEntity.CONF_SET_PLAIN);\n        //        Assert.assertEquals(plainSet, ImmutableSet.of());\n        Object object = testEntity.getConfig(TestEntity.CONF_OBJECT);\n        Assert.assertEquals(object, \"\");\n    }","id":45611,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testEmptyConfig() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",\n            \"  brooklyn.config:\",\n            \"    test.confName: \\\"\\\"\",\n            \"    test.confListPlain: !!seq []\",\n            \"    test.confMapPlain: !!map {}\",\n            \"    test.confSetPlain: !!set {}\",\n            \"    test.confObject: \\\"\\\"\"));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-basic-template\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Entity entity = app.getChildren().iterator().next();\n        Assert.assertNotNull(entity, \"Expected app to have child entity\");\n        Assert.assertTrue(entity instanceof TestEntity, \"Expected TestEntity, found \" + entity.getClass());\n        TestEntity testEntity = (TestEntity) entity;\n        Assert.assertEquals(testEntity.getConfig(TestEntity.CONF_NAME), \"\");\n        List<String> list = testEntity.getConfig(TestEntity.CONF_LIST_PLAIN);\n        Assert.assertEquals(list, ImmutableList.of());\n        Map<String, String> map = testEntity.getConfig(TestEntity.CONF_MAP_PLAIN);\n        Assert.assertEquals(map, ImmutableMap.of());\n        // TODO: CONF_SET_PLAIN is being set to an empty ArrayList - may be a snakeyaml issue?\n        //        Set<String> plainSet = (Set<String>)testEntity.getConfig(TestEntity.CONF_SET_PLAIN);\n        //        Assert.assertEquals(plainSet, ImmutableSet.of());\n        Object object = testEntity.getConfig(TestEntity.CONF_OBJECT);\n        Assert.assertEquals(object, \"\");\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testAppWithSameServerEntityStarts() throws Exception {\n        Entity app = createAndStartApplication(\"same-server-entity-test.yaml\");\n        waitForApplicationTasks(app);\n        assertNotNull(app);\n        assertEquals(app.getAttribute(Attributes.SERVICE_STATE), Lifecycle.RUNNING, \"service state\");\n        assertTrue(app.getAttribute(Attributes.SERVICE_UP), \"service up\");\n\n        assertEquals(app.getChildren().size(), 1);\n        Entity entity = Iterables.getOnlyElement(app.getChildren());\n        assertTrue(entity instanceof SameServerEntity, \"entity=\"+entity);\n\n        SameServerEntity sse = (SameServerEntity) entity;\n        assertEquals(sse.getChildren().size(), 2);\n        for (Entity child : sse.getChildren()) {\n            assertTrue(child instanceof BasicEntity, \"child=\"+child);\n        }\n    }","id":45612,"modified_method":"@Test\n    public void testAppWithSameServerEntityStarts() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"same-server-entity-test.yaml\"));\n        waitForApplicationTasks(app);\n        assertNotNull(app);\n        assertEquals(app.getAttribute(Attributes.SERVICE_STATE), Lifecycle.RUNNING, \"service state\");\n        assertTrue(app.getAttribute(Attributes.SERVICE_UP), \"service up\");\n\n        assertEquals(app.getChildren().size(), 1);\n        Entity entity = Iterables.getOnlyElement(app.getChildren());\n        assertTrue(entity instanceof SameServerEntity, \"entity=\"+entity);\n\n        SameServerEntity sse = (SameServerEntity) entity;\n        assertEquals(sse.getChildren().size(), 2);\n        for (Entity child : sse.getChildren()) {\n            assertTrue(child instanceof BasicEntity, \"child=\"+child);\n        }\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testSensorOnArbitraryClass() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\", \n            \"  brooklyn.config:\",\n            \"    test.confObject: $brooklyn:sensor(\\\"io.brooklyn.camp.brooklyn.EntitiesYamlTest$ArbitraryClassWithSensor\\\", \\\"mysensor\\\")\");\n        waitForApplicationTasks(app);\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        TestEntity entity = (TestEntity) app.getChildren().iterator().next();\n        Object object = entity.getConfig(TestEntity.CONF_OBJECT);\n        Assert.assertEquals(object, ArbitraryClassWithSensor.MY_SENSOR);\n    }","id":45613,"modified_method":"@Test\n    public void testSensorOnArbitraryClass() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\", \n            \"  brooklyn.config:\",\n            \"    test.confObject: $brooklyn:sensor(\\\"io.brooklyn.camp.brooklyn.EntitiesYamlTest$ArbitraryClassWithSensor\\\", \\\"mysensor\\\")\"));\n        waitForApplicationTasks(app);\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        TestEntity entity = (TestEntity) app.getChildren().iterator().next();\n        Object object = entity.getConfig(TestEntity.CONF_OBJECT);\n        Assert.assertEquals(object, ArbitraryClassWithSensor.MY_SENSOR);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testCreateClusterWithMemberSpec() throws Exception {\n        Entity app = createAndStartApplication(\"test-cluster-with-member-spec.yaml\");\n        waitForApplicationTasks(app);\n        assertEquals(app.getChildren().size(), 1);\n\n        Entity clusterEntity = Iterables.getOnlyElement(app.getChildren());\n        assertTrue(clusterEntity instanceof DynamicCluster, \"cluster=\"+clusterEntity);\n\n        DynamicCluster cluster = DynamicCluster.class.cast(clusterEntity);\n        assertEquals(cluster.getMembers().size(), 2, \"members=\"+cluster.getMembers());\n\n        for (Entity member : cluster.getMembers()) {\n            assertTrue(member instanceof TestEntity, \"member=\"+member);\n            assertEquals(member.getConfig(TestEntity.CONF_NAME), \"yamlTest\");\n        }\n    }","id":45614,"modified_method":"@Test\n    public void testCreateClusterWithMemberSpec() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-cluster-with-member-spec.yaml\"));\n        waitForApplicationTasks(app);\n        assertEquals(app.getChildren().size(), 1);\n\n        Entity clusterEntity = Iterables.getOnlyElement(app.getChildren());\n        assertTrue(clusterEntity instanceof DynamicCluster, \"cluster=\"+clusterEntity);\n\n        DynamicCluster cluster = DynamicCluster.class.cast(clusterEntity);\n        assertEquals(cluster.getMembers().size(), 2, \"members=\"+cluster.getMembers());\n\n        for (Entity member : cluster.getMembers()) {\n            assertTrue(member instanceof TestEntity, \"member=\"+member);\n            assertEquals(member.getConfig(TestEntity.CONF_NAME), \"yamlTest\");\n        }\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testMultiplePolicyReferences() throws Exception {\n        final Entity app = createAndStartApplication(\"test-referencing-policies.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-referencing-policies\");\n        \n        Entity entity1 = null, entity2 = null, child1 = null, child2 = null, grandchild1 = null, grandchild2 = null;\n        \n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity child : app.getChildren()) {\n            if (child.getDisplayName().equals(\"entity 1\"))\n                entity1 = child;\n            if (child.getDisplayName().equals(\"entity 2\"))\n                entity2 = child;\n        }\n        Assert.assertNotNull(entity1);\n        Assert.assertNotNull(entity2);\n        \n        Assert.assertEquals(entity1.getChildren().size(), 2);\n        for (Entity child : entity1.getChildren()) {\n            if (child.getDisplayName().equals(\"child 1\"))\n                child1 = child;\n            if (child.getDisplayName().equals(\"child 2\"))\n                child2 = child;\n        }\n        Assert.assertNotNull(child1);\n        Assert.assertNotNull(child2);\n        \n        Assert.assertEquals(child1.getChildren().size(), 2);\n        for (Entity child : child1.getChildren()) {\n            if (child.getDisplayName().equals(\"grandchild 1\"))\n               grandchild1 = child;\n            if (child.getDisplayName().equals(\"grandchild 2\"))\n                grandchild2 = child;\n        }\n        Assert.assertNotNull(grandchild1);\n        Assert.assertNotNull(grandchild2);\n        \n        ImmutableSet<Policy> policies = new ImmutableSet.Builder<Policy>()\n                .add(getPolicy(app))\n                .add(getPolicy(entity1))\n                .add(getPolicy(entity2))\n                .add(getPolicy(child1))\n                .add(getPolicy(child2))\n                .add(getPolicy(grandchild1))\n                .add(getPolicy(grandchild2))\n                .build();\n        \n        Map<ConfigKey<Entity>, Entity> keyToEntity = new ImmutableMap.Builder<ConfigKey<Entity>, Entity>()\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_APP, app)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY1, entity1)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY2, entity2)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD1, child1)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD2, child2)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD1, grandchild1)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD2, grandchild2)\n                .build();\n        \n        for (Policy policy : policies)\n            checkReferences(policy, keyToEntity);\n        \n    }","id":45615,"modified_method":"@Test\n    public void testMultiplePolicyReferences() throws Exception {\n        final Entity app = createAndStartApplication(loadYaml(\"test-referencing-policies.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-referencing-policies\");\n        \n        Entity entity1 = null, entity2 = null, child1 = null, child2 = null, grandchild1 = null, grandchild2 = null;\n        \n        Assert.assertEquals(app.getChildren().size(), 2);\n        for (Entity child : app.getChildren()) {\n            if (child.getDisplayName().equals(\"entity 1\"))\n                entity1 = child;\n            if (child.getDisplayName().equals(\"entity 2\"))\n                entity2 = child;\n        }\n        Assert.assertNotNull(entity1);\n        Assert.assertNotNull(entity2);\n        \n        Assert.assertEquals(entity1.getChildren().size(), 2);\n        for (Entity child : entity1.getChildren()) {\n            if (child.getDisplayName().equals(\"child 1\"))\n                child1 = child;\n            if (child.getDisplayName().equals(\"child 2\"))\n                child2 = child;\n        }\n        Assert.assertNotNull(child1);\n        Assert.assertNotNull(child2);\n        \n        Assert.assertEquals(child1.getChildren().size(), 2);\n        for (Entity child : child1.getChildren()) {\n            if (child.getDisplayName().equals(\"grandchild 1\"))\n               grandchild1 = child;\n            if (child.getDisplayName().equals(\"grandchild 2\"))\n                grandchild2 = child;\n        }\n        Assert.assertNotNull(grandchild1);\n        Assert.assertNotNull(grandchild2);\n        \n        ImmutableSet<Policy> policies = new ImmutableSet.Builder<Policy>()\n                .add(getPolicy(app))\n                .add(getPolicy(entity1))\n                .add(getPolicy(entity2))\n                .add(getPolicy(child1))\n                .add(getPolicy(child2))\n                .add(getPolicy(grandchild1))\n                .add(getPolicy(grandchild2))\n                .build();\n        \n        Map<ConfigKey<Entity>, Entity> keyToEntity = new ImmutableMap.Builder<ConfigKey<Entity>, Entity>()\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_APP, app)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY1, entity1)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_ENTITY2, entity2)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD1, child1)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_CHILD2, child2)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD1, grandchild1)\n                .put(ReferencingYamlTestEntity.TEST_REFERENCE_GRANDCHILD2, grandchild2)\n                .build();\n        \n        for (Policy policy : policies)\n            checkReferences(policy, keyToEntity);\n        \n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithEntityPolicy() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-with-policy.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-with-policy\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Assert.assertEquals(app.getPolicies().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity child = app.getChildren().iterator().next();\n        Assert.assertEquals(child.getPolicies().size(), 1);\n        Policy policy = child.getPolicies().iterator().next();\n        Assert.assertNotNull(policy);\n        Assert.assertTrue(policy instanceof TestPolicy, \"policy=\" + policy + \"; type=\" + policy.getClass());\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        Assert.assertEquals(((TestPolicy) policy).getLeftoverProperties(),\n                ImmutableMap.of(\"policyLiteralValue1\", \"Hello\", \"policyLiteralValue2\", \"World\"));\n        Assert.assertEquals(policy.getConfig(TestPolicy.TEST_ATTRIBUTE_SENSOR), TestEntity.NAME);\n    }","id":45616,"modified_method":"@Test\n    public void testWithEntityPolicy() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-with-policy.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-entity-with-policy\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Assert.assertEquals(app.getPolicies().size(), 0);\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity child = app.getChildren().iterator().next();\n        Assert.assertEquals(child.getPolicies().size(), 1);\n        Policy policy = child.getPolicies().iterator().next();\n        Assert.assertNotNull(policy);\n        Assert.assertTrue(policy instanceof TestPolicy, \"policy=\" + policy + \"; type=\" + policy.getClass());\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        Assert.assertEquals(((TestPolicy) policy).getLeftoverProperties(),\n                ImmutableMap.of(\"policyLiteralValue1\", \"Hello\", \"policyLiteralValue2\", \"World\"));\n        Assert.assertEquals(policy.getConfig(TestPolicy.TEST_ATTRIBUTE_SENSOR), TestEntity.NAME);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testChildWithPolicy() throws Exception {\n        Entity app = createAndStartApplication(\"test-entity-basic-template.yaml\",\n                    \"  brooklyn.config:\",\n                    \"    test.confName: parent entity\",\n                    \"  brooklyn.children:\",\n                    \"  - serviceType: brooklyn.test.entity.TestEntity\",\n                    \"    name: Child Entity\",\n                    \"    brooklyn.policies:\",\n                    \"    - policyType: brooklyn.test.policy.TestPolicy\",\n                    \"      brooklyn.config:\",\n                    \"        test.confName: Name from YAML\",\n                    \"        test.attributeSensor: $brooklyn:sensor(\\\"brooklyn.test.entity.TestEntity\\\", \\\"test.name\\\")\");\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity firstEntity = app.getChildren().iterator().next();\n        Assert.assertEquals(firstEntity.getChildren().size(), 1);\n        final Entity child = firstEntity.getChildren().iterator().next();\n        Assert.assertEquals(child.getChildren().size(), 0);\n\n        Assert.assertEquals(app.getPolicies().size(), 0);\n        Assert.assertEquals(firstEntity.getPolicies().size(), 0);\n        \n        Asserts.eventually(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                return child.getPolicies().size();\n            }\n        }, Predicates.<Integer> equalTo(1));\n        \n        Policy policy = child.getPolicies().iterator().next();\n        Assert.assertTrue(policy instanceof TestPolicy);\n        Assert.assertEquals(policy.getConfig(TestPolicy.TEST_ATTRIBUTE_SENSOR), TestEntity.NAME);\n    }","id":45617,"modified_method":"@Test\n    public void testChildWithPolicy() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-entity-basic-template.yaml\",\n                    \"  brooklyn.config:\",\n                    \"    test.confName: parent entity\",\n                    \"  brooklyn.children:\",\n                    \"  - serviceType: brooklyn.test.entity.TestEntity\",\n                    \"    name: Child Entity\",\n                    \"    brooklyn.policies:\",\n                    \"    - policyType: brooklyn.test.policy.TestPolicy\",\n                    \"      brooklyn.config:\",\n                    \"        test.confName: Name from YAML\",\n                    \"        test.attributeSensor: $brooklyn:sensor(\\\"brooklyn.test.entity.TestEntity\\\", \\\"test.name\\\")\"));\n        waitForApplicationTasks(app);\n\n        Assert.assertEquals(app.getChildren().size(), 1);\n        Entity firstEntity = app.getChildren().iterator().next();\n        Assert.assertEquals(firstEntity.getChildren().size(), 1);\n        final Entity child = firstEntity.getChildren().iterator().next();\n        Assert.assertEquals(child.getChildren().size(), 0);\n\n        Assert.assertEquals(app.getPolicies().size(), 0);\n        Assert.assertEquals(firstEntity.getPolicies().size(), 0);\n        \n        Asserts.eventually(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                return child.getPolicies().size();\n            }\n        }, Predicates.<Integer> equalTo(1));\n        \n        Policy policy = child.getPolicies().iterator().next();\n        Assert.assertTrue(policy instanceof TestPolicy);\n        Assert.assertEquals(policy.getConfig(TestPolicy.TEST_ATTRIBUTE_SENSOR), TestEntity.NAME);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWithAppPolicy() throws Exception {\n        Entity app = createAndStartApplication(\"test-app-with-policy.yaml\");\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-app-with-policy\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Assert.assertEquals(app.getPolicies().size(), 1);\n        Policy policy = app.getPolicies().iterator().next();\n        Assert.assertTrue(policy instanceof TestPolicy);\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        Map<?, ?> leftoverProperties = ((TestPolicy) policy).getLeftoverProperties();\n        Assert.assertEquals(leftoverProperties.get(\"policyLiteralValue1\"), \"Hello\");\n        Assert.assertEquals(leftoverProperties.get(\"policyLiteralValue2\"), \"World\");\n        Assert.assertEquals(leftoverProperties.size(), 2);\n    }","id":45618,"modified_method":"@Test\n    public void testWithAppPolicy() throws Exception {\n        Entity app = createAndStartApplication(loadYaml(\"test-app-with-policy.yaml\"));\n        waitForApplicationTasks(app);\n        Assert.assertEquals(app.getDisplayName(), \"test-app-with-policy\");\n\n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n\n        Assert.assertEquals(app.getPolicies().size(), 1);\n        Policy policy = app.getPolicies().iterator().next();\n        Assert.assertTrue(policy instanceof TestPolicy);\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_NAME), \"Name from YAML\");\n        Assert.assertEquals(policy.getConfig(TestPolicy.CONF_FROM_FUNCTION), \"$brooklyn: is a fun place\");\n        Map<?, ?> leftoverProperties = ((TestPolicy) policy).getLeftoverProperties();\n        Assert.assertEquals(leftoverProperties.get(\"policyLiteralValue1\"), \"Hello\");\n        Assert.assertEquals(leftoverProperties.get(\"policyLiteralValue2\"), \"World\");\n        Assert.assertEquals(leftoverProperties.size(), 2);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testInvocationSensorAndEnricher() throws Exception {\n        Preconditions.checkArgument(Networking.isPortAvailable(4321), \"port 4321 must not be in use (no leaked nc instances) for this test to succeed!\");\n        \n        Entity app = createAndStartApplication(\"vanilla-bash-netcat-w-client.yaml\");\n        waitForApplicationTasks(app);\n        \n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertEquals(app.getDisplayName(), \"Simple Netcat with Client\");\n        \n        // comparing by plan ID is one common way\n        Iterable<Entity> netcatI = Iterables.filter(app.getChildren(), EntityPredicates.configEqualTo(BrooklynCampConstants.PLAN_ID, \"netcat-server\"));\n        Assert.assertTrue(netcatI.iterator().hasNext(), \"no 'netcat-server' child of app: \"+app.getChildren());\n        Entity netcat = Iterables.getOnlyElement(netcatI);\n        \n        // make sure netcat is running\n        EntityTestUtils.assertAttributeEventually(netcat, Attributes.SERVICE_STATE, Predicates.equalTo(Lifecycle.RUNNING));\n        \n        // find the pinger, now comparing by name\n        Iterable<Entity> pingerI = Iterables.filter(app.getChildren(), EntityPredicates.displayNameEqualTo(\"Simple Pinger\"));\n        Assert.assertTrue(pingerI.iterator().hasNext(), \"no 'Simple Pinger' child of app: \"+app.getChildren());\n        Entity pinger = Iterables.getOnlyElement(pingerI);\n\n        // invoke effector\n        Task<String> ping;\n        ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());\n        Assert.assertEquals(ping.get().trim(), \"hello\");\n        // and check we get the right result \n        EntityTestUtils.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral(\"hi netcat\"));\n        log.info(\"invoked ping from \"+pinger+\" to \"+netcat+\", 'all' sensor shows:\\n\"+\n            netcat.getAttribute(SENSOR_OUTPUT_ALL));\n\n        // netcat should now fail and restart\n        EntityTestUtils.assertAttributeEventually(netcat, Attributes.SERVICE_STATE, Predicates.not(Predicates.equalTo(Lifecycle.RUNNING)));\n        log.info(\"detected failure, state is: \"+netcat.getAttribute(Attributes.SERVICE_STATE));\n        EntityTestUtils.assertAttributeEventually(netcat, Attributes.SERVICE_STATE, Predicates.equalTo(Lifecycle.RUNNING));\n        log.info(\"detected recovery, state is: \"+netcat.getAttribute(Attributes.SERVICE_STATE));\n\n        // invoke effector again, now with a parameter\n        ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of(\"message\", \"yo yo yo\"));\n        Assert.assertEquals(ping.get().trim(), \"hello\");\n        // checking right result\n        EntityTestUtils.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral(\"yo yo yo\"));\n        log.info(\"invoked ping again from \"+pinger+\" to \"+netcat+\", 'all' sensor shows:\\n\"+\n            netcat.getAttribute(SENSOR_OUTPUT_ALL));\n        \n        // and it's propagated to the app\n        EntityTestUtils.assertAttributeEventually(app, Sensors.newStringSensor(\"output.last\"), StringPredicates.containsLiteral(\"yo yo yo\"));\n        \n        log.info(\"after all is said and done, app is:\");\n        Entities.dumpInfo(app);\n    }","id":45619,"modified_method":"@Test(groups=\"Integration\")\n    public void testInvocationSensorAndEnricher() throws Exception {\n        Preconditions.checkArgument(Networking.isPortAvailable(4321), \"port 4321 must not be in use (no leaked nc instances) for this test to succeed!\");\n        \n        Entity app = createAndStartApplication(loadYaml(\"vanilla-bash-netcat-w-client.yaml\"));\n        waitForApplicationTasks(app);\n        \n        log.info(\"App started:\");\n        Entities.dumpInfo(app);\n        \n        Assert.assertEquals(app.getDisplayName(), \"Simple Netcat with Client\");\n        \n        // comparing by plan ID is one common way\n        Iterable<Entity> netcatI = Iterables.filter(app.getChildren(), EntityPredicates.configEqualTo(BrooklynCampConstants.PLAN_ID, \"netcat-server\"));\n        Assert.assertTrue(netcatI.iterator().hasNext(), \"no 'netcat-server' child of app: \"+app.getChildren());\n        Entity netcat = Iterables.getOnlyElement(netcatI);\n        \n        // make sure netcat is running\n        EntityTestUtils.assertAttributeEventually(netcat, Attributes.SERVICE_STATE, Predicates.equalTo(Lifecycle.RUNNING));\n        \n        // find the pinger, now comparing by name\n        Iterable<Entity> pingerI = Iterables.filter(app.getChildren(), EntityPredicates.displayNameEqualTo(\"Simple Pinger\"));\n        Assert.assertTrue(pingerI.iterator().hasNext(), \"no 'Simple Pinger' child of app: \"+app.getChildren());\n        Entity pinger = Iterables.getOnlyElement(pingerI);\n\n        // invoke effector\n        Task<String> ping;\n        ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of());\n        Assert.assertEquals(ping.get().trim(), \"hello\");\n        // and check we get the right result \n        EntityTestUtils.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral(\"hi netcat\"));\n        log.info(\"invoked ping from \"+pinger+\" to \"+netcat+\", 'all' sensor shows:\\n\"+\n            netcat.getAttribute(SENSOR_OUTPUT_ALL));\n\n        // netcat should now fail and restart\n        EntityTestUtils.assertAttributeEventually(netcat, Attributes.SERVICE_STATE, Predicates.not(Predicates.equalTo(Lifecycle.RUNNING)));\n        log.info(\"detected failure, state is: \"+netcat.getAttribute(Attributes.SERVICE_STATE));\n        EntityTestUtils.assertAttributeEventually(netcat, Attributes.SERVICE_STATE, Predicates.equalTo(Lifecycle.RUNNING));\n        log.info(\"detected recovery, state is: \"+netcat.getAttribute(Attributes.SERVICE_STATE));\n\n        // invoke effector again, now with a parameter\n        ping = pinger.invoke(EFFECTOR_SAY_HI, MutableMap.<String,Object>of(\"message\", \"yo yo yo\"));\n        Assert.assertEquals(ping.get().trim(), \"hello\");\n        // checking right result\n        EntityTestUtils.assertAttributeEventually(netcat, SENSOR_OUTPUT_ALL, StringPredicates.containsLiteral(\"yo yo yo\"));\n        log.info(\"invoked ping again from \"+pinger+\" to \"+netcat+\", 'all' sensor shows:\\n\"+\n            netcat.getAttribute(SENSOR_OUTPUT_ALL));\n        \n        // and it's propagated to the app\n        EntityTestUtils.assertAttributeEventually(app, Sensors.newStringSensor(\"output.last\"), StringPredicates.containsLiteral(\"yo yo yo\"));\n        \n        log.info(\"after all is said and done, app is:\");\n        Entities.dumpInfo(app);\n    }","commit_id":"0956ebee5b3d297cf2bd220ac1b85a6df915a914","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tString format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isSpam(userId, body, serviceContext)) {\n\t\t\tthrow new MessageBodyException();\n\t\t}\n\n\t\treturn super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, format, inputStreamOVPs, anonymous, priority,\n\t\t\tallowPingbacks, serviceContext);\n\t}","id":45620,"modified_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tString format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, format, inputStreamOVPs, anonymous, priority,\n\t\t\tallowPingbacks, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tString subject, String body, String format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isSpam(userId, body, serviceContext)) {\n\t\t\tthrow new MessageBodyException();\n\t\t}\n\n\t\treturn super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, subject, body, format,\n\t\t\tinputStreamOVPs, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\t}","id":45621,"modified_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tString subject, String body, String format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, subject, body, format,\n\t\t\tinputStreamOVPs, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, long threadId, long parentMessageId, String subject,\n\t\t\tString body, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isSpam(userId, body, serviceContext)) {\n\t\t\tthrow new MessageBodyException();\n\t\t}\n\n\t\treturn super.addDiscussionMessage(\n\t\t\tuserId, userName, groupId, className, classPK, threadId,\n\t\t\tparentMessageId, subject, body, serviceContext);\n\t}","id":45622,"modified_method":"@Override\n\tpublic MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, long threadId, long parentMessageId, String subject,\n\t\t\tString body, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isDiscussionsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addDiscussionMessage(\n\t\t\tuserId, userName, groupId, className, classPK, threadId,\n\t\t\tparentMessageId, subject, body, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage updateDiscussionMessage(\n\t\t\tlong userId, long messageId, String className, long classPK,\n\t\t\tString subject, String body, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isSpam(userId, body, serviceContext)) {\n\t\t\tthrow new MessageBodyException();\n\t\t}\n\n\t\treturn super.updateDiscussionMessage(\n\t\t\tuserId, messageId, className, classPK, subject, body,\n\t\t\tserviceContext);\n\t}","id":45623,"modified_method":"@Override\n\tpublic MBMessage updateDiscussionMessage(\n\t\t\tlong userId, long messageId, String className, long classPK,\n\t\t\tString subject, String body, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isDiscussionsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.updateDiscussionMessage(\n\t\t\tuserId, messageId, className, classPK, subject, body,\n\t\t\tserviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isSpam(userId, body, serviceContext)) {\n\t\t\tthrow new MessageBodyException();\n\t\t}\n\n\t\treturn super.updateMessage(\n\t\t\tuserId, messageId, subject, body, inputStreamOVPs, existingFiles,\n\t\t\tpriority, allowPingbacks, serviceContext);\n\t}","id":45624,"modified_method":"@Override\n\tpublic MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.updateMessage(\n\t\t\tuserId, messageId, subject, body, inputStreamOVPs, existingFiles,\n\t\t\tpriority, allowPingbacks, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static boolean isSpam(\n\t\t\tlong companyId, String ipAddress, String userAgent, String referrer,\n\t\t\tString permalink, String commentType, String userName,\n\t\t\tString emailAddress, String content)\n\t\tthrows PortalException, SystemException {\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(Http.HTTP_WITH_SLASH);\n\t\tsb.append(\n\t\t\tPrefsPortletPropsUtil.getString(\n\t\t\t\tcompanyId, PortletPropsKeys.AKISMET_API_KEY));\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(AkismetConstants.REST_URL);\n\t\tsb.append(AkismetConstants.CHECK_SPAM_PATH);\n\n\t\tString location = sb.toString();\n\n\t\tMap<String, String> parts = new HashMap<String, String>();\n\n\t\tparts.put(\"blog\", _getPortalURL(companyId));\n\t\tparts.put(\"comment_author\", userName);\n\t\tparts.put(\"comment_author_email\", emailAddress);\n\t\tparts.put(\"comment_content\", content);\n\t\tparts.put(\"comment_type\", commentType);\n\t\tparts.put(\"permalink\", permalink);\n\t\tparts.put(\"referrer\", referrer);\n\t\tparts.put(\"user_agent\", userAgent);\n\t\tparts.put(\"user_ip\", ipAddress);\n\n\t\tString response = _sendRequest(location, parts);\n\n\t\tif (Validator.isNull(response) || response.equals(\"invalid\")) {\n\t\t\t_log.error(\"There was an issue with Akismet comment validation\");\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (response.equals(\"true\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":45625,"modified_method":"public static boolean isSpam(\n\t\t\tlong companyId, String ipAddress, String userAgent, String referrer,\n\t\t\tString permalink, String commentType, String userName,\n\t\t\tString emailAddress, String content)\n\t\tthrows PortalException, SystemException {\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(Http.HTTP_WITH_SLASH);\n\t\tsb.append(\n\t\t\tPrefsPortletPropsUtil.getString(\n\t\t\t\tcompanyId, PortletPropsKeys.AKISMET_API_KEY));\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(AkismetConstants.REST_URL);\n\t\tsb.append(AkismetConstants.PATH_CHECK_SPAM);\n\n\t\tString location = sb.toString();\n\n\t\tString response = _sendRequest(\n\t\t\tlocation, companyId, ipAddress, userAgent, referrer, permalink,\n\t\t\tcommentType, userName, emailAddress, content);\n\n\t\tif (Validator.isNull(response) || response.equals(\"invalid\")) {\n\t\t\t_log.error(\"There was an issue with Akismet comment validation\");\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (response.equals(\"true\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static boolean verifyApiKey(long companyId, String apiKey)\n\t\tthrows PortalException, SystemException {\n\n\t\tString location =\n\t\t\tHttp.HTTP_WITH_SLASH + AkismetConstants.REST_URL +\n\t\t\t\tAkismetConstants.VERIFY_PATH;\n\n\t\tMap<String, String> parts = new HashMap<String, String>();\n\n\t\tparts.put(\"blog\", _getPortalURL(companyId));\n\t\tparts.put(\"key\", apiKey);\n\n\t\tString response = _sendRequest(location, parts);\n\n\t\tif (response.equals(\"valid\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":45626,"modified_method":"public static boolean verifyApiKey(long companyId, String apiKey)\n\t\tthrows PortalException, SystemException {\n\n\t\tString location =\n\t\t\tHttp.HTTP_WITH_SLASH + AkismetConstants.REST_URL +\n\t\t\t\tAkismetConstants.PATH_VERIFY;\n\n\t\tMap<String, String> parts = new HashMap<String, String>();\n\n\t\tparts.put(\"blog\", _getPortalURL(companyId));\n\t\tparts.put(\"key\", apiKey);\n\n\t\tString response = _sendRequest(location, parts);\n\n\t\tif (response.equals(\"valid\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static boolean isEnabled(long companyId) throws SystemException {\n\t\tPortletPreferences preferences =\n\t\t\tPrefsPortletPropsUtil.getPortletPreferences(companyId);\n\n\t\treturn GetterUtil.getBoolean(\n\t\t\tpreferences.getValue(\"enabled\", String.valueOf(Boolean.TRUE)));\n\t}","id":45627,"modified_method":"public static boolean isDiscussionsEnabled(long companyId)\n\t\tthrows SystemException {\n\n\t\treturn PrefsPortletPropsUtil.getBoolean(\n\t\t\tcompanyId, PortletPropsKeys.AKISMET_DISCUSSIONS_CHECK_ENABLED);\n\t}","commit_id":"ff3992f4a2fc274c7bd5626836e15652a5ea2c66","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tString format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, format, inputStreamOVPs, anonymous, priority,\n\t\t\tallowPingbacks, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","id":45628,"modified_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tString format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId, groupId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, format, inputStreamOVPs, anonymous, priority,\n\t\t\tallowPingbacks, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"40c63cac27f00880dfad040429bfd115de47cd82","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected boolean isMessageBoardsEnabled(long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tif (AkismetUtil.isMessageBoardsEnabled(user.getCompanyId())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":45629,"modified_method":"protected boolean isMessageBoardsEnabled(long userId, long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tif (!AkismetUtil.isMessageBoardsEnabled(user.getCompanyId())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint checkThreshold = PrefsPortletPropsUtil.getInteger(\n\t\t\tuser.getCompanyId(), PortletPropsKeys.AKISMET_CHECK_THRESHOLD);\n\n\t\tif (checkThreshold > 0) {\n\t\t\tint userMessagesCount = super.getGroupMessagesCount(\n\t\t\t\tgroupId, userId, WorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif (userMessagesCount > checkThreshold) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"40c63cac27f00880dfad040429bfd115de47cd82","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.updateMessage(\n\t\t\tuserId, messageId, subject, body, inputStreamOVPs, existingFiles,\n\t\t\tpriority, allowPingbacks, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","id":45630,"modified_method":"@Override\n\tpublic MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = super.getMBMessage(messageId);\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId, message.getGroupId());\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tmessage = super.updateMessage(\n\t\t\tuserId, messageId, subject, body, inputStreamOVPs, existingFiles,\n\t\t\tpriority, allowPingbacks, serviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"40c63cac27f00880dfad040429bfd115de47cd82","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tString subject, String body, String format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, subject, body, format,\n\t\t\tinputStreamOVPs, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","id":45631,"modified_method":"@Override\n\tpublic MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tString subject, String body, String format,\n\t\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean enabled = isMessageBoardsEnabled(userId, groupId);\n\n\t\tif (enabled) {\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t}\n\n\t\tMBMessage message = super.addMessage(\n\t\t\tuserId, userName, groupId, categoryId, subject, body, format,\n\t\t\tinputStreamOVPs, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\tAkismetData akismetData = updateAkismetData(message, serviceContext);\n\n\t\tif (!enabled) {\n\t\t\treturn message;\n\t\t}\n\n\t\tint status = WorkflowConstants.STATUS_APPROVED;\n\n\t\tif (isSpam(userId, subject, body, akismetData)) {\n\t\t\tstatus = WorkflowConstants.STATUS_DENIED;\n\t\t}\n\n\t\treturn super.updateStatus(\n\t\t\tuserId, message.getMessageId(), status, serviceContext);\n\t}","commit_id":"40c63cac27f00880dfad040429bfd115de47cd82","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void updateConfiguration(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString apiKey = ParamUtil.getString(actionRequest, \"apiKey\");\n\t\tboolean discussionsEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"discussionsEnabled\");\n\t\tboolean messageBoardsEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"messageBoardsEnabled\");\n\t\tint reportableTime = ParamUtil.getInteger(\n\t\t\tactionRequest, \"reportableTime\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPrefsPortletPropsUtil.getPortletPreferences(\n\t\t\t\tthemeDisplay.getCompanyId());\n\n\t\tpreferences.setValue(PortletPropsKeys.AKISMET_API_KEY, apiKey);\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_DISCUSSIONS_CHECK_ENABLED,\n\t\t\tString.valueOf(discussionsEnabled));\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_MESSAGE_BOARDS_CHECK_ENABLED,\n\t\t\tString.valueOf(messageBoardsEnabled));\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_REPORTABLE_TIME,\n\t\t\tString.valueOf(reportableTime));\n\n\t\tpreferences.store();\n\n\t\tif (!AkismetUtil.verifyApiKey(themeDisplay.getCompanyId(), apiKey)) {\n\t\t\tSessionErrors.add(actionRequest, \"apiKeyError\");\n\t\t}\n\t}","id":45632,"modified_method":"public void updateConfiguration(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString apiKey = ParamUtil.getString(actionRequest, \"apiKey\");\n\t\tint checkThreshold = ParamUtil.getInteger(\n\t\t\tactionRequest, \"checkThreshold\");\n\t\tboolean discussionsEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"discussionsEnabled\");\n\t\tboolean messageBoardsEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"messageBoardsEnabled\");\n\t\tint reportableTime = ParamUtil.getInteger(\n\t\t\tactionRequest, \"reportableTime\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPrefsPortletPropsUtil.getPortletPreferences(\n\t\t\t\tthemeDisplay.getCompanyId());\n\n\t\tpreferences.setValue(PortletPropsKeys.AKISMET_API_KEY, apiKey);\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_CHECK_THRESHOLD,\n\t\t\tString.valueOf(checkThreshold));\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_DISCUSSIONS_CHECK_ENABLED,\n\t\t\tString.valueOf(discussionsEnabled));\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_MESSAGE_BOARDS_CHECK_ENABLED,\n\t\t\tString.valueOf(messageBoardsEnabled));\n\t\tpreferences.setValue(\n\t\t\tPortletPropsKeys.AKISMET_REPORTABLE_TIME,\n\t\t\tString.valueOf(reportableTime));\n\n\t\tpreferences.store();\n\n\t\tif (!AkismetUtil.verifyApiKey(themeDisplay.getCompanyId(), apiKey)) {\n\t\t\tSessionErrors.add(actionRequest, \"apiKeyError\");\n\t\t}\n\t}","commit_id":"40c63cac27f00880dfad040429bfd115de47cd82","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updateMessage(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\t\tlong categoryId = ParamUtil.getLong(actionRequest, \"mbCategoryId\");\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\t\tboolean attachments = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"attachments\");\n\n\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\n\t\tif (attachments) {\n\t\t\tUploadPortletRequest uploadRequest =\n\t\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\t\tFile file = uploadRequest.getFile(\"msgFile\" + i);\n\t\t\t\tString fileName = uploadRequest.getFileName(\"msgFile\" + i);\n\t\t\t\tbyte[] bytes = FileUtil.getBytes(file);\n\n\t\t\t\tif ((bytes != null) && (bytes.length > 0)) {\n\t\t\t\t\tObjectValuePair<String, byte[]> ovp =\n\t\t\t\t\t\tnew ObjectValuePair<String, byte[]>(fileName, bytes);\n\n\t\t\t\t\tfiles.add(ovp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean question = ParamUtil.getBoolean(actionRequest, \"question\");\n\t\tboolean anonymous = ParamUtil.getBoolean(actionRequest, \"anonymous\");\n\t\tdouble priority = ParamUtil.getDouble(actionRequest, \"priority\");\n\t\tboolean allowPingbacks = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowPingbacks\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\t\t\tif (PropsValues.CAPTCHA_CHECK_PORTLET_MESSAGE_BOARDS_EDIT_MESSAGE) {\n\t\t\t\tCaptchaUtil.check(actionRequest);\n\t\t\t}\n\n\t\t\tif (threadId <= 0) {\n\n\t\t\t\t// Post new thread\n\n\t\t\t\tmessage = MBMessageServiceUtil.addMessage(\n\t\t\t\t\tgroupId, categoryId, subject, body, files, anonymous,\n\t\t\t\t\tpriority, allowPingbacks, serviceContext);\n\n\t\t\t\tif (question) {\n\t\t\t\t\tMBMessageFlagLocalServiceUtil.addQuestionFlag(\n\t\t\t\t\t\tmessage.getMessageId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Post reply\n\n\t\t\t\tmessage = MBMessageServiceUtil.addMessage(\n\t\t\t\t\tgroupId, categoryId, threadId, parentMessageId, subject,\n\t\t\t\t\tbody, files, anonymous, priority, allowPingbacks,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tList<String> existingFiles = new ArrayList<String>();\n\n\t\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\t\tString path = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"existingPath\" + i);\n\n\t\t\t\tif (Validator.isNotNull(path)) {\n\t\t\t\t\texistingFiles.add(path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateMessage(\n\t\t\t\tmessageId, subject, body, files, existingFiles, priority,\n\t\t\t\tallowPingbacks, serviceContext);\n\n\t\t\tif (message.isRoot()) {\n\t\t\t\tif (question) {\n\t\t\t\t\tMBMessageFlagLocalServiceUtil.addQuestionFlag(messageId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMBMessageFlagLocalServiceUtil.deleteQuestionAndAnswerFlags(\n\t\t\t\t\t\tmessage.getThreadId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPortletURL portletURL =\n\t\t\t((ActionResponseImpl)actionResponse).createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/message_boards/view_message\");\n\t\tportletURL.setParameter(\n\t\t\t\"messageId\", String.valueOf(message.getMessageId()));\n\n\t\tactionResponse.sendRedirect(portletURL.toString());\n\t}","id":45633,"modified_method":"protected MBMessage updateMessage(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\t\tlong categoryId = ParamUtil.getLong(actionRequest, \"mbCategoryId\");\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\t\tboolean attachments = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"attachments\");\n\n\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\n\t\tif (attachments) {\n\t\t\tUploadPortletRequest uploadRequest =\n\t\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\t\tFile file = uploadRequest.getFile(\"msgFile\" + i);\n\t\t\t\tString fileName = uploadRequest.getFileName(\"msgFile\" + i);\n\t\t\t\tbyte[] bytes = FileUtil.getBytes(file);\n\n\t\t\t\tif ((bytes != null) && (bytes.length > 0)) {\n\t\t\t\t\tObjectValuePair<String, byte[]> ovp =\n\t\t\t\t\t\tnew ObjectValuePair<String, byte[]>(fileName, bytes);\n\n\t\t\t\t\tfiles.add(ovp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean question = ParamUtil.getBoolean(actionRequest, \"question\");\n\t\tboolean anonymous = ParamUtil.getBoolean(actionRequest, \"anonymous\");\n\t\tdouble priority = ParamUtil.getDouble(actionRequest, \"priority\");\n\t\tboolean allowPingbacks = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowPingbacks\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\t\t\tif (PropsValues.CAPTCHA_CHECK_PORTLET_MESSAGE_BOARDS_EDIT_MESSAGE) {\n\t\t\t\tCaptchaUtil.check(actionRequest);\n\t\t\t}\n\n\t\t\tif (threadId <= 0) {\n\n\t\t\t\t// Post new thread\n\n\t\t\t\tmessage = MBMessageServiceUtil.addMessage(\n\t\t\t\t\tgroupId, categoryId, subject, body, files, anonymous,\n\t\t\t\t\tpriority, allowPingbacks, serviceContext);\n\n\t\t\t\tif (question) {\n\t\t\t\t\tMBMessageFlagLocalServiceUtil.addQuestionFlag(\n\t\t\t\t\t\tmessage.getMessageId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Post reply\n\n\t\t\t\tmessage = MBMessageServiceUtil.addMessage(\n\t\t\t\t\tgroupId, categoryId, threadId, parentMessageId, subject,\n\t\t\t\t\tbody, files, anonymous, priority, allowPingbacks,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tList<String> existingFiles = new ArrayList<String>();\n\n\t\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\t\tString path = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"existingPath\" + i);\n\n\t\t\t\tif (Validator.isNotNull(path)) {\n\t\t\t\t\texistingFiles.add(path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateMessage(\n\t\t\t\tmessageId, subject, body, files, existingFiles, priority,\n\t\t\t\tallowPingbacks, serviceContext);\n\n\t\t\tif (message.isRoot()) {\n\t\t\t\tif (question) {\n\t\t\t\t\tMBMessageFlagLocalServiceUtil.addQuestionFlag(messageId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMBMessageFlagLocalServiceUtil.deleteQuestionAndAnswerFlags(\n\t\t\t\t\t\tmessage.getThreadId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tupdateMessage(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.LOCK)) {\n\t\t\t\tlockThread(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribeMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNLOCK)) {\n\t\t\t\tunlockThread(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribeMessage(actionRequest);\n\t\t\t}\n\n\t\t\tif (cmd.equals(Constants.DELETE) ||\n\t\t\t\tcmd.equals(Constants.LOCK) ||\n\t\t\t\tcmd.equals(Constants.SUBSCRIBE) ||\n\t\t\t\tcmd.equals(Constants.UNSUBSCRIBE) ||\n\t\t\t\tcmd.equals(Constants.UNLOCK)) {\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof CaptchaTextException ||\n\t\t\t\t\t e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof LockedThreadException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof AssetTagException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":45634,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tMBMessage message = null;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tmessage = updateMessage(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.LOCK)) {\n\t\t\t\tlockThread(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribeMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNLOCK)) {\n\t\t\t\tunlockThread(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribeMessage(actionRequest);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tString redirect = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"redirect\");\n\n\t\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\n\t\t\t\tif ((message != null) &&\n\t\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\t\tactionResponse, message);\n\t\t\t\t}\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof CaptchaTextException ||\n\t\t\t\t\t e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof LockedThreadException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof AssetTagException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tindexer.delete(message);\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\t\telse if (mbMessageFlagLocalService.hasAnswerFlag(\n\t\t\t\t\tmessage.getMessageId())) {\n\n\t\t\tmbMessageFlagService.deleteAnswerFlag(message.getMessageId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","id":45635,"modified_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tindexer.delete(message);\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\t\telse if (mbMessageFlagLocalService.hasAnswerFlag(\n\t\t\t\t\tmessage.getMessageId())) {\n\n\t\t\tmbMessageFlagService.deleteAnswerFlag(message.getMessageId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\n\t\t// Workflow\n\n\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLink(\n\t\t\tmessage.getCompanyId(), message.getGroupId(),\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext, boolean update)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getScopeGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","id":45636,"modified_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getScopeGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessageDisplay getMessageDisplay(\n\t\t\tMBMessage message, int status, String threadView)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tmessage.getCategoryId());\n\n\t\tMBMessage parentMessage = null;\n\n\t\tif (message.isReply()) {\n\t\t\tparentMessage = mbMessagePersistence.findByPrimaryKey(\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbThreadLocalService.updateThread(\n\t\t\t\tthread.getThreadId(), thread.getViewCount() + 1);\n\t\t}\n\n\t\tThreadLastPostDateComparator comparator =\n\t\t\tnew ThreadLastPostDateComparator(false);\n\n\t\tMBThread[] prevAndNextThreads =\n\t\t\tmbThreadPersistence.findByG_C_PrevAndNext(\n\t\t\t\tmessage.getThreadId(), message.getGroupId(),\n\t\t\t\tmessage.getCategoryId(), comparator);\n\n\t\tMBThread previousThread = prevAndNextThreads[0];\n\t\tMBThread nextThread = prevAndNextThreads[2];\n\n\t\treturn new MBMessageDisplayImpl(\n\t\t\tmessage, parentMessage, category, thread,\n\t\t\tpreviousThread, nextThread, status, threadView);\n\t}","id":45637,"modified_method":"public MBMessageDisplay getMessageDisplay(\n\t\t\tMBMessage message, int status, String threadView)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tmessage.getCategoryId());\n\n\t\tMBMessage parentMessage = null;\n\n\t\tif (message.isReply()) {\n\t\t\tparentMessage = mbMessagePersistence.findByPrimaryKey(\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tmbThreadLocalService.updateThread(\n\t\t\t\tthread.getThreadId(), thread.getViewCount() + 1);\n\t\t}\n\n\t\tMBThread previousThread = null;\n\t\tMBThread nextThread = null;\n\n\t\tif (message.getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tThreadLastPostDateComparator comparator =\n\t\t\t\tnew ThreadLastPostDateComparator(false);\n\n\t\t\tMBThread[] prevAndNextThreads =\n\t\t\t\tmbThreadPersistence.findByG_C_PrevAndNext(\n\t\t\t\t\tmessage.getThreadId(), message.getGroupId(),\n\t\t\t\t\tmessage.getCategoryId(), comparator);\n\n\t\t\tpreviousThread = prevAndNextThreads[0];\n\t\t\tnextThread = prevAndNextThreads[2];\n\t\t}\n\n\t\treturn new MBMessageDisplayImpl(\n\t\t\tmessage, parentMessage, category, thread,\n\t\t\tpreviousThread, nextThread, status, threadView);\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tint status = WorkflowConstants.STATUS_DRAFT;\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tstatus = WorkflowConstants.STATUS_APPROVED;\n\t\t}\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tif ((status ==\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t(categoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (anonymous) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(userId);\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Statistics\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t// Category\n\n\t\t\tif (categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(message, serviceContext, false);\n\n\t\t// Ping\n\n\t\tpingPingback(message, serviceContext);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tindexer.reindex(message);\n\n\t\treturn message;\n\t}","id":45638,"modified_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), message,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\treturn message;\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\treturn updateStatus(userId, message, serviceContext, true);\n\t}","id":45639,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif (thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t}\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Asset\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.reindex(message);\n\n\t\t\t\t// Social\n\n\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\n\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\tlong receiverUserId = 0;\n\n\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t\t\t}\n\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\t\t\treceiverUserId);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tnotifySubscribers(message, serviceContext);\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Asset\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tMBCategory category = message.getCategory();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Status\n\n\t\tint status = WorkflowConstants.STATUS_DRAFT;\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tstatus = WorkflowConstants.STATUS_APPROVED;\n\t\t}\n\n\t\tif (oldStatus != status) {\n\t\t\tmessage = updateStatus(\n\t\t\t\tuserId, message, serviceContext, false);\n\t\t}\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Category\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tcategory.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Subscriptions\n\n\t\tboolean update = true;\n\n\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tupdate = false;\n\t\t}\n\n\t\tnotifySubscribers(message, serviceContext, update);\n\n\t\t// Ping\n\n\t\tpingPingback(message, serviceContext);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tindexer.reindex(message);\n\n\t\treturn message;\n\t}","id":45640,"modified_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tserviceContext.setAttribute(\"update\", Boolean.TRUE.toString());\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tcompanyId, message.getGroupId(), userId,\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), message,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportMessage(\n\t\t\tPortletDataContext context, Element categoriesEl,\n\t\t\tElement messagesEl, Element messageFlagsEl, MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(message.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\texportParentCategory(context, categoriesEl, message.getCategoryId());\n\n\t\tString path = getMessagePath(context, message);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement messageEl = messagesEl.addElement(\"message\");\n\n\t\t\tmessageEl.addAttribute(\"path\", path);\n\n\t\t\tmessage.setUserUuid(message.getUserUuid());\n\t\t\tmessage.setPriority(message.getPriority());\n\n\t\t\tcontext.addPermissions(MBMessage.class, message.getMessageId());\n\n\t\t\tcontext.addLocks(\n\t\t\t\tMBThread.class, String.valueOf(message.getThreadId()));\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.addRatingsEntries(\n\t\t\t\t\tMBMessage.class, message.getMessageId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(MBMessage.class, message.getMessageId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tmessage.isAttachments()) {\n\n\t\t\t\tfor (String attachment : message.getAttachmentsFiles()) {\n\t\t\t\t\tint pos = attachment.lastIndexOf(StringPool.FORWARD_SLASH);\n\n\t\t\t\t\tString name = attachment.substring(pos + 1);\n\t\t\t\t\tString binPath = getMessageAttachementBinPath(\n\t\t\t\t\t\tcontext, message, name);\n\n\t\t\t\t\tElement attachmentEl = messageEl.addElement(\"attachment\");\n\n\t\t\t\t\tattachmentEl.addAttribute(\"name\", name);\n\t\t\t\t\tattachmentEl.addAttribute(\"bin-path\", binPath);\n\n\t\t\t\t\tbyte[] bytes = DLServiceUtil.getFile(\n\t\t\t\t\t\tcontext.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\t\t\tattachment);\n\n\t\t\t\t\tcontext.addZipEntry(binPath, bytes);\n\t\t\t\t}\n\n\t\t\t\tmessage.setAttachmentsDir(message.getAttachmentsDir());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"flags\")) {\n\t\t\t\tList<MBMessageFlag> messageFlags =\n\t\t\t\t\tMBMessageFlagUtil.findByMessageId(\n\t\t\t\t\t\tmessage.getMessageId());\n\n\t\t\t\tfor (MBMessageFlag messageFlag : messageFlags) {\n\t\t\t\t\texportMessageFlag(context, messageFlagsEl, messageFlag);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.addZipEntry(path, message);\n\t\t}\n\t}","id":45641,"modified_method":"protected void exportMessage(\n\t\t\tPortletDataContext context, Element categoriesEl,\n\t\t\tElement messagesEl, Element messageFlagsEl, MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(message.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\texportParentCategory(context, categoriesEl, message.getCategoryId());\n\n\t\tString path = getMessagePath(context, message);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement messageEl = messagesEl.addElement(\"message\");\n\n\t\t\tmessageEl.addAttribute(\"path\", path);\n\n\t\t\tmessage.setUserUuid(message.getUserUuid());\n\t\t\tmessage.setPriority(message.getPriority());\n\n\t\t\tcontext.addPermissions(MBMessage.class, message.getMessageId());\n\n\t\t\tcontext.addLocks(\n\t\t\t\tMBThread.class, String.valueOf(message.getThreadId()));\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.addRatingsEntries(\n\t\t\t\t\tMBMessage.class, message.getMessageId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(MBMessage.class, message.getMessageId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tmessage.isAttachments()) {\n\n\t\t\t\tfor (String attachment : message.getAttachmentsFiles()) {\n\t\t\t\t\tint pos = attachment.lastIndexOf(StringPool.FORWARD_SLASH);\n\n\t\t\t\t\tString name = attachment.substring(pos + 1);\n\t\t\t\t\tString binPath = getMessageAttachementBinPath(\n\t\t\t\t\t\tcontext, message, name);\n\n\t\t\t\t\tElement attachmentEl = messageEl.addElement(\"attachment\");\n\n\t\t\t\t\tattachmentEl.addAttribute(\"name\", name);\n\t\t\t\t\tattachmentEl.addAttribute(\"bin-path\", binPath);\n\n\t\t\t\t\tbyte[] bytes = DLServiceUtil.getFile(\n\t\t\t\t\t\tcontext.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\t\t\tattachment);\n\n\t\t\t\t\tcontext.addZipEntry(binPath, bytes);\n\t\t\t\t}\n\n\t\t\t\tmessage.setAttachmentsDir(message.getAttachmentsDir());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"flags\")) {\n\t\t\t\tList<MBMessageFlag> messageFlags =\n\t\t\t\t\tMBMessageFlagUtil.findByMessageId(\n\t\t\t\t\t\tmessage.getMessageId());\n\n\t\t\t\tfor (MBMessageFlag messageFlag : messageFlags) {\n\t\t\t\t\texportMessageFlag(context, messageFlagsEl, messageFlag);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.addZipEntry(path, message);\n\t\t}\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward render(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tlong messageId = ParamUtil.getLong(renderRequest, \"messageId\");\n\n\t\t\tPortalPreferences preferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\trenderRequest);\n\n\t\t\tString threadView = ParamUtil.getString(\n\t\t\t\trenderRequest, \"threadView\");\n\n\t\t\tif (Validator.isNotNull(threadView)) {\n\t\t\t\tpreferences.setValue(\n\t\t\t\t\tPortletKeys.MESSAGE_BOARDS, \"thread-view\", threadView);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthreadView = preferences.getValue(\n\t\t\t\t\tPortletKeys.MESSAGE_BOARDS, \"thread-view\",\n\t\t\t\t\tPropsValues.MESSAGE_BOARDS_THREAD_VIEWS_DEFAULT);\n\t\t\t}\n\n\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\tPropsValues.MESSAGE_BOARDS_THREAD_VIEWS, threadView)) {\n\n\t\t\t\tthreadView = PropsValues.MESSAGE_BOARDS_THREAD_VIEWS_DEFAULT;\n\n\t\t\t\tpreferences.setValue(\n\t\t\t\t\tPortletKeys.MESSAGE_BOARDS, \"thread-view\", threadView);\n\t\t\t}\n\n\t\t\tMBMessageDisplay messageDisplay =\n\t\t\t\tMBMessageServiceUtil.getMessageDisplay(\n\t\t\t\t\tmessageId, WorkflowConstants.STATUS_APPROVED, threadView);\n\n\t\t\trenderRequest.setAttribute(\n\t\t\t\tWebKeys.MESSAGE_BOARDS_MESSAGE, messageDisplay);\n\n\t\t\treturn mapping.findForward(\"portlet.message_boards.view_message\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(renderRequest, e.getClass().getName());\n\n\t\t\t\treturn mapping.findForward(\"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":45642,"modified_method":"public ActionForward render(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tlong messageId = ParamUtil.getLong(renderRequest, \"messageId\");\n\n\t\t\tPortalPreferences preferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\trenderRequest);\n\n\t\t\tString threadView = ParamUtil.getString(\n\t\t\t\trenderRequest, \"threadView\");\n\n\t\t\tif (Validator.isNotNull(threadView)) {\n\t\t\t\tpreferences.setValue(\n\t\t\t\t\tPortletKeys.MESSAGE_BOARDS, \"thread-view\", threadView);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthreadView = preferences.getValue(\n\t\t\t\t\tPortletKeys.MESSAGE_BOARDS, \"thread-view\",\n\t\t\t\t\tPropsValues.MESSAGE_BOARDS_THREAD_VIEWS_DEFAULT);\n\t\t\t}\n\n\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\tPropsValues.MESSAGE_BOARDS_THREAD_VIEWS, threadView)) {\n\n\t\t\t\tthreadView = PropsValues.MESSAGE_BOARDS_THREAD_VIEWS_DEFAULT;\n\n\t\t\t\tpreferences.setValue(\n\t\t\t\t\tPortletKeys.MESSAGE_BOARDS, \"thread-view\", threadView);\n\t\t\t}\n\n\t\t\tMBMessageDisplay messageDisplay =\n\t\t\t\tMBMessageServiceUtil.getMessageDisplay(\n\t\t\t\t\tmessageId, WorkflowConstants.STATUS_ANY, threadView);\n\n\t\t\trenderRequest.setAttribute(\n\t\t\t\tWebKeys.MESSAGE_BOARDS_MESSAGE, messageDisplay);\n\n\t\t\treturn mapping.findForward(\"portlet.message_boards.view_message\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(renderRequest, e.getClass().getName());\n\n\t\t\t\treturn mapping.findForward(\"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"30afd067b10a99cd6e3a71e1201db2a563a435b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Map<String, Integer> calculateCaps() {\n        Map<String, Integer> capSizes = new HashMap<String, Integer>();\n        for (Map.Entry<String, Integer> entry : DEFAULT_CAP_SIZES.entrySet()) {\n            capSizes.put(entry.getKey(), sizer.scaleCacheSize(entry.getValue()));\n        }\n        return capSizes;\n    }","id":45643,"modified_method":"private Map<String, Integer> calculateCaps() {\n        Map<String, Integer> capSizes = new HashMap<String, Integer>();\n        for (Map.Entry<String, Integer> entry : DEFAULT_CAP_SIZES.entrySet()) {\n            capSizes.put(entry.getKey(), scaleCacheSize(entry.getValue()));\n        }\n        return capSizes;\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"public <K, V> PersistentIndexedCache<K, V> createCache(final String cacheName, final Class<K> keyType, final Serializer<V> valueSerializer) {\n        PersistentIndexedCacheParameters<K, V> parameters = new PersistentIndexedCacheParameters<K, V>(cacheName, keyType, valueSerializer)\n                .cacheDecorator(cacheDecorator);\n        return cache.createCache(parameters);\n    }","id":45644,"modified_method":"public <K, V> PersistentIndexedCache<K, V> createCache(final String cacheName, final Class<K> keyType, final Serializer<V> valueSerializer) {\n        PersistentIndexedCacheParameters<K, V> parameters = new PersistentIndexedCacheParameters<K, V>(cacheName, keyType, valueSerializer)\n                .cacheDecorator(inMemoryTaskArtifactCache);\n        return cache.createCache(parameters);\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultTaskHistoryStore(Gradle gradle, CacheRepository cacheRepository, CacheDecorator decorator) {\n        this.cacheDecorator = decorator;\n        cache = cacheRepository\n                .cache(gradle, \"taskArtifacts\")\n                .withDisplayName(\"task history cache\")\n                .withLockOptions(mode(FileLockManager.LockMode.None)) // Lock on demand\n                .open();\n    }","id":45645,"modified_method":"public DefaultTaskHistoryStore(Gradle gradle, CacheRepository cacheRepository, InMemoryTaskArtifactCache inMemoryTaskArtifactCache) {\n        this.inMemoryTaskArtifactCache = inMemoryTaskArtifactCache;\n        cache = cacheRepository\n                .cache(gradle, \"taskArtifacts\")\n                .withDisplayName(\"task history cache\")\n                .withLockOptions(mode(FileLockManager.LockMode.None)) // Lock on demand\n                .open();\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void flush() {\n        cache.flush();\n    }","id":45646,"modified_method":"@Override\n    public void flush() {\n        cache.flush();\n        inMemoryTaskArtifactCache.onFlush();\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"InMemoryTaskArtifactCache createInMemoryTaskArtifactCache() {\n        return new InMemoryTaskArtifactCache();\n    }","id":45647,"modified_method":"InMemoryTaskArtifactCache createInMemoryTaskArtifactCache() {\n        if(environment.isLongLivingProcess()) {\n            return new InMemoryTaskArtifactCache();\n        } else {\n            // drop caches on memory pressure\n            return new SoftInMemoryTaskArtifactCache();\n        }\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"InMemoryTaskArtifactCache(CacheCapSizer cacheCapSizer) {\n        this.cacheCapSizer = cacheCapSizer;\n        this.cache = CacheBuilder.newBuilder()\n                .maximumSize(cacheCapSizer.getNumberOfCaches() * 2) //X2 to factor in a child build (for example buildSrc)\n                .build();\n    }","id":45648,"modified_method":"InMemoryTaskArtifactCache(CacheCapSizer cacheCapSizer) {\n        this.cacheCapSizer = cacheCapSizer;\n        final CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                .maximumSize(cacheCapSizer.getNumberOfCaches() * 2);\n        configureCacheHolderCache(cacheBuilder);\n        this.cache = cacheBuilder //X2 to factor in a child build (for example buildSrc)\n                .build();\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"private Cache<Object, Object> createInMemoryCache(String cacheId, String cacheName) {\n        Cache<Object, Object> inMemoryCache = this.cache.getIfPresent(cacheId);\n        if (inMemoryCache != null) {\n            LOG.info(\"In-memory cache of {}: Size{{}}, {}\", cacheId, inMemoryCache.size(), inMemoryCache.stats());\n        } else {\n            Integer maxSize = cacheCapSizer.getMaxSize(cacheName);\n            assert maxSize != null : \"Unknown cache.\";\n            LOG.debug(\"Creating In-memory cache of {}: MaxSize{{}}\", cacheId, maxSize);\n            LoggingEvictionListener evictionListener = new LoggingEvictionListener(cacheId, maxSize);\n            inMemoryCache = CacheBuilder.newBuilder().maximumSize(maxSize).recordStats().removalListener(evictionListener).build();\n            evictionListener.setCache(inMemoryCache);\n            this.cache.put(cacheId, inMemoryCache);\n        }\n        return inMemoryCache;\n    }","id":45649,"modified_method":"private Cache<Object, Object> createInMemoryCache(String cacheId, String cacheName) {\n        Cache<Object, Object> inMemoryCache = this.cache.getIfPresent(cacheId);\n        if (inMemoryCache != null) {\n            LOG.info(\"In-memory cache of {}: Size{{}}, {}\", cacheId, inMemoryCache.size(), inMemoryCache.stats());\n        } else {\n            Integer maxSize = cacheCapSizer.getMaxSize(cacheName);\n            assert maxSize != null : \"Unknown cache.\";\n            LOG.debug(\"Creating In-memory cache of {}: MaxSize{{}}\", cacheId, maxSize);\n            LoggingEvictionListener evictionListener = new LoggingEvictionListener(cacheId, maxSize);\n            final CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder().maximumSize(maxSize).recordStats().removalListener(evictionListener);\n            configureInMemoryCache(cacheBuilder, cacheId, cacheName);\n            inMemoryCache = cacheBuilder.build();\n            evictionListener.setCache(inMemoryCache);\n            this.cache.put(cacheId, inMemoryCache);\n        }\n        return inMemoryCache;\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"public synchronized <K, V> MultiProcessSafePersistentIndexedCache<K, V> decorate(String cacheId, String cacheName, MultiProcessSafePersistentIndexedCache<K, V> persistentCache, AsyncCacheAccess asyncCacheAccess) {\n        return new InMemoryDecoratedCache<K, V>(asyncCacheAccess, persistentCache, createInMemoryCache(cacheId, cacheName), cacheId, getFileLockStateReference(cacheId));\n    }","id":45650,"modified_method":"public synchronized <K, V> MultiProcessSafePersistentIndexedCache<K, V> decorate(String cacheId, String cacheName, MultiProcessSafePersistentIndexedCache<K, V> persistentCache, AsyncCacheAccess asyncCacheAccess) {\n        return createInMemoryDecoratedCache(asyncCacheAccess, persistentCache, createInMemoryCache(cacheId, cacheName), cacheId, getFileLockStateReference(cacheId));\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"TaskHistoryStore createCacheAccess(Gradle gradle, CacheRepository cacheRepository, InMemoryTaskArtifactCache inMemoryTaskArtifactCache, GradleBuildEnvironment environment) {\n        CacheDecorator decorator;\n        if (environment.isLongLivingProcess()) {\n            decorator = inMemoryTaskArtifactCache;\n        } else {\n            decorator = new AsyncCacheAccessDecorator();\n        }\n        return new DefaultTaskHistoryStore(gradle, cacheRepository, decorator);\n    }","id":45651,"modified_method":"TaskHistoryStore createCacheAccess(Gradle gradle, CacheRepository cacheRepository, InMemoryTaskArtifactCache inMemoryTaskArtifactCache, GradleBuildEnvironment environment) {\n        return new DefaultTaskHistoryStore(gradle, cacheRepository, inMemoryTaskArtifactCache);\n    }","commit_id":"905c4f9732de6a24e56bff0b6fbe7197be3180bb","url":"https://github.com/gradle/gradle"},{"original_method":"public static List<File> getJavacServerClasspath() {\n    final Set<File> cp = new LinkedHashSet<File>();\n    cp.add(getResourcePath(JavacServer.class));\n    cp.add(getResourcePath(com.google.protobuf.Message.class)); // protobuf\n    cp.add(getResourcePath(org.jboss.netty.bootstrap.Bootstrap.class)); // netty\n    cp.add(getResourcePath(TIntHash.class));  // trove\n    cp.add(getResourcePath(FileUtil.class));  // util module\n    cp.add(getResourcePath(Pointer.class));  // jna.jar\n    cp.add(getResourcePath(com.google.common.collect.MapMaker.class));  // guava\n    cp.add(getResourcePath(FileMonitor.class));  // jna-utils.jar\n    cp.add(getResourcePath(org.jdom.input.SAXBuilder.class));  // jdom\n\n    final Class<StandardJavaFileManager> optimizedFileManagerClass = getOptimizedFileManagerClass();\n    if (optimizedFileManagerClass != null) {\n      cp.add(getResourcePath(optimizedFileManagerClass));  // optimizedFileManager\n    }\n\n    try {\n      final Class<?> cmdLineWrapper = Class.forName(\"com.intellij.rt.execution.CommandLineWrapper\");\n      cp.add(getResourcePath(cmdLineWrapper));  // idea_rt.jar\n    }\n    catch (Throwable ignored) {\n    }\n\n    final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n    if (systemCompiler != null) {\n      try {\n        cp.add(getResourcePath(systemCompiler.getClass()));  // tools.jar\n      }\n      catch (Throwable ignored) {\n      }\n    }\n\n    return new ArrayList<File>(cp);\n  }","id":45652,"modified_method":"public static List<File> getJavacServerClasspath() {\n    final Set<File> cp = new LinkedHashSet<File>();\n    cp.add(getResourcePath(JavacServer.class));\n    cp.add(getResourcePath(com.google.protobuf.Message.class)); // protobuf\n    cp.add(getResourcePath(org.jboss.netty.bootstrap.Bootstrap.class)); // netty\n    cp.add(getResourcePath(TIntHash.class));  // trove\n    cp.add(getResourcePath(FileUtil.class));  // util module\n    cp.add(getResourcePath(Pointer.class));  // jna.jar\n    cp.add(getResourcePath(CacheBuilder.class));  // guava\n    cp.add(getResourcePath(FileMonitor.class));  // jna-utils.jar\n    cp.add(getResourcePath(org.jdom.input.SAXBuilder.class));  // jdom\n\n    final Class<StandardJavaFileManager> optimizedFileManagerClass = getOptimizedFileManagerClass();\n    if (optimizedFileManagerClass != null) {\n      cp.add(getResourcePath(optimizedFileManagerClass));  // optimizedFileManager\n    }\n\n    try {\n      final Class<?> cmdLineWrapper = Class.forName(\"com.intellij.rt.execution.CommandLineWrapper\");\n      cp.add(getResourcePath(cmdLineWrapper));  // idea_rt.jar\n    }\n    catch (Throwable ignored) {\n    }\n\n    final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n    if (systemCompiler != null) {\n      try {\n        cp.add(getResourcePath(systemCompiler.getClass()));  // tools.jar\n      }\n      catch (Throwable ignored) {\n      }\n    }\n\n    return new ArrayList<File>(cp);\n  }","commit_id":"a9fe6a90b69f393b2133342d303e0af49894acf5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<File> getCompileServerApplicationClasspath() {\n    final Set<File> cp = new LinkedHashSet<File>();\n    cp.add(getResourcePath(Server.class));\n    cp.add(getResourcePath(com.google.protobuf.Message.class)); // protobuf\n    cp.add(getResourcePath(org.jboss.netty.bootstrap.Bootstrap.class)); // netty\n    cp.add(getResourcePath(TIntHash.class));  // trove\n    cp.add(getResourcePath(FileUtil.class));  // util module\n    cp.add(getResourcePath(Pointer.class));  // jna.jar\n    cp.add(getResourcePath(com.google.common.collect.MapMaker.class));  // guava\n    cp.add(getResourcePath(FileMonitor.class));  // jna-utils.jar\n    cp.add(getResourcePath(ClassWriter.class));  // asm\n    cp.add(getResourcePath(org.objectweb.asm.commons.EmptyVisitor.class));  // asm-commons\n    cp.add(getResourcePath(MacroExpander.class));  // jps-model\n    cp.add(getResourcePath(AlienFormFileException.class));  // forms-compiler\n    cp.add(getResourcePath(GroovyException.class));  // groovy\n    cp.add(getResourcePath(org.jdom.input.SAXBuilder.class));  // jdom\n    cp.add(getResourcePath(GridConstraints.class));  // forms-rt\n    cp.add(getResourcePath(CellConstraints.class));  // jgoodies-forms\n    cp.add(getResourcePath(NotNullVerifyingInstrumenter.class));  // not-null\n    cp.add(getResourcePath(IXMLBuilder.class));  // nano-xml\n    cp.add(getResourcePath(GroovyCompilerWrapper.class));  // groovy_rt\n    cp.add(getResourcePath(org.apache.log4j.Logger.class)); // log4j\n\n    final Class<StandardJavaFileManager> optimizedFileManagerClass = getOptimizedFileManagerClass();\n    if (optimizedFileManagerClass != null) {\n      cp.add(getResourcePath(optimizedFileManagerClass));  // optimizedFileManager\n    }\n\n    try {\n      final Class<?> cmdLineWrapper = Class.forName(\"com.intellij.rt.execution.CommandLineWrapper\");\n      cp.add(getResourcePath(cmdLineWrapper));  // idea_rt.jar\n    }\n    catch (Throwable ignored) {\n    }\n\n    final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n    if (systemCompiler != null) {\n      try {\n        cp.add(getResourcePath(systemCompiler.getClass()));  // tools.jar\n      }\n      catch (Throwable ignored) {\n      }\n    }\n    return new ArrayList<File>(cp);\n  }","id":45653,"modified_method":"public static List<File> getCompileServerApplicationClasspath() {\n    final Set<File> cp = new LinkedHashSet<File>();\n    cp.add(getResourcePath(Server.class));\n    cp.add(getResourcePath(com.google.protobuf.Message.class)); // protobuf\n    cp.add(getResourcePath(org.jboss.netty.bootstrap.Bootstrap.class)); // netty\n    cp.add(getResourcePath(TIntHash.class));  // trove\n    cp.add(getResourcePath(FileUtil.class));  // util module\n    cp.add(getResourcePath(Pointer.class));  // jna.jar\n    cp.add(getResourcePath(CacheBuilder.class));  // guava\n    cp.add(getResourcePath(FileMonitor.class));  // jna-utils.jar\n    cp.add(getResourcePath(ClassWriter.class));  // asm\n    cp.add(getResourcePath(org.objectweb.asm.commons.EmptyVisitor.class));  // asm-commons\n    cp.add(getResourcePath(MacroExpander.class));  // jps-model\n    cp.add(getResourcePath(AlienFormFileException.class));  // forms-compiler\n    cp.add(getResourcePath(GroovyException.class));  // groovy\n    cp.add(getResourcePath(org.jdom.input.SAXBuilder.class));  // jdom\n    cp.add(getResourcePath(GridConstraints.class));  // forms-rt\n    cp.add(getResourcePath(CellConstraints.class));  // jgoodies-forms\n    cp.add(getResourcePath(NotNullVerifyingInstrumenter.class));  // not-null\n    cp.add(getResourcePath(IXMLBuilder.class));  // nano-xml\n    cp.add(getResourcePath(GroovyCompilerWrapper.class));  // groovy_rt\n    cp.add(getResourcePath(org.apache.log4j.Logger.class)); // log4j\n\n    final Class<StandardJavaFileManager> optimizedFileManagerClass = getOptimizedFileManagerClass();\n    if (optimizedFileManagerClass != null) {\n      cp.add(getResourcePath(optimizedFileManagerClass));  // optimizedFileManager\n    }\n\n    try {\n      final Class<?> cmdLineWrapper = Class.forName(\"com.intellij.rt.execution.CommandLineWrapper\");\n      cp.add(getResourcePath(cmdLineWrapper));  // idea_rt.jar\n    }\n    catch (Throwable ignored) {\n    }\n\n    final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n    if (systemCompiler != null) {\n      try {\n        cp.add(getResourcePath(systemCompiler.getClass()));  // tools.jar\n      }\n      catch (Throwable ignored) {\n      }\n    }\n    return new ArrayList<File>(cp);\n  }","commit_id":"a9fe6a90b69f393b2133342d303e0af49894acf5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentSLRUMap(final int protectedQueueSize, final int probationalQueueSize) {\n    myProtectedQueue = new MapMaker().concurrencyLevel(4).evictionListener(new MapEvictionListener<K, V>() {\n      @Override\n      public void onEviction(K key, V value) {\n        myProbationalQueue.put(key, value); // no size check since it is costly\n      }\n    }).initialCapacity(10).maximumSize(protectedQueueSize).makeMap();\n\n    myProbationalQueue = new MapMaker().concurrencyLevel(4).evictionListener(new MapEvictionListener<K, V>() {\n      @Override\n      public void onEviction(K key, V value) {\n        onDropFromCache(key, value);  // no size check since it is costly\n      }\n    }).initialCapacity(10).maximumSize(probationalQueueSize).makeMap();\n  }","id":45654,"modified_method":"public ConcurrentSLRUMap(final int protectedQueueSize, final int probationalQueueSize) {\n    myProtectedQueue = CacheBuilder.newBuilder().concurrencyLevel(4).removalListener(new RemovalListener<K, V>() {\n      @Override\n      public void onRemoval(RemovalNotification<K, V> notification) {\n        myProbationalQueue.put(notification.getKey(), notification.getValue());\n      }\n    }).initialCapacity(10).maximumSize(protectedQueueSize).<K, V>build().asMap();\n\n    myProbationalQueue = CacheBuilder.newBuilder().concurrencyLevel(4).removalListener(new RemovalListener<K, V>() {\n      @Override\n      public void onRemoval(RemovalNotification<K, V> notification) {\n        onDropFromCache(notification.getKey(), notification.getValue());\n      }\n    }).initialCapacity(10).maximumSize(probationalQueueSize).<K, V>build().asMap();\n  }","commit_id":"a9fe6a90b69f393b2133342d303e0af49894acf5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t\t * Don't actually send an interest\n\t\t */\n\t\t@Override\n\t\tprotected void sendInterest(InterestData id) {\n\t\t\tInterest old = id.getLastInterest();\n\t\t\tInterest interest = id.buildInterest();\n\t\t\tsynchronized(_interestMap) {\n\t\t\t\t// Remove the old interest so we never match more than one\n\t\t\t\t// thing to an INterestData\n\t\t\t\tif( null != old )\n\t\t\t\t\t_interestMap.remove(old);\n\n\t\t\t\ttry {\n\t\t\t\t\tif( _sendInterests )\n\t\t\t\t\t\t_handle.expressInterest(interest, this);\n\t\t\t\t\t_interestMap.put(interest, id);\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":45655,"modified_method":"/**\n\t\t * Don't actually send an interest\n\t\t */\n\t\t@Override\n\t\tprotected void sendInterest(InterestData id) {\n\t\t\tInterest old = id.getLastInterest();\n\t\t\tInterest interest = id.buildInterest();\n\t\t\tsynchronized(_interestMap) {\n\t\t\t\t// Remove the old interest so we never match more than one\n\t\t\t\t// thing to an INterestData\n\t\t\t\tif( null != old )\n\t\t\t\t\t_interestMap.remove(old);\n\n\t\t\t\ttry {\n\t\t\t\t\tif( _sendInterests )\n\t\t\t\t\t\t_handle.expressInterest(interest, this);\n\t\t\t\t\t_interestMap.put(interest, new InterestMapData(id));\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Generate interests and return data to the listener\n\t * @throws IOException \n\t */\n\tpublic synchronized void start() throws IOException {\n\t\t_running = true;\n\t\tgenerateInterests();\n\t}","id":45656,"modified_method":"/**\n\t * Generate interests and return data to the listener\n\t * @throws IOException \n\t */\n\tpublic synchronized void start() throws IOException {\n\t\t//\t\t_running = true;\n\t\tgenerateInterests();\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Send a new interest and manage the _interestMap.  If the\n\t * InterestData has an old interest, we remove it from the map, so\n\t * it will no longer cause a new interest to be sent and then add\n\t * the new interest to the map, so when we receive an object for\n\t * it, we'll issue a new interest.\n\t */\n\tprotected void sendInterest(InterestData id) {\n\t\tInterest old = id.getLastInterest();\n\t\tInterest interest = id.buildInterest();\n\t\tsynchronized(_interestMap) {\n\t\t\t// Remove the old interest so we never match more than one\n\t\t\t// thing to an INterestData\n\t\t\tif( null != old ) {\n\t\t\t\t_handle.cancelInterest(old, this);\n\t\t\t\t_interestMap.remove(old);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t_handle.expressInterest(interest, this);\n\t\t\t\t_interestMap.put(interest, id);\n\t\t\t} catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":45657,"modified_method":"/**\n\t * Send a new interest and manage the _interestMap.  If the\n\t * InterestData has an old interest, we set the reexpress flag to false it in the map, so\n\t * it will no longer cause a new interest to be sent and then add\n\t * the new interest to the map, so when we receive an object for\n\t * it, we'll issue a new interest.\n\t */\n\tprotected void sendInterest(InterestData id) {\n\t\tInterest old = id.getLastInterest();\n\t\tInterest interest = id.buildInterest();\n\t\tsynchronized(_interestMap) {\n\t\t\t// Remove the old interest so we never match more than one\n\t\t\t// thing to an INterestData\n\t\t\tif( null != old ) {\n\t\t\t\t_handle.cancelInterest(old, this);\n\t\t\t\tInterestMapData imd = _interestMap.get(old);\n\t\t\t\tif( null != imd )\n\t\t\t\t\timd.setReexpress(false);\n\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_ENCODING, \"sendInterest nulling _interestMap for {0}\",old);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t_handle.expressInterest(interest, this);\n\t\t\t\t_interestMap.put(interest, new InterestMapData(id));\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_ENCODING, \"sendInterest setting  _interestMap for {0} to {1}\", interest, id);\n\t\t\t} catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Called from handleInterest\n\t * @param data\n\t * @param interest\n\t * @return\n\t */\n\tprotected Interest receive(ContentObject data, Interest interest) {\n\t\tInterestData datum;\n\t\tInterest newInterest = null;\n\n\t\tVersionNumber version;\n\n\t\t// Match the interest to our pending interests.  This removes it\n\t\t// from the pending interest map.\n\t\tsynchronized(_interestMap) {\n\t\t\tdatum = _interestMap.remove(interest);\n\t\t}\n\n\t\t// if we cannot find a version component, just re-express the same interest\n\t\ttry {\n\t\t\tversion = new VersionNumber(data.name());\n\t\t} catch (VersionMissingException e) {\n\t\t\te.printStackTrace();\n\t\t\t\n\t\t\tif( null != datum )\n\t\t\t\tnewInterest = datum.buildInterest();\n\n\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER))\n\t\t\t\tLog.finer(Log.FAC_ENCODING, \"Returning new interest {0}\",\n\t\t\t\t\t\tnull == newInterest ? \"NULL\" : newInterest.toString());\n\t\t\treturn newInterest;\n\t\t}\n\t\t\n\t\tif( null == datum && Log.isLoggable(Log.FAC_ENCODING, Level.FINE) )\n\t\t\tLog.fine(Log.FAC_ENCODING, \"Version {0} did not match a pending interest.\",\n\t\t\t\t\tversion.toString());\n\t\t\n\t\t// Is this something we should ignore?  This will avoid sending the\n\t\t// object up to the user.\n\t\tif( version.before(_startingVersion) || VersionNumber.getMaximumVersion().before(version) ) \n\t\t{\n\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE) )\n\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Ignorning version {0} because outside interval {1} to {2}\",\n\t\t\t\t\t\tversion.toString(),\n\t\t\t\t\t\t_startingVersion.toString(),\n\t\t\t\t\t\tVersionNumber.getMaximumVersion().toString());\t\t\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// store it in our global list of exclusions\n\t\t// If the version is already in the exclusion list, \n\t\tsynchronized(_exclusions) {\n\t\t\tif( ! _exclusions.add(version) ) {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE) )\n\t\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Receive duplicate version {0}\",\n\t\t\t\t\t\t\tversion.toString());\n\t\t\t} else {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_ENCODING, \"Receive version {0}\",\n\t\t\t\t\t\t\tversion.toString());\t\n\t\t\t}\n\t\t}\n\n\t\t// if we did not match anything, then we are no longer interested in it.\n\t\t// This most likely happens because of a re-build, in which case we do\n\t\t// not need to re-express an interest as the re-build did that.\n\t\tif( null != datum ) {\n\n\t\t\n\t\t\t\n\t\t\t// Figure out where to put the exclusion.  Because of re-building,\n\t\t\t// an exclusion will not always go in the original datum.  But,\n\t\t\t// that is usually a great first choice, so try it.  If that does\n\t\t\t// not work, search for where to put it\n\t\t\tInterestData excludeDatum = datum;\n\t\t\tif( !excludeDatum.contains(version) ) {\n\t\t\t\t// search for where to add the exclusion.  \"x\" is just to search the tree.\n\t\t\t\tInterestData x = new InterestData(null, version);\n\n\t\t\t\t// This is the InterestData that must contain version because\n\t\t\t\t// it is the largest startTime that is less than version\n\t\t\t\tInterestData floor = _interestData.floor(x);\n\n\t\t\t\t// floor shouldn't every be null\n\t\t\t\tif( null == floor ) {\n\t\t\t\t\tLog.warning(Log.FAC_ENCODING, \"Warning: floor element is null for version {0}\",\n\t\t\t\t\t\t\tversion.toString());\t\n\t\t\t\t}\n\n\t\t\t\tif( null != floor && floor.contains(version) ) {\n\t\t\t\t\texcludeDatum = floor;\n\t\t\t\t} else {\n\t\t\t\t\texcludeDatum = null;\n\t\t\t\t\tLog.severe(Log.FAC_ENCODING, \"Error: floor element {0} did not contain version {1}\",\n\t\t\t\t\t\t\tfloor.toString(), version.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( null != excludeDatum ) {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE))\n\t\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Excluding version {0} from InterestData {1}\",\n\t\t\t\t\t\t\tversion.toString(),\n\t\t\t\t\t\t\texcludeDatum);\t\t\n\t\t\t\t\n\t\t\t\tif( !excludeDatum.addExclude(version)) {\n\t\t\t\t\t// we cannot put the new exclusion in there, so we need to rebuild\n\t\t\t\t\trebuild(version, excludeDatum);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.WARNING))\n\t\t\t\t\tLog.warning(Log.FAC_ENCODING, \"Warning: Version {0} did not match any excludes!\",\n\t\t\t\t\t\t\tversion.toString(),\n\t\t\t\t\t\t\texcludeDatum);\t\n\t\t\t}\n\n\t\t\tnewInterest = datum.buildInterest();\n\t\t\tsynchronized(_interestMap) {\n\t\t\t\t_interestMap.put(newInterest, datum);\n\t\t\t}\n\t\t}\n\n\t\t// pass it off to the user\n\t\t_listener.handleContent(data, interest);\n\n\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER))\n\t\t\tLog.finer(Log.FAC_ENCODING, \"Returning new interest {0}\",\n\t\t\t\t\tnull == newInterest ? \"NULL\" : newInterest.toString());\n\n\t\treturn newInterest;\n\t}","id":45658,"modified_method":"/**\n\t * Called from handleInterest\n\t * @param data\n\t * @param interest\n\t * @return\n\t */\n\tprotected Interest receive(ContentObject data, Interest interest) {\n\t\tInterestData datum = null;\n\t\tInterest newInterest = null;\n\n\t\t// should we reexpress the interest?\n\t\tboolean reexpress = false;\n\n\t\tVersionNumber version;\n\n\t\t// Match the interest to our pending interests.  This removes it\n\t\t// from the pending interest map.\n\t\tsynchronized(_interestMap) {\n\t\t\tInterestMapData imd = _interestMap.remove(interest);\n\t\t\tif( null != imd ) {\n\t\t\t\tdatum = imd.getInterestData(); \n\t\t\t\treexpress = imd.getReexpress();\n\t\t\t}\n\t\t}\n\n\t\t// if we cannot find a version component, just re-express the same interest\n\t\ttry {\n\t\t\tversion = new VersionNumber(data.name());\n\t\t} catch (VersionMissingException e) {\n\t\t\te.printStackTrace();\n\n\t\t\tif( null != datum )\n\t\t\t\tnewInterest = datum.buildInterest();\n\n\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER))\n\t\t\t\tLog.finer(Log.FAC_ENCODING, \"Returning new interest {0}\",\n\t\t\t\t\t\tnull == newInterest ? \"NULL\" : newInterest.toString());\n\t\t\treturn newInterest;\n\t\t}\n\n\t\tif( null == datum && Log.isLoggable(Log.FAC_ENCODING, Level.WARNING) )\n\t\t\tLog.warning(Log.FAC_ENCODING, \"Did not match a pending interest for version {0} interest {1}\",\n\t\t\t\t\tversion.toString(), interest.toString());\n\n\t\t// Is this something we should ignore?  This will avoid sending the\n\t\t// object up to the user.\n\t\tif( version.before(_startingVersion) || VersionNumber.getMaximumVersion().before(version) ) \n\t\t{\n\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE) )\n\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Ignorning version {0} because outside interval {1} to {2}\",\n\t\t\t\t\t\tversion.toString(),\n\t\t\t\t\t\t_startingVersion.toString(),\n\t\t\t\t\t\tVersionNumber.getMaximumVersion().toString());\t\t\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// store it in our global list of exclusions\n\t\t// If the version is already in the exclusion list, \n\t\tsynchronized(_exclusions) {\n\t\t\tif( ! _exclusions.add(version) ) {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE) )\n\t\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Receive duplicate version {0}\",\n\t\t\t\t\t\t\tversion.toString());\n\t\t\t} else {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_ENCODING, \"Receive version {0}\",\n\t\t\t\t\t\t\tversion.toString());\t\n\t\t\t}\n\t\t}\n\n\t\tInterestData excludeDatum = findInterestContainingVersion(version, datum);\n\n\t\tif( null != excludeDatum ) {\n\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE))\n\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Excluding version {0} from InterestData {1}\",\n\t\t\t\t\t\tversion.toString(),\n\t\t\t\t\t\texcludeDatum);\t\t\n\n\t\t\tif( !excludeDatum.addExclude(version)) {\n\t\t\t\t// we cannot put the new exclusion in there, so we need to rebuild\n\t\t\t\trebuild(version, excludeDatum);\n\t\t\t}\n\n\t\t\tif( reexpress ) {\n\t\t\t\tnewInterest = datum.buildInterest();\n\t\t\t\tsynchronized(_interestMap) {\n\t\t\t\t\t_interestMap.put(newInterest, new InterestMapData(datum));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINE))\n\t\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Re-express false, so letting interest die: {0}\",\n\t\t\t\t\t\t\tinterest.toString());\n\t\t\t}\n\t\t}\n\n\t\t// pass it off to the user\n\t\t_listener.handleContent(data, interest);\n\n\t\tif( Log.isLoggable(Log.FAC_ENCODING, Level.FINER))\n\t\t\tLog.finer(Log.FAC_ENCODING, \"Returning new interest {0}\",\n\t\t\t\t\tnull == newInterest ? \"NULL\" : newInterest.toString());\n\n\t\treturn newInterest;\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * cancel all interests and stop operation\n\t */\n\tpublic synchronized void stop() {\n\t\t_running = false;\n\t\tcancelInterests();\n\t}","id":45659,"modified_method":"/**\n\t * cancel all interests and stop operation\n\t */\n\tpublic synchronized void stop() {\n\t\t//\t\t_running = false;\n\t\tcancelInterests();\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void send(CCNHandle handle, TestVIM vim, ContentName name, CCNTime version) throws IOException, InterruptedException {\n\t\tCCNStringObject so = new CCNStringObject(name, \"Hello, World!\", SaveType.LOCALREPOSITORY, handle);\n\t\tint trycount = 10;\n\t\tIOException error = null;\n\t\tdo {\n\t\t\terror = null;\n\t\t\ttrycount--;\n\t\t\ttry {\n\t\t\t\tso.save(version);\n\t\t\t\t// do this every time, not just on errors.  The FlowController seems\n\t\t\t\t// to not like to receive a lot of objects all at once.\n\t\t\t\tThread.sleep(SEND_PAUSE);\n\t\t\t} catch(IOException e) {\n\t\t\t\terror = e;\n\t\t\t\tThread.sleep(SEND_PAUSE);\n\t\t\t} \n\t\t} while( trycount > 0 && null != error );\n\t\t\n\t\tif( null != error ) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tint available_count = 0;\n\t\twhile(!so.available()) {\n\t\t\tavailable_count++;\n\t\t\tThread.sleep(SEND_PAUSE * 3);\n\t\t}\n\t\tif( available_count > 0 )\n\t\tLog.warning(Log.FAC_ENCODING, \"sleeps on so.available() count {0}\", available_count);\n\n\t\t// We are satisfying the interest, so it is no longer pending\n\t\tInterest interest = sinkhandle.interests.get(0);\n\t\tsinkhandle.cancelInterest(interest, vim);\n\n\t\tAssert.assertNotNull(interest);\n\t\tAssert.assertNotNull(\"null first segment, trycount \" + trycount, so.getFirstSegment());\n\t\t\n\t\tInterest newInterest = vim.exposeReceive(so.getFirstSegment(), interest);\n\n\t\tso.close();\n\n\t\t// this is normally done by handleContent\n\t\tif( newInterest != null )\n\t\t\tsinkhandle.expressInterest(newInterest, vim);\n\t}","id":45660,"modified_method":"private void send(CCNHandle handle, TestVIM vim, ContentName name, CCNTime version) throws IOException, InterruptedException {\n\t\tCCNStringObject so = new CCNStringObject(name, \"Hello, World!\", SaveType.LOCALREPOSITORY, handle);\n\t\tint trycount = 10;\n\t\tIOException error = null;\n\t\tfinal IOException noFirstSegment = new IOException(\"No first segment!\");\n\t\t\n\t\tdo {\n\t\t\terror = null;\n\t\t\ttrycount--;\n\t\t\ttry {\n\t\t\t\tso.save(version);\n\t\t\t\t// do this every time, not just on errors.  The FlowController seems\n\t\t\t\t// to not like to receive a lot of objects all at once.\n\t\t\t\tThread.sleep(SEND_PAUSE);\n\t\t\t} catch(IOException e) {\n\t\t\t\terror = e;\n\t\t\t\tThread.sleep(SEND_PAUSE);\n\t\t\t} \n\t\t\t\n\t\t\tint available_count = 0;\n\t\t\twhile(!so.available()) {\n\t\t\t\tavailable_count++;\n\t\t\t\tThread.sleep(SEND_PAUSE * 3);\n\t\t\t}\n\t\t\t\n\t\t\tif( available_count > 0 )\n\t\t\t\tLog.warning(Log.FAC_ENCODING, \"sleeps on so.available() count {0}\", available_count);\n\n\t\t\tint firstsegment_try = 2;\n\t\t\twhile(null == so.getFirstSegment() && firstsegment_try > 0) {\n\t\t\t\tfirstsegment_try--;\n\t\t\t\tThread.sleep(SEND_PAUSE * 3);\n\t\t\t}\n\t\t\t\n\t\t\tif( firstsegment_try < 2 ) {\n\t\t\t\tLog.warning(Log.FAC_ENCODING, \"sleeps on so.getFirstSegment() count {0}\", 2 - firstsegment_try);\n\t\t\t\tdumpstate(vim);\n\t\t\t\tthrow noFirstSegment;\n\t\t\t}\n\t\t\t\n\t\t\tif( null == so.getFirstSegment() )\n\t\t\t\terror = noFirstSegment;\n\n\t\t} while( trycount > 0 && null != error );\n\t\t\n\t\tif( null != error ) {\n\t\t\tthrow error;\n\t\t}\n\t\n\t\t// We are satisfying the interest, so it is no longer pending\n\t\tInterest interest = sinkhandle.interests.get(0);\n\t\tsinkhandle.cancelInterest(interest, vim);\n\n\t\tAssert.assertNotNull(interest);\n\t\tAssert.assertNotNull(\"null first segment, trycount \" + trycount, so.getFirstSegment());\n\t\t\n\t\tInterest newInterest = vim.exposeReceive(so.getFirstSegment(), interest);\n\n\t\tso.close();\n\n\t\t// this is normally done by handleContent\n\t\tif( newInterest != null )\n\t\t\tsinkhandle.expressInterest(newInterest, vim);\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Send a very long stream with arrivals uniformly over some interval\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void testLongStreamUniform() throws Exception {\n\t\tSystem.out.println(\"********** testLongStreamUniform\");\n\t\tContentName basename = ContentName.fromNative(prefix, String.format(\"content_%016X\", _rnd.nextLong()));\n\n\t\tTestListener listener = new TestListener();\n\n\t\tTestVIM vim = new TestVIM(sinkhandle, basename, null, VersionNumber.getMinimumVersion(), listener);\n\t\tvim.setSendInterest(true);\n\t\tvim.start();\n\n\t\tint tosend = VersioningInterestManager.MAX_FILL * LONG_SEND_MULTIPLE;\n\n\t\t// send MAX_FILL items, should only be one interest\n\t\tCCNTime now = CCNTime.now();\n\t\tint max_spacing = 20000;\n\t\tlong start_time = now.getTime();\n\t\tlong stop_time = start_time + tosend * max_spacing;\n\n\t\tSystem.out.println(\"***** Sending stream 1 *****\");\n\t\tTreeSet<CCNTime> sent1 = sendStreamUniform(sinkhandle, vim, basename, start_time, stop_time, tosend);\n\n\t\t// wait a while\n\t\tThread.sleep(10000);\n\n\t\t// we dont know how many interets this will take, but we can bound it\n\t\tint min_interests = (int) Math.ceil((double) tosend / VersioningInterestManager.MAX_FILL);\n\t\tint max_interests = (int) Math.floor((double) tosend / VersioningInterestManager.MIN_FILL);\n\n\t\tSystem.out.println(\"handle interests: \" + sinkhandle.total_count.getValue());\n\t\tSystem.out.println(\"exclusions      : \" + vim.getExclusions().size());\n\t\tSystem.out.println(\"vim interests   : \" + vim.getInterestDataTree().size() + \" (should be close to min interests)\");\n\t\tSystem.out.println(\"min interests   : \" + min_interests);\n\t\tSystem.out.println(\"max interests   : \" + max_interests);\n\n\t\tAssert.assertTrue( min_interests <= vim.getInterestDataTree().size() );\n\t\tAssert.assertTrue( vim.getInterestDataTree().size() <= max_interests );\n\n\n\t\tAssert.assertTrue( min_interests + tosend <= sinkhandle.total_count.getValue() );\n\t\tAssert.assertTrue( sinkhandle.total_count.getValue() <= max_interests + tosend );\n\t}","id":45661,"modified_method":"/**\n\t * Send a very long stream with arrivals uniformly over some interval\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void testLongStreamUniform() throws Exception {\n\t\tSystem.out.println(\"********** testLongStreamUniform\");\n\t\tContentName basename = ContentName.fromNative(prefix, String.format(\"content_%016X\", _rnd.nextLong()));\n\n\t\tTestListener listener = new TestListener();\n\n\t\tTestVIM vim = new TestVIM(sinkhandle, basename, null, VersionNumber.getMinimumVersion(), listener);\n\t\tvim.setSendInterest(true);\n\t\tvim.start();\n\n\t\tint tosend = VersioningInterestManager.MAX_FILL * LONG_SEND_MULTIPLE;\n\n\t\t// send MAX_FILL items, should only be one interest\n\t\tCCNTime now = CCNTime.now();\n\t\tint max_spacing = 20000;\n\t\tlong start_time = now.getTime();\n\t\tlong stop_time = start_time + tosend * max_spacing;\n\n\t\tSystem.out.println(\"***** Sending stream 1 *****\");\n\t\t@SuppressWarnings(\"unused\")\n\t\tTreeSet<CCNTime> sent1 = sendStreamUniform(sinkhandle, vim, basename, start_time, stop_time, tosend);\n\n\t\t// wait a while\n\t\tThread.sleep(10000);\n\n\t\t// we dont know how many interets this will take, but we can bound it\n\t\tint min_interests = (int) Math.ceil((double) tosend / VersioningInterestManager.MAX_FILL);\n\t\tint max_interests = (int) Math.floor((double) tosend / VersioningInterestManager.MIN_FILL);\n\n\t\tSystem.out.println(\"handle interests: \" + sinkhandle.total_count.getValue());\n\t\tSystem.out.println(\"exclusions      : \" + vim.getExclusions().size());\n\t\tSystem.out.println(\"vim interests   : \" + vim.getInterestDataTree().size() + \" (should be close to min interests)\");\n\t\tSystem.out.println(\"min interests   : \" + min_interests);\n\t\tSystem.out.println(\"max interests   : \" + max_interests);\n\n\t\tAssert.assertTrue( min_interests <= vim.getInterestDataTree().size() );\n\t\tAssert.assertTrue( vim.getInterestDataTree().size() <= max_interests );\n\n\n\t\tAssert.assertTrue( min_interests + tosend <= sinkhandle.total_count.getValue() );\n\t\tAssert.assertTrue( sinkhandle.total_count.getValue() <= max_interests + tosend );\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Send a very long stream with arrivals normally distributed around a spot\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void testLongStreamGaussian() throws Exception {\n\t\tSystem.out.println(\"********** testLongStreamGaussian\");\n\t\tContentName basename = ContentName.fromNative(prefix, String.format(\"content_%016X\", _rnd.nextLong()));\n\n\t\tTestListener listener = new TestListener();\n\n\t\tTestVIM vim = new TestVIM(sinkhandle, basename, null, VersionNumber.getMinimumVersion(), listener);\n\t\tvim.setSendInterest(true);\n\t\tvim.start();\n\n\t\tint tosend = VersioningInterestManager.MAX_FILL * LONG_SEND_MULTIPLE;\n\n\t\t// send MAX_FILL items, should only be one interest\n\t\tCCNTime now = CCNTime.now();\n\t\tint max_spacing = 20000;\n\t\tdouble mean_time = now.getTime();\n\t\tdouble std_time = tosend * max_spacing;\n\n\t\tSystem.out.println(\"***** Sending stream 1 *****\");\n\t\tTreeSet<CCNTime> sent1 = sendStreamGaussian(sinkhandle, vim, basename, mean_time, std_time, tosend);\n\n\t\t// wait a while\n\t\tThread.sleep(10000);\n\n\t\t// we dont know how many interets this will take, but we can bound it\n\t\tint min_interests = (int) Math.ceil((double) tosend / VersioningInterestManager.MAX_FILL);\n\t\tint max_interests = (int) Math.floor((double) tosend / VersioningInterestManager.MIN_FILL);\n\n\t\tSystem.out.println(\"handle interests: \" + sinkhandle.total_count.getValue());\n\t\tSystem.out.println(\"exclusions      : \" + vim.getExclusions().size());\n\t\tSystem.out.println(\"vim interests   : \" + vim.getInterestDataTree().size() + \" (should be close to min interests)\");\n\t\tSystem.out.println(\"min interests   : \" + min_interests);\n\t\tSystem.out.println(\"max interests   : \" + max_interests);\n\n\t\tAssert.assertTrue( min_interests <= vim.getInterestDataTree().size() );\n\t\tAssert.assertTrue( vim.getInterestDataTree().size() <= max_interests );\n\n\n\t\tAssert.assertTrue( min_interests + tosend <= sinkhandle.total_count.getValue() );\n\t\tAssert.assertTrue( sinkhandle.total_count.getValue() <= max_interests + tosend );\n\t}","id":45662,"modified_method":"/**\n\t * Send a very long stream with arrivals normally distributed around a spot\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void testLongStreamGaussian() throws Exception {\n\t\tSystem.out.println(\"********** testLongStreamGaussian\");\n\t\tContentName basename = ContentName.fromNative(prefix, String.format(\"content_%016X\", _rnd.nextLong()));\n\n\t\tTestListener listener = new TestListener();\n\n\t\tTestVIM vim = new TestVIM(sinkhandle, basename, null, VersionNumber.getMinimumVersion(), listener);\n\t\tvim.setSendInterest(true);\n\t\tvim.start();\n\n\t\tint tosend = VersioningInterestManager.MAX_FILL * LONG_SEND_MULTIPLE;\n\n\t\t// send MAX_FILL items, should only be one interest\n\t\tCCNTime now = CCNTime.now();\n\t\tint max_spacing = 20000;\n\t\tdouble mean_time = now.getTime();\n\t\tdouble std_time = tosend * max_spacing;\n\n\t\tSystem.out.println(\"***** Sending stream 1 *****\");\n\t\t@SuppressWarnings(\"unused\")\n\t\tTreeSet<CCNTime> sent1 = sendStreamGaussian(sinkhandle, vim, basename, mean_time, std_time, tosend);\n\n\t\t// wait a while\n\t\tThread.sleep(10000);\n\n\t\t// we dont know how many interets this will take, but we can bound it\n\t\tint min_interests = (int) Math.ceil((double) tosend / VersioningInterestManager.MAX_FILL);\n\t\tint max_interests = (int) Math.floor((double) tosend / VersioningInterestManager.MIN_FILL);\n\n\t\tSystem.out.println(\"handle interests: \" + sinkhandle.total_count.getValue());\n\t\tSystem.out.println(\"exclusions      : \" + vim.getExclusions().size());\n\t\tSystem.out.println(\"vim interests   : \" + vim.getInterestDataTree().size() + \" (should be close to min interests)\");\n\t\tSystem.out.println(\"min interests   : \" + min_interests);\n\t\tSystem.out.println(\"max interests   : \" + max_interests);\n\n\t\tAssert.assertTrue( min_interests <= vim.getInterestDataTree().size() );\n\t\tAssert.assertTrue( vim.getInterestDataTree().size() <= max_interests );\n\n\n\t\tAssert.assertTrue( min_interests + tosend <= sinkhandle.total_count.getValue() );\n\t\tAssert.assertTrue( sinkhandle.total_count.getValue() <= max_interests + tosend );\n\t}","commit_id":"563b8bda005e4b03277d1e76d9a5ed9a9890d3d5","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected void updateHandledResponses(ContentName n) {\n\t\tfor (NEResponse t: _handledResponses) {\n\t\t\tif (t.prefix.isPrefixOf(n)) {\n\t\t\t\tt.dirty();\n\t\t\t}\n\t\t}\n\t}","id":45663,"modified_method":"protected void updateHandledResponses(ContentName n) {\n\t\tsynchronized(_handledResponses){\n\t\t\tfor (NEResponse t: _handledResponses) {\n\t\t\t\tif (t.prefix.isPrefixOf(n)) {\n\t\t\t\t\tt.dirty();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void registerNameSpace(ContentName name) {\n\t\t\n\t\tif (!_registeredNames.contains(name)) {\n\t\t\t_registeredNames.add(name);\n\t\t\t//Library.logger().info(\"registered \"+ name.toString()+\" as namespace\");\n\t\t\t_library.registerFilter(name, this);\n\t\t}\n\t\t\n\t}","id":45664,"modified_method":"public void registerNameSpace(ContentName name) {\n\t\tsynchronized(_handledResponses){\n\t\t\tif (!_registeredNames.contains(name)) {\n\t\t\t\t_registeredNames.add(name);\n\t\t\t\t//Library.logger().info(\"registered \"+ name.toString()+\" as namespace\");\n\t\t\t\t_library.registerFilter(name, this);\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected NEResponse getHandledResponse(ContentName n) {\n\t\t//Library.logger().info(\"checking handled responses...\");\n\t\tfor (NEResponse t: _handledResponses) {\n\t\t\t//Library.logger().info(\"getHandledResponse: \"+t.prefix.toString());\n\t\t\tif (t.prefix.equals(n))\n\t\t\t\treturn t;\n\t\t}\n\t\treturn null;\n\t}","id":45665,"modified_method":"protected NEResponse getHandledResponse(ContentName n) {\n\t\t//Library.logger().info(\"checking handled responses...\");\n\t\tsynchronized(_handledResponses){\n\t\t\tfor (NEResponse t: _handledResponses) {\n\t\t\t\t//Library.logger().info(\"getHandledResponse: \"+t.prefix.toString());\n\t\t\t\tif (t.prefix.equals(n))\n\t\t\t\t\treturn t;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public int handleInterests(ArrayList<Interest> interests) {\n\t\t//Library.logger().info(\"Received Interests matching my filter!\");\n\t\t\n\t\tContentName collectionName = null;\n\t\tLinkReference match;\n\t\tCollectionData cd;\n\t\t\t\t\n\t\t\n\t\tContentName name = null;\n\t\tNEResponse r = null;\n\t\tfor (Interest i: interests) {\n\t\t\tname = i.name().clone();\n\t\t\t//Library.logger().info(\"processing interest: \"+name.toString());\n\t\t\t//collectionName = i.name().clone();\n\t\t\t\n\t\t\tcd = new CollectionData();\n\t\t\t//Verify NameEnumeration Marker is in the name\n\t\t\tif (!name.contains(NEMARKER)) {\n\t\t\t\t//Skip...  we don't handle these\n\t\t\t} else {\n\t\t\t\t//Library.logger().info(\"this interest contains the NE marker!\");\n\t\t\t\tname = name.cut(NEMARKER);\n\t\t\t\tcollectionName = new ContentName(name, NEMARKER);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tboolean skip = false;\n\t\t\t\t//have we handled this response already?\n\t\t\t\tr = getHandledResponse(name);\n\t\t\t\tif (r != null) {\n\t\t\t\t\t//we have handled this before!\n\t\t\t\t\tif (r.isDirty()) {\n\t\t\t\t\t\t//this has updates to send back!!\n\t\t\t\t\t\t//Library.logger().info(\"the marker is dirty!  we have new names to send back!\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//nothing new to send back...  go ahead and skip to next interest\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t\t//Library.logger().info(\"no new names to report...  skipping\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//this is a new one...\n\t\t\t\t\t//Library.logger().info(\"adding new handled response: \"+name.toString());\n\t\t\t\t\tr = new NEResponse(name);\n\t\t\t\t\t_handledResponses.add(r);\n\t\t\t\t}\n\t\t\t\tif (!skip) {\n\t\t\t\t\tfor (ContentName n: _registeredNames) {\n\t\t\t\t\t\t//Library.logger().info(\"checking registered name: \"+n.toString());\n\t\t\t\t\t\tif (name.isPrefixOf(n)) {\n\t\t\t\t\t\t\tContentName tempName = n.clone();\n\t\t\t\t\t\t\t//Library.logger().info(\"we have a match! (\"+tempName.toString()+\")\");\n\t\t\t\t\t\t\t//Library.logger().info(\"prefix size \"+name.count()+\" registered name size \"+n.count());\n\t\t\t\t\t\t\tbyte[] tn = n.component(name.count());\n\t\t\t\t\t\t\tbyte[][] na = new byte[1][tn.length];\n\t\t\t\t\t\t\tna[0] = tn;\n\t\t\t\t\t\t\ttempName = new ContentName(na);\n\t\t\t\t\t\t\tmatch = new LinkReference(tempName);\n\t\t\t\t\t\t\t//names.add(match);\n\t\t\t\t\t\t\tif (!cd.contents().contains(match)) {\n\t\t\t\t\t\t\t\tcd.add(match);\n\t\t\t\t\t\t\t\t//Library.logger().info(\"added name to response: \"+tempName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (cd.size()>0) {\n\t\t\t\t//Library.logger().info(\"we have a response to send back for \"+i.name().toString());\n\t\t\t\t//Library.logger().info(\"Collection Name: \"+collectionName.toString());\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t//the following 6 lines are to be deleted after Collections are refactored\n\t\t\t\t\tLinkReference[] temp = new LinkReference[cd.contents().size()];\n\t\t\t\t\tfor (int x = 0; x < cd.contents().size(); x++)\n\t\t\t\t\t\ttemp[x] = cd.contents().get(x);\n\t\t\t\t\t_library.put(collectionName, temp);\n\t\t\t\t\t\n\t\t\t\t\t//CCNEncodableCollectionData ecd = new CCNEncodableCollectionData(collectionName, cd);\n\t\t\t\t\t//ecd.save();\n\t\t\t\t\t//Library.logger().info(\"saved ecd.  name: \"+ecd.getName());\n\t\t\t\t\tr.clean();\n\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\t\n\t\t\t\t} catch(SignatureException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Library.logger().info(\"this interest did not have any matching names...  not returning anything.\");\n\t\t\t\tif (r != null)\n\t\t\t\t\tr.clean();\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn 0;\n\t}","id":45666,"modified_method":"public int handleInterests(ArrayList<Interest> interests) {\n\t\t//Library.logger().info(\"Received Interests matching my filter!\");\n\t\t\n\t\tContentName collectionName = null;\n\t\tLinkReference match;\n\t\tCollectionData cd;\n\t\t\t\t\n\t\t\n\t\tContentName name = null;\n\t\tNEResponse r = null;\n\t\tfor (Interest i: interests) {\n\t\t\tname = i.name().clone();\n\t\t\t//Library.logger().info(\"processing interest: \"+name.toString());\n\t\t\t//collectionName = i.name().clone();\n\t\t\t\n\t\t\tcd = new CollectionData();\n\t\t\t//Verify NameEnumeration Marker is in the name\n\t\t\tif (!name.contains(NEMARKER)) {\n\t\t\t\t//Skip...  we don't handle these\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//Library.logger().info(\"this interest contains the NE marker!\");\n\t\t\t\tname = name.cut(NEMARKER);\n\t\t\t\tcollectionName = new ContentName(name, NEMARKER);\n\t\t\t\t\n\t\t\t\tboolean skip = false;\n\t\t\t\tsynchronized(_handledResponses){\n\t\t\t\t\t//have we handled this response already?\n\t\t\t\t\tr = getHandledResponse(name);\n\t\t\t\t\tif (r != null) {\n\t\t\t\t\t\t//we have handled this before!\n\t\t\t\t\t\tif (r.isDirty()) {\n\t\t\t\t\t\t\t//this has updates to send back!!\n\t\t\t\t\t\t\t//Library.logger().info(\"the marker is dirty!  we have new names to send back!\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//nothing new to send back...  go ahead and skip to next interest\n\t\t\t\t\t\t\tskip = true;\n\t\t\t\t\t\t\t//Library.logger().info(\"no new names to report...  skipping\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//this is a new one...\n\t\t\t\t\t\t//Library.logger().info(\"adding new handled response: \"+name.toString());\n\t\t\t\t\t\tr = new NEResponse(name);\n\t\t\t\t\t\t_handledResponses.add(r);\n\t\t\t\t\t}\n\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\tfor (ContentName n: _registeredNames) {\n\t\t\t\t\t\t\t//Library.logger().info(\"checking registered name: \"+n.toString());\n\t\t\t\t\t\t\tif(name.isPrefixOf(n)) {\n\t\t\t\t\t\t\t\tContentName tempName = n.clone();\n\t\t\t\t\t\t\t\t//Library.logger().info(\"we have a match! (\"+tempName.toString()+\")\");\n\t\t\t\t\t\t\t\t//Library.logger().info(\"prefix size \"+name.count()+\" registered name size \"+n.count());\n\t\t\t\t\t\t\t\tbyte[] tn = n.component(name.count());\n\t\t\t\t\t\t\t\tbyte[][] na = new byte[1][tn.length];\n\t\t\t\t\t\t\t\tna[0] = tn;\n\t\t\t\t\t\t\t\ttempName = new ContentName(na);\n\t\t\t\t\t\t\t\tmatch = new LinkReference(tempName);\n\t\t\t\t\t\t\t\t//names.add(match);\n\t\t\t\t\t\t\t\tif (!cd.contents().contains(match)) {\n\t\t\t\t\t\t\t\t\tcd.add(match);\n\t\t\t\t\t\t\t\t\t//Library.logger().info(\"added name to response: \"+tempName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\tif (cd.size()>0) {\n\t\t\t\t\t\t//Library.logger().info(\"we have a response to send back for \"+i.name().toString());\n\t\t\t\t\t\t//Library.logger().info(\"Collection Name: \"+collectionName.toString());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t\t\t//the following 6 lines are to be deleted after Collections are refactored\n\t\t\t\t\t\t\tLinkReference[] temp = new LinkReference[cd.contents().size()];\n\t\t\t\t\t\t\tfor (int x = 0; x < cd.contents().size(); x++)\n\t\t\t\t\t\t\t\ttemp[x] = cd.contents().get(x);\n\t\t\t\t\t\t\t_library.put(collectionName, temp);\n\t\t\t\t\t\n\t\t\t\t\t\t\t//CCNEncodableCollectionData ecd = new CCNEncodableCollectionData(collectionName, cd);\n\t\t\t\t\t\t\t//ecd.save();\n\t\t\t\t\t\t\t//Library.logger().info(\"saved ecd.  name: \"+ecd.getName());\n\t\t\t\t\t\t\tr.clean();\n\n\t\t\t\t\t\t} catch(IOException e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t} catch(SignatureException e) {\n\t\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Library.logger().info(\"this interest did not have any matching names...  not returning anything.\");\n\t\t\t\t\tif (r != null)\n\t\t\t\t\t\tr.clean();\n\t\t\t\t} //end of synchronized\n\t\t\t}  //end of name enumeration marker check\n\t\t}//end of interest processing loop\n\t\t\t\n\t\treturn 0;\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void registerPrefix(ContentName prefix) throws IOException{\n\t\tNERequest r = getCurrentRequest(prefix);\n\t\tif(r!=null){\n\t\t\t//this prefix is already registered...\n\t\t\tLibrary.logger().info(\"prefix \"+prefix.toString()+\" is already registered...  returning\");\n\t\t}\n\t\telse{\n\t\t\tr = new NERequest(prefix);\n\t\t\t_currentRequests.add(r);\n\t\t}\n\t\t\t\n\t\tLibrary.logger().info(\"Registered Prefix: \"+prefix.toString());\n\t\t//Library.logger().info(\"creating Interest\");\n\t\t\t\n\t\tContentName prefixMarked = new ContentName(prefix, NEMARKER);\n\t\t\t\n\t\tInterest pi = new Interest(prefixMarked);\n\t\tpi.orderPreference(Interest.ORDER_PREFERENCE_ORDER_NAME);\n\t\tpi.nameComponentCount(prefix.count() + 1);\n\t\t\t\n\t\t//Library.logger().info(\"interest name: \"+pi.name().toString()+\" prefix: \"+pi.name().prefixCount()+\" order preference \"+pi.orderPreference());\n\t\tr.addInterest(pi);\n\t\t\n\t\t_library.expressInterest(pi, this);\n\t\t\t\n\t\t//Library.logger().info(\"expressed Interest: \"+prefixMarked.toString());\n\t}","id":45667,"modified_method":"public void registerPrefix(ContentName prefix) throws IOException{\n\t\tsynchronized(_currentRequests){\n\t\t\tNERequest r = getCurrentRequest(prefix);\n\t\t\tif(r!=null){\n\t\t\t\t//this prefix is already registered...\n\t\t\t\tLibrary.logger().info(\"prefix \"+prefix.toString()+\" is already registered...  returning\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = new NERequest(prefix);\n\t\t\t\t_currentRequests.add(r);\n\t\t\t}\n\t\t\t\n\t\t\tLibrary.logger().info(\"Registered Prefix: \"+prefix.toString());\n\t\t\t//Library.logger().info(\"creating Interest\");\n\t\t\t\n\t\t\tContentName prefixMarked = new ContentName(prefix, NEMARKER);\n\t\t\t\n\t\t\tInterest pi = new Interest(prefixMarked);\n\t\t\tpi.orderPreference(Interest.ORDER_PREFERENCE_ORDER_NAME);\n\t\t\tpi.nameComponentCount(prefix.count() + 1);\n\t\t\t\n\t\t\t//Library.logger().info(\"interest name: \"+pi.name().toString()+\" prefix: \"+pi.name().prefixCount()+\" order preference \"+pi.orderPreference());\n\t\t\tr.addInterest(pi);\n\t\t\n\t\t\t_library.expressInterest(pi, this);\n\t\t\t\n\t\t\t//Library.logger().info(\"expressed Interest: \"+prefixMarked.toString());\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public boolean containsRegisteredName(ContentName name) {\n\t\tif (name == null) {\n\t\t\tSystem.err.println(\"trying to check for null registered name\");\n\t\t\treturn false;\n\t\t}\n\t\tif (_registeredNames.contains(name))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}","id":45668,"modified_method":"public boolean containsRegisteredName(ContentName name) {\n\t\tif (name == null) {\n\t\t\tSystem.err.println(\"trying to check for null registered name\");\n\t\t\treturn false;\n\t\t}\n\t\tsynchronized(_handledResponses){\n\t\t\tif (_registeredNames.contains(name))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ArrayList<ContentObject> results, Interest interest) {\n\t\t\n\t\t//Library.logger().info(\"we recieved a Collection matching our prefix...\");\n\t\t\n\t\tif (interest.name().contains(NEMARKER)) {\n\t\t\t//the NEMarker is in the name...  good!\n\t\t} else {\n\t\t\t//NEMARKER missing...  we have a problem\n\t\t\tSystem.err.println(\"the name enumeration marker is missing...  shouldn't have gotten this callback\");\n\t\t\t_library.cancelInterest(interest, this);\n\t\t\treturn null;\n\t\t}\n\t\tCollection collection;\n\t\tArrayList<ContentName> names = new ArrayList<ContentName>();\n\t\tArrayList<LinkReference> links;\n\t\tContentName responseName = null;\n\t\t\n\t\t//TODO  integrate handling for multiple responders, for now, just handles one result properly\n\t\tif (results != null) {\n\t\t\tfor (ContentObject c: results) {\n\t\t\t\t//Library.logger().info(\"we have a match on \"+interest.name());\n\t\t\t\t//responseName = c.name();\n\t\t\t\tresponseName = new ContentName(c.name(), c.contentDigest());\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tcollection = Collection.contentToCollection(c);\n\t\t\t\t\tlinks = collection.contents();\n\t\t\t\t\tfor (LinkReference l: links) {\n\t\t\t\t\t\tnames.add(l.targetName());\n\t\t\t\t\t\t//Library.logger().info(\"names: \"+l.targetName());\n\t\t\t\t\t}\n\t\t\t\t\t//strip off NEMarker before passing through callback\n\t\t\t\t\tcallback.handleNameEnumerator(interest.name().cut(NEMARKER), names);\n\t\t\t\t} catch(XMLStreamException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.err.println(\"Error getting CollectionData from ContentObject in CCNNameEnumerator\");\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\tInterest newInterest = interest;\n\t\tif (responseName != null) {\n\t\t\tnewInterest = Interest.last(responseName);\n\t\t\t//newInterest.orderPreference(newInterest.name().count()-2);\n\t\t\tnewInterest.orderPreference(Interest.ORDER_PREFERENCE_ORDER_NAME);// | Interest.ORDER_PREFERENCE_RIGHT);\n\t\t\tnewInterest.nameComponentCount(interest.nameComponentCount());\n\t\t\tNERequest ner = getCurrentRequest(interest.name().cut(NEMARKER));\n\t\t\tif (ner != null) {\n\t\t\t\tner.removeInterest(interest);\n\t\t\t\tner.addInterest(newInterest);\n\t\t\t}\n\t\t\t/*\n\t\t\t Library.logger().info(\"new interest name: \"+newInterest.name()+\" total components: \"+newInterest.name().count());\n\t\t\t \n\t\t\t  try {\n\t\t\t  \tLibrary.logger().info(\"version: \"+VersioningProfile.getVersionAsTimestamp(responseName));\n\t\t\t  }\n\t\t\t  catch(Exception e) {}\n\t\t\t*/\n\t\t}\n\t\treturn newInterest;\n\t}","id":45669,"modified_method":"public Interest handleContent(ArrayList<ContentObject> results, Interest interest) {\n\t\t\n\t\t//Library.logger().info(\"we received a Collection matching our prefix...\");\n\t\t\n\t\tif (interest.name().contains(NEMARKER)) {\n\t\t\t//the NEMarker is in the name...  good!\n\t\t} else {\n\t\t\t//NEMARKER missing...  we have a problem\n\t\t\tSystem.err.println(\"the name enumeration marker is missing...  shouldn't have gotten this callback\");\n\t\t\t_library.cancelInterest(interest, this);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tsynchronized(_currentRequests){\n\t\t\tContentName prefix = interest.name().cut(NEMARKER);\n\t\t\tNERequest ner = getCurrentRequest(prefix);\n\t\t\n\t\t\t//need to make sure the prefix is still registered\n\t\t\tif(ner==null){\n\t\t\t\t//this is no longer registered...  no need to keep refreshing the interest use the callback\n\t\t\t\t_library.cancelInterest(interest, this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse\n\t\t\t\tner.removeInterest(interest);\n\t\t\n\t\t\tCollection collection;\n\t\t\tArrayList<ContentName> names = new ArrayList<ContentName>();\n\t\t\tArrayList<LinkReference> links;\n\t\t\tContentName responseName = null;\n\t\t\tInterest newInterest = interest;\n\t\t\n\t\t\t//TODO  integrate handling for multiple responders, for now, just handles one result properly\n\t\t\tif (results != null) {\n\t\t\t\tfor (ContentObject c: results) {\n\t\t\t\t\t//Library.logger().info(\"we have a match on \"+interest.name());\n\n\t\t\t\t\tresponseName = new ContentName(c.name(), c.contentDigest());\n\t\t\t\t\tnewInterest = Interest.last(responseName);\n\t\t\t\t\tnewInterest.orderPreference(Interest.ORDER_PREFERENCE_ORDER_NAME);// | Interest.ORDER_PREFERENCE_RIGHT);\n\t\t\t\t\tnewInterest.nameComponentCount(interest.nameComponentCount());\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_library.expressInterest(newInterest, this);\n\t\t\t\t\t\tner.addInterest(newInterest);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t// error registering new interest\n\t\t\t\t\t\tSystem.err.println(\"error registering new interest in handleContent\");\n\t\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcollection = Collection.contentToCollection(c);\n\t\t\t\t\t\tlinks = collection.contents();\n\t\t\t\t\t\tfor (LinkReference l: links) {\n\t\t\t\t\t\t\tnames.add(l.targetName());\n\t\t\t\t\t\t\t//Library.logger().info(\"names: \"+l.targetName());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//strip off NEMarker before passing through callback\n\t\t\t\t\t\tcallback.handleNameEnumerator(interest.name().cut(NEMARKER), names);\n\t\t\t\t\t} catch(XMLStreamException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\tSystem.err.println(\"Error getting CollectionData from ContentObject in CCNNameEnumerator\");\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//we now express the new interests as we process the responses...\n\t\t//return newInterest;\n\t\treturn null; \n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public boolean cancelPrefix(ContentName prefix) {\n\t\tLibrary.logger().info(\"cancel prefix: \"+prefix.toString());\n\t\t//cancel the behind the scenes interests and remove from the local ArrayList\n\t\tNERequest r = getCurrentRequest(prefix);\n\t\tif (r != null) {\n\t\t\tArrayList<Interest> is = r.getInterests();\n\t\t\tfor (Interest i: is)\n\t\t\t\t_library.cancelInterest(i, this);\n\t\t\t\n\t\t\t_currentRequests.remove(r);\n\t\t\treturn (getCurrentRequest(prefix) == null);\n\t\t}\n\n\t\treturn false;\n\t}","id":45670,"modified_method":"public boolean cancelPrefix(ContentName prefix) {\n\t\tLibrary.logger().info(\"cancel prefix: \"+prefix.toString());\n\t\tsynchronized(_currentRequests){\n\t\t\t//cancel the behind the scenes interests and remove from the local ArrayList\n\t\t\tNERequest r = getCurrentRequest(prefix);\n\t\t\tif (r != null) {\n\t\t\t\tArrayList<Interest> is = r.getInterests();\n\t\t\t\tLibrary.logger().fine(\"we have \"+is.size()+\" interests to cancel\");\n\t\t\t\tInterest i;\n\t\t\t\twhile(!r.getInterests().isEmpty()){\n\t\t\t\t\ti=r.getInterests().remove(0);\n\t\t\t\t\t_library.cancelInterest(i, this);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t_currentRequests.remove(r);\n\t\t\t\treturn (getCurrentRequest(prefix) == null);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected NERequest getCurrentRequest(ContentName n) {\n\t\t//Library.logger().info(\"checking current requests...\");\n\t\tfor (NERequest r: _currentRequests) {\n\t\t\tif (r.prefix.equals(n))\n\t\t\t\treturn r;\n\t\t}\n\t\treturn null;\n\t}","id":45671,"modified_method":"protected NERequest getCurrentRequest(ContentName n) {\n\t\t//Library.logger().info(\"checking current requests...\");\n\t\tsynchronized(_handledResponses){\n\t\t\tfor (NERequest r: _currentRequests) {\n\t\t\t\tif (r.prefix.equals(n))\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void registerNameForResponses(ContentName name) {\n\n\t\tif (name == null) {\n\t\t\tSystem.err.println(\"The content name for registerNameForResponses was null, ignoring\");\n\t\t\treturn;\n\t\t}\n\t\t//Do not need to register each name as a filter...  the namespace should cover it\n\t\t//_library.registerFilter(name, this);\n\t\tif (!_registeredNames.contains(name)) {\n\t\t\t// DKS - if we don't care about order, could use a Set instead of an ArrayList,\n\t\t\t// then just call add as duplicates suppressed\n\t\t  _registeredNames.add(name);\n\t\t  //Library.logger().info(\"registered \"+ name.toString()+\") for responses\");\t\t  \n\t\t}\n\t\t\n\t\t//check prefixes that were handled...  if so, mark them dirty\n\t\tupdateHandledResponses(name);\n\t}","id":45672,"modified_method":"public void registerNameForResponses(ContentName name) {\n\n\t\tif (name == null) {\n\t\t\tSystem.err.println(\"The content name for registerNameForResponses was null, ignoring\");\n\t\t\treturn;\n\t\t}\n\t\t//Do not need to register each name as a filter...  the namespace should cover it\n\t\tsynchronized(_handledResponses){\n\t\t\t//_library.registerFilter(name, this);\n\t\t\tif (!_registeredNames.contains(name)) {\n\t\t\t\t// DKS - if we don't care about order, could use a Set instead of an ArrayList,\n\t\t\t\t// then just call add as duplicates suppressed\n\t\t\t\t_registeredNames.add(name);\n\t\t\t\t//Library.logger().info(\"registered \"+ name.toString()+\") for responses\");\t\t  \n\t\t\t}\n\t\t\t//check prefixes that were handled...  if so, mark them dirty\n\t\t\tupdateHandledResponses(name);\n\t\t}\n\t}","commit_id":"f1d12fb4cd195fe816904fbcf50ab70138013ac0","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void init(ContentName name) throws IOException {\n\t\t_baseName = name;\n\t\tclearUnmatchedInterests();\t// Remove possible leftover interests from \"getLatestVersion\"\n\t\tContentName repoWriteName = new ContentName(name, CCNBase.REPO_START_WRITE, CCNLibrary.nonce());\n\t\t_listener = new RepoListener();\n\t\t_writeInterest = new Interest(repoWriteName);\n\t\t_library.expressInterest(_writeInterest, _listener);\n\t\tif (! _bestEffort) {\n\t\t\t_ackHandler = new RepoAckHandler();\n\t\t\t_ackne = new CCNNameEnumerator(_library, _ackHandler);\n\t\t}\n\t\t\n\t\t/*\n\t\t * Wait for information to be returned from a repo\n\t\t */\n\t\tsynchronized (this) {\n\t\t\tboolean interrupted;\n\t\t\tdo\n\t\t\t\ttry {\n\t\t\t\t\tinterrupted = false;\n\t\t\t\t\twait(getTimeout());\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tinterrupted = true;\n\t\t\t\t}\n\t\t\twhile (interrupted);\n\t\t}\n\t\tif (_repoName == null)\n\t\t\tthrow new IOException(\"No response from a repository\");\n\t}","id":45673,"modified_method":"public void init(ContentName name) throws IOException {\n\t\t_baseName = name;\n\t\tclearUnmatchedInterests();\t// Remove possible leftover interests from \"getLatestVersion\"\n\t\tContentName repoWriteName = new ContentName(name, CCNBase.REPO_START_WRITE, CCNLibrary.nonce());\n\t\t//_listener = new RepoListener();\n\t\t_writeInterest = new Interest(repoWriteName);\n\t\t//_library.expressInterest(_writeInterest, _listener);\n\t\t_library.expressInterest(_writeInterest, this);\n\t\tif (! _bestEffort) {\n\t\t\t_ackHandler = new RepoAckHandler();\n\t\t\t_ackne = new CCNNameEnumerator(_library, _ackHandler);\n\t\t}\n\t\t\n\t\t/*\n\t\t * Wait for information to be returned from a repo\n\t\t */\n\t\tsynchronized (this) {\n\t\t\tboolean interrupted;\n\t\t\tdo\n\t\t\t\ttry {\n\t\t\t\t\tinterrupted = false;\n\t\t\t\t\twait(getTimeout());\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tinterrupted = true;\n\t\t\t\t}\n\t\t\twhile (interrupted);\n\t\t}\n\t\tif (_repoName == null)\n\t\t\tthrow new IOException(\"No response from a repository\");\n\t}","commit_id":"4d5b7342c22f92428c5ace300129f968ab2e18d9","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void cancelInterests() {\n\t\t_ackne.cancelPrefix(_baseName);\n\t\tif (_writeInterest != null)\n\t\t\t_library.cancelInterest(_writeInterest, _listener);\n\t}","id":45674,"modified_method":"private void cancelInterests() {\n\t\t_ackne.cancelPrefix(_baseName);\n\t\tif (_writeInterest != null){\n\t\t\t//_library.cancelInterest(_writeInterest, _listener);\n\t\t\t_library.cancelInterest(_writeInterest, this);\n\t\t}\n\t}","commit_id":"4d5b7342c22f92428c5ace300129f968ab2e18d9","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n    public void saveUsageRecords(List<UsageVO> usageRecords) {\n        TransactionLegacy txn = TransactionLegacy.currentTxn();\n        try {\n            txn.start();\n            String sql = INSERT_USGAE_RECORDS;\n            PreparedStatement pstmt = null;\n            pstmt = txn.prepareAutoCloseStatement(sql); // in reality I just want CLOUD_USAGE dataSource connection\n            for (UsageVO usageRecord : usageRecords) {\n                pstmt.setLong(1, usageRecord.getZoneId());\n                pstmt.setLong(2, usageRecord.getAccountId());\n                pstmt.setLong(3, usageRecord.getDomainId());\n                pstmt.setString(4, usageRecord.getDescription());\n                pstmt.setString(5, usageRecord.getUsageDisplay());\n                pstmt.setInt(6, usageRecord.getUsageType());\n                pstmt.setDouble(7, usageRecord.getRawUsage());\n                if (usageRecord.getVmInstanceId() != null) {\n                    pstmt.setLong(8, usageRecord.getVmInstanceId());\n                } else {\n                    pstmt.setNull(8, Types.BIGINT);\n                }\n                pstmt.setString(9, usageRecord.getVmName());\n                if (usageRecord.getOfferingId() != null) {\n                    pstmt.setLong(10, usageRecord.getOfferingId());\n                } else {\n                    pstmt.setNull(10, Types.BIGINT);\n                }\n                if (usageRecord.getTemplateId() != null) {\n                    pstmt.setLong(11, usageRecord.getTemplateId());\n                } else {\n                    pstmt.setNull(11, Types.BIGINT);\n                }\n                if (usageRecord.getUsageId() != null) {\n                    pstmt.setLong(12, usageRecord.getUsageId());\n                } else {\n                    pstmt.setNull(12, Types.BIGINT);\n                }\n                pstmt.setString(13, usageRecord.getType());\n                if (usageRecord.getSize() != null) {\n                    pstmt.setLong(14, usageRecord.getSize());\n                } else {\n                    pstmt.setNull(14, Types.BIGINT);\n                }\n                if (usageRecord.getNetworkId() != null) {\n                    pstmt.setLong(15, usageRecord.getNetworkId());\n                } else {\n                    pstmt.setNull(15, Types.BIGINT);\n                }\n                pstmt.setTimestamp(16, new Timestamp(usageRecord.getStartDate().getTime()));\n                pstmt.setTimestamp(17, new Timestamp(usageRecord.getEndDate().getTime()));\n                if (usageRecord.getVirtualSize() != null) {\n                    pstmt.setLong(18, usageRecord.getSize());\n                } else {\n                    pstmt.setNull(18, Types.BIGINT);\n                }\n                pstmt.addBatch();\n            }\n            pstmt.executeBatch();\n            txn.commit();\n        } catch (Exception ex) {\n            txn.rollback();\n            s_logger.error(\"error saving usage records to cloud_usage db\", ex);\n            throw new CloudRuntimeException(ex.getMessage());\n        }\n    }","id":45675,"modified_method":"@Override\n    public void saveUsageRecords(List<UsageVO> usageRecords) {\n        TransactionLegacy txn = TransactionLegacy.currentTxn();\n        try {\n            txn.start();\n            String sql = INSERT_USGAE_RECORDS;\n            PreparedStatement pstmt = null;\n            pstmt = txn.prepareAutoCloseStatement(sql); // in reality I just want CLOUD_USAGE dataSource connection\n            for (UsageVO usageRecord : usageRecords) {\n                pstmt.setLong(1, usageRecord.getZoneId());\n                pstmt.setLong(2, usageRecord.getAccountId());\n                pstmt.setLong(3, usageRecord.getDomainId());\n                pstmt.setString(4, usageRecord.getDescription());\n                pstmt.setString(5, usageRecord.getUsageDisplay());\n                pstmt.setInt(6, usageRecord.getUsageType());\n                pstmt.setDouble(7, usageRecord.getRawUsage());\n                if (usageRecord.getVmInstanceId() != null) {\n                    pstmt.setLong(8, usageRecord.getVmInstanceId());\n                } else {\n                    pstmt.setNull(8, Types.BIGINT);\n                }\n                pstmt.setString(9, usageRecord.getVmName());\n                if (usageRecord.getOfferingId() != null) {\n                    pstmt.setLong(10, usageRecord.getOfferingId());\n                } else {\n                    pstmt.setNull(10, Types.BIGINT);\n                }\n                if (usageRecord.getTemplateId() != null) {\n                    pstmt.setLong(11, usageRecord.getTemplateId());\n                } else {\n                    pstmt.setNull(11, Types.BIGINT);\n                }\n                if (usageRecord.getUsageId() != null) {\n                    pstmt.setLong(12, usageRecord.getUsageId());\n                } else {\n                    pstmt.setNull(12, Types.BIGINT);\n                }\n                pstmt.setString(13, usageRecord.getType());\n                if (usageRecord.getSize() != null) {\n                    pstmt.setLong(14, usageRecord.getSize());\n                } else {\n                    pstmt.setNull(14, Types.BIGINT);\n                }\n                if (usageRecord.getNetworkId() != null) {\n                    pstmt.setLong(15, usageRecord.getNetworkId());\n                } else {\n                    pstmt.setNull(15, Types.BIGINT);\n                }\n                pstmt.setString(16, DateUtil.getDateDisplayString(s_gmtTimeZone, usageRecord.getStartDate()));\n                pstmt.setString(17, DateUtil.getDateDisplayString(s_gmtTimeZone, usageRecord.getEndDate()));\n                if (usageRecord.getVirtualSize() != null) {\n                    pstmt.setLong(18, usageRecord.getSize());\n                } else {\n                    pstmt.setNull(18, Types.BIGINT);\n                }\n                pstmt.addBatch();\n            }\n            pstmt.executeBatch();\n            txn.commit();\n        } catch (Exception ex) {\n            txn.rollback();\n            s_logger.error(\"error saving usage records to cloud_usage db\", ex);\n            throw new CloudRuntimeException(ex.getMessage());\n        }\n    }","commit_id":"f012a2655d38fb8aa0f9e6cb6ee740e89b12359d","url":"https://github.com/apache/cloudstack"},{"original_method":"public void visit(Method obj) {\n\t\tif (obj.getName().equals(\"enum\") || obj.getName().equals(\"assert\")) {\n\t\t\tBugInstance bug = new BugInstance(this, \"Nm_DONT_USE_ENUM\", NORMAL_PRIORITY)\n\t\t\t.addClass(this).addMethod(this);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t}","id":45676,"modified_method":"@Override\n\tpublic void visit(Method obj) {\n\t\tif (isReservedName(obj.getName())) {\n\t\t\tBugInstance bug = new BugInstance(this, \"NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER\", isVisible(obj) ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t}","commit_id":"cf9347054be7c1ee29b46bd3141036342c05ae53","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void visit(Field obj) {\n\t\tif (obj.getName().equals(\"enum\") || obj.getName().equals(\"assert\")) {\n\t\t\tBugInstance bug = new BugInstance(this, \"Nm_DONT_USE_ENUM\", NORMAL_PRIORITY)\n\t\t\t.addClass(this).addField(this);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t}","id":45677,"modified_method":"@Override\n\tpublic void visit(Field obj) {\n\t\tif (isReservedName(obj.getName())) {\n\t\t\tBugInstance bug = new BugInstance(this, \"NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER\", isVisible(obj) ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t.addClass(this).addField(this);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t}","commit_id":"cf9347054be7c1ee29b46bd3141036342c05ae53","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Method obj) {\n\t\tif (!validClass)\n\t\t\treturn;\n\t\tvalidMethod = false;\n\t\tmethodName = obj.getName();\n\t\tif (methodName.equals(\"setUp\") || methodName.equals(\"tearDown\")) {\n\t\t\tif (methodName.equals(\"setUp\"))\n\t\t\t\tsetUpAnnotation = MethodAnnotation.fromVisitedMethod(this);\n\t\t\telse if (methodName.equals(\"tearDown\"))\n\t\t\t\ttearDownAnnotation = MethodAnnotation.fromVisitedMethod(this);\n\t\t\tvalidMethod = true;\n\t\t\tstate = SEEN_NOTHING;\n\t\t\tsuper.visit(obj);\n\t\t} else if (methodName.equals(\"suite\") && !obj.isStatic())\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"IJU_SUITE_NOT_STATIC\", NORMAL_PRIORITY)\n\t\t\t        .addClass(this)\n\t\t\t        .addMethod(MethodAnnotation.fromVisitedMethod(this)));\n\t}","id":45678,"modified_method":"public void visit(Method obj) {\n\t\tif (getMethodName().equals(\"suite\") && !obj.isStatic())\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"IJU_SUITE_NOT_STATIC\",\n\t\t\t\t\tNORMAL_PRIORITY).addClassAndMethod(this));\n\n\t}","commit_id":"172a6078e7ed539e65d7588cdca781634b59dfda","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Code obj) {\n\t\tif (validClass && validMethod)\n\t\t\tsuper.visit(obj);\n\t}","id":45679,"modified_method":"public void visit(Code obj) {\n\t\tif (!directChildOfTestCase\n\t\t\t\t&& (getMethodName().equals(\"setUp\") || getMethodName().equals(\n\t\t\t\t\t\t\"tearDown\"))) {\n\t\t\tsawSuperCall = false;\n\t\t\tsuper.visit(obj);\n\t\t\tif (sawSuperCall)\n\t\t\t\treturn;\n\t\t\tJavaClass we = Lookup.findSuperImplementor(getThisClass(),\n\t\t\t\t\tgetMethodName(), \"()V\", bugReporter);\n\t\t\tif (!we.getClassName().equals(\"junit.framework.TestCase\")) {\n\t\t\t\t// OK, got a bug\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, getMethodName()\n\t\t\t\t\t\t.equals(\"setUp\") ? \"IJU_SETUP_NO_SUPER\"\n\t\t\t\t\t\t: \"IJU_TEARDOWN_NO_SUPER\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this));\n\t\t\t}\n\t\t}\n\t}","commit_id":"172a6078e7ed539e65d7588cdca781634b59dfda","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void sawOpcode(int seen) {\n\t\tswitch (state) {\n\t\tcase SEEN_NOTHING:\n\t\t\tif (seen == ALOAD_0)\n\t\t\t\tstate = SEEN_ALOAD_0;\n\t\t\tbreak;\n\n\t\tcase SEEN_ALOAD_0:\n//\t\t\tif (seen == INVOKESPECIAL)\n//\t\t\t\tSystem.out.println(getNameConstantOperand());\n\t\t\tif ((seen == INVOKESPECIAL)\n\t\t\t        && (getNameConstantOperand().equals(methodName))\n\t\t\t        && (getMethodSig().equals(\"()V\"))) {\n\t\t\t\tif (methodName.equals(\"setUp\"))\n\t\t\t\t\tsawSetUp = true;\n\t\t\t\telse if (methodName.equals(\"tearDown\"))\n\t\t\t\t\tsawTearDown = true;\n\t\t\t}\n\t\t\tstate = SEEN_NOTHING;\n\t\t\tbreak;\n\t\t}\n\t}","id":45680,"modified_method":"public void sawOpcode(int seen) {\n\t\tswitch (state) {\n\t\tcase SEEN_NOTHING:\n\t\t\tif (seen == ALOAD_0)\n\t\t\t\tstate = SEEN_ALOAD_0;\n\t\t\tbreak;\n\n\t\tcase SEEN_ALOAD_0:\n\t\t\tif ((seen == INVOKESPECIAL)\n\t\t\t\t\t&& (getNameConstantOperand().equals(getMethodName()))\n\t\t\t\t\t&& (getMethodSig().equals(\"()V\")))\n\t\t\t\tsawSuperCall = true;\n\t\t\tstate = SEEN_NOTHING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate = SEEN_NOTHING;\n\t\t}\n\t}","commit_id":"172a6078e7ed539e65d7588cdca781634b59dfda","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\ttry {\n\t\t\tsetUpAnnotation = null;\n\t\t\ttearDownAnnotation = null;\n\t\t\tvalidClass = false;\n\t\t\tvalidMethod = false;\n\t\t\tsawSetUp = false;\n\t\t\tsawTearDown = false;\n\t\t\tJavaClass[] superClasses = classContext.getJavaClass().getSuperClasses();\n\t\t\tfor (int i = 0; i < superClasses.length; i++) {\n\t\t\t\tJavaClass sc = superClasses[i];\n\t\t\t\tif (sc.getClassName().equals(\"junit.framework.TestCase\")) {\n\t\t\t\t\tvalidClass = true;\n\t\t\t\t\tclassContext.getJavaClass().accept(this);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\tbugReporter.reportMissingClass(cnfe);\n\t\t}\n\t\t\t\n\t}","id":45681,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass jClass = classContext.getJavaClass();\n\n\t\ttry {\n\t\t\tif (!Repository.instanceOf(jClass, \"junit.framework.TestCase\"))\n\t\t\t\treturn;\n\n\t\t\tJavaClass superClass = jClass.getSuperClass();\n\t\t\tdirectChildOfTestCase = superClass.getClassName().equals(\n\t\t\t\t\t\"junit.framework.TestCase\");\n\t\t\tjClass.accept(this);\n\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\tbugReporter.reportMissingClass(cnfe);\n\t\t}\n\n\t}","commit_id":"172a6078e7ed539e65d7588cdca781634b59dfda","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(JavaClass obj) {\n\t\tif (obj.isInterface())\n\t\t\treturn;\n\t\tclassFields.clear();\n\t\t\n\t\tField[] fields = obj.getFields();\n\t\tString fieldName;\n\t\tfor (int f = 0; f < fields.length; f++) {\n\t\t\tfieldName = fields[f].getName();\n\t\t\tclassFields.put(fieldName, fields[f]);\n\t\t}\n\t\t\n\t\t// Walk up the super class chain, looking for name collisions\n\t\ttry\n\t\t{\t\n\t\t\tJavaClass[] superClasses = org.apache.bcel.Repository.getSuperClasses(obj);\n\t\t\t\tfor (int c = 0; c < superClasses.length; c++) {\n\t\t\t\t\tfields = superClasses[c].getFields();\n\t\t\t\t\tfor (int f = 0; f < fields.length; f++) {\n\t\t\t\t\t\tField fld = fields[f];\n\t\t\t\t\t\tif (!fld.isStatic() \n\t\t\t\t\t\t\t&& !maskedFields.contains(fld)\n\t\t\t\t\t\t\t&& (fld.isPublic() || fld.isProtected())) {\n\t\t\t\t\t\t\tfieldName = fld.getName();\n\t\t\t\t\t\t\tif (fieldName.length() == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (fieldName.equals(\"serialVersionUID\"))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (classFields.containsKey( fieldName )) {\n\t\t\t\t\t\t\t\tmaskedFields.add(fld);\n\t\t\t\t\t\t\t\tField maskingField = classFields.get( fieldName);\n\t\t\t\t\t\t\t\tFieldAnnotation fa = new FieldAnnotation( getDottedClassName(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  maskingField.getName(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t  maskingField.getSignature(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t  maskingField.isStatic());\n\t\t\t\t                                bugReporter.reportBug(\n\t\t\t\t\t\t\t\t\tnew BugInstance(\"MF_CLASS_MASKS_FIELD\", LOW_PRIORITY)\n\t\t\t\t                                        \t.addClass(this)\n\t\t\t\t                                        \t.addField(fa));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e) { \n\t\t\tbugReporter. reportMissingClass(e);\n\t\t}\n\t\t\n\t\tsuper.visit(obj);\n\t}","id":45682,"modified_method":"public void visit(JavaClass obj) {\n\t\tif (obj.isInterface())\n\t\t\treturn;\n\t\tclassFieldMap.clear();\n\t\tsuperclassFieldMap.clear();\n\n\t\t// Build map of fields in this class\n\t\tField[] fields = obj.getFields();\n\t\tString fieldName;\n\t\tfor (int f = 0; f < fields.length; f++) {\n\t\t\tFieldAnnotation fa = FieldAnnotation.fromBCELField(obj.getClassName(), fields[f]);\n\t\t\tclassFieldMap.put(fa.getFieldName(), fa);\n\t\t}\n\n\t\t// Build map of visible instance fields in superclasses\n\t\t// FIXME: would be nice to store these in a persistent data\n\t\t// structure, rather than recreating them for each\n\t\t// subclass.\n\t\ttry {\t\n\t\t\tJavaClass[] superClasses = org.apache.bcel.Repository.getSuperClasses(obj);\n\t\t\tfor (int c = 0; c < superClasses.length; c++) {\n\t\t\t\tField[] superFields = superClasses[c].getFields();\n\t\t\t\tfor (int f = 0; f < superFields.length; f++) {\n\t\t\t\t\tField superfield = superFields[f];\n\n\t\t\t\t\t// Only want instance fields that are guaranteed to be visible\n\t\t\t\t\t// FIXME: doesn't handle package-protected fields, which\n\t\t\t\t\t// might be obscured by another class in the same package\n\t\t\t\t\tif (superfield.isStatic() || !(superfield.isPublic() || superfield.isProtected()))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// Have we seen a superclass field with this name yet?\n\t\t\t\t\tif (superclassFieldMap.get(superfield.getName()) != null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// Add it\n\t\t\t\t\tFieldAnnotation faSuper =\n\t\t\t\t\t\tFieldAnnotation.fromBCELField(superClasses[c].getClassName(), superfield);\n\t\t\t\t\tsuperclassFieldMap.put(superfield.getName(), faSuper);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) { \n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\t\t// Masked fields are the intersection of the fields defined\n\t\t// by the class and the visible superclass fields.\n\t\tMap<String, FieldAnnotation> intersection = new HashMap<String, FieldAnnotation>(superclassFieldMap);\n\t\tintersection.keySet().retainAll(classFieldMap.keySet());\n\t\tfor (Iterator<FieldAnnotation> i = intersection.values().iterator(); i.hasNext(); ) {\n\t\t\tbugReporter.reportBug(new BugInstance(\"MF_CLASS_MASKS_FIELD\", LOW_PRIORITY)\n\t\t\t\t.addClass(this)\n\t\t\t\t.addField(i.next()).describe(\"FIELD_SUPER\"));\n\t\t}\n\n\t\tsuper.visit(obj);\n\t}","commit_id":"506ed3710260cd6b1d43af392632d19dde933e38","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(LocalVariableTable obj) {\n\t\tif (staticMethod)\n\t\t\treturn;\n\t\t\t\n\t\tLocalVariable[] vars = obj.getLocalVariableTable();\n\t\tfor (int v = numParms+1; v < vars.length; v++) { \n\t\t\tLocalVariable var = vars[v];\n\t\t\tString varName = var.getName();\n\t\t\tif (varName.equals(\"serialVersionUID\"))\n\t\t\t\tcontinue;\n\t\t\tif (classFields.containsKey(varName)) {\n\t\t\t\tFieldAnnotation fa = new FieldAnnotation( getDottedClassName(), \n\t\t\t\t\t\t\t\t\t\tvarName, \n\t\t\t\t\t\t\t\t\t\tvar.getSignature(), \n\t\t\t\t\t\t\t\t\t\tfalse);\n\t\t\t\tMethodAnnotation ma = MethodAnnotation.fromVisitedMethod(this);\n\t\t\t\tif (var.getStartPC() > 0)\n\t\t                        bugReporter.reportBug(\n\t\t\t\t\t\tnew BugInstance(\"MF_METHOD_MASKS_FIELD\", NORMAL_PRIORITY)\n\t\t                                \t.addClass(this)\n\t\t                                \t.addMethod(ma)\n\t\t                                \t.addField(fa)\n\t\t                                \t.addSourceLine(this, var.getStartPC()-1));\n\t\t\t}\n\t\t}\n\t\tsuper.visit(obj);\n\t}","id":45683,"modified_method":"public void visit(LocalVariableTable obj) {\n\t\tif (staticMethod)\n\t\t\treturn;\n\t\t\t\n\t\tLocalVariable[] vars = obj.getLocalVariableTable();\n\t\tfor (int v = numParms+1; v < vars.length; v++) { \n\t\t\tLocalVariable var = vars[v];\n\t\t\tString varName = var.getName();\n\t\t\tif (varName.equals(\"serialVersionUID\"))\n\t\t\t\tcontinue;\n\t\t\tFieldAnnotation fa;\n\t\t\tif ((fa = classFieldMap.get(varName)) != null || (fa = superclassFieldMap.get(varName)) != null) {\n\t\t\t\tif (var.getStartPC() > 0)\n\t\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\tnew BugInstance(\"MF_METHOD_MASKS_FIELD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addField(fa)\n\t\t\t\t\t\t\t.addSourceLine(this, var.getStartPC()-1));\n\t\t\t}\n\t\t}\n\t\tsuper.visit(obj);\n\t}","commit_id":"506ed3710260cd6b1d43af392632d19dde933e38","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"protected String prependI18nLanguageId(\n\t\tHttpServletRequest request, String i18nLanguageId,\n\t\tint prependFriendlyUrlStyle) {\n\n\t\tString userLanguageId = null;\n\n\t\tUser user = (User)request.getAttribute(WebKeys.USER);\n\n\t\tif (user != null) {\n\t\t\tuserLanguageId = user.getLanguageId();\n\t\t}\n\n\t\tString guestLanguageId = userLanguageId;\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = CookieKeys.getCookie(\n\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID, false);\n\t\t}\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getDefault());\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = defaultLanguageId;\n\t\t}\n\n\t\tif ((prependFriendlyUrlStyle == 1) ||\n\t\t\t((prependFriendlyUrlStyle == 3) &&\n\t\t\t Validator.isNull(userLanguageId))) {\n\n\t\t\tif (!defaultLanguageId.equals(guestLanguageId)) {\n\t\t\t\ti18nLanguageId = guestLanguageId;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 2) {\n\t\t\ti18nLanguageId = LocaleUtil.toLanguageId(\n\t\t\t\tPortalUtil.getLocale(request));\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 3) {\n\t\t\tif (Validator.isNotNull(userLanguageId)) {\n\t\t\t\tHttpSession session = request.getSession();\n\n\t\t\t\tLocale locale = (Locale)session.getAttribute(\n\t\t\t\t\tGlobals.LOCALE_KEY);\n\n\t\t\t\tif (!userLanguageId.equals(LocaleUtil.toLanguageId(locale))) {\n\t\t\t\t\ti18nLanguageId = LocaleUtil.toLanguageId(locale);\n\n\t\t\t\t\tPortalUtil.addUserLocaleOptionsMessage(request);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn i18nLanguageId;\n\t}","id":45684,"modified_method":"protected String prependI18nLanguageId(\n\t\tHttpServletRequest request, int prependFriendlyUrlStyle) {\n\n\t\tString userLanguageId = null;\n\n\t\tUser user = (User)request.getAttribute(WebKeys.USER);\n\n\t\tif (user != null) {\n\t\t\tuserLanguageId = user.getLanguageId();\n\t\t}\n\n\t\tString guestLanguageId = userLanguageId;\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = CookieKeys.getCookie(\n\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID, false);\n\t\t}\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getDefault());\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = defaultLanguageId;\n\t\t}\n\n\t\tif ((prependFriendlyUrlStyle == 1) ||\n\t\t\t((prependFriendlyUrlStyle == 3) &&\n\t\t\t Validator.isNull(userLanguageId))) {\n\n\t\t\tif (!defaultLanguageId.equals(guestLanguageId)) {\n\t\t\t\treturn guestLanguageId;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 2) {\n\t\t\treturn LocaleUtil.toLanguageId(PortalUtil.getLocale(request));\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 3) {\n\t\t\tif (Validator.isNotNull(userLanguageId)) {\n\t\t\t\tHttpSession session = request.getSession();\n\n\t\t\t\tLocale locale = (Locale)session.getAttribute(\n\t\t\t\t\tGlobals.LOCALE_KEY);\n\n\t\t\t\tif (!userLanguageId.equals(LocaleUtil.toLanguageId(locale))) {\n\t\t\t\t\tPortalUtil.addUserLocaleOptionsMessage(request);\n\n\t\t\t\t\treturn LocaleUtil.toLanguageId(locale);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"39a6f6cf136726aeab5eaf3a5dec5f12a2358d1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getRedirect(HttpServletRequest request) throws Exception {\n\t\tif (PropsValues.LOCALE_PREPEND_FRIENDLY_URL_STYLE == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString method = request.getMethod();\n\n\t\tif (method.equals(HttpMethods.POST)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString requestURI = request.getRequestURI();\n\n\t\tif (Validator.isNotNull(contextPath) &&\n\t\t\trequestURI.contains(contextPath)) {\n\n\t\t\trequestURI = requestURI.substring(contextPath.length());\n\t\t}\n\n\t\trequestURI = StringUtil.replace(\n\t\t\trequestURI, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tString i18nLanguageId = requestURI.substring(1);\n\n\t\tint pos = requestURI.indexOf(CharPool.SLASH, 1);\n\n\t\tif (pos != -1) {\n\t\t\ti18nLanguageId = i18nLanguageId.substring(0, pos - 1);\n\t\t}\n\n\t\tif (_languageIds.contains(i18nLanguageId)) {\n\t\t\treturn null;\n\t\t}\n\n\t\ti18nLanguageId = prependI18nLanguageId(\n\t\t\trequest, i18nLanguageId,\n\t\t\tPropsValues.LOCALE_PREPEND_FRIENDLY_URL_STYLE);\n\n\t\tif (i18nLanguageId == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tLocale locale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\n\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString i18nPathLanguageId = PortalUtil.getI18nPathLanguageId(\n\t\t\tlocale, i18nLanguageId);\n\n\t\tString i18nPath = StringPool.SLASH.concat(i18nPathLanguageId);\n\n\t\tif (requestURI.contains(i18nPath.concat(StringPool.SLASH))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString redirect = contextPath + i18nPath + requestURI;\n\n\t\tLayoutSet layoutSet = (LayoutSet)request.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (layoutSet != null) {\n\t\t\tint[] groupFriendlyURLIndex = PortalUtil.getGroupFriendlyURLIndex(\n\t\t\t\trequestURI);\n\n\t\t\tif (groupFriendlyURLIndex != null) {\n\t\t\t\tint x = groupFriendlyURLIndex[0];\n\t\t\t\tint y = groupFriendlyURLIndex[1];\n\n\t\t\t\tString groupFriendlyURL = requestURI.substring(x, y);\n\n\t\t\t\tGroup group = layoutSet.getGroup();\n\n\t\t\t\tif (groupFriendlyURL.equals(group.getFriendlyURL())) {\n\t\t\t\t\tredirect = contextPath + i18nPath + requestURI.substring(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (Validator.isNotNull(queryString)) {\n\t\t\tredirect += StringPool.QUESTION + request.getQueryString();\n\t\t}\n\n\t\treturn redirect;\n\t}","id":45685,"modified_method":"protected String getRedirect(HttpServletRequest request) throws Exception {\n\t\tif (PropsValues.LOCALE_PREPEND_FRIENDLY_URL_STYLE == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString method = request.getMethod();\n\n\t\tif (method.equals(HttpMethods.POST)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString requestURI = request.getRequestURI();\n\n\t\tif (Validator.isNotNull(contextPath) &&\n\t\t\trequestURI.contains(contextPath)) {\n\n\t\t\trequestURI = requestURI.substring(contextPath.length());\n\t\t}\n\n\t\trequestURI = StringUtil.replace(\n\t\t\trequestURI, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tString i18nLanguageId = prependI18nLanguageId(\n\t\t\trequest, PropsValues.LOCALE_PREPEND_FRIENDLY_URL_STYLE);\n\n\t\tif (i18nLanguageId == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tLocale locale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\n\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString i18nPathLanguageId = PortalUtil.getI18nPathLanguageId(\n\t\t\tlocale, i18nLanguageId);\n\n\t\tString i18nPath = StringPool.SLASH.concat(i18nPathLanguageId);\n\n\t\tif (requestURI.contains(i18nPath.concat(StringPool.SLASH))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString redirect = contextPath + i18nPath + requestURI;\n\n\t\tLayoutSet layoutSet = (LayoutSet)request.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (layoutSet != null) {\n\t\t\tint[] groupFriendlyURLIndex = PortalUtil.getGroupFriendlyURLIndex(\n\t\t\t\trequestURI);\n\n\t\t\tif (groupFriendlyURLIndex != null) {\n\t\t\t\tint x = groupFriendlyURLIndex[0];\n\t\t\t\tint y = groupFriendlyURLIndex[1];\n\n\t\t\t\tString groupFriendlyURL = requestURI.substring(x, y);\n\n\t\t\t\tGroup group = layoutSet.getGroup();\n\n\t\t\t\tif (groupFriendlyURL.equals(group.getFriendlyURL())) {\n\t\t\t\t\tredirect = contextPath + i18nPath + requestURI.substring(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (Validator.isNotNull(queryString)) {\n\t\t\tredirect += StringPool.QUESTION + request.getQueryString();\n\t\t}\n\n\t\treturn redirect;\n\t}","commit_id":"39a6f6cf136726aeab5eaf3a5dec5f12a2358d1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getPrependI18nLanguageId(\n\t\t\tint localePrependFriendlyURLStyle, Locale userLocale,\n\t\t\tLocale sessionLocale, Locale cookieLocale)\n\t\tthrows Exception {\n\n\t\tHttpSession session = _request.getSession();\n\n\t\tsession.setAttribute(Globals.LOCALE_KEY, sessionLocale);\n\n\t\tif (userLocale != null) {\n\t\t\tUser user = UserTestUtil.addUser(\n\t\t\t\tServiceTestUtil.randomString(), true, userLocale,\n\t\t\t\tServiceTestUtil.randomString(), ServiceTestUtil.randomString(),\n\t\t\t\tnew long[] {TestPropsValues.getGroupId()});\n\n\t\t\t_request.setAttribute(WebKeys.USER, user);\n\t\t}\n\n\t\tif (cookieLocale != null) {\n\t\t\tLanguageUtil.updateCookie(_request, _response, cookieLocale);\n\n\t\t\t// passing cookies from mockresponse to mockrequest\n\n\t\t\t_request.setCookies(_response.getCookies());\n\t\t}\n\n\t\treturn _i18nFilter.prependI18nLanguageId(\n\t\t\t_request, StringPool.BLANK, localePrependFriendlyURLStyle);\n\t}","id":45686,"modified_method":"protected String getPrependI18nLanguageId(\n\t\t\tint localePrependFriendlyURLStyle, Locale userLocale,\n\t\t\tLocale sessionLocale, Locale cookieLocale)\n\t\tthrows Exception {\n\n\t\tHttpSession session = _request.getSession();\n\n\t\tsession.setAttribute(Globals.LOCALE_KEY, sessionLocale);\n\n\t\tif (userLocale != null) {\n\t\t\tUser user = UserTestUtil.addUser(\n\t\t\t\tServiceTestUtil.randomString(), true, userLocale,\n\t\t\t\tServiceTestUtil.randomString(), ServiceTestUtil.randomString(),\n\t\t\t\tnew long[] {TestPropsValues.getGroupId()});\n\n\t\t\t_request.setAttribute(WebKeys.USER, user);\n\t\t}\n\n\t\tif (cookieLocale != null) {\n\t\t\tLanguageUtil.updateCookie(_request, _response, cookieLocale);\n\n\t\t\t// passing cookies from mockresponse to mockrequest\n\n\t\t\t_request.setCookies(_response.getCookies());\n\t\t}\n\n\t\treturn _i18nFilter.prependI18nLanguageId(\n\t\t\t_request, localePrependFriendlyURLStyle);\n\t}","commit_id":"39a6f6cf136726aeab5eaf3a5dec5f12a2358d1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String generateLocalizedContent(\n\t\tString content, Locale defaultLocale) {\n\n\t\tStringBundler sb = new StringBundler(8 + 6 * _locales.length);\n\n\t\tStringBuilder availableLocales = new StringBuilder();\n\n\t\tfor (int i = 0; i < _locales.length; i++) {\n\t\t\tLocale locale = _locales[i];\n\n\t\t\tavailableLocales.append(LocaleUtil.toLanguageId(locale));\n\n\t\t\tif (i != (_locales.length - 1)) {\n\t\t\t\tavailableLocales.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"<?xml version=\\\"1.0\\\"?><root available-locales=\");\n\t\tsb.append(\"\\\"\");\n\t\tsb.append(availableLocales.toString());\n\t\tsb.append(\"\\\" \");\n\t\tsb.append(\"default-locale=\\\"\");\n\t\tsb.append(LocaleUtil.toLanguageId(defaultLocale));\n\t\tsb.append(\"\\\">\");\n\n\t\tfor (Locale locale : _locales) {\n\t\t\tsb.append(\"<static-content language-id=\\\"\");\n\t\t\tsb.append(LocaleUtil.toLanguageId(locale));\n\t\t\tsb.append(\"\\\"><![CDATA[<p>\");\n\t\t\tsb.append(content);\n\t\t\tsb.append(LocaleUtil.toLanguageId(locale));\n\t\t\tsb.append(\"<\/p>]]><\/static-content>\");\n\t\t}\n\n\t\tsb.append(\"<\/root>\");\n\n\t\treturn sb.toString();\n\t}","id":45687,"modified_method":"public static String generateLocalizedContent(\n\t\tString content, Locale defaultLocale) {\n\n\t\tStringBuilder availableLocales = new StringBuilder();\n\n\t\tfor (int i = 0; i < _locales.length; i++) {\n\t\t\tLocale locale = _locales[i];\n\n\t\t\tavailableLocales.append(LocaleUtil.toLanguageId(locale));\n\n\t\t\tif (i != (_locales.length - 1)) {\n\t\t\t\tavailableLocales.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tDocument document = createDocument(\n\t\t\tavailableLocales.toString(),\n\t\t\tLocaleUtil.toLanguageId(defaultLocale));\n\n\t\tfor (Locale locale : _locales) {\n\t\t\tStringBuilder sb = new StringBuilder(3);\n\n\t\t\tsb.append(content);\n\t\t\tsb.append(\" - \");\n\t\t\tsb.append(LocaleUtil.toLanguageId(locale));\n\n\t\t\taddLanguageIdElement(\n\t\t\t\tdocument.getRootElement(), LocaleUtil.toLanguageId(locale),\n\t\t\t\tsb.toString());\n\t\t}\n\n\t\treturn document.asXML();\n\t}","commit_id":"88a5dd3f2d35db742d2cec29d0d7a11b4867fb1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _prependIfRequestedLocaleDiffersFromDefaultLocale(\n\t\tString defaultLanguageId, String guestLanguageId) {\n\n\t\treturn (!defaultLanguageId.equals(guestLanguageId)) ?\n\t\t\tguestLanguageId : null;\n\t}","id":45688,"modified_method":"private String _prependIfRequestedLocaleDiffersFromDefaultLocale(\n\t\tString defaultLanguageId, String guestLanguageId) {\n\n\t\tif (defaultLanguageId.equals(guestLanguageId))  {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn guestLanguageId;\n\t}","commit_id":"553bb28bca16720eedd7aec11e1fea82080d0cc9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String prependI18nLanguageId(\n\t\tHttpServletRequest request, int prependFriendlyUrlStyle) {\n\n\t\tString userLanguageId = null;\n\n\t\tUser user = (User)request.getAttribute(WebKeys.USER);\n\n\t\tif (user != null) {\n\t\t\tuserLanguageId = user.getLanguageId();\n\t\t}\n\n\t\tString guestLanguageId = userLanguageId;\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = CookieKeys.getCookie(\n\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID, false);\n\t\t}\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getDefault());\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = defaultLanguageId;\n\t\t}\n\n\t\tif (prependFriendlyUrlStyle == 1) {\n\t\t\treturn _prependIfRequestedLocaleDiffersFromDefaultLocale(\n\t\t\t\tdefaultLanguageId, guestLanguageId);\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 2) {\n\t\t\treturn LocaleUtil.toLanguageId(PortalUtil.getLocale(request));\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 3) {\n\t\t\tif (user != null) {\n\t\t\t\tHttpSession session = request.getSession();\n\n\t\t\t\tLocale locale = (Locale)session.getAttribute(\n\t\t\t\t\tGlobals.LOCALE_KEY);\n\n\t\t\t\treturn !userLanguageId.equals(LocaleUtil.toLanguageId(locale)) ?\n\t\t\t\t\tLocaleUtil.toLanguageId(locale) : null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn _prependIfRequestedLocaleDiffersFromDefaultLocale(\n\t\t\t\t\tdefaultLanguageId, guestLanguageId);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":45689,"modified_method":"protected String prependI18nLanguageId(\n\t\tHttpServletRequest request, int prependFriendlyUrlStyle) {\n\n\t\tString userLanguageId = null;\n\n\t\tUser user = (User)request.getAttribute(WebKeys.USER);\n\n\t\tif (user != null) {\n\t\t\tuserLanguageId = user.getLanguageId();\n\t\t}\n\n\t\tString guestLanguageId = userLanguageId;\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = CookieKeys.getCookie(\n\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID, false);\n\t\t}\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getDefault());\n\n\t\tif (Validator.isNull(guestLanguageId)) {\n\t\t\tguestLanguageId = defaultLanguageId;\n\t\t}\n\n\t\tif (prependFriendlyUrlStyle == 1) {\n\t\t\treturn _prependIfRequestedLocaleDiffersFromDefaultLocale(\n\t\t\t\tdefaultLanguageId, guestLanguageId);\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 2) {\n\t\t\treturn LocaleUtil.toLanguageId(PortalUtil.getLocale(request));\n\t\t}\n\t\telse if (prependFriendlyUrlStyle == 3) {\n\t\t\tif (user != null) {\n\t\t\t\tHttpSession session = request.getSession();\n\n\t\t\t\tLocale locale = (Locale)session.getAttribute(\n\t\t\t\t\tGlobals.LOCALE_KEY);\n\n\t\t\t\tif (userLanguageId.equals(LocaleUtil.toLanguageId(locale))) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn LocaleUtil.toLanguageId(locale);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn _prependIfRequestedLocaleDiffersFromDefaultLocale(\n\t\t\t\t\tdefaultLanguageId, guestLanguageId);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"553bb28bca16720eedd7aec11e1fea82080d0cc9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Creates a child {@ling Agent} witht the given name.\n     *\n     * @param name The name of the child {@ling Agent}.\n     * @return\n     */\n    protected Container createChildAgent(String name) throws InterruptedException {\n        //Wait for zookeeper service to become available.\n        IZKClient zooKeeper = getOsgiService(IZKClient.class);\n\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n\n        Thread.sleep(DEFAULT_WAIT);\n\n        Container[] containers = fabricService.getContainers();\n        assertNotNull(containers);\n\n        assertEquals(\"Expected to find 1 container\", 1, containers.length);\n        Container parent = containers[0];\n        assertEquals(\"Expected to find the root container\", \"root\", parent.getId());\n\n        CreateContainerOptions args = CreateContainerOptionsBuilder.basic().name(\"chlid1\").parent(parent.getId());\n        Container child = fabricService.createContainers(args)[0];\n        return child;\n    }","id":45690,"modified_method":"/**\n     * Creates a child {@ling Agent} witht the given name.\n     *\n     * @param name The name of the child {@ling Agent}.\n     * @return\n     */\n    protected Container createChildAgent(String name) throws Exception {\n        //Wait for zookeeper service to become available.\n        IZKClient zooKeeper = getOsgiService(IZKClient.class);\n\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n\n        Thread.sleep(DEFAULT_WAIT);\n\n        Container[] containers = fabricService.getContainers();\n        assertNotNull(containers);\n\n        assertEquals(\"Expected to find 1 container\", 1, containers.length);\n        Container parent = containers[0];\n        assertEquals(\"Expected to find the root container\", \"root\", parent.getId());\n\n        CreateContainerOptions args = CreateContainerOptionsBuilder.basic().name(\"chlid1\").parent(parent.getId());\n        CreateContainerMetadata[] metadata = fabricService.createContainers(args);\n        if (metadata.length > 0) {\n            return metadata[0].getContainer();\n        }\n        throw new Exception(\"Cohild container not created\");\n    }","commit_id":"26142e811a6fd3d3389b1fbc4919edd91efc66c7","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates a child {@ling Agent} witht the given name.\n     *\n     * @param name The name of the child {@ling Agent}.\n     * @return\n     */\n    protected Container createChildAgent(String name) throws InterruptedException {\n        //Wait for zookeeper service to become available.\n        IZKClient zooKeeper = getOsgiService(IZKClient.class);\n\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n\n        Thread.sleep(DEFAULT_WAIT);\n\n        Container[] containers = fabricService.getContainers();\n        assertNotNull(containers);\n\n        assertEquals(\"Expected to find 1 container\", 1, containers.length);\n        Container parent = containers[0];\n        assertEquals(\"Expected to find the root container\", \"root\", parent.getId());\n\n        CreateContainerOptions args = CreateContainerOptionsBuilder.basic().name(\"chlid1\").parent(parent.getId());\n        Container child = fabricService.createContainers(args)[0];\n        return child;\n    }","id":45691,"modified_method":"/**\n     * Creates a child {@ling Agent} witht the given name.\n     *\n     * @param name The name of the child {@ling Agent}.\n     * @return\n     */\n    protected Container createChildAgent(String name) throws Exception {\n        //Wait for zookeeper service to become available.\n        IZKClient zooKeeper = getOsgiService(IZKClient.class);\n\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n\n        Thread.sleep(DEFAULT_WAIT);\n\n        Container[] containers = fabricService.getContainers();\n        assertNotNull(containers);\n\n        assertEquals(\"Expected to find 1 container\", 1, containers.length);\n        Container parent = containers[0];\n        assertEquals(\"Expected to find the root container\", \"root\", parent.getId());\n\n        CreateContainerOptions args = CreateContainerOptionsBuilder.basic().name(\"chlid1\").parent(parent.getId());\n        CreateContainerMetadata[] metadata = fabricService.createContainers(args);\n        if (metadata.length > 0) {\n            return metadata[0].getContainer();\n        }\n        throw new Exception(\"Cohild container not created\");\n    }","commit_id":"47f01a19b46c78d2af3fb3cb902c687d6ffcb304","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public CreateContainerMetadata<?>[] createContainers(Map<String, String> options) {\n\n        String providerType = options.get(\"providerType\");\n\n        if (providerType == null) {\n            throw new RuntimeException(\"No providerType provided\");\n        }\n\n        CreateContainerOptions createContainerOptions = null;\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        if (providerType.equals(\"child\")) {\n            createContainerOptions = mapper.convertValue(options, CreateContainerChildOptions.class);\n            createContainerOptions.setResolver(null);\n        } else if (providerType.equals(\"ssh\")) {\n            createContainerOptions = mapper.convertValue(options, CreateSshContainerOptions.class);\n        } else if (providerType.equals(\"jclouds\")) {\n            createContainerOptions = mapper.convertValue(options, CreateJCloudsContainerOptions.class);\n        }\n\n        if (createContainerOptions == null) {\n            throw new RuntimeException(\"Unknown provider type : \" + providerType);\n        }\n\n        createContainerOptions.setZookeeperPassword(getFabricService().getZookeeperPassword());\n        createContainerOptions.setZookeeperUrl(getFabricService().getZookeeperUrl());\n\n        return getFabricService().createContainers(createContainerOptions);\n    }","id":45692,"modified_method":"@Override\n    public Map<String, String> createContainers(Map<String, String> options) {\n\n        String providerType = options.get(\"providerType\");\n\n        if (providerType == null) {\n            throw new RuntimeException(\"No providerType provided\");\n        }\n\n        CreateContainerOptions createContainerOptions = null;\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        if (providerType.equals(\"child\")) {\n            createContainerOptions = mapper.convertValue(options, CreateContainerChildOptions.class);\n            createContainerOptions.setResolver(null);\n        } else if (providerType.equals(\"ssh\")) {\n            createContainerOptions = mapper.convertValue(options, CreateSshContainerOptions.class);\n        } else if (providerType.equals(\"jclouds\")) {\n            createContainerOptions = mapper.convertValue(options, CreateJCloudsContainerOptions.class);\n        }\n\n        if (createContainerOptions == null) {\n            throw new RuntimeException(\"Unknown provider type : \" + providerType);\n        }\n\n        createContainerOptions.setZookeeperPassword(getFabricService().getZookeeperPassword());\n        createContainerOptions.setZookeeperUrl(getFabricService().getZookeeperUrl());\n\n        CreateContainerMetadata<?> metadatas[] = getFabricService().createContainers(createContainerOptions);\n\n        Map<String, String> rc = new HashMap<String, String>();\n\n        for(CreateContainerMetadata<?> metadata : metadatas) {\n            if (!metadata.isSuccess()) {\n                rc.put(metadata.getContainerName(), metadata.getFailure().getMessage());\n            }\n        }\n\n        return rc;\n    }","commit_id":"ea26ad4ab6690ffff76178876a101ce3bacf0e14","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void build() {\n        setLayout(new BorderLayout());\n        setBorder(BorderFactory.createEmptyBorder(3,3,3,3));\n        add(buildUploadCommentPanel(), BorderLayout.NORTH);\n        add(pnlUploadParameterSummary = new UploadParameterSummaryPanel(), BorderLayout.CENTER);\n    }","id":45693,"modified_method":"protected void build() {\n        setLayout(new BorderLayout());\n        setBorder(BorderFactory.createEmptyBorder(3,3,3,3));\n        add(buildUploadCommentPanel(), BorderLayout.NORTH);\n        add(pnlUploadParameterSummary, BorderLayout.CENTER);\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected JPanel buildUploadCommentPanel() {\n        JPanel pnl = new JPanel();\n        pnl.setLayout(new GridBagLayout());\n        pnl.add(new JLabel(tr(\"Provide a brief comment for the changes you are uploading:\")), GBC.eol().insets(0, 5, 10, 3));\n        hcbUploadComment = new HistoryComboBox();\n        hcbUploadComment.setToolTipText(tr(\"Enter an upload comment\"));\n        hcbUploadComment.setMaxTextLength(Changeset.MAX_COMMENT_LENGTH);\n        List<String> cmtHistory = new LinkedList<String>(Main.pref.getCollection(HISTORY_KEY, new LinkedList<String>()));\n        // we have to reverse the history, because ComboBoxHistory will reverse it again\n        // in addElement()\n        //\n        Collections.reverse(cmtHistory);\n        hcbUploadComment.setPossibleItems(cmtHistory);\n        hcbUploadComment.getEditor().addActionListener(\n                new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        changesetCommentModel.setComment(hcbUploadComment.getText());\n                    }\n                }\n        );\n        hcbUploadComment.getEditor().getEditorComponent().addFocusListener(\n                new FocusAdapter() {\n                    @Override\n                    public void focusLost(FocusEvent e) {\n                        changesetCommentModel.setComment(hcbUploadComment.getText());\n                    }\n                }\n        );\n        pnl.add(hcbUploadComment, GBC.eol().fill(GBC.HORIZONTAL));\n        return pnl;\n    }","id":45694,"modified_method":"protected JPanel buildUploadCommentPanel() {\n        JPanel pnl = new JPanel();\n        pnl.setLayout(new GridBagLayout());\n\n        pnl.add(new JLabel(tr(\"Provide a brief comment for the changes you are uploading:\")), GBC.eol().insets(0, 5, 10, 3));\n        hcbUploadComment.setToolTipText(tr(\"Enter an upload comment\"));\n        hcbUploadComment.setMaxTextLength(Changeset.MAX_COMMENT_LENGTH);\n        List<String> cmtHistory = new LinkedList<String>(Main.pref.getCollection(HISTORY_KEY, new LinkedList<String>()));\n        Collections.reverse(cmtHistory); // we have to reverse the history, because ComboBoxHistory will reverse it again in addElement()\n        hcbUploadComment.setPossibleItems(cmtHistory);\n        final CommentModelListener commentModelListener = new CommentModelListener(hcbUploadComment, changesetCommentModel);\n        hcbUploadComment.getEditor().addActionListener(commentModelListener);\n        hcbUploadComment.getEditor().getEditorComponent().addFocusListener(commentModelListener);\n        pnl.add(hcbUploadComment, GBC.eol().fill(GBC.HORIZONTAL));\n\n        pnl.add(new JLabel(tr(\"Specify the data source for the changes:\")), GBC.eol().insets(0, 8, 10, 3));\n        hcbUploadSource.setToolTipText(tr(\"Enter a source\"));\n        List<String> sourceHistory = new LinkedList<String>(Main.pref.getCollection(SOURCE_HISTORY_KEY, new LinkedList<String>()));\n        Collections.reverse(sourceHistory); // we have to reverse the history, because ComboBoxHistory will reverse it again in addElement()\n        hcbUploadComment.setPossibleItems(sourceHistory);\n        final CommentModelListener sourceModelListener = new CommentModelListener(hcbUploadSource, changesetSourceModel);\n        hcbUploadSource.getEditor().addActionListener(sourceModelListener);\n        hcbUploadSource.getEditor().getEditorComponent().addFocusListener(sourceModelListener);\n        pnl.add(hcbUploadSource, GBC.eol().fill(GBC.HORIZONTAL));\n        return pnl;\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates the panel\n     *\n     * @param changesetCommentModel the model for the changeset comment. Must not be null\n     * @throws IllegalArgumentException thrown if {@code changesetCommentModel} is null\n     */\n    public BasicUploadSettingsPanel(ChangesetCommentModel changesetCommentModel) {\n        CheckParameterUtil.ensureParameterNotNull(changesetCommentModel, \"changesetCommentModel\");\n        this.changesetCommentModel = changesetCommentModel;\n        changesetCommentModel.addObserver(new ChangesetCommentObserver());\n        build();\n    }","id":45695,"modified_method":"/**\n     * Creates the panel\n     *\n     * @param changesetCommentModel the model for the changeset comment. Must not be null\n     * @param changesetSourceModel the model for the changeset source. Must not be null.\n     * @throws IllegalArgumentException thrown if {@code changesetCommentModel} is null\n     */\n    public BasicUploadSettingsPanel(ChangesetCommentModel changesetCommentModel, ChangesetCommentModel changesetSourceModel) {\n        CheckParameterUtil.ensureParameterNotNull(changesetCommentModel, \"changesetCommentModel\");\n        CheckParameterUtil.ensureParameterNotNull(changesetSourceModel, \"changesetSourceModel\");\n        this.changesetCommentModel = changesetCommentModel;\n        this.changesetSourceModel = changesetSourceModel;\n        changesetCommentModel.addObserver(new ChangesetCommentObserver(hcbUploadComment));\n        changesetSourceModel.addObserver(new ChangesetCommentObserver(hcbUploadSource));\n        build();\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void update(Observable o, Object arg) {\n            if (!(o instanceof ChangesetCommentModel)) return;\n            String newComment = (String)arg;\n            if (!hcbUploadComment.getText().equals(newComment)) {\n                hcbUploadComment.setText(newComment);\n            }\n        }","id":45696,"modified_method":"@Override\n        public void update(Observable o, Object arg) {\n            if (!(o instanceof ChangesetCommentModel)) return;\n            String newComment = (String)arg;\n            if (!destination.getText().equals(newComment)) {\n                destination.setText(newComment);\n            }\n        }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Remembers the user input in the preference settings\n     */\n    public void rememberUserInput() {\n        // store the history of comments\n        hcbUploadComment.addCurrentItemToHistory();\n        Main.pref.putCollection(HISTORY_KEY, hcbUploadComment.getHistory());\n        Main.pref.putInteger(HISTORY_LAST_USED_KEY, (int) (System.currentTimeMillis() / 1000));\n    }","id":45697,"modified_method":"/**\n     * Remembers the user input in the preference settings\n     */\n    public void rememberUserInput() {\n        // store the history of comments\n        hcbUploadComment.addCurrentItemToHistory();\n        Main.pref.putCollection(HISTORY_KEY, hcbUploadComment.getHistory());\n        Main.pref.putInteger(HISTORY_LAST_USED_KEY, (int) (System.currentTimeMillis() / 1000));\n        // store the history of sources\n        hcbUploadSource.addCurrentItemToHistory();\n        Main.pref.putCollection(SOURCE_HISTORY_KEY, hcbUploadSource.getHistory());\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void tableChanged(TableModelEvent e) {\n        String uploadComment = getUploadComment();\n        changesetCommentModel.setComment(uploadComment);\n    }","id":45698,"modified_method":"@Override\n    public void tableChanged(TableModelEvent e) {\n        changesetCommentModel.setComment(getTagEditorValue(\"comment\"));\n        changesetSourceModel.setComment(getTagEditorValue(\"source\"));\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void initFromChangeset(Changeset cs) {\n        String currentComment = getUploadComment();\n        Map<String,String> tags = getDefaultTags();\n        if (cs != null) {\n            tags.putAll(cs.getKeys());\n        }\n        if (tags.get(\"comment\") == null) {\n            tags.put(\"comment\", currentComment);\n        }\n        String agent = Version.getInstance().getAgentString(false);\n        String created_by = tags.get(\"created_by\");\n        if (created_by == null || created_by.isEmpty()) {\n            tags.put(\"created_by\", agent);\n        } else if (!created_by.contains(agent)) {\n            tags.put(\"created_by\", created_by + \";\" + agent);\n        }\n        pnlTagEditor.getModel().initFromTags(tags);\n    }","id":45699,"modified_method":"public void initFromChangeset(Changeset cs) {\n        String currentComment = getTagEditorValue(\"comment\");\n        Map<String,String> tags = getDefaultTags();\n        if (cs != null) {\n            tags.putAll(cs.getKeys());\n        }\n        if (tags.get(\"comment\") == null) {\n            tags.put(\"comment\", currentComment);\n        }\n        if (tags.get(\"source\") == null) {\n            tags.put(\"source\", \"\");\n        }\n        String agent = Version.getInstance().getAgentString(false);\n        String created_by = tags.get(\"created_by\");\n        if (created_by == null || created_by.isEmpty()) {\n            tags.put(\"created_by\", agent);\n        } else if (!created_by.contains(agent)) {\n            tags.put(\"created_by\", created_by + \";\" + agent);\n        }\n        pnlTagEditor.getModel().initFromTags(tags);\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void build() {\n        setLayout(new BorderLayout());\n        add(pnlTagEditor = new TagEditorPanel(null), BorderLayout.CENTER);\n    }","id":45700,"modified_method":"protected void build() {\n        setLayout(new BorderLayout());\n        add(pnlTagEditor, BorderLayout.CENTER);\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates a new panel\n     *\n     * @param changesetCommentModel the changeset comment model. Must not be null.\n     * @throws IllegalArgumentException thrown if {@code changesetCommentModel} is null\n     */\n    public TagSettingsPanel(ChangesetCommentModel changesetCommentModel) throws IllegalArgumentException{\n        CheckParameterUtil.ensureParameterNotNull(changesetCommentModel, \"changesetCommentModel\");\n        this.changesetCommentModel = changesetCommentModel;\n        this.changesetCommentModel.addObserver(new ChangesetCommentObserver());\n        build();\n        pnlTagEditor.getModel().addTableModelListener(this);\n    }","id":45701,"modified_method":"/**\n     * Creates a new panel\n     *\n     * @param changesetCommentModel the changeset comment model. Must not be null.\n     * @param changesetSourceModel the changeset source model. Must not be null.\n     * @throws IllegalArgumentException thrown if {@code changesetCommentModel} is null\n     */\n    public TagSettingsPanel(ChangesetCommentModel changesetCommentModel, ChangesetCommentModel changesetSourceModel) throws IllegalArgumentException{\n        CheckParameterUtil.ensureParameterNotNull(changesetCommentModel, \"changesetCommentModel\");\n        CheckParameterUtil.ensureParameterNotNull(changesetSourceModel, \"changesetSourceModel\");\n        this.changesetCommentModel = changesetCommentModel;\n        this.changesetSourceModel = changesetSourceModel;\n        this.changesetCommentModel.addObserver(new ChangesetCommentObserver(\"comment\"));\n        this.changesetSourceModel.addObserver(new ChangesetCommentObserver(\"source\"));\n        build();\n        pnlTagEditor.getModel().addTableModelListener(this);\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void update(Observable o, Object arg) {\n            if (!(o instanceof ChangesetCommentModel)) return;\n            String newValue = (String)arg;\n            String oldValue = getUploadComment();\n            if (oldValue == null) {\n                oldValue = \"\";\n            }\n            if (!oldValue.equals(newValue)) {\n                setUploadComment((String)arg);\n            }\n        }","id":45702,"modified_method":"@Override\n        public void update(Observable o, Object arg) {\n            if (!(o instanceof ChangesetCommentModel)) return;\n            String newValue = (String)arg;\n            String oldValue = getTagEditorValue(key);\n            if (oldValue == null) {\n                oldValue = \"\";\n            }\n            if (!oldValue.equals(newValue)) {\n                setProperty(key, (String) arg);\n            }\n        }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * builds the content panel for the upload dialog\n     *\n     * @return the content panel\n     */\n    protected JPanel buildContentPanel() {\n        JPanel pnl = new JPanel(new GridBagLayout());\n        pnl.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n        // the panel with the list of uploaded objects\n        //\n        pnl.add(pnlUploadedObjects = new UploadedObjectsSummaryPanel(), GBC.eol().fill(GBC.BOTH));\n\n        // Custom components\n        for (Component c : customComponents) {\n            pnl.add(c, GBC.eol().fill(GBC.HORIZONTAL));\n        }\n\n        // a tabbed pane with configuration panels in the lower half\n        //\n        tpConfigPanels = new JTabbedPane() {\n            @Override\n            public Dimension getPreferredSize() {\n                // make sure the tabbed pane never grabs more space than necessary\n                //\n                return super.getMinimumSize();\n            }\n        };\n\n        changesetCommentModel = new ChangesetCommentModel();\n\n        tpConfigPanels.add(pnlBasicUploadSettings = new BasicUploadSettingsPanel(changesetCommentModel));\n        tpConfigPanels.setTitleAt(0, tr(\"Settings\"));\n        tpConfigPanels.setToolTipTextAt(0, tr(\"Decide how to upload the data and which changeset to use\"));\n\n        tpConfigPanels.add(pnlTagSettings = new TagSettingsPanel(changesetCommentModel));\n        tpConfigPanels.setTitleAt(1, tr(\"Tags of new changeset\"));\n        tpConfigPanels.setToolTipTextAt(1, tr(\"Apply tags to the changeset data is uploaded to\"));\n\n        tpConfigPanels.add(pnlChangesetManagement = new ChangesetManagementPanel(changesetCommentModel));\n        tpConfigPanels.setTitleAt(2, tr(\"Changesets\"));\n        tpConfigPanels.setToolTipTextAt(2, tr(\"Manage open changesets and select a changeset to upload to\"));\n\n        tpConfigPanels.add(pnlUploadStrategySelectionPanel = new UploadStrategySelectionPanel());\n        tpConfigPanels.setTitleAt(3, tr(\"Advanced\"));\n        tpConfigPanels.setToolTipTextAt(3, tr(\"Configure advanced settings\"));\n\n        pnl.add(tpConfigPanels, GBC.eol().fill(GBC.HORIZONTAL));\n        return pnl;\n    }","id":45703,"modified_method":"/**\n     * builds the content panel for the upload dialog\n     *\n     * @return the content panel\n     */\n    protected JPanel buildContentPanel() {\n        JPanel pnl = new JPanel(new GridBagLayout());\n        pnl.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n        // the panel with the list of uploaded objects\n        //\n        pnl.add(pnlUploadedObjects = new UploadedObjectsSummaryPanel(), GBC.eol().fill(GBC.BOTH));\n\n        // Custom components\n        for (Component c : customComponents) {\n            pnl.add(c, GBC.eol().fill(GBC.HORIZONTAL));\n        }\n\n        // a tabbed pane with configuration panels in the lower half\n        //\n        tpConfigPanels = new JTabbedPane() {\n            @Override\n            public Dimension getPreferredSize() {\n                // make sure the tabbed pane never grabs more space than necessary\n                //\n                return super.getMinimumSize();\n            }\n        };\n\n        tpConfigPanels.add(pnlBasicUploadSettings = new BasicUploadSettingsPanel(changesetCommentModel, changesetSourceModel));\n        tpConfigPanels.setTitleAt(0, tr(\"Settings\"));\n        tpConfigPanels.setToolTipTextAt(0, tr(\"Decide how to upload the data and which changeset to use\"));\n\n        tpConfigPanels.add(pnlTagSettings = new TagSettingsPanel(changesetCommentModel, changesetSourceModel));\n        tpConfigPanels.setTitleAt(1, tr(\"Tags of new changeset\"));\n        tpConfigPanels.setToolTipTextAt(1, tr(\"Apply tags to the changeset data is uploaded to\"));\n\n        tpConfigPanels.add(pnlChangesetManagement = new ChangesetManagementPanel(changesetCommentModel));\n        tpConfigPanels.setTitleAt(2, tr(\"Changesets\"));\n        tpConfigPanels.setToolTipTextAt(2, tr(\"Manage open changesets and select a changeset to upload to\"));\n\n        tpConfigPanels.add(pnlUploadStrategySelectionPanel = new UploadStrategySelectionPanel());\n        tpConfigPanels.setTitleAt(3, tr(\"Advanced\"));\n        tpConfigPanels.setToolTipTextAt(3, tr(\"Configure advanced settings\"));\n\n        pnl.add(tpConfigPanels, GBC.eol().fill(GBC.HORIZONTAL));\n        return pnl;\n    }","commit_id":"5e5fea49eb0d9224ae4e337b949a0d38278deea7","url":"https://github.com/openstreetmap/josm"},{"original_method":"public MetadataTableEditor()\n       {\n           super(new JTextField());\n           field = (JTextField)getComponent();\n           \n           //categories.setFont(GUI.LabelFace);\n           //categories.setModel(new CategoryComboBoxModel());\n           //categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           \n           //tempPanel = new JPanel();//new ActionPanel(MetadataEditor.this,row);\n           //tempPanel.setOpaque(true);\n           //tempPanel.setBackground(java.awt.Color.BLUE);\n           deleteButton = new edu.tufts.vue.metadata.gui.MetaButton(MetadataEditor.this,\"delete\");\n           //tempPanel.add(deleteButton);\n           // ***needs mouseListener that saves data unless point is over Button..\n           //.addActionListener(deleteButton)\n           //\n           \n           metaButtonPanel = new \n                   edu.tufts.vue.metadata.gui.MetaButtonPanel(MetadataEditor.this,\"delete\");\n           \n       }","id":45704,"modified_method":"public MetadataTableEditor()\n       {\n           super(new JTextField());\n           field = (JTextField)getComponent();\n           \n           // //categories.setFont(GUI.LabelFace);\n           // //categories.setModel(new CategoryComboBoxModel());\n           // //categories.setRenderer(new CategoryComboBoxRenderer());\n           // \n           // //tempPanel = new JPanel();//new ActionPanel(MetadataEditor.this,row);\n           // //tempPanel.setOpaque(true);\n           // //tempPanel.setBackground(java.awt.Color.BLUE);\n           // deleteButton = new edu.tufts.vue.metadata.gui.MetaButton(MetadataEditor.this,\"delete\");\n           // //tempPanel.add(deleteButton);\n           // // ***needs mouseListener that saves data unless point is over Button..\n           // //.addActionListener(deleteButton)\n           // //\n           \n           metaButtonPanel = new edu.tufts.vue.metadata.gui.MetaButtonPanel(MetadataEditor.this,\"delete\");\n       }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"public void addNewRow()\n    {\n        VueMetadataElement vme = new VueMetadataElement();\n        String[] emptyEntry = {NONE_ONT,\"\"};\n        vme.setObject(emptyEntry);\n        vme.setType(VueMetadataElement.CATEGORY);\n        //metadataTable.getModel().setValueAt(vme,metadataTable.getRowCount()+1,0);\n        // wrong order?? not getting intial field in multiples and current could be\n        // non empty when currentMultiples is also..\n        /*if(current !=null)\n        {    \n          MetadataEditor.this.current.getMetadataList().getMetadata().add(vme);\n        }\n        else if(currentMultiples != null)\n        {\n                      \n          currentMultiples.getMetadataList().getMetadata().add(vme);   \n            \n          if(DEBUG_LOCAL)\n          {\n              System.out.println(\"ME: current multiples is not null -- addNewRow \" +\n                      currentMultiples.getMetadataList().getCategoryListSize() );\n          }\n \n        }*/\n        \n        if(currentMultiples != null) {\n          currentMultiples.getMetadataList().getMetadata().add(vme);   \n          if(DEBUG_LOCAL) { System.out.println(\"ME: current multiples is not null -- addNewRow \" + currentMultiples.getMetadataList().getCategoryListSize() ); }\n        }\n        else if (/*AUTO_ADD_EMPTY &&*/ current !=null) {    \n            MetadataEditor.this.current.getMetadataList().getMetadata().add(vme);\n        }\n        ((MetadataTableModel)metadataTable.getModel()).refresh();\n    }","id":45705,"modified_method":"public void addNewRow()\n    {\n        if (DEBUG.PAIN) Log.debug(\"addNewRow, EmptyVME: \" + EmptyVME);\n        \n        VueMetadataElement vme = new VueMetadataElement();\n        String[] emptyEntry = {NONE_ONT,\"\"};\n        vme.setObject(emptyEntry);\n        vme.setType(VueMetadataElement.CATEGORY);\n        //metadataTable.getModel().setValueAt(vme,metadataTable.getRowCount()+1,0);\n        // wrong order?? not getting intial field in multiples and current could be\n        // non empty when currentMultiples is also..\n        /*if(current !=null) {    \n          MetadataEditor.this.current.getMetadataList().getMetadata().add(vme);\n        } else if(currentMultiples != null) {\n          currentMultiples.getMetadataList().getMetadata().add(vme);   \n          if(DEBUG_LOCAL) {\n              System.out.println(\"ME: current multiples is not null -- addNewRow \" +\n                      currentMultiples.getMetadataList().getCategoryListSize() );\n          } }*/\n        \n        if(currentMultiples != null) {\n            currentMultiples.getMetadataList().getMetadata().add(vme);   \n            if(DEBUG_LOCAL) { System.out.println(\"ME: current multiples is not null -- addNewRow \" + currentMultiples.getMetadataList().getCategoryListSize() ); }\n        }\n        else if (/*AUTO_ADD_EMPTY &&*/ current != null) {\n            // If we skip this, we get infinite loop when selecting a node!\n            MetadataEditor.this.current.getMetadataList().getMetadata().add(vme);\n        }\n        ((MetadataTableModel)metadataTable.getModel()).refresh();\n    }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"public void selectionChanged(LWSelection selection)\n    {\n        if(DEBUG_LOCAL)\n        {\n            System.out.println(\"MDE: selection changed\" + selection);\n        }\n        \n        if(!selection.isEmpty())\n        {\n            if(selection.contents().size() > 1)\n            {\n                \n         //------------------\n                       focusToggle = false;  \n           \n         //if(DEBUG_LOCAL)\n         //{\n         //    System.out.println(\"MetadataEditor: active changed - \" + e + \",\" + this);\n         //}\n           \n         //LWSelection currentSelection = selection;\n         \n         metadataTable.removeEditor();\n         \n         //((MetadataTableModel)metadataTable.getModel()).clearGUIInfo();\n         \n         previousMultiples = currentMultiples;\n         \n         //--------\n                \n              currentMultiples = LWGroup.createTemporary(selection);\n              \n              \n              java.util.List<VueMetadataElement> shared = new java.util.ArrayList<VueMetadataElement>();\n              \n              // the following intersection of lists might take a while? \n              //perhaps want to put this in another thread..\n              // but probably would need some additional gui work to make clear what is \n              // happening\n              // also: could get these components from the selection to speed things up\n              java.util.Iterator<LWComponent> children = \n                      currentMultiples.getAllDescendents().iterator();\n              \n              LWComponent firstComp = children.next();\n              shared.addAll(firstComp.getMetadataList().getCategoryList().getList());\n              \n              if(DEBUG_LOCAL)\n              {\n                  System.out.println(\"MDE: shared initialized -- \" + firstComp.getMetadataList().\n                          getMetadataAsHTML(VueMetadataElement.CATEGORY));\n              }\n              \n              while(children.hasNext())\n              {\n                  LWComponent comp = children.next();\n                  \n                  shared.retainAll(comp.getMetadataList().getCategoryList().getList());\n                  \n                  // create set from shared\n                  //  use set iterator -- use element,count(frequency) in shared,count in comp\n                  // then remove lastIndexOf from shared as manhy times\n                  // as needed for each element\n                  java.util.Set uniqueShares = new java.util.HashSet(shared);\n                  java.util.Iterator<VueMetadataElement> us = uniqueShares.iterator();\n                  while(us.hasNext())\n                  {\n                      VueMetadataElement next = us.next();\n                      int sharedCount = java.util.Collections.frequency(shared,next);\n                      int compCount = java.util.Collections.frequency(comp.getMetadataList().getCategoryList().getList(),next);\n                      int numberToRemove = sharedCount - compCount;\n                      \n                      if(DEBUG_LOCAL)\n                      {\n                          System.out.println(\"ME -- for comp - \" + comp.getID());\n                          System.out.println(\"ME -- comp count vs shared count \" + compCount + \"-\" + sharedCount);\n                          System.out.println(\"ME - number of \" + next.getObject() + \" to remove from shared: \" + numberToRemove);\n                      }\n                      \n                      if(sharedCount > compCount)\n                      {    \n                        for(int i=0;i<numberToRemove;i++)\n                        {\n                          if(shared.indexOf(next) != -1)\n                            shared.remove(shared.indexOf(next));\n                        }\n                      }\n                  }\n                  \n              }\n              \n              java.util.List<VueMetadataElement> cmList = \n                       currentMultiples.getMetadataList().getMetadata();\n              \n              if(DEBUG_LOCAL)\n              {\n                  System.out.println(\"MDE: after shared is constructed: \" + currentMultiples.getMetadataList().\n                                             getMetadataAsHTML(VueMetadataElement.CATEGORY));\n              }\n              for(int i=0;i<shared.size();i++)\n              {\n                  cmList.add(shared.get(i));\n              }\n              \n              //((MetadataTableModel)metadataTable.getModel()).refresh();\n              MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n              \n              \n              if(DEBUG_LOCAL)\n              {\n                  System.out.println(\"MDE shared calculated -- what is its size? : \" + shared.size());\n              }\n              \n              //maybe add an empty item to the group instead.\n              // it would never have to get added unless changed\n              // actually only do this if the intersection of lists calculated above\n              // is empty..\n              if(shared.size() == 0) // tried cmList...\n                addNewRow();\n              \n              //why is this needed? --**--\n              //for(int i=0;i<model.getRowCount();i++)\n              //{\n              //   model.setSaved(i,true);    \n              //}    \n\n              \n              \n              \n              //this should do the same thing.. (its what activeChanged does)\n              ((MetadataTableModel)metadataTable.getModel()).clearGUIInfo();\n         \n              ((MetadataTableModel)metadataTable.getModel()).refresh();\n              \n\n              \n              // maybe also need to null out current in active changed (depends on order)\n              // better to allow current to be non null..\n              //current = null;\n              \n              \n\n            }\n            else\n            {\n              currentMultiples = null;\n            }\n        }\n        else\n        {\n            currentMultiples = null;\n        }\n        \n        if (VUE.getSelection().size() == 1 && VUE.getSelection().get(0) instanceof tufts.vue.LWNode)\n        \tautoTagButton.setVisible(true);\n        else\n        \tautoTagButton.setVisible(false);\n    }","id":45706,"modified_method":"public void selectionChanged(LWSelection selection)\n    {\n        if (DEBUG_LOCAL) Log.debug(\"selection changed\" + selection);\n        \n        if(!selection.isEmpty())\n        {\n            if(selection.contents().size() > 1)\n            {\n                \n         //------------------\n                       focusToggle = false;  \n           \n         //if(DEBUG_LOCAL)\n         //{\n         //    System.out.println(\"MetadataEditor: active changed - \" + e + \",\" + this);\n         //}\n           \n         //LWSelection currentSelection = selection;\n         \n         metadataTable.removeEditor();\n         \n         //((MetadataTableModel)metadataTable.getModel()).clearGUIInfo();\n         \n         previousMultiples = currentMultiples;\n         \n         //--------\n                \n              currentMultiples = LWGroup.createTemporary(selection);\n              \n              \n              java.util.List<VueMetadataElement> shared = new java.util.ArrayList<VueMetadataElement>();\n              \n              // the following intersection of lists might take a while? \n              //perhaps want to put this in another thread..\n              // but probably would need some additional gui work to make clear what is \n              // happening\n              // also: could get these components from the selection to speed things up\n              java.util.Iterator<LWComponent> children = \n                      currentMultiples.getAllDescendents().iterator();\n              \n              LWComponent firstComp = children.next();\n              shared.addAll(firstComp.getMetadataList().getCategoryList().getList());\n              \n              if(DEBUG_LOCAL)\n              {\n                  System.out.println(\"MDE: shared initialized -- \" + firstComp.getMetadataList().\n                          getMetadataAsHTML(VueMetadataElement.CATEGORY));\n              }\n              \n              while(children.hasNext())\n              {\n                  LWComponent comp = children.next();\n                  \n                  shared.retainAll(comp.getMetadataList().getCategoryList().getList());\n                  \n                  // create set from shared\n                  //  use set iterator -- use element,count(frequency) in shared,count in comp\n                  // then remove lastIndexOf from shared as manhy times\n                  // as needed for each element\n                  java.util.Set uniqueShares = new java.util.HashSet(shared);\n                  java.util.Iterator<VueMetadataElement> us = uniqueShares.iterator();\n                  while(us.hasNext())\n                  {\n                      VueMetadataElement next = us.next();\n                      int sharedCount = java.util.Collections.frequency(shared,next);\n                      int compCount = java.util.Collections.frequency(comp.getMetadataList().getCategoryList().getList(),next);\n                      int numberToRemove = sharedCount - compCount;\n                      \n                      if(DEBUG_LOCAL) {\n                          System.out.println(\"ME -- for comp - \" + comp.getID());\n                          System.out.println(\"ME -- comp count vs shared count \" + compCount + \"-\" + sharedCount);\n                          System.out.println(\"ME - number of \" + getObject(next) + \" to remove from shared: \" + numberToRemove);\n                      }\n                      \n                      if(sharedCount > compCount)\n                      {    \n                        for(int i=0;i<numberToRemove;i++)\n                        {\n                          if(shared.indexOf(next) != -1)\n                            shared.remove(shared.indexOf(next));\n                        }\n                      }\n                  }\n                  \n              }\n              \n              java.util.List<VueMetadataElement> cmList = \n                       currentMultiples.getMetadataList().getMetadata();\n              \n              if(DEBUG_LOCAL)\n              {\n                  System.out.println(\"MDE: after shared is constructed: \" + currentMultiples.getMetadataList().\n                                             getMetadataAsHTML(VueMetadataElement.CATEGORY));\n              }\n              for(int i=0;i<shared.size();i++)\n              {\n                  cmList.add(shared.get(i));\n              }\n              \n              //((MetadataTableModel)metadataTable.getModel()).refresh();\n              MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n              \n              \n              if(DEBUG_LOCAL)\n              {\n                  System.out.println(\"MDE shared calculated -- what is its size? : \" + shared.size());\n              }\n              \n              //maybe add an empty item to the group instead.\n              // it would never have to get added unless changed\n              // actually only do this if the intersection of lists calculated above\n              // is empty..\n              if(shared.size() == 0) // tried cmList...\n                addNewRow();\n              \n              //why is this needed? --**--\n              //for(int i=0;i<model.getRowCount();i++)\n              //{\n              //   model.setSaved(i,true);    \n              //}    \n\n              \n              \n              \n              //this should do the same thing.. (its what activeChanged does)\n              ((MetadataTableModel)metadataTable.getModel()).clearGUIInfo();\n         \n              ((MetadataTableModel)metadataTable.getModel()).refresh();\n              \n\n              \n              // maybe also need to null out current in active changed (depends on order)\n              // better to allow current to be non null..\n              //current = null;\n              \n              \n\n            }\n            else\n            {\n              currentMultiples = null;\n            }\n        }\n        else\n        {\n            currentMultiples = null;\n        }\n        \n        if (VUE.getSelection().size() == 1 && VUE.getSelection().get(0) instanceof tufts.vue.LWNode)\n        \tautoTagButton.setVisible(true);\n        else\n        \tautoTagButton.setVisible(false);\n    }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"public java.awt.Component getTableCellEditorComponent(final JTable table,final Object value,boolean isSelected,final int row,final int col)\n       {\n           final JTextField field = new JTextField();\n           final JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           final JLabel categoryLabel = new JLabel();\n           final JLabel notEditable = new JLabel();\n           final JPanel comp = new JPanel();\n           \n           //edu.tufts.vue.metadata.gui.MetaButton deleteButton = new \n           //                       edu.tufts.vue.metadata.gui.MetaButton(MetadataEditor.this,\"delete\");\n           \n           comp.addMouseListener(new MouseAdapter(){\n              public void mousePressed(MouseEvent e)\n              {\n                  ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  stopCellEditing();\n              }\n           });\n           \n           currentRow = row;\n           \n           notEditable.setFont(GUI.LabelFace);\n           field.setFont(GUI.LabelFace);\n           \n           categories.addItemListener(new ItemListener() \n           {\n               public void itemStateChanged(ItemEvent e) \n               {\n                   if(DEBUG_LOCAL)\n                   {    \n                      System.out.println(\"MetdataEditor categories item listener itemStateChanged: \" + e);\n                   }\n                   \n                   \n                   if(e.getStateChange() == ItemEvent.SELECTED)\n                   {   \n                       if(e.getItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                       {                           \n                           JDialog ecd = new JDialog(VUE.getApplicationFrame(),VueResources.getString(\"dialog.editcat.title\"));\n                           ecd.setModal(true);\n                           ecd.add(new CategoryEditor(ecd,categories,MetadataEditor.this,current,row,col));\n                           ecd.setBounds(475,300,300,250);\n                           ecd.setVisible(true);\n                           \n                           metadataTable.getCellEditor().stopCellEditing();\n                           ((MetadataTableModel)metadataTable.getModel()).refresh();\n                       }\n                   }\n               }\n           });\n           \n           categories.addFocusListener(new FocusAdapter(){\n               public void focusLost(java.awt.event.FocusEvent fe)\n               {      \n                   MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n                   if(model.lastSavedRow != row)\n                   {    \n                     model.setSaved(row,true);\n                   }\n               }\n           });\n           \n           categories.addItemListener(new java.awt.event.ItemListener(){\n              public void itemStateChanged(java.awt.event.ItemEvent ie)\n              {\n                  \n                  if(ie.getStateChange()==java.awt.event.ItemEvent.SELECTED)\n                  {\n                      \n                    if(categories.getSelectedItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                    {\n                        return;\n                    }\n                      \n                    VueMetadataElement vme = new VueMetadataElement();\n                    \n                    String[] keyValuePair = {((OntType)categories.getSelectedItem()).getBase()+\"#\"+((OntType)categories.getSelectedItem()).getLabel(),\n                                               ((VueMetadataElement)table.getModel().getValueAt(row,buttonColumn - 1)).getValue()};\n                    \n                    vme.setObject(keyValuePair);\n                    vme.setType(VueMetadataElement.CATEGORY);\n                    if(currentMultiples != null)\n                    {\n                      // also need to add/set for individuals in group.. todo: subclass LWGroup to do this?\n                      // in the meantime just set these by hand\n                      if(currentMultiples.getMetadataList().getCategoryListSize() > (row))\n                      {\n                        VueMetadataElement oldVME = currentMultiples.getMetadataList().getCategoryList().get(row);  \n                          \n                        currentMultiples.getMetadataList().getCategoryList().set(row,vme);\n                        \n                        java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                        while(multiples.hasNext())\n                        {\n                          LWComponent multiple = multiples.next();\n                          MetadataList.SubsetList md = multiple.getMetadataList().getCategoryList();\n                          if(md.contains(oldVME))\n                          {\n                              md.set(md.indexOf(oldVME),vme);\n                          }\n                          else\n                          {\n                              multiple.getMetadataList().getMetadata().add(vme);\n                          }\n                        }\n                        \n                      }\n                      else\n                      {\n                        currentMultiples.getMetadataList().getMetadata().add(vme); \n                        \n                        java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                        while(multiples.hasNext())\n                        {\n                          LWComponent multiple = multiples.next();\n                          MetadataList.SubsetList md = multiple.getMetadataList().getCategoryList();\n                          if(md.contains(vme))\n                          {\n                              md.set(md.indexOf(vme),vme);\n                          }\n                          else\n                          {\n                              multiple.getMetadataList().getMetadata().add(vme);\n                          }\n                        }\n                      }  \n                    }\n                    else if(current !=null)\n                    {    \n                      if(current.getMetadataList().getCategoryListSize() > (row))\n                      {\n                        current.getMetadataList().getCategoryList().set(row,vme);\n                      }\n                      else\n                      {\n                        current.getMetadataList().getMetadata().add(vme); \n                      }\n                    }\n                  }\n              }\n           });\n           \n           field.addKeyListener(new java.awt.event.KeyAdapter(){\n              public void keyPressed(java.awt.event.KeyEvent e)\n              {\n                  if(e.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER)\n                  {\n                      ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  }\n              }\n           });\n           \n           field.addFocusListener(new FocusAdapter(){\n              public void focusLost(java.awt.event.FocusEvent fe)\n              {  \n                  if( ( current == null && currentMultiples == null) )\n                          //|| VUE.getActiveMap() == null || VUE.getActiveViewer() == null)\n                  {\n                      return;\n                  }\n                  \n                    if(DEBUG_LOCAL)\n                    {\n                      Object editor = metadataTable.getCellEditor();\n                      \n                      MetadataTableEditor mte = null;\n                      \n                      System.out.println(\"MetadataEditor -- field focus lost -- CellEditor: \" + \n                                           editor);\n                      \n                      if(editor != null)\n                      {\n                          mte = (MetadataTableEditor)editor;\n                          System.out.println(\"MetadataEditor -- field focus lost -- CellEditor row: \" + \n                                           mte.getRow());\n                      }\n                      \n                      \n                    }\n                  \n                  \n                   MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n                   if(model.lastSavedRow != row)\n                   {    \n                     model.setSaved(row,true);\n                   }\n                  \n                  VUE.getActiveMap().markAsModified();\n                  \n                  if(DEBUG_LOCAL && fe != null)\n                  {    \n                     System.out.println(\"MDE field focus lost -- opposite component: \" + fe.getOppositeComponent());\n                  }\n                  \n                  /*if(currentMultiples != null)\n                  {\n                      return;\n                  }*/\n                                    \n                  /*if(fe!= null && fe.getOppositeComponent() == categories)\n                  {\n                      return;\n                  }*/\n                  \n                  // note: fix for currentMultiples != null and focus lost off bottom of info window (not\n                  // as likely in the multiple selection case?)\n                  if(tufts.vue.gui.DockWindow.isDockWindow(fe.getOppositeComponent()) && currentMultiples == null)\n                  {\n                      model.setSaved(row,true);\n                      TableCellEditor tce = metadataTable.getCellEditor();\n                      \n                      if(tce != null)\n                      {    \n                        metadataTable.getCellEditor().stopCellEditing();\n                      }\n                  }\n                  \n                  //java.util.List<VueMetadataElement> metadata = null;\n                  MetadataList.SubsetList metadata = null;\n                  \n                  if(previousCurrent == null && current == null &&\n                       previousMultiples == null && currentMultiples ==  null)\n                  {\n                      return;\n                  }\n                  else\n                  if(previousCurrent != null && !focusToggle)\n                  {\n                     metadata = previousCurrent.getMetadataList().getCategoryList();\n                  } \n                  else if(previousCurrent != null && !focusToggle)\n                  {\n                     metadata = previousCurrent.getMetadataList().getCategoryList();\n                  }   \n                  else \n                  {\n                     if( currentMultiples!=null )\n                     {    \n                       metadata = currentMultiples.getMetadataList().getCategoryList();\n                     }\n                     else if( current!=null )\n                     {\n                       //going in this order should mean current == null is not\n                       // needed on selection of more than one component..\n                         \n                       metadata = current.getMetadataList().getCategoryList();   \n                     }\n                  }\n                  \n                  VueMetadataElement currentVME = null;\n                  \n                  if( (current != null && current.getMetadataList().getCategoryListSize() > 0 ) ||\n                          \n                      (currentMultiples != null && currentMultiples.getMetadataList().getCategoryListSize() > 0 )      \n                    )\n                  {\n                   currentVME = metadata.get(row);\n                  }\n                  \n                  VueMetadataElement vme = new VueMetadataElement();\n                  \n                  if(currentVME==null)\n                  {\n                     String[] emptyEntry = {NONE_ONT,field.getText()};\n                     vme.setObject(emptyEntry);\n                     vme.setType(VueMetadataElement.CATEGORY);  \n                  }\n                  else\n                  {\n                    String[] obj = (String[])currentVME.getObject();  \n                    String[] pairedValue = {obj[0],field.getText()};\n                    vme.setObject(pairedValue);\n                  }\n                  if( (current != null && current.getMetadataList().getCategoryListSize() > (row)) ||\n                     (currentMultiples != null && currentMultiples.getMetadataList().getCategoryListSize() > row) )\n                  {\n                    if(DEBUG_LOCAL)\n                    {\n                        System.out.println(\"ME: setting value from field -- \" + row + \":\" + vme.getObject() +\n                                            \" \" + metadata);\n                    }\n                    \n                    VueMetadataElement old = metadata.get(row);\n                    \n                    metadata.set(row,vme);\n                    \n                    if(currentMultiples != null) // !! must make sure there is more than one in group -- other\n                                                 // wise is back to base case of single selection.\n                    {\n                        java.util.Collection selection = currentMultiples.getAllDescendents();\n                        java.util.Iterator children = selection.iterator();\n                        while(children.hasNext())\n                        {\n                            LWComponent child = (LWComponent)children.next();\n                            MetadataList.SubsetList cMeta = child.getMetadataList().getCategoryList();\n                            int size = cMeta.size();\n                            if(size > 0 && cMeta.get(size-1).getValue().equals(\"\"))\n                            {\n                                cMeta.set(size-1,vme);\n                            }\n                            // also need to set in condition where already in all the sub components?\n                            // somehow need to detect edit here.. but condition in line above this\n                            // one is not neccesarily equivalent..\n                            else\n                              if(cMeta.contains(old))\n                              {\n                                // should it always be the first index?\n                                cMeta.set(cMeta.indexOf(old),vme);\n                              }\n                              else\n                                child.getMetadataList().getMetadata().add(vme);\n                            child.layout();\n                            // also might need VUE activelistener repaint\n                        }\n                    }\n                    \n                  }\n                  else\n                  {\n                    metadata.add(vme); \n                  }\n                  \n                  // done earlier for multiples.  // may also  need active viewer repaint\n                  if(current !=null)\n                     current.layout();\n                  \n                  \n                  VUE.getActiveViewer().repaint();\n                  \n                  metadataTable.repaint();\n              }\n              \n              public void focusGained(java.awt.event.FocusEvent fe)\n              {\n                  focusToggle = true;\n              }\n           });\n           comp.setLayout(new BorderLayout());\n           if(col == buttonColumn - 2)\n           {\n               final int n = categories.getModel().getSize();\n \n               Object currObject = null;\n               \n               if(currentMultiples != null)\n               {\n                 currObject = currentMultiples.getMetadataList().getCategoryListElement(row).getObject();  \n               }\n               else if(current != null)\n               {    \n                 currObject = current.getMetadataList().getCategoryListElement(row).getObject();\n               }\n               final Object currValue = (((String[])currObject)[0]);\n               Object currFieldValue = (((String[])currObject)[1]);\n               \n               /*if(false) /// with new isCellEditable() logic on cell editor...\n               {\n                   String displayString = currValue.toString();\n                   int nameIndex = displayString.indexOf(\"#\");\n                   if(nameIndex != -1 && ( (nameIndex + 1)< displayString.length()) ) \n                   {\n                     displayString = displayString.substring(nameIndex + 1);\n                   }\n                   categoryLabel.setText(displayString);\n                   \n                   categoryLabel.setFont(GUI.LabelFace);\n                   \n                   boolean found = findCategory(currValue,row,col,n,categories);\n                   \n                   if(found)\n                   {    \n                     comp.add(categoryLabel);\n                   }\n                   else\n                   {\n                     categoryLabel.setText(categoryLabel.getText() + \"*\"); \n                     comp.add(categoryLabel);\n                   }    \n                   comp.setBorder(getMetadataCellBorder(row,col));\n                   \n                   ((MetadataTableModel)table.getModel()).refresh();\n                   metadataTable.repaint();\n                   \n                   return comp;\n               }*/\n               findCategory(currValue,row,col,n,categories); \n               \n\n               comp.add(categories);\n               \n               comp.setBorder(getMetadataCellBorder(row,col));\n               ((MetadataTableModel)table.getModel()).refresh();\n               metadataTable.repaint();\n           }\n           else\n           if(col == (buttonColumn - 1))\n           {\n               if(value instanceof String)\n                 field.setText(value.toString());\n               if(value instanceof VueMetadataElement)\n               {\n                 VueMetadataElement vme = (VueMetadataElement)value;\n                 field.setText(vme.getValue());\n               }\n               if(true) // new isCellEditable stuff\n               {\n                 comp.add(field);\n               }\n               else\n               {\n                 notEditable.setText(field.getText());\n                 comp.add(notEditable);\n               }\n           }\n           else if(col ==  buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //comp.add(buttonLabel);\n                              \n               metaButtonPanel.setRow(row);\n               //deleteButton.setRow(row);\n               //comp.add(deleteButton);\n               //comp = metaButtonPanel;\n               comp.add(metaButtonPanel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           if(LIMITED_FOCUS)\n           {\n             field.addMouseListener(new MouseAdapter() {\n                 public void mouseExited(MouseEvent me)\n                 {\n                       stopCellEditing();\n                 }\n             });\n           }\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           return comp;\n       }","id":45707,"modified_method":"public java.awt.Component getTableCellEditorComponent(final JTable table, final Object value, boolean isSelected, final int row, final int col)\n       {\n           if (DEBUG.PAIN) Log.debug(\"getTableCellEditorComponent\");\n           \n           final JTextField field = new JTextField();\n           final JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           final JLabel categoryLabel = new JLabel();\n           final JLabel notEditable = new JLabel();\n           final JPanel comp = new JPanel();\n           \n           //edu.tufts.vue.metadata.gui.MetaButton deleteButton = new \n           //                       edu.tufts.vue.metadata.gui.MetaButton(MetadataEditor.this,\"delete\");\n           \n           comp.addMouseListener(new MouseAdapter(){\n              public void mousePressed(MouseEvent e) {\n                  ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  stopCellEditing();\n              }\n           });\n           \n           currentRow = row;\n           \n           notEditable.setFont(GUI.LabelFace);\n           field.setFont(GUI.LabelFace);\n           \n           categories.addFocusListener(new FocusAdapter() { public void focusLost(final java.awt.event.FocusEvent fe) {      \n               final MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n               if (model.lastSavedRow != row)\n                   model.setSaved(row,true);\n           }});\n\n           categories.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent e) {\n               if (e.getStateChange() == ItemEvent.SELECTED && e.getItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem) {\n                   if (DEBUG.PAIN) Log.debug(\"categories itemStateChanged v1: \" + Util.tags(e.getItem()));\n                   final JDialog ecd = new JDialog(VUE.getApplicationFrame(), VueResources.local(\"dialog.editcat.title\"));\n                   ecd.setModal(true);\n                   ecd.add(new CategoryEditor(ecd,categories,MetadataEditor.this,current,row,col));\n                   ecd.setBounds(475,300,300,250);\n                   ecd.setVisible(true);\n                   metadataTable.getCellEditor().stopCellEditing();\n                   ((MetadataTableModel)metadataTable.getModel()).refresh();\n               }\n           }});\n                      \n           // Note the two item listers installed: the 1st to handle EditCategoryItem, this one everything else.\n           categories.addItemListener(new ItemListener() { public void itemStateChanged(final ItemEvent ie) {\n               if (ie.getStateChange() != ItemEvent.SELECTED)\n                   return;\n               if (categories.getSelectedItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                   return;\n\n               if (DEBUG.PAIN) Log.debug(\"categories itemStateChanged v2: \" + Util.tags(ie.getItem()));\n                  \n               // THIS IS THE CATEGORY COMBO INPUT POINT\n\n               final OntType ontType = (OntType) categories.getSelectedItem();\n               final VueMetadataElement tableVME = (VueMetadataElement) table.getModel().getValueAt(row, buttonColumn - 1);\n                       \n               final String[] keyValuePair = {\n                   ontType.getBase() + \"#\" + ontType.getLabel(),\n                   tableVME.getValue()\n               };\n\n               if (DEBUG.PAIN) Log.debug(\"constructed key: [\" + keyValuePair[0] + \"]\");\n\n               final VueMetadataElement vme = new VueMetadataElement();\n               vme.setObject(keyValuePair);\n               vme.setType(VueMetadataElement.CATEGORY);\n               \n               if (currentMultiples != null) {\n                   // also need to add/set for individuals in group.. todo: subclass LWGroup to do this?\n                   // in the meantime just set these by hand\n                   if (currentMultiples.getMetadataList().getCategoryListSize() > (row)) {\n                       VueMetadataElement oldVME = currentMultiples.getMetadataList().getCategoryList().get(row);  \n                          \n                       currentMultiples.getMetadataList().getCategoryList().set(row,vme);\n                        \n                       java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                       while(multiples.hasNext()) {\n                           LWComponent multiple = multiples.next();\n                           MetadataList.SubsetList md = multiple.getMetadataList().getCategoryList();\n                           if (md.contains(oldVME))\n                               md.set(md.indexOf(oldVME),vme);\n                           else\n                               multiple.getMetadataList().getMetadata().add(vme);\n                       }\n                   }\n                   else {\n                       currentMultiples.getMetadataList().getMetadata().add(vme); \n                        \n                       java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                       while(multiples.hasNext()) {\n                           LWComponent multiple = multiples.next();\n                           MetadataList.SubsetList md = multiple.getMetadataList().getCategoryList();\n                           if (md.contains(vme))\n                               md.set(md.indexOf(vme),vme);\n                           else\n                               multiple.getMetadataList().getMetadata().add(vme);\n                       }\n                   }  \n               }\n               else if (current != null) {    \n                   if (current.getMetadataList().getCategoryListSize() > row)\n                       current.getMetadataList().getCategoryList().set(row,vme);\n                   else\n                       current.getMetadataList().getMetadata().add(vme); \n               }\n           }});\n           \n           field.addKeyListener(new java.awt.event.KeyAdapter(){\n              public void keyPressed(java.awt.event.KeyEvent e) {\n                  if(e.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER)\n                      ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n              }\n           });\n           \n           // todo fix: note RADICALLY different behaviour of VK_ENTER v.s. focusLost\n           field.addFocusListener(new FocusAdapter() {\n                   public void focusLost(java.awt.event.FocusEvent fe) { handleFieldFocusLost(fe, row, field); }\n                   public void focusGained(java.awt.event.FocusEvent fe) { focusToggle = true; }\n           });\n           \n           comp.setLayout(new BorderLayout());\n           if (col == buttonColumn - 2) {\n               // // Object currObject = null;\n               // // if(currentMultiples != null)\n               // //     currObject = currentMultiples.getMetadataList().getCategoryListElement(row).getObject();  \n               // // else if(current != null)\n               // //     currObject = current.getMetadataList().getCategoryListElement(row).getObject();\n               // final Object currObject = getObjectActive(row);\n               // final String currValue = (((String[])currObject)[0]);\n               // Object currFieldValue = (((String[])currObject)[1]);\n               \n               // // /*if(false) /// with new isCellEditable() logic on cell editor... {\n               // //     String displayString = currValue.toString();\n               // //     int nameIndex = displayString.indexOf(\"#\");\n               // //     if(nameIndex != -1 && ( (nameIndex + 1)< displayString.length()) ) {\n               // //       displayString = displayString.substring(nameIndex + 1);\n               // //     }\n               // //     categoryLabel.setText(displayString);\n               // //     categoryLabel.setFont(GUI.LabelFace);\n               // //     boolean found = findCategory(currValue,row,col,n,categories);\n               // //     if(found) {    \n               // //       comp.add(categoryLabel);\n               // //     } else {\n               // //       categoryLabel.setText(categoryLabel.getText() + \"*\"); \n               // //       comp.add(categoryLabel);\n               // //     }    \n               // //     comp.setBorder(getMetadataCellBorder(row,col));\n               // //     ((MetadataTableModel)table.getModel()).refresh();\n               // //     metadataTable.repaint();\n               // //     return comp; }*/\n               \n               final String key = getKeyForRow(row);\n\n               findCategory(key,row,col,categories); \n               comp.add(categories);\n               comp.setBorder(getMetadataCellBorder(row,col));\n               ((MetadataTableModel)table.getModel()).refresh();\n               metadataTable.repaint();\n           }\n           else if(col == (buttonColumn - 1))\n           {\n               if(value instanceof String)\n                 field.setText(value.toString());\n               if(value instanceof VueMetadataElement)\n               {\n                 VueMetadataElement vme = (VueMetadataElement)value;\n                 field.setText(vme.getValue());\n               }\n               if(true) // new isCellEditable stuff\n               {\n                 comp.add(field);\n               }\n               else\n               {\n                 notEditable.setText(field.getText());\n                 comp.add(notEditable);\n               }\n           }\n           else if(col ==  buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //comp.add(buttonLabel);\n                              \n               metaButtonPanel.setRow(row);\n               //deleteButton.setRow(row);\n               //comp.add(deleteButton);\n               //comp = metaButtonPanel;\n               comp.add(metaButtonPanel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           if(LIMITED_FOCUS)\n           {\n             field.addMouseListener(new MouseAdapter() {\n                 public void mouseExited(MouseEvent me)\n                 {\n                       stopCellEditing();\n                 }\n             });\n           }\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           return comp;\n       }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"public Object getValueAt(int row, int column)\n         {\n             \n             categoryIncluded.trimToSize();\n             \n             if(current == null && currentMultiples == null)\n                 return \"null\";\n             else if(currentMultiples != null)\n             {\n               /*java.util.List<VueMetadataElement> list = currentMultiples.getMetadataList().getMetadata();\n             \n               if(list.size() == 0)\n                 addNewRow();\n               else\n               if(list.size() < row + 1)\n                 return null;*/\n                 \n               if(currentMultiples.getMetadataList().getCategoryListSize() == 0)\n                 addNewRow();\n               else\n                 if(currentMultiples.getMetadataList().getCategoryListSize() < row + 1)\n                   return null;\n                 \n               //while(list.size() < row + 1)\n               //  addNewRow();\n             \n               return currentMultiples.getMetadataList().getCategoryListElement(row);\n               //return current.getMetadataList().getMetadata().get(row);                 \n             }\n             \n             /*java.util.List<VueMetadataElement> list = current.getMetadataList().getMetadata();\n             \n             if(list.size() == 0)\n                 addNewRow();\n             else\n             if(list.size() < row + 1)\n                 return null; */\n             \n             if(current.getMetadataList().getCategoryListSize() == 0)\n                 addNewRow();\n             else\n                 if(current.getMetadataList().getCategoryListSize() < row + 1)\n                   return null;\n             \n             //while(list.size() < row + 1)\n             //  addNewRow();\n             \n             return current.getMetadataList().getCategoryListElement(row);\n             //return current.getMetadataList().getMetadata().get(row);\n         }","id":45708,"modified_method":"public Object getValueAt(int row, int column)\n        {\n            categoryIncluded.trimToSize();\n\n            if (current == null && currentMultiples == null)\n                return \"<null-VME-table-value>\";\n            else if (currentMultiples != null) {\n                final int size = currentMultiples.getMetadataList().getCategoryListSize();\n                if (size == 0)\n                    addNewRow();\n                else if (size < row + 1) // what this do?\n                    return null;\n                return currentMultiples.getMetadataList().getCategoryListElement(row);\n            } else {\n                final int size = current.getMetadataList().getCategoryListSize();\n                if (size == 0)\n                    return EmptyVME; //addNewRow();\n                else if (size < row + 1) // what's this do?\n                    return null;\n            }\n            return current.getMetadataList().getCategoryListElement(row);\n        }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"public java.awt.Component getTableCellRendererComponent(JTable table, Object value,boolean isSelected,boolean hasFocus,int row,int col)\n       {\n           JPanel comp = new JPanel();\n           //JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           comp.setLayout(new BorderLayout());\n           if(col == buttonColumn-2)\n           {\n               int n = categories.getModel().getSize();\n               \n               Object currObject = null;\n               if(current != null)\n                 currObject = current.getMetadataList().getCategoryList().get(row).getObject();\n               else if(currentMultiples!=null)\n               {    \n                 VueMetadataElement ele = currentMultiples.getMetadataList().getCategoryList().get(row);\n                 \n                 if(DEBUG_LOCAL)\n                 {\n                     System.out.println(\"ME - getTableCellRendererComponent - ele: \" + ele);\n                 }\n                 \n                 currObject = ele.getObject();\n                 \n                 /*if(currObject !=null)\n                   currObject = ele.getObject();\n                 else\n                 {\n                   VueMetadataElement vme = VueMetadataElement.getNewCategoryElement();\n                   currentMultiples.getMetadataList().getCategoryList().set(row,vme);\n                     \n                   currObject = vme.getObject();\n                 }*/\n               }\n               \n               Object currValue = (((String[])currObject)[0]);\n               boolean found = findCategory(currValue,row,col,n,categories); \n              \n               MetadataTableModel model = (MetadataTableModel)table.getModel();\n               \n               if((found) || !model.getIsSaved(row))\n               {    \n                 model.setCategoryFound(row,true);  \n                   \n                 if(!model.getIsSaved(row) )\n                  comp.add(categories);\n                 else\n                 {\n                   String customName = currValue.toString();\n                   int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                   if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                   {\n                       customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                   }\n                   JLabel custom = new JLabel(customName);\n                   custom.setFont(GUI.LabelFace);\n                   comp.add(custom);\n                 }\n               }\n               else\n               {\n                 model.setCategoryFound(row,false);  \n                 String customName = currValue.toString();\n                 int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                 if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                 {\n                     customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                 }\n                 JLabel custom = new JLabel(customName+\"*\");\n                 custom.setFont(GUI.LabelFace);\n                 comp.add(custom);\n                 JLabel addLabel = new JLabel(\"[+]\");\n                 comp.add(addLabel,BorderLayout.EAST);\n               }\n               \n           }\n           else if(col == buttonColumn-1)\n           {\n               \n               boolean saved = ((MetadataTableModel)metadataTable.getModel()).getIsSaved(row);\n               \n               if(value instanceof VueMetadataElement)\n               {\n                   VueMetadataElement vme = (VueMetadataElement)value;\n                   if(saved == true)\n                   {\n                     JLabel custom = new JLabel(vme.getValue());\n                     custom.setFont(GUI.LabelFace);\n                     comp.add(custom);\n                   }\n                   else \n                   if(saved == false)\n                   {\n                     JTextField field = new JTextField(vme.getValue());\n                     field.setFont(GUI.LabelFace);\n                     comp.add(field);\n                   }\n               } \n               else\n               {\n                   if(DEBUG_LOCAL && value != null)\n                   {\n                       System.out.println(\"MetadataEditor -- renderer for field not vme: \" + value.getClass());\n                   }\n               }\n                 \n           }\n           else if(col == buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               \n               // VUE-912, put delete button back -- also add back mouselistener\n               //if(row!=0)\n               //{    \n                 //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //}\n               //comp.add(buttonLabel);\n               \n               //$\n                 //comp.setOpaque(true);\n                 //comp.setBackground(java.awt.Color.RED);\n               //$\n               \n               //JPanel holder = new JPanel();\n               holder.add(deleteButton);\n               comp.add(holder);\n           }\n           \n           comp.setOpaque(false);\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           return comp;\n       }","id":45709,"modified_method":"public java.awt.Component getTableCellRendererComponent(JTable table, Object value,boolean isSelected,boolean hasFocus,int row,int col)\n       {\n           JPanel comp = new JPanel();\n           //JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           comp.setLayout(new BorderLayout());\n           if (col == buttonColumn - 2) {\n               // // Object currObject = null;\n               // // if (current != null) {\n               // //     currObject = getObjectCurrent(row);\n               // // } else if(currentMultiples!=null) {    \n               // //     final VueMetadataElement ele = currentMultiples.getMetadataList().getCategoryList().get(row);\n               // //     if (DEBUG_LOCAL) Log.debug(\"getTableCellRendererComponent - ele: \" + ele);\n               // //     currObject = getObject(ele);\n               // //     /*if(currObject !=null)\n               // //       currObject = ele.getObject();\n               // //       else {\n               // //       VueMetadataElement vme = VueMetadataElement.getNewCategoryElement();\n               // //       currentMultiples.getMetadataList().getCategoryList().set(row,vme);\n               // //       currObject = vme.getObject(); }*/\n               // // }\n               // // Object currValue = (((String[])currObject)[0]);\n               // final String currValue = getObjectActive(row)[0];\n\n               final String key = getKeyForRow(row);\n               final boolean found = findCategory(key,row,col,categories); \n              \n               final MetadataTableModel model = (MetadataTableModel)table.getModel();\n               \n               if (found || !model.getIsSaved(row)) {\n                   \n                   model.setCategoryFound(row,true);\n                   if (!model.getIsSaved(row) ) {\n                       comp.add(categories);\n                   } else {\n                       String customName = key;\n                       int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                       if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                           customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                       JLabel custom = new JLabel(customName);\n                       custom.setFont(GUI.LabelFace);\n                       comp.add(custom);\n                   }\n               }\n               else {\n                   model.setCategoryFound(row,false);  \n                   String customName = key.toString();\n                   final int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                   if (ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                       customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                   final JLabel custom = new JLabel(customName+\"*\");\n                   custom.setFont(GUI.LabelFace);\n                   comp.add(custom);\n                   final JLabel addLabel = new JLabel(\"[+]\");\n                   comp.add(addLabel, BorderLayout.EAST);\n               }\n           }\n           else if (col == buttonColumn-1) {\n               final boolean saved = ((MetadataTableModel)metadataTable.getModel()).getIsSaved(row);\n               \n               if( value instanceof VueMetadataElement) {\n                   final VueMetadataElement vme = (VueMetadataElement) value;\n                   if (saved == true) {\n                       JLabel custom = new JLabel(vme.getValue());\n                       custom.setFont(GUI.LabelFace);\n                       comp.add(custom);\n                   }\n                   else if(saved == false) {\n                       JTextField field = new JTextField(vme.getValue());\n                       field.setFont(GUI.LabelFace);\n                       comp.add(field);\n                   }\n               } \n               else {\n                   if (DEBUG_LOCAL && value != null) Log.debug(\"renderer for field not vme: \" + value.getClass());\n               }\n                 \n           }\n           else if(col == buttonColumn) {\n               //JLabel buttonLabel = new JLabel();\n               // VUE-912, put delete button back -- also add back mouselistener\n               //if(row!=0)\n                 //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //comp.add(buttonLabel);\n               // //comp.setOpaque(true);\n               // //comp.setBackground(java.awt.Color.RED);\n               //JPanel holder = new JPanel();\n               holder.add(deleteButton);\n               comp.add(holder);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(getMetadataCellBorder(row,col));\n           return comp;\n       }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean findCategory(Object currValue,int row,int col,int n,JComboBox categories)\n    {\n    \n               boolean found = false;\n        \n               //if(DEBUG_LOCAL)\n               //{\n               //    System.out.println(\"MetadataEditor findCategory - \" + currValue);\n               //}\n        \n               //Object currValue = table.getModel().getValueAt(row,col); //.toString();\n               //System.out.println(\"Editor -- currValue: \" + currValue);\n               for(int i=0;i<n;i++)\n               {\n                   \n                   Object item = categories.getModel().getElementAt(i);\n                   String currLabel = \"\";\n                   if(currValue instanceof OntType)\n                       currLabel = ((OntType)currValue).getLabel();\n                   else\n                       currLabel = currValue.toString();\n                   \n                   if(item instanceof OntType &&\n                           (((OntType)item).getBase()+\"#\"+((OntType)item).getLabel()).equals(currLabel))\n                   {\n                       categories.setSelectedIndex(i);\n                       found = true;\n                   }\n                   \n               }\n               \n               return found;\n               \n    }","id":45710,"modified_method":"/** @return true if we can find a proper RDF style category for the given keyName -- will also select that item in categories */\n    public boolean findCategory(final String keyName, final int _unused_row, final int _unused_col, final JComboBox categories)\n    {\n        final int msize = categories.getModel().getSize();\n        \n        if (DEBUG.PAIN) Log.debug(\"findCategory: lookup with: \" + Util.tags(keyName));\n        // Util.printClassTrace(\"!java\");\n\n        if (keyName == null || keyName.indexOf('#') < 0)\n            return false;\n        \n        //if(DEBUG_LOCAL)  System.out.println(\"MetadataEditor findCategory - \" + currValue);\n        //Object currValue = table.getModel().getValueAt(row,col); //.toString();\n        //System.out.println(\"Editor -- currValue: \" + currValue);\n        \n        boolean found = false;\n        for(int i = 0; i < msize; i++) {\n            final Object item = categories.getModel().getElementAt(i);\n            //String currLabel = \"\";\n            // if (currValue instanceof OntType)\n            //     currLabel = ((OntType)currValue).getLabel();\n            // else currLabel = curValue.toString();\n            if (item instanceof OntType) {\n                final OntType ont = (OntType) item;\n                if (keyName.equals(ont.getBase()+\"#\"+ont.getLabel())) {\n                    if (DEBUG.PAIN) Log.debug(\"findCategory: at index \" + i + \" hit \" + Util.tags(item));\n                    categories.setSelectedIndex(i);\n                    found = true;\n                    break;\n                    // SMF: added break, which would change this from select last to select first, tho this is a JComboBox,\n                    // and no items should be the same.\n                }\n            }\n        }\n        return found;\n    }","commit_id":"770517c386a7568ba83b78f2f5558afd63c2524c","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n  protected void replaceEditor(JComponent oldEditor, JComponent newEditor) {\n    super.replaceEditor(oldEditor, newEditor);\n    if (newEditor != null) {\n      newEditor.getComponents()[0].addFocusListener(new FocusAdapter() {\n        @Override\n        public void focusGained(FocusEvent e) {\n          spinner.repaint();\n        }\n\n        @Override\n        public void focusLost(FocusEvent e) {\n          spinner.repaint();\n        }\n      });\n    }\n  }","id":45711,"modified_method":"@Override\n  protected void replaceEditor(JComponent oldEditor, JComponent newEditor) {\n    super.replaceEditor(oldEditor, newEditor);\n    if (oldEditor != null) {\n      oldEditor.getComponents()[0].removeFocusListener(myFocusListener);\n    }\n    if (newEditor != null) {\n      newEditor.getComponents()[0].addFocusListener(myFocusListener);\n    }\n  }","commit_id":"df889626a077303a07b4465c059af27f828a0704","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    // check source constraints\n    final Iter s = SeqIter.get(expr[1].iter(ctx));\n    final SeqIter seq = new SeqIter();\n    Item i = s.next();\n    // e needed to track order of attribute / non attribute nodes XUTY0004\n    boolean e = false;\n    boolean a = false;\n    while(i != null) {\n      // [CG] check txt constructor\n      if(i.type.num || i.type.str) seq.add(new FTxt(i.str(), null));\n      else if(i instanceof Nod) {\n        final Nod tn = (Nod) i;\n        final int k = Nod.kind(tn.type);\n        if(k == Data.ATTR) {\n          if(e) Err.or(UPNOATTRPER, this);\n          a = true;\n        }\n        if(k != Data.ATTR) e = true;\n        if(Nod.kind(tn.type) == Data.DOC) \n          seq.add(tn.child());\n        else seq.add(tn);\n      } else Err.or(UPDATE, this);\n      i = s.next();\n    }\n    seq.reset();\n    \n    final boolean into = !(before || after);\n    // check target constraints\n    final Iter t = SeqIter.get(expr[0].iter(ctx));\n    i = t.next();\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(!(i instanceof Nod) || t.size() > 1) Err.or(UPTRGTYP, this);\n    final Nod n = (Nod) i;\n    final int k = Nod.kind(n.type);\n    if(into && (!(k == Data.ELEM || k == Data.DOC))) Err.or(UPTRGTYP, this);\n    if(before || after) {\n      if(k == Data.ATTR) Err.or(UPTRGTYP2, this);\n      if(n.parent() == null) Err.or(UPPAREMPTY, this);\n    }\n    \n    UpdatePrimitive p = null;\n    if(into) p = first ? new InsertIntoFirstPrimitive(n, seq, a) : \n      last ? new InsertIntoLastPrimitive(n, seq, a) : \n        new InsertIntoPrimitive(n, seq, a);\n    \n    if(after) p = new InsertAfterPrimitive(n, seq, a);\n    if(before) p = new InsertBeforePrimitive(n, seq, a);\n    \n    ctx.updates.addPrimitive(p);\n    return Iter.EMPTY;\n  }","id":45712,"modified_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    // check source constraints\n    final Iter s = SeqIter.get(expr[1].iter(ctx));\n    final SeqIter seq = new SeqIter();\n    Item i = s.next();\n    // e needed to track order of attribute / non attribute nodes XUTY0004\n    boolean e = false;\n    while(i != null) {\n      // [LK] check  use of txt node constructor\n      if(i.type.num || i.type.str) seq.add(new FTxt(i.str(), null));\n      else if(i instanceof Nod) {\n        final Nod tn = (Nod) i;\n        final int k = Nod.kind(tn.type);\n        if(k == Data.ATTR) {\n          if(e) Err.or(UPNOATTRPER, this);\n        }\n        if(k != Data.ATTR) e = true;\n        if(Nod.kind(tn.type) == Data.DOC) \n          seq.add(tn.child());\n        else seq.add(tn);\n      } else Err.or(UPDATE, this);\n      i = s.next();\n    }\n    seq.reset();\n    \n    final boolean into = !(before || after);\n    // check target constraints\n    final Iter t = SeqIter.get(expr[0].iter(ctx));\n    i = t.next();\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(!(i instanceof Nod) || t.size() > 1) Err.or(UPTRGTYP, this);\n    final Nod n = (Nod) i;\n    final int k = Nod.kind(n.type);\n    if(into && (!(k == Data.ELEM || k == Data.DOC))) Err.or(UPTRGTYP, this);\n    if(before || after) {\n      if(k == Data.ATTR) Err.or(UPTRGTYP2, this);\n      if(n.parent() == null) Err.or(UPPAREMPTY, this);\n    }\n    \n    int pl = -1;\n    if(n instanceof DBNode) {\n      final DBNode dn = (DBNode) n;\n      pl = dn.pre + dn.data.attSize(dn.pre, dn.data.kind(dn.pre));\n    }\n    UpdatePrimitive p = null;\n    if(into) p = first ? new InsertIntoFirstPrimitive(n, seq, pl) : \n      last ? new InsertIntoLastPrimitive(n, seq, pl) : \n        new InsertIntoPrimitive(n, seq, pl);\n    \n    if(after) p = new InsertAfterPrimitive(n, seq, pl);\n    if(before) p = new InsertBeforePrimitive(n, seq, pl);\n    \n    ctx.updates.addPrimitive(p);\n    return Iter.EMPTY;\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertAfterPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45713,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param l actual pre location where nodes are inserted\n   */\n  public InsertAfterPrimitive(final Nod n, final Iter copy, final int l) {\n    super(n, copy, l);\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertBeforePrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45714,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param l actual pre location where nodes are inserted\n   */\n  public InsertBeforePrimitive(final Nod n, final Iter copy, final int l) {\n    super(n, copy, l);\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertIntoFirstPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45715,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param l actual pre location where nodes are inserted\n   */\n  public InsertIntoFirstPrimitive(final Nod n, final Iter copy, final int l) {\n    super(n, copy, l);\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertIntoLastPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45716,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param l actual pre location where nodes are inserted\n   */\n  public InsertIntoLastPrimitive(final Nod n, final Iter copy, final int l) {\n    super(n, copy, l);\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertIntoPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45717,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param l actual pre location where nodes are inserted\n   */\n  public InsertIntoPrimitive(final Nod n, final Iter copy, final int l) {\n    super(n, copy, l);\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() throws QueryException {\n    if(!(node instanceof DBNode)) return;\n\n    // create db containing insertion nodes\n    // attribute nodes are treated seperately\n    final SeqIter aSeq = new SeqIter();\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      final Iter ni = it.next();\n      // sort nodes into attribute sequence and others\n      Item i = ni.next();\n      while(i != null) {\n        if(Nod.kind(i.type) == Data.ATTR) aSeq.add(i);\n        else seq.add(i);\n        i = ni.next();\n      }\n    }\n    \n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    MemData m = null;\n    // source nodes may be empty, thus insert has no effect at all\n    if(seq.size() == 0 && aSeq.size() == 0) return;\n    \n    // insert non-attribute nodes\n    if(seq.size() > 0) {\n      m = buildDB(seq, ((DBNode) node).data);\n      d.insertSeq(n.pre + d.attSize(n.pre, Nod.kind(n.type)), n.pre, m);\n    }\n    \n    // insert attributes\n    if(aSeq.size() > 0) {\n      m = buildDB(aSeq, ((DBNode) node).data);\n      UpdateFunctions.insertAttributes(n.pre + d.attSize(n.pre, d.kind(n.pre)), \n          n.pre, d, m);\n    }\n  }","id":45718,"modified_method":"@Override\n  public void apply() throws QueryException {\n    if(!(node instanceof DBNode)) return;\n\n    // create db containing insertion nodes\n    // attribute nodes are treated seperately\n    final SeqIter aSeq = new SeqIter();\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      final Iter ni = it.next();\n      // sort nodes into attribute sequence and others\n      Item i = ni.next();\n      while(i != null) {\n        if(Nod.kind(i.type) == Data.ATTR) aSeq.add(i);\n        else seq.add(i);\n        i = ni.next();\n      }\n    }\n    \n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    MemData m = null;\n    // source nodes may be empty, thus insert has no effect at all\n    if(seq.size() == 0 && aSeq.size() == 0) return;\n    \n    // insert non-attribute nodes\n    if(seq.size() > 0) {\n      m = buildDB(seq, ((DBNode) node).data);\n      d.insertSeq(loc, n.pre, m);\n    }\n    \n    // insert attributes\n    if(aSeq.size() > 0) {\n      m = buildDB(aSeq, ((DBNode) node).data);\n      UpdateFunctions.insertAttributes(n.pre + d.attSize(n.pre, d.kind(n.pre)), \n          n.pre, d, m);\n    }\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy node copy\n   * @param attr copied nodes are attributes\n   */\n  protected NodeCopyPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n);\n    c = new LinkedList<Iter>();\n    c.add(copy);\n    a = attr;\n  }","id":45719,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy node copy\n   */\n  protected NodeCopyPrimitive(final Nod n, final Iter copy) {\n    super(n);\n    c = new LinkedList<Iter>();\n    c.add(copy);\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param replace replace nodes\n   * @param attr replacing nodes are attributes\n   */\n  public ReplacePrimitive(final Nod n, final Iter replace, \n      final boolean attr) {\n    super(n, replace, attr);\n  }","id":45720,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param replace replace nodes\n   * @param attr replacing nodes are attributes\n   */\n  public ReplacePrimitive(final Nod n, final Iter replace, \n      final boolean attr) {\n    super(n, replace);\n    a = attr;\n  }","commit_id":"213a189883fabff4c8b4a02e068cd43f68493592","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    // check source constraints\n    final Iter s = SeqIter.get(expr[1].iter(ctx));\n    final SeqIter seq = new SeqIter();\n    Item i = s.next();\n    // e needed to track order of attribute / non attribute nodes XUTY0004\n    boolean e = false;\n    while(i != null) {\n      if(i.type.num || i.type.str) seq.add(new FTxt(i.str(), null));\n      else if(i instanceof Nod) {\n        final Nod tn = (Nod) i;\n        final int k = Nod.kind(tn.type);\n        if(e && k == Data.ATTR) Err.or(UPNOATTRPER, this);\n        if(k != Data.ATTR) e = true;\n        if(Nod.kind(tn.type) == Data.DOC) \n          seq.add(tn.child());\n        else seq.add(tn);\n      } else Err.or(UPDATE, this);\n      i = s.next();\n    }\n    seq.reset();\n    \n    final boolean into = !(before || after);\n    // check target constraints\n    final Iter t = SeqIter.get(expr[0].iter(ctx));\n    i = t.next();\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(!(i instanceof Nod) || t.size() > 1) Err.or(UPTRGTYP, this);\n    final Nod n = (Nod) i;\n    final int k = Nod.kind(n.type);\n    if(into && (!(k == Data.ELEM || k == Data.DOC))) Err.or(UPTRGTYP, this);\n    if(before || after) {\n      if(k == Data.ATTR) Err.or(UPTRGTYP2, this);\n      if(n.parent() == null) Err.or(UPPAREMPTY, this);\n    }\n    \n    Err.or(UPDATE, this);\n    return Iter.EMPTY;\n  }","id":45721,"modified_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    // check source constraints\n    final Iter s = SeqIter.get(expr[1].iter(ctx));\n    final SeqIter seq = new SeqIter();\n    Item i = s.next();\n    // e needed to track order of attribute / non attribute nodes XUTY0004\n    boolean e = false;\n    boolean a = false;\n    while(i != null) {\n      if(i.type.num || i.type.str) seq.add(new FTxt(i.str(), null));\n      else if(i instanceof Nod) {\n        final Nod tn = (Nod) i;\n        final int k = Nod.kind(tn.type);\n        if(k == Data.ATTR) {\n          if(e) Err.or(UPNOATTRPER, this);\n          a = true;\n        }\n        if(k != Data.ATTR) e = true;\n        if(Nod.kind(tn.type) == Data.DOC) \n          seq.add(tn.child());\n        else seq.add(tn);\n      } else Err.or(UPDATE, this);\n      i = s.next();\n    }\n    seq.reset();\n    \n    final boolean into = !(before || after);\n    // check target constraints\n    final Iter t = SeqIter.get(expr[0].iter(ctx));\n    i = t.next();\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(!(i instanceof Nod) || t.size() > 1) Err.or(UPTRGTYP, this);\n    final Nod n = (Nod) i;\n    final int k = Nod.kind(n.type);\n    if(into && (!(k == Data.ELEM || k == Data.DOC))) Err.or(UPTRGTYP, this);\n    if(before || after) {\n      if(k == Data.ATTR) Err.or(UPTRGTYP2, this);\n      if(n.parent() == null) Err.or(UPPAREMPTY, this);\n    }\n    \n    UpdatePrimitive p = null;\n    if(into) p = first ? new InsertIntoFirstPrimitive(n, seq, a) : \n      last ? new InsertIntoLastPrimitive(n, seq, a) : \n        new InsertIntoPrimitive(n, seq, a);\n    \n    if(after) p = new InsertAfterPrimitive(n, seq, a);\n    if(before) p = new InsertBeforePrimitive(n, seq, a);\n    \n    ctx.updates.addPrimitive(p);\n    return Iter.EMPTY;\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void check() throws QueryException {\n    super.check();\n    Err.or(UPDATE, this);\n  }","id":45722,"modified_method":"@Override\n  public void check() throws QueryException {\n    Err.or(UPDATE, this);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  protected InsertAfterPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45723,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertAfterPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n  }","id":45724,"modified_method":"@Override\n  public void apply() throws QueryException {\n // create db containing insertion nodes\n    if(!(node instanceof DBNode)) return;\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      seq.add(it.next());\n    }\n//    m = buildDB(seq, ((DBNode) node).data);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  protected InsertBeforePrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45725,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertBeforePrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void check() throws QueryException {\n    super.check();\n    Err.or(UPDATE, this);\n  }","id":45726,"modified_method":"@Override\n  public void check() throws QueryException {\n    Err.or(UPDATE, this);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n  }","id":45727,"modified_method":"@Override\n  public void apply() throws QueryException {\n // create db containing insertion nodes\n    if(!(node instanceof DBNode)) return;\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      seq.add(it.next());\n    }\n//    m = buildDB(seq, ((DBNode) node).data);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  protected InsertIntoFirstPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45728,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertIntoFirstPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n  }","id":45729,"modified_method":"@Override\n  public void apply() throws QueryException {\n // create db containing insertion nodes\n    if(!(node instanceof DBNode)) return;\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      seq.add(it.next());\n    }\n//    MemData m = buildDB(seq, ((DBNode) node).data);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void check() throws QueryException {\n    super.check();\n    Err.or(UPDATE, this);\n  }","id":45730,"modified_method":"@Override\n  public void check() throws QueryException {\n    Err.or(UPDATE, this);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void check() throws QueryException {\n    super.check();\n    Err.or(UPDATE, this);\n  }","id":45731,"modified_method":"@Override\n  public void check() throws QueryException {\n    Err.or(UPDATE, this);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  protected InsertIntoLastPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","id":45732,"modified_method":"/**\n   * Constructor.\n   * @param n target node\n   * @param copy copy of nodes to be inserted\n   * @param attr copied nodes are attributes\n   */\n  public InsertIntoLastPrimitive(final Nod n, final Iter copy, \n      final boolean attr) {\n    super(n, copy, attr);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n  }","id":45733,"modified_method":"@Override\n  public void apply() throws QueryException {\n // create db containing insertion nodes\n    if(!(node instanceof DBNode)) return;\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      seq.add(it.next());\n    }\n//    m = buildDB(seq, ((DBNode) node).data);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    if(a)\n      UpdateFunctions.insertAttributes(n.pre + d.attSize(n.pre, d.kind(n.pre)), \n          n.pre, d, m);\n    else\n      d.insertSeq(n.pre + d.attSize(n.pre, Nod.kind(n.type)), n.pre, m);\n  }","id":45734,"modified_method":"@Override\n  public void apply() throws QueryException {\n    if(!(node instanceof DBNode)) return;\n\n    // create db containing insertion nodes\n    if(!(node instanceof DBNode)) return;\n    // attribute nodes are treated seperately\n    final SeqIter aSeq = new SeqIter();\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      final Iter ni = it.next();\n      // sort nodes into attribute sequence and others\n      if(a) {\n        Item i = ni.next();\n        while(i != null) {\n          if(Nod.kind(i.type) == Data.ATTR) aSeq.add(i);\n          else seq.add(i);\n          i = ni.next();\n        }\n      } else seq.add(it.next());\n    }\n    \n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    MemData m = null;\n    // insert attributes\n    if(aSeq.size() > 0) {\n      m = buildDB(aSeq, ((DBNode) node).data);\n      UpdateFunctions.insertAttributes(n.pre + d.attSize(n.pre, d.kind(n.pre)), \n          n.pre, d, m);\n    }\n    // insert others\n    if(seq.size() > 0) {\n      m = buildDB(seq, ((DBNode) node).data);\n      d.insertSeq(n.pre + d.attSize(n.pre, Nod.kind(n.type)), n.pre, m);\n    }\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void check() throws QueryException {\n    super.check();\n  }","id":45735,"modified_method":"@SuppressWarnings(\"unused\")\n  @Override\n  public void check() throws QueryException {\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void check() throws QueryException {\n    super.check();\n  }","id":45736,"modified_method":"@SuppressWarnings(\"unused\")\n  @Override\n  public void check() throws QueryException {\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    final int k = Nod.kind(n.type);\n    final int par = d.parent(n.pre, d.kind(n.pre));\n    if(a)\n      UpdateFunctions.insertAttributes(n.pre, par, d, m);\n    else d.insertSeq(n.pre + d.size(n.pre, k), par , m);\n    d.delete(n.pre);\n  }","id":45737,"modified_method":"@Override\n  public void apply() throws QueryException {\n    // create db containing insertion nodes\n    if(!(node instanceof DBNode)) return;\n    final SeqIter seq = new SeqIter();\n    final Iterator<Iter> it = c.iterator();\n    while(it.hasNext()) {\n      seq.add(it.next());\n    }\n    final MemData m = buildDB(seq, ((DBNode) node).data);\n    \n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    final int k = Nod.kind(n.type);\n    final int par = d.parent(n.pre, d.kind(n.pre));\n    if(a)\n      UpdateFunctions.insertAttributes(n.pre, par, d, m);\n    else d.insertSeq(n.pre + d.size(n.pre, k), par , m);\n    d.delete(n.pre);\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Applies the update operation represented by this primitive to the \n   * database. \n   */\n  public abstract void apply();","id":45738,"modified_method":"/**\n   * Applies the update operation represented by this primitive to the \n   * database. \n   * @throws QueryException query exception \n   */\n  public abstract void apply() throws QueryException;","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   */\n  public XQUPTest() {\n    doc =\n      \"<up>\" +\n      \"<cars cat='c'>\" +\n        \"<good>\" +\n          \"<car id='1'>\" +\n            \"<!-- NO COMMENT -->\" +\n          \"<\/car>\" +\n          \"<car id='2' color='blue'>\" +\n            \"<wheels>optional<\/wheels>\" +\n          \"<\/car>\" +\n        \"<\/good>\" +\n        \n        \"<bad howbad='really bad'>\" +\n          \"<car id='3' color='pink'>\" +\n            \"<?advice nogo='buying this one'?>\" +\n            \"<wheels>\" +\n              \"positive\" +\n              \"<count what='wheels'>2 and a half<\/count>\" +\n            \"<\/wheels>\" +\n          \"<\/car>\" +\n        \"<\/bad>\" +\n        \n        \"<ugly>\" +\n          \"<car id='4'>\" +\n            \"<!-- nice one -->\" +\n          \"<\/car>\" +\n        \"<\/ugly>\" +\n      \"<\/cars>\" +\n      \"<?dohere what='how'?>\" +\n      \"<\/up>\";\n    \n    // XQUP expressions return an empty iterator thus every test query q which \n    // name starts with 'xxx' is an update query.\n    // The test query following q represents the actual test.\n    queries = new Object[][] {\n//        { \"xxxxxxxxxxxxx\", nodes(),\n//        \"/up/cars/good/car[1]/@id\" },\n        \n        // delete\n        { \"xxxdel1\", nodes(),\n        \"delete nodes /up/cars/good/car[1]\" },\n        { \"del1\", nodes(5, 12, 22),\n        \"//car\" },\n        { \"xxxdel2\", nodes(),\n        \"delete nodes //car\" },\n        { \"del2\", nodes(),\n        \"//car\" },\n        { \"xxxdel3\", nodes(),\n        \"delete node /up/cars/good/car[1]/@id\" },\n        { \"del3\", nodes(),\n        \"/up/cars/good/car[1]/@id\" },\n        { \"xxxdel4\", nodes(),\n        \"delete node //wheels/text()\" },\n        { \"del4\", nodes(),\n        \"//wheels/text()\" },\n        { \"xxxdel5\", nodes(),\n        \"delete node //comment()\" },\n        { \"del5\", nodes(),\n        \"//comment()\" },\n        { \"xxxdel6\", nodes(),\n        \"delete node //processing-instruction()\" },\n        { \"del6\", nodes(),\n        \"//processing-instruction()\" },\n        \n        // rename\n        { \"xxxren1\", nodes(),\n        \"rename node /up/cars as 'CARS'\" },\n        { \"ren1\", nodes(2),\n        \"/up/CARS\" },\n        { \"xxxren2\", nodes(),\n        \"rename node /up/cars/good/car[1]/@id as 'ID'\" },\n        { \"ren2\", nodes(6),\n        \"//car/@ID\" },\n        { \"xxxren3\", nodes(),\n        \"rename node //processing-instruction('dohere') as 'BADVICE'\" },\n        { \"ren3\", nodes(28),\n        \"//processing-instruction('BADVICE')\" },\n        \n        //[LK] add fragment tests\n        // replace elem\n        { \"xxxrep1\", nodes(),\n        \"replace node /up/cars/good/car[1] with /up/cars/good/car[2]\" },\n        { \"rep1\", nodes(7),\n        \"/up/cars/good/car[1]/@color\" },\n        // replace attribute\n        { \"xxxrep2\", nodes(),\n        \"replace node /up/cars/good/car[1]/@id with \" +\n        \"/up/cars/good/car[2]/@color\" },\n        { \"rep2\", nodes(6),\n        \"/up/cars/good/car[1]/@color, /up/cars/good/car[1]/@id\" },\n        // replace text\n        { \"xxxrep3\", nodes(),\n        \"replace node /up/cars/good/car/wheels/text() with 'snap'\" },\n        { \"rep3\", nodes(11),\n        \"/up/cars/good/car/wheels[text()='snap']\" },\n        { \"xxxrep4\", nodes(),\n        \"replace node /up/cars/good/car/wheels/text() with \" + SEQ1},\n        { \"rep4\", nodes(11),\n        \"/up/cars/good/car/wheels[text()='fooboo']\" },\n        // replace attribute\n        { \"xxxrep5\", nodes(),\n        \"replace node /up/cars/good/car[@id='1']/@id with \" + SEQ3},\n        { \"rep5\", nodes(6,7), \"/up/cars/good/car/@n, /up/cars/good/car/@c\" },\n        // replace comment\n        { \"xxxrep6\", nodes(),\n        \"replace node /up/cars/good/car/comment() with \" + SEQ1},\n        { \"rep6\", nodes(8,9),  \n        \"/up/cars/good/car/text()\" },\n        // replace processing instruction\n        { \"xxxrep7\", nodes(),\n        \"replace node /up/cars/bad/car/processing-instruction() with \" + SEQ1},\n        { \"rep7\", nodes(18,19,20), \n        \"/up/cars/bad/car/a, /up/cars/bad/car/text()\" }, \n    \n        // insert\n        // parser tests\n    };\n  }","id":45739,"modified_method":"/**\n   * Constructor.\n   */\n  public XQUPTest() {\n    doc =\n      \"<up>\" +\n      \"<cars cat='c'>\" +\n        \"<good>\" +\n          \"<car id='1'>\" +\n            \"<!-- NO COMMENT -->\" +\n          \"<\/car>\" +\n          \"<car id='2' color='blue'>\" +\n            \"<wheels>optional<\/wheels>\" +\n          \"<\/car>\" +\n        \"<\/good>\" +\n        \n        \"<bad howbad='really bad'>\" +\n          \"<car id='3' color='pink'>\" +\n            \"<?advice nogo='buying this one'?>\" +\n            \"<wheels>\" +\n              \"positive\" +\n              \"<count what='wheels'>2 and a half<\/count>\" +\n            \"<\/wheels>\" +\n          \"<\/car>\" +\n        \"<\/bad>\" +\n        \n        \"<ugly>\" +\n          \"<car id='4'>\" +\n            \"<!-- nice one -->\" +\n          \"<\/car>\" +\n        \"<\/ugly>\" +\n      \"<\/cars>\" +\n      \"<?dohere what='how'?>\" +\n      \"<\/up>\";\n    \n    // XQUP expressions return an empty iterator thus every test query q which \n    // name starts with 'xxx' is an update query.\n    // The test query following q represents the actual test.\n    queries = new Object[][] {\n//        { \"xxxxxxxxxxxxx\", nodes(),\n//        \"/up/cars/good/car[1]/@id\" },\n        \n        // delete\n        { \"xxxdel1\", nodes(),\n        \"delete nodes /up/cars/good/car[1]\" },\n        { \"del1\", nodes(5, 12, 22),\n        \"//car\" },\n        { \"xxxdel2\", nodes(),\n        \"delete nodes //car\" },\n        { \"del2\", nodes(),\n        \"//car\" },\n        { \"xxxdel3\", nodes(),\n        \"delete node /up/cars/good/car[1]/@id\" },\n        { \"del3\", nodes(),\n        \"/up/cars/good/car[1]/@id\" },\n        { \"xxxdel4\", nodes(),\n        \"delete node //wheels/text()\" },\n        { \"del4\", nodes(),\n        \"//wheels/text()\" },\n        { \"xxxdel5\", nodes(),\n        \"delete node //comment()\" },\n        { \"del5\", nodes(),\n        \"//comment()\" },\n        { \"xxxdel6\", nodes(),\n        \"delete node //processing-instruction()\" },\n        { \"del6\", nodes(),\n        \"//processing-instruction()\" },\n        \n        // rename\n        { \"xxxren1\", nodes(),\n        \"rename node /up/cars as 'CARS'\" },\n        { \"ren1\", nodes(2),\n        \"/up/CARS\" },\n        { \"xxxren2\", nodes(),\n        \"rename node /up/cars/good/car[1]/@id as 'ID'\" },\n        { \"ren2\", nodes(6),\n        \"//car/@ID\" },\n        { \"xxxren3\", nodes(),\n        \"rename node //processing-instruction('dohere') as 'BADVICE'\" },\n        { \"ren3\", nodes(28),\n        \"//processing-instruction('BADVICE')\" },\n        \n        //[LK] add fragment tests\n        // replace elem\n        { \"xxxrep1\", nodes(),\n        \"replace node /up/cars/good/car[1] with /up/cars/good/car[2]\" },\n        { \"rep1\", nodes(7),\n        \"/up/cars/good/car[1]/@color\" },\n        // replace attribute\n        { \"xxxrep2\", nodes(),\n        \"replace node /up/cars/good/car[1]/@id with \" +\n        \"/up/cars/good/car[2]/@color\" },\n        { \"rep2\", nodes(6),\n        \"/up/cars/good/car[1]/@color, /up/cars/good/car[1]/@id\" },\n        // replace text\n        { \"xxxrep3\", nodes(),\n        \"replace node /up/cars/good/car/wheels/text() with 'snap'\" },\n        { \"rep3\", nodes(11),\n        \"/up/cars/good/car/wheels[text()='snap']\" },\n        { \"xxxrep4\", nodes(),\n        \"replace node /up/cars/good/car/wheels/text() with \" + SEQ1},\n        { \"rep4\", nodes(11),\n        \"/up/cars/good/car/wheels[text()='fooboo']\" },\n        // replace attribute\n        { \"xxxrep5\", nodes(),\n        \"replace node /up/cars/good/car[@id='1']/@id with \" + SEQ3},\n        { \"rep5\", nodes(6,7), \"/up/cars/good/car/@n, /up/cars/good/car/@c\" },\n        // replace comment\n        { \"xxxrep6\", nodes(),\n        \"replace node /up/cars/good/car/comment() with \" + SEQ1},\n        { \"rep6\", nodes(8,9),  \n        \"/up/cars/good/car/text()\" },\n        // replace processing instruction\n        { \"xxxrep7\", nodes(),\n        \"replace node /up/cars/bad/car/processing-instruction() with \" + SEQ1},\n        { \"rep7\", nodes(18,19,20), \n        \"/up/cars/bad/car/a, /up/cars/bad/car/text()\" }, \n    \n        // insert\n        { \"xxxins1\", nodes(),\n        \"insert node \" + SEQ1 + \"into /up/cars/good/car[@id=1]\"},\n        { \"ins1\", nodes(18,19,20), \n        \"/up/cars/bad/car/a, /up/cars/bad/car/text()\" },\n        { \"xxxins2\", nodes(),\n        \"insert node \" + SEQ5 + \"into /up/cars/good/car[@id=1]\"},\n        { \"ins2\", nodes(18,19,20), \n        \"/up/cars/bad/car/a, /up/cars/bad/car/text()\" },\n        // parser tests\n    };\n  }","commit_id":"0a04a7786584690d90647c31da9d425db259f619","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param src source expression\n   * @param a as\n   * @param la last\n   * @param in into\n   * @param af after\n   * @param trg target expression\n   */\n  public Insert(final Expr src, final boolean a, final boolean la,\n      final boolean in, final boolean af, final Expr trg) {\n    super(src, trg);\n    as = a;\n    last = la;\n    into = in;\n    after = af;\n  }","id":45740,"modified_method":"/**\n   * Constructor.\n   * @param src source expression\n   * @param a as\n   * @param la last\n   * @param in into\n   * @param af after\n   * @param trg target expression\n   */\n  public Insert(final Expr src, final boolean a, final boolean la,\n      final boolean in, final boolean af, final Expr trg) {\n    super(trg, src);\n    as = a;\n    last = la;\n    into = in;\n    after = af;\n  }","commit_id":"fecb560db9eb339f16f3af829fadfe0d407a21af","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    if(!into) Err.or(UPIMPL, \"only insert into\");\n    final Iter src = expr[1].iter(ctx);\n    Item i = src.next();\n    if(i == null) Err.or(UPSEQEMP, src);\n    if(src.next() != null) Err.or(UPTRGMULT, src);\n    if(!(i instanceof Nod)) Err.or(UPTRGMULT, src);\n    final Nod trgtN = (Nod) i;\n    // [LK] check nodes for type\n    final Iter r = SeqIter.get(expr[0].iter(ctx));\n    i = r.next();\n    if(i instanceof Nod) {\n      final Nod n = (Nod) i;\n      if(Nod.kind(n.type) == Data.ATTR) Err.or(UPIMPL, \"no attrs supported\");\n    }\n    r.reset();\n    final MemData m = buildDB(r,\n        trgtN instanceof DBNode ? ((DBNode) trgtN).data : null);\n    ctx.updates.addPrimitive(new InsertPrimitive(trgtN, m));\n    return Iter.EMPTY;\n  }","id":45741,"modified_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    if(!into) Err.or(UPIMPL, \"only insert into\");\n    final Iter ti = expr[0].iter(ctx);\n    Item i = ti.next();\n    if(i == null) Err.or(UPSEQEMP, ti);\n    if(ti.next() != null) Err.or(UPTRGMULT, ti);\n    if(!(i instanceof Nod)) Err.or(UPTRGMULT, ti);\n    final Nod trgtN = (Nod) i;\n    // [LK] check nodes for type\n    final Iter r = SeqIter.get(expr[1].iter(ctx));\n    i = r.next();\n    final boolean insAttr = Nod.kind(i.type) == Data.ATTR;\n    if(insAttr && Nod.kind(trgtN.type) != Data.ELEM) Err.or(INCOMPLETE, r);\n    i = r.next();\n    while(i != null) {\n      if((Nod.kind(i.type) == Data.ATTR) ^ insAttr) Err.or(INCOMPLETE, r);\n      i = r.next();\n    }\n    r.reset();\n    final MemData m = buildDB(r,\n        trgtN instanceof DBNode ? ((DBNode) trgtN).data : null);\n    ctx.updates.addPrimitive(new InsertPrimitive(trgtN, m, insAttr));\n    return Iter.EMPTY;\n  }","commit_id":"fecb560db9eb339f16f3af829fadfe0d407a21af","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    n.data.insertSeq(n.pre + n.data.attSize(n.pre, Nod.kind(n.type)), n.pre, i);\n  }","id":45742,"modified_method":"@Override\n  public void apply() {\n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    if(a)\n      UpdateFunctions.insertAttributes(n.pre + d.attSize(n.pre, d.kind(n.pre)), \n          n.pre, d, i);\n    else\n      d.insertSeq(n.pre + d.attSize(n.pre, Nod.kind(n.type)), n.pre, i);\n  }","commit_id":"fecb560db9eb339f16f3af829fadfe0d407a21af","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor\n   * @param n target \n   * @param insert insert nodes\n   */\n  public InsertPrimitive(Nod n, final MemData insert) {\n    super(n);\n    i = insert;\n  }","id":45743,"modified_method":"/**\n   * Constructor\n   * @param n target \n   * @param insert insert nodes\n   * @param attr inserted nodes are attributes \n   */\n  public InsertPrimitive(Nod n, final MemData insert, final boolean attr) {\n    super(n);\n    a = attr;\n    i = insert;\n  }","commit_id":"fecb560db9eb339f16f3af829fadfe0d407a21af","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() {\n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    final Data data = n.data;\n    final int k = Nod.kind(n.type);\n    if(a)\n      UpdateFunctions.insertAttributes(n.pre, data, r);\n    else data.insertSeq(n.pre + data.size(n.pre, k), \n        data.parent(n.pre, k), r);\n    data.delete(n.pre);\n  }","id":45744,"modified_method":"@Override\n  public void apply() {\n    if(!(node instanceof DBNode)) return;\n    final DBNode n = (DBNode) node;\n    final Data d = n.data;\n    final int k = Nod.kind(n.type);\n    final int par = d.parent(n.pre, d.kind(n.pre));\n    if(a)\n      UpdateFunctions.insertAttributes(n.pre, par, d, r);\n    else d.insertSeq(n.pre + d.size(n.pre, k), par , r);\n    d.delete(n.pre);\n  }","commit_id":"fecb560db9eb339f16f3af829fadfe0d407a21af","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Inserts a set of attributes a node.\n   * @param pre target pre value\n   * @param d target data reference\n   * @param m {@link MemData} instance holding attributes\n   */\n  public static void insertAttributes(final int pre, final Data d, \n      final MemData m) {\n    final int ss = m.size(0, m.kind(0));\n    final int par = d.parent(pre, d.kind(pre));\n    for(int s = 1; s < ss; s++) {\n      final int p = pre + s - 1;\n      d.insert(p, par, m.attName(s), m.attValue(s));\n    }\n  }","id":45745,"modified_method":"/**\n   * Adds a set of attributes to a node.\n   * @param pre target pre value\n   * @param par parent node\n   * @param d target data reference\n   * @param m {@link MemData} instance holding attributes\n   */\n  public static void insertAttributes(final int pre, final int par, \n      final Data d, final MemData m) {\n    final int ss = m.size(0, m.kind(0));\n    for(int s = 1; s < ss; s++) {\n      final int p = pre + s - 1;\n      d.insert(p, par, m.attName(s), m.attValue(s));\n    }\n  }","commit_id":"fecb560db9eb339f16f3af829fadfe0d407a21af","url":"https://github.com/BaseXdb/basex"},{"original_method":"public void startup() {\r\n\t\tconfProvider.startup();\r\n\t}","id":45746,"modified_method":"public boolean startup() {\r\n\t\treturn confProvider.startup();\r\n\t}","commit_id":"6b24878a5c57a529cd24d6672889abbb843b8616","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n    public void startup() {    \t\n        Client c = manager.getESLClient();\n        if (c.canSend()) {\n            c.addEventListener( this );\n            c.cancelEventSubscriptions();\n            c.setEventSubscriptions( \"plain\", \"all\" );\n            c.addEventFilter( \"Event-Name\", \"heartbeat\" );\n            c.addEventFilter( \"Event-Name\", \"custom\" );\n            c.addEventFilter( \"Event-Name\", \"background_job\" );\n            \n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException ex) {\n                java.util.logging.Logger.getLogger(FreeswitchApplication.class.getName()).log(Level.SEVERE, null, ex);\n            }        \t\n        }\n\n        //Start Heartbeat and exception Event Observer Monitor\n        startHeartbeatMonitor();\n    }","id":45747,"modified_method":"@Override\n    public boolean startup() {    \t\n        Client c = manager.getESLClient();\n        if (c.canSend()) {\n            c.addEventListener( this );\n            c.cancelEventSubscriptions();\n            c.setEventSubscriptions( \"plain\", \"all\" );\n            c.addEventFilter( \"Event-Name\", \"heartbeat\" );\n            c.addEventFilter( \"Event-Name\", \"custom\" );\n            c.addEventFilter( \"Event-Name\", \"background_job\" );\n            \n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException ex) {\n                java.util.logging.Logger.getLogger(FreeswitchApplication.class.getName()).log(Level.SEVERE, null, ex);\n                return false;\n            }        \t\n        }\n\n        //Start Heartbeat and exception Event Observer Monitor\n        startHeartbeatMonitor();\n        return true;\n    }","commit_id":"6b24878a5c57a529cd24d6672889abbb843b8616","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic void startup() {\r\n\t\tif (connection == null) {\r\n\t\t\tlog.error(\"Cannot start application as ESL Client has not been set.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (connect()) {\r\n            appDelegate.startup();\r\n\t\t}\r\n\t}","id":45748,"modified_method":"@Override\r\n\tpublic boolean startup() {\r\n\t\tif (connection == null) {\r\n\t\t\tlog.error(\"Cannot start application as ESL Client has not been set.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (connect()) {\r\n            return appDelegate.startup();\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}","commit_id":"6b24878a5c57a529cd24d6672889abbb843b8616","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n\tpublic boolean appStart(IScope scope) {\n\t\tlog.debug(APP + \":appStart \" + scope.getName());\n\t\tconferenceService.startup();\n\t\treturn true;\n\t}","id":45749,"modified_method":"@Override\n\tpublic boolean appStart(IScope scope) {\n\t\tlog.debug(APP + \":appStart \" + scope.getName());\n\t\treturn conferenceService.startup();\n\t}","commit_id":"6b24878a5c57a529cd24d6672889abbb843b8616","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void startup(final OServerConfiguration iConfiguration) throws IllegalArgumentException, SecurityException,\r\n      InvocationTargetException, NoSuchMethodException {\r\n    OLogManager.instance().info(this, \"OrientDB Server v\" + OConstants.getVersion() + \" is starting up...\");\r\n\r\n    Orient.instance();\r\n\r\n    loadConfiguration(iConfiguration);\r\n\r\n    if (OGlobalConfiguration.USE_NODE_ID_CLUSTER_POSITION.getValueAsBoolean())\r\n      OLogManager.instance().info(\r\n          this,\r\n          \"ONodeId will be used as presentation of cluster position, \" + \" please do not forget to set \"\r\n              + OGlobalConfiguration.USE_NODE_ID_CLUSTER_POSITION.getKey() + \" property to \\\"true\\\" value on client side ...\");\r\n\r\n    if (OGlobalConfiguration.ENVIRONMENT_DUMP_CFG_AT_STARTUP.getValueAsBoolean()) {\r\n      System.out.println(\"Dumping environment after server startup...\");\r\n      OGlobalConfiguration.dumpConfiguration(System.out);\r\n    }\r\n\r\n    OSharedDocumentDatabase.setup(contextConfiguration.getValueAsInteger(OGlobalConfiguration.DB_POOL_MIN),\r\n        contextConfiguration.getValueAsInteger(OGlobalConfiguration.DB_POOL_MAX));\r\n\r\n    databaseDirectory = contextConfiguration.getValue(\"server.database.path\", \"${\" + Orient.ORIENTDB_HOME + \"}/databases/\");\r\n    databaseDirectory = OSystemVariableResolver.resolveSystemVariables(databaseDirectory);\r\n    databaseDirectory = databaseDirectory.replace(\"//\", \"/\");\r\n  }","id":45750,"modified_method":"public OServer startup(final OServerConfiguration iConfiguration) throws IllegalArgumentException, SecurityException,\r\n      InvocationTargetException, NoSuchMethodException {\r\n    OLogManager.instance().info(this, \"OrientDB Server v\" + OConstants.getVersion() + \" is starting up...\");\r\n\r\n    Orient.instance();\r\n\r\n    loadConfiguration(iConfiguration);\r\n\r\n    if (OGlobalConfiguration.USE_NODE_ID_CLUSTER_POSITION.getValueAsBoolean())\r\n      OLogManager.instance().info(\r\n          this,\r\n          \"ONodeId will be used as presentation of cluster position, \" + \" please do not forget to set \"\r\n              + OGlobalConfiguration.USE_NODE_ID_CLUSTER_POSITION.getKey() + \" property to \\\"true\\\" value on client side ...\");\r\n\r\n    if (OGlobalConfiguration.ENVIRONMENT_DUMP_CFG_AT_STARTUP.getValueAsBoolean()) {\r\n      System.out.println(\"Dumping environment after server startup...\");\r\n      OGlobalConfiguration.dumpConfiguration(System.out);\r\n    }\r\n\r\n    OSharedDocumentDatabase.setup(contextConfiguration.getValueAsInteger(OGlobalConfiguration.DB_POOL_MIN),\r\n        contextConfiguration.getValueAsInteger(OGlobalConfiguration.DB_POOL_MAX));\r\n\r\n    databaseDirectory = contextConfiguration.getValue(\"server.database.path\", \"${\" + Orient.ORIENTDB_HOME + \"}/databases/\");\r\n    databaseDirectory = OSystemVariableResolver.resolveSystemVariables(databaseDirectory);\r\n    databaseDirectory = databaseDirectory.replace(\"//\", \"/\");\r\n    \r\n    return this;\r\n  }","commit_id":"1bf0a26534f5c1985637e4b91c17833ad42062dc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void startup(final InputStream iInputStream) throws InstantiationException, IllegalAccessException,\r\n      ClassNotFoundException, IllegalArgumentException, SecurityException, InvocationTargetException, NoSuchMethodException,\r\n      IOException {\r\n\r\n    configurationLoader = new OServerConfigurationLoaderXml(OServerConfiguration.class, iInputStream);\r\n    configuration = configurationLoader.load();\r\n\r\n    // Startup function split to allow pre-activation changes\r\n    startup(configuration);\r\n  }","id":45751,"modified_method":"public OServer startup(final InputStream iInputStream) throws InstantiationException, IllegalAccessException,\r\n      ClassNotFoundException, IllegalArgumentException, SecurityException, InvocationTargetException, NoSuchMethodException,\r\n      IOException {\r\n\r\n    configurationLoader = new OServerConfigurationLoaderXml(OServerConfiguration.class, iInputStream);\r\n    configuration = configurationLoader.load();\r\n\r\n    // Startup function split to allow pre-activation changes\r\n    return startup(configuration);\r\n  }","commit_id":"1bf0a26534f5c1985637e4b91c17833ad42062dc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public void activate() throws ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n    for (OServerLifecycleListener l : lifecycleListeners)\r\n      l.onBeforeActivate();\r\n\r\n    // REGISTER PROTOCOLS\r\n    for (OServerNetworkProtocolConfiguration p : configuration.network.protocols)\r\n      networkProtocols.put(p.name, (Class<? extends ONetworkProtocol>) Class.forName(p.implementation));\r\n\r\n    // STARTUP LISTENERS\r\n    for (OServerNetworkListenerConfiguration l : configuration.network.listeners)\r\n      networkListeners.add(new OServerNetworkListener(this, l.ipAddress, l.portRange, l.protocol, networkProtocols.get(l.protocol),\r\n          l.parameters, l.commands));\r\n\r\n    registerPlugins();\r\n\r\n    for (OServerLifecycleListener l : lifecycleListeners)\r\n      l.onAfterActivate();\r\n\r\n    OLogManager.instance().info(this, \"OrientDB Server v\" + OConstants.ORIENT_VERSION + \" is active.\");\r\n    startupLatch.countDown();\r\n  }","id":45752,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public OServer activate() throws ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n    for (OServerLifecycleListener l : lifecycleListeners)\r\n      l.onBeforeActivate();\r\n\r\n    // REGISTER PROTOCOLS\r\n    for (OServerNetworkProtocolConfiguration p : configuration.network.protocols)\r\n      networkProtocols.put(p.name, (Class<? extends ONetworkProtocol>) Class.forName(p.implementation));\r\n\r\n    // STARTUP LISTENERS\r\n    for (OServerNetworkListenerConfiguration l : configuration.network.listeners)\r\n      networkListeners.add(new OServerNetworkListener(this, l.ipAddress, l.portRange, l.protocol, networkProtocols.get(l.protocol),\r\n          l.parameters, l.commands));\r\n\r\n    registerPlugins();\r\n\r\n    for (OServerLifecycleListener l : lifecycleListeners)\r\n      l.onAfterActivate();\r\n\r\n    OLogManager.instance().info(this, \"OrientDB Server v\" + OConstants.ORIENT_VERSION + \" is active.\");\r\n    startupLatch.countDown();\r\n    \r\n    return this;\r\n  }","commit_id":"1bf0a26534f5c1985637e4b91c17833ad42062dc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void startup(final String iConfiguration) throws InstantiationException, IllegalAccessException, ClassNotFoundException,\r\n      IllegalArgumentException, SecurityException, InvocationTargetException, NoSuchMethodException, IOException {\r\n    startup(new ByteArrayInputStream(iConfiguration.getBytes()));\r\n  }","id":45753,"modified_method":"public OServer startup(final String iConfiguration) throws InstantiationException, IllegalAccessException, ClassNotFoundException,\r\n      IllegalArgumentException, SecurityException, InvocationTargetException, NoSuchMethodException, IOException {\r\n    return startup(new ByteArrayInputStream(iConfiguration.getBytes()));\r\n  }","commit_id":"1bf0a26534f5c1985637e4b91c17833ad42062dc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static void main(String[] args)\n  {\n    try\n    {\n      setPortalBaseDir();\n      propertiesUri = UtilitiesBean.fixURI(\"properties\" + File.separator + \"dbloader.xml\");\n      con = rdbmService.getConnection ();\n\n      if (con != null)\n      {\n        long startTime = System.currentTimeMillis();\n\n        // Read in the properties\n        XMLReader parser = getXMLReader();\n        printInfo();\n        readProperties(parser);\n\n        // Read drop/create/populate table settings\n        dropTables = Boolean.valueOf(PropertiesHandler.properties.getDropTables()).booleanValue();\n        createTables = Boolean.valueOf(PropertiesHandler.properties.getCreateTables()).booleanValue();\n        populateTables = Boolean.valueOf(PropertiesHandler.properties.getPopulateTables()).booleanValue();\n\n        // Set up script\n        createScript = Boolean.valueOf(PropertiesHandler.properties.getCreateScript()).booleanValue();\n        if (createScript)\n          initScript();\n\n        try\n        {\n          String tablesURI = UtilitiesBean.fixURI(PropertiesHandler.properties.getTablesUri());\n          \n          // Read tables.xml\n          DOMParser domParser = new DOMParser();\n          // Eventually, write and validate against a DTD\n          //domParser.setFeature (\"http://xml.org/sax/features/validation\", true);\n          //domParser.setEntityResolver(new DTDResolver(\"tables.dtd\"));\n          domParser.parse(tablesURI);\n          tablesDoc = domParser.getDocument();\n        }\n        catch(Exception e)\n        {\n          System.out.println(\"Could not open \" + UtilitiesBean.fixURI(PropertiesHandler.properties.getTablesUri()));\n          e.printStackTrace();\n          \n          return;\n        }\n\n        // Hold on to tables xml with generic types\n        tablesDocGeneric = (Document)tablesDoc.cloneNode(true);\n\n        // Replace all generic data types with local data types\n        replaceDataTypes(tablesDoc);\n\n        String tablesXslUri = UtilitiesBean.fixURI(PropertiesHandler.properties.getTablesXslUri());\n        \n        // tables.xml + tables.xsl --> DROP TABLE and CREATE TABLE sql statements\n        XSLTProcessor processor = XSLTProcessorFactory.getProcessor (new org.apache.xalan.xpath.xdom.XercesLiaison ());\n        XSLTInputSource tablesInputSource = new XSLTInputSource(tablesDoc);\n        XSLTInputSource tablesXslInputSource = new XSLTInputSource(tablesXslUri);\n        XSLTResultTarget tablesTarget = new XSLTResultTarget(new TableHandler());\n        processor.process (tablesInputSource, tablesXslInputSource, tablesTarget);\n\n        // data.xml --> INSERT sql statements\n        readData(parser);\n\n        System.out.println(\"Done!\");\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Elapsed time: \" + ((endTime - startTime) / 1000f) + \" seconds\");\n        exit();\n      }\n      else\n        System.out.println(\"DbLoader couldn't obtain a database connection. See '\" + portalBaseDir + \"logs\" + File.separator + \"portal.log' for details.\");\n\n    }\n    catch (Exception e)\n    {\n      e.printStackTrace();\n    }\n    finally\n    {\n      exit();\n    }\n  }","id":45754,"modified_method":"public static void main(String[] args)\n  {\n    try\n    {\n      setPortalBaseDir();\n      propertiesUri = UtilitiesBean.fixURI(\"properties\" + File.separator + \"dbloader.xml\");\n      con = rdbmService.getConnection ();\n\n      if (con != null)\n      {\n        long startTime = System.currentTimeMillis();\n\n        // Read in the properties\n        XMLReader parser = getXMLReader();\n        printInfo();\n        readProperties(parser);\n\n        // Read drop/create/populate table settings\n        dropTables = Boolean.valueOf(PropertiesHandler.properties.getDropTables()).booleanValue();\n        createTables = Boolean.valueOf(PropertiesHandler.properties.getCreateTables()).booleanValue();\n        populateTables = Boolean.valueOf(PropertiesHandler.properties.getPopulateTables()).booleanValue();\n\n        // Set up script\n        createScript = Boolean.valueOf(PropertiesHandler.properties.getCreateScript()).booleanValue();\n        if (createScript)\n          initScript();\n\n        try\n        {\n          // Read tables.xml\n          DOMParser domParser = new DOMParser();\n          // Eventually, write and validate against a DTD\n          //domParser.setFeature (\"http://xml.org/sax/features/validation\", true);\n          //domParser.setEntityResolver(new DTDResolver(\"tables.dtd\"));\n          tablesUri = UtilitiesBean.fixURI(PropertiesHandler.properties.getTablesUri());\n          domParser.parse(tablesURI);\n          tablesDoc = domParser.getDocument();\n        }\n        catch(Exception e)\n        {\n          System.out.println(\"Could not open \" + tablesUri);\n          e.printStackTrace();\n\n          return;\n        }\n\n        // Hold on to tables xml with generic types\n        tablesDocGeneric = (Document)tablesDoc.cloneNode(true);\n\n        // Replace all generic data types with local data types\n        replaceDataTypes(tablesDoc);\n\n        // tables.xml + tables.xsl --> DROP TABLE and CREATE TABLE sql statements\n        XSLTProcessor processor = XSLTProcessorFactory.getProcessor (new org.apache.xalan.xpath.xdom.XercesLiaison ());\n        XSLTInputSource tablesInputSource = new XSLTInputSource(tablesDoc);\n        tablesXslUri = UtilitiesBean.fixURI(PropertiesHandler.properties.getTablesXslUri());\n        XSLTInputSource tablesXslInputSource = new XSLTInputSource(tablesXslUri);\n        XSLTResultTarget tablesTarget = new XSLTResultTarget(new TableHandler());\n        processor.process (tablesInputSource, tablesXslInputSource, tablesTarget);\n\n        // data.xml --> INSERT sql statements\n        readData(parser);\n\n        System.out.println(\"Done!\");\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Elapsed time: \" + ((endTime - startTime) / 1000f) + \" seconds\");\n        exit();\n      }\n      else\n        System.out.println(\"DbLoader couldn't obtain a database connection. See '\" + portalBaseDir + \"logs\" + File.separator + \"portal.log' for details.\");\n\n    }\n    catch (Exception e)\n    {\n      e.printStackTrace();\n    }\n    finally\n    {\n      exit();\n    }\n  }","commit_id":"b09b9326c8d2b1c262c0acbc3ce82b7dc37d46c6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void renderXML (DocumentHandler out) throws PortalException\n  {\n    String xml;\n\n    try\n    {\n      xml = getXmlString (fullxmlUri);\n    }\n    catch (Exception e)\n    {\n      throw new ResourceMissingException (fullxmlUri, \"\", e.getMessage());\n    }\n\n    runtimeData.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n\n    // Runtime data parameters gets handed to the stylesheet.\n    // Add any static data parameters so it gets a full set of variables.\n    // Possibly this should be a copy.\n    if (xmlUri != null)\n      runtimeData.put(\"cw_xml\", xmlUri);\n    if (sslUri != null)\n      runtimeData.put(\"cs_ssl\", sslUri);\n    if (xslTitle != null)\n      runtimeData.put(\"cw_xslTitle\", xslTitle);\n    if (xslUri != null)\n      runtimeData.put(\"cw_xsl\", xslUri);\n    if (passThrough != null)\n      runtimeData.put(\"cw_passThrough\", passThrough);\n    if (tidy != null)\n      runtimeData.put(\"cw_tidy\", tidy);\n    if (infoUri != null)\n      runtimeData.put(\"cw_info\", infoUri);\n    if (helpUri != null)\n      runtimeData.put(\"cw_help\", helpUri);\n    if (editUri != null)\n      runtimeData.put(\"cw_edit\", editUri);\n\n    try\n    {\n      if (xslUri != null)\n        XSLT.transform(xml, new URL(UtilitiesBean.fixURI(sslUri)), out, runtimeData);\n      else\n      {\n        if (xslTitle != null)\n          XSLT.transform(xml, new URL(UtilitiesBean.fixURI(sslUri)), out, runtimeData, xslTitle, runtimeData.getBrowserInfo());\n        else\n          XSLT.transform(xml, new URL(UtilitiesBean.fixURI(sslUri)), out, runtimeData, runtimeData.getBrowserInfo());\n      }\n    }\n    catch (org.xml.sax.SAXException e)\n    {\n      throw new GeneralRenderingException(\"problem performing the transformation\");\n    } catch (IOException i) {\n      StringWriter sw = new StringWriter();\n      i.printStackTrace(new PrintWriter(sw));\n      sw.flush();\n      throw new GeneralRenderingException(sw.toString());\n    }\n  }","id":45755,"modified_method":"public void renderXML (DocumentHandler out) throws PortalException\n  {\n    String xml;\n\n    try\n    {\n      xml = getXmlString (fullxmlUri);\n    }\n    catch (Exception e)\n    {\n      throw new ResourceMissingException (fullxmlUri, \"\", e.getMessage());\n    }\n\n    runtimeData.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n\n    // Runtime data parameters gets handed to the stylesheet.\n    // Add any static data parameters so it gets a full set of variables.\n    // Possibly this should be a copy.\n    if (xmlUri != null)\n      runtimeData.put(\"cw_xml\", xmlUri);\n    if (sslUri != null)\n      runtimeData.put(\"cs_ssl\", sslUri);\n    if (xslTitle != null)\n      runtimeData.put(\"cw_xslTitle\", xslTitle);\n    if (xslUri != null)\n      runtimeData.put(\"cw_xsl\", xslUri);\n    if (passThrough != null)\n      runtimeData.put(\"cw_passThrough\", passThrough);\n    if (tidy != null)\n      runtimeData.put(\"cw_tidy\", tidy);\n    if (infoUri != null)\n      runtimeData.put(\"cw_info\", infoUri);\n    if (helpUri != null)\n      runtimeData.put(\"cw_help\", helpUri);\n    if (editUri != null)\n      runtimeData.put(\"cw_edit\", editUri);\n\n    XSLT xslt = new XSLT();\n    xslt.setXML(xml);\n    if (xslUri != null)\n      xslt.setXSL(xslUri);\n    else \n      xslt.setSSL(UtilitiesBean.fixURI(sslUri), xslTitle, runtimeData.getBrowserInfo());\n    xslt.setTarget(out);\n    xslt.setStylesheetParameters(runtimeData);\n    xslt.transform();\n  }","commit_id":"bca4a156b01d7cba3a879203b17c78175af37372","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n        final ClassPathBeanDefinitionScanner scanner = super.configureScanner(parserContext, element);\n\n        final ResourceLoader originalResourceLoader = parserContext.getReaderContext().getResourceLoader();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Scanning only this classloader:\" + originalResourceLoader.getClassLoader());\n        }\n\n        ResourceLoader parentOnlyResourceLoader;\n        try {\n            parentOnlyResourceLoader = new ResourceLoader() {\n                ClassLoader parentOnlyGetResourcesClassLoader = new ParentOnlyGetResourcesClassLoader(originalResourceLoader.getClassLoader());\n\n                public Resource getResource(String location) {\n                    return originalResourceLoader.getResource(location);\n                }\n\n                public ClassLoader getClassLoader() {\n                    return parentOnlyGetResourcesClassLoader;\n                }\n            };\n        }\n        catch (Throwable t) {\n            // restrictive classloading environment, use the original\n            parentOnlyResourceLoader = originalResourceLoader;\n        }\n\n        final PathMatchingResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(parentOnlyResourceLoader) {\n            @Override\n            protected Resource[] findAllClassPathResources(String location) throws IOException {\n                Set<Resource> result = new LinkedHashSet<Resource>(16);\n\n                @SuppressWarnings(\"unused\")\n                URL classesDir = GrailsApp.getCLASSES_DIR().toURI().toURL();\n\n                // only scan classes from project classes directory\n                String path = location;\n                if (path.startsWith(\"/\")) {\n                    path = path.substring(1);\n                }\n                Enumeration<URL> resourceUrls = getClassLoader().getResources(path);\n                while (resourceUrls.hasMoreElements()) {\n                    URL url = resourceUrls.nextElement();\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Scanning URL \" + url.toExternalForm() + \" while searching for '\" + location + \"'\");\n                    }\n                    /*\n                    if (!warDeployed && classesDir!= null && url.equals(classesDir)) {\n                        result.add(convertClassLoaderURL(url));\n                    }\n                    else if (warDeployed) {\n                        result.add(convertClassLoaderURL(url));\n                    }\n                    */\n                    result.add(convertClassLoaderURL(url));\n                }\n                return result.toArray(new Resource[result.size()]);\n            }\n        };\n        resourceResolver.setPathMatcher(new AntPathMatcher() {\n            @Override\n            public boolean match(String pattern, String path) {\n                if (path.endsWith(\".class\")) {\n                    String filename = GrailsStringUtils.getFileBasename(path);\n                    if (filename.contains(\"$\")) return false;\n                }\n                return super.match(pattern, path);\n            }\n        });\n        scanner.setResourceLoader(resourceResolver);\n        return scanner;\n    }","id":45756,"modified_method":"@Override\n    protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n        final ClassPathBeanDefinitionScanner scanner = super.configureScanner(parserContext, element);\n\n        final ResourceLoader originalResourceLoader = parserContext.getReaderContext().getResourceLoader();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Scanning only this classloader:\" + originalResourceLoader.getClassLoader());\n        }\n\n        ResourceLoader parentOnlyResourceLoader;\n        try {\n            parentOnlyResourceLoader = new ResourceLoader() {\n                ClassLoader parentOnlyGetResourcesClassLoader = new ParentOnlyGetResourcesClassLoader(originalResourceLoader.getClassLoader());\n\n                public Resource getResource(String location) {\n                    return originalResourceLoader.getResource(location);\n                }\n\n                public ClassLoader getClassLoader() {\n                    return parentOnlyGetResourcesClassLoader;\n                }\n            };\n        }\n        catch (Throwable t) {\n            // restrictive classloading environment, use the original\n            parentOnlyResourceLoader = originalResourceLoader;\n        }\n\n        final PathMatchingResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(parentOnlyResourceLoader) {\n            @Override\n            protected Resource[] findAllClassPathResources(String location) throws IOException {\n                Set<Resource> result = new LinkedHashSet<Resource>(16);\n\n                if(BuildSettings.CLASSES_DIR != null) {\n                    @SuppressWarnings(\"unused\")\n                    URL classesDir = BuildSettings.CLASSES_DIR.toURI().toURL();\n\n                    // only scan classes from project classes directory\n                    String path = location;\n                    if (path.startsWith(\"/\")) {\n                        path = path.substring(1);\n                    }\n                    Enumeration<URL> resourceUrls = getClassLoader().getResources(path);\n                    while (resourceUrls.hasMoreElements()) {\n                        URL url = resourceUrls.nextElement();\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Scanning URL \" + url.toExternalForm() + \" while searching for '\" + location + \"'\");\n                        }\n                    /*\n                    if (!warDeployed && classesDir!= null && url.equals(classesDir)) {\n                        result.add(convertClassLoaderURL(url));\n                    }\n                    else if (warDeployed) {\n                        result.add(convertClassLoaderURL(url));\n                    }\n                    */\n                        result.add(convertClassLoaderURL(url));\n                    }\n                }\n                return result.toArray(new Resource[result.size()]);\n            }\n        };\n        resourceResolver.setPathMatcher(new AntPathMatcher() {\n            @Override\n            public boolean match(String pattern, String path) {\n                if (path.endsWith(\".class\")) {\n                    String filename = GrailsStringUtils.getFileBasename(path);\n                    if (filename.contains(\"$\")) return false;\n                }\n                return super.match(pattern, path);\n            }\n        });\n        scanner.setResourceLoader(resourceResolver);\n        return scanner;\n    }","commit_id":"d70195aac3215470c79bb1822a27abc0dbc2cd60","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Configures the loaded classes within the GrailsApplication instance using the\n     * registered ArtefactHandler instances.\n     *\n     * @param classes The classes to configure\n     */\n    protected void configureLoadedClasses(Class<?>[] classes) {\n\n        initArtefactHandlers();\n\n        artefactInfo.clear();\n        allArtefactClasses.clear();\n        allArtefactClassesArray = null;\n        allClasses = classes;\n\n        // first load the domain classes\n        log.debug(\"Going to inspect artefact classes.\");\n        boolean warDeployed = Environment.isWarDeployed();\n        for (final Class<?> theClass : classes) {\n            log.debug(\"Inspecting [\" + theClass.getName() + \"]\");\n            // start fresh\n            if (!warDeployed) {\n                GroovySystem.getMetaClassRegistry().removeMetaClass(theClass);\n            }\n            if (allArtefactClasses.contains(theClass)) {\n                continue;\n            }\n\n            // check what kind of artefact it is and add to corrent data structure\n            for (ArtefactHandler artefactHandler : artefactHandlers) {\n                if (artefactHandler.isArtefact(theClass)) {\n                    log.debug(\"Adding artefact \" + theClass + \" of kind \" + artefactHandler.getType());\n                    GrailsClass gclass = addArtefact(artefactHandler.getType(), theClass);\n                    // Also maintain set of all artefacts (!= all classes loaded)\n                    allArtefactClasses.add(theClass);\n\n                    // Update per-artefact cache\n                    DefaultArtefactInfo info = getArtefactInfo(artefactHandler.getType(), true);\n                    info.addGrailsClass(gclass);\n                    break;\n                }\n            }\n        }\n\n        refreshArtefactGrailsClassCaches();\n\n        allArtefactClassesArray = allArtefactClasses.toArray(new Class[allArtefactClasses.size()]);\n\n        // Tell all artefact handlers to init now we've worked out which classes are which artefacts\n        for (ArtefactHandler artefactHandler : artefactHandlers) {\n            initializeArtefacts(artefactHandler);\n        }\n    }","id":45757,"modified_method":"/**\n     * Configures the loaded classes within the GrailsApplication instance using the\n     * registered ArtefactHandler instances.\n     *\n     * @param classes The classes to configure\n     */\n    protected void configureLoadedClasses(Class<?>[] classes) {\n\n        initArtefactHandlers();\n\n        artefactInfo.clear();\n        allArtefactClasses.clear();\n        allArtefactClassesArray = null;\n        allClasses = classes;\n\n        // first load the domain classes\n        log.debug(\"Going to inspect artefact classes.\");\n        MetaClassRegistry metaClassRegistry = GroovySystem.getMetaClassRegistry();\n\n        for (final Class<?> theClass : classes) {\n            log.debug(\"Inspecting [\" + theClass.getName() + \"]\");\n            // start fresh\n            metaClassRegistry.removeMetaClass(theClass);\n            if (allArtefactClasses.contains(theClass)) {\n                continue;\n            }\n\n            // check what kind of artefact it is and add to corrent data structure\n            for (ArtefactHandler artefactHandler : artefactHandlers) {\n                if (artefactHandler.isArtefact(theClass)) {\n                    log.debug(\"Adding artefact \" + theClass + \" of kind \" + artefactHandler.getType());\n                    GrailsClass gclass = addArtefact(artefactHandler.getType(), theClass);\n                    // Also maintain set of all artefacts (!= all classes loaded)\n                    allArtefactClasses.add(theClass);\n\n                    // Update per-artefact cache\n                    DefaultArtefactInfo info = getArtefactInfo(artefactHandler.getType(), true);\n                    info.addGrailsClass(gclass);\n                    break;\n                }\n            }\n        }\n\n        refreshArtefactGrailsClassCaches();\n\n        allArtefactClassesArray = allArtefactClasses.toArray(new Class[allArtefactClasses.size()]);\n\n        // Tell all artefact handlers to init now we've worked out which classes are which artefacts\n        for (ArtefactHandler artefactHandler : artefactHandlers) {\n            initializeArtefacts(artefactHandler);\n        }\n    }","commit_id":"d70195aac3215470c79bb1822a27abc0dbc2cd60","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public Resource getResource(String location) {\n\n        if (location.startsWith(WEB_INF_PREFIX)) {\n            location = location.substring(WEB_INF_PREFIX.length());\n        }\n        if (groovyPages.containsKey(location)) {\n            try {\n                return new ByteArrayResource(groovyPages.get(location).getBytes(\"UTF-8\"), location);\n            } catch (UnsupportedEncodingException e) {\n                // continue\n            }\n        }\n        \n        if(basePath == null) {\n            String basedir = GrailsApp.getBASE_DIR().getAbsolutePath();\n            basePath = basedir + File.separatorChar + GrailsResourceUtils.VIEWS_DIR_PATH;\n        }\n\n        String path = basePath + location;\n        path = makeCanonical(path);\n        return new FileSystemResource(path);\n    }","id":45758,"modified_method":"@Override\n    public Resource getResource(String location) {\n\n        if (location.startsWith(WEB_INF_PREFIX)) {\n            location = location.substring(WEB_INF_PREFIX.length());\n        }\n        if (groovyPages.containsKey(location)) {\n            try {\n                return new ByteArrayResource(groovyPages.get(location).getBytes(\"UTF-8\"), location);\n            } catch (UnsupportedEncodingException e) {\n                // continue\n            }\n        }\n        \n        if(basePath == null) {\n            String basedir = BuildSettings.BASE_DIR.getAbsolutePath();\n            basePath = basedir + File.separatorChar + GrailsResourceUtils.VIEWS_DIR_PATH;\n        }\n\n        String path = basePath + location;\n        path = makeCanonical(path);\n        return new FileSystemResource(path);\n    }","commit_id":"d70195aac3215470c79bb1822a27abc0dbc2cd60","url":"https://github.com/grails/grails-core"},{"original_method":"public ResourceLocator getResourceLocator() {\n        if (resourceLocator == null) {\n            resourceLocator = new DefaultResourceLocator();\n            String basedir = GrailsApp.getBASE_DIR().getAbsolutePath();\n            resourceLocator.setSearchLocation(basedir);\n        }\n        return resourceLocator;\n    }","id":45759,"modified_method":"public ResourceLocator getResourceLocator() {\n        if (resourceLocator == null) {\n            resourceLocator = new DefaultResourceLocator();\n            String basedir = BuildSettings.BASE_DIR.getAbsolutePath();\n            resourceLocator.setSearchLocation(basedir);\n        }\n        return resourceLocator;\n    }","commit_id":"d70195aac3215470c79bb1822a27abc0dbc2cd60","url":"https://github.com/grails/grails-core"},{"original_method":"public void clean() {\n        MetaClassRegistry registry = GroovySystem.getMetaClassRegistry();\n        Set<Class> classes = new HashSet<Class>(alteredClasses.keySet());\n        for (Class aClass : classes) {\n            Object alteredMetaClass = alteredClasses.get(aClass);\n            if(alteredMetaClass == NO_CUSTOM_METACLASS) {\n                registry.removeMetaClass(aClass);\n            }\n            else {\n                registry.setMetaClass(aClass, (MetaClass) alteredMetaClass);\n            }\n        }\n        alteredClasses.clear();\n    }","id":45760,"modified_method":"public void clean() {\n        MetaClassRegistryImpl registry = (MetaClassRegistryImpl) GroovySystem.getMetaClassRegistry();\n        cleanMetaClassOfClass(registry);\n        cleanMetaClassOfInstance(registry);\n    }","commit_id":"ffc7b16928f981479de2d6d034765973c2b664c5","url":"https://github.com/grails/grails-core"},{"original_method":"public void updateConstantMetaClass(MetaClassRegistryChangeEvent cmcu) {\n        MetaClass oldMetaClass = cmcu.getOldMetaClass();\n        Class classToUpdate = cmcu.getClassToUpdate();\n        if(oldMetaClass != null) {\n            Object current = alteredClasses.get(classToUpdate);\n            if(current == null || current == NO_CUSTOM_METACLASS) {\n                alteredClasses.put(classToUpdate, oldMetaClass);\n            }\n        }\n        else {\n            alteredClasses.put(classToUpdate, NO_CUSTOM_METACLASS);\n        }\n    }","id":45761,"modified_method":"public void updateConstantMetaClass(MetaClassRegistryChangeEvent cmcu) {\n        MetaClass oldMetaClass = cmcu.getOldMetaClass();\n        Class classToUpdate = cmcu.getClassToUpdate();\n        Object instanceToUpdate = cmcu.getInstance();\n        if (instanceToUpdate == null) {\n            updateMetaClassOfClass(oldMetaClass, classToUpdate);\n        } else {\n            updateMetaClassOfInstance(oldMetaClass, instanceToUpdate);\n        }\n    }","commit_id":"ffc7b16928f981479de2d6d034765973c2b664c5","url":"https://github.com/grails/grails-core"},{"original_method":"public void updateConstantMetaClass(MetaClassRegistryChangeEvent cmcu) {\n        MetaClass oldMetaClass = cmcu.getOldMetaClass();\n        Class classToUpdate = cmcu.getClassToUpdate();\n        if(oldMetaClass != null) {\n            Object current = alteredClasses.get(classToUpdate);\n            if(current == null || current == NO_CUSTOM_METACLASS) {\n                alteredClasses.put(classToUpdate, oldMetaClass);\n            }\n        }\n        else {\n            alteredClasses.put(classToUpdate, NO_CUSTOM_METACLASS);\n        }\n    }","id":45762,"modified_method":"public void updateConstantMetaClass(MetaClassRegistryChangeEvent cmcu) {\n        MetaClass oldMetaClass = cmcu.getOldMetaClass();\n        Class classToUpdate = cmcu.getClassToUpdate();\n        Object instanceToUpdate = cmcu.getInstance();\n        if (instanceToUpdate == null) {\n            updateMetaClassOfClass(oldMetaClass, classToUpdate);\n        } else {\n            updateMetaClassOfInstance(oldMetaClass, instanceToUpdate);\n        }\n    }","commit_id":"ae7273bfe5b3bf3a6f47d32d74d0382ad2f7c729","url":"https://github.com/grails/grails-core"},{"original_method":"public void clean() {\n        MetaClassRegistry registry = GroovySystem.getMetaClassRegistry();\n        Set<Class> classes = new HashSet<Class>(alteredClasses.keySet());\n        for (Class aClass : classes) {\n            Object alteredMetaClass = alteredClasses.get(aClass);\n            if(alteredMetaClass == NO_CUSTOM_METACLASS) {\n                registry.removeMetaClass(aClass);\n            }\n            else {\n                registry.setMetaClass(aClass, (MetaClass) alteredMetaClass);\n            }\n        }\n        alteredClasses.clear();\n    }","id":45763,"modified_method":"public void clean() {\n        MetaClassRegistryImpl registry = (MetaClassRegistryImpl) GroovySystem.getMetaClassRegistry();\n        cleanMetaClassOfClass(registry);\n        cleanMetaClassOfInstance(registry);\n    }","commit_id":"ae7273bfe5b3bf3a6f47d32d74d0382ad2f7c729","url":"https://github.com/grails/grails-core"},{"original_method":"public void applyChangeSet(ChangeSet changeSet) {\r\n        synchronized (this.registeredResources) {\r\n            this.listener.info(\"KnowledgeAgent applying ChangeSet\");\r\n\r\n            ChangeSetState changeSetState = new ChangeSetState();\r\n            changeSetState.scanDirectories = this.scanDirectories;\r\n            // incremental build is inverse of newInstance\r\n            changeSetState.incrementalBuild = !(this.newInstance);\r\n\r\n            // Process the new ChangeSet\r\n            processChangeSet(changeSet, changeSetState);\r\n            // Rebuild or do an update to the KnowledgeBase\r\n            buildKnowledgeBase(changeSetState);\r\n            // Rebuild the resource mapping\r\n            //buildResourceMapping();\r\n        }\r\n    }","id":45764,"modified_method":"public void applyChangeSet(ChangeSet changeSet) {\r\n        synchronized (this.registeredResources) {\r\n            this.eventSupport.fireBeforeChangeSetApplied(changeSet);\r\n\r\n            this.listener.info(\"KnowledgeAgent applying ChangeSet\");\r\n\r\n            ChangeSetState changeSetState = new ChangeSetState();\r\n            changeSetState.scanDirectories = this.scanDirectories;\r\n            // incremental build is inverse of newInstance\r\n            changeSetState.incrementalBuild = !(this.newInstance);\r\n\r\n            // Process the new ChangeSet\r\n            processChangeSet(changeSet, changeSetState);\r\n            // Rebuild or do an update to the KnowledgeBase\r\n            buildKnowledgeBase(changeSetState);\r\n            // Rebuild the resource mapping\r\n            //buildResourceMapping();\r\n\r\n            this.eventSupport.fireAfterChangeSetApplied(changeSet);\r\n        }\r\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Compiles the resource and returns the created package using the passed\r\n     * kbuilder. If kbuilder is null, a new instance of a Builder is used.\r\n     * Kbuilder is not used for resources that already are packages.\r\n     * @param resource the resource to compile.\r\n     * @param kbuilder the builder used to compile the resource. If the resource\r\n     * is already a package, this builder is not used.\r\n     * @return the package resulting of the compilation of resource.\r\n     */\r\n    private KnowledgePackageImp createPackageFromResource(Resource resource,KnowledgeBuilder kbuilder) {\r\n\r\n        if (kbuilder == null){\r\n            kbuilder = this.createKBuilder();\r\n        }\r\n\r\n        if (((InternalResource) resource).getResourceType() != ResourceType.PKG) {\r\n            kbuilder.add(resource, ((InternalResource) resource).getResourceType());\r\n            if (kbuilder.hasErrors()) {\r\n                this.listener.warning(\r\n                        \"KnowledgeAgent has KnowledgeBuilder errors \", kbuilder.getErrors());\r\n            }\r\n            if (kbuilder.getKnowledgePackages().iterator().hasNext()){\r\n                return (KnowledgePackageImp) kbuilder.getKnowledgePackages().iterator().next();\r\n            }\r\n            return null;\r\n        } else {\r\n            // .pks are handled as a special case.\r\n            InputStream is = null;\r\n            KnowledgePackageImp kpkg = null;\r\n            try {\r\n                is = resource.getInputStream();\r\n                Object object = DroolsStreamUtils.streamIn(is);\r\n                if (object instanceof KnowledgePackageImp) {\r\n                    kpkg = ((KnowledgePackageImp) object);\r\n                } else {\r\n                    kpkg = new KnowledgePackageImp((Package) object);\r\n                }\r\n                for (Rule rule : kpkg.pkg.getRules()) {\r\n                    rule.setResource(resource);\r\n                }\r\n\r\n            } catch (Exception ex) {\r\n                this.listener.exception(new RuntimeException(\"KnowledgeAgent exception while trying to deserialize KnowledgeDefinitionsPackage  \", ex));\r\n            } finally {\r\n                try {\r\n                    if (is != null) {\r\n                        is.close();\r\n                    }\r\n                } catch (IOException e) {\r\n                    this.listener.exception(new RuntimeException(\"KnowledgeAgent exception while trying to close KnowledgeDefinitionsPackage  \", e));\r\n                }\r\n            }\r\n            return kpkg;\r\n        }\r\n    }","id":45765,"modified_method":"/**\r\n     * Compiles the resource and returns the created package using the passed\r\n     * kbuilder. If kbuilder is null, a new instance of a Builder is used.\r\n     * Kbuilder is not used for resources that already are packages.\r\n     * @param resource the resource to compile.\r\n     * @param kbuilder the builder used to compile the resource. If the resource\r\n     * is already a package, this builder is not used.\r\n     * @return the package resulting of the compilation of resource.\r\n     */\r\n    private KnowledgePackageImp createPackageFromResource(Resource resource,KnowledgeBuilder kbuilder) {\r\n\r\n        if (kbuilder == null){\r\n            kbuilder = this.createKBuilder();\r\n        }\r\n\r\n        if (((InternalResource) resource).getResourceType() != ResourceType.PKG) {\r\n            kbuilder.add(resource, ((InternalResource) resource).getResourceType());\r\n            if (kbuilder.hasErrors()) {\r\n                this.eventSupport.fireResourceCompilationFailed(kbuilder, resource, ((InternalResource) resource).getResourceType());\r\n                this.listener.warning(\r\n                        \"KnowledgeAgent has KnowledgeBuilder errors \", kbuilder.getErrors());\r\n            }\r\n            if (kbuilder.getKnowledgePackages().iterator().hasNext()){\r\n                return (KnowledgePackageImp) kbuilder.getKnowledgePackages().iterator().next();\r\n            }\r\n            return null;\r\n        } else {\r\n            // .pks are handled as a special case.\r\n            InputStream is = null;\r\n            KnowledgePackageImp kpkg = null;\r\n            try {\r\n                is = resource.getInputStream();\r\n                Object object = DroolsStreamUtils.streamIn(is);\r\n                if (object instanceof KnowledgePackageImp) {\r\n                    kpkg = ((KnowledgePackageImp) object);\r\n                } else {\r\n                    kpkg = new KnowledgePackageImp((Package) object);\r\n                }\r\n                for (Rule rule : kpkg.pkg.getRules()) {\r\n                    rule.setResource(resource);\r\n                }\r\n\r\n            } catch (Exception ex) {\r\n                this.listener.exception(new RuntimeException(\"KnowledgeAgent exception while trying to deserialize KnowledgeDefinitionsPackage  \", ex));\r\n            } finally {\r\n                try {\r\n                    if (is != null) {\r\n                        is.close();\r\n                    }\r\n                } catch (IOException e) {\r\n                    this.listener.exception(new RuntimeException(\"KnowledgeAgent exception while trying to close KnowledgeDefinitionsPackage  \", e));\r\n                }\r\n            }\r\n            return kpkg;\r\n        }\r\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Rebuilds and creates a new KnowledgeBase for this KnowledgeAgent when\r\n     * called based on the ChangeSet that comes in and if newInstance is set to\r\n     * true. If incremental building or KnowledgeBase updates is on, then this\r\n     * will attempt to update the KnowledgeBase instead.\r\n     *\r\n     * @param changeSetState\r\n     *            The state that the ChangeSet performed\r\n     */\r\n    public void buildKnowledgeBase(ChangeSetState changeSetState) {\r\n        this.listener.debug(\"KnowledgeAgent rebuilding KnowledgeBase using ChangeSet\");\r\n        synchronized (this.registeredResources) {\r\n\r\n            /*\r\n             * Do the following only if we are building a new instance,\r\n             * otherwise, do an incremental build/update\r\n             */\r\n            if (this.newInstance) {\r\n                rebuildResources(changeSetState);\r\n            } else {\r\n                incrementalBuildResources(changeSetState);\r\n            }\r\n\r\n            /*\r\n             * If the ruleBase is sequential, after rebuilding or incremental\r\n             * update, do an ordering of the ReteooBuilder\r\n             */\r\n            InternalRuleBase ruleBase = (InternalRuleBase) ((KnowledgeBaseImpl) this.kbase).ruleBase;\r\n            synchronized (ruleBase.getPackagesMap()) {\r\n                if (ruleBase.getConfiguration().isSequential()) {\r\n                    ruleBase.getReteooBuilder().order();\r\n                }\r\n            }\r\n        }\r\n        this.listener.debug(\"KnowledgeAgent finished rebuilding KnowledgeBase using ChangeSet\");\r\n    }","id":45766,"modified_method":"/**\r\n     * Rebuilds and creates a new KnowledgeBase for this KnowledgeAgent when\r\n     * called based on the ChangeSet that comes in and if newInstance is set to\r\n     * true. If incremental building or KnowledgeBase updates is on, then this\r\n     * will attempt to update the KnowledgeBase instead.\r\n     *\r\n     * @param changeSetState\r\n     *            The state that the ChangeSet performed\r\n     */\r\n    public void buildKnowledgeBase(ChangeSetState changeSetState) {\r\n        this.listener.debug(\"KnowledgeAgent rebuilding KnowledgeBase using ChangeSet\");\r\n        synchronized (this.registeredResources) {\r\n\r\n            /*\r\n             * Do the following only if we are building a new instance,\r\n             * otherwise, do an incremental build/update\r\n             */\r\n            if (this.newInstance) {\r\n                rebuildResources(changeSetState);\r\n            } else {\r\n                incrementalBuildResources(changeSetState);\r\n            }\r\n\r\n            /*\r\n             * If the ruleBase is sequential, after rebuilding or incremental\r\n             * update, do an ordering of the ReteooBuilder\r\n             */\r\n            InternalRuleBase ruleBase = (InternalRuleBase) ((KnowledgeBaseImpl) this.kbase).ruleBase;\r\n            synchronized (ruleBase.getPackagesMap()) {\r\n                if (ruleBase.getConfiguration().isSequential()) {\r\n                    ruleBase.getReteooBuilder().order();\r\n                }\r\n            }\r\n        }\r\n        this.eventSupport.fireKnowledgeBaseUpdated(this.kbase);\r\n        this.listener.debug(\"KnowledgeAgent finished rebuilding KnowledgeBase using ChangeSet\");\r\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private KnowledgeBuilder createKBuilder(){\r\n        if (this.builderConfiguration != null){\r\n            return KnowledgeBuilderFactory.newKnowledgeBuilder(this.builderConfiguration);\r\n        }\r\n\r\n        if (this.useKBaseClassLoaderForCompiling){\r\n            return  KnowledgeBuilderFactory.newKnowledgeBuilder(KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(null, ((ReteooRuleBase)((KnowledgeBaseImpl)this.getKnowledgeBase()).getRuleBase()).getRootClassLoader()));\r\n        }\r\n\r\n        return KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n\r\n    }","id":45767,"modified_method":"private KnowledgeBuilder createKBuilder(){\r\n        KnowledgeBuilder kbuilder = null;\r\n        if (this.builderConfiguration != null){\r\n            kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(this.builderConfiguration);\r\n        }else if (this.useKBaseClassLoaderForCompiling){\r\n            kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(null, ((ReteooRuleBase)((KnowledgeBaseImpl)this.getKnowledgeBase()).getRuleBase()).getRootClassLoader()));\r\n        }else{\r\n            kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        }\r\n\r\n        if (this.dslResources != null){\r\n            for (Map.Entry<Resource, String> entry : this.dslResources.entrySet()) {\r\n                kbuilder.add(ResourceFactory.newByteArrayResource(entry.getValue().getBytes()), ResourceType.DSL);\r\n            }\r\n        }\r\n\r\n        return kbuilder;\r\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Adds the resources to the current KnowledgeBase on this KnowledgeAgent.\r\n     * This method processes {@link ChangeSetState#addedResources} and\r\n     * {@link ChangeSetState#createdPackages} lists in two different ways:\r\n     * <ul>\r\n     * <li>\r\n     * The elments of {@link ChangeSetState#addedResources} are compiled using\r\n     * {@link #createPackageFromResource(org.drools.io.Resource, org.drools.builder.KnowledgeBuilder)}\r\n     * and added to {@link ChangeSetState#createdPackages}. The same kbuilder\r\n     * is used for all the elements.\r\n     * <\/li>\r\n     * <li>\r\n     * The elments of {@link ChangeSetState#createdPackages} are added to\r\n     * {@link #kbase}. Each package is mapped to the original resource\r\n     * using {@link #buildResourceMapping(org.drools.rule.Package, org.drools.io.Resource)}.\r\n     * <\/li>\r\n     * <\/ul>\r\n     *\r\n     *\r\n     * @param changeSetState the object containing the added resources list and\r\n     * created pacages list.\r\n     */\r\n    private void addResourcesToKnowledgeBase(ChangeSetState changeSetState) {\r\n\r\n        KnowledgeBuilder kbuilder = this.createKBuilder();\r\n        List<Package> packages = new ArrayList<Package>();\r\n\r\n\r\n        for (Resource resource : changeSetState.addedResources) {\r\n            KnowledgePackageImp createdPackage = this.createPackageFromResource(resource, kbuilder);\r\n            changeSetState.createdPackages.put(resource, createdPackage);\r\n        }\r\n\r\n\r\n        for (Map.Entry<Resource, KnowledgePackage> entry : changeSetState.createdPackages.entrySet()) {\r\n            // For PKG (.pks) just add them\r\n            Resource resource = entry.getKey();\r\n            this.listener.debug(\"KnowledgeAgent obtaining pkg resource=\"\r\n                    + resource);\r\n\r\n            try {\r\n                Package pkg = ((KnowledgePackageImp) entry.getValue()).pkg;\r\n                for (Rule rule : pkg.getRules()) {\r\n                    rule.setResource(resource);\r\n                }\r\n                packages.add(pkg);\r\n\r\n                this.buildResourceMapping(pkg, resource);\r\n            } catch (Exception e) {\r\n                this.listener.exception(new RuntimeException(\r\n                        \"KnowledgeAgent exception while trying to deserialize KnowledgeDefinitionsPackage  \",\r\n                        e));\r\n            }\r\n        }\r\n\r\n        if (kbuilder\r\n                != null) {\r\n            // Log any errors we come across\r\n            if (kbuilder.hasErrors()) {\r\n                this.listener.warning(\r\n                        \"KnowledgeAgent has KnowledgeBuilder errors \", kbuilder.getErrors());\r\n            }\r\n            this.listener.debug(\"KnowledgeAgent adding KnowledgePackages from KnowledgeBuilder\");\r\n            this.kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());\r\n        }\r\n        /*\r\n         * Add all the packages we found, but did not build, from the resources\r\n         * now\r\n         */\r\n        for (Package pkg : packages) {\r\n            this.listener.debug(\"KnowledgeAgent adding KnowledgeDefinitionsPackage \"\r\n                    + pkg.getName());\r\n            ((KnowledgeBaseImpl) this.kbase).ruleBase.addPackage(pkg);\r\n        }\r\n    }","id":45768,"modified_method":"/**\r\n     * Adds the resources to the current KnowledgeBase on this KnowledgeAgent.\r\n     * This method processes {@link ChangeSetState#addedResources} and\r\n     * {@link ChangeSetState#createdPackages} lists in two different ways:\r\n     * <ul>\r\n     * <li>\r\n     * The elments of {@link ChangeSetState#addedResources} are compiled using\r\n     * {@link #createPackageFromResource(org.drools.io.Resource, org.drools.builder.KnowledgeBuilder)}\r\n     * and added to {@link ChangeSetState#createdPackages}. The same kbuilder\r\n     * is used for all the elements.\r\n     * <\/li>\r\n     * <li>\r\n     * The elments of {@link ChangeSetState#createdPackages} are added to\r\n     * {@link #kbase}. Each package is mapped to the original resource\r\n     * using {@link #buildResourceMapping(org.drools.rule.Package, org.drools.io.Resource)}.\r\n     * <\/li>\r\n     * <\/ul>\r\n     *\r\n     *\r\n     * @param changeSetState the object containing the added resources list and\r\n     * created pacages list.\r\n     */\r\n    private void addResourcesToKnowledgeBase(ChangeSetState changeSetState) {\r\n\r\n        KnowledgeBuilder kbuilder = this.createKBuilder();\r\n        List<Package> packages = new ArrayList<Package>();\r\n\r\n\r\n        for (Resource resource : changeSetState.addedResources) {\r\n            KnowledgePackageImp createdPackage = this.createPackageFromResource(resource, kbuilder);\r\n            changeSetState.createdPackages.put(resource, createdPackage);\r\n        }\r\n\r\n        //createPackageFromResource already log this\r\n//        if (kbuilder.hasErrors()) {\r\n//            this.listener.warning(\r\n//                    \"KnowledgeAgent has KnowledgeBuilder errors \", kbuilder.getErrors());\r\n//        }\r\n\r\n        for (Map.Entry<Resource, KnowledgePackage> entry : changeSetState.createdPackages.entrySet()) {\r\n            // For PKG (.pks) just add them\r\n            Resource resource = entry.getKey();\r\n            this.listener.debug(\"KnowledgeAgent obtaining pkg resource=\"\r\n                    + resource);\r\n\r\n            try {\r\n                Package pkg = ((KnowledgePackageImp) entry.getValue()).pkg;\r\n                for (Rule rule : pkg.getRules()) {\r\n                    rule.setResource(resource);\r\n                }\r\n                packages.add(pkg);\r\n\r\n                this.buildResourceMapping(pkg, resource);\r\n            } catch (Exception e) {\r\n                this.listener.exception(new RuntimeException(\r\n                        \"KnowledgeAgent exception while trying to deserialize KnowledgeDefinitionsPackage  \",\r\n                        e));\r\n            }\r\n        }\r\n\r\n//        if (kbuilder\r\n//                != null) {\r\n//            // Log any errors we come across\r\n//            if (kbuilder.hasErrors()) {\r\n//                this.listener.warning(\r\n//                        \"KnowledgeAgent has KnowledgeBuilder errors \", kbuilder.getErrors());\r\n//            }\r\n//            this.listener.debug(\"KnowledgeAgent adding KnowledgePackages from KnowledgeBuilder\");\r\n//            this.kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());\r\n//        }\r\n        /*\r\n         * Add all the packages we found, but did not build, from the resources\r\n         * now\r\n         */\r\n        for (Package pkg : packages) {\r\n            this.listener.debug(\"KnowledgeAgent adding KnowledgeDefinitionsPackage \"\r\n                    + pkg.getName());\r\n            ((KnowledgeBaseImpl) this.kbase).ruleBase.addPackage(pkg);\r\n        }\r\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Processes a changeSet.\r\n     * If {@link ChangeSetState#incrementalBuild} is set to true, this method\r\n     * fill the lists and Maps of <code>changeSetState<\/code>.\r\n     * \r\n     * @param changeSet\r\n     * @param changeSetState\r\n     */\r\n    public void processChangeSet(ChangeSet changeSet,\r\n            ChangeSetState changeSetState) {\r\n        synchronized (this.registeredResources) {\r\n            /*\r\n             * Process the added resources from a ChangeSet by subscribing to\r\n             * the notifier and inserting a new ResourceMapping.\r\n             */\r\n            for (Resource resource : changeSet.getResourcesAdded()) {\r\n                if (((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET) {\r\n                    // @TODO We should not ignore an added change set\r\n                    this.listener.debug(\"KnowledgeAgent processing sub ChangeSet=\"\r\n                            + resource);\r\n                    processChangeSet(resource, changeSetState);\r\n                } else if (((InternalResource) resource).isDirectory()) {\r\n                    this.resourceDirectories.add(resource);\r\n                    this.listener.debug(\"KnowledgeAgent subscribing to directory=\"\r\n                            + resource);\r\n                    this.notifier.subscribeResourceChangeListener(this,\r\n                            resource);\r\n                    // if it's a dir, subscribe it's children first\r\n                    for (Resource child : ((InternalResource) resource).listResources()) {\r\n\r\n                        // ignore sub directories\r\n                        if (((InternalResource) child).isDirectory()) {\r\n                            continue;\r\n                        }\r\n\r\n                        ((InternalResource) child).setResourceType(((InternalResource) resource).getResourceType());\r\n\r\n                        this.addDefinitionMapping(child, null, true);\r\n                        if (this.addResourceMapping(child, true)\r\n                                && changeSetState.incrementalBuild) {\r\n                            changeSetState.addedResources.add(child);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.addResourceMapping(resource, true)\r\n                            && changeSetState.incrementalBuild) {\r\n                        changeSetState.addedResources.add(resource);\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            /*\r\n             * For those marked as removed by the ChangeSet, remove their\r\n             * mappings, index them if we are doing incremental builds so the\r\n             * incremental building process knows what to remove.\r\n             */\r\n            for (Resource resource : changeSet.getResourcesRemoved()) {\r\n                if (((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET) {\r\n                    // @TODO Is this true? Shouldn't we just ignore it in\r\n                    // removed?\r\n                    processChangeSet(resource, changeSetState);\r\n                } else if (changeSetState.scanDirectories\r\n                        && ((InternalResource) resource).isDirectory()) {\r\n                    this.listener.debug(\"KnowledgeAgent unsubscribing from directory resource=\"\r\n                            + resource);\r\n                    this.resourceDirectories.remove(resource);\r\n                    this.notifier.unsubscribeResourceChangeListener(this,\r\n                            resource);\r\n                } else {\r\n\r\n                    Set<KnowledgeDefinition> definitions = this.removeResourceMapping(resource, true);\r\n\r\n                    if (definitions != null && changeSetState.incrementalBuild) {\r\n                        changeSetState.removedResourceMappings.put(resource, definitions);\r\n                    }\r\n                }\r\n            }\r\n\r\n            /*\r\n             * For those marked as modified, remove their ResourceMapping,\r\n             * attach it to the ChangeSetState, and add a new one - it will be\r\n             * repopulated with the KnowledgeDefinitions later after rebuilding.\r\n             * Process any modified ChangeSets - treat them as if they were new.\r\n             */\r\n            for (Resource resource : changeSet.getResourcesModified()) {\r\n                if (((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET) {\r\n                    // processChangeSet(resource, changeSetState);\r\n                    continue;\r\n                } else if (((InternalResource) resource).isDirectory()) {\r\n                    if (this.resourceDirectories.add(resource)) {\r\n                        this.listener.warning(\"KnowledgeAgent is subscribing to a modified directory=\"\r\n                                + resource\r\n                                + \" when it should have already been subscribed\");\r\n                        this.notifier.subscribeResourceChangeListener(this,\r\n                                resource);\r\n                    }\r\n                    // if it's a dir, subscribe it's children first\r\n                    for (Resource child : ((InternalResource) resource).listResources()) {\r\n\r\n                        // ignore sub directories\r\n                        if (((InternalResource) child).isDirectory()) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (this.addResourceMapping(child, true)) {\r\n                            ((InternalResource) child).setResourceType(((InternalResource) resource).getResourceType());\r\n                            if (changeSetState.incrementalBuild) {\r\n                                changeSetState.addedResources.add(child);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n\r\n                    boolean isResourceMapped = this.registeredResources.isResourceMapped(resource);\r\n\r\n                    if (!isResourceMapped) {\r\n                        this.listener.warning(\"KnowledgeAgent subscribing to new resource=\"\r\n                                + resource\r\n                                + \", though it was marked as modified.\");\r\n                        this.addResourceMapping(resource, true);\r\n                        if (changeSetState.incrementalBuild) {\r\n                            changeSetState.addedResources.add(resource);\r\n                        }\r\n                    } else {\r\n                        if (changeSetState.incrementalBuild) {\r\n\r\n                            Set<KnowledgeDefinition> definitions = this.removeResourceMapping(resource, true);\r\n\r\n                            changeSetState.modifiedResourceMappings.put(resource, definitions);\r\n\r\n                            //adds a new empty mapping that will be filled in buildKnowledgeBase()\r\n                            this.addResourceMapping(resource, false);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }","id":45769,"modified_method":"/**\r\n     * Processes a changeSet.\r\n     * If {@link ChangeSetState#incrementalBuild} is set to true, this method\r\n     * fill the lists and Maps of <code>changeSetState<\/code>.\r\n     * \r\n     * @param changeSet\r\n     * @param changeSetState\r\n     */\r\n    public void processChangeSet(ChangeSet changeSet,\r\n            ChangeSetState changeSetState) {\r\n        synchronized (this.registeredResources) {\r\n            this.eventSupport.fireBeforeChangeSetProcessed(changeSet);\r\n\r\n            /*\r\n             * Process the added resources from a ChangeSet by subscribing to\r\n             * the notifier and inserting a new ResourceMapping.\r\n             */\r\n            for (Resource resource : changeSet.getResourcesAdded()) {\r\n                this.eventSupport.fireBeforeResourceProcessed(changeSet, resource, ((InternalResource) resource).getResourceType(), ResourceStatus.RESOURCE_ADDED);\r\n                if (((InternalResource) resource).getResourceType() == ResourceType.DSL){\r\n                    this.notifier.subscribeResourceChangeListener(this,\r\n                            resource);\r\n                    try {\r\n                        this.retrieveDSLResource(resource);\r\n                    } catch (IOException ex) {\r\n                        this.listener.exception(\"KnowledgeAgent Fails trying to read DSL Resource: \"\r\n                            + resource,ex);\r\n                    }\r\n                } else if (((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET) {\r\n                    // @TODO We should not ignore an added change set\r\n                    this.listener.debug(\"KnowledgeAgent processing sub ChangeSet=\"\r\n                            + resource);\r\n                    processChangeSet(resource, changeSetState);\r\n                } else if (((InternalResource) resource).isDirectory()) {\r\n                    this.resourceDirectories.add(resource);\r\n                    this.listener.debug(\"KnowledgeAgent subscribing to directory=\"\r\n                            + resource);\r\n                    this.notifier.subscribeResourceChangeListener(this,\r\n                            resource);\r\n                    // if it's a dir, subscribe it's children first\r\n                    for (Resource child : ((InternalResource) resource).listResources()) {\r\n\r\n                        // ignore sub directories\r\n                        if (((InternalResource) child).isDirectory()) {\r\n                            continue;\r\n                        }\r\n\r\n                        ((InternalResource) child).setResourceType(((InternalResource) resource).getResourceType());\r\n\r\n                        this.addDefinitionMapping(child, null, true);\r\n                        if (this.addResourceMapping(child, true)\r\n                                && changeSetState.incrementalBuild) {\r\n                            changeSetState.addedResources.add(child);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.addResourceMapping(resource, true)\r\n                            && changeSetState.incrementalBuild) {\r\n                        changeSetState.addedResources.add(resource);\r\n\r\n                    }\r\n                }\r\n                this.eventSupport.fireAfterResourceProcessed(changeSet, resource, ((InternalResource) resource).getResourceType(), ResourceStatus.RESOURCE_ADDED);\r\n            }\r\n\r\n            /*\r\n             * For those marked as removed by the ChangeSet, remove their\r\n             * mappings, index them if we are doing incremental builds so the\r\n             * incremental building process knows what to remove.\r\n             */\r\n            for (Resource resource : changeSet.getResourcesRemoved()) {\r\n                this.eventSupport.fireBeforeResourceProcessed(changeSet, resource, ((InternalResource) resource).getResourceType(), ResourceStatus.RESOURCE_MODIFIED);\r\n                if (((InternalResource) resource).getResourceType() == ResourceType.DSL){\r\n                    this.notifier.unsubscribeResourceChangeListener(this,\r\n                            resource);\r\n                    this.dslResources.remove(resource);\r\n                } else if (((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET) {\r\n                    // @TODO Is this true? Shouldn't we just ignore it in\r\n                    // removed?\r\n                    processChangeSet(resource, changeSetState);\r\n                } else if (changeSetState.scanDirectories\r\n                        && ((InternalResource) resource).isDirectory()) {\r\n                    this.listener.debug(\"KnowledgeAgent unsubscribing from directory resource=\"\r\n                            + resource);\r\n                    this.resourceDirectories.remove(resource);\r\n                    this.notifier.unsubscribeResourceChangeListener(this,\r\n                            resource);\r\n                } else {\r\n\r\n                    Set<KnowledgeDefinition> definitions = this.removeResourceMapping(resource, true);\r\n\r\n                    if (definitions != null && changeSetState.incrementalBuild) {\r\n                        changeSetState.removedResourceMappings.put(resource, definitions);\r\n                    }\r\n                }\r\n                this.eventSupport.fireAfterResourceProcessed(changeSet, resource, ((InternalResource) resource).getResourceType(), ResourceStatus.RESOURCE_MODIFIED);\r\n            }\r\n\r\n            /*\r\n             * For those marked as modified, remove their ResourceMapping,\r\n             * attach it to the ChangeSetState, and add a new one - it will be\r\n             * repopulated with the KnowledgeDefinitions later after rebuilding.\r\n             * Process any modified ChangeSets - treat them as if they were new.\r\n             */\r\n            for (Resource resource : changeSet.getResourcesModified()) {\r\n                this.eventSupport.fireBeforeResourceProcessed(changeSet, resource, ((InternalResource) resource).getResourceType(), ResourceStatus.RESOURCE_REMOVED);\r\n                if (((InternalResource) resource).getResourceType() == ResourceType.DSL){\r\n                    try {\r\n                        this.retrieveDSLResource(resource);\r\n                    } catch (IOException ex) {\r\n                        this.listener.exception(\"KnowledgeAgent Fails trying to read DSL Resource: \"\r\n                            + resource,ex);\r\n                    }\r\n                } else if (((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET) {\r\n                    // processChangeSet(resource, changeSetState);\r\n                    continue;\r\n                } else if (((InternalResource) resource).isDirectory()) {\r\n                    if (this.resourceDirectories.add(resource)) {\r\n                        this.listener.warning(\"KnowledgeAgent is subscribing to a modified directory=\"\r\n                                + resource\r\n                                + \" when it should have already been subscribed\");\r\n                        this.notifier.subscribeResourceChangeListener(this,\r\n                                resource);\r\n                    }\r\n                    // if it's a dir, subscribe it's children first\r\n                    for (Resource child : ((InternalResource) resource).listResources()) {\r\n\r\n                        // ignore sub directories\r\n                        if (((InternalResource) child).isDirectory()) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (this.addResourceMapping(child, true)) {\r\n                            ((InternalResource) child).setResourceType(((InternalResource) resource).getResourceType());\r\n                            if (changeSetState.incrementalBuild) {\r\n                                changeSetState.addedResources.add(child);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n\r\n                    boolean isResourceMapped = this.registeredResources.isResourceMapped(resource);\r\n\r\n                    if (!isResourceMapped) {\r\n                        this.listener.warning(\"KnowledgeAgent subscribing to new resource=\"\r\n                                + resource\r\n                                + \", though it was marked as modified.\");\r\n                        this.addResourceMapping(resource, true);\r\n                        if (changeSetState.incrementalBuild) {\r\n                            changeSetState.addedResources.add(resource);\r\n                        }\r\n                    } else {\r\n                        if (changeSetState.incrementalBuild) {\r\n\r\n                            Set<KnowledgeDefinition> definitions = this.removeResourceMapping(resource, true);\r\n\r\n                            changeSetState.modifiedResourceMappings.put(resource, definitions);\r\n\r\n                            //adds a new empty mapping that will be filled in buildKnowledgeBase()\r\n                            this.addResourceMapping(resource, false);\r\n                        }\r\n                    }\r\n                }\r\n                this.eventSupport.fireAfterResourceProcessed(changeSet, resource, ((InternalResource) resource).getResourceType(), ResourceStatus.RESOURCE_REMOVED);\r\n            }\r\n\r\n            this.eventSupport.fireAfterChangeSetProcessed(changeSet, changeSetState.addedResources, changeSetState.modifiedResourceMappings, changeSetState.removedResourceMappings);\r\n        }\r\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        fileManager = new FileManager();\n        fileManager.setUp();\n        ((ResourceChangeScannerImpl) ResourceFactory.getResourceChangeScannerService()).reset();\n        ResourceFactory.getResourceChangeNotifierService().start();\n        ResourceFactory.getResourceChangeScannerService().start();\n\n        this.server = new Server(0);\n        ResourceHandler resourceHandler = new ResourceHandler();\n        resourceHandler.setResourceBase(fileManager.getRootDirectory().getPath());\n        System.out.println(\"root : \" + fileManager.getRootDirectory().getPath());\n\n        server.setHandler(resourceHandler);\n\n        server.start();\n    }","id":45770,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        fileManager = new FileManager();\n        fileManager.setUp();\n        ((ResourceChangeScannerImpl) ResourceFactory.getResourceChangeScannerService()).reset();\n        ResourceFactory.getResourceChangeNotifierService().start();\n        ResourceFactory.getResourceChangeScannerService().start();\n\n        this.server = new Server(0);\n        ResourceHandler resourceHandler = new ResourceHandler();\n        resourceHandler.setResourceBase(fileManager.getRootDirectory().getPath());\n\n        server.setHandler(resourceHandler);\n\n        server.start();\n    }","commit_id":"a750755ab619697e0c7333b509d9951d1c5170f2","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n  protected InspectionToolsConfigurable createConfigurable(InspectionProjectProfileManager projectProfileManager,\n                                                           InspectionProfileManager profileManager,\n                                                           JComboBox profilesCombo) {\n    return new ExternalProfilesComboboxAwareInspectionToolsConfigurable(projectProfileManager, profileManager, profilesCombo) {\n      @Override\n      protected boolean acceptTool(InspectionToolWrapper entry) {\n        return super.acceptTool(entry) && entry.isCleanupTool();\n      }\n\n      @Override\n      public String getDisplayName() {\n        return CODE_CLEANUP_INSPECTIONS_DISPLAY_NAME;\n      }\n    };\n  }","id":45771,"modified_method":"@Override\n  protected InspectionToolsConfigurable createConfigurable(InspectionProjectProfileManager projectProfileManager,\n                                                           InspectionProfileManager profileManager,\n                                                           ProfilesComboBox profilesCombo) {\n    return new ExternalProfilesComboboxAwareInspectionToolsConfigurable(projectProfileManager, profileManager, profilesCombo) {\n      @Override\n      protected boolean acceptTool(InspectionToolWrapper entry) {\n        return super.acceptTool(entry) && entry.isCleanupTool();\n      }\n\n      @Override\n      public String getDisplayName() {\n        return CODE_CLEANUP_INSPECTIONS_DISPLAY_NAME;\n      }\n    };\n  }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected InspectionToolsConfigurable createConfigurable(InspectionProjectProfileManager projectProfileManager,\n                                                           InspectionProfileManager profileManager,\n                                                           final JComboBox profilesCombo) {\n    return new ExternalProfilesComboboxAwareInspectionToolsConfigurable(projectProfileManager, profileManager, profilesCombo);\n  }","id":45772,"modified_method":"protected InspectionToolsConfigurable createConfigurable(InspectionProjectProfileManager projectProfileManager,\n                                                           InspectionProfileManager profileManager,\n                                                           final ProfilesComboBox profilesCombo) {\n    return new ExternalProfilesComboboxAwareInspectionToolsConfigurable(projectProfileManager, profileManager, profilesCombo);\n  }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExternalProfilesComboboxAwareInspectionToolsConfigurable(@NotNull InspectionProjectProfileManager projectProfileManager,\n                                                                    InspectionProfileManager profileManager,\n                                                                    JComboBox profilesCombo) {\n      super(projectProfileManager, profileManager);\n      myProfilesCombo = profilesCombo;\n    }","id":45773,"modified_method":"public ExternalProfilesComboboxAwareInspectionToolsConfigurable(@NotNull InspectionProjectProfileManager projectProfileManager,\n                                                                    InspectionProfileManager profileManager,\n                                                                    ProfilesComboBox profilesCombo) {\n      super(projectProfileManager, profileManager);\n      myProfilesCombo = profilesCombo;\n    }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void addProfile(InspectionProfileImpl model, InspectionProfileImpl profile) {\n      super.addProfile(model, profile);\n      ((DefaultComboBoxModel)myProfilesCombo.getModel()).addElement(model);\n    }","id":45774,"modified_method":"@Override\n    protected void addProfile(InspectionProfileImpl model, InspectionProfileImpl profile) {\n      super.addProfile(model, profile);\n      myProfilesCombo.addProfile(profile);\n    }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected JComponent getAdditionalActionSettings(@NotNull final Project project, final BaseAnalysisActionDialog dialog) {\n    final AdditionalPanel panel = new AdditionalPanel();\n    final InspectionManagerEx manager = (InspectionManagerEx)InspectionManager.getInstance(project);\n    final JComboBox profiles = panel.myBrowseProfilesCombo.getComboBox();\n    profiles.setRenderer(new ListCellRendererWrapper() {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof Profile) {\n          Profile profile = (Profile)value;\n          setText(profile.getName());\n          setIcon(profile.isProjectLevel() ? AllIcons.General.ProjectSettings : AllIcons.General.Settings);\n        }\n      }\n    });\n    final InspectionProfileManager profileManager = InspectionProfileManager.getInstance();\n    final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n    reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n    panel.myBrowseProfilesCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final InspectionToolsConfigurable errorConfigurable = createConfigurable(projectProfileManager, profileManager, profiles);\n        final MySingleConfigurableEditor editor = new MySingleConfigurableEditor(project, errorConfigurable, manager);\n        if (editor.showAndGet()) {\n          reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n        }\n        else {\n          //if profile was disabled and cancel after apply was pressed\n          final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n          final boolean canExecute = profile != null && profile.isExecutable(project);\n          dialog.setOKActionEnabled(canExecute);\n        }\n      }\n    });\n    profiles.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myExternalProfile = (InspectionProfile)profiles.getSelectedItem();\n        final boolean canExecute = myExternalProfile != null && myExternalProfile.isExecutable(project);\n        dialog.setOKActionEnabled(canExecute);\n        if (canExecute) {\n          manager.setProfile(myExternalProfile.getName());\n        }\n      }\n    });\n    final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n    dialog.setOKActionEnabled(profile != null && profile.isExecutable(project));\n    return panel.myAdditionalPanel;\n  }","id":45775,"modified_method":"@Override\n  protected JComponent getAdditionalActionSettings(@NotNull final Project project, final BaseAnalysisActionDialog dialog) {\n    final AdditionalPanel panel = new AdditionalPanel();\n    final InspectionManagerEx manager = (InspectionManagerEx)InspectionManager.getInstance(project);\n    final ProfilesComboBox profiles = (ProfilesComboBox)panel.myBrowseProfilesCombo.getComboBox();\n    final InspectionProfileManager profileManager = InspectionProfileManager.getInstance();\n    final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n    reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n    panel.myBrowseProfilesCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final InspectionToolsConfigurable errorConfigurable = createConfigurable(projectProfileManager, profileManager, profiles);\n        final MySingleConfigurableEditor editor = new MySingleConfigurableEditor(project, errorConfigurable, manager);\n        if (editor.showAndGet()) {\n          reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n        }\n        else {\n          //if profile was disabled and cancel after apply was pressed\n          final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n          final boolean canExecute = profile != null && profile.isExecutable(project);\n          dialog.setOKActionEnabled(canExecute);\n        }\n      }\n    });\n    profiles.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myExternalProfile = (InspectionProfile)profiles.getSelectedItem();\n        final boolean canExecute = myExternalProfile != null && myExternalProfile.isExecutable(project);\n        dialog.setOKActionEnabled(canExecute);\n        if (canExecute) {\n          manager.setProfile(myExternalProfile.getName());\n        }\n      }\n    });\n    final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n    dialog.setOKActionEnabled(profile != null && profile.isExecutable(project));\n    return panel.myAdditionalPanel;\n  }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void applyRootProfile(@NotNull String name, boolean isProjectLevel) {\n      for (int i = 0; i < myProfilesCombo.getItemCount(); i++) {\n        final InspectionProfileImpl profile = (InspectionProfileImpl)myProfilesCombo.getItemAt(i);\n        if (name.equals(profile.getName())) {\n          myProfilesCombo.setSelectedIndex(i);\n          break;\n        }\n      }\n    }","id":45776,"modified_method":"@Override\n    protected void applyRootProfile(@NotNull String name, boolean isProjectLevel) {\n      for (int i = 0; i < myProfilesCombo.getItemCount(); i++) {\n        final InspectionProfileImpl profile = myProfilesCombo.getItemAt(i);\n        if (name.equals(profile.getName())) {\n          myProfilesCombo.setSelectedIndex(i);\n          break;\n        }\n      }\n    }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reloadProfiles(JComboBox profiles,\n                              InspectionProfileManager inspectionProfileManager,\n                              InspectionProjectProfileManager inspectionProjectProfileManager,\n                              InspectionManagerEx inspectionManager) {\n    final InspectionProfile selectedProfile = getGlobalInspectionContext(inspectionManager.getProject()).getCurrentProfile();\n    final DefaultComboBoxModel model = (DefaultComboBoxModel)profiles.getModel();\n    model.removeAllElements();\n    fillModel(inspectionProfileManager, model);\n    fillModel(inspectionProjectProfileManager, model);\n    profiles.setSelectedItem(selectedProfile);\n  }","id":45777,"modified_method":"private void reloadProfiles(ProfilesComboBox profilesCombo,\n                              InspectionProfileManager inspectionProfileManager,\n                              InspectionProjectProfileManager inspectionProjectProfileManager,\n                              InspectionManagerEx inspectionManager) {\n    final InspectionProfile selectedProfile = getGlobalInspectionContext(inspectionManager.getProject()).getCurrentProfile();\n    List<Profile> profiles = new ArrayList<>();\n    profiles.addAll(inspectionProfileManager.getProfiles());\n    profiles.addAll(inspectionProjectProfileManager.getProfiles());\n    profilesCombo.reset(profiles);\n    profilesCombo.selectProfile((InspectionProfileImpl)selectedProfile);\n  }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void addProfile(InspectionProfileImpl inspectionProfile) {\n    myComboModel.add(inspectionProfile);\n    if (!isProjectLevel(inspectionProfile)) {\n      findFirstGlobalProfile();\n    }\n  }","id":45778,"modified_method":"public void addProfile(InspectionProfileImpl inspectionProfile) {\n    myComboModel.add(inspectionProfile);\n    if (!isProjectLevel(inspectionProfile)) {\n      findFirstGlobalProfile();\n    }\n  }","commit_id":"8ede59c32955a58adcd3f6a3ab71f3863868c134","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    restoreFactory(item);\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if (myComboBox.getItemCount() == 0 || !equalLight(item, (TextWithImports)myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n  }","id":45779,"modified_method":"public void setText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    restoreFactory(item);\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if (myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n  }","commit_id":"c0a8db233b14ec982c74b2d7d5d73cd3ccd8aa48","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object object) {\n    if(!(object instanceof TextWithImportsImpl)) {\n      return false;\n    }\n    TextWithImportsImpl item = ((TextWithImportsImpl)object);\n    return Comparing.equal(item.myText, myText) && Comparing.equal(item.myImports, myImports) && Comparing.equal(item.myFileType, myFileType);\n  }","id":45780,"modified_method":"public boolean equals(Object object) {\n    if(!(object instanceof TextWithImportsImpl)) {\n      return false;\n    }\n    TextWithImportsImpl item = ((TextWithImportsImpl)object);\n    return Comparing.equal(item.myText, myText) && Comparing.equal(item.myImports, myImports);\n  }","commit_id":"c0a8db233b14ec982c74b2d7d5d73cd3ccd8aa48","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performInplaceIntroduce(DartIntroduceOperation operation) {\n    final PsiElement statement = performRefactoring(operation);\n    final DartComponent target = PsiTreeUtil.findChildOfType(statement, DartComponent.class);\n    if (target == null) {\n      return;\n    }\n    final List<PsiElement> occurrences = operation.getOccurrences();\n    final PsiElement occurrence = DartRefactoringUtil.findOccurrenceUnderCaret(occurrences, operation.getEditor());\n    final PsiElement elementForCaret = occurrence != null ? occurrence : target;\n    operation.getEditor().getCaretModel().moveToOffset(elementForCaret.getTextRange().getStartOffset());\n    final InplaceVariableIntroducer<PsiElement> introducer =\n      new DartInplaceVariableIntroducer(target.getComponentName(), operation, occurrences);\n    introducer.performInplaceRefactoring(new LinkedHashSet<String>(operation.getSuggestedNames()));\n  }","id":45781,"modified_method":"protected void performInplaceIntroduce(DartIntroduceOperation operation) {\n    final PsiElement statement = performRefactoring(operation);\n    final DartComponent target = PsiTreeUtil.findChildOfType(statement, DartComponent.class);\n    final DartComponentName componentName = target != null ? target.getComponentName() : null;\n    if (componentName == null) {\n      return;\n    }\n    final List<PsiElement> occurrences = operation.getOccurrences();\n    operation.getEditor().getCaretModel().moveToOffset(componentName.getTextOffset());\n    final InplaceVariableIntroducer<PsiElement> introducer =\n      new DartInplaceVariableIntroducer(componentName, operation, occurrences);\n    introducer.performInplaceRefactoring(new LinkedHashSet<String>(operation.getSuggestedNames()));\n  }","commit_id":"f89e4cd02a498543f870115c09392eb7e97b35ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void performActionOnElementOccurrences(final DartIntroduceOperation operation) {\n    final Editor editor = operation.getEditor();\n    if (editor.getSettings().isVariableInplaceRenameEnabled()) {\n      ensureName(operation);\n      if (operation.isReplaceAll() != null) {\n        performInplaceIntroduce(operation);\n      }\n      else {\n        OccurrencesChooser.simpleChooser(editor).showChooser(\n          operation.getElement(),\n          operation.getOccurrences(),\n          new Pass<OccurrencesChooser.ReplaceChoice>() {\n            @Override\n            public void pass(OccurrencesChooser.ReplaceChoice replaceChoice) {\n              operation.setReplaceAll(replaceChoice == OccurrencesChooser.ReplaceChoice.ALL);\n              performInplaceIntroduce(operation);\n            }\n          });\n      }\n    }\n    else {\n      performIntroduceWithDialog(operation);\n    }\n  }","id":45782,"modified_method":"protected void performActionOnElementOccurrences(final DartIntroduceOperation operation) {\n    final Editor editor = operation.getEditor();\n    if (editor.getSettings().isVariableInplaceRenameEnabled()) {\n      ensureName(operation);\n      if (operation.isReplaceAll()) {\n        performInplaceIntroduce(operation);\n      }\n      else {\n        OccurrencesChooser.simpleChooser(editor).showChooser(\n          operation.getElement(),\n          operation.getOccurrences(),\n          new Pass<OccurrencesChooser.ReplaceChoice>() {\n            @Override\n            public void pass(OccurrencesChooser.ReplaceChoice replaceChoice) {\n              operation.setReplaceAll(replaceChoice == OccurrencesChooser.ReplaceChoice.ALL);\n              performInplaceIntroduce(operation);\n            }\n          });\n      }\n    }\n    else {\n      performIntroduceWithDialog(operation);\n    }\n  }","commit_id":"f89e4cd02a498543f870115c09392eb7e97b35ac","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private synchronized void removeConfiguration(String name) {\n    myNameToConfiguration.remove(name);\n  }","id":45783,"modified_method":"synchronized void removeConfiguration(String name) {\n    myNameToConfiguration.remove(name);\n  }","commit_id":"58ab63b6fd5093272223869f64f60bf27754b94f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void initJdomExternalizable(Class componentClass, BaseComponent component) {\n    try {\n      Element element = getDefaults(component);\n\n      if (element != null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Loading defaults for \" + componentClass.getName());\n        }\n        ((JDOMExternalizable)component).readExternal(element);\n      }\n    }\n    catch (Exception e) {\n      LOG.error(\"Cannot load defaults for \" + componentClass.getName(), e);\n    }\n\n    Element element = getConfiguration(component.getComponentName());\n\n    if (element != null) {\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Loading configuration for \" + componentClass.getName());\n        }\n        ((JDOMExternalizable)component).readExternal(element);\n      }\n      catch (InvalidDataException e) {\n        throw new InvalidComponentDataException(e);\n      }\n      removeConfiguration(component.getComponentName());\n    }\n  }","id":45784,"modified_method":"void initJdomExternalizable(Class componentClass, BaseComponent component) {\n    final String componentName = component.getComponentName();\n\n    try {\n      Element element = getDefaults(component);\n\n      if (element != null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Loading defaults for \" + componentClass.getName());\n        }\n        ((JDOMExternalizable)component).readExternal(element);\n      }\n    }\n    catch (Exception e) {\n      LOG.error(\"Cannot load defaults for \" + componentClass.getName(), e);\n    }\n\n    Element element = getConfiguration(componentName);\n\n    if (element != null) {\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Loading configuration for \" + componentClass.getName());\n        }\n        ((JDOMExternalizable)component).readExternal(element);\n      }\n      catch (InvalidDataException e) {\n        throw new InvalidComponentDataException(e);\n      }\n      removeConfiguration(componentName);\n    }\n  }","commit_id":"58ab63b6fd5093272223869f64f60bf27754b94f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getDescription()\n    {\n        if (connectorServerUrl != null)\n        {\n            return \"JMX Agent: \" + connectorServerUrl;\n        }\n        else\n        {\n            return \"JMX Agent\";\n        }\n    }","id":45785,"modified_method":"/** {@inheritDoc}\n     *\n     * @see org.mule.umo.manager.UMOAgent#getDescription()\n     */\n    public String getDescription()\n    {\n        if (connectorServerUrl != null)\n        {\n            return \"JMX Agent: \" + connectorServerUrl;\n        }\n        else\n        {\n            return \"JMX Agent\";\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public Map getConnectorServerProperties()\n    {\n        return connectorServerProperties;\n    }","id":45786,"modified_method":"/**\n     * Getter for property 'connectorServerProperties'.\n     *\n     * @return Value for property 'connectorServerProperties'.\n     */\n    public Map getConnectorServerProperties() {\n        return connectorServerProperties;\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void unregistered()\n    {\n        // nothing to do\n    }","id":45787,"modified_method":"/** {@inheritDoc}\n     * (non-Javadoc)\n     * \n     * @see org.mule.umo.manager.UMOAgent#unregistered()\n     */\n    public void unregistered()\n    {\n        // nothing to do\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void initialise() throws InitialisationException\n    {\n        if (initialized)\n        {\n            return;\n        }\n        if (!locateServer && !createServer)\n        {\n            throw new InitialisationException(new Message(Messages.JMX_CREATE_OR_LOCATE_SHOULD_BE_SET), this);\n        }\n        if (mBeanServer == null && locateServer)\n        {\n            List l = MBeanServerFactory.findMBeanServer(null);\n            if (l != null && l.size() > 0)\n            {\n                mBeanServer = (MBeanServer)l.get(0);\n            }\n        }\n        if (mBeanServer == null && createServer)\n        {\n            mBeanServer = MBeanServerFactory.createMBeanServer();\n            serverCreated = true;\n        }\n        if (mBeanServer == null)\n        {\n            throw new InitialisationException(new Message(Messages.JMX_CANT_LOCATE_CREATE_SERVER), this);\n        }\n        if (connectorServerUrl != null)\n        {\n            try\n            {\n                JMXServiceURL url = new JMXServiceURL(connectorServerUrl);\n                connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url,\n                    connectorServerProperties, mBeanServer);\n            }\n            catch (Exception e)\n            {\n                throw new InitialisationException(new Message(Messages.FAILED_TO_CREATE_X, \"Jmx Connector\"),\n                    e, this);\n            }\n        }\n\n        // We need to register all the services once the server has initialised\n        ModelNotificationListener l = new ModelNotificationListener()\n        {\n            public void onNotification(UMOServerNotification notification)\n            {\n                if (notification.getAction() == ModelNotification.MODEL_STARTED)\n                {\n                    try\n                    {\n                        registerStatisticsService();\n                        registerMuleService();\n                        registerConfigurationService();\n                        registerModelService();\n                        registerComponentServices();\n                        registerEndpointServices();\n                        registerConnectorServices();\n                    }\n                    catch (Exception e)\n                    {\n                        throw new MuleRuntimeException(\n                            new Message(Messages.X_FAILED_TO_INITIALISE, \"MBeans\"), e);\n                    }\n                }\n            }\n        };\n\n        try\n        {\n            MuleManager.getInstance().registerListener(l);\n        }\n        catch (NotificationException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n        initialized = true;\n    }","id":45788,"modified_method":"/** {@inheritDoc}\n     * (non-Javadoc)\n     * \n     * @see org.mule.umo.lifecycle.Initialisable#initialise()\n     */\n    public void initialise() throws InitialisationException\n    {\n        if (initialized) {\n            return;\n        }\n        if (!locateServer && !createServer) {\n            throw new InitialisationException(new Message(Messages.JMX_CREATE_OR_LOCATE_SHOULD_BE_SET), this);\n        }\n        if (mBeanServer == null && locateServer) {\n            List l = MBeanServerFactory.findMBeanServer(null);\n            if (l != null && l.size() > 0) {\n                mBeanServer = (MBeanServer) l.get(0);\n            }\n        }\n        if (mBeanServer == null && createServer) {\n            mBeanServer = MBeanServerFactory.createMBeanServer();\n            serverCreated = true;\n        }\n        if (mBeanServer == null) {\n            throw new InitialisationException(new Message(Messages.JMX_CANT_LOCATE_CREATE_SERVER), this);\n        }\n        if (connectorServerUrl != null) {\n            try {\n                JMXServiceURL url = new JMXServiceURL(connectorServerUrl);\n                connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, connectorServerProperties, mBeanServer);\n            } catch (Exception e) {\n                throw new InitialisationException(new Message(Messages.FAILED_TO_CREATE_X, \"Jmx Connector\"), e, this);\n            }\n        }\n\n        jmxSupport = jmxSupportFactory.newJmxSupport();\n\n        // We need to register all the services once the server has initialised\n        ModelNotificationListener l = new ModelNotificationListener() {\n            public void onNotification(UMOServerNotification notification)\n            {\n                if (notification.getAction() == ModelNotification.MODEL_STARTED) {\n                    try {\n                        registerStatisticsService();\n                        registerMuleService();\n                        registerConfigurationService();\n                        registerModelService();\n                        registerComponentServices();\n                        registerEndpointServices();\n                        registerConnectorServices();\n                    } catch (Exception e) {\n                        throw new MuleRuntimeException(new Message(Messages.X_FAILED_TO_INITIALISE, \"MBeans\"), e);\n                    }\n                }\n            }\n        };\n\n        try {\n            MuleManager.getInstance().registerListener(l);\n        } catch (NotificationException e) {\n            throw new InitialisationException(e, this);\n        }\n        initialized = true;\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setConnectorServerProperties(Map connectorServerProperties)\n    {\n        this.connectorServerProperties = connectorServerProperties;\n    }","id":45789,"modified_method":"/**\n     * Setter for property 'connectorServerProperties'.\n     *\n     * @param connectorServerProperties Value to set for property 'connectorServerProperties'.\n     */\n    public void setConnectorServerProperties(Map connectorServerProperties) {\n        this.connectorServerProperties = connectorServerProperties;\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerModelService()\n        throws NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException,\n        MalformedObjectNameException\n    {\n        ModelServiceMBean serviceMBean = new ModelService();\n        String name = serviceMBean.getName() + \"(\" + serviceMBean.getType() + \")\";\n        ObjectName on = ObjectName.getInstance(getDomainName() + \":type=org.mule.Model,name=\" + name);\n        logger.debug(\"Registering model with name: \" + on);\n        mBeanServer.registerMBean(serviceMBean, on);\n        registeredMBeans.add(on);\n    }","id":45790,"modified_method":"protected void registerModelService() throws NotCompliantMBeanException, MBeanRegistrationException,\n            InstanceAlreadyExistsException, MalformedObjectNameException\n    {\n        ModelServiceMBean serviceMBean = new ModelService();\n        String rawName = serviceMBean.getName() + \"(\" + serviceMBean.getType() + \")\";\n        String name = jmxSupport.escape(rawName);\n        ObjectName on = jmxSupport.getInstance(jmxSupport.getDomainName() + \":type=org.mule.Model,name=\" + name);\n        logger.debug(\"Registering model with name: \" + on);\n        mBeanServer.registerMBean(serviceMBean, on);\n        registeredMBeans.add(on);\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setName(String name)\n    {\n        this.name = name;\n    }","id":45791,"modified_method":"/** {@inheritDoc}\n     *\n     * @see org.mule.umo.manager.UMOAgent#setName(java.lang.String)\n     */\n    public void setName(String name)\n    {\n        this.name = name;\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerEndpointServices()\n        throws NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException,\n        MalformedObjectNameException\n    {\n        Iterator iter = MuleManager.getInstance().getConnectors().values().iterator();\n        UMOConnector connector;\n        while (iter.hasNext())\n        {\n            connector = (UMOConnector)iter.next();\n            if (connector instanceof AbstractConnector)\n            {\n                for (Iterator iterator = ((AbstractConnector)connector).getReceivers().values().iterator(); iterator.hasNext();)\n                {\n                    EndpointServiceMBean mBean = new EndpointService((UMOMessageReceiver)iterator.next());\n                    if (logger.isInfoEnabled())\n                    {\n                        logger.info(\"Attempting to register service with name: \" + getDomainName()\n                                    + \":type=org.mule.umo.UMOEndpoint,name=\" + mBean.getName());\n                    }\n                    ObjectName on = ObjectName.getInstance(getDomainName()\n                                                           + \":type=org.mule.Endpoint,component=\"\n                                                           + mBean.getComponentName() + \",name=\"\n                                                           + mBean.getName());\n                    mBeanServer.registerMBean(mBean, on);\n                    registeredMBeans.add(on);\n                    logger.info(\"Registered Endpoint Service with name: \" + on);\n                }\n            }\n            else\n            {\n                logger.warn(\"Connector: \"\n                            + connector\n                            + \" is not an istance of AbstractConnector, cannot obtain Endpoint MBeans from it\");\n            }\n\n        }\n    }","id":45792,"modified_method":"protected void registerEndpointServices() throws NotCompliantMBeanException, MBeanRegistrationException,\n            InstanceAlreadyExistsException, MalformedObjectNameException\n    {\n        Iterator iter = MuleManager.getInstance().getConnectors().values().iterator();\n        UMOConnector connector;\n        while (iter.hasNext()) {\n            connector = (UMOConnector) iter.next();\n            if (connector instanceof AbstractConnector) {\n                for (Iterator iterator = ((AbstractConnector) connector).getReceivers().values().iterator(); iterator.hasNext();) {\n                    EndpointServiceMBean mBean = new EndpointService((UMOMessageReceiver) iterator.next());\n                    final String rawName = mBean.getName();\n                    final String name = jmxSupport.escape(rawName);\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Attempting to register service with name: \" + jmxSupport.getDomainName()\n                                + \":type=org.mule.umo.UMOEndpoint,name=\" + name);\n                    }\n                    ObjectName on = jmxSupport.getInstance(\n                                                    jmxSupport.getDomainName() +\n                                                    \":type=org.mule.Endpoint,component=\" +\n                                                    jmxSupport.escape(mBean.getComponentName()) +\n                                                    \",name=\" + name);\n                    mBeanServer.registerMBean(mBean, on);\n                    registeredMBeans.add(on);\n                    logger.info(\"Registered Endpoint Service with name: \" + on);\n                }\n            } else {\n                logger.warn(\"Connector: \" + connector\n                        + \" is not an istance of AbstractConnector, cannot obtain Endpoint MBeans from it\");\n            }\n\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerConfigurationService()\n        throws NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException,\n        MalformedObjectNameException\n    {\n        ObjectName on = ObjectName.getInstance(getDomainName()\n                                               + \":type=org.mule.Configuration,name=GlobalConfiguration\");\n        MuleConfigurationServiceMBean serviceMBean = new MuleConfigurationService();\n        logger.debug(\"Registering configuration with name: \" + on);\n        mBeanServer.registerMBean(serviceMBean, on);\n        registeredMBeans.add(on);\n    }","id":45793,"modified_method":"protected void registerConfigurationService() throws NotCompliantMBeanException, MBeanRegistrationException,\n            InstanceAlreadyExistsException, MalformedObjectNameException\n    {\n        ObjectName on = jmxSupport.getInstance(jmxSupport.getDomainName() + \":type=org.mule.Configuration,name=GlobalConfiguration\");\n        MuleConfigurationServiceMBean serviceMBean = new MuleConfigurationService();\n        logger.debug(\"Registering configuration with name: \" + on);\n        mBeanServer.registerMBean(serviceMBean, on);\n        registeredMBeans.add(on);\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerStatisticsService()\n        throws NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException,\n        MalformedObjectNameException\n    {\n        ObjectName on = ObjectName.getInstance(getDomainName()\n                                               + \":type=org.mule.Statistics,name=AllStatistics\");\n        StatisticsService mBean = new StatisticsService();\n        mBean.setManager(MuleManager.getInstance());\n        mBean.setEnabled(isEnableStatistics());\n        logger.debug(\"Registering statistics with name: \" + on);\n        mBeanServer.registerMBean(mBean, on);\n        registeredMBeans.add(on);\n    }","id":45794,"modified_method":"protected void registerStatisticsService() throws NotCompliantMBeanException, MBeanRegistrationException,\n            InstanceAlreadyExistsException, MalformedObjectNameException\n    {\n        ObjectName on = jmxSupport.getInstance(jmxSupport.getDomainName() + \":type=org.mule.Statistics,name=AllStatistics\");\n        StatisticsService mBean = new StatisticsService();\n        mBean.setManager(MuleManager.getInstance());\n        mBean.setEnabled(isEnableStatistics());\n        logger.debug(\"Registering statistics with name: \" + on);\n        mBeanServer.registerMBean(mBean, on);\n        registeredMBeans.add(on);\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void start() throws UMOException\n    {\n        if (connectorServer != null)\n        {\n            try\n            {\n                logger.info(\"Starting JMX agent connector Server\");\n                connectorServer.start();\n            }\n            catch (Exception e)\n            {\n                throw new JmxManagementException(new Message(Messages.FAILED_TO_START_X, \"Jmx Connector\"), e);\n            }\n        }\n    }","id":45795,"modified_method":"/** {@inheritDoc}\n     * (non-Javadoc)\n     * \n     * @see org.mule.umo.lifecycle.Startable#start()\n     */\n    public void start() throws UMOException\n    {\n        if (connectorServer != null) {\n            try {\n                logger.info(\"Starting JMX agent connector Server\");\n                connectorServer.start();\n            } catch (Exception e) {\n                throw new JmxManagementException(new Message(Messages.FAILED_TO_START_X, \"Jmx Connector\"), e);\n            }\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerConnectorServices()\n        throws MalformedObjectNameException, NotCompliantMBeanException, MBeanRegistrationException,\n        InstanceAlreadyExistsException\n    {\n        Iterator iter = MuleManager.getInstance().getConnectors().values().iterator();\n        while (iter.hasNext())\n        {\n            UMOConnector connector = (UMOConnector)iter.next();\n            ConnectorServiceMBean mBean = new ConnectorService(connector);\n            final String stringName = getDomainName() + \":type=org.mule.Connector,name=\" + mBean.getName();\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Attempting to register service with name: \" + stringName);\n            }\n            ObjectName oName = ObjectName.getInstance(stringName);\n            mBeanServer.registerMBean(mBean, oName);\n            registeredMBeans.add(oName);\n            logger.info(\"Registered Connector Service with name \" + oName);\n        }\n    }","id":45796,"modified_method":"protected void registerConnectorServices() throws\n                                                MalformedObjectNameException,\n                                                NotCompliantMBeanException,\n                                                MBeanRegistrationException,\n                                                InstanceAlreadyExistsException\n    {\n        Iterator iter = MuleManager.getInstance().getConnectors().values().iterator();\n        while (iter.hasNext()) {\n            UMOConnector connector = (UMOConnector) iter.next();\n            ConnectorServiceMBean mBean = new ConnectorService(connector);\n            final String rawName = mBean.getName();\n            final String name = jmxSupport.escape(rawName);\n            final String stringName = jmxSupport.getDomainName() + \":type=org.mule.Connector,name=\" + name;\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Attempting to register service with name: \" + stringName);\n            }\n            ObjectName oName = jmxSupport.getInstance(stringName);\n            mBeanServer.registerMBean(mBean, oName);\n            registeredMBeans.add(oName);\n            logger.info(\"Registered Connector Service with name \" + oName);\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerComponentServices()\n        throws NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException,\n        MalformedObjectNameException\n    {\n        Iterator iter = MuleManager.getInstance().getModel().getComponentNames();\n        String name;\n        while (iter.hasNext())\n        {\n            name = iter.next().toString();\n            ObjectName on = ObjectName.getInstance(getDomainName() + \":type=org.mule.Component,name=\" + name);\n            ComponentServiceMBean serviceMBean = new ComponentService(name);\n            logger.debug(\"Registering component with name: \" + on);\n            mBeanServer.registerMBean(serviceMBean, on);\n            registeredMBeans.add(on);\n        }\n    }","id":45797,"modified_method":"protected void registerComponentServices() throws NotCompliantMBeanException, MBeanRegistrationException,\n            InstanceAlreadyExistsException, MalformedObjectNameException\n    {\n        Iterator iter = MuleManager.getInstance().getModel().getComponentNames();\n        String rawName;\n        while (iter.hasNext()) {\n            rawName = iter.next().toString();\n            final String name = jmxSupport.escape(rawName);\n            ObjectName on = jmxSupport.getInstance(jmxSupport.getDomainName() + \":type=org.mule.Component,name=\" + name);\n            ComponentServiceMBean serviceMBean = new ComponentService(rawName);\n            logger.debug(\"Registering component with name: \" + on);\n            mBeanServer.registerMBean(serviceMBean, on);\n            registeredMBeans.add(on);\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerMuleService()\n        throws NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException,\n        MalformedObjectNameException\n    {\n        ObjectName on = ObjectName.getInstance(getDomainName()\n                                               + \":type=org.mule.ManagementContext,name=MuleServerInfo\");\n        MuleServiceMBean serviceMBean = new MuleService();\n        logger.debug(\"Registering mule with name: \" + on);\n        mBeanServer.registerMBean(serviceMBean, on);\n        registeredMBeans.add(on);\n    }","id":45798,"modified_method":"protected void registerMuleService() throws NotCompliantMBeanException, MBeanRegistrationException,\n            InstanceAlreadyExistsException, MalformedObjectNameException\n    {\n        ObjectName on = jmxSupport.getInstance(jmxSupport.getDomainName() + \":type=org.mule.ManagementContext,name=MuleServerInfo\");\n        MuleServiceMBean serviceMBean = new MuleService();\n        logger.debug(\"Registering mule with name: \" + on);\n        mBeanServer.registerMBean(serviceMBean, on);\n        registeredMBeans.add(on);\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void stop() throws UMOException\n    {\n        if (connectorServer != null)\n        {\n            try\n            {\n                connectorServer.stop();\n            }\n            catch (Exception e)\n            {\n                throw new JmxManagementException(new Message(Messages.FAILED_TO_STOP_X, \"Jmx Connector\"), e);\n            }\n        }\n    }","id":45799,"modified_method":"/** {@inheritDoc}\n     * (non-Javadoc)\n     * \n     * @see org.mule.umo.lifecycle.Stoppable#stop()\n     */\n    public void stop() throws UMOException\n    {\n        if (connectorServer != null) {\n            try {\n                connectorServer.stop();\n            } catch (Exception e) {\n                throw new JmxManagementException(new Message(Messages.FAILED_TO_STOP_X, \"Jmx Connector\"), e);\n            }\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void registered()\n    {\n        // nothing to do\n    }","id":45800,"modified_method":"/** {@inheritDoc}\n     * (non-Javadoc)\n     * \n     * @see org.mule.umo.manager.UMOAgent#registered()\n     */\n    public void registered()\n    {\n        // nothing to do\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void dispose()\n    {\n        if (mBeanServer != null)\n        {\n            for (Iterator iterator = registeredMBeans.iterator(); iterator.hasNext();)\n            {\n                ObjectName objectName = (ObjectName)iterator.next();\n                try\n                {\n                    mBeanServer.unregisterMBean(objectName);\n                }\n                catch (Exception e)\n                {\n                    logger.warn(\"Failed to unregister MBean: \" + objectName + \". Error is: \" + e.getMessage());\n                }\n            }\n            if (serverCreated)\n            {\n                MBeanServerFactory.releaseMBeanServer(mBeanServer);\n            }\n            mBeanServer = null;\n        }\n    }","id":45801,"modified_method":"/** {@inheritDoc}\n     * (non-Javadoc)\n     * \n     * @see org.mule.umo.lifecycle.Disposable#dispose()\n     */\n    public void dispose()\n    {\n        if (mBeanServer != null) {\n            for (Iterator iterator = registeredMBeans.iterator(); iterator.hasNext();) {\n                ObjectName objectName = (ObjectName) iterator.next();\n                try {\n                    mBeanServer.unregisterMBean(objectName);\n                } catch (Exception e) {\n                    logger.warn(\"Failed to unregister MBean: \" + objectName + \". Error is: \" + e.getMessage());\n                }\n            }\n            if (serverCreated) {\n                MBeanServerFactory.releaseMBeanServer(mBeanServer);\n            }\n            mBeanServer = null;\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public String getName()\n    {\n        return this.name;\n    }","id":45802,"modified_method":"/** {@inheritDoc}\n    *\n    * @see org.mule.umo.manager.UMOAgent#getName()\n    */\n    public String getName()\n    {\n        return this.name;\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void dispose()\n    {\n        try\n        {\n            if (listenerObjectName != null)\n            {\n                mBeanServer.unregisterMBean(listenerObjectName);\n            }\n        }\n        catch (Exception e)\n        {\n            logger.warn(e.getMessage(), e);\n        }\n        try\n        {\n            mBeanServer.unregisterMBean(broadcasterObjectName);\n        }\n        catch (Exception e)\n        {\n            logger.warn(e.getMessage(), e);\n        }\n        super.dispose();\n    }","id":45803,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void dispose()\n    {\n        try\n        {\n            if (listenerObjectName != null)\n            {\n                mBeanServer.unregisterMBean(listenerObjectName);\n            }\n        } catch (Exception e)\n        {\n            logger.warn(e.getMessage(), e);\n        }\n        try\n        {\n            mBeanServer.unregisterMBean(broadcasterObjectName);\n        } catch (Exception e)\n        {\n            logger.warn(e.getMessage(), e);\n        }\n        super.dispose();\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"List getNotificsationList();","id":45804,"modified_method":"/**\n         * Getter for property 'notificsationList'.\n         *\n         * @return Value for property 'notificsationList'.\n         */\n        List getNotificationsList();","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected List getList()\n        {\n            if (notifs == null)\n            {\n                notifs = new ArrayList(listSize);\n            }\n            return notifs;\n        }","id":45805,"modified_method":"/**\n         * Getter for property 'list'.\n         *\n         * @return Value for property 'list'.\n         */\n        protected List getList()\n        {\n            if (notifs == null)\n            {\n                notifs = new ArrayList(listSize);\n            }\n            return notifs;\n        }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void logEvent(UMOServerNotification e)\n    {\n        broadcastNotificationMbean.sendNotification(new Notification(e.getClass().getName(), e,\n            e.getTimestamp(), e.toString()));\n    }","id":45806,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    protected void logEvent(UMOServerNotification e)\n    {\n        broadcastNotificationMbean.sendNotification(new Notification(e.getClass().getName(), e, e.getTimestamp(), e.toString()));\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public List getNotificsationList()\n        {\n            return notifs;\n        }","id":45807,"modified_method":"/**\n         * {@inheritDoc}\n         */\n        public List getNotificationsList()\n        {\n            return notifs;\n        }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setListSize(int listSize)\n        {\n            this.listSize = listSize;\n        }","id":45808,"modified_method":"/**\n         * {@inheritDoc}\n         */\n        public void setListSize(int listSize)\n        {\n            this.listSize = listSize;\n        }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"int getListSize();","id":45809,"modified_method":"/**\n         * Getter for property 'listSize'.\n         *\n         * @return Value for property 'listSize'.\n         */\n        int getListSize();","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"void setListSize(int listSize);","id":45810,"modified_method":"/**\n         * Setter for property 'listSize'.\n         *\n         * @param listSize Value to set for property 'listSize'.\n         */\n        void setListSize(int listSize);","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doInitialise() throws InitialisationException\n    {\n        if (getName() == null)\n        {\n            setName(\"Jmx Notification Agent\");\n        }\n        try\n        {\n            mBeanServer = (MBeanServer)MBeanServerFactory.findMBeanServer(null).get(0);\n            broadcasterObjectName = ObjectName.getInstance(getDomainName() + \":\"\n                                                           + BROADCASTER_JMX_OBJECT_NAME);\n            broadcastNotificationMbean = new BroadcastNotificationService();\n            mBeanServer.registerMBean(broadcastNotificationMbean, broadcasterObjectName);\n            if (registerListenerMbean)\n            {\n                listenerObjectName = ObjectName.getInstance(getDomainName() + \":\" + LISTENER_JMX_OBJECT_NAME);\n                NotificationListener mbean = new NotificationListener();\n                broadcastNotificationMbean.addNotificationListener(mbean, null, null);\n                mBeanServer.registerMBean(mbean, listenerObjectName);\n            }\n        }\n        catch (Exception e)\n        {\n            throw new InitialisationException(new Message(Messages.FAILED_TO_START_X,\n                \"JMX Server Notification Agent\"), e, this);\n        }\n    }","id":45811,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    protected void doInitialise() throws InitialisationException\n    {\n        if (getName() == null)\n        {\n            setName(\"Jmx Notification Agent\");\n        }\n        try\n        {\n            jmxSupport = jmxSupportFactory.newJmxSupport();\n            mBeanServer = (MBeanServer) MBeanServerFactory.findMBeanServer(null).get(0);\n            broadcasterObjectName = ObjectName.getInstance(jmxSupport.getDomainName() + \":\" + BROADCASTER_JMX_OBJECT_NAME);\n            broadcastNotificationMbean = new BroadcastNotificationService();\n            mBeanServer.registerMBean(broadcastNotificationMbean, broadcasterObjectName);\n            if (registerListenerMbean)\n            {\n                listenerObjectName = ObjectName.getInstance(jmxSupport.getDomainName() + \":\" + LISTENER_JMX_OBJECT_NAME);\n                NotificationListener mbean = new NotificationListener();\n                broadcastNotificationMbean.addNotificationListener(mbean, null, null);\n                mBeanServer.registerMBean(mbean, listenerObjectName);\n            }\n        } catch (Exception e)\n        {\n            throw new InitialisationException(new Message(Messages.FAILED_TO_START_X, \"JMX Server Notification Agent\"), e, this);\n        }\n    }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public int getListSize()\n        {\n            return listSize;\n        }","id":45812,"modified_method":"/**\n         * {@inheritDoc}\n         */\n        public int getListSize()\n        {\n            return listSize;\n        }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"public void handleNotification(Notification notification, Object o)\n        {\n            if (getList().size() == listSize)\n            {\n                getList().remove(listSize - 1);\n            }\n            getList().add(0, notification);\n        }","id":45813,"modified_method":"/**\n         * {@inheritDoc}\n         */\n        public void handleNotification(Notification notification, Object o)\n        {\n            if (getList().size() == listSize)\n            {\n                getList().remove(listSize - 1);\n            }\n            getList().add(0, notification);\n        }","commit_id":"7bc548fb2a0993240807751bcad5247d1fb73e38","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Object processInvocation(InterceptorContext context) throws Exception {\n        final Component component = context.getPrivateData(Component.class);\n        if (component instanceof EJBComponent == false) {\n            throw MESSAGES.unexpectedComponent(component,EJBComponent.class);\n        }\n        final Method invokedMethod = context.getMethod();\n        final ComponentView componentView = context.getPrivateData(ComponentView.class);\n        final String viewClassOfInvokedMethod = componentView.getViewClass().getName();\n        // shouldn't really happen if the interceptor was setup correctly. But let's be safe and do a check\n        if (!this.viewClassName.equals(viewClassOfInvokedMethod) || !this.viewMethod.equals(invokedMethod)) {\n            throw MESSAGES.failProcessInvocation(this.getClass().getName(), invokedMethod,viewClassOfInvokedMethod, viewMethod, viewClassName);\n        }\n        final EJBComponent ejbComponent = (EJBComponent) component;\n        // check @DenyAll/exclude-list\n        if (ejbMethodSecurityMetaData.isDenyAll()) {\n            throw MESSAGES.invocationOfMethodNotAllowed(invokedMethod,ejbComponent.getComponentName());\n        }\n        // If @PermitAll isn't applicable for the method then check the allowed roles\n        if (!ejbMethodSecurityMetaData.isPermitAll()) {\n            // get allowed roles (if any) for this method invocation\n            final Collection<String> allowedRoles = ejbMethodSecurityMetaData.getRolesAllowed();\n            if (!allowedRoles.isEmpty()) {\n                // call the security API to do authorization check\n                final ServerSecurityManager securityManager = ejbComponent.getSecurityManager();\n                final EJBSecurityMetaData ejbSecurityMetaData = ejbComponent.getSecurityMetaData();\n                if (!securityManager.isCallerInRole(ejbSecurityMetaData.getSecurityRoles(), ejbSecurityMetaData.getSecurityRoleLinks(), allowedRoles.toArray(new String[allowedRoles.size()]))) {\n                    throw MESSAGES.invocationOfMethodNotAllowed(invokedMethod,ejbComponent.getComponentName());\n                }\n            }\n        }\n        // successful authorization, let the invocation proceed\n        return context.proceed();\n    }","id":45814,"modified_method":"@Override\n    public Object processInvocation(InterceptorContext context) throws Exception {\n        final Component component = context.getPrivateData(Component.class);\n        if (component instanceof EJBComponent == false) {\n            throw MESSAGES.unexpectedComponent(component,EJBComponent.class);\n        }\n        final Method invokedMethod = context.getMethod();\n        final ComponentView componentView = context.getPrivateData(ComponentView.class);\n        final String viewClassOfInvokedMethod = componentView.getViewClass().getName();\n        // shouldn't really happen if the interceptor was setup correctly. But let's be safe and do a check\n        if (!this.viewClassName.equals(viewClassOfInvokedMethod) || !this.viewMethod.equals(invokedMethod)) {\n            throw MESSAGES.failProcessInvocation(this.getClass().getName(), invokedMethod,viewClassOfInvokedMethod, viewMethod, viewClassName);\n        }\n        final EJBComponent ejbComponent = (EJBComponent) component;\n        final ServerSecurityManager securityManager = ejbComponent.getSecurityManager();\n        final MethodInterfaceType methodIntfType = this.getMethodInterfaceType(componentView.getPrivateData(MethodIntf.class));\n\n        // set the JACC contextID before calling the security manager.\n        final String previousContextID = setContextID(this.contextID);\n        try {\n            if (!securityManager.authorize(ejbComponent.getComponentName(), componentView.getProxyClass().getProtectionDomain().getCodeSource(),\n                methodIntfType.name(), this.viewMethod, this.getMethodRolesAsPrincipals(), this.contextID))\n                throw MESSAGES.invocationOfMethodNotAllowed(invokedMethod,ejbComponent.getComponentName());\n        }\n        finally {\n            // reset the previous JACC contextID.\n            setContextID(previousContextID);\n        }\n\n        // successful authorization, let the invocation proceed\n        return context.proceed();\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public AuthorizationInterceptor(final EJBMethodSecurityAttribute ejbMethodSecurityMetaData, final String viewClassName, final Method viewMethod) {\n        if (ejbMethodSecurityMetaData == null) {\n            throw MESSAGES.ejbMethodSecurityMetaDataIsNull();\n        }\n        if (viewClassName == null || viewClassName.trim().isEmpty()) {\n            throw MESSAGES.viewClassNameIsNull();\n        }\n        if (viewMethod == null) {\n            throw MESSAGES.viewMethodIsNull();\n        }\n        this.ejbMethodSecurityMetaData = ejbMethodSecurityMetaData;\n        this.viewClassName = viewClassName;\n        this.viewMethod = viewMethod;\n    }","id":45815,"modified_method":"public AuthorizationInterceptor(final EJBMethodSecurityAttribute ejbMethodSecurityMetaData, final String viewClassName, final Method viewMethod, final String contextID) {\n        if (ejbMethodSecurityMetaData == null) {\n            throw MESSAGES.ejbMethodSecurityMetaDataIsNull();\n        }\n        if (viewClassName == null || viewClassName.trim().isEmpty()) {\n            throw MESSAGES.viewClassNameIsNull();\n        }\n        if (viewMethod == null) {\n            throw MESSAGES.viewMethodIsNull();\n        }\n        this.ejbMethodSecurityMetaData = ejbMethodSecurityMetaData;\n        this.viewClassName = viewClassName;\n        this.viewMethod = viewMethod;\n        this.contextID = contextID;\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void configure(DeploymentPhaseContext context, ComponentConfiguration componentConfiguration, ViewDescription viewDescription, ViewConfiguration viewConfiguration) throws DeploymentUnitProcessingException {\n        if (componentConfiguration.getComponentDescription() instanceof EJBComponentDescription == false) {\n            throw MESSAGES.invalidEjbComponent(componentConfiguration.getComponentName(), componentConfiguration.getComponentClass());\n        }\n        final DeploymentReflectionIndex deploymentReflectionIndex = context.getDeploymentUnit().getAttachment(org.jboss.as.server.deployment.Attachments.REFLECTION_INDEX);\n        final EJBComponentDescription ejbComponentDescription = (EJBComponentDescription) componentConfiguration.getComponentDescription();\n        // The getSecurityDomain() will return a null value if neither an explicit security domain is configured\n        // for the bean nor there's any default security domain that's configured at EJB3 subsystem level.\n        // In such cases, we do *not* apply any security interceptors\n        if (ejbComponentDescription.getSecurityDomain() == null) {\n            ROOT_LOGGER.debug(\"Security is *not* enabled on EJB: \" + ejbComponentDescription.getEJBName() +\n                    \", since no explicit security domain is configured for the bean, nor is there any default security domain configured in the EJB3 subsystem\");\n            return;\n        }\n\n        final String viewClassName = viewDescription.getViewClassName();\n        final EJBViewDescription ejbViewDescription = (EJBViewDescription) viewDescription;\n\n        // setup the method specific security interceptor(s)\n        boolean beanHasMethodLevelSecurityMetadata = false;\n        final List<Method> viewMethods = viewConfiguration.getProxyFactory().getCachedMethods();\n        for (final Method viewMethod : viewMethods) {\n            // TODO: proxy factory exposes non-public methods, is this a bug in the no-interface view?\n            if (!Modifier.isPublic(viewMethod.getModifiers())) {\n                continue;\n            }\n            if (viewMethod.getDeclaringClass() == WriteReplaceInterface.class) {\n                continue;\n            }\n            // setup the authorization interceptor\n            final ApplicableMethodInformation<EJBMethodSecurityAttribute> permissions = ejbComponentDescription.getDescriptorMethodPermissions();\n            boolean methodHasSecurityMetadata = handlePermissions(componentConfiguration, viewConfiguration, deploymentReflectionIndex, viewClassName, ejbViewDescription, viewMethod, permissions, false);\n            if (!methodHasSecurityMetadata) {\n                //if it was not handled by the descriptor processor we look for annotation basic info\n                methodHasSecurityMetadata = handlePermissions(componentConfiguration, viewConfiguration, deploymentReflectionIndex, viewClassName, ejbViewDescription, viewMethod, ejbComponentDescription.getAnnotationMethodPermissions(), true);\n            }\n            // if any method has security metadata then the bean has method level security metadata\n            if (methodHasSecurityMetadata) {\n                beanHasMethodLevelSecurityMetadata = true;\n            }\n        }\n\n        // now add the security interceptor if the bean has *any* security metadata applicable\n        if (beanHasMethodLevelSecurityMetadata || this.hasSecurityMetaData(ejbComponentDescription)) {\n            // setup the security context interceptor\n            viewConfiguration.addViewInterceptor(new SecurityContextInterceptorFactory(), InterceptorOrder.View.SECURITY_CONTEXT);\n        } else {\n            // if security is not applicable for the EJB, then do *not* add the security related interceptors\n            ROOT_LOGGER.debug(\"Security is *not* enabled on EJB: \" + ejbComponentDescription.getEJBName() + \", no security interceptors will apply\");\n            return;\n        }\n\n    }","id":45816,"modified_method":"@Override\n    public void configure(DeploymentPhaseContext context, ComponentConfiguration componentConfiguration, ViewDescription viewDescription, ViewConfiguration viewConfiguration) throws DeploymentUnitProcessingException {\n        if (componentConfiguration.getComponentDescription() instanceof EJBComponentDescription == false) {\n            throw MESSAGES.invalidEjbComponent(componentConfiguration.getComponentName(), componentConfiguration.getComponentClass());\n        }\n        final DeploymentReflectionIndex deploymentReflectionIndex = context.getDeploymentUnit().getAttachment(org.jboss.as.server.deployment.Attachments.REFLECTION_INDEX);\n        final EJBComponentDescription ejbComponentDescription = (EJBComponentDescription) componentConfiguration.getComponentDescription();\n        // The getSecurityDomain() will return a null value if neither an explicit security domain is configured\n        // for the bean nor there's any default security domain that's configured at EJB3 subsystem level.\n        // In such cases, we do *not* apply any security interceptors\n        if (ejbComponentDescription.getSecurityDomain() == null) {\n            ROOT_LOGGER.debug(\"Security is *not* enabled on EJB: \" + ejbComponentDescription.getEJBName() +\n                    \", since no explicit security domain is configured for the bean, nor is there any default security domain configured in the EJB3 subsystem\");\n            return;\n        }\n\n        final String viewClassName = viewDescription.getViewClassName();\n        final EJBViewDescription ejbViewDescription = (EJBViewDescription) viewDescription;\n\n        // setup the JACC contextID.\n        DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        String contextID = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            contextID = deploymentUnit.getParent().getName() + \"!\" + contextID;\n        }\n\n        // setup the method specific security interceptor(s)\n        boolean beanHasMethodLevelSecurityMetadata = false;\n        final List<Method> viewMethods = viewConfiguration.getProxyFactory().getCachedMethods();\n        for (final Method viewMethod : viewMethods) {\n            // TODO: proxy factory exposes non-public methods, is this a bug in the no-interface view?\n            if (!Modifier.isPublic(viewMethod.getModifiers())) {\n                continue;\n            }\n            if (viewMethod.getDeclaringClass() == WriteReplaceInterface.class) {\n                continue;\n            }\n            // setup the authorization interceptor\n            final ApplicableMethodInformation<EJBMethodSecurityAttribute> permissions = ejbComponentDescription.getDescriptorMethodPermissions();\n            boolean methodHasSecurityMetadata = handlePermissions(contextID, componentConfiguration, viewConfiguration, deploymentReflectionIndex, viewClassName, ejbViewDescription, viewMethod, permissions, false);\n            if (!methodHasSecurityMetadata) {\n                //if it was not handled by the descriptor processor we look for annotation basic info\n                methodHasSecurityMetadata = handlePermissions(contextID, componentConfiguration, viewConfiguration, deploymentReflectionIndex, viewClassName, ejbViewDescription, viewMethod, ejbComponentDescription.getAnnotationMethodPermissions(), true);\n            }\n            // if any method has security metadata then the bean has method level security metadata\n            if (methodHasSecurityMetadata) {\n                beanHasMethodLevelSecurityMetadata = true;\n            }\n        }\n\n        // now add the security interceptor if the bean has *any* security metadata applicable\n        if (beanHasMethodLevelSecurityMetadata || this.hasSecurityMetaData(ejbComponentDescription)) {\n            // setup the security context interceptor\n            viewConfiguration.addViewInterceptor(new SecurityContextInterceptorFactory(), InterceptorOrder.View.SECURITY_CONTEXT);\n        } else {\n            // if security is not applicable for the EJB, then do *not* add the security related interceptors\n            ROOT_LOGGER.debug(\"Security is *not* enabled on EJB: \" + ejbComponentDescription.getEJBName() + \", no security interceptors will apply\");\n            return;\n        }\n\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean handlePermissions(ComponentConfiguration componentConfiguration, ViewConfiguration viewConfiguration, DeploymentReflectionIndex deploymentReflectionIndex, String viewClassName, EJBViewDescription ejbViewDescription, Method viewMethod, ApplicableMethodInformation<EJBMethodSecurityAttribute> permissions, boolean annotations) {\n        EJBMethodSecurityAttribute ejbMethodSecurityMetaData = permissions.getViewAttribute(ejbViewDescription.getMethodIntf(), viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes());\n        final List<EJBMethodSecurityAttribute> allAttributes = new ArrayList<EJBMethodSecurityAttribute>();\n        allAttributes.addAll(permissions.getAllAttributes(ejbViewDescription.getMethodIntf(), viewMethod.getDeclaringClass().getName(), viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes()));\n\n        if (ejbMethodSecurityMetaData == null) {\n            ejbMethodSecurityMetaData = permissions.getViewAttribute(MethodIntf.BEAN, viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes());\n        }\n        allAttributes.addAll(permissions.getAllAttributes(MethodIntf.BEAN, viewMethod.getDeclaringClass().getName(), viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes()));\n\n        final Method classMethod = ClassReflectionIndexUtil.findMethod(deploymentReflectionIndex, componentConfiguration.getComponentClass(), viewMethod);\n        if (ejbMethodSecurityMetaData == null) {\n            //if this is null we try with the corresponding bean method\n            if (classMethod != null) {\n                ejbMethodSecurityMetaData = permissions.getAttribute(ejbViewDescription.getMethodIntf(), classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes());\n                if (ejbMethodSecurityMetaData == null) {\n                    ejbMethodSecurityMetaData = permissions.getAttribute(MethodIntf.BEAN, classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes());\n\n                }\n            }\n        }\n        if (classMethod != null) {\n            allAttributes.addAll(permissions.getAllAttributes(ejbViewDescription.getMethodIntf(), classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes()));\n            allAttributes.addAll(permissions.getAllAttributes(MethodIntf.BEAN, classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes()));\n        }\n\n\n        //we do not add the security interceptor if there is no security information\n        if (ejbMethodSecurityMetaData != null) {\n\n            if (!annotations &&\n                    !ejbMethodSecurityMetaData.isDenyAll() &&\n                    !ejbMethodSecurityMetaData.isPermitAll()) {\n                //roles are additive when defined in the deployment descriptor\n                final Set<String> rolesAllowed = new HashSet<String>();\n                for (EJBMethodSecurityAttribute attr : allAttributes) {\n                    rolesAllowed.addAll(attr.getRolesAllowed());\n                }\n                ejbMethodSecurityMetaData = EJBMethodSecurityAttribute.rolesAllowed(rolesAllowed);\n            }\n\n            final Interceptor authorizationInterceptor = new AuthorizationInterceptor(ejbMethodSecurityMetaData, viewClassName, viewMethod);\n            viewConfiguration.addViewInterceptor(viewMethod, new ImmediateInterceptorFactory(authorizationInterceptor), InterceptorOrder.View.EJB_SECURITY_AUTHORIZATION_INTERCEPTOR);\n            return true;\n        }\n        return false;\n    }","id":45817,"modified_method":"private boolean handlePermissions(String contextID, ComponentConfiguration componentConfiguration, ViewConfiguration viewConfiguration, DeploymentReflectionIndex deploymentReflectionIndex, String viewClassName, EJBViewDescription ejbViewDescription, Method viewMethod, ApplicableMethodInformation<EJBMethodSecurityAttribute> permissions, boolean annotations) {\n        EJBMethodSecurityAttribute ejbMethodSecurityMetaData = permissions.getViewAttribute(ejbViewDescription.getMethodIntf(), viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes());\n        final List<EJBMethodSecurityAttribute> allAttributes = new ArrayList<EJBMethodSecurityAttribute>();\n        allAttributes.addAll(permissions.getAllAttributes(ejbViewDescription.getMethodIntf(), viewMethod.getDeclaringClass().getName(), viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes()));\n\n        if (ejbMethodSecurityMetaData == null) {\n            ejbMethodSecurityMetaData = permissions.getViewAttribute(MethodIntf.BEAN, viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes());\n        }\n        allAttributes.addAll(permissions.getAllAttributes(MethodIntf.BEAN, viewMethod.getDeclaringClass().getName(), viewMethod.getName(), MethodIdentifier.getIdentifierForMethod(viewMethod).getParameterTypes()));\n\n        final Method classMethod = ClassReflectionIndexUtil.findMethod(deploymentReflectionIndex, componentConfiguration.getComponentClass(), viewMethod);\n        if (ejbMethodSecurityMetaData == null) {\n            //if this is null we try with the corresponding bean method\n            if (classMethod != null) {\n                ejbMethodSecurityMetaData = permissions.getAttribute(ejbViewDescription.getMethodIntf(), classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes());\n                if (ejbMethodSecurityMetaData == null) {\n                    ejbMethodSecurityMetaData = permissions.getAttribute(MethodIntf.BEAN, classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes());\n\n                }\n            }\n        }\n        if (classMethod != null) {\n            allAttributes.addAll(permissions.getAllAttributes(ejbViewDescription.getMethodIntf(), classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes()));\n            allAttributes.addAll(permissions.getAllAttributes(MethodIntf.BEAN, classMethod.getDeclaringClass().getName(), classMethod.getName(), MethodIdentifier.getIdentifierForMethod(classMethod).getParameterTypes()));\n        }\n\n\n        //we do not add the security interceptor if there is no security information\n        if (ejbMethodSecurityMetaData != null) {\n\n            if (!annotations &&\n                    !ejbMethodSecurityMetaData.isDenyAll() &&\n                    !ejbMethodSecurityMetaData.isPermitAll()) {\n                //roles are additive when defined in the deployment descriptor\n                final Set<String> rolesAllowed = new HashSet<String>();\n                for (EJBMethodSecurityAttribute attr : allAttributes) {\n                    rolesAllowed.addAll(attr.getRolesAllowed());\n                }\n                ejbMethodSecurityMetaData = EJBMethodSecurityAttribute.rolesAllowed(rolesAllowed);\n            }\n\n            final Interceptor authorizationInterceptor = new AuthorizationInterceptor(ejbMethodSecurityMetaData, viewClassName, viewMethod, contextID);\n            viewConfiguration.addViewInterceptor(viewMethod, new ImmediateInterceptorFactory(authorizationInterceptor), InterceptorOrder.View.EJB_SECURITY_AUTHORIZATION_INTERCEPTOR);\n            return true;\n        }\n        return false;\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        final DeploymentClassIndex classIndex = deploymentUnit.getAttachment(Attachments.CLASS_INDEX);\n\n        final EJBComponentDescription component = EJBComponentDescription.class.cast(description);\n\n        final EjbJaccConfig config = new EjbJaccConfig();\n        context.getDeploymentUnit().addToAttachmentList(EjbDeploymentAttachmentKeys.JACC_PERMISSIONS, config);\n\n        String ejbClassName = component.getEJBClassName();\n        String ejbName = component.getEJBName();\n        // Process the exclude-list and method-permission\n        // check class level\n        boolean denyOnAllViews = true;\n        boolean permitOnAllViews = true;\n        List<EJBMethodPermission> permissions = new ArrayList<EJBMethodPermission>();\n        List<EJBMethodPermission> uncheckedPermissions = new ArrayList<EJBMethodPermission>();\n        final ApplicableMethodInformation<EJBMethodSecurityAttribute> perms = component.getDescriptorMethodPermissions();\n        for (ViewDescription view : component.getViews()) {\n\n            String viewClassName = view.getViewClassName();\n            final ClassIndex viewClass;\n            try {\n                viewClass = classIndex.classIndex(viewClassName);\n            } catch (ClassNotFoundException e) {\n                throw EjbMessages.MESSAGES.failToLoadEjbViewClass(e);\n            }\n            MethodIntf methodIntf = ((EJBViewDescription) view).getMethodIntf();\n            MethodInterfaceType type = getMethodInterfaceType(methodIntf);\n            EJBMethodSecurityAttribute classLevel = perms.getClassLevelAttribute(ejbClassName);\n            if (classLevel != null && !classLevel.isDenyAll()) {\n                denyOnAllViews = false;\n            } else {\n                EJBMethodPermission p = new EJBMethodPermission(ejbName, null, type.name(), null);\n                permissions.add(p);\n            }\n            if (classLevel != null && !classLevel.isPermitAll()) {\n                permitOnAllViews = false;\n            } else {\n                EJBMethodPermission p = new EJBMethodPermission(ejbName, null, type.name(), null);\n                uncheckedPermissions.add(p);\n            }\n            if (classLevel != null) {\n                for (String role : classLevel.getRolesAllowed()) {\n                    config.addRole(role, new EJBMethodPermission(ejbName, null, null, null));\n                }\n            }\n\n            for (Method method : viewClass.getClassMethods()) {\n                final MethodIdentifier identifier = MethodIdentifier.getIdentifierForMethod(method);\n                EJBMethodSecurityAttribute methodLevel = component.getDescriptorMethodPermissions().getAttribute(methodIntf, method.getDeclaringClass().getName(), method.getName(), identifier.getParameterTypes());\n                // check method level\n                if (methodLevel == null) {\n                    methodLevel = component.getAnnotationMethodPermissions().getAttribute(methodIntf, method.getDeclaringClass().getName(), method.getName(), identifier.getParameterTypes());\n                    if (methodLevel == null) {\n                        continue;\n                    }\n                }\n                EJBMethodPermission p = new EJBMethodPermission(ejbName, identifier.getName(), type.name(), identifier.getParameterTypes());\n\n                if (methodLevel.isDenyAll()) {\n                    config.addDeny(p);\n                }\n                if (methodLevel.isPermitAll()) {\n                    config.addPermit(p);\n                }\n                for (String role : methodLevel.getRolesAllowed()) {\n                    config.addRole(role, p);\n                }\n            }\n        }\n        // if deny is on all views, we add permission with null as the interface\n        if (denyOnAllViews) {\n            permissions = new ArrayList<EJBMethodPermission>();\n            permissions.add(new EJBMethodPermission(ejbName, null, null, null));\n        }\n\n        // add exclude-list permissions\n        for (EJBMethodPermission ejbMethodPermission : permissions) {\n            config.addDeny(ejbMethodPermission);\n        }\n\n        // if permit is on all views, we add permission with null as the interface\n        if (permitOnAllViews) {\n            uncheckedPermissions = new ArrayList<EJBMethodPermission>();\n            uncheckedPermissions.add(new EJBMethodPermission(ejbName, null, null, null));\n        }\n\n        // add method-permission permissions\n        for (EJBMethodPermission ejbMethodPermission : uncheckedPermissions) {\n            config.addPermit(ejbMethodPermission);\n        }\n\n        // Process the security-role-ref\n        Map<String, Collection<String>> securityRoles = component.getSecurityRoleLinks();\n        for (Map.Entry<String, Collection<String>> entry : securityRoles.entrySet()) {\n            String roleName = entry.getKey();\n            for (String roleLink : entry.getValue()) {\n                EJBRoleRefPermission p = new EJBRoleRefPermission(ejbName, roleName);\n                config.addRole(roleLink, p);\n            }\n        }\n\n        /*\n        * Special handling of stateful session bean getEJBObject due how the stateful session handles acquire the\n        * proxy by sending an invocation to the ejb container.\n        */\n        if (component instanceof SessionBeanComponentDescription) {\n            SessionBeanComponentDescription session = SessionBeanComponentDescription.class.cast(component);\n            if (session.isStateful()) {\n                EJBMethodPermission p = new EJBMethodPermission(ejbName, \"getEJBObject\", \"Home\", null);\n                config.addPermit(p);\n            }\n        }\n    }","id":45818,"modified_method":"@Override\n    public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        final DeploymentReflectionIndex reflectionIndex = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);\n        final EJBComponentDescription ejbComponentDescription = EJBComponentDescription.class.cast(description);\n        final EjbJaccConfig ejbJaccConfig = new EjbJaccConfig();\n        context.getDeploymentUnit().addToAttachmentList(EjbDeploymentAttachmentKeys.JACC_PERMISSIONS, ejbJaccConfig);\n\n        // process the method permissions.\n        for (final ViewConfiguration viewConfiguration : configuration.getViews()) {\n            final List<Method> viewMethods = viewConfiguration.getProxyFactory().getCachedMethods();\n            for (final Method viewMethod : viewMethods) {\n                if (!Modifier.isPublic(viewMethod.getModifiers()) || viewMethod.getDeclaringClass() == WriteReplaceInterface.class) {\n                    continue;\n                }\n                final EJBViewConfiguration ejbViewConfiguration = EJBViewConfiguration.class.cast(viewConfiguration);\n                // try to create permissions using the descriptor metadata first.\n                ApplicableMethodInformation<EJBMethodSecurityAttribute> permissions = ejbComponentDescription.getDescriptorMethodPermissions();\n                boolean createdPerms = this.createPermissions(ejbJaccConfig, ejbComponentDescription, ejbViewConfiguration, viewMethod, reflectionIndex, permissions);\n                // no permissions created using the descriptor metadata - try to use annotation metadata.\n                if (!createdPerms) {\n                    permissions = ejbComponentDescription.getAnnotationMethodPermissions();\n                    createPermissions(ejbJaccConfig, ejbComponentDescription, ejbViewConfiguration, viewMethod, reflectionIndex, permissions);\n                }\n            }\n        }\n\n        // process the security-role-ref.\n        Map<String, Collection<String>> securityRoles = ejbComponentDescription.getSecurityRoleLinks();\n        for (Map.Entry<String, Collection<String>> entry : securityRoles.entrySet()) {\n            String roleName = entry.getKey();\n            for (String roleLink : entry.getValue()) {\n                EJBRoleRefPermission p = new EJBRoleRefPermission(ejbComponentDescription.getEJBName(), roleName);\n                ejbJaccConfig.addRole(roleLink, p);\n            }\n        }\n\n        // special handling of stateful session bean getEJBObject due how the stateful session handles acquire the\n        // proxy by sending an invocation to the ejb container.\n        if (ejbComponentDescription instanceof SessionBeanComponentDescription) {\n            SessionBeanComponentDescription session = SessionBeanComponentDescription.class.cast(ejbComponentDescription);\n            if (session.isStateful()) {\n                EJBMethodPermission p = new EJBMethodPermission(ejbComponentDescription.getEJBName(), \"getEJBObject\", \"Home\", null);\n                ejbJaccConfig.addPermit(p);\n            }\n        }\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(Request request, Response response) throws IOException, ServletException {\n        activeRequest.set(request);\n\n        Session session = null;\n        // Get the request caller which could be set due to SSO\n        Principal caller = request.getPrincipal();\n        // The cached web container principal\n        JBossGenericPrincipal principal = null;\n        HttpSession hsession = request.getSession(false);\n\n        WebLogger.WEB_SECURITY_LOGGER.tracef(\"Begin invoke, caller=\" + caller);\n\n        boolean createdSecurityContext = false;\n        SecurityContext sc = SecurityActions.getSecurityContext();\n        if (sc == null) {\n            createdSecurityContext = true;\n            sc = SecurityActions.createSecurityContext(securityDomain);\n            SecurityActions.setSecurityContextOnAssociation(sc);\n        }\n\n        try {\n            Wrapper servlet = null;\n            try {\n                servlet = request.getWrapper();\n                if (servlet != null) {\n                    String name = servlet.getName();\n                    RunAsIdentityMetaData identity = runAsIdentity.get(name);\n                    RunAsIdentity runAsIdentity = null;\n                    if (identity != null) {\n                        WebLogger.WEB_SECURITY_LOGGER.tracef(name + \", runAs: \" + identity);\n                        runAsIdentity = new RunAsIdentity(identity.getRoleName(), identity.getPrincipalName(),\n                                identity.getRunAsRoles());\n                    }\n                    SecurityActions.pushRunAsIdentity(runAsIdentity);\n                }\n\n                // If there is a session, get the tomcat session for the principal\n                Manager manager = container.getManager();\n                if (manager != null && hsession != null) {\n                    try {\n                        session = manager.findSession(hsession.getId());\n                    } catch (IOException ignore) {\n                    }\n                }\n\n                if (caller == null || !(caller instanceof JBossGenericPrincipal)) {\n                    // Look to the session for the active caller security context\n                    if (session != null) {\n                        principal = (JBossGenericPrincipal) session.getPrincipal();\n                    }\n                    if (principal == null) {\n                        Session sessionInternal = request.getSessionInternal(false);\n                        if (sessionInternal != null) {\n                            principal = (JBossGenericPrincipal) sessionInternal.getNote(Constants.FORM_PRINCIPAL_NOTE);\n                        }\n                    }\n                } else {\n                    // Use the request principal as the caller identity\n                    principal = (JBossGenericPrincipal) caller;\n                }\n\n                // If there is a caller use this as the identity to propagate\n                if (principal != null) {\n                    WebLogger.WEB_SECURITY_LOGGER.tracef(\"Restoring principal info from cache\");\n                    if (createdSecurityContext) {\n                        sc.getUtil().createSubjectInfo(new SimplePrincipal(principal.getName()), principal.getCredentials(),\n                                principal.getSubject());\n                    }\n                }\n            } catch (Throwable e) {\n                //TODO:decide whether to log this as info or warn\n                WebLogger.WEB_SECURITY_LOGGER.debug(\"Failed to determine servlet\", e);\n            }\n            // set JACC contextID\n            PolicyContext.setContextID(contextId);\n\n            // Perform the request\n            getNext().invoke(request, response);\n            if (servlet != null) {\n                SecurityActions.popRunAsIdentity();\n            }\n        } finally {\n            WebLogger.WEB_SECURITY_LOGGER.tracef(\"End invoke, caller=\" + caller);\n            SecurityActions.clearSecurityContext();\n            SecurityRolesAssociation.setSecurityRoles(null);\n            PolicyContext.setContextID(null);\n            activeRequest.set(null);\n        }\n    }","id":45819,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(Request request, Response response) throws IOException, ServletException {\n        activeRequest.set(request);\n\n        Session session = null;\n        // Get the request caller which could be set due to SSO\n        Principal caller = request.getPrincipal();\n        // The cached web container principal\n        JBossGenericPrincipal principal = null;\n        HttpSession hsession = request.getSession(false);\n\n        WebLogger.WEB_SECURITY_LOGGER.tracef(\"Begin invoke, caller=\" + caller);\n\n        boolean createdSecurityContext = false;\n        SecurityContext sc = SecurityActions.getSecurityContext();\n        if (sc == null) {\n            createdSecurityContext = true;\n            sc = SecurityActions.createSecurityContext(securityDomain);\n            SecurityActions.setSecurityContextOnAssociation(sc);\n        }\n\n        String previousContextID = null;\n        try {\n            Wrapper servlet = null;\n            try {\n                servlet = request.getWrapper();\n                if (servlet != null) {\n                    String name = servlet.getName();\n                    RunAsIdentityMetaData identity = runAsIdentity.get(name);\n                    RunAsIdentity runAsIdentity = null;\n                    if (identity != null) {\n                        WebLogger.WEB_SECURITY_LOGGER.tracef(name + \", runAs: \" + identity);\n                        runAsIdentity = new RunAsIdentity(identity.getRoleName(), identity.getPrincipalName(),\n                                identity.getRunAsRoles());\n                    }\n                    SecurityActions.pushRunAsIdentity(runAsIdentity);\n                }\n\n                // If there is a session, get the tomcat session for the principal\n                Manager manager = container.getManager();\n                if (manager != null && hsession != null) {\n                    try {\n                        session = manager.findSession(hsession.getId());\n                    } catch (IOException ignore) {\n                    }\n                }\n\n                if (caller == null || !(caller instanceof JBossGenericPrincipal)) {\n                    // Look to the session for the active caller security context\n                    if (session != null) {\n                        principal = (JBossGenericPrincipal) session.getPrincipal();\n                    }\n                    if (principal == null) {\n                        Session sessionInternal = request.getSessionInternal(false);\n                        if (sessionInternal != null) {\n                            principal = (JBossGenericPrincipal) sessionInternal.getNote(Constants.FORM_PRINCIPAL_NOTE);\n                        }\n                    }\n                } else {\n                    // Use the request principal as the caller identity\n                    principal = (JBossGenericPrincipal) caller;\n                }\n\n                // If there is a caller use this as the identity to propagate\n                if (principal != null) {\n                    WebLogger.WEB_SECURITY_LOGGER.tracef(\"Restoring principal info from cache\");\n                    if (createdSecurityContext) {\n                        sc.getUtil().createSubjectInfo(new SimplePrincipal(principal.getName()), principal.getCredentials(),\n                                principal.getSubject());\n                    }\n                }\n            } catch (Throwable e) {\n                //TODO:decide whether to log this as info or warn\n                WebLogger.WEB_SECURITY_LOGGER.debug(\"Failed to determine servlet\", e);\n            }\n            // set JACC contextID\n            previousContextID = setContextID(contextId);\n\n            // Perform the request\n            getNext().invoke(request, response);\n            if (servlet != null) {\n                SecurityActions.popRunAsIdentity();\n            }\n        } finally {\n            WebLogger.WEB_SECURITY_LOGGER.tracef(\"End invoke, caller=\" + caller);\n            SecurityActions.clearSecurityContext();\n            SecurityRolesAssociation.setSecurityRoles(null);\n            setContextID(previousContextID);\n            activeRequest.set(null);\n        }\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n        if (component instanceof EJBComponent == false) {\n            throw MESSAGES.unexpectedComponent(component, EJBComponent.class);\n        }\n        final EJBComponent ejbComponent = (EJBComponent) component;\n        final ServerSecurityManager securityManager = ejbComponent.getSecurityManager();\n        final EJBSecurityMetaData securityMetaData = ejbComponent.getSecurityMetaData();\n        final String securityDomain = securityMetaData.getSecurityDomain();\n        if (securityDomain == null) {\n            throw MESSAGES.invalidSecurityForDomainSet(ejbComponent.getComponentName());\n        }\n        if (ROOT_LOGGER.isTraceEnabled()) {\n            ROOT_LOGGER.trace(\"Using security domain: \" + securityDomain + \" for EJB \" + ejbComponent.getComponentName());\n        }\n        final String runAs = securityMetaData.getRunAs();\n        // TODO - We should do something with DeclaredRoles although it never has much meaning in JBoss AS\n        final String runAsPrincipal = securityMetaData.getRunAsPrincipal();\n        final SecurityRolesMetaData securityRoles = securityMetaData.getSecurityRoles();\n        Set<String> extraRoles = null;\n        Map<String,Set<String>> principalVsRolesMap = null;\n        if (securityRoles != null && runAsPrincipal != null) {\n            principalVsRolesMap = securityRoles.getPrincipalVersusRolesMap();\n            extraRoles = securityRoles.getSecurityRoleNamesByPrincipal(runAsPrincipal);\n        }\n        SecurityContextInterceptorHolder holder = new SecurityContextInterceptorHolder();\n        holder.setSecurityManager(securityManager).setSecurityDomain(securityDomain)\n        .setRunAs(runAs).setRunAsPrincipal(runAsPrincipal)\n        .setExtraRoles(extraRoles).setPrincipalVsRolesMap(principalVsRolesMap);\n\n        return new SecurityContextInterceptor(holder);\n    }","id":45820,"modified_method":"@Override\n    protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n        if (component instanceof EJBComponent == false) {\n            throw MESSAGES.unexpectedComponent(component, EJBComponent.class);\n        }\n        final EJBComponent ejbComponent = (EJBComponent) component;\n        final ServerSecurityManager securityManager = ejbComponent.getSecurityManager();\n        final EJBSecurityMetaData securityMetaData = ejbComponent.getSecurityMetaData();\n        final String securityDomain = securityMetaData.getSecurityDomain();\n        if (securityDomain == null) {\n            throw MESSAGES.invalidSecurityForDomainSet(ejbComponent.getComponentName());\n        }\n        if (ROOT_LOGGER.isTraceEnabled()) {\n            ROOT_LOGGER.trace(\"Using security domain: \" + securityDomain + \" for EJB \" + ejbComponent.getComponentName());\n        }\n        final String runAs = securityMetaData.getRunAs();\n        // TODO - We should do something with DeclaredRoles although it never has much meaning in JBoss AS\n        final String runAsPrincipal = securityMetaData.getRunAsPrincipal();\n        final SecurityRolesMetaData securityRoles = securityMetaData.getSecurityRoles();\n        Set<String> extraRoles = null;\n        Map<String,Set<String>> principalVsRolesMap = null;\n        if (securityRoles != null) {\n            principalVsRolesMap = securityRoles.getPrincipalVersusRolesMap();\n            if (runAsPrincipal != null)\n                extraRoles = securityRoles.getSecurityRoleNamesByPrincipal(runAsPrincipal);\n        }\n        SecurityContextInterceptorHolder holder = new SecurityContextInterceptorHolder();\n        holder.setSecurityManager(securityManager).setSecurityDomain(securityDomain)\n        .setRunAs(runAs).setRunAsPrincipal(runAsPrincipal)\n        .setExtraRoles(extraRoles).setPrincipalVsRolesMap(principalVsRolesMap);\n\n        return new SecurityContextInterceptor(holder);\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     *\n     * @param mappedRoles The principal vs roles mapping (if any). Can be null.\n     * @param roleLinks The role link map where the key is a alias role name and the value is the collection of\n     *                  role names, that alias represents. Can be null.\n     * @param roleNames The role names for which the caller is being checked for\n     * @return true if the user is in <b>any<\/b> one of the <code>roleNames<\/code>. Else returns false\n     */\n    public boolean isCallerInRole(final Object incommingMappedRoles, final Map<String, Collection<String>> roleLinks,\n                                  final String... roleNames) {\n        final SecurityRolesMetaData mappedRoles = (SecurityRolesMetaData) incommingMappedRoles;\n        final SecurityContext securityContext = doPrivileged(securityContext());\n        if (securityContext == null) {\n            return false;\n        }\n\n        RoleGroup roleGroup = null;\n\n        RunAs runAs = securityContext.getIncomingRunAs();\n        if (runAs != null && runAs instanceof RunAsIdentity) {\n            RunAsIdentity runAsIdentity = (RunAsIdentity) runAs;\n            roleGroup = runAsIdentity.getRunAsRolesAsRoleGroup();\n        } else {\n            AuthorizationManager am = securityContext.getAuthorizationManager();\n            SecurityContextCallbackHandler scb = new SecurityContextCallbackHandler(securityContext);\n\n            roleGroup = am.getSubjectRoles(securityContext.getSubjectInfo().getAuthenticatedSubject(), scb);\n        }\n\n        List<Role> roles = roleGroup.getRoles();\n\n        // TODO - Review most performant way.\n        Set<String> requiredRoles = new HashSet<String>();\n        for (String current : roleNames) {\n            requiredRoles.add(current);\n        }\n        Set<String> actualRoles = new HashSet<String>();\n        for (Role current : roles) {\n            actualRoles.add(current.getRoleName());\n        }\n        // add mapped roles\n        if (mappedRoles != null) {\n            Principal callerPrincipal = getCallerPrincipal();\n            Set<String> mapped = mappedRoles.getSecurityRoleNamesByPrincipal(callerPrincipal.getName());\n            if (mapped != null) {\n                actualRoles.addAll(mapped);\n            }\n        }\n        // if the actual roles matches any of the required roles, then return true\n        if (!Collections.disjoint(requiredRoles, actualRoles)) {\n            return true;\n        }\n        // we did not have a match between the required roles and the actual roles.\n        // let's now get the alias role names (if any) for each of the actual role\n        // and see if any of those aliases of the actual roles matches the required roles\n        if (roleLinks != null) {\n            for (final String actualRole : actualRoles) {\n                // get aliases (if any) for actual role\n                final Set<String> aliases = this.getRoleAliases(actualRole, roleLinks);\n                // if there's a match between the required role and an alias of an actual role, then\n                // return true indicating that the caller is in one of the required roles\n                if (!Collections.disjoint(requiredRoles, aliases)) {\n                    return true;\n                }\n            }\n        }\n        // caller is not in any of the required roles\n        return false;\n    }","id":45821,"modified_method":"/**\n     *\n     * @param incommingMappedRoles The principal vs roles mapping (if any). Can be null.\n     * @param roleLinks The role link map where the key is a alias role name and the value is the collection of\n     *                  role names, that alias represents. Can be null.\n     * @param roleNames The role names for which the caller is being checked for\n     * @return true if the user is in <b>any<\/b> one of the <code>roleNames<\/code>. Else returns false\n     */\n    public boolean isCallerInRole(final Object incommingMappedRoles, final Map<String, Collection<String>> roleLinks,\n                                  final String... roleNames) {\n        final SecurityRolesMetaData mappedRoles = (SecurityRolesMetaData) incommingMappedRoles;\n        final SecurityContext securityContext = doPrivileged(securityContext());\n        if (securityContext == null) {\n            return false;\n        }\n\n        RoleGroup roleGroup = null;\n\n        RunAs runAs = securityContext.getIncomingRunAs();\n        if (runAs != null && runAs instanceof RunAsIdentity) {\n            RunAsIdentity runAsIdentity = (RunAsIdentity) runAs;\n            roleGroup = runAsIdentity.getRunAsRolesAsRoleGroup();\n        } else {\n            AuthorizationManager am = securityContext.getAuthorizationManager();\n            SecurityContextCallbackHandler scb = new SecurityContextCallbackHandler(securityContext);\n\n            roleGroup = am.getSubjectRoles(securityContext.getSubjectInfo().getAuthenticatedSubject(), scb);\n        }\n\n        List<Role> roles = roleGroup.getRoles();\n\n        // TODO - Review most performant way.\n        Set<String> requiredRoles = new HashSet<String>();\n        for (String current : roleNames) {\n            requiredRoles.add(current);\n        }\n        Set<String> actualRoles = new HashSet<String>();\n        for (Role current : roles) {\n            actualRoles.add(current.getRoleName());\n        }\n        // add mapped roles\n        if (mappedRoles != null) {\n            Principal callerPrincipal = getCallerPrincipal();\n            Set<String> mapped = mappedRoles.getSecurityRoleNamesByPrincipal(callerPrincipal.getName());\n            if (mapped != null) {\n                actualRoles.addAll(mapped);\n            }\n        }\n        // if the actual roles matches any of the required roles, then return true\n        if (!Collections.disjoint(requiredRoles, actualRoles)) {\n            return true;\n        }\n        // we did not have a match between the required roles and the actual roles.\n        // let's now get the alias role names (if any) for each of the actual role\n        // and see if any of those aliases of the actual roles matches the required roles\n        if (roleLinks != null) {\n            for (final String actualRole : actualRoles) {\n                // get aliases (if any) for actual role\n                final Set<String> aliases = this.getRoleAliases(actualRole, roleLinks);\n                // if there's a match between the required role and an alias of an actual role, then\n                // return true indicating that the caller is in one of the required roles\n                if (!Collections.disjoint(requiredRoles, aliases)) {\n                    return true;\n                }\n            }\n        }\n        // caller is not in any of the required roles\n        return false;\n    }","commit_id":"7edc3b71e22f64debf07f2ce1fc7d4dfc8666a5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Create and add new blackboard artifacts, attributes, and types\n     *\n     * @param results\n     * @param dataSource\n     */\n    private static void importArtifacts(Content dataSource, ExternalResults results) {\n        for (ExternalResults.Artifact art : results.getArtifacts()) {\n            try {\n                // Get the artifact type id if defined, or create a new \n                // user-defined artifact type.\n                int artifactTypeId;\n                BlackboardArtifact.ARTIFACT_TYPE stdArtType = isStandardArtifactType(art.getType());\n                if (stdArtType != null) {\n                    artifactTypeId = stdArtType.getTypeID();\n                } else {\n                    artifactTypeId = Case.getCurrentCase().getSleuthkitCase().addArtifactType(art.getType(), art.getType());\n                }\n\n                Collection<BlackboardAttribute> bbAttributes = new ArrayList<>();\n                for (ExternalResults.ArtifactAttribute attr : art.getAttributes()) {\n                    int bbAttrTypeId;\n                    BlackboardAttribute.ATTRIBUTE_TYPE stdAttrType = isStandardAttributeType(attr.getType());\n                    if (stdAttrType != null) {\n                        bbAttrTypeId = stdAttrType.getTypeID();\n                    } else {\n                        // assume it's user defined RJCTODO fix\n                        bbAttrTypeId = Case.getCurrentCase().getSleuthkitCase().addAttrType(attr.getType(), attr.getType());\n                    }\n\n                    BlackboardAttribute bbAttr = null;\n                    switch (attr.getValueType()) {\n                        case \"text\": //NON-NLS\n                            bbAttr = new BlackboardAttribute(bbAttrTypeId, attr.getSourceModule(), attr.getValue());\n                            break;\n                        case \"int32\": //NON-NLS\n                            int intValue = Integer.parseInt(attr.getValue());\n                            bbAttr = new BlackboardAttribute(bbAttrTypeId, attr.getSourceModule(), intValue);\n                            break;\n                        case \"int64\": //NON-NLS\n                            long longValue = Long.parseLong(attr.getValue());\n                            bbAttr = new BlackboardAttribute(bbAttrTypeId, attr.getSourceModule(), longValue);\n                            break;\n                        case \"double\": //NON-NLS\n                            double doubleValue = Double.parseDouble(attr.getValue());\n                            bbAttr = new BlackboardAttribute(bbAttrTypeId, attr.getSourceModule(), doubleValue);\n                            break;\n                        default:\n                            logger.log(Level.WARNING, \"Ignoring invalid attribute value type {0}\", attr.getValueType());\n                            break;\n                    }\n                    if (bbAttr != null) {\n                        bbAttributes.add(bbAttr);\n                    }\n                }\n\n                // Get associated localFile (if any) to use as the content obj to attach the artifact to\n                Content currContent = null;\n                if (art.getSourceFilePath().isEmpty()) {\n                    currContent = findFileInDatabase(art.getSourceFilePath());\n                }\n\n                // If no associated localFile, use current data source itself\n                if (currContent == null) {\n                    currContent = dataSource;\n                }\n\n                BlackboardArtifact bbArt = currContent.newArtifact(artifactTypeId);\n                bbArt.addAttributes(bbAttributes);\n                if (stdArtType != null) {\n                    IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(\"\", stdArtType)); //NON-NLS\n                }\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, ex.getLocalizedMessage());\n            }\n        }\n    }","id":45822,"modified_method":"private void importArtifacts(ExternalResults results) {\n        SleuthkitCase caseDb = Case.getCurrentCase().getSleuthkitCase();\n        for (ExternalResults.Artifact artifactData : results.getArtifacts()) {\n            try {\n                // Add the artifact to the case database.\n                boolean artifactTypeIsUserDefined = false;\n                int artifactTypeId = caseDb.getArtifactTypeIdIfExists(artifactData.getType());\n                if (artifactTypeId == -1) {\n                    artifactTypeId = caseDb.addArtifactType(artifactData.getType(), artifactData.getType());\n                    artifactTypeIsUserDefined = true;\n                }\n                Content sourceFile = findFile(results.getDataSource(), artifactData.getSourceFilePath());\n                BlackboardArtifact artifact = sourceFile.newArtifact(artifactTypeId);\n\n                // Add the artifact's attributes to the case database.\n                Collection<BlackboardAttribute> attributes = new ArrayList<>();\n                for (ExternalResults.ArtifactAttribute attributeData : artifactData.getAttributes()) {\n                    int attributeTypeId = caseDb.getAttrTypeIdIfExists(attributeData.getType());\n                    if (artifactTypeId == -1) {\n                        artifactTypeId = caseDb.addArtifactType(attributeData.getType(), attributeData.getType());\n                    }\n                    switch (attributeData.getValueType()) {\n                        case \"text\": //NON-NLS\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), attributeData.getValue()));\n                            break;\n                        case \"int32\": //NON-NLS\n                            int intValue = Integer.parseInt(attributeData.getValue());\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), intValue));\n                            break;\n                        case \"int64\": //NON-NLS\n                            long longValue = Long.parseLong(attributeData.getValue());\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), longValue));\n                            break;\n                        case \"double\": //NON-NLS\n                            double doubleValue = Double.parseDouble(attributeData.getValue());\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), doubleValue));\n                            break;\n                        default:\n                            String errorMessage = String.format(\"Could not import %s attribute, value = %s, for %s artifact from %s, unrecognized attribute value type: %s\", \n                                    attributeData.getType(), attributeData.getValue(), \n                                    artifactData.getType(), artifactData.getSourceFilePath(),\n                                    attributeData.getValueType());\n                            ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                            this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                            break;\n                    }\n                }\n                artifact.addAttributes(attributes);\n\n                if (!artifactTypeIsUserDefined) {\n                    IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(this.getClass().getSimpleName(), BlackboardArtifact.ARTIFACT_TYPE.fromID(artifactTypeId)));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import %s artifact from %s, error updating case database\", artifactData.getType(), artifactData.getSourceFilePath());\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static void importReports(ExternalResults results) {\n        for (ExternalResults.Report report : results.getReports()) {\n            try {\n                String reportPath = report.getLocalPath();\n                File reportFile = new File(reportPath);\n                if (reportFile.exists()) {\n                    // Try to get a relative local path\n                    String relPath = reportPath;\n                    Path pathTo = Paths.get(reportPath);\n                    if (pathTo.isAbsolute()) {\n                        Path pathBase = Paths.get(Case.getCurrentCase().getCaseDirectory());\n                        try {\n                            Path pathRelative = pathBase.relativize(pathTo);\n                            relPath = pathRelative.toString();\n                        } catch (IllegalArgumentException ex) {\n                            logger.log(Level.WARNING, \"Report file {0} path may be incorrect. The report record will still be added to the database.\", reportPath);\n                        }\n                    }\n\n                    if (!relPath.isEmpty()) {\n                        Case.getCurrentCase().getSleuthkitCase().addReport(relPath, report.getDisplayName());\n                    }\n                }\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, ex.getLocalizedMessage());\n            }\n        }\n    }","id":45823,"modified_method":"private void importReports(ExternalResults results) {\n        for (ExternalResults.Report report : results.getReports()) {\n            String reportPath = Case.getCurrentCase().getCaseDirectory() + File.separator + report.getLocalPath();\n            try {\n                File reportFile = new File(reportPath);\n                if (reportFile.exists()) {\n                    Case.getCurrentCase().getSleuthkitCase().addReport(reportPath, report.getDisplayName());\n                } else {\n                    String errorMessage = String.format(\"Could not import report at %s, file does not exist\", reportPath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import report at %s, error updating case database\", reportPath);\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static void importDerivedFiles(ExternalResults results) {\n        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n        for (ExternalResults.DerivedFile fileData : results.getDerivedFiles()) {\n            try {\n                String localPath = fileData.getLocalPath();\n                File localFile = new File(localPath); // RJCTODO: State/check ExternalResults contract that is not empty\n                if (!localFile.exists()) {\n                    AbstractFile parentFile = findFileInDatabase(fileData.getParentPath());\n                    if (parentFile == null) {\n                        String relativePath = getPathRelativeToCaseFolder(fileData.getLocalPath());\n                        DerivedFile derivedFile = fileManager.addDerivedFile(localFile.getName(), relativePath, localFile.length(),\n                                0, 0, 0, 0, // Do not currently have localFile times for derived files, should they provide via XML?\n                                true, parentFile, \"\", \"\", \"\", \"\");\n\n                        if (derivedFile != null) {\n                            IngestServices.getInstance().fireModuleContentEvent(new ModuleContentEvent(derivedFile));\n                        }\n                    } else {\n                        // RJCTODO: parent file not in database                                                     \n                    }\n                } else {\n                    // RJCTODO: file missing                         \n                }\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, ex.getLocalizedMessage());\n            }\n        }\n    }","id":45824,"modified_method":"private void importDerivedFiles(ExternalResults results) {\n        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n        for (ExternalResults.DerivedFile fileData : results.getDerivedFiles()) {\n            String filePath = Case.getCurrentCase().getCaseDirectory() + File.separator + fileData.getLocalPath();\n            try {\n                File localFile = new File(filePath);\n                if (!localFile.exists()) {\n                    AbstractFile parentFile = findFile(results.getDataSource(), fileData.getParentPath());\n                    if (parentFile != null) {\n                        DerivedFile derivedFile = fileManager.addDerivedFile(localFile.getName(), fileData.getLocalPath(), localFile.length(),\n                                0, 0, 0, 0, // Do not currently have file times for derived files from external processes.\n                                true, parentFile,\n                                \"\", \"\", \"\", \"\"); // Not currently providing derivation info for derived files from external processes.\n                        IngestServices.getInstance().fireModuleContentEvent(new ModuleContentEvent(derivedFile));\n                    } else {\n                        String errorMessage = String.format(\"Could not import derived file at %s, parent file %s not found\", filePath);\n                        ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                        this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                    }\n                } else {\n                    String errorMessage = String.format(\"Could not import derived file at %s, file does not exist\", filePath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import derived file at %s, error querying/updating case database\", filePath);\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseReports(Element root) {\n        NodeList reportsListNodes = root.getElementsByTagName(ExternalResultsXML.REPORTS_LIST_ELEM.toString());\n        for (int i = 0; i < reportsListNodes.getLength(); ++i) {\n            Element reportsListElem = (Element) reportsListNodes.item(i);\n            NodeList reportNodes = reportsListElem.getElementsByTagName(ExternalResultsXML.REPORT_ELEM.toString());\n            for (int j = 0; j < reportNodes.getLength(); ++j) {\n                Element reportElem = (Element) reportNodes.item(j);\n                String displayName = getChildElementContent(reportElem, ExternalResultsXML.DISPLAY_NAME_ELEM.toString());\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                String path = getChildElementContent(reportElem, ExternalResultsXML.LOCAL_PATH_ELEM.toString());\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                externalResults.addReport(displayName, path);\n            }\n        }\n    }","id":45825,"modified_method":"private void parseReports(Element root) {\n        NodeList reportsListNodes = root.getElementsByTagName(TagNames.REPORTS_LIST_ELEM.toString());\n        for (int i = 0; i < reportsListNodes.getLength(); ++i) {\n            Element reportsListElem = (Element) reportsListNodes.item(i);\n            NodeList reportNodes = reportsListElem.getElementsByTagName(TagNames.REPORT_ELEM.toString());\n            for (int j = 0; j < reportNodes.getLength(); ++j) {\n                Element reportElem = (Element) reportNodes.item(j);\n                String displayName = getChildElementContent(reportElem, TagNames.DISPLAY_NAME_ELEM.toString());\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                String path = getChildElementContent(reportElem, TagNames.LOCAL_PATH_ELEM.toString());\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                externalResults.addReport(displayName, path);\n            }\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseDerivedFiles(Element rootElement) {\n        NodeList derivedFilesListNodes = rootElement.getElementsByTagName(ExternalResultsXML.DERIVED_FILES_LIST_ELEM.toString());\n        for (int i = 0; i < derivedFilesListNodes.getLength(); ++i) {\n            Element derivedFilesListElem = (Element) derivedFilesListNodes.item(i);\n            NodeList derivedFileNodes = derivedFilesListElem.getElementsByTagName(ExternalResultsXML.DERIVED_FILE_ELEM.toString());\n            for (int j = 0; j < derivedFileNodes.getLength(); ++j) {\n                Element derivedFileElem = (Element) derivedFileNodes.item(j);\n                String path = getChildElementContent(derivedFileElem, ExternalResultsXML.LOCAL_PATH_ELEM.toString());\n                if (path.isEmpty()) {\n                    continue;\n                }\n                String parentPath = getChildElementContent((Element) derivedFileNodes.item(j), ExternalResultsXML.PARENT_PATH_ELEM.toString());\n                if (parentPath.isEmpty()) {\n                    continue;\n                }\n                externalResults.addDerivedFile(path, parentPath);\n            }\n        }\n    }","id":45826,"modified_method":"private void parseDerivedFiles(Element rootElement) {\n        NodeList derivedFilesListNodes = rootElement.getElementsByTagName(TagNames.DERIVED_FILES_LIST_ELEM.toString());\n        for (int i = 0; i < derivedFilesListNodes.getLength(); ++i) {\n            Element derivedFilesListElem = (Element) derivedFilesListNodes.item(i);\n            NodeList derivedFileNodes = derivedFilesListElem.getElementsByTagName(TagNames.DERIVED_FILE_ELEM.toString());\n            for (int j = 0; j < derivedFileNodes.getLength(); ++j) {\n                Element derivedFileElem = (Element) derivedFileNodes.item(j);\n                String path = getChildElementContent(derivedFileElem, TagNames.LOCAL_PATH_ELEM.toString());\n                if (path.isEmpty()) {\n                    continue;\n                }\n                String parentPath = getChildElementContent((Element) derivedFileNodes.item(j), TagNames.PARENT_PATH_ELEM.toString());\n                if (parentPath.isEmpty()) {\n                    continue;\n                }\n                externalResults.addDerivedFile(path, parentPath);\n            }\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseArtifactAttributes(final Element artifactElem, ExternalResults.Artifact artifact) {\n        NodeList attributeNodesList = artifactElem.getElementsByTagName(ExternalResultsXML.ATTRIBUTE_ELEM.toString());\n        for (int i = 0; i < attributeNodesList.getLength(); ++i) {\n            // Get the type of the artifact attribute.\n            Element attributeElem = (Element) attributeNodesList.item(i);\n            final String type = getElementAttributeValue(attributeElem, ExternalResultsXML.TYPE_ATTR.toString());\n            if (type.isEmpty()) {\n                continue;\n            }            \n            // Get the value of the artifact attribute.\n            Element valueElem = this.getChildElement(attributeElem, ExternalResultsXML.VALUE_ELEM.toString());\n            if (valueElem == null) {\n                continue;\n            }\n            final String value = valueElem.getTextContent();\n            if (value.isEmpty()) {\n                logger.log(Level.WARNING, \"Found {0} element that has no content in {1}\", new Object[]{\n                    ExternalResultsXML.VALUE_ELEM.toString(), this.resultsFilePath});\n                continue;\n            }            \n            // Get the value type.\n            String valueType = valueElem.getAttribute(ExternalResultsXML.TYPE_ATTR.toString());\n            if (valueType.isEmpty()) {\n                valueType = ExternalResultsXML.VALUE_TYPE_TEXT.toString();\n            }            \n            // Get the source module for the artifact attribute.\n            String sourceModule = \"\";\n            NodeList sourceModuleNodes = attributeElem.getElementsByTagName(ExternalResultsXML.SOURCE_MODULE_ELEM.toString());\n            if (sourceModuleNodes.getLength() > 0) {\n                if (sourceModuleNodes.getLength() > 1) {\n                    logger.log(Level.WARNING, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                        ExternalResultsXML.SOURCE_MODULE_ELEM.toString(),\n                        attributeElem.getTagName(),\n                        this.resultsFilePath}); // NON-NLS\n                }\n                Element srcModuleElem = (Element) sourceModuleNodes.item(0);\n                sourceModule = srcModuleElem.getTextContent();\n            }            \n            // Add the attribute to the artifact.\n            artifact.addAttribute(type, value, valueType, sourceModule);\n        }\n    }","id":45827,"modified_method":"private void parseArtifactAttributes(final Element artifactElem, ExternalResults.Artifact artifact) {\n        NodeList attributeNodesList = artifactElem.getElementsByTagName(TagNames.ATTRIBUTE_ELEM.toString());\n        for (int i = 0; i < attributeNodesList.getLength(); ++i) {\n            // Get the type of the artifact attribute.\n            Element attributeElem = (Element) attributeNodesList.item(i);\n            final String type = getElementAttributeValue(attributeElem, TagNames.TYPE_ATTR.toString());\n            if (type.isEmpty()) {\n                continue;\n            }\n            // Get the value of the artifact attribute.\n            Element valueElem = this.getChildElement(attributeElem, TagNames.VALUE_ELEM.toString());\n            if (valueElem == null) {\n                continue;\n            }\n            final String value = valueElem.getTextContent();\n            if (value.isEmpty()) {\n                String errorMessage = String.format(\"Found %s element that has no content in %s\",\n                        TagNames.VALUE_ELEM.toString(), this.resultsFilePath);\n                recordError(errorMessage);\n                continue;\n            }\n            // Get the value type.\n            String valueType = valueElem.getAttribute(TagNames.TYPE_ATTR.toString());\n            if (valueType.isEmpty()) {\n                valueType = TagNames.VALUE_TYPE_TEXT.toString();\n            }\n            // Get the source module for the artifact attribute.\n            String sourceModule = \"\";\n            NodeList sourceModuleNodes = attributeElem.getElementsByTagName(TagNames.SOURCE_MODULE_ELEM.toString());\n            if (sourceModuleNodes.getLength() > 0) {\n                if (sourceModuleNodes.getLength() > 1) {\n                    String errorMessage = String.format(\"Found multiple %s child elements for %s element in %s, ignoring all but first occurrence\",\n                            TagNames.SOURCE_MODULE_ELEM.toString(), attributeElem.getTagName(), this.resultsFilePath);\n                    recordError(errorMessage);\n                }\n                Element srcModuleElem = (Element) sourceModuleNodes.item(0);\n                sourceModule = srcModuleElem.getTextContent();\n            }\n            // Add the attribute to the artifact.\n            artifact.addAttribute(type, value, valueType, sourceModule);\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String getChildElementContent(Element parentElement, String childElementTagName) {\n        String content = \"\";\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            if (childNodes.getLength() > 1) {\n                logger.log(Level.WARNING, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                    childElementTagName,\n                    parentElement.getTagName(),\n                    this.resultsFilePath}); // NON-NLS\n            }\n            Element childElement = (Element) childNodes.item(0);\n            content = childElement.getTextContent();\n            if (content.isEmpty()) {\n                logger.log(Level.WARNING, \"Found {0} element with {1} child element that has no content in {2}\", new Object[]{\n                    parentElement.getTagName(),\n                    childElementTagName,\n                    this.resultsFilePath}); // NON-NLS\n            }\n        } else {\n            logger.log(Level.WARNING, \"Found {0} element missing {1} child element in {2}\", new Object[]{\n                parentElement.getTagName(),\n                childElementTagName,\n                this.resultsFilePath});  // NON-NLS   \n        }\n        return content;\n    }","id":45828,"modified_method":"private String getChildElementContent(Element parentElement, String childElementTagName) {\n        String content = \"\";\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            if (childNodes.getLength() > 1) {\n                logger.log(Level.SEVERE, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                    childElementTagName,\n                    parentElement.getTagName(),\n                    this.resultsFilePath}); // NON-NLS\n            }\n            Element childElement = (Element) childNodes.item(0);\n            content = childElement.getTextContent();\n            if (content.isEmpty()) {\n                logger.log(Level.SEVERE, \"Found {0} element with {1} child element that has no content in {2}\", new Object[]{\n                    parentElement.getTagName(),\n                    childElementTagName,\n                    this.resultsFilePath}); // NON-NLS\n            }\n        } else {\n            logger.log(Level.SEVERE, \"Found {0} element missing {1} child element in {2}\", new Object[]{\n                parentElement.getTagName(),\n                childElementTagName,\n                this.resultsFilePath});  // NON-NLS   \n        }\n        return content;\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Constructor.\n     *\n     * @param importFilePath Full path of the results file to be parsed.\n     */\n    ExternalResultsXMLParser(Content dataSource, String resultsFilePath) {\n        this.resultsFilePath = resultsFilePath;\n        externalResults = new ExternalResults(dataSource);\n    }","id":45829,"modified_method":"/**\n     * Constructor.\n     *\n     * @param importFilePath Full path of the results file to be parsed.\n     */\n    public ExternalResultsXMLParser(Content dataSource, String resultsFilePath) {\n        this.resultsFilePath = resultsFilePath;\n        externalResults = new ExternalResults(dataSource);\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String getElementAttributeValue(Element element, String attributeName) {\n        final String attributeValue = element.getAttribute(attributeName);\n        if (attributeValue.isEmpty()) {\n            logger.log(Level.WARNING, \"Found {0} element missing {1} attribute in {2}\", new Object[]{\n                element.getTagName(),\n                attributeName,\n                this.resultsFilePath});\n        }\n        return attributeValue;\n    }","id":45830,"modified_method":"private String getElementAttributeValue(Element element, String attributeName) {\n        final String attributeValue = element.getAttribute(attributeName);\n        if (attributeValue.isEmpty()) {\n            logger.log(Level.SEVERE, \"Found {0} element missing {1} attribute in {2}\", new Object[]{\n                element.getTagName(),\n                attributeName,\n                this.resultsFilePath});\n        }\n        return attributeValue;\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseArtifacts(final Element root) {\n        NodeList artifactsListNodes = root.getElementsByTagName(ExternalResultsXML.ARTIFACTS_LIST_ELEM.toString());\n        for (int i = 0; i < artifactsListNodes.getLength(); ++i) {\n            Element artifactsListElem = (Element) artifactsListNodes.item(i);\n            NodeList artifactNodes = artifactsListElem.getElementsByTagName(ExternalResultsXML.ARTIFACT_ELEM.toString());\n            for (int j = 0; j < artifactNodes.getLength(); ++j) {\n                Element artifactElem = (Element) artifactNodes.item(j);\n                final String type = getElementAttributeValue(artifactElem, ExternalResultsXML.TYPE_ATTR.toString());\n                if (!type.isEmpty()) {\n                    Element sourceFileElem = getChildElement(artifactElem, ExternalResultsXML.SOURCE_FILE_ELEM.toString());\n                    if (sourceFileElem != null) {\n                        final String sourceFilePath = this.getChildElementContent((Element) sourceFileElem, ExternalResultsXML.PATH_ELEM.toString());\n                        if (!sourceFilePath.isEmpty()) {\n                            ExternalResults.Artifact artifact = externalResults.addArtifact(type, sourceFilePath);\n                            parseArtifactAttributes(artifactElem, artifact);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":45831,"modified_method":"private void parseArtifacts(final Element root) {\n        NodeList artifactsListNodes = root.getElementsByTagName(TagNames.ARTIFACTS_LIST_ELEM.toString());\n        for (int i = 0; i < artifactsListNodes.getLength(); ++i) {\n            Element artifactsListElem = (Element) artifactsListNodes.item(i);\n            NodeList artifactNodes = artifactsListElem.getElementsByTagName(TagNames.ARTIFACT_ELEM.toString());\n            for (int j = 0; j < artifactNodes.getLength(); ++j) {\n                Element artifactElem = (Element) artifactNodes.item(j);\n                final String type = getElementAttributeValue(artifactElem, TagNames.TYPE_ATTR.toString());\n                if (!type.isEmpty()) {\n                    final String sourceFilePath = this.getChildElementContent((Element) artifactElem, TagNames.PATH_ELEM.toString());\n                    if (!sourceFilePath.isEmpty()) {\n                        ExternalResults.Artifact artifact = externalResults.addArtifact(type, sourceFilePath);\n                        parseArtifactAttributes(artifactElem, artifact);\n                    }\n                }\n            }\n        }\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private Element getChildElement(Element parentElement, String childElementTagName) {\n        Element childElem = null;\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            if (childNodes.getLength() > 1) {\n                logger.log(Level.WARNING, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                    childElementTagName,\n                    parentElement.getTagName(),\n                    this.resultsFilePath}); // NON-NLS\n            }\n        }\n        return childElem;\n    }","id":45832,"modified_method":"private Element getChildElement(Element parentElement, String childElementTagName) {\n        Element childElem = null;\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            if (childNodes.getLength() > 1) {\n                logger.log(Level.SEVERE, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                    childElementTagName,\n                    parentElement.getTagName(),\n                    this.resultsFilePath}); // NON-NLS\n            }\n        }\n        return childElem;\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public ExternalResults parse() {\n        try {\n            // Note that XMLUtil.loadDoc() logs a warning if the file does not\n            // conform to the XSD, but still returns a Document object. Until \n            // this behavior is improved, validation is still required. If \n            // XMLUtil.loadDoc() does return null, it failed to load the \n            // document and it logged the error.\n            final Document doc = XMLUtil.loadDoc(ExternalResultsXMLParser.class, this.resultsFilePath, XSD_FILE);\n            if (doc != null) {\n                final Element rootElem = doc.getDocumentElement();\n                if (rootElem != null && rootElem.getNodeName().equals(ExternalResultsXML.ROOT_ELEM.toString())) {\n                    parseArtifacts(rootElem);\n                    parseReports(rootElem);\n                    parseDerivedFiles(rootElem);\n                } else {\n                    logger.log(Level.SEVERE, \"Did not find {0} root element of {2}\", new Object[]{\n                        ExternalResultsXML.ROOT_ELEM.toString(), this.resultsFilePath}); //NON-NLS\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing \" + this.resultsFilePath, e); //NON-NLS\n        }\n        return externalResults;\n    }","id":45833,"modified_method":"@Override\n    public ExternalResults parse() {\n        try {\n            // Note that XMLUtil.loadDoc() logs a warning if the file does not\n            // conform to the XSD, but still returns a Document object. Until \n            // this behavior is improved, validation is still required. If \n            // XMLUtil.loadDoc() does return null, it failed to load the \n            // document and it logged the error.\n            final Document doc = XMLUtil.loadDoc(ExternalResultsXMLParser.class, this.resultsFilePath, XSD_FILE);\n            if (doc != null) {\n                final Element rootElem = doc.getDocumentElement();\n                if (rootElem != null && rootElem.getNodeName().equals(TagNames.ROOT_ELEM.toString())) {\n                    parseDerivedFiles(rootElem);\n                    parseArtifacts(rootElem);\n                    parseReports(rootElem);\n                } else {\n                    String errorMessage = String.format(\"Did not find %s root element of %s\", TagNames.ROOT_ELEM.toString(), this.resultsFilePath);\n                    recordError(errorMessage);\n                }\n            }\n        } catch (Exception ex) {\n            String errorMessage = String.format(\"Error parsing %s\", this.resultsFilePath);\n            recordError(errorMessage, ex);\n        }\n        return externalResults;\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void generateSimulatedResultsFile(String dataSourcePath, List<String> derivedFilePaths, String reportPath, String resultsFilePath) throws ParserConfigurationException, TransformerConfigurationException, TransformerException {\n        // Create the XML DOM document and the root element.\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        Document doc = docBuilder.newDocument();\n        Element rootElement = doc.createElement(ExternalResultsXML.ROOT_ELEM.toString());\n        doc.appendChild(rootElement);\n\n        // Add an artifacts list element to the root element.\n        Element artifactsListElement = doc.createElement(ExternalResultsXML.ARTIFACTS_LIST_ELEM.toString());\n        rootElement.appendChild(artifactsListElement);\n\n        // Add an artifact element to the artifacts list element. A standard \n        // artifact type is used as the required type attribute of this \n        // artifact element.\n        Element artifactElement = doc.createElement(ExternalResultsXML.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getLabel());\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add an optional file element to the artifact element, and add a path \n        // element to the file element. This is how a source file for an \n        // artifact is usually specified. If an artifact element has no file\n        // element, the data source is used as the default source file for the\n        // artifact.\n        Element fileElement = doc.createElement(ExternalResultsXML.SOURCE_FILE_ELEM.toString());\n        artifactElement.appendChild(fileElement);\n        Element pathElement = doc.createElement(ExternalResultsXML.PATH_ELEM.toString());\n        pathElement.setTextContent(dataSourcePath);\n        fileElement.appendChild(pathElement);\n\n        // Add an artifact attribute element to the artifact element. A standard \n        // artifact attribute type is used as the required type XML attribute of \n        // the artifact attribute element.\n        Element artifactAttrElement = doc.createElement(ExternalResultsXML.ATTRIBUTE_ELEM.toString());\n        artifactAttrElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ATTRIBUTE_TYPE.TSK_SET_NAME.getLabel());\n        artifactElement.appendChild(artifactAttrElement);\n\n        // Add the required value element to the artifact attribute element, \n        // with an optional type XML attribute of ExternalXML.VALUE_TYPE_TEXT, \n        // which is the default.        \n        Element artifactAttributeValueElement = doc.createElement(ExternalResultsXML.VALUE_ELEM.toString());\n        artifactAttributeValueElement.setTextContent(\"SampleInterestingFilesSet\");\n        artifactAttrElement.appendChild(artifactAttributeValueElement);\n\n        // Add an optional source module element to the artifct attribute \n        // element.\n        Element artifactAttrSourceElement = doc.createElement(ExternalResultsXML.SOURCE_MODULE_ELEM.toString());\n        artifactAttrSourceElement.setTextContent(moduleName);\n        artifactAttrElement.appendChild(artifactAttrSourceElement);\n\n        // Add an artifact element with a user-defined type. No file element is \n        // added to the artifact element, so the data source will be used as the \n        // default for the source file.\n        artifactElement = doc.createElement(ExternalResultsXML.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), \"SampleArtifactType\");\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add artifact attribute elements with user-defined types to the \n        // artifact element, adding value elements of assorted types.\n        for (int i = 0; i < 4; ++i) {\n            artifactAttrElement = doc.createElement(ExternalResultsXML.ATTRIBUTE_ELEM.toString());\n            artifactAttrElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), \"SampleArtifactAttributeType\");\n            artifactElement.appendChild(artifactAttrElement);\n            artifactAttributeValueElement = doc.createElement(ExternalResultsXML.VALUE_ELEM.toString());\n            switch (i) {\n                case 0:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ExternalResultsXML.VALUE_TYPE_TEXT.toString());\n                    artifactAttributeValueElement.setTextContent(\"One\");\n                    break;\n                case 1:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ExternalResultsXML.VALUE_TYPE_INT32.toString());\n                    artifactAttributeValueElement.setTextContent(\"2\");\n                    break;\n                case 2:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ExternalResultsXML.VALUE_TYPE_INT64.toString());\n                    artifactAttributeValueElement.setTextContent(\"3\");\n                    break;\n                case 3:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ExternalResultsXML.VALUE_TYPE_DOUBLE.toString());\n                    artifactAttributeValueElement.setTextContent(\"4.0\");\n                    break;\n            }\n            artifactAttrElement.appendChild(artifactAttributeValueElement);\n        }\n\n        // Add a reports list element to the root element.\n        Element reportsListElement = doc.createElement(ExternalResultsXML.REPORTS_LIST_ELEM.toString());\n        rootElement.appendChild(reportsListElement);\n\n        // Add a report element to the reports list element.\n        Element reportElement = doc.createElement(ExternalResultsXML.REPORT_ELEM.toString());\n        reportsListElement.appendChild(reportElement);\n\n        // Add the required display name element to the report element.\n        Element reportDisplayNameElement = doc.createElement(ExternalResultsXML.DISPLAY_NAME_ELEM.toString());\n        reportDisplayNameElement.setTextContent(\"Sample Report\");\n        reportElement.appendChild(reportDisplayNameElement);\n\n        // Add the required local path element to the report element.\n        Element reportPathElement = doc.createElement(ExternalResultsXML.LOCAL_PATH_ELEM.toString());\n        reportPathElement.setTextContent(reportPath);\n        reportElement.appendChild(reportPathElement);\n\n        // Add a derived files list element to the root element.\n        Element derivedFilesListElement = doc.createElement(ExternalResultsXML.DERIVED_FILES_LIST_ELEM.toString());\n        rootElement.appendChild(derivedFilesListElement);\n\n        // Add derived file elements to the derived files list element. Each \n        // file element gets a required absolute path element and one gets an \n        // optional parent file path element. If the parent file path is not \n        // supplied, the data source root directory is used as the default \n        // parent.\n        Element parentPathElement = null;\n        for (String filePath : derivedFilePaths) {\n            Element derivedFileElement = doc.createElement(ExternalResultsXML.DERIVED_FILE_ELEM.toString());\n            derivedFilesListElement.appendChild(derivedFileElement);\n            Element localPathElement = doc.createElement(ExternalResultsXML.LOCAL_PATH_ELEM.toString());\n            localPathElement.setTextContent(filePath);\n            derivedFileElement.appendChild(localPathElement);\n            if (parentPathElement == null) {\n                parentPathElement = doc.createElement(ExternalResultsXML.PARENT_PATH_ELEM.toString());\n                parentPathElement.setTextContent(dataSourcePath);\n                derivedFileElement.appendChild(parentPathElement);\n            }\n        }\n\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(resultsFilePath));\n        transformer.transform(source, result);\n    }","id":45834,"modified_method":"private void generateSimulatedResultsFile(String dataSourcePath, List<String> derivedFilePaths, String reportPath, String resultsFilePath) throws ParserConfigurationException, TransformerConfigurationException, TransformerException {\n        // Create the XML DOM document and the root element.\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        Document doc = docBuilder.newDocument();\n        Element rootElement = doc.createElement(ExternalResultsXMLParser.TagNames.ROOT_ELEM.toString());\n        doc.appendChild(rootElement);\n\n        // Add an artifacts list element to the root element.\n        Element artifactsListElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACTS_LIST_ELEM.toString());\n        rootElement.appendChild(artifactsListElement);\n\n        // Add an artifact element to the artifacts list element. A standard \n        // artifact type is used as the required type attribute of this \n        // artifact element.\n        Element artifactElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getLabel());\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add an optional file element to the artifact element, and add a path \n        // element to the file element. This is how a source file for an \n        // artifact is usually specified. If an artifact element has no file\n        // element, the data source is used as the default source file for the\n        // artifact.\n        Element fileElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_FILE_ELEM.toString());\n        artifactElement.appendChild(fileElement);\n        Element pathElement = doc.createElement(ExternalResultsXMLParser.TagNames.PATH_ELEM.toString());\n        pathElement.setTextContent(dataSourcePath);\n        fileElement.appendChild(pathElement);\n\n        // Add an artifact attribute element to the artifact element. A standard \n        // artifact attribute type is used as the required type XML attribute of \n        // the artifact attribute element.\n        Element artifactAttrElement = doc.createElement(ExternalResultsXMLParser.TagNames.ATTRIBUTE_ELEM.toString());\n        artifactAttrElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ATTRIBUTE_TYPE.TSK_SET_NAME.getLabel());\n        artifactElement.appendChild(artifactAttrElement);\n\n        // Add the required value element to the artifact attribute element, \n        // with an optional type XML attribute of ExternalXML.VALUE_TYPE_TEXT, \n        // which is the default.        \n        Element artifactAttributeValueElement = doc.createElement(ExternalResultsXMLParser.TagNames.VALUE_ELEM.toString());\n        artifactAttributeValueElement.setTextContent(\"SampleInterestingFilesSet\");\n        artifactAttrElement.appendChild(artifactAttributeValueElement);\n\n        // Add an optional source module element to the artifct attribute \n        // element.\n        Element artifactAttrSourceElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_MODULE_ELEM.toString());\n        artifactAttrSourceElement.setTextContent(moduleName);\n        artifactAttrElement.appendChild(artifactAttrSourceElement);\n\n        // Add an artifact element with a user-defined type. No file element is \n        // added to the artifact element, so the data source will be used as the \n        // default for the source file.\n        artifactElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), \"SampleArtifactType\");\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add artifact attribute elements with user-defined types to the \n        // artifact element, adding value elements of assorted types.\n        for (int i = 0; i < 4; ++i) {\n            artifactAttrElement = doc.createElement(ExternalResultsXMLParser.TagNames.ATTRIBUTE_ELEM.toString());\n            artifactAttrElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), \"SampleArtifactAttributeType\");\n            artifactElement.appendChild(artifactAttrElement);\n            artifactAttributeValueElement = doc.createElement(ExternalResultsXMLParser.TagNames.VALUE_ELEM.toString());\n            switch (i) {\n                case 0:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_TEXT.toString());\n                    artifactAttributeValueElement.setTextContent(\"One\");\n                    break;\n                case 1:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_INT32.toString());\n                    artifactAttributeValueElement.setTextContent(\"2\");\n                    break;\n                case 2:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_INT64.toString());\n                    artifactAttributeValueElement.setTextContent(\"3\");\n                    break;\n                case 3:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_DOUBLE.toString());\n                    artifactAttributeValueElement.setTextContent(\"4.0\");\n                    break;\n            }\n            artifactAttrElement.appendChild(artifactAttributeValueElement);\n        }\n\n        // Add a reports list element to the root element.\n        Element reportsListElement = doc.createElement(ExternalResultsXMLParser.TagNames.REPORTS_LIST_ELEM.toString());\n        rootElement.appendChild(reportsListElement);\n\n        // Add a report element to the reports list element.\n        Element reportElement = doc.createElement(ExternalResultsXMLParser.TagNames.REPORT_ELEM.toString());\n        reportsListElement.appendChild(reportElement);\n\n        // Add the required display name element to the report element.\n        Element reportDisplayNameElement = doc.createElement(ExternalResultsXMLParser.TagNames.DISPLAY_NAME_ELEM.toString());\n        reportDisplayNameElement.setTextContent(\"Sample Report\");\n        reportElement.appendChild(reportDisplayNameElement);\n\n        // Add the required local path element to the report element.\n        Element reportPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.LOCAL_PATH_ELEM.toString());\n        reportPathElement.setTextContent(reportPath);\n        reportElement.appendChild(reportPathElement);\n\n        // Add a derived files list element to the root element.\n        Element derivedFilesListElement = doc.createElement(ExternalResultsXMLParser.TagNames.DERIVED_FILES_LIST_ELEM.toString());\n        rootElement.appendChild(derivedFilesListElement);\n\n        // Add derived file elements to the derived files list element. Each \n        // file element gets a required absolute path element and one gets an \n        // optional parent file path element. If the parent file path is not \n        // supplied, the data source root directory is used as the default \n        // parent.\n        Element parentPathElement = null;\n        for (String filePath : derivedFilePaths) {\n            Element derivedFileElement = doc.createElement(ExternalResultsXMLParser.TagNames.DERIVED_FILE_ELEM.toString());\n            derivedFilesListElement.appendChild(derivedFileElement);\n            Element localPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.LOCAL_PATH_ELEM.toString());\n            localPathElement.setTextContent(filePath);\n            derivedFileElement.appendChild(localPathElement);\n            if (parentPathElement == null) {\n                parentPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.PARENT_PATH_ELEM.toString());\n                parentPathElement.setTextContent(dataSourcePath);\n                derivedFileElement.appendChild(parentPathElement);\n            }\n        }\n\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(resultsFilePath));\n        transformer.transform(source, result);\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {\n        if (refCounter.get(jobId) == 1) {\n            try {\n                // There will be two tasks: data source analysis and import of \n                // the results of the analysis.\n                progressBar.switchToDeterminate(2);\n\n                // Do the analysis. The following commented out code could be \n                // used to run an executable. In this case the executable takes \n                // two command line arguments, the path to the data source to be \n                // analyzed and the path to a results file. The results file is \n                // an XML file (see org.sleuthkit.autopsy.externalresults.autopsy_external_results.xsd)\n                // with instructions for the import of blackboard artifacts, \n                // derived files, and reports generated by the analysis. In this \n                // sample ingest module, the generation of the analysis results is\n                // simulated. \n                String dataSourcePath = dataSource.getImage().getPaths()[0];\n                String resultsFilePath = outputDirPath + File.separator + String.format(\"job_%d_results.xml\", jobId);\n//                ExecUtil executor = new ExecUtil();\n//                executor.execute(\"some.exe\", dataSourcePath, resultsFilePath);\n                generateSimulatedResults(dataSourcePath, resultsFilePath);\n                progressBar.progress(1);\n\n                // Import the results of the analysis.\n                ExternalResultsImporter.importResultsFromXML(dataSource, resultsFilePath);\n                progressBar.progress(2);\n            } catch (TskCoreException | ParserConfigurationException | TransformerException | IOException ex) {\n                Logger logger = IngestServices.getInstance().getLogger(moduleName);\n                logger.log(Level.SEVERE, \"Failed to simulate analysis and results import\", ex);  //NON-NLS\n                return ProcessResult.ERROR;\n            }\n        }\n\n        return ProcessResult.OK;\n    }","id":45835,"modified_method":"@Override\n    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {\n        if (refCounter.get(jobId) == 1) {\n            try {\n                // There will be two tasks: data source analysis and import of \n                // the results of the analysis.\n                progressBar.switchToDeterminate(2);\n\n                // Do the analysis. The following commented out code could be \n                // used to run an executable. In this case the executable takes \n                // two command line arguments, the path to the data source to be \n                // analyzed and the path to a results file. The results file is \n                // an XML file (see org.sleuthkit.autopsy.externalresults.autopsy_external_results.xsd)\n                // with instructions for the import of blackboard artifacts, \n                // derived files, and reports generated by the analysis. In this \n                // sample ingest module, the generation of the analysis results is\n                // simulated. \n                String dataSourcePath = dataSource.getImage().getPaths()[0];\n                String resultsFilePath = outputDirPath + File.separator + String.format(\"job_%d_results.xml\", jobId);\n//                ExecUtil executor = new ExecUtil();\n//                executor.execute(\"some.exe\", dataSourcePath, resultsFilePath);\n                generateSimulatedResults(dataSourcePath, resultsFilePath);\n                progressBar.progress(1);\n\n                // Import the results of the analysis.\n                ExternalResults results = new ExternalResultsXMLParser(dataSource, resultsFilePath).parse(); \n                // RJCTODO: Get error messages\n                ExternalResultsImporter importer = new ExternalResultsImporter();\n                importer.importResults(results);\n                // RJCTODO: Get error messages\n                \n                progressBar.progress(2);\n            } catch (TskCoreException | ParserConfigurationException | TransformerException | IOException ex) {\n                Logger logger = IngestServices.getInstance().getLogger(moduleName);\n                logger.log(Level.SEVERE, \"Failed to simulate analysis and results import\", ex);  //NON-NLS\n                return ProcessResult.ERROR;\n            }\n        }\n\n        return ProcessResult.OK;\n    }","commit_id":"388dc636afe7e44547b676581575ad5a19aea3cf","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Called only when top component was closed so that now it is closed on all\n     * workspaces in the system. The intent is to provide subclasses information\n     * about TopComponent's life cycle across workspaces. Subclasses will\n     * usually perform cleaning tasks here.\n     */\n    @Override\n    public void componentClosed() {\n        //@@@ push the selection node to null?\n    }","id":45836,"modified_method":"/**\n     * Called only when top component was closed so that now it is closed on all\n     * workspaces in the system. The intent is to provide subclasses information\n     * about TopComponent's life cycle across workspaces. Subclasses will\n     * usually perform cleaning tasks here.\n     */\n    @Override\n    public void componentClosed() {\n        //@@@ push the selection node to null?\n        contentChildren = null;\n    }","commit_id":"f8bb586d4f241b442d5b4c9931eca5715a17e067","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Refreshes changed content nodes\n     */\n    void refreshContentTree() {\n        Node selectedNode = getSelectedNode();\n        final String[] selectedPath = NodeOp.createPath(selectedNode, em.getRootContext());\n\n        Children rootChildren = em.getRootContext().getChildren();\n        Node imagesFilterNode = rootChildren.findChild(DataSourcesNode.NAME);\n        OriginalNode imagesNodeOrig = imagesFilterNode.getLookup().lookup(OriginalNode.class);\n\n        if (imagesNodeOrig == null) {\n            logger.log(Level.SEVERE, \"Cannot find Images node, won't refresh the content tree\");\n            return;\n        }\n\n        Node imagesNode = imagesNodeOrig.getNode();\n\n        RootContentChildren contentRootChildren = (RootContentChildren) imagesNode.getChildren();\n        contentRootChildren.refreshContentKeys();\n\n        //final TreeView tree = getTree();\n        //tree.expandNode(imagesNode);\n\n        setSelectedNode(selectedPath, DataSourcesNode.NAME);\n\n    }","id":45837,"modified_method":"/**\n     * Refreshes changed content nodes\n     */\n    void refreshContentTree() {\n        Node selectedNode = getSelectedNode();\n        final String[] selectedPath = NodeOp.createPath(selectedNode, em.getRootContext());\n\n        Children rootChildren = em.getRootContext().getChildren();\n        Node dataSourcesFilterNode = rootChildren.findChild(DataSourcesNode.NAME);\n        if (dataSourcesFilterNode == null) {\n            logger.log(Level.SEVERE, \"Cannot find data sources filter node, won't refresh the content tree\");\n            return;\n        }\n        OriginalNode imagesNodeOrig = dataSourcesFilterNode.getLookup().lookup(OriginalNode.class);\n\n        if (imagesNodeOrig == null) {\n            logger.log(Level.SEVERE, \"Cannot find data sources node, won't refresh the content tree\");\n            return;\n        }\n\n        Node imagesNode = imagesNodeOrig.getNode();\n\n        RootContentChildren contentRootChildren = (RootContentChildren) imagesNode.getChildren();\n        contentRootChildren.refreshContentKeys();\n\n        //final TreeView tree = getTree();\n        //tree.expandNode(imagesNode);\n\n        setSelectedNode(selectedPath, DataSourcesNode.NAME);\n\n    }","commit_id":"f8bb586d4f241b442d5b4c9931eca5715a17e067","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Called only when top component was closed on all workspaces before and\n     * now is opened for the first time on some workspace. The intent is to\n     * provide subclasses information about TopComponent's life cycle across all\n     * existing workspaces. Subclasses will usually perform initializing tasks\n     * here.\n     */\n    @Override\n    public void componentOpened() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (Case.existsCurrentCase()) {\n                Case currentCase = Case.getCurrentCase();\n\n                // close the top component if there's no image in this case\n                if (currentCase.getRootObjectsCount() == 0) {\n                    //this.close();\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n                } else {\n                    // if there's at least one image, load the image and open the top component\n                    List<Object> items = new ArrayList<Object>();\n                    items.add(new Images(currentCase.getSleuthkitCase()));\n                    items.add(new Views(currentCase.getSleuthkitCase()));\n                    items.add(new Results(currentCase.getSleuthkitCase()));\n                    contentChildren = new RootContentChildren(items);\n                    Node root = new AbstractNode(contentChildren) {\n                        /**\n                         * to override the right click action in the white blank\n                         * space area on the directory tree window\n                         */\n                        @Override\n                        public Action[] getActions(boolean popup) {\n                            return new Action[]{};\n                        }\n\n                        // Overide the AbstractNode use of DefaultHandle to return\n                        // a handle which can be serialized without a parent\n                        @Override\n                        public Node.Handle getHandle() {\n                            return new Node.Handle() {\n                                @Override\n                                public Node getNode() throws IOException {\n                                    return em.getRootContext();\n                                }\n                            };\n                        }\n                    };\n\n                    root = new DirectoryTreeFilterNode(root, true);\n\n\n                    em.setRootContext(root);\n                    em.getRootContext().setName(currentCase.getName());\n                    em.getRootContext().setDisplayName(currentCase.getName());\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n\n                    // Reset the forward and back lists because we're resetting the root context\n                    resetHistoryListAndButtons();\n\n                    Children childNodes = em.getRootContext().getChildren();\n                    TreeView tree = getTree();\n\n                    Node results = childNodes.findChild(ResultsNode.NAME);\n                    tree.expandNode(results);\n\n                    Children resultsChilds = results.getChildren();\n                    tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n                    tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n\n\n                    Node views = childNodes.findChild(ViewsNode.NAME);\n                    Children viewsChilds = views.getChildren();\n                    for (Node n : viewsChilds.getNodes()) {\n                        tree.expandNode(n);\n                    }\n\n                    tree.collapseNode(views);\n\n                    // if the dataResult is not opened\n                    if (!dataResult.isOpened()) {\n                        dataResult.open(); // open the data result top component as well when the directory tree is opened\n                    }\n\n\n                    // select the first image node, if there is one\n                    // (this has to happen after dataResult is opened, because the event\n                    // of changing the selected node fires a handler that tries to make\n                    // dataResult active)\n                    if (childNodes.getNodesCount() > 0) {\n                        try {\n                            em.setSelectedNodes(new Node[]{childNodes.getNodeAt(0)});\n                        } catch (Exception ex) {\n                            logger.log(Level.SEVERE, \"Error setting default selected node.\", ex);\n                        }\n                    }\n\n                }\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","id":45838,"modified_method":"/**\n     * Called only when top component was closed on all workspaces before and\n     * now is opened for the first time on some workspace. The intent is to\n     * provide subclasses information about TopComponent's life cycle across all\n     * existing workspaces. Subclasses will usually perform initializing tasks\n     * here.\n     */\n    @Override\n    public void componentOpened() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (Case.existsCurrentCase()) {\n                Case currentCase = Case.getCurrentCase();\n\n                // close the top component if there's no image in this case\n                if (currentCase.getRootObjectsCount() == 0) {\n                    //this.close();\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n                } else {\n                    // if there's at least one image, load the image and open the top component\n                    List<Object> items = new ArrayList<Object>();\n                    final SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n                    items.add(new DataSources(tskCase));\n                    items.add(new Views(tskCase));\n                    items.add(new Results(tskCase));\n                    contentChildren = new RootContentChildren(items);\n                    Node root = new AbstractNode(contentChildren) {\n                        /**\n                         * to override the right click action in the white blank\n                         * space area on the directory tree window\n                         */\n                        @Override\n                        public Action[] getActions(boolean popup) {\n                            return new Action[]{};\n                        }\n\n                        // Overide the AbstractNode use of DefaultHandle to return\n                        // a handle which can be serialized without a parent\n                        @Override\n                        public Node.Handle getHandle() {\n                            return new Node.Handle() {\n                                @Override\n                                public Node getNode() throws IOException {\n                                    return em.getRootContext();\n                                }\n                            };\n                        }\n                    };\n\n                    root = new DirectoryTreeFilterNode(root, true);\n\n\n                    em.setRootContext(root);\n                    em.getRootContext().setName(currentCase.getName());\n                    em.getRootContext().setDisplayName(currentCase.getName());\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n\n                    // Reset the forward and back lists because we're resetting the root context\n                    resetHistoryListAndButtons();\n\n                    Children childNodes = em.getRootContext().getChildren();\n                    TreeView tree = getTree();\n\n                    Node results = childNodes.findChild(ResultsNode.NAME);\n                    tree.expandNode(results);\n\n                    Children resultsChilds = results.getChildren();\n                    tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n                    tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n\n\n                    Node views = childNodes.findChild(ViewsNode.NAME);\n                    Children viewsChilds = views.getChildren();\n                    for (Node n : viewsChilds.getNodes()) {\n                        tree.expandNode(n);\n                    }\n\n                    tree.collapseNode(views);\n\n                    // if the dataResult is not opened\n                    if (!dataResult.isOpened()) {\n                        dataResult.open(); // open the data result top component as well when the directory tree is opened\n                    }\n\n\n                    // select the first image node, if there is one\n                    // (this has to happen after dataResult is opened, because the event\n                    // of changing the selected node fires a handler that tries to make\n                    // dataResult active)\n                    if (childNodes.getNodesCount() > 0) {\n                        try {\n                            em.setSelectedNodes(new Node[]{childNodes.getNodeAt(0)});\n                        } catch (Exception ex) {\n                            logger.log(Level.SEVERE, \"Error setting default selected node.\", ex);\n                        }\n                    }\n\n                }\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","commit_id":"f8bb586d4f241b442d5b4c9931eca5715a17e067","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Add local files and dirs - the general method that does it all for files\n     * and dirs and in bulk/\n     * Sends event to inform listeners of new content (note, this is temporary, we will be using \n     * datamodel observer and node auto-refresh in future)\n     *\n     * @param localAbsPaths list of absolute paths to local files and dirs\n     * @return list of root AbstractFile objects created to represent roots of\n     * added local files/dirs\n     * @throws TskCoreException exception thrown if the object creation failed\n     * due to a critical system error or of the file manager has already been\n     * closed. There is no \"revert\" logic if one of the additions fails. The\n     * addition stops with the first error encountered.\n     */\n    public synchronized List<AbstractFile> addLocalFilesDirs(List<String> localAbsPaths) throws TskCoreException {\n        final List<AbstractFile> added = new ArrayList<AbstractFile>();\n\n        final List<java.io.File> rootsToAdd = new ArrayList<java.io.File>();\n        //first validate all the inputs before any additions\n        for (String absPath : localAbsPaths) {\n            java.io.File localFile = new java.io.File(absPath);\n            if (!localFile.exists() || !localFile.canRead()) {\n                String msg = \"One of the local files/dirs to add is not readable: \" + localFile.getAbsolutePath() + \", aborting the process before any files added\";\n                logger.log(Level.SEVERE, msg);\n                throw new TskCoreException(msg);\n            }\n            rootsToAdd.add(localFile);\n        }\n\n        for (java.io.File localRootToAdd : rootsToAdd) {\n            AbstractFile localFileAdded = null;\n            if (localRootToAdd.isFile()) {\n                localFileAdded = addLocalFileSingle(localRootToAdd.getAbsolutePath());\n            } else {\n                localFileAdded = this.addLocalDir(localRootToAdd.getAbsolutePath());\n            }\n            if (localFileAdded == null) {\n                String msg = \"One of the local files/dirs could not be added: \" + localRootToAdd.getAbsolutePath();\n                logger.log(Level.SEVERE, msg);\n                throw new TskCoreException(msg);\n            } else {\n                added.add(localFileAdded);\n            }\n        }\n        \n        if (! added.isEmpty()) {\n            //TODO use datamodel observer that sends such events, and node-autorefresh\n           // DirectoryTreeTopComponent.getDefault().refreshContentTreeSafe();\n        }\n\n\n        return added;\n    }","id":45839,"modified_method":"/**\n     * Add local files and dirs - the general method that does it all for files\n     * and dirs and in bulk/\n     *\n     * @param localAbsPaths list of absolute paths to local files and dirs\n     * @return list of root AbstractFile objects created to represent roots of\n     * added local files/dirs\n     * @throws TskCoreException exception thrown if the object creation failed\n     * due to a critical system error or of the file manager has already been\n     * closed. There is no \"revert\" logic if one of the additions fails. The\n     * addition stops with the first error encountered.\n     */\n    public synchronized List<AbstractFile> addLocalFilesDirs(List<String> localAbsPaths) throws TskCoreException {\n        final List<AbstractFile> added = new ArrayList<AbstractFile>();\n\n        final List<java.io.File> rootsToAdd = new ArrayList<java.io.File>();\n        //first validate all the inputs before any additions\n        for (String absPath : localAbsPaths) {\n            java.io.File localFile = new java.io.File(absPath);\n            if (!localFile.exists() || !localFile.canRead()) {\n                String msg = \"One of the local files/dirs to add is not readable: \" + localFile.getAbsolutePath() + \", aborting the process before any files added\";\n                logger.log(Level.SEVERE, msg);\n                throw new TskCoreException(msg);\n            }\n            rootsToAdd.add(localFile);\n        }\n\n        for (java.io.File localRootToAdd : rootsToAdd) {\n            AbstractFile localFileAdded = null;\n            if (localRootToAdd.isFile()) {\n                localFileAdded = addLocalFileSingle(localRootToAdd.getAbsolutePath());\n            } else {\n                localFileAdded = this.addLocalDir(localRootToAdd.getAbsolutePath());\n            }\n            if (localFileAdded == null) {\n                String msg = \"One of the local files/dirs could not be added: \" + localRootToAdd.getAbsolutePath();\n                logger.log(Level.SEVERE, msg);\n                throw new TskCoreException(msg);\n            } else {\n                added.add(localFileAdded);\n            }\n        }\n        \n       \n\n        return added;\n    }","commit_id":"f8bb586d4f241b442d5b4c9931eca5715a17e067","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static JavaCommand createCeServerCommand(Props props, File homeDir) {\n    JavaCommand webServer = new JavaCommand(\"ce\", CESERVER_PROCESS_INDEX)\n      .setWorkDir(homeDir)\n      .setClassName(\"org.sonar.ce.app.CeServer\")\n      .setArguments(props.rawProperties())\n      .addClasspath(\"./lib/common/*\")\n      .addClasspath(\"./lib/server/*\")\n      .addClasspath(\"./lib/ce/*\");\n    String driverPath = props.value(ProcessProperties.JDBC_DRIVER_PATH);\n    if (driverPath != null) {\n      webServer.addClasspath(driverPath);\n    }\n    return webServer;\n  }","id":45840,"modified_method":"private static JavaCommand createCeServerCommand(Props props, File homeDir) {\n    JavaCommand webServer = new JavaCommand(\"ce\", CESERVER_PROCESS_INDEX)\n      .setWorkDir(homeDir)\n      .addJavaOptions(ProcessProperties.CE_ENFORCED_JVM_ARGS)\n      .addJavaOptions(props.nonNullValue(ProcessProperties.CE_JAVA_OPTS))\n      .addJavaOptions(props.nonNullValue(ProcessProperties.CE_JAVA_ADDITIONAL_OPTS))\n      .setClassName(\"org.sonar.ce.app.CeServer\")\n      .setArguments(props.rawProperties())\n      .addClasspath(\"./lib/common/*\")\n      .addClasspath(\"./lib/server/*\")\n      .addClasspath(\"./lib/ce/*\");\n    String driverPath = props.value(ProcessProperties.JDBC_DRIVER_PATH);\n    if (driverPath != null) {\n      webServer.addClasspath(driverPath);\n    }\n    return webServer;\n  }","commit_id":"70d12b389773bfbe79c6d44ebb5ceca056565411","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static Map<String, String> defaults() {\n    Map<String, String> defaults = new HashMap<>();\n    defaults.put(ProcessProperties.CLUSTER_NAME, \"sonarqube\");\n    defaults.put(ProcessProperties.CLUSTER_NODE_NAME, \"sonar-\" + System.currentTimeMillis());\n\n    defaults.put(ProcessProperties.SEARCH_HOST, \"127.0.0.1\");\n    defaults.put(ProcessProperties.SEARCH_JAVA_OPTS, \"-Xmx1G -Xms256m -Xss256k -Djava.net.preferIPv4Stack=true \" +\n      \"-XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly \" +\n      \"-XX:+HeapDumpOnOutOfMemoryError\");\n    defaults.put(ProcessProperties.SEARCH_JAVA_ADDITIONAL_OPTS, \"\");\n\n    defaults.put(ProcessProperties.WEB_JAVA_OPTS, \"-Xmx768m -Xms256m -XX:MaxPermSize=160m -XX:+HeapDumpOnOutOfMemoryError -Djava.net.preferIPv4Stack=true\");\n    defaults.put(ProcessProperties.WEB_JAVA_ADDITIONAL_OPTS, \"\");\n    defaults.put(ProcessProperties.JDBC_URL, \"jdbc:h2:tcp://localhost:9092/sonar\");\n    defaults.put(ProcessProperties.JDBC_MAX_ACTIVE, \"60\");\n    defaults.put(ProcessProperties.JDBC_MAX_IDLE, \"5\");\n    defaults.put(ProcessProperties.JDBC_MIN_IDLE, \"2\");\n    defaults.put(ProcessProperties.JDBC_MAX_WAIT, \"5000\");\n    defaults.put(ProcessProperties.JDBC_MIN_EVICTABLE_IDLE_TIME_MILLIS, \"600000\");\n    defaults.put(ProcessProperties.JDBC_TIME_BETWEEN_EVICTION_RUNS_MILLIS, \"30000\");\n    return defaults;\n  }","id":45841,"modified_method":"public static Map<String, String> defaults() {\n    Map<String, String> defaults = new HashMap<>();\n    defaults.put(ProcessProperties.CLUSTER_NAME, \"sonarqube\");\n    defaults.put(ProcessProperties.CLUSTER_NODE_NAME, \"sonar-\" + System.currentTimeMillis());\n\n    defaults.put(ProcessProperties.SEARCH_HOST, \"127.0.0.1\");\n    defaults.put(ProcessProperties.SEARCH_JAVA_OPTS, \"-Xmx1G -Xms256m -Xss256k -Djava.net.preferIPv4Stack=true \" +\n      \"-XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly \" +\n      \"-XX:+HeapDumpOnOutOfMemoryError\");\n    defaults.put(ProcessProperties.SEARCH_JAVA_ADDITIONAL_OPTS, \"\");\n\n    defaults.put(ProcessProperties.WEB_JAVA_OPTS, \"-Xmx768m -Xms256m -XX:MaxPermSize=160m -XX:+HeapDumpOnOutOfMemoryError -Djava.net.preferIPv4Stack=true\");\n    defaults.put(ProcessProperties.WEB_JAVA_ADDITIONAL_OPTS, \"\");\n    defaults.put(ProcessProperties.CE_JAVA_OPTS, \"-Xmx768m -Xms256m -XX:MaxPermSize=160m -XX:+HeapDumpOnOutOfMemoryError -Djava.net.preferIPv4Stack=true\");\n    defaults.put(ProcessProperties.CE_JAVA_ADDITIONAL_OPTS, \"\");\n    defaults.put(ProcessProperties.JDBC_URL, \"jdbc:h2:tcp://localhost:9092/sonar\");\n    defaults.put(ProcessProperties.JDBC_MAX_ACTIVE, \"60\");\n    defaults.put(ProcessProperties.JDBC_MAX_IDLE, \"5\");\n    defaults.put(ProcessProperties.JDBC_MIN_IDLE, \"2\");\n    defaults.put(ProcessProperties.JDBC_MAX_WAIT, \"5000\");\n    defaults.put(ProcessProperties.JDBC_MIN_EVICTABLE_IDLE_TIME_MILLIS, \"600000\");\n    defaults.put(ProcessProperties.JDBC_TIME_BETWEEN_EVICTION_RUNS_MILLIS, \"30000\");\n    return defaults;\n  }","commit_id":"70d12b389773bfbe79c6d44ebb5ceca056565411","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"List<JavaCommand> createCommands(Props props) {\n    List<JavaCommand> commands = new ArrayList<JavaCommand>();\n    File homeDir = props.nonNullValueAsFile(\"sonar.path.home\");\n    File tempDir = props.nonNullValueAsFile(\"sonar.path.temp\");\n    JavaCommand elasticsearch = new JavaCommand(\"search\");\n    elasticsearch\n      .setWorkDir(homeDir)\n      .addJavaOptions(props.nonNullValue(DefaultSettings.SEARCH_JAVA_OPTS))\n      .addJavaOptions(props.nonNullValue(DefaultSettings.SEARCH_JAVA_ADDITIONAL_OPTS))\n      .setTempDir(tempDir.getAbsoluteFile())\n      .setClassName(\"org.sonar.search.SearchServer\")\n      .setArguments(props.rawProperties())\n      .addClasspath(\"./lib/common/*\")\n      .addClasspath(\"./lib/search/*\");\n    commands.add(elasticsearch);\n\n    // do not yet start SQ in cluster mode. See SONAR-5483 & SONAR-5391\n    if (StringUtils.isEmpty(props.value(DefaultSettings.CLUSTER_MASTER))) {\n      JavaCommand webServer = new JavaCommand(\"web\")\n        .setWorkDir(homeDir)\n        .addJavaOptions(props.nonNullValue(DefaultSettings.WEB_JAVA_OPTS))\n        .addJavaOptions(props.nonNullValue(DefaultSettings.WEB_JAVA_ADDITIONAL_OPTS))\n        .setTempDir(tempDir.getAbsoluteFile())\n        // required for logback tomcat valve\n        .setEnvVariable(\"sonar.path.logs\", props.nonNullValue(\"sonar.path.logs\"))\n        .setClassName(\"org.sonar.server.app.WebServer\")\n        .setArguments(props.rawProperties())\n        .addClasspath(\"./lib/common/*\")\n        .addClasspath(\"./lib/server/*\");\n      String driverPath = props.value(JdbcSettings.PROPERTY_DRIVER_PATH);\n      if (driverPath != null) {\n        webServer.addClasspath(driverPath);\n      }\n      commands.add(webServer);\n    }\n    return commands;\n  }","id":45842,"modified_method":"List<JavaCommand> createCommands(Props props) {\n    List<JavaCommand> commands = new ArrayList<JavaCommand>();\n    File homeDir = props.nonNullValueAsFile(\"sonar.path.home\");\n    File tempDir = props.nonNullValueAsFile(\"sonar.path.temp\");\n    JavaCommand elasticsearch = new JavaCommand(\"search\");\n    elasticsearch\n      .setWorkDir(homeDir)\n      .addJavaOptions(\"-Djava.awt.headless=true\")\n      .addJavaOptions(props.nonNullValue(DefaultSettings.SEARCH_JAVA_OPTS))\n      .addJavaOptions(props.nonNullValue(DefaultSettings.SEARCH_JAVA_ADDITIONAL_OPTS))\n      .setTempDir(tempDir.getAbsoluteFile())\n      .setClassName(\"org.sonar.search.SearchServer\")\n      .setArguments(props.rawProperties())\n      .addClasspath(\"./lib/common/*\")\n      .addClasspath(\"./lib/search/*\");\n    commands.add(elasticsearch);\n\n    // do not yet start SQ in cluster mode. See SONAR-5483 & SONAR-5391\n    if (StringUtils.isEmpty(props.value(DefaultSettings.CLUSTER_MASTER))) {\n      JavaCommand webServer = new JavaCommand(\"web\")\n        .setWorkDir(homeDir)\n        .addJavaOptions(\"-Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djruby.management.enabled=false\")\n        .addJavaOptions(props.nonNullValue(DefaultSettings.WEB_JAVA_OPTS))\n        .addJavaOptions(props.nonNullValue(DefaultSettings.WEB_JAVA_ADDITIONAL_OPTS))\n        .setTempDir(tempDir.getAbsoluteFile())\n        // required for logback tomcat valve\n        .setEnvVariable(\"sonar.path.logs\", props.nonNullValue(\"sonar.path.logs\"))\n        .setClassName(\"org.sonar.server.app.WebServer\")\n        .setArguments(props.rawProperties())\n        .addClasspath(\"./lib/common/*\")\n        .addClasspath(\"./lib/server/*\");\n      String driverPath = props.value(JdbcSettings.PROPERTY_DRIVER_PATH);\n      if (driverPath != null) {\n        webServer.addClasspath(driverPath);\n      }\n      commands.add(webServer);\n    }\n    return commands;\n  }","commit_id":"7eb13c86cafb14b8d7afbb3737a27fb3c6fe9d51","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockUtil.setupLogging();\n        MockUtil.resetLogLevel();\n        \n        if (m_runSupers) {\n        \n            m_network = new MockNetwork();\n            m_network.setCriticalService(\"ICMP\");\n            m_network.addNode(1, \"Router\");\n            m_network.addInterface(\"192.168.1.1\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addInterface(\"192.168.1.2\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addNode(2, \"Server\");\n            m_network.addInterface(\"192.168.1.3\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"HTTP\");\n            m_network.addNode(3, \"Firewall\");\n            m_network.addInterface(\"192.168.1.4\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            m_network.addInterface(\"192.168.1.5\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            \n            m_db = new MockDatabase();\n            m_db.populate(m_network);\n            \n            m_eventd = new Eventd();\n            m_eventdConfigMgr = new MockEventConfigManager(MOCK_EVENT_CONFIG);\n            m_eventd.setConfigManager(m_eventdConfigMgr);\n            DatabaseConnectionFactory.setInstance(m_db);\n            \n            Reader rdr = new StringReader(SNMP_CONFIG);\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            rdr = new StringReader(MOCK_EVENT_CONF);\n            EventConfigurationManager.loadConfiguration(rdr);\n            \n            m_eventdIpcMgr = new EventIpcManagerDefaultImpl(m_eventdConfigMgr);\n            EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n            m_eventd.setEventIpcManager(m_eventdIpcMgr);\n            m_eventd.init();\n            m_eventd.start();\n        \n        }\n\n    }","id":45843,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockUtil.setupLogging();\n        MockUtil.resetLogLevel();\n        \n        if (m_runSupers) {\n        \n            m_network = new MockNetwork();\n            m_network.setCriticalService(\"ICMP\");\n            m_network.addNode(1, \"Router\");\n            m_network.addInterface(\"192.168.1.1\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addInterface(\"192.168.1.2\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addNode(2, \"Server\");\n            m_network.addInterface(\"192.168.1.3\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"HTTP\");\n            m_network.addNode(3, \"Firewall\");\n            m_network.addInterface(\"192.168.1.4\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            m_network.addInterface(\"192.168.1.5\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            \n            m_db = new MockDatabase();\n            m_db.populate(m_network);\n            \n            DatabaseConnectionFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(SNMP_CONFIG);\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventd = new Eventd();\n                m_eventdConfigMgr = new MockEventConfigManager(MOCK_EVENT_CONFIG);\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n                \n                \n                Reader configRdr = new StringReader(MOCK_EVENT_CONF);\n                EventConfigurationManager.loadConfiguration(configRdr);\n                \n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl(m_eventdConfigMgr);\n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n\n    }","commit_id":"b2b0a9873c1e3e1407a5715b11af46f3a39fccc3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void tearDown() throws Exception {\n        if(m_runSupers) {\n            m_eventd.stop();\n            super.tearDown();\n        }\n    }","id":45844,"modified_method":"protected void tearDown() throws Exception {\n        if(m_runSupers) {\n            if (isStartEventd()) m_eventd.stop();\n            super.tearDown();\n        }\n    }","commit_id":"b2b0a9873c1e3e1407a5715b11af46f3a39fccc3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method constructs the next SnmpPduPacket (pdu) for sending to the\n     * remote node.\n     * \n     * For SNMPv1, GET commands are built. Each constructed PDU contains\n     * varbinds for all the objects to be collected for a single interface. For\n     * objects whose instance id is determined by ifIndex (such as ifOctetsIn or\n     * ifOctetsOut in the ifTable) the interface index will be appended to the\n     * oid name within the varbind. Therefore, for an SNMPv1 based collection\n     * the number of PDUs generated will be equal to the number interfaces in\n     * the remote node's ifTable. As each GET response is received the response\n     * count is incremented and each subsequent call to getNextSnmpV1Pdu() will\n     * generate a PDU for collecting data pertaining to the next interface in\n     * the ifTable.\n     * \n     * @param ifAddress\n     *            Interface address of the remote agent\n     * \n     * @return An SnmpPduPacket appropriate for the SNMP version supported.\n     * \n     * @see org.opennms.protocols.snmp.SnmpNull SnmpNull\n     * @see org.opennms.protocols.snmp.SnmpPduPacket SnmpPduPacket\n     */\n    private SnmpPduPacket getNextSnmpV1Pdu(String ifAddress) {\n        // Log4j category\n        //\n        Integer index = null;\n        SnmpPduPacket pdu = null;\n\n        pdu = new SnmpPduRequest(SnmpPduPacket.GET);\n        index = new Integer(m_indexArray[m_responses]);\n        m_objList = ((IfInfo) m_ifMap.get(index)).getOidList();\n        if (log().isDebugEnabled())\n            log().debug(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") ifindex: \" + index + \" oidListIndex=\" + m_oidListIndex + \" objCount=\" + m_objList.size());\n\n        pdu.setRequestId(SnmpPduPacket.nextSequence());\n\n        // Generate new SnmpVarBind object. Add each oid from the\n        // object list until max var count is reached or there are no\n        // more objects to collect.\n        Object[] oidArray = m_objList.toArray();\n        for (int ii = m_oidListIndex; ii < m_objList.size() && (ii - m_oidListIndex) < m_maxVarsPerPdu; ii++) {\n            MibObject mibObject = ((MibObject) oidArray[ii]);\n\n            SnmpObjectId oid = null;\n            String instance = mibObject.getInstance();\n\n            // instance must be one of the following:\n            // 1) null. In this case the object's oid value is used as-is.\n            // 2) a special keyword which indicates a specific\n            // value will be retrieved and appended to the object's oid.\n            // Currently the only supported keywords are:\n            // \"ifIndex\" - current interface's ifIndex is retrieved from the\n            // database\n            // \"ifAddress\" - current interface's IP address\n            // 3) an integer value indicating the instance of the MIB object to\n            // be\n            // retrieved. This value will be appended to the object's oid.\n            //\n            if (instance == null) {\n                oid = new SnmpObjectId(mibObject.getOid());\n            } else if (instance.equals(MibObject.INSTANCE_IFINDEX)) {\n                // Verify that we have a valid ifIndex value\n                if (index.intValue() == -1) {\n                    if (log().isEnabledFor(Priority.WARN)) {\n                        log().warn(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") valid 'ifIndex' value unavailable for interface \" + ifAddress + \" and MIB object: \" + mibObject.getOid());\n                        log().warn(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") substituting instance value 0.\");\n                    }\n                    oid = new SnmpObjectId(mibObject.getOid() + \".0\");\n                } else {\n                    oid = new SnmpObjectId(mibObject.getOid() + \".\" + index.toString());\n                }\n            } else if (instance.equals(MibObject.INSTANCE_IFADDRESS)) {\n                // Append current interface's ip Address\n                oid = new SnmpObjectId(mibObject.getOid() + \".\" + ifAddress);\n            } else {\n                // Attempt to convert the instance string to an integer value\n                // If the instance string cannot be converted to an integer just\n                // use an instance string of \"0\".\n                int temp = -1;\n                try {\n                    temp = Integer.parseInt(instance);\n                } catch (NumberFormatException nfe) {\n                    instance = \"0\";\n                }\n\n                oid = new SnmpObjectId(mibObject.getOid() + \".\" + instance);\n            }\n\n            // Add the variable binding to the pdu\n            if (log().isDebugEnabled())\n                log().debug(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") adding oid to pdu: \" + oid.toString());\n\n            pdu.addVarBind(new SnmpVarBind(oid));\n        }\n\n        if (log().isDebugEnabled())\n            log().debug(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") finished building next pdu, num vars in pdu=\" + pdu.getLength());\n        return pdu;\n    }","id":45845,"modified_method":"/**\n     * This method constructs the next SnmpPduPacket (pdu) for sending to the\n     * remote node.\n     * \n     * For SNMPv1, GET commands are built. Each constructed PDU contains\n     * varbinds for all the objects to be collected for a single interface. For\n     * objects whose instance id is determined by ifIndex (such as ifOctetsIn or\n     * ifOctetsOut in the ifTable) the interface index will be appended to the\n     * oid name within the varbind. Therefore, for an SNMPv1 based collection\n     * the number of PDUs generated will be equal to the number interfaces in\n     * the remote node's ifTable. As each GET response is received the response\n     * count is incremented and each subsequent call to getNextSnmpV1Pdu() will\n     * generate a PDU for collecting data pertaining to the next interface in\n     * the ifTable.\n     * \n     * @param ifAddress\n     *            Interface address of the remote agent\n     * \n     * @return An SnmpPduPacket appropriate for the SNMP version supported.\n     * \n     * @see org.opennms.protocols.snmp.SnmpNull SnmpNull\n     * @see org.opennms.protocols.snmp.SnmpPduPacket SnmpPduPacket\n     */\n    private SnmpPduPacket getNextSnmpV1Pdu(String ifAddress) {\n        // Log4j category\n        //\n        Integer index = null;\n        SnmpPduPacket pdu = null;\n\n        pdu = new SnmpPduRequest(SnmpPduPacket.GET);\n        index = new Integer(m_indexArray[m_responses]);\n        m_objList = ((IfInfo) m_ifMap.get(index)).getOidList();\n        if (log().isDebugEnabled())\n            log().debug(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") ifindex: \" + index + \" oidListIndex=\" + m_oidListIndex + \" objCount=\" + (m_objList == null ? 0 : m_objList.size()));\n\n        pdu.setRequestId(SnmpPduPacket.nextSequence());\n\n        // Generate new SnmpVarBind object. Add each oid from the\n        // object list until max var count is reached or there are no\n        // more objects to collect.\n        Object[] oidArray = m_objList.toArray();\n        for (int ii = m_oidListIndex; ii < m_objList.size() && (ii - m_oidListIndex) < m_maxVarsPerPdu; ii++) {\n            MibObject mibObject = ((MibObject) oidArray[ii]);\n\n            SnmpObjectId oid = null;\n            String instance = mibObject.getInstance();\n\n            // instance must be one of the following:\n            // 1) null. In this case the object's oid value is used as-is.\n            // 2) a special keyword which indicates a specific\n            // value will be retrieved and appended to the object's oid.\n            // Currently the only supported keywords are:\n            // \"ifIndex\" - current interface's ifIndex is retrieved from the\n            // database\n            // \"ifAddress\" - current interface's IP address\n            // 3) an integer value indicating the instance of the MIB object to\n            // be\n            // retrieved. This value will be appended to the object's oid.\n            //\n            if (instance == null) {\n                oid = new SnmpObjectId(mibObject.getOid());\n            } else if (instance.equals(MibObject.INSTANCE_IFINDEX)) {\n                // Verify that we have a valid ifIndex value\n                if (index.intValue() == -1) {\n                    if (log().isEnabledFor(Priority.WARN)) {\n                        log().warn(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") valid 'ifIndex' value unavailable for interface \" + ifAddress + \" and MIB object: \" + mibObject.getOid());\n                        log().warn(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") substituting instance value 0.\");\n                    }\n                    oid = new SnmpObjectId(mibObject.getOid() + \".0\");\n                } else {\n                    oid = new SnmpObjectId(mibObject.getOid() + \".\" + index.toString());\n                }\n            } else if (instance.equals(MibObject.INSTANCE_IFADDRESS)) {\n                // Append current interface's ip Address\n                oid = new SnmpObjectId(mibObject.getOid() + \".\" + ifAddress);\n            } else {\n                // Attempt to convert the instance string to an integer value\n                // If the instance string cannot be converted to an integer just\n                // use an instance string of \"0\".\n                int temp = -1;\n                try {\n                    temp = Integer.parseInt(instance);\n                } catch (NumberFormatException nfe) {\n                    instance = \"0\";\n                }\n\n                oid = new SnmpObjectId(mibObject.getOid() + \".\" + instance);\n            }\n\n            // Add the variable binding to the pdu\n            if (log().isDebugEnabled())\n                log().debug(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") adding oid to pdu: \" + oid.toString());\n\n            pdu.addVarBind(new SnmpVarBind(oid));\n        }\n\n        if (log().isDebugEnabled())\n            log().debug(\"getNextSnmpV1Pdu: (\"+m_primaryIf+\") finished building next pdu, num vars in pdu=\" + pdu.getLength());\n        return pdu;\n    }","commit_id":"b2b0a9873c1e3e1407a5715b11af46f3a39fccc3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    final List children = element.getChildren();\n    for (final Object child : children) {\n      myManager.loadConfiguration((Element)child, true);\n    }\n  }","id":45846,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    myUnloadedElements = null;\n\n    final List children = element.getChildren();\n    for (final Object child : children) {\n      if (!myManager.loadConfiguration((Element)child, true) && Comparing.strEqual(element.getName(), RunManagerImpl.CONFIGURATION)) {\n        if (myUnloadedElements == null) myUnloadedElements = new ArrayList<Element>(2);\n        myUnloadedElements.add(element);\n      }\n    }\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(Element element) throws WriteExternalException {\n    final Collection<RunnerAndConfigurationSettingsImpl> configurations = myManager.getStableConfigurations().values();\n    for (RunnerAndConfigurationSettingsImpl configuration : configurations) {\n      if (myManager.isConfigurationShared(configuration)){\n        myManager.addConfigurationElement(element, configuration);\n      }\n    }\n  }","id":45847,"modified_method":"public void writeExternal(Element element) throws WriteExternalException {\n    final Collection<RunnerAndConfigurationSettingsImpl> configurations = myManager.getStableConfigurations().values();\n    for (RunnerAndConfigurationSettingsImpl configuration : configurations) {\n      if (myManager.isConfigurationShared(configuration)){\n        myManager.addConfigurationElement(element, configuration);\n      }\n    }\n    if (myUnloadedElements != null) {\n      for (Element unloadedElement : myUnloadedElements) {\n        element.addContent((Element)unloadedElement.clone());\n      }\n    }\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(final Element parentNode) throws WriteExternalException {\n    LOG.assertTrue(parentNode != null);\n\n    if (myTempConfiguration != null) {\n      addConfigurationElement(parentNode, myTempConfiguration, TEMP_CONFIGURATION);\n    }\n\n    for (final RunnerAndConfigurationSettingsImpl runnerAndConfigurationSettings : myTemplateConfigurationsMap.values()) {\n      addConfigurationElement(parentNode, runnerAndConfigurationSettings);\n    }\n\n    final Collection<RunnerAndConfigurationSettingsImpl> configurations = getStableConfigurations().values();\n    for (RunnerAndConfigurationSettingsImpl configuration : configurations) {\n      addConfigurationElement(parentNode, configuration); //write shared configurations twice to save order     \n    }\n    if (mySelectedConfiguration != null){\n      parentNode.setAttribute(SELECTED_ATTR, getUniqueName(mySelectedConfiguration.getConfiguration()));\n    }\n  }","id":45848,"modified_method":"public void writeExternal(final Element parentNode) throws WriteExternalException {\n    LOG.assertTrue(parentNode != null);\n\n    if (myTempConfiguration != null) {\n      addConfigurationElement(parentNode, myTempConfiguration, TEMP_CONFIGURATION);\n    }\n\n    for (final RunnerAndConfigurationSettingsImpl runnerAndConfigurationSettings : myTemplateConfigurationsMap.values()) {\n      addConfigurationElement(parentNode, runnerAndConfigurationSettings);\n    }\n\n    final Collection<RunnerAndConfigurationSettingsImpl> configurations = getStableConfigurations().values();\n    for (RunnerAndConfigurationSettingsImpl configuration : configurations) {\n      addConfigurationElement(parentNode, configuration); //write shared configurations twice to save order     \n    }\n    if (mySelectedConfiguration != null){\n      parentNode.setAttribute(SELECTED_ATTR, getUniqueName(mySelectedConfiguration.getConfiguration()));\n    }\n\n    if (myUnloadedElements != null) {\n      for (Element unloadedElement : myUnloadedElements) {\n        parentNode.addContent((Element)unloadedElement.clone());\n      }\n    }\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadConfiguration(final Element element, boolean isShared) throws InvalidDataException {\n    RunnerAndConfigurationSettingsImpl configuration = new RunnerAndConfigurationSettingsImpl(this);\n    configuration.readExternal(element);\n    ConfigurationFactory factory = configuration.getFactory();\n    if (factory == null) return;\n\n    final Element methodsElement = element.getChild(METHOD);\n    if (configuration.isTemplate()) {\n      myTemplateConfigurationsMap.put(factory, configuration);\n      final Map<String, Boolean> map = updateStepsBeforeRun(methodsElement);\n      setCompileMethodBeforeRun(configuration.getConfiguration(), map);\n    }\n    else {\n      if (Boolean.valueOf(element.getAttributeValue(SELECTED_ATTR)).booleanValue()) { //to support old style\n        mySelectedConfiguration = configuration;\n      }\n      if (TEMP_CONFIGURATION.equals(element.getName())) {\n        myTempConfiguration = configuration;\n      }\n      final Map<String, Boolean> map = updateStepsBeforeRun(methodsElement);\n      addConfiguration(configuration, isShared, map);\n    }\n  }","id":45849,"modified_method":"public boolean loadConfiguration(final Element element, boolean isShared) throws InvalidDataException {\n    RunnerAndConfigurationSettingsImpl configuration = new RunnerAndConfigurationSettingsImpl(this);\n    configuration.readExternal(element);\n    ConfigurationFactory factory = configuration.getFactory();\n    if (factory == null) {\n      return false;\n    }\n\n    final Element methodsElement = element.getChild(METHOD);\n    if (configuration.isTemplate()) {\n      myTemplateConfigurationsMap.put(factory, configuration);\n      final Map<String, Boolean> map = updateStepsBeforeRun(methodsElement);\n      setCompileMethodBeforeRun(configuration.getConfiguration(), map);\n    }\n    else {\n      if (Boolean.valueOf(element.getAttributeValue(SELECTED_ATTR)).booleanValue()) { //to support old style\n        mySelectedConfiguration = configuration;\n      }\n      if (TEMP_CONFIGURATION.equals(element.getName())) {\n        myTempConfiguration = configuration;\n      }\n      final Map<String, Boolean> map = updateStepsBeforeRun(methodsElement);\n      addConfiguration(configuration, isShared, map);\n    }\n    return true;\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(final Element parentNode) throws InvalidDataException {\n    myConfigurations.clear();\n\n    final List children = parentNode.getChildren();\n    for (final Object aChildren : children) {\n      final Element element = (Element)aChildren;\n      loadConfiguration(element, false);\n    }\n    mySelectedConfig = parentNode.getAttributeValue(SELECTED_ATTR);\n  }","id":45850,"modified_method":"public void readExternal(final Element parentNode) throws InvalidDataException {\n    myConfigurations.clear();\n    myUnloadedElements = null;\n\n    final List children = parentNode.getChildren();\n    for (final Object aChildren : children) {\n      final Element element = (Element)aChildren;\n      if (!loadConfiguration(element, false) && Comparing.strEqual(element.getName(), CONFIGURATION)) {\n        if (myUnloadedElements == null) myUnloadedElements = new ArrayList<Element>(2);        \n        myUnloadedElements.add(element);\n      }\n    }\n    mySelectedConfig = parentNode.getAttributeValue(SELECTED_ATTR);\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    myIsTemplate = Boolean.valueOf(element.getAttributeValue(TEMPLATE_FLAG_ATTRIBUTE)).booleanValue();\n    final ConfigurationFactory factory = getFactory(element);\n    if (factory == null) return;\n\n    if (myIsTemplate) {\n      myConfiguration = myManager.getConfigurationTemplate(factory).getConfiguration();\n    }\n    else {\n      final String name = element.getAttributeValue(NAME_ATTR);\n      myConfiguration = myManager.createConfiguration(name, factory).getConfiguration();\n    }\n\n    myConfiguration.readExternal(element);\n    List runners = element.getChildren(RUNNER_ELEMENT);\n    for (final Object runner1 : runners) {\n      Element runnerElement = (Element)runner1;\n      String id = runnerElement.getAttributeValue(RUNNER_ID);\n      JavaProgramRunner runner = ExecutionRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        RunnerSettings settings = createRunnerSettings(runner);\n        settings.readExternal(runnerElement);\n        myRunnerSettings.put(runner, settings);\n      }\n    }\n\n    List configurations = element.getChildren(CONFIGURATION_ELEMENT);\n    for (final Object configuration : configurations) {\n      Element configurationElement = (Element)configuration;\n      String id = configurationElement.getAttributeValue(RUNNER_ID);\n      JavaProgramRunner runner = ExecutionRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        ConfigurationPerRunnerSettings settings =\n          new ConfigurationPerRunnerSettings(runner.getInfo(), myConfiguration.createRunnerSettings(new InfoProvider(runner)));\n        settings.readExternal(configurationElement);\n        myConfigurationPerRunnerSettings.put(runner, settings);\n      }\n    }\n  }","id":45851,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    myIsTemplate = Boolean.valueOf(element.getAttributeValue(TEMPLATE_FLAG_ATTRIBUTE)).booleanValue();\n    final ConfigurationFactory factory = getFactory(element);\n    if (factory == null) return;\n\n    if (myIsTemplate) {\n      myConfiguration = myManager.getConfigurationTemplate(factory).getConfiguration();\n    }\n    else {\n      final String name = element.getAttributeValue(NAME_ATTR);\n      myConfiguration = myManager.createConfiguration(name, factory).getConfiguration();\n    }\n\n    myConfiguration.readExternal(element);\n    List runners = element.getChildren(RUNNER_ELEMENT);\n    myUnloadedRunnerSettings = null;\n    for (final Object runner1 : runners) {\n      Element runnerElement = (Element)runner1;\n      String id = runnerElement.getAttributeValue(RUNNER_ID);\n      JavaProgramRunner runner = ExecutionRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        RunnerSettings settings = createRunnerSettings(runner);\n        settings.readExternal(runnerElement);\n        myRunnerSettings.put(runner, settings);\n      } else {\n        if (myUnloadedRunnerSettings == null) myUnloadedRunnerSettings = new ArrayList<Element>(1);\n        myUnloadedRunnerSettings.add(runnerElement);\n      }\n    }\n\n    List configurations = element.getChildren(CONFIGURATION_ELEMENT);\n    myUnloadedConfigurationPerRunnerSettings = null;\n    for (final Object configuration : configurations) {\n      Element configurationElement = (Element)configuration;\n      String id = configurationElement.getAttributeValue(RUNNER_ID);\n      JavaProgramRunner runner = ExecutionRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        ConfigurationPerRunnerSettings settings =\n          new ConfigurationPerRunnerSettings(runner.getInfo(), myConfiguration.createRunnerSettings(new InfoProvider(runner)));\n        settings.readExternal(configurationElement);\n        myConfigurationPerRunnerSettings.put(runner, settings);\n      } else {\n        if (myUnloadedConfigurationPerRunnerSettings == null) myUnloadedConfigurationPerRunnerSettings = new ArrayList<Element>(1);\n        myUnloadedConfigurationPerRunnerSettings.add(configurationElement);\n      }\n    }\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Comparator<? super JavaProgramRunner> createComparator() {\n    return new Comparator<JavaProgramRunner>() {\n      public int compare(final JavaProgramRunner runner1, final JavaProgramRunner runner2) {\n        return runner1.getInfo().getId().compareTo(runner2.getInfo().getId());\n      }\n    };\n  }","id":45852,"modified_method":"private static Comparator<Element> createRunnerComparator() {\n    return new Comparator<Element>() {\n      public int compare(final Element o1, final Element o2) {\n        final String attributeValue1 = o1.getAttributeValue(RUNNER_ID);\n        if (attributeValue1 == null) {\n          return 1;\n\n        }\n        final String attributeValue2 = o2.getAttributeValue(RUNNER_ID);\n        if (attributeValue2 == null) {\n          return -1;\n        }\n        return attributeValue1.compareTo(attributeValue2);\n      }\n    };\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    final ConfigurationFactory factory = myConfiguration.getFactory();\n\n    element.setAttribute(TEMPLATE_FLAG_ATTRIBUTE, String.valueOf(myIsTemplate));\n    if (!myIsTemplate) {\n      element.setAttribute(NAME_ATTR, myConfiguration.getName());\n    }\n    element.setAttribute(CONFIGURATION_TYPE_ATTRIBUTE, factory.getType().getComponentName());\n    element.setAttribute(FACTORY_NAME_ATTRIBUTE, factory.getName());\n    myConfiguration.writeExternal(element);\n\n    for (JavaProgramRunner runner : myRunnerSettings.keySet()) {\n      RunnerSettings settings = myRunnerSettings.get(runner);\n      Element runnerElement = new Element(RUNNER_ELEMENT);\n      settings.writeExternal(runnerElement);\n      element.addContent(runnerElement);\n      runnerElement.setAttribute(RUNNER_ID, runner.getInfo().getId());\n    }\n\n    for (JavaProgramRunner runner : myConfigurationPerRunnerSettings.keySet()) {\n      ConfigurationPerRunnerSettings settings = myConfigurationPerRunnerSettings.get(runner);\n      Element runnerElement = new Element(CONFIGURATION_ELEMENT);\n      settings.writeExternal(runnerElement);\n      element.addContent(runnerElement);\n      runnerElement.setAttribute(RUNNER_ID, runner.getInfo().getId());\n    }\n  }","id":45853,"modified_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    final ConfigurationFactory factory = myConfiguration.getFactory();\n\n    element.setAttribute(TEMPLATE_FLAG_ATTRIBUTE, String.valueOf(myIsTemplate));\n    if (!myIsTemplate) {\n      element.setAttribute(NAME_ATTR, myConfiguration.getName());\n    }\n    element.setAttribute(CONFIGURATION_TYPE_ATTRIBUTE, factory.getType().getComponentName());\n    element.setAttribute(FACTORY_NAME_ATTRIBUTE, factory.getName());\n    myConfiguration.writeExternal(element);\n\n    final Comparator<Element> runnerComparator = createRunnerComparator();\n    writeRunnerSettings(runnerComparator, element);\n    writeConfigurationPerRunnerSettings(runnerComparator, element);\n  }","commit_id":"8136e6ea9c8c474dec6480c92dd81f07b80b27b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Called by the VelocityServlet init(). We want to set a set of properties so that templates will be found in the webapp root. This makes this easier to work with as an example, so a new user doesn't have to worry about config issues when first\n\t * figuring things out\n\t */\n\tprotected Properties loadConfiguration(ServletConfig config) throws IOException, FileNotFoundException\n\t{\n\t\t// load the properties as configured in the servlet init params\n\t\tProperties p = super.loadConfiguration(config);\n\n\t\t/*\n\t\t * first, we set the template path for the FileResourceLoader to the root of the webapp. This probably won't work under in a WAR under WebLogic, but should under tomcat :)\n\t\t */\n\n\t\tString path = config.getServletContext().getRealPath(\"/\");\n\n\t\tif (path == null)\n\t\t{\n\t\t\tSystem.out.println(\" SampleServlet.loadConfiguration() : unable to \"\n\t\t\t\t\t+ \"get the current webapp root.  Using '/'. Please fix.\");\n\n\t\t\tpath = \"/\";\n\t\t}\n\n\t\tp.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, path);\n\n\t\t/**\n\t\t * and the same for the log file\n\t\t */\n\n\t\tp.setProperty(\"runtime.log\", path + p.getProperty(\"runtime.log\"));\n\n\t\treturn p;\n\t}","id":45854,"modified_method":"/**\n\t * Called by the VelocityServlet init(). We want to set a set of properties so that templates will be found in the webapp root. This makes this easier to work with as an example, so a new user doesn't have to worry about config issues when first\n\t * figuring things out\n\t */\n\tprotected ExtendedProperties loadConfiguration(ServletConfig config) throws IOException, FileNotFoundException\n\t{\n\t\t// This is to support old config property.\n\t\tString configPath = config.getInitParameter(\"properties\");\n\t\tExtendedProperties p;\n\t\tif (configPath != null && configPath.length() > 0)\n\t\t{\n\t\t\tp = new ExtendedProperties();\n\t\t\tif (!configPath.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tconfigPath = \"/\"+configPath;\n\t\t\t}\n\t\t\tp.load(getServletContext().getResourceAsStream(configPath));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// load the properties as configured in the servlet init params\n\t\t\tp = super.loadConfiguration(config);\n\t\t}\n\n\t\t/*\n\t\t * first, we set the template path for the FileResourceLoader to the root of the webapp. This probably won't work under in a WAR under WebLogic, but should under tomcat :)\n\t\t */\n\n\t\tString path = config.getServletContext().getRealPath(\"/\");\n\n\t\tif (path == null)\n\t\t{\n\t\t\tSystem.out.println(\" SampleServlet.loadConfiguration() : unable to \"\n\t\t\t\t\t+ \"get the current webapp root.  Using '/'. Please fix.\");\n\n\t\t\tpath = \"/\";\n\t\t}\n\n\t\tp.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, path);\n\n\t\t/**\n\t\t * and the same for the log file\n\t\t */\n\n\t\tp.setProperty(\"runtime.log\", path + p.getProperty(\"runtime.log\"));\n\n\t\treturn p;\n\t}","commit_id":"83ce5a7ad0d2d8c69104a33c8a2959c5314dbde3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void deleteClosedIssuesOfProjectBefore(String uuid, Date beforeDate) {\n    FilterBuilder projectFilter = FilterBuilders.boolFilter().must(FilterBuilders.termsFilter(IssueIndexDefinition.FIELD_ISSUE_PROJECT_UUID, uuid));\n    FilterBuilder dateFilter = FilterBuilders.rangeFilter(IssueNormalizer.IssueField.ISSUE_CLOSE_DATE.field()).lt(beforeDate.getTime());\n    QueryBuilder queryBuilder = QueryBuilders.filteredQuery(\n      QueryBuilders.matchAllQuery(),\n      FilterBuilders.andFilter(projectFilter, dateFilter)\n      );\n\n    getClient().prepareDeleteByQuery(getIndexName()).setQuery(queryBuilder).get();\n  }","id":45855,"modified_method":"public void deleteClosedIssuesOfProjectBefore(String uuid, Date beforeDate) {\n    FilterBuilder projectFilter = FilterBuilders.boolFilter().must(FilterBuilders.termsFilter(IssueIndexDefinition.FIELD_ISSUE_PROJECT_UUID, uuid));\n    FilterBuilder dateFilter = FilterBuilders.rangeFilter(IssueNormalizer.IssueField.ISSUE_CLOSE_DATE.field()).lt(beforeDate.getTime());\n    QueryBuilder queryBuilder = QueryBuilders.filteredQuery(\n      QueryBuilders.matchAllQuery(),\n      FilterBuilders.andFilter(projectFilter, dateFilter)\n      );\n\n    getClient().prepareDeleteByQuery(IssueIndexDefinition.INDEX).setQuery(queryBuilder).get();\n  }","commit_id":"a0cf1e569694f72edf2316623099ea4c27f10fd4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<FacetValue> listAssignees(IssueQuery query) {\n    QueryContext queryContext = new QueryContext().setPage(1, 0);\n\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setIndices(this.getIndexName());\n\n    QueryBuilder esQuery = QueryBuilders.matchAllQuery();\n    BoolFilterBuilder esFilter = getFilter(query, queryContext);\n    if (esFilter.hasClauses()) {\n      esSearch.setQuery(QueryBuilders.filteredQuery(esQuery, esFilter));\n    } else {\n      esSearch.setQuery(esQuery);\n    }\n    esSearch.addAggregation(AggregationBuilders.terms(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE)\n      .size(Integer.MAX_VALUE)\n      .field(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE));\n    esSearch.addAggregation(AggregationBuilders.missing(\"notAssigned\")\n      .field(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE));\n\n    SearchResponse response = esSearch.get();\n    Terms aggregation = (Terms) response.getAggregations().getAsMap().get(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE);\n    List<FacetValue> facetValues = newArrayList();\n    for (Terms.Bucket value : aggregation.getBuckets()) {\n      facetValues.add(new FacetValue(value.getKey(), value.getDocCount()));\n    }\n    facetValues.add(new FacetValue(\"_notAssigned_\", ((InternalMissing) response.getAggregations().get(\"notAssigned\")).getDocCount()));\n\n    return facetValues;\n  }","id":45856,"modified_method":"public List<FacetValue> listAssignees(IssueQuery query) {\n    QueryContext queryContext = new QueryContext().setPage(1, 0);\n\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(IssueIndexDefinition.INDEX)\n      .setTypes(IssueIndexDefinition.TYPE_ISSUE);\n\n    QueryBuilder esQuery = QueryBuilders.matchAllQuery();\n    BoolFilterBuilder esFilter = getFilter(query, queryContext);\n    if (esFilter.hasClauses()) {\n      esSearch.setQuery(QueryBuilders.filteredQuery(esQuery, esFilter));\n    } else {\n      esSearch.setQuery(esQuery);\n    }\n    esSearch.addAggregation(AggregationBuilders.terms(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE)\n      .size(Integer.MAX_VALUE)\n      .field(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE));\n    esSearch.addAggregation(AggregationBuilders.missing(\"notAssigned\")\n      .field(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE));\n\n    SearchResponse response = esSearch.get();\n    Terms aggregation = (Terms) response.getAggregations().getAsMap().get(IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE);\n    List<FacetValue> facetValues = newArrayList();\n    for (Terms.Bucket value : aggregation.getBuckets()) {\n      facetValues.add(new FacetValue(value.getKey(), value.getDocCount()));\n    }\n    facetValues.add(new FacetValue(\"_notAssigned_\", ((InternalMissing) response.getAggregations().get(\"notAssigned\")).getDocCount()));\n\n    return facetValues;\n  }","commit_id":"a0cf1e569694f72edf2316623099ea4c27f10fd4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Result<Issue> search(IssueQuery query, QueryContext options) {\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setIndices(this.getIndexName());\n\n    if (options.isScroll()) {\n      esSearch.setSearchType(SearchType.SCAN);\n      esSearch.setScroll(TimeValue.timeValueMinutes(3));\n    }\n\n    setSorting(query, esSearch);\n    setPagination(options, esSearch);\n\n    QueryBuilder esQuery = QueryBuilders.matchAllQuery();\n    BoolFilterBuilder esFilter = FilterBuilders.boolFilter();\n    Map<String, FilterBuilder> filters = getFilters(query, options);\n    for (FilterBuilder filter : filters.values()) {\n      if (filter != null) {\n        esFilter.must(filter);\n      }\n    }\n\n    if (esFilter.hasClauses()) {\n      esSearch.setQuery(QueryBuilders.filteredQuery(esQuery, esFilter));\n    } else {\n      esSearch.setQuery(esQuery);\n    }\n\n    setFacets(query, options, filters, esQuery, esSearch);\n\n    SearchResponse response = esSearch.get();\n    return new Result<Issue>(this, response);\n  }","id":45857,"modified_method":"public Result<Issue> search(IssueQuery query, QueryContext options) {\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(IssueIndexDefinition.INDEX)\n      .setTypes(IssueIndexDefinition.TYPE_ISSUE);\n\n    if (options.isScroll()) {\n      esSearch.setSearchType(SearchType.SCAN);\n      esSearch.setScroll(TimeValue.timeValueMinutes(3));\n    }\n\n    setSorting(query, esSearch);\n    setPagination(options, esSearch);\n\n    QueryBuilder esQuery = QueryBuilders.matchAllQuery();\n    BoolFilterBuilder esFilter = FilterBuilders.boolFilter();\n    Map<String, FilterBuilder> filters = getFilters(query, options);\n    for (FilterBuilder filter : filters.values()) {\n      if (filter != null) {\n        esFilter.must(filter);\n      }\n    }\n\n    if (esFilter.hasClauses()) {\n      esSearch.setQuery(QueryBuilders.filteredQuery(esQuery, esFilter));\n    } else {\n      esSearch.setQuery(esQuery);\n    }\n\n    setFacets(query, options, filters, esQuery, esSearch);\n\n    SearchResponse response = esSearch.get();\n    return new Result<Issue>(this, response);\n  }","commit_id":"a0cf1e569694f72edf2316623099ea4c27f10fd4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ParameterTablePanel(Project project, VariableData[] variableData, final PsiElement... scopeElements) {\n    super(new BorderLayout());\n    myProject = project;\n    myVariableData = variableData;\n\n    myTableModel = new MyTableModel();\n    myTable = new Table(myTableModel);\n    DefaultCellEditor defaultEditor = (DefaultCellEditor)myTable.getDefaultEditor(Object.class);\n    defaultEditor.setClickCountToStart(1);\n\n    myTable.setTableHeader(null);\n    myTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTable.getColumnModel().getColumn(MyTableModel.CHECKMARK_COLUMN).setCellRenderer(new CheckBoxTableCellRenderer());\n    myTable.getColumnModel().getColumn(MyTableModel.CHECKMARK_COLUMN).setMaxWidth(new JCheckBox().getPreferredSize().width);\n    myTable.getColumnModel().getColumn(MyTableModel.PARAMETER_NAME_COLUMN).setCellRenderer(new DefaultTableCellRenderer() {\n      public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n        VariableData data = myVariableData[row];\n        setText(data.name);\n        return this;\n      }\n    });\n\n    myTable.getColumnModel().getColumn(MyTableModel.PARAMETER_TYPE_COLUMN).setCellRenderer(new DefaultTableCellRenderer() {\n      public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n        VariableData data = myVariableData[row];\n        setText(data.type.getPresentableText());\n        return this;\n      }\n    });\n\n    TypeSelectorManager[] managers = new TypeSelectorManagerImpl[myVariableData.length];\n    for (int i = 0; i < managers.length; i++) {\n      PsiExpression[] occurrences = findVariableOccurrences(scopeElements, myVariableData[i].variable);\n      managers[i] = new TypeSelectorManagerImpl(myProject, myVariableData[i].type, occurrences);\n    }\n\n    final TypeSelector[] selectors = new TypeSelector[managers.length];\n    for (int i = 0; i < selectors.length; i++) {\n      selectors[i] = managers[i].getTypeSelector();\n    }\n\n    myTable.getColumnModel().getColumn(MyTableModel.PARAMETER_TYPE_COLUMN).setCellEditor(new AbstractTableCellEditor() {\n      TypeSelector myCurrentSelector;\n      public Object getCellEditorValue() {\n        return myCurrentSelector.getSelectedType();\n      }\n\n      public Component getTableCellEditorComponent(final JTable table,\n                                                   final Object value,\n                                                   final boolean isSelected,\n                                                   final int row,\n                                                   final int column) {\n        myCurrentSelector = selectors[row];\n        return myCurrentSelector.getComponent();\n      }\n    });\n\n    myTable.setPreferredScrollableViewportSize(new Dimension(250, myTable.getRowHeight() * 5));\n    myTable.setShowGrid(false);\n    myTable.setIntercellSpacing(new Dimension(0, 0));\n    @NonNls final InputMap inputMap = myTable.getInputMap();\n    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), \"enable_disable\");\n    @NonNls final ActionMap actionMap = myTable.getActionMap();\n    actionMap.put(\"enable_disable\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (myTable.isEditing()) return;\n        int[] rows = myTable.getSelectedRows();\n        if (rows.length > 0) {\n          boolean valueToBeSet = false;\n          for (int row : rows) {\n            if (!myVariableData[row].passAsParameter) {\n              valueToBeSet = true;\n              break;\n            }\n          }\n          for (int row : rows) {\n            myVariableData[row].passAsParameter = valueToBeSet;\n          }\n          myTableModel.fireTableRowsUpdated(rows[0], rows[rows.length - 1]);\n          TableUtil.selectRows(myTable, rows);\n        }\n      }\n    });\n    // F2 should edit the name\n    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0), \"edit_parameter_name\");\n    actionMap.put(\"edit_parameter_name\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (!myTable.isEditing()) {\n          int row = myTable.getSelectedRow();\n          if (row >= 0 && row < myTableModel.getRowCount()) {\n            TableUtil.editCellAt(myTable, row, MyTableModel.PARAMETER_NAME_COLUMN);\n          }\n        }\n      }\n    });\n\n    // make ENTER work when the table has focus\n    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"invokeImpl\");\n    actionMap.put(\"invokeImpl\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        TableCellEditor editor = myTable.getCellEditor();\n        if (editor != null) {\n          editor.stopCellEditing();\n        }\n        else {\n          doEnterAction();\n        }\n      }\n    });\n\n    // make ESCAPE work when the table has focus\n    actionMap.put(\"doCancel\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        TableCellEditor editor = myTable.getCellEditor();\n        if (editor != null) {\n          editor.stopCellEditing();\n        }\n        else {\n          doCancelAction();\n        }\n      }\n    });\n\n    JPanel listPanel = new JPanel(new BorderLayout());\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTable);\n    listPanel.add(scrollPane, BorderLayout.CENTER);\n    listPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    add(listPanel, BorderLayout.CENTER);\n\n    JPanel buttonsPanel = new JPanel();\n    buttonsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    add(buttonsPanel, BorderLayout.EAST);\n\n    buttonsPanel.setLayout(new GridBagLayout());\n    GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n    gbConstraints.insets = new Insets(2, 4, 2, 4);\n\n    myUpButton = new JButton();\n    myUpButton.setText(RefactoringBundle.message(\"row.move.up\"));\n    myUpButton.setDefaultCapable(false);\n    buttonsPanel.add(myUpButton, gbConstraints);\n\n    myDownButton = new JButton();\n    myDownButton.setText(RefactoringBundle.message(\"row.move.down\"));\n    myDownButton.setDefaultCapable(false);\n    buttonsPanel.add(myDownButton, gbConstraints);\n\n    gbConstraints.weighty = 1;\n    buttonsPanel.add(new JPanel(), gbConstraints);\n\n    myUpButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myTable.isEditing()) {\n          final boolean isStopped = myTable.getCellEditor().stopCellEditing();\n          if (!isStopped) return;\n        }\n        moveSelectedItem(-1);\n        updateSignature();\n        myTable.requestFocus();\n      }\n    });\n\n    myDownButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myTable.isEditing()) {\n          final boolean isStopped = myTable.getCellEditor().stopCellEditing();\n          if (!isStopped) return;\n        }\n        moveSelectedItem(+1);\n        updateSignature();\n        myTable.requestFocus();\n      }\n    });\n\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateMoveButtons();\n      }\n    });\n    if (myVariableData.length <= 1) {\n      myUpButton.setEnabled(false);\n      myDownButton.setEnabled(false);\n    }\n    else {\n      myTable.getSelectionModel().setSelectionInterval(0, 0);\n    }\n    updateMoveButtons();\n  }","id":45858,"modified_method":"public ParameterTablePanel(Project project, VariableData[] variableData, final PsiElement... scopeElements) {\n    super(new BorderLayout());\n    myProject = project;\n    myVariableData = variableData;\n\n    myTableModel = new MyTableModel();\n    myTable = new Table(myTableModel);\n    DefaultCellEditor defaultEditor = (DefaultCellEditor)myTable.getDefaultEditor(Object.class);\n    defaultEditor.setClickCountToStart(1);\n\n    myTable.setTableHeader(null);\n    myTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTable.getColumnModel().getColumn(MyTableModel.CHECKMARK_COLUMN).setCellRenderer(new CheckBoxTableCellRenderer());\n    myTable.getColumnModel().getColumn(MyTableModel.CHECKMARK_COLUMN).setMaxWidth(new JCheckBox().getPreferredSize().width);\n    myTable.getColumnModel().getColumn(MyTableModel.PARAMETER_NAME_COLUMN).setCellRenderer(new DefaultTableCellRenderer() {\n      public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n        VariableData data = myVariableData[row];\n        setText(data.name);\n        return this;\n      }\n    });\n\n    myParameterTypeSelectors = new TypeSelector[myVariableData.length];\n    for (int i = 0; i < myParameterTypeSelectors.length; i++) {\n      PsiExpression[] occurrences = findVariableOccurrences(scopeElements, myVariableData[i].variable);\n      TypeSelectorManager manager = new TypeSelectorManagerImpl(myProject, myVariableData[i].type, occurrences);\n      myParameterTypeSelectors[i] = manager.getTypeSelector();\n    }\n\n    myTable.getColumnModel().getColumn(MyTableModel.PARAMETER_TYPE_COLUMN).setCellEditor(new AbstractTableCellEditor() {\n      TypeSelector myCurrentSelector;\n      public Object getCellEditorValue() {\n        return myCurrentSelector.getSelectedType();\n      }\n\n      public Component getTableCellEditorComponent(final JTable table,\n                                                   final Object value,\n                                                   final boolean isSelected,\n                                                   final int row,\n                                                   final int column) {\n        myCurrentSelector = myParameterTypeSelectors[row];\n        return myCurrentSelector.getComponent();\n      }\n    });\n\n    myTable.getColumnModel().getColumn(MyTableModel.PARAMETER_TYPE_COLUMN).setCellRenderer(new DefaultTableCellRenderer() {\n      public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n        VariableData data = myVariableData[row];\n        setText(data.type.getPresentableText());\n        return this;\n      }\n    });\n\n    myTable.setPreferredScrollableViewportSize(new Dimension(250, myTable.getRowHeight() * 5));\n    myTable.setShowGrid(false);\n    myTable.setIntercellSpacing(new Dimension(0, 0));\n    @NonNls final InputMap inputMap = myTable.getInputMap();\n    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), \"enable_disable\");\n    @NonNls final ActionMap actionMap = myTable.getActionMap();\n    actionMap.put(\"enable_disable\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (myTable.isEditing()) return;\n        int[] rows = myTable.getSelectedRows();\n        if (rows.length > 0) {\n          boolean valueToBeSet = false;\n          for (int row : rows) {\n            if (!myVariableData[row].passAsParameter) {\n              valueToBeSet = true;\n              break;\n            }\n          }\n          for (int row : rows) {\n            myVariableData[row].passAsParameter = valueToBeSet;\n          }\n          myTableModel.fireTableRowsUpdated(rows[0], rows[rows.length - 1]);\n          TableUtil.selectRows(myTable, rows);\n        }\n      }\n    });\n    // F2 should edit the name\n    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0), \"edit_parameter_name\");\n    actionMap.put(\"edit_parameter_name\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        if (!myTable.isEditing()) {\n          int row = myTable.getSelectedRow();\n          if (row >= 0 && row < myTableModel.getRowCount()) {\n            TableUtil.editCellAt(myTable, row, MyTableModel.PARAMETER_NAME_COLUMN);\n          }\n        }\n      }\n    });\n\n    // make ENTER work when the table has focus\n    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"invokeImpl\");\n    actionMap.put(\"invokeImpl\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        TableCellEditor editor = myTable.getCellEditor();\n        if (editor != null) {\n          editor.stopCellEditing();\n        }\n        else {\n          doEnterAction();\n        }\n      }\n    });\n\n    // make ESCAPE work when the table has focus\n    actionMap.put(\"doCancel\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        TableCellEditor editor = myTable.getCellEditor();\n        if (editor != null) {\n          editor.stopCellEditing();\n        }\n        else {\n          doCancelAction();\n        }\n      }\n    });\n\n    JPanel listPanel = new JPanel(new BorderLayout());\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTable);\n    listPanel.add(scrollPane, BorderLayout.CENTER);\n    listPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    add(listPanel, BorderLayout.CENTER);\n\n    JPanel buttonsPanel = new JPanel();\n    buttonsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    add(buttonsPanel, BorderLayout.EAST);\n\n    buttonsPanel.setLayout(new GridBagLayout());\n    GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n    gbConstraints.insets = new Insets(2, 4, 2, 4);\n\n    myUpButton = new JButton();\n    myUpButton.setText(RefactoringBundle.message(\"row.move.up\"));\n    myUpButton.setDefaultCapable(false);\n    buttonsPanel.add(myUpButton, gbConstraints);\n\n    myDownButton = new JButton();\n    myDownButton.setText(RefactoringBundle.message(\"row.move.down\"));\n    myDownButton.setDefaultCapable(false);\n    buttonsPanel.add(myDownButton, gbConstraints);\n\n    gbConstraints.weighty = 1;\n    buttonsPanel.add(new JPanel(), gbConstraints);\n\n    myUpButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myTable.isEditing()) {\n          final boolean isStopped = myTable.getCellEditor().stopCellEditing();\n          if (!isStopped) return;\n        }\n        moveSelectedItem(-1);\n        updateSignature();\n        myTable.requestFocus();\n      }\n    });\n\n    myDownButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myTable.isEditing()) {\n          final boolean isStopped = myTable.getCellEditor().stopCellEditing();\n          if (!isStopped) return;\n        }\n        moveSelectedItem(+1);\n        updateSignature();\n        myTable.requestFocus();\n      }\n    });\n\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateMoveButtons();\n      }\n    });\n    if (myVariableData.length <= 1) {\n      myUpButton.setEnabled(false);\n      myDownButton.setEnabled(false);\n    }\n    else {\n      myTable.getSelectionModel().setSelectionInterval(0, 0);\n    }\n    updateMoveButtons();\n  }","commit_id":"f8c8303bce4b5546b7bb5cc38edde5adc5be4ed3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isCellEditable(int rowIndex, int columnIndex) {\n      switch (columnIndex) {\n        case CHECKMARK_COLUMN:\n          return isEnabled();\n        case PARAMETER_NAME_COLUMN:\n        case PARAMETER_TYPE_COLUMN:\n          return isEnabled() && myVariableData[rowIndex].passAsParameter;\n        default:\n          return false;\n      }\n    }","id":45859,"modified_method":"public boolean isCellEditable(int rowIndex, int columnIndex) {\n      switch (columnIndex) {\n        case CHECKMARK_COLUMN:\n          return isEnabled();\n        case PARAMETER_NAME_COLUMN:\n          return isEnabled() && myVariableData[rowIndex].passAsParameter;\n        case PARAMETER_TYPE_COLUMN:\n          return isEnabled() && myVariableData[rowIndex].passAsParameter && !(myParameterTypeSelectors[rowIndex].getComponent() instanceof JLabel);\n        default:\n          return false;\n      }\n    }","commit_id":"f8c8303bce4b5546b7bb5cc38edde5adc5be4ed3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TypeSelector(PsiType type) {\n    myType = type;\n    myComponent = new JLabel(myType.getCanonicalText());\n    myComboBoxModel = null;\n  }","id":45860,"modified_method":"public TypeSelector(PsiType type) {\n    myType = type;\n    myComponent = new JLabel(myType.getPresentableText());\n    myComboBoxModel = null;\n  }","commit_id":"f8c8303bce4b5546b7bb5cc38edde5adc5be4ed3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TypeSelectorManagerImpl(Project project, PsiType type, PsiExpression[] occurrences) {\n    myFactory = PsiManager.getInstance(project).getElementFactory();\n    myDefaultType = type;\n    myMainOccurence = null;\n    myOccurrences = occurrences;\n    myExpectedTypesProvider = ExpectedTypesProvider.getInstance(project);\n    myOccurrenceClassProvider = createOccurrenceClassProvider();\n    myTypesForAll = getTypesForAll();\n    myTypesForMain = PsiType.EMPTY_ARRAY;\n    myIsOneSuggestion = true;\n    myTypeSelector = new TypeSelector();\n    myTypeSelector.setTypes(myTypesForAll);\n  }","id":45861,"modified_method":"public TypeSelectorManagerImpl(Project project, PsiType type, PsiExpression[] occurrences) {\n    myFactory = PsiManager.getInstance(project).getElementFactory();\n    myDefaultType = type;\n    myMainOccurence = null;\n    myOccurrences = occurrences;\n    myExpectedTypesProvider = ExpectedTypesProvider.getInstance(project);\n    myOccurrenceClassProvider = createOccurrenceClassProvider();\n    myTypesForAll = getTypesForAll();\n    myTypesForMain = PsiType.EMPTY_ARRAY;\n    myIsOneSuggestion = myTypesForAll.length == 1;\n\n    if (myIsOneSuggestion) {\n      myTypeSelector = new TypeSelector(myTypesForAll[0]);\n    }\n    else {\n      myTypeSelector = new TypeSelector();\n      myTypeSelector.setTypes(myTypesForAll);\n    }\n  }","commit_id":"f8c8303bce4b5546b7bb5cc38edde5adc5be4ed3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JCExpression transform(Tree.PostfixOperatorExpression expr) {\n        OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            return makeErroneous(expr, \"Not supported yet: \"+expr.getNodeType());\n        }\n        \n        OptimisationStrategy optimisationStrategy = operator.getOptimisationStrategy(expr, this);\n        boolean canOptimise = optimisationStrategy.useJavaOperator();\n        \n        // only fully optimise if we don't have to access the getter/setter\n        if(canOptimise && Util.isDirectAccessVariable(expr.getTerm())){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n        \n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getTypeArgument(valueType, 0);\n\n        Tree.Term term = expr.getTerm();\n        List<JCVariableDecl> decls = List.nil();\n        List<JCStatement> stats = List.nil();\n        JCExpression result = null;\n        // we can optimise that case a bit sometimes\n        boolean boxResult = !canOptimise;\n\n        // attr++\n        // (let $tmp = attr; attr = $tmp.getSuccessor(); $tmp;)\n        if(term instanceof Tree.BaseMemberExpression){\n            JCExpression getter = transform((Tree.BaseMemberExpression)term, null);\n            at(expr);\n            // Type $tmp = attr\n            JCExpression exprType = makeJavaType(returnType, boxResult ? NO_PRIMITIVES : 0);\n            Name varName = names().fromString(tempName(\"op\"));\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, boxResult ? BoxingStrategy.BOXED : BoxingStrategy.UNBOXED, returnType);\n            JCVariableDecl tmpVar = make().VarDef(make().Modifiers(0), varName, exprType, getter);\n            decls = decls.prepend(tmpVar);\n\n            // attr = $tmp.getSuccessor()\n            JCExpression successor;\n            if(canOptimise){\n                // use +1/-1 if we can optimise a bit\n                successor = make().Binary(operator == OperatorTranslation.UNARY_POSTFIX_INCREMENT ? JCTree.PLUS : JCTree.MINUS, \n                        make().Ident(varName), makeInteger(1));\n            }else{\n                successor = make().Apply(null, \n                                         makeSelect(make().Ident(varName), operator.ceylonMethod), \n                                         List.<JCExpression>nil());\n                // make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n                successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            }\n            JCExpression assignment = transformAssignment(expr, term, successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n\n            // $tmp\n            result = make().Ident(varName);\n        }\n        else if(term instanceof Tree.QualifiedMemberExpression){\n            // e.attr++\n            // (let $tmpE = e, $tmpV = $tmpE.attr; $tmpE.attr = $tmpV.getSuccessor(); $tmpV;)\n            Tree.QualifiedMemberExpression qualified = (Tree.QualifiedMemberExpression) term;\n\n            // transform the primary, this will get us a boxed primary \n            JCExpression e = transformQualifiedMemberPrimary(qualified);\n            at(expr);\n            \n            // Type $tmpE = e\n            JCExpression exprType = makeJavaType(qualified.getTarget().getQualifyingType(), NO_PRIMITIVES);\n            Name varEName = names().fromString(tempName(\"opE\"));\n            JCVariableDecl tmpEVar = make().VarDef(make().Modifiers(0), varEName, exprType, e);\n\n            // Type $tmpV = $tmpE.attr\n            JCExpression attrType = makeJavaType(returnType, boxResult ? NO_PRIMITIVES : 0);\n            Name varVName = names().fromString(tempName(\"opV\"));\n            JCExpression getter = transformMemberExpression(qualified, make().Ident(varEName), null);\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, boxResult ? BoxingStrategy.BOXED : BoxingStrategy.UNBOXED, returnType);\n            JCVariableDecl tmpVVar = make().VarDef(make().Modifiers(0), varVName, attrType, getter);\n\n            // define all the variables\n            decls = decls.prepend(tmpVVar);\n            decls = decls.prepend(tmpEVar);\n            \n            // $tmpE.attr = $tmpV.getSuccessor()\n            JCExpression successor;\n            if(canOptimise){\n                // use +1/-1 if we can optimise a bit\n                successor = make().Binary(operator == OperatorTranslation.UNARY_POSTFIX_INCREMENT ? JCTree.PLUS : JCTree.MINUS, \n                        make().Ident(varVName), makeInteger(1));\n            }else{\n                successor = make().Apply(null, \n                                         makeSelect(make().Ident(varVName), operator.ceylonMethod), \n                                         List.<JCExpression>nil());\n                //  make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n                successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            }\n            JCExpression assignment = transformAssignment(expr, term, make().Ident(varEName), successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n            \n            // $tmpV\n            result = make().Ident(varVName);\n        }else{\n            return makeErroneous(term, \"Not supported yet\");\n        }\n        // e?.attr++ is probably not legal\n        // a[i]++ is not for M1 but will be:\n        // (let $tmpA = a, $tmpI = i, $tmpV = $tmpA.item($tmpI); $tmpA.setItem($tmpI, $tmpV.getSuccessor()); $tmpV;)\n        // a?[i]++ is probably not legal\n        // a[i1..i1]++ and a[i1...]++ are probably not legal\n        // a[].attr++ and a[].e.attr++ are probably not legal\n\n        return make().LetExpr(decls, stats, result);\n    }","id":45862,"modified_method":"public JCExpression transform(Tree.PostfixOperatorExpression expr) {\n        OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            return makeErroneous(expr, \"Not supported yet: \"+expr.getNodeType());\n        }\n        \n        OptimisationStrategy optimisationStrategy = operator.getOptimisationStrategy(expr, this);\n        boolean canOptimise = optimisationStrategy.useJavaOperator();\n        \n        // only fully optimise if we don't have to access the getter/setter\n        if(canOptimise && Util.isDirectAccessVariable(expr.getTerm())){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n        \n        Tree.Term term = expr.getTerm();\n\n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getMostPreciseType(term, getTypeArgument(valueType, 0));\n\n        List<JCVariableDecl> decls = List.nil();\n        List<JCStatement> stats = List.nil();\n        JCExpression result = null;\n        // we can optimise that case a bit sometimes\n        boolean boxResult = !canOptimise;\n\n        // attr++\n        // (let $tmp = attr; attr = $tmp.getSuccessor(); $tmp;)\n        if(term instanceof Tree.BaseMemberExpression){\n            JCExpression getter = transform((Tree.BaseMemberExpression)term, null);\n            at(expr);\n            // Type $tmp = attr\n            JCExpression exprType = makeJavaType(returnType, boxResult ? NO_PRIMITIVES : 0);\n            Name varName = names().fromString(tempName(\"op\"));\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, boxResult ? BoxingStrategy.BOXED : BoxingStrategy.UNBOXED, returnType);\n            JCVariableDecl tmpVar = make().VarDef(make().Modifiers(0), varName, exprType, getter);\n            decls = decls.prepend(tmpVar);\n\n            // attr = $tmp.getSuccessor()\n            JCExpression successor;\n            if(canOptimise){\n                // use +1/-1 if we can optimise a bit\n                successor = make().Binary(operator == OperatorTranslation.UNARY_POSTFIX_INCREMENT ? JCTree.PLUS : JCTree.MINUS, \n                        make().Ident(varName), makeInteger(1));\n                successor = unAutoPromote(successor, returnType);\n            }else{\n                successor = make().Apply(null, \n                                         makeSelect(make().Ident(varName), operator.ceylonMethod), \n                                         List.<JCExpression>nil());\n                // make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n                successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            }\n            JCExpression assignment = transformAssignment(expr, term, successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n\n            // $tmp\n            result = make().Ident(varName);\n        }\n        else if(term instanceof Tree.QualifiedMemberExpression){\n            // e.attr++\n            // (let $tmpE = e, $tmpV = $tmpE.attr; $tmpE.attr = $tmpV.getSuccessor(); $tmpV;)\n            Tree.QualifiedMemberExpression qualified = (Tree.QualifiedMemberExpression) term;\n\n            // transform the primary, this will get us a boxed primary \n            JCExpression e = transformQualifiedMemberPrimary(qualified);\n            at(expr);\n            \n            // Type $tmpE = e\n            JCExpression exprType = makeJavaType(qualified.getTarget().getQualifyingType(), NO_PRIMITIVES);\n            Name varEName = names().fromString(tempName(\"opE\"));\n            JCVariableDecl tmpEVar = make().VarDef(make().Modifiers(0), varEName, exprType, e);\n\n            // Type $tmpV = $tmpE.attr\n            JCExpression attrType = makeJavaType(returnType, boxResult ? NO_PRIMITIVES : 0);\n            Name varVName = names().fromString(tempName(\"opV\"));\n            JCExpression getter = transformMemberExpression(qualified, make().Ident(varEName), null);\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, boxResult ? BoxingStrategy.BOXED : BoxingStrategy.UNBOXED, returnType);\n            JCVariableDecl tmpVVar = make().VarDef(make().Modifiers(0), varVName, attrType, getter);\n\n            // define all the variables\n            decls = decls.prepend(tmpVVar);\n            decls = decls.prepend(tmpEVar);\n            \n            // $tmpE.attr = $tmpV.getSuccessor()\n            JCExpression successor;\n            if(canOptimise){\n                // use +1/-1 if we can optimise a bit\n                successor = make().Binary(operator == OperatorTranslation.UNARY_POSTFIX_INCREMENT ? JCTree.PLUS : JCTree.MINUS, \n                        make().Ident(varVName), makeInteger(1));\n                successor = unAutoPromote(successor, returnType);\n            }else{\n                successor = make().Apply(null, \n                                         makeSelect(make().Ident(varVName), operator.ceylonMethod), \n                                         List.<JCExpression>nil());\n                //  make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n                successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            }\n            JCExpression assignment = transformAssignment(expr, term, make().Ident(varEName), successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n            \n            // $tmpV\n            result = make().Ident(varVName);\n        }else{\n            return makeErroneous(term, \"Not supported yet\");\n        }\n        // e?.attr++ is probably not legal\n        // a[i]++ is not for M1 but will be:\n        // (let $tmpA = a, $tmpI = i, $tmpV = $tmpA.item($tmpI); $tmpA.setItem($tmpI, $tmpV.getSuccessor()); $tmpV;)\n        // a?[i]++ is probably not legal\n        // a[i1..i1]++ and a[i1...]++ are probably not legal\n        // a[].attr++ and a[].e.attr++ are probably not legal\n\n        return make().LetExpr(decls, stats, result);\n    }","commit_id":"ceb2ad2a3480447e4557c4284089771709e387d9","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCExpression transform(final Tree.ArithmeticAssignmentOp op){\n        final AssignmentOperatorTranslation operator = Operators.getAssignmentOperator(op.getClass());\n        if(operator == null){\n            return makeErroneous(op, \"Not supported yet: \"+op.getNodeType());\n        }\n\n        // see if we can optimise it\n        if(op.getUnboxed() && Util.isDirectAccessVariable(op.getLeftTerm())){\n            return optimiseAssignmentOperator(op, operator);\n        }\n        \n        // we can use unboxed types if both operands are unboxed\n        final boolean boxResult = !op.getUnboxed();\n        \n        // find the proper type\n        Interface compoundType = op.getUnit().getNumericDeclaration();\n        if(op instanceof Tree.AddAssignOp){\n            compoundType = op.getUnit().getSummableDeclaration();\n        }else if(op instanceof Tree.RemainderAssignOp){\n            compoundType = op.getUnit().getIntegralDeclaration();\n        }\n        \n        final ProducedType leftType = getSupertype(op.getLeftTerm(), compoundType);\n        final ProducedType rightType = getTypeArgument(leftType, 0);\n\n        // we work on boxed types\n        return transformAssignAndReturnOperation(op, op.getLeftTerm(), boxResult, \n                leftType, rightType, \n                new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // make this call: previousValue OP RHS\n                return transformOverridableBinaryOperator(op, operator.binaryOperator, \n                        boxResult ? OptimisationStrategy.NONE : OptimisationStrategy.OPTIMISE, \n                        previousValue, rightType);\n            }\n        });\n    }","id":45863,"modified_method":"public JCExpression transform(final Tree.ArithmeticAssignmentOp op){\n        final AssignmentOperatorTranslation operator = Operators.getAssignmentOperator(op.getClass());\n        if(operator == null){\n            return makeErroneous(op, \"Not supported yet: \"+op.getNodeType());\n        }\n\n        // see if we can optimise it\n        if(op.getUnboxed() && Util.isDirectAccessVariable(op.getLeftTerm())){\n            return optimiseAssignmentOperator(op, operator);\n        }\n        \n        // we can use unboxed types if both operands are unboxed\n        final boolean boxResult = !op.getUnboxed();\n        \n        // find the proper type\n        Interface compoundType = op.getUnit().getNumericDeclaration();\n        if(op instanceof Tree.AddAssignOp){\n            compoundType = op.getUnit().getSummableDeclaration();\n        }else if(op instanceof Tree.RemainderAssignOp){\n            compoundType = op.getUnit().getIntegralDeclaration();\n        }\n        \n        final ProducedType leftType = getSupertype(op.getLeftTerm(), compoundType);\n        final ProducedType rightType = getMostPreciseType(op.getLeftTerm(), getTypeArgument(leftType, 0));\n\n        // we work on boxed types\n        return transformAssignAndReturnOperation(op, op.getLeftTerm(), boxResult, \n                leftType, rightType, \n                new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // make this call: previousValue OP RHS\n                JCExpression ret = transformOverridableBinaryOperator(op, operator.binaryOperator, \n                        boxResult ? OptimisationStrategy.NONE : OptimisationStrategy.OPTIMISE, \n                        previousValue, rightType);\n                ret = unAutoPromote(ret, rightType);\n                return ret;\n            }\n        });\n    }","commit_id":"ceb2ad2a3480447e4557c4284089771709e387d9","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCExpression transform(Tree.PrefixOperatorExpression expr) {\n        final OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            return makeErroneous(expr, \"Not supported yet: \"+expr.getNodeType());\n        }\n        \n        OptimisationStrategy optimisationStrategy = operator.getOptimisationStrategy(expr, this);\n        final boolean canOptimise = optimisationStrategy.useJavaOperator();\n        \n        // only fully optimise if we don't have to access the getter/setter\n        if(canOptimise && Util.isDirectAccessVariable(expr.getTerm())){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n\n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getTypeArgument(valueType, 0);\n        \n        // we work on boxed types unless we could have optimised\n        return transformAssignAndReturnOperation(expr, expr.getTerm(), !canOptimise, \n                valueType, returnType, new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // use +1/-1 if we can optimise a bit\n                if(canOptimise){\n                    return make().Binary(operator == OperatorTranslation.UNARY_PREFIX_INCREMENT ? JCTree.PLUS : JCTree.MINUS, \n                            previousValue, makeInteger(1));\n                }\n                // make this call: previousValue.getSuccessor() or previousValue.getPredecessor()\n                return make().Apply(null, makeSelect(previousValue, operator.ceylonMethod), List.<JCExpression>nil());\n            }\n        });\n    }","id":45864,"modified_method":"public JCExpression transform(final Tree.PrefixOperatorExpression expr) {\n        final OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            return makeErroneous(expr, \"Not supported yet: \"+expr.getNodeType());\n        }\n        \n        OptimisationStrategy optimisationStrategy = operator.getOptimisationStrategy(expr, this);\n        final boolean canOptimise = optimisationStrategy.useJavaOperator();\n        \n        Term term = expr.getTerm();\n        // only fully optimise if we don't have to access the getter/setter\n        if(canOptimise && Util.isDirectAccessVariable(term)){\n            JCExpression jcTerm = transformExpression(term, BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, jcTerm);\n        }\n\n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(term, compoundType);\n        final ProducedType returnType = getMostPreciseType(term, getTypeArgument(valueType, 0));\n        \n        // we work on boxed types unless we could have optimised\n        return transformAssignAndReturnOperation(expr, term, !canOptimise, \n                valueType, returnType, new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // use +1/-1 if we can optimise a bit\n                if(canOptimise){\n                    JCExpression ret = make().Binary(operator == OperatorTranslation.UNARY_PREFIX_INCREMENT ? JCTree.PLUS : JCTree.MINUS, \n                            previousValue, makeInteger(1));\n                    ret = unAutoPromote(ret, returnType);\n                    return ret;\n                }\n                // make this call: previousValue.getSuccessor() or previousValue.getPredecessor()\n                return make().Apply(null, makeSelect(previousValue, operator.ceylonMethod), List.<JCExpression>nil());\n            }\n        });\n    }","commit_id":"ceb2ad2a3480447e4557c4284089771709e387d9","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** {@inheritDoc} */\n    @Override public boolean test(Map<Object, Object> ctx) throws Exception {\n        int orgId = nextRandom(orgRange);\n\n        Collection<List<?>> res = executeQueryJoin(orgId, broadcast, false);\n\n        int persons = orgId % 10 + 1;\n\n        if (res.size() != persons)\n            throw new Exception(\"Invalid join result [orgId=\" + orgId + \", resSize=\" + res.size() + ']');\n\n        for (List<?> l : res) {\n            int orgId0 = (Integer)l.get(1);\n\n            if (orgId != orgId0)\n                throw new Exception(\"Invalid join result [orgId=\" + orgId + \", res=\" + l + ']');\n        }\n\n        return true;\n    }","id":45865,"modified_method":"/** {@inheritDoc} */\n    @Override public boolean test(Map<Object, Object> ctx) throws Exception {\n        int orgId = nextRandom(range);\n\n        Collection<List<?>> res = executeQueryJoin(orgId, broadcast, false);\n\n        int persons = 1;\n\n        if (res.size() != persons)\n            throw new Exception(\"Invalid join result [orgId=\" + orgId + \", resSize=\" + res.size() + ']');\n\n        for (List<?> l : res) {\n            int orgId0 = (Integer)l.get(1);\n\n            if (orgId != orgId0)\n                throw new Exception(\"Invalid join result [orgId=\" + orgId + \", res=\" + l + ']');\n        }\n\n        return true;\n    }","commit_id":"808eab475eb8e301253a8137feb140f5ec6cdf09","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void setUp(BenchmarkConfiguration cfg) throws Exception {\n        super.setUp(cfg);\n\n        broadcast = broadcastJoin();\n\n        println(cfg, \"Populating query data...\");\n\n        long start = System.nanoTime();\n\n        int personCnt = 0;\n\n        try (IgniteDataStreamer<Object, Object> dataLdr = ignite().dataStreamer(cache.getName())) {\n            orgRange = args.range() / 10;\n\n            if (orgRange <= 0)\n                throw new IllegalArgumentException();\n\n            // Populate organizations.\n            for (int orgId = 0; orgId < orgRange; orgId++) {\n                dataLdr.addData(orgId, new Organization(orgId, \"org\" + orgId));\n\n                if (orgId % 1000 == 0 && Thread.currentThread().isInterrupted())\n                    return;\n            }\n\n            dataLdr.flush();\n\n            // Populate persons.\n            for (int orgId = 0; orgId < orgRange; orgId++) {\n                int persons = orgId % 10 + 1;\n\n                for (int j = 0; j < persons; j++) {\n                    int personId = orgRange + personCnt++;\n\n                    Person p = new Person(personId,\n                        orgId,\n                        \"firstName\" + personId,\n                        \"lastName\" + personId, 1000);\n\n                    dataLdr.addData(personId, p);\n                }\n\n                if (personCnt % 100000 == 0)\n                    println(cfg, \"Populated persons: \" + personCnt);\n\n                if (orgId % 1000 == 0 && Thread.currentThread().isInterrupted())\n                    return;\n            }\n\n            dataLdr.close();\n        }\n\n        println(cfg, \"Finished populating join query [orgCnt=\" + orgRange +\n            \", personCnt=\" + personCnt +\n            \", broadcastJoin=\" + broadcast +\n            \", time=\" + ((System.nanoTime() - start) / 1_000_000) + \"ms]\");\n\n        executeQueryJoin(0, broadcast, true);\n    }","id":45866,"modified_method":"/** {@inheritDoc} */\n    @Override public void setUp(BenchmarkConfiguration cfg) throws Exception {\n        super.setUp(cfg);\n\n        broadcast = broadcastJoin();\n\n        println(cfg, \"Populating query data...\");\n\n        long start = System.nanoTime();\n\n        range = args.range();\n\n        if (range <= 0)\n            throw new IllegalArgumentException();\n\n        try (IgniteDataStreamer<Object, Object> dataLdr = ignite().dataStreamer(cache.getName())) {\n            for (int orgId = 0; orgId < range; orgId++) {\n                dataLdr.addData(orgId, new Organization(orgId, \"org\" + orgId));\n\n                int personId = range + orgId;\n\n                Person p = new Person(personId,\n                    orgId,\n                    \"firstName\" + personId,\n                    \"lastName\" + personId, 1000);\n\n                dataLdr.addData(personId, p);\n\n                if (orgId % 1000 == 0 && Thread.currentThread().isInterrupted())\n                    return;\n            }\n\n            dataLdr.close();\n        }\n\n        println(cfg, \"Finished populating join query [orgCnt=\" + range +\n            \", personCnt=\" + range +\n            \", broadcastJoin=\" + broadcast +\n            \", time=\" + ((System.nanoTime() - start) / 1_000_000) + \"ms]\");\n\n        executeQueryJoin(0, broadcast, true);\n    }","commit_id":"808eab475eb8e301253a8137feb140f5ec6cdf09","url":"https://github.com/apache/ignite"},{"original_method":"/**\n   * Creates a new data reference for the specified input, or returns a\n   * reference to an already opened file or database.\n   * @param input file path or name of database\n   * @param col collection flag\n   * @param ii input info\n   * @return data reference\n   * @throws QueryException query exception\n   */\n  public Data data(final byte[] input, final boolean col, final InputInfo ii)\n      throws QueryException {\n\n    // check if a database with the same name has already been opened\n    final String in = string(input);\n    for(int d = 0; d < datas; ++d) {\n      if(data[d].meta.name.equals(in)) return data[d];\n    }\n\n    // check if a database with the same file path has already been opened\n    final IO io = IO.get(in);\n    for(int d = 0; d < datas; ++d) {\n      if(IO.get(data[d].meta.path).eq(io)) return data[d];\n    }\n\n    // retrieve and add new data reference\n    Data d = doc(in, ctx.baseURI == Uri.EMPTY, col, ii);\n    if(d == null) d = doc(ctx.base().merge(in).path(), true, col, ii);\n    addData(d);\n    return d;\n  }","id":45867,"modified_method":"/**\n   * Creates a new data reference for the specified input, or returns a\n   * reference to an already opened file or database.\n   * @param input file path or name of database\n   * @param col collection flag\n   * @param ii input info\n   * @return data reference\n   * @throws QueryException query exception\n   */\n  public Data data(final byte[] input, final boolean col, final InputInfo ii)\n      throws QueryException {\n\n    // check if a database with the same name has already been opened\n    final String in = string(input);\n    for(int d = 0; d < datas; ++d) {\n      if(data[d].meta.name.equals(in)) return data[d];\n    }\n\n    // check if a database with the same file path has already been opened\n    final IO io = IO.get(in);\n    for(int d = 0; d < datas; ++d) {\n      if(IO.get(data[d].meta.path).eq(io)) return data[d];\n    }\n\n    // retrieve and add new data reference\n    Data d = doc(in, ctx.baseURI == Uri.EMPTY, col, ii);\n    if(d == null) d = doc(ctx.base().merge(in).path(), true, col, ii);\n    return addData(d);\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Adds a data reference to the global list.\n   * @param d data reference to be added\n   */\n  private void addData(final Data d) {\n    if(datas == data.length) {\n      final Data[] tmp = new Data[Array.newSize(datas)];\n      System.arraycopy(data, 0, tmp, 0, datas);\n      data = tmp;\n    }\n    data[datas++] = d;\n  }","id":45868,"modified_method":"/**\n   * Adds a data reference to the global list.\n   * @param d data reference to be added\n   * @return data reference\n   */\n  private Data addData(final Data d) {\n    if(datas == data.length) {\n      final Data[] tmp = new Data[Array.newSize(datas)];\n      System.arraycopy(data, 0, tmp, 0, datas);\n      data = tmp;\n    }\n    data[datas++] = d;\n    return d;\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Opens a new database or returns a reference to an already opened database.\n   * @param name name of database\n   * @param ii input info\n   * @return database instance\n   * @throws QueryException query exception\n   */\n  public Data data(final byte[] name, final InputInfo ii)\n      throws QueryException {\n\n    // check if a database with the same name has already been opened\n    final String in = string(name);\n    for(int d = 0; d < datas; ++d) {\n      if(data[d].meta.name.equals(in)) return data[d];\n    }\n\n    try {\n      // open database\n      final Data d = Open.open(in, ctx.context);\n      addData(d);\n      return d;\n    } catch(final IOException ex) {\n      throw NODB.thrw(ii, in);\n    }\n  }","id":45869,"modified_method":"/**\n   * Opens a new database or returns a reference to an already opened database.\n   * @param name name of database\n   * @param ii input info\n   * @return database instance\n   * @throws QueryException query exception\n   */\n  public Data data(final byte[] name, final InputInfo ii)\n      throws QueryException {\n\n    // check if a database with the same name has already been opened\n    final String in = string(name);\n    for(int d = 0; d < datas; ++d) {\n      if(data[d].meta.name.equals(in)) return data[d];\n    }\n\n    try {\n      // open and add new data reference\n      return addData(Open.open(in, ctx.context));\n    } catch(final IOException ex) {\n      throw NODB.thrw(ii, in);\n    }\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Removes a package from package repository.\n   * @param pkg package\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public void delete(final String pkg, final InputInfo ii)\n      throws QueryException {\n    boolean found = false;\n    for(final byte[] nextPkg : ctx.repo.pkgDict()) {\n      if(nextPkg != null) {\n        final byte[] dir = ctx.repo.pkgDict().get(nextPkg);\n        if(eq(Package.getName(nextPkg), token(pkg)) || eq(dir, token(pkg))) {\n          // A package can be deleted either by its name or by its directory\n          // name\n          found = true;\n          // Check if package to be deleted participates in a dependency\n          final byte[] primPkg = getPrimary(nextPkg, ii);\n          if(primPkg == null) {\n            // Clean package repository\n            final File f = new File(ctx.repo.path, string(dir));\n            final File desc = new File(f, DESCRIPTOR);\n            ctx.repo.remove(new PkgParser(ctx, ii).parse(new IOFile(desc)));\n            // Package does not participate in a dependency => delete it\n            deleteFromDisc(f, ii);\n          } else PKGDEP.thrw(ii, string(primPkg), pkg);\n        }\n      }\n    }\n    if(!found) PKGNOTINST.thrw(ii, pkg);\n  }","id":45870,"modified_method":"/**\n   * Removes a package from package repository.\n   * @param pkg package\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public void delete(final String pkg, final InputInfo ii)\n      throws QueryException {\n    boolean found = false;\n    for(final byte[] nextPkg : ctx.repo.pkgDict()) {\n      if(nextPkg != null) {\n        final byte[] dir = ctx.repo.pkgDict().get(nextPkg);\n        if(eq(Package.getName(nextPkg), token(pkg)) || eq(dir, token(pkg))) {\n          // A package can be deleted either by its name or by its directory\n          // name\n          found = true;\n          // Check if package to be deleted participates in a dependency\n          final byte[] primPkg = getPrimary(nextPkg, ii);\n          if(primPkg == null) {\n            // Clean package repository\n            final File f = new File(ctx.repo.path, string(dir));\n            final File desc = new File(f, DESCRIPTOR);\n            ctx.repo.remove(new PkgParser(ctx, ii).parse(new IOFile(desc)));\n            // Package does not participate in a dependency => delete it\n            if(!new IOFile(f).delete()) CANNOTDELPKG.thrw(ii);\n          } else PKGDEP.thrw(ii, string(primPkg), pkg);\n        }\n      }\n    }\n    if(!found) PKGNOTINST.thrw(ii, pkg);\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Installs a new package.\n   * @param path package path\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public void install(final String path, final InputInfo ii)\n      throws QueryException {\n\n    // Check repository\n    createRepo();\n    // Check package existence\n    final File pkgFile = new File(path);\n    if(!pkgFile.exists()) PKGNOTEXIST.thrw(ii, path);\n    // Check package name - must be a .xar file\n    checkPkgName(path, ii);\n\n    try {\n      final ZipFile xar = new ZipFile(pkgFile);\n      final byte[] cont = FNZip.read(xar, DESCRIPTOR);\n      final Package pkg = new PkgParser(ctx, ii).parse(new IOContent(cont));\n      new PkgValidator(ctx, ii).check(pkg);\n      unzip(xar);\n      ctx.repo.add(pkg, extractPkgName(xar.getName()));\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      throw PKGREADFAIL.thrw(ii, ex.getMessage());\n    }\n  }","id":45871,"modified_method":"/**\n   * Installs a new package.\n   * @param path package path\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public void install(final String path, final InputInfo ii)\n      throws QueryException {\n\n    // Check repository if not done yet\n    new File(ctx.repo.path).mkdirs();\n    // Check package existence\n    final File pkgFile = new File(path);\n    if(!pkgFile.exists()) PKGNOTEXIST.thrw(ii, path);\n    // Check package name - must be a .xar file\n    checkPkgName(path, ii);\n\n    try {\n      final ZipFile xar = new ZipFile(pkgFile);\n      final byte[] cont = FNZip.read(xar, DESCRIPTOR);\n      final Package pkg = new PkgParser(ctx, ii).parse(new IOContent(cont));\n      new PkgValidator(ctx, ii).check(pkg);\n      unzip(xar);\n      ctx.repo.add(pkg, extractPkgName(xar.getName()));\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      throw PKGREADFAIL.thrw(ii, ex.getMessage());\n    }\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Unzips a package in the package repository.\n   * @param xar package archive\n   * @throws IOException I/O exception\n   */\n  private void unzip(final ZipFile xar) throws IOException {\n    final File dir = new File(repoPath(), extractPkgName(xar.getName()));\n    dir.mkdir();\n\n    final Enumeration<? extends ZipEntry> en = xar.entries();\n    while(en.hasMoreElements()) {\n      final ZipEntry entry = en.nextElement();\n      final File f = new File(dir, entry.getName());\n      if(entry.isDirectory()) {\n        f.mkdirs();\n      } else {\n        f.getParentFile().mkdirs();\n        final OutputStream out = new FileOutputStream(f);\n        final InputStream in = xar.getInputStream(entry);\n        try {\n          final byte[] data = new byte[IO.BLOCKSIZE];\n          for(int c; (c = in.read(data)) != -1;)\n            out.write(data, 0, c);\n        } finally {\n          try {\n            out.close();\n          } catch(final IOException e) { }\n          try {\n            in.close();\n          } catch(final IOException e) { }\n        }\n      }\n    }\n  }","id":45872,"modified_method":"/**\n   * Unzips a package in the package repository.\n   * @param xar package archive\n   * @throws IOException I/O exception\n   */\n  private void unzip(final ZipFile xar) throws IOException {\n    final File repo = new File(ctx.repo.path);\n    final File dir = new File(repo, extractPkgName(xar.getName()));\n    dir.mkdir();\n\n    final Enumeration<? extends ZipEntry> en = xar.entries();\n    while(en.hasMoreElements()) {\n      final ZipEntry entry = en.nextElement();\n      final File f = new File(dir, entry.getName());\n      if(entry.isDirectory()) {\n        f.mkdirs();\n      } else {\n        f.getParentFile().mkdirs();\n        final OutputStream out = new FileOutputStream(f);\n        final InputStream in = xar.getInputStream(entry);\n        try {\n          final byte[] data = new byte[IO.BLOCKSIZE];\n          for(int c; (c = in.read(data)) != -1;)\n            out.write(data, 0, c);\n        } finally {\n          try {\n            out.close();\n          } catch(final IOException e) { }\n          try {\n            in.close();\n          } catch(final IOException e) { }\n        }\n      }\n    }\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns information on all users.\r\n   * @param users optional second list\r\n   * @return user information\r\n   */\r\n  public synchronized byte[] info(final Users users) {\r\n    final Table table = new Table();\r\n    table.description = USERS;\r\n\r\n    final int sz = file == null ? 3 : 5;\r\n    for(int u = 0; u < sz; ++u) table.header.add(USERHEAD[u]);\r\n\r\n    for(final User user : list) {\r\n      if(users != null) if(users.get(user.name) == null) continue;\r\n\r\n      final TokenList entry = new TokenList();\r\n      entry.add(user.name);\r\n      entry.add(user.perm(User.READ) ? \"X\" : \"\");\r\n      entry.add(user.perm(User.WRITE) ? \"X\" : \"\");\r\n      if(sz == 5) {\r\n        entry.add(user.perm(User.CREATE) ? \"X\" : \"\");\r\n        entry.add(user.perm(User.ADMIN) ? \"X\" : \"\");\r\n      }\r\n      table.contents.add(entry);\r\n    }\r\n    table.sort();\r\n    table.toTop(token(ADMIN));\r\n    return table.finish();\r\n  }","id":45873,"modified_method":"/**\r\n   * Returns information on all users.\r\n   * @param users optional second list\r\n   * @return user information\r\n   */\r\n  public synchronized byte[] info(final Users users) {\r\n    final Table table = new Table();\r\n    table.description = USERS;\r\n\r\n    final int sz = file == null ? 3 : 5;\r\n    for(int u = 0; u < sz; ++u) table.header.add(USERHEAD[u]);\r\n\r\n    for(final User user : list) {\r\n      if(users != null) if(users.get(user.name) == null) continue;\r\n\r\n      final TokenList tl = new TokenList();\r\n      tl.add(user.name);\r\n      tl.add(user.perm(User.READ) ? \"X\" : \"\");\r\n      tl.add(user.perm(User.WRITE) ? \"X\" : \"\");\r\n      if(sz == 5) {\r\n        tl.add(user.perm(User.CREATE) ? \"X\" : \"\");\r\n        tl.add(user.perm(User.ADMIN) ? \"X\" : \"\");\r\n      }\r\n      table.contents.add(tl);\r\n    }\r\n    table.sort();\r\n    table.toTop(token(ADMIN));\r\n    return table.finish();\r\n  }","commit_id":"fc3ed66d5741fcc9da7d8cc20023d7c9c6d49fe1","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected void upgradeTable(\n\t\t\tString tableName, String columnName, String[][] names,\n\t\t\tWildcardMode wildcardMode)\n\t\tthrows SQLException {\n\n\t\ttry (LoggingTimer loggingTimer = new LoggingTimer(tableName)) {\n\t\t\tStringBundler updateSB = new StringBundler(7);\n\n\t\t\tupdateSB.append(\"update \");\n\t\t\tupdateSB.append(tableName);\n\t\t\tupdateSB.append(\" set \");\n\t\t\tupdateSB.append(columnName);\n\t\t\tupdateSB.append(\" = ? where \");\n\t\t\tupdateSB.append(columnName);\n\t\t\tupdateSB.append(\" = ?\");\n\n\t\t\tString updateSQL = updateSB.toString();\n\n\t\t\tStringBundler selectPrefixSB = new StringBundler(7);\n\n\t\t\tselectPrefixSB.append(\"select distinct \");\n\t\t\tselectPrefixSB.append(columnName);\n\t\t\tselectPrefixSB.append(\" from \");\n\t\t\tselectPrefixSB.append(tableName);\n\t\t\tselectPrefixSB.append(\" where \");\n\t\t\tselectPrefixSB.append(columnName);\n\n\t\t\tif (wildcardMode.equals(WildcardMode.LEADING) ||\n\t\t\t\twildcardMode.equals(WildcardMode.SURROUND)) {\n\n\t\t\t\tselectPrefixSB.append(\" like '%\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselectPrefixSB.append(\" like '\");\n\t\t\t}\n\n\t\t\tString selectPrefix = selectPrefixSB.toString();\n\n\t\t\tString selectPostfix = StringPool.APOSTROPHE;\n\n\t\t\tif (wildcardMode.equals(WildcardMode.SURROUND) ||\n\t\t\t\twildcardMode.equals(WildcardMode.TRAILING)) {\n\n\t\t\t\tselectPostfix = \"%'\";\n\t\t\t}\n\n\t\t\tfor (String[] name : names) {\n\t\t\t\tString selectSQL = selectPrefix.concat(name[0]).concat(\n\t\t\t\t\tselectPostfix);\n\n\t\t\t\tupgradeTable(columnName, selectSQL, updateSQL, name);\n\t\t\t}\n\t\t}\n\t}","id":45874,"modified_method":"protected void upgradeTable(\n\t\t\tList<Future<Void>> futures, String tableName, String columnName,\n\t\t\tString[][] names, WildcardMode wildcardMode)\n\t\tthrows SQLException {\n\n\t\ttry (LoggingTimer loggingTimer = new LoggingTimer(tableName)) {\n\t\t\tStringBundler updateSB = new StringBundler(7);\n\n\t\t\tupdateSB.append(\"update \");\n\t\t\tupdateSB.append(tableName);\n\t\t\tupdateSB.append(\" set \");\n\t\t\tupdateSB.append(columnName);\n\t\t\tupdateSB.append(\" = ? where \");\n\t\t\tupdateSB.append(columnName);\n\t\t\tupdateSB.append(\" = ?\");\n\n\t\t\tString updateSQL = updateSB.toString();\n\n\t\t\tStringBundler selectPrefixSB = new StringBundler(7);\n\n\t\t\tselectPrefixSB.append(\"select distinct \");\n\t\t\tselectPrefixSB.append(columnName);\n\t\t\tselectPrefixSB.append(\" from \");\n\t\t\tselectPrefixSB.append(tableName);\n\t\t\tselectPrefixSB.append(\" where \");\n\t\t\tselectPrefixSB.append(columnName);\n\n\t\t\tif (wildcardMode.equals(WildcardMode.LEADING) ||\n\t\t\t\twildcardMode.equals(WildcardMode.SURROUND)) {\n\n\t\t\t\tselectPrefixSB.append(\" like '%\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselectPrefixSB.append(\" like '\");\n\t\t\t}\n\n\t\t\tString selectPrefix = selectPrefixSB.toString();\n\n\t\t\tString selectPostfix = StringPool.APOSTROPHE;\n\n\t\t\tif (wildcardMode.equals(WildcardMode.SURROUND) ||\n\t\t\t\twildcardMode.equals(WildcardMode.TRAILING)) {\n\n\t\t\t\tselectPostfix = \"%'\";\n\t\t\t}\n\n\t\t\tfor (String[] name : names) {\n\t\t\t\tString selectSQL = selectPrefix.concat(name[0]).concat(\n\t\t\t\t\tselectPostfix);\n\n\t\t\t\tfutures.add(\n\t\t\t\t\t_threadPoolExecutor.submit(\n\t\t\t\t\t\tnew UpgradeKernelPackageCallable(\n\t\t\t\t\t\t\tcolumnName, selectSQL, updateSQL, name)));\n\t\t\t}\n\t\t}\n\t}","commit_id":"d632b6275ae22f1337774b38ce22c45d160f282f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doUpgrade() throws UpgradeException {\n\t\ttry {\n\t\t\tupgradeTable(\n\t\t\t\t\"Counter\", \"name\", getClassNames(), WildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\t\"ClassName_\", \"value\", getClassNames(), WildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\t\"ResourceAction\", \"name\", getClassNames(),\n\t\t\t\tWildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\t\"ResourceBlock\", \"name\", getClassNames(),\n\t\t\t\tWildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\t\"ResourcePermission\", \"name\", getClassNames(),\n\t\t\t\tWildcardMode.SURROUND);\n\n\t\t\tupgradeTable(\n\t\t\t\t\"ResourceAction\", \"name\", getResourceNames(),\n\t\t\t\tWildcardMode.LEADING);\n\t\t\tupgradeTable(\n\t\t\t\t\"ResourceBlock\", \"name\", getResourceNames(),\n\t\t\t\tWildcardMode.LEADING);\n\t\t\tupgradeTable(\n\t\t\t\t\"ResourcePermission\", \"name\", getResourceNames(),\n\t\t\t\tWildcardMode.LEADING);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tthrow new UpgradeException(sqle);\n\t\t}\n\t}","id":45875,"modified_method":"@Override\n\tprotected void doUpgrade() throws UpgradeException {\n\t\tString[][] classNames = getClassNames();\n\t\tString[][] resourceNames = getResourceNames();\n\n\t\tList<Future<Void>> futures = new ArrayList<>(\n\t\t\t(classNames.length * 5) + (resourceNames.length * 3));\n\n\t\ttry {\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"Counter\", \"name\", classNames, WildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ClassName_\", \"value\", classNames,\n\t\t\t\tWildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ResourceAction\", \"name\", classNames,\n\t\t\t\tWildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ResourceBlock\", \"name\", classNames,\n\t\t\t\tWildcardMode.SURROUND);\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ResourcePermission\", \"name\", classNames,\n\t\t\t\tWildcardMode.SURROUND);\n\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ResourceAction\", \"name\", resourceNames,\n\t\t\t\tWildcardMode.LEADING);\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ResourceBlock\", \"name\", resourceNames,\n\t\t\t\tWildcardMode.LEADING);\n\t\t\tupgradeTable(\n\t\t\t\tfutures, \"ResourcePermission\", \"name\", resourceNames,\n\t\t\t\tWildcardMode.LEADING);\n\n\t\t\tfor (Future<Void> future : futures) {\n\t\t\t\tfuture.get();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UpgradeException(e);\n\t\t}\n\t}","commit_id":"d632b6275ae22f1337774b38ce22c45d160f282f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void assertUpgradeSuccessful(String tableName, String columnName)\n\t\tthrows Exception {\n\n\t\tStringBundler oldSelectSB = new StringBundler(9);\n\n\t\toldSelectSB.append(\"select \");\n\t\toldSelectSB.append(columnName);\n\t\toldSelectSB.append(\" from \");\n\t\toldSelectSB.append(tableName);\n\t\toldSelectSB.append(\" where \");\n\t\toldSelectSB.append(columnName);\n\t\toldSelectSB.append(\" like '%\");\n\t\toldSelectSB.append(_OLD_CLASS_NAME);\n\t\toldSelectSB.append(\"%'\");\n\n\t\tString oldValue = null;\n\n\t\ttry (PreparedStatement ps = connection.prepareStatement(\n\t\t\t\toldSelectSB.toString());\n\t\t\tResultSet rs = ps.executeQuery()) {\n\n\t\t\tAssert.assertTrue(\n\t\t\t\t\"Table \" + tableName + \" and column \" + columnName +\n\t\t\t\t\t\" does not contain value \" + _OLD_CLASS_NAME,\n\t\t\t\trs.next());\n\n\t\t\toldValue = rs.getString(columnName);\n\t\t}\n\n\t\tupgradeTable(\n\t\t\ttableName, columnName, getClassNames(), WildcardMode.SURROUND);\n\n\t\tString newValue = StringUtil.replace(\n\t\t\toldValue, _OLD_CLASS_NAME, _NEW_CLASS_NAME);\n\n\t\tStringBundler newSelectSB = new StringBundler(9);\n\n\t\tnewSelectSB.append(\"select \");\n\t\tnewSelectSB.append(columnName);\n\t\tnewSelectSB.append(\" from \");\n\t\tnewSelectSB.append(tableName);\n\t\tnewSelectSB.append(\" where \");\n\t\tnewSelectSB.append(columnName);\n\t\tnewSelectSB.append(\" = '\");\n\t\tnewSelectSB.append(newValue);\n\t\tnewSelectSB.append(\"'\");\n\n\t\ttry (PreparedStatement ps = connection.prepareStatement(\n\t\t\t\tnewSelectSB.toString());\n\t\t\tResultSet rs = ps.executeQuery()) {\n\n\t\t\tAssert.assertTrue(\n\t\t\t\t\"Table \" + tableName + \" and column \" + columnName +\n\t\t\t\t\t\" does not contain value \" + newValue,\n\t\t\t\trs.next());\n\t\t}\n\t}","id":45876,"modified_method":"protected void assertUpgradeSuccessful(String tableName, String columnName)\n\t\tthrows Exception {\n\n\t\tStringBundler oldSelectSB = new StringBundler(9);\n\n\t\toldSelectSB.append(\"select \");\n\t\toldSelectSB.append(columnName);\n\t\toldSelectSB.append(\" from \");\n\t\toldSelectSB.append(tableName);\n\t\toldSelectSB.append(\" where \");\n\t\toldSelectSB.append(columnName);\n\t\toldSelectSB.append(\" like '%\");\n\t\toldSelectSB.append(_OLD_CLASS_NAME);\n\t\toldSelectSB.append(\"%'\");\n\n\t\tString oldValue = null;\n\n\t\ttry (PreparedStatement ps = connection.prepareStatement(\n\t\t\t\toldSelectSB.toString());\n\t\t\tResultSet rs = ps.executeQuery()) {\n\n\t\t\tAssert.assertTrue(\n\t\t\t\t\"Table \" + tableName + \" and column \" + columnName +\n\t\t\t\t\t\" does not contain value \" + _OLD_CLASS_NAME,\n\t\t\t\trs.next());\n\n\t\t\toldValue = rs.getString(columnName);\n\t\t}\n\n\t\tList<Future<Void>> futures = new ArrayList<>(1);\n\n\t\tupgradeTable(\n\t\t\tfutures, tableName, columnName, getClassNames(),\n\t\t\tWildcardMode.SURROUND);\n\n\t\tfor (Future<Void> future : futures) {\n\t\t\tfuture.get();\n\t\t}\n\n\t\tString newValue = StringUtil.replace(\n\t\t\toldValue, _OLD_CLASS_NAME, _NEW_CLASS_NAME);\n\n\t\tStringBundler newSelectSB = new StringBundler(9);\n\n\t\tnewSelectSB.append(\"select \");\n\t\tnewSelectSB.append(columnName);\n\t\tnewSelectSB.append(\" from \");\n\t\tnewSelectSB.append(tableName);\n\t\tnewSelectSB.append(\" where \");\n\t\tnewSelectSB.append(columnName);\n\t\tnewSelectSB.append(\" = '\");\n\t\tnewSelectSB.append(newValue);\n\t\tnewSelectSB.append(\"'\");\n\n\t\ttry (PreparedStatement ps = connection.prepareStatement(\n\t\t\t\tnewSelectSB.toString());\n\t\t\tResultSet rs = ps.executeQuery()) {\n\n\t\t\tAssert.assertTrue(\n\t\t\t\t\"Table \" + tableName + \" and column \" + columnName +\n\t\t\t\t\t\" does not contain value \" + newValue,\n\t\t\t\trs.next());\n\t\t}\n\t}","commit_id":"d632b6275ae22f1337774b38ce22c45d160f282f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSingleResult() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(10, 11);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(1, dynamicQueryClassNames.size());\n\t}","id":45877,"modified_method":"@Test\n\tpublic void testSingleResult() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\t\tdynamicQuery.setLimit(10, 11);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertEquals(1, dynamicQueryClassNames.size());\n\t\tAssert.assertEquals(\n\t\t\t_allClassNames.get(10), dynamicQueryClassNames.get(0));\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUpperBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(QueryUtil.ALL_POS, _BATCH_SIZE);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(_BATCH_SIZE, dynamicQueryClassNames.size());\n\t}","id":45878,"modified_method":"@Test\n\tpublic void testUpperBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\t\tdynamicQuery.setLimit(QueryUtil.ALL_POS, _BATCH_SIZE);\n\n\t\tAssert.assertEquals(\n\t\t\t_allClassNames.subList(0, _BATCH_SIZE),\n\t\t\tClassNameLocalServiceUtil.<ClassName>dynamicQuery(dynamicQuery));\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() {\n\t\t_existingClassNames = ClassNameLocalServiceUtil.getClassNames(\n\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (int i = 0; i < _BATCH_SIZE; i++) {\n\t\t\tClassName className = ClassNameLocalServiceUtil.addClassName(\n\t\t\t\tRandomTestUtil.randomString(\n\t\t\t\t\tUniqueStringRandomizerBumper.INSTANCE));\n\n\t\t\t_newClassNames.add(className);\n\t\t}\n\t}","id":45879,"modified_method":"@Before\n\tpublic void setUp() {\n\t\t_allClassNames = new ArrayList<>(\n\t\t\tClassNameLocalServiceUtil.getClassNames(\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS));\n\n\t\t_oldClassNameCount = _allClassNames.size();\n\n\t\tfor (int i = 0; i < _BATCH_SIZE; i++) {\n\t\t\tClassName className = ClassNameLocalServiceUtil.addClassName(\n\t\t\t\tRandomTestUtil.randomString(\n\t\t\t\t\tUniqueStringRandomizerBumper.INSTANCE));\n\n\t\t\t_newClassNames.add(className);\n\t\t\t_allClassNames.add(className);\n\t\t}\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNegativeBoundaries() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(-1985, -625);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(0, dynamicQueryClassNames.size());\n\t}","id":45880,"modified_method":"@Test\n\tpublic void testNegativeBoundaries() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(-1985, -625);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertTrue(dynamicQueryClassNames.isEmpty());\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNegativeLowerBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(-50, QueryUtil.ALL_POS);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(\n\t\t\t_existingClassNames.size() + _BATCH_SIZE,\n\t\t\tdynamicQueryClassNames.size());\n\t}","id":45881,"modified_method":"@Test\n\tpublic void testNegativeLowerBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\t\tdynamicQuery.setLimit(-50, QueryUtil.ALL_POS);\n\n\t\tAssert.assertEquals(\n\t\t\t_allClassNames,\n\t\t\tClassNameLocalServiceUtil.<ClassName>dynamicQuery(dynamicQuery));\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNoResults() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(10, 10);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(0, dynamicQueryClassNames.size());\n\t}","id":45882,"modified_method":"@Test\n\tpublic void testNoResults() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(10, 10);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertTrue(dynamicQueryClassNames.isEmpty());\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLowerBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(_existingClassNames.size(), QueryUtil.ALL_POS);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\n\t\tAssert.assertEquals(_BATCH_SIZE, dynamicQueryClassNames.size());\n\t}","id":45883,"modified_method":"@Test\n\tpublic void testLowerBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\t\tdynamicQuery.setLimit(_oldClassNameCount, QueryUtil.ALL_POS);\n\n\t\tAssert.assertEquals(\n\t\t\t_newClassNames,\n\t\t\tClassNameLocalServiceUtil.<ClassName>dynamicQuery(dynamicQuery));\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testStartHigherThanEnd() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(1984, 309);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(0, dynamicQueryClassNames.size());\n\t}","id":45884,"modified_method":"@Test\n\tpublic void testStartHigherThanEnd() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(1984, 309);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertTrue(dynamicQueryClassNames.isEmpty());\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLowerUpperBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\n\t\tdynamicQuery.setLimit(\n\t\t\t_existingClassNames.size(),\n\t\t\t_existingClassNames.size() + _BATCH_SIZE);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(_BATCH_SIZE, dynamicQueryClassNames.size());\n\n\t\tfor (ClassName className : dynamicQueryClassNames) {\n\t\t\tif (_existingClassNames.contains(className)) {\n\t\t\t\tAssert.fail(\n\t\t\t\t\t\"Returned class name should not contain \" + className);\n\t\t\t}\n\t\t}\n\t}","id":45885,"modified_method":"@Test\n\tpublic void testLowerUpperBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\t\tdynamicQuery.setLimit(\n\t\t\t_oldClassNameCount, _oldClassNameCount + _BATCH_SIZE);\n\n\t\tAssert.assertEquals(\n\t\t\t_newClassNames,\n\t\t\tClassNameLocalServiceUtil.<ClassName>dynamicQuery(dynamicQuery));\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNoLimit() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(\n\t\t\t_existingClassNames.size() + _BATCH_SIZE,\n\t\t\tdynamicQueryClassNames.size());\n\t}","id":45886,"modified_method":"@Test\n\tpublic void testNoLimit() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"classNameId\"));\n\n\t\tAssert.assertEquals(\n\t\t\t_allClassNames,\n\t\t\tClassNameLocalServiceUtil.<ClassName>dynamicQuery(dynamicQuery));\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNegativeUpperBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(QueryUtil.ALL_POS, -50);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertNotNull(dynamicQueryClassNames);\n\t\tAssert.assertEquals(0, dynamicQueryClassNames.size());\n\t}","id":45887,"modified_method":"@Test\n\tpublic void testNegativeUpperBound() {\n\t\tDynamicQuery dynamicQuery = ClassNameLocalServiceUtil.dynamicQuery();\n\n\t\tdynamicQuery.setLimit(QueryUtil.ALL_POS, -50);\n\n\t\tList<ClassName> dynamicQueryClassNames =\n\t\t\tClassNameLocalServiceUtil.dynamicQuery(dynamicQuery);\n\n\t\tAssert.assertTrue(dynamicQueryClassNames.isEmpty());\n\t}","commit_id":"f62db4b8f2fe45df6a427cb753aa54001f2096ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public PsiPackage findPackage(@NotNull String qualifiedName) {\n    PsiPackage aPackage = myPackageCache.get(qualifiedName);\n    if (aPackage != null) {\n      return aPackage;\n    }\n\n    for (PsiElementFinder finder : filteredFinders()) {\n      aPackage = finder.findPackage(qualifiedName);\n      if (aPackage != null) {\n        return ConcurrencyUtil.cacheOrGet(myPackageCache, qualifiedName, aPackage);\n      }\n    }\n\n    return null;\n  }","id":45888,"modified_method":"@Override\n  public PsiPackage findPackage(@NotNull String qualifiedName) {\n    SoftReference<ConcurrentMap<String, PsiPackage>> ref = myPackageCache;\n    ConcurrentMap<String, PsiPackage> cache = ref == null ? null : ref.get();\n    if (cache == null) {\n      myPackageCache = new SoftReference<ConcurrentMap<String, PsiPackage>>(cache = new ConcurrentHashMap<String, PsiPackage>());\n    }\n    \n    PsiPackage aPackage = cache.get(qualifiedName);\n    if (aPackage != null) {\n      return aPackage;\n    }\n\n    for (PsiElementFinder finder : filteredFinders()) {\n      aPackage = finder.findPackage(qualifiedName);\n      if (aPackage != null) {\n        return ConcurrencyUtil.cacheOrGet(cache, qualifiedName, aPackage);\n      }\n    }\n\n    return null;\n  }","commit_id":"a365f08dd855f5563392d17ea802b7ec84f3b105","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaPsiFacadeImpl(Project project,\n                           PsiManagerImpl psiManager,\n                           JavaFileManager javaFileManager,\n                           MessageBus bus) {\n    myProject = project;\n    myFileManager = javaFileManager;\n    myNameHelper = new PsiNameHelperImpl(this);\n    myConstantEvaluationHelper = new PsiConstantEvaluationHelperImpl();\n\n    final PsiModificationTracker modificationTracker = psiManager.getModificationTracker();\n\n    if (bus != null) {\n      bus.connect().subscribe(PsiModificationTracker.TOPIC, new PsiModificationTracker.Listener() {\n        private long lastTimeSeen = -1L;\n\n        @Override\n        public void modificationCountChanged() {\n          final long now = modificationTracker.getJavaStructureModificationCount();\n          if (lastTimeSeen != now) {\n            lastTimeSeen = now;\n            myPackageCache.clear();\n          }\n        }\n      });\n    }\n\n    DummyHolderFactory.setFactory(new JavaDummyHolderFactory());\n    JavaElementType.ANNOTATION.getIndex(); // Initialize stubs.\n  }","id":45889,"modified_method":"public JavaPsiFacadeImpl(Project project,\n                           PsiManagerImpl psiManager,\n                           JavaFileManager javaFileManager,\n                           MessageBus bus) {\n    myProject = project;\n    myFileManager = javaFileManager;\n    myNameHelper = new PsiNameHelperImpl(this);\n    myConstantEvaluationHelper = new PsiConstantEvaluationHelperImpl();\n\n    final PsiModificationTracker modificationTracker = psiManager.getModificationTracker();\n\n    if (bus != null) {\n      bus.connect().subscribe(PsiModificationTracker.TOPIC, new PsiModificationTracker.Listener() {\n        private long lastTimeSeen = -1L;\n\n        @Override\n        public void modificationCountChanged() {\n          final long now = modificationTracker.getJavaStructureModificationCount();\n          if (lastTimeSeen != now) {\n            lastTimeSeen = now;\n            myPackageCache = null;\n          }\n        }\n      });\n    }\n\n    DummyHolderFactory.setFactory(new JavaDummyHolderFactory());\n    JavaElementType.ANNOTATION.getIndex(); // Initialize stubs.\n  }","commit_id":"a365f08dd855f5563392d17ea802b7ec84f3b105","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Set<String> getClassNamesCache() {\n    if (myPublicClassNamesCache == null) {\n      Set<String> classNames = getFacade().getClassNames(this, allScope());\n      synchronized (myPublicClassNamesCacheLock) {\n        myPublicClassNamesCache = classNames;\n      }\n    }\n\n    return myPublicClassNamesCache;\n  }","id":45890,"modified_method":"private Set<String> getClassNamesCache() {\n    SoftReference<Set<String>> ref = myPublicClassNamesCache;\n    Set<String> cache = ref == null ? null : ref.get();\n    if (cache == null) {\n      cache = getFacade().getClassNames(this, allScope());\n      synchronized (myPublicClassNamesCacheLock) {\n        myPublicClassNamesCache = new SoftReference<Set<String>>(cache);\n      }\n    }\n\n    return cache;\n  }","commit_id":"a365f08dd855f5563392d17ea802b7ec84f3b105","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int indexOfFirstDifferentChar(@NotNull String path, int start) {\n    return indexOfFirstDifferentChar(path, start, part, 0, !SystemInfo.isFileSystemCaseSensitive);\n  }","id":45891,"modified_method":"private static int indexOfFirstDifferentChar(@NotNull CharSequence s1, int start1, @NotNull String s2, int start2) {\n    boolean ignoreCase = !SystemInfo.isFileSystemCaseSensitive;\n    int len1 = s1.length();\n    int len2 = s2.length();\n    while (start1 < len1 && start2 < len2) {\n      char c1 = s1.charAt(start1);\n      char c2 = s2.charAt(start2);\n      if (!StringUtil.charsEqual(c1, c2, ignoreCase)) {\n        return start1;\n      }\n      start1++;\n      start2++;\n    }\n    return start1;\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void checkConsistency() {\n    if (!DEBUG) return;\n    int childSum = 0;\n    for (FilePointerPartNode child : children) {\n      childSum += child.pointersUnder;\n      child.checkConsistency();\n      assert child.parent == this;\n    }\n    if (leaf != null) childSum++;\n    assert (useCount == 0) == (leaf == null) : useCount + \" - \" +leaf;\n    assert pointersUnder == childSum : \"expected: \"+pointersUnder+\"; actual: \"+childSum;\n  }","id":45892,"modified_method":"void checkConsistency() {\n    if (UNIT_TEST && !ApplicationInfoImpl.isInPerformanceTest()) {\n      doCheckConsistency();\n    }\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  // returns pair.second != null always\n  Pair<VirtualFile, String> update() {\n    VirtualFileManager fileManager = VirtualFileManager.getInstance();\n\n    long lastUpdated = myLastUpdated;\n    Pair<VirtualFile, String> fileAndUrl = myFileAndUrl;\n    long fsModCount = fileManager.getModificationCount();\n    if (lastUpdated == fsModCount) return fileAndUrl;\n    VirtualFile file = fileAndUrl.first;\n    String url = fileAndUrl.second;\n\n    if (url == null) {\n      url = file.getUrl();\n      if (!file.isValid()) file = null;\n    }\n    boolean fileIsValid = file != null && file.isValid();\n    if (file != null && !fileIsValid) {\n      file = null;\n    }\n    if (file == null) {\n      file = fileManager.findFileByUrl(url);\n      fileIsValid = file != null && file.isValid();\n    }\n    if (file != null) {\n      if (fileIsValid) {\n        url = file.getUrl(); // refresh url, it can differ\n      }\n      else {\n        file = null; // can't find, try next time\n      }\n    }\n    assert url != null;\n    Pair<VirtualFile, String> result = Pair.create(file, url);\n    myFileAndUrl = result;\n    myLastUpdated = fsModCount;\n    return result;\n  }","id":45893,"modified_method":"@NotNull\n  // returns pair.second != null always\n  Pair<VirtualFile, String> update() {\n    long lastUpdated = myLastUpdated;\n    Pair<VirtualFile, String> fileAndUrl = myFileAndUrl;\n    long fsModCount = ourFileManager.getModificationCount();\n    if (lastUpdated == fsModCount) return fileAndUrl;\n    VirtualFile file = fileAndUrl.first;\n    String url = fileAndUrl.second;\n    boolean changed = false;\n\n    if (url == null) {\n      url = file.getUrl();\n      if (!file.isValid()) file = null;\n      changed = true;\n    }\n    boolean fileIsValid = file != null && file.isValid();\n    if (file != null && !fileIsValid) {\n      file = null;\n      changed = true;\n    }\n    if (file == null) {\n      file = ourFileManager.findFileByUrl(url);\n      fileIsValid = file != null && file.isValid();\n      if (file != null) {\n        changed = true;\n      }\n    }\n    if (file != null) {\n      if (fileIsValid) {\n        url = file.getUrl(); // refresh url, it can differ\n        changed |= !url.equals(fileAndUrl.second);\n      }\n      else {\n        file = null; // can't find, try next time\n        changed = true;\n      }\n    }\n    Pair<VirtualFile, String> result;\n    if (changed) {\n      result = Pair.create(file, url);\n      myFileAndUrl = result;\n    }\n    else {\n      result = fileAndUrl;\n    }\n    myLastUpdated = fsModCount;\n    return result;\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int indexOfFirstDifferentChar(@NotNull String s1, int start1, @NotNull String s2, int start2, boolean ignoreCase) {\n    int len1 = s1.length();\n    int len2 = s2.length();\n    while (start1 < len1 && start2 < len2) {\n      char c1 = s1.charAt(start1);\n      char c2 = s2.charAt(start2);\n      if (ignoreCase ? !StringUtil.charsEqualIgnoreCase(c1, c2) : c1 != c2) {\n        return start1;\n      }\n      start1++;\n      start2++;\n    }\n    return start1;\n  }","id":45894,"modified_method":"private int indexOfFirstDifferentChar(@NotNull CharSequence path, int start) {\n    return indexOfFirstDifferentChar(path, start, part, 0);\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void before(@NotNull final List<? extends VFileEvent> events) {\n    List<FilePointerPartNode> toFireEvents = new ArrayList<FilePointerPartNode>();\n    List<FilePointerPartNode> toUpdateUrl = new ArrayList<FilePointerPartNode>();\n    VirtualFilePointer[] toFirePointers;\n\n    synchronized (this) {\n      incModificationCount();\n      for (VFileEvent event : events) {\n        if (event instanceof VFileDeleteEvent) {\n          final VFileDeleteEvent deleteEvent = (VFileDeleteEvent)event;\n          String path = deleteEvent.getFile().getPath();\n          addPointersUnder(path, toFireEvents);\n        }\n        else if (event instanceof VFileCreateEvent) {\n          final VFileCreateEvent createEvent = (VFileCreateEvent)event;\n          String url = createEvent.getPath();\n          addPointersUnder(url, toFireEvents);\n        }\n        else if (event instanceof VFileCopyEvent) {\n          final VFileCopyEvent copyEvent = (VFileCopyEvent)event;\n          String url = copyEvent.getNewParent().getPath() + \"/\" + copyEvent.getFile().getName();\n          addPointersUnder(url, toFireEvents);\n        }\n        else if (event instanceof VFileMoveEvent) {\n          final VFileMoveEvent moveEvent = (VFileMoveEvent)event;\n          VirtualFile eventFile = moveEvent.getFile();\n          addPointersUnder(moveEvent.getNewParent().getPath() + \"/\" + eventFile.getName(), toFireEvents);\n\n          List<FilePointerPartNode> nodes = new ArrayList<FilePointerPartNode>();\n          addPointersUnder(eventFile.getPath(), nodes);\n          for (FilePointerPartNode pair : nodes) {\n            VirtualFile file = pair.leaf.getFile();\n            if (file != null) {\n              toUpdateUrl.add(pair);\n            }\n          }\n        }\n        else if (event instanceof VFilePropertyChangeEvent) {\n          final VFilePropertyChangeEvent change = (VFilePropertyChangeEvent)event;\n          if (VirtualFile.PROP_NAME.equals(change.getPropertyName())) {\n            VirtualFile eventFile = change.getFile();\n            VirtualFile parent = eventFile.getParent(); // e.g. for LightVirtualFiles\n            addPointersUnder((parent == null ? \"\" : parent.getPath()) + \"/\" + change.getNewValue(), toFireEvents);\n\n            List<FilePointerPartNode> nodes = new ArrayList<FilePointerPartNode>();\n            addPointersUnder(eventFile.getPath(), nodes);\n            for (FilePointerPartNode pair : nodes) {\n              VirtualFile file = pair.leaf.getFile();\n              if (file != null) {\n                toUpdateUrl.add(pair);\n              }\n            }\n          }\n        }\n      }\n\n      myEvents = new ArrayList<EventDescriptor>();\n      toFirePointers = toPointers(toFireEvents);\n      for (final VirtualFilePointerListener listener : myPointers.keySet()) {\n        if (listener == null) continue;\n        List<VirtualFilePointer> filtered = ContainerUtil.filter(toFirePointers, new Condition<VirtualFilePointer>() {\n          @Override\n          public boolean value(VirtualFilePointer pointer) {\n            return ((VirtualFilePointerImpl)pointer).getListener() == listener;\n          }\n        });\n        if (!filtered.isEmpty()) {\n          EventDescriptor event = new EventDescriptor(listener, filtered.toArray(new VirtualFilePointer[filtered.size()]));\n          myEvents.add(event);\n        }\n      }\n    }\n\n    for (EventDescriptor descriptor : myEvents) {\n      descriptor.fireBefore();\n    }\n\n    if (!toFireEvents.isEmpty()) {\n      myBus.syncPublisher(VirtualFilePointerListener.TOPIC).beforeValidityChanged(toFirePointers);\n    }\n\n    myPointersToFire = toFireEvents;\n    myPointersToUpdateUrl = toUpdateUrl;\n  }","id":45895,"modified_method":"@Override\n  public void before(@NotNull final List<? extends VFileEvent> events) {\n    List<FilePointerPartNode> toFireEvents = new ArrayList<FilePointerPartNode>();\n    List<FilePointerPartNode> toUpdateUrl = new ArrayList<FilePointerPartNode>();\n    VirtualFilePointer[] toFirePointers;\n\n    synchronized (this) {\n      incModificationCount();\n      for (VFileEvent event : events) {\n        if (event instanceof VFileDeleteEvent) {\n          final VFileDeleteEvent deleteEvent = (VFileDeleteEvent)event;\n          addPointersUnder(deleteEvent.getFile(), false, \"\", toFireEvents);\n\n        }\n        else if (event instanceof VFileCreateEvent) {\n          final VFileCreateEvent createEvent = (VFileCreateEvent)event;\n          addPointersUnder(createEvent.getParent(), true, createEvent.getChildName(), toFireEvents);\n        }\n        else if (event instanceof VFileCopyEvent) {\n          final VFileCopyEvent copyEvent = (VFileCopyEvent)event;\n          addPointersUnder(copyEvent.getNewParent(), true, copyEvent.getFile().getName(), toFireEvents);\n        }\n        else if (event instanceof VFileMoveEvent) {\n          final VFileMoveEvent moveEvent = (VFileMoveEvent)event;\n          VirtualFile eventFile = moveEvent.getFile();\n          addPointersUnder(moveEvent.getNewParent(), true, eventFile.getName(), toFireEvents);\n\n          List<FilePointerPartNode> nodes = new ArrayList<FilePointerPartNode>();\n          addPointersUnder(eventFile, false, \"\", nodes);\n          for (FilePointerPartNode pair : nodes) {\n            VirtualFile file = pair.leaf.getFile();\n            if (file != null) {\n              toUpdateUrl.add(pair);\n            }\n          }\n        }\n        else if (event instanceof VFilePropertyChangeEvent) {\n          final VFilePropertyChangeEvent change = (VFilePropertyChangeEvent)event;\n          if (VirtualFile.PROP_NAME.equals(change.getPropertyName())) {\n            VirtualFile eventFile = change.getFile();\n            VirtualFile parent = eventFile.getParent(); // e.g. for LightVirtualFiles\n            addPointersUnder(parent, true, change.getNewValue().toString(), toFireEvents);\n\n            List<FilePointerPartNode> nodes = new ArrayList<FilePointerPartNode>();\n            addPointersUnder(eventFile, false, \"\", nodes);\n            for (FilePointerPartNode pair : nodes) {\n              VirtualFile file = pair.leaf.getFile();\n              if (file != null) {\n                toUpdateUrl.add(pair);\n              }\n            }\n          }\n        }\n      }\n\n      myEvents = new ArrayList<EventDescriptor>();\n      toFirePointers = toPointers(toFireEvents);\n      for (final VirtualFilePointerListener listener : myPointers.keySet()) {\n        if (listener == null) continue;\n        List<VirtualFilePointer> filtered = ContainerUtil.filter(toFirePointers, new Condition<VirtualFilePointer>() {\n          @Override\n          public boolean value(VirtualFilePointer pointer) {\n            return ((VirtualFilePointerImpl)pointer).getListener() == listener;\n          }\n        });\n        if (!filtered.isEmpty()) {\n          EventDescriptor event = new EventDescriptor(listener, filtered.toArray(new VirtualFilePointer[filtered.size()]));\n          myEvents.add(event);\n        }\n      }\n    }\n\n    for (EventDescriptor descriptor : myEvents) {\n      descriptor.fireBefore();\n    }\n\n    if (!toFireEvents.isEmpty()) {\n      myBus.syncPublisher(VirtualFilePointerListener.TOPIC).beforeValidityChanged(toFirePointers);\n    }\n\n    myPointersToFire = toFireEvents;\n    myPointersToUpdateUrl = toUpdateUrl;\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public synchronized VirtualFilePointer create(@NotNull VirtualFile file, @NotNull Disposable parent, @Nullable VirtualFilePointerListener listener) {\n    return create(file, file.getUrl(), parent, listener);\n  }","id":45896,"modified_method":"@Override\n  @NotNull\n  public synchronized VirtualFilePointer create(@NotNull VirtualFile file, @NotNull Disposable parent, @Nullable VirtualFilePointerListener listener) {\n    return create(file, null, parent, listener);\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addPointersUnder(@NotNull String path, @NotNull List<FilePointerPartNode> out) {\n    for (FilePointerPartNode root : myPointers.values()) {\n      root.getPointersUnder(path, 0, out);\n    }\n  }","id":45897,"modified_method":"private void addPointersUnder(VirtualFile parent,\n                                boolean separator,\n                                @NotNull CharSequence childName,\n                                @NotNull List<FilePointerPartNode> out) {\n    for (FilePointerPartNode root : myPointers.values()) {\n      root.getPointersUnder(parent, separator, childName, out);\n    }\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addAllPointers(@NotNull Collection<VirtualFilePointerImpl> pointers) {\n    List<FilePointerPartNode> out = new ArrayList<FilePointerPartNode>();\n    for (FilePointerPartNode root : myPointers.values()) {\n      root.getPointersUnder(\"\", 0, out);\n    }\n    for (FilePointerPartNode node : out) {\n      pointers.add(node.leaf);\n    }\n  }","id":45898,"modified_method":"private void addAllPointers(@NotNull Collection<VirtualFilePointerImpl> pointers) {\n    List<FilePointerPartNode> out = new ArrayList<FilePointerPartNode>();\n    for (FilePointerPartNode root : myPointers.values()) {\n      root.getPointersUnder(null, false, \"\", out);\n    }\n    for (FilePointerPartNode node : out) {\n      pointers.add(node.leaf);\n    }\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized void assertAllPointersDisposed() {\n    for (Map.Entry<VirtualFilePointerListener, FilePointerPartNode> entry : myPointers.entrySet()) {\n      FilePointerPartNode root = entry.getValue();\n      ArrayList<FilePointerPartNode> left = new ArrayList<FilePointerPartNode>();\n      root.getPointersUnder(\"\", 0, left);\n      if (!left.isEmpty()) {\n        VirtualFilePointerImpl p = left.get(0).leaf;\n        try {\n          p.throwDisposalError(\"Not disposed pointer: \"+p);\n        }\n        finally {\n          for (FilePointerPartNode pair : left) {\n            VirtualFilePointerImpl pointer = pair.leaf;\n            pointer.dispose();\n          }\n        }\n      }\n    }\n\n    synchronized (myContainers) {\n      if (!myContainers.isEmpty()) {\n        VirtualFilePointerContainerImpl container = myContainers.iterator().next();\n        container.throwDisposalError(\"Not disposed container\");\n      }\n    }\n  }","id":45899,"modified_method":"private synchronized void assertAllPointersDisposed() {\n    for (Map.Entry<VirtualFilePointerListener, FilePointerPartNode> entry : myPointers.entrySet()) {\n      FilePointerPartNode root = entry.getValue();\n      ArrayList<FilePointerPartNode> left = new ArrayList<FilePointerPartNode>();\n      root.getPointersUnder(null, false, \"\", left);\n      if (!left.isEmpty()) {\n        VirtualFilePointerImpl p = left.get(0).leaf;\n        try {\n          p.throwDisposalError(\"Not disposed pointer: \"+p);\n        }\n        finally {\n          for (FilePointerPartNode pair : left) {\n            VirtualFilePointerImpl pointer = pair.leaf;\n            pointer.dispose();\n          }\n        }\n      }\n    }\n\n    synchronized (myContainers) {\n      if (!myContainers.isEmpty()) {\n        VirtualFilePointerContainerImpl container = myContainers.iterator().next();\n        container.throwDisposalError(\"Not disposed container\");\n      }\n    }\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testManyPointersUpdatePerformance() throws IOException {\n    FilePointerPartNode.pushDebug(false, disposable);\n    LoggingListener listener = new LoggingListener();\n    final List<VFileEvent> events = new ArrayList<VFileEvent>();\n    final File ioTempDir = createTempDirectory();\n    final VirtualFile temp = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(ioTempDir);\n    for (int i=0; i<100000; i++) {\n      myVirtualFilePointerManager.create(VfsUtilCore.pathToUrl(\"/a/b/c/d/\" + i), disposable, listener);\n      events.add(new VFileCreateEvent(this, temp, \"xxx\" + i, false, true));\n    }\n    PlatformTestUtil.startPerformanceTest(\"vfp update\", 10000, new ThrowableRunnable() {\n      @Override\n      public void run() throws Throwable {\n        for (int i=0; i<100; i++) {\n          // simulate VFS refresh events since launching the actual refresh is too slow\n          myVirtualFilePointerManager.before(events);\n          myVirtualFilePointerManager.after(events);\n        }\n      }\n    }).assertTiming();\n  }","id":45900,"modified_method":"public void testManyPointersUpdatePerformance() throws IOException {\n    LoggingListener listener = new LoggingListener();\n    final List<VFileEvent> events = new ArrayList<VFileEvent>();\n    final File ioTempDir = createTempDirectory();\n    final VirtualFile temp = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(ioTempDir);\n    for (int i=0; i<100000; i++) {\n      myVirtualFilePointerManager.create(VfsUtilCore.pathToUrl(\"/a/b/c/d/\" + i), disposable, listener);\n      events.add(new VFileCreateEvent(this, temp, \"xxx\" + i, false, true));\n    }\n    PlatformTestUtil.startPerformanceTest(\"vfp update\", 10000, new ThrowableRunnable() {\n      @Override\n      public void run() throws Throwable {\n        for (int i=0; i<100; i++) {\n          // simulate VFS refresh events since launching the actual refresh is too slow\n          myVirtualFilePointerManager.before(events);\n          myVirtualFilePointerManager.after(events);\n        }\n      }\n    }).assertTiming();\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testThreadsPerformance() throws IOException, InterruptedException {\n    final File ioTempDir = createTempDirectory();\n    final File ioPtrBase = new File(ioTempDir, \"parent\");\n    final File ioPtr = new File(ioPtrBase, \"f1\");\n    final File ioSand = new File(ioTempDir, \"sand\");\n    final File ioSandPtr = new File(ioSand, \"f2\");\n    ioSandPtr.getParentFile().mkdirs();\n    ioSandPtr.createNewFile();\n    ioPtr.getParentFile().mkdirs();\n    ioPtr.createNewFile();\n\n    doVfsRefresh();\n    final VirtualFilePointer pointer = createPointerByFile(ioPtr, null);\n    assertTrue(pointer.isValid());\n    final VirtualFile virtualFile = pointer.getFile();\n    assertNotNull(virtualFile);\n    assertTrue(virtualFile.isValid());\n\n    VirtualFileAdapter listener = new VirtualFileAdapter() {\n      @Override\n      public void fileCreated(@NotNull VirtualFileEvent event) {\n        stressRead(pointer);\n      }\n\n      @Override\n      public void fileDeleted(@NotNull VirtualFileEvent event) {\n        stressRead(pointer);\n      }\n    };\n    Disposable disposable = Disposer.newDisposable();\n    VirtualFileManager.getInstance().addVirtualFileListener(listener, disposable);\n    int N = Timings.adjustAccordingToMySpeed(1000, false);\n    System.out.println(\"N = \" + N);\n    for (int i=0;i< N;i++) {\n      assertNotNull(pointer.getFile());\n      FileUtil.delete(ioPtrBase);\n      doVfsRefresh();\n\n      // ptr is now null, cached as map\n\n      final VirtualFile v = LocalFileSystem.getInstance().findFileByIoFile(ioSandPtr);\n      new WriteCommandAction.Simple(getProject()) {\n        @Override\n        protected void run() throws Throwable {\n          v.delete(this); //inc FS modCount\n          LocalFileSystem.getInstance().findFileByIoFile(ioSand).createChildData(this, ioSandPtr.getName());\n        }\n      }.execute().throwException();\n\n      // ptr is still null\n\n      assertTrue(ioPtrBase.mkdirs());\n      assertTrue(ioPtr.createNewFile());\n\n      stressRead(pointer);\n      doVfsRefresh();\n    }\n\n    Disposer.dispose(disposable); // unregister listener early\n  }","id":45901,"modified_method":"public void testThreadsPerformance() throws IOException, InterruptedException {\n    final File ioTempDir = createTempDirectory();\n    final File ioPtrBase = new File(ioTempDir, \"parent\");\n    final File ioPtr = new File(ioPtrBase, \"f1\");\n    final File ioSand = new File(ioTempDir, \"sand\");\n    final File ioSandPtr = new File(ioSand, \"f2\");\n    ioSandPtr.getParentFile().mkdirs();\n    ioSandPtr.createNewFile();\n    ioPtr.getParentFile().mkdirs();\n    ioPtr.createNewFile();\n\n    doVfsRefresh();\n    final VirtualFilePointer pointer = createPointerByFile(ioPtr, null);\n    assertTrue(pointer.isValid());\n    final VirtualFile virtualFile = pointer.getFile();\n    assertNotNull(virtualFile);\n    assertTrue(virtualFile.isValid());\n\n    VirtualFileAdapter listener = new VirtualFileAdapter() {\n      @Override\n      public void fileCreated(@NotNull VirtualFileEvent event) {\n        stressRead(pointer);\n      }\n\n      @Override\n      public void fileDeleted(@NotNull VirtualFileEvent event) {\n        stressRead(pointer);\n      }\n    };\n    Disposable disposable = Disposer.newDisposable();\n    VirtualFileManager.getInstance().addVirtualFileListener(listener, disposable);\n    try {\n      int N = Timings.adjustAccordingToMySpeed(1000, false);\n      System.out.println(\"N = \" + N);\n      for (int i=0;i< N;i++) {\n        assertNotNull(pointer.getFile());\n        FileUtil.delete(ioPtrBase);\n        doVfsRefresh();\n\n        // ptr is now null, cached as map\n\n        final VirtualFile v = LocalFileSystem.getInstance().findFileByIoFile(ioSandPtr);\n        new WriteCommandAction.Simple(getProject()) {\n          @Override\n          protected void run() throws Throwable {\n            v.delete(this); //inc FS modCount\n            LocalFileSystem.getInstance().findFileByIoFile(ioSand).createChildData(this, ioSandPtr.getName());\n          }\n        }.execute().throwException();\n\n        // ptr is still null\n\n        assertTrue(ioPtrBase.mkdirs());\n        assertTrue(ioPtr.createNewFile());\n\n        stressRead(pointer);\n        doVfsRefresh();\n      }\n    }\n    finally {\n      Disposer.dispose(disposable); // unregister listener early\n    }\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMultipleCreationOfTheSamePointerPerformance() throws IOException {\n    FilePointerPartNode.pushDebug(false, disposable);\n    final LoggingListener listener = new LoggingListener();\n    final String url = VfsUtilCore.pathToUrl(\"/a/b/c/d/e\");\n    final VirtualFilePointer thePointer = myVirtualFilePointerManager.create(url, disposable, listener);\n    TempFileSystem.getInstance();\n    PlatformTestUtil.startPerformanceTest(\"same url vfp create\", 500, new ThrowableRunnable() {\n      @Override\n      public void run() throws Throwable {\n        for (int i=0; i<1000000; i++) {\n          VirtualFilePointer pointer = myVirtualFilePointerManager.create(url, disposable, listener);\n          assertSame(pointer, thePointer);\n        }\n      }\n    }).assertTiming();\n  }","id":45902,"modified_method":"public void testMultipleCreationOfTheSamePointerPerformance() throws IOException {\n    final LoggingListener listener = new LoggingListener();\n    final String url = VfsUtilCore.pathToUrl(\"/a/b/c/d/e\");\n    final VirtualFilePointer thePointer = myVirtualFilePointerManager.create(url, disposable, listener);\n    TempFileSystem.getInstance();\n    PlatformTestUtil.startPerformanceTest(\"same url vfp create\", 5000, new ThrowableRunnable() {\n      @Override\n      public void run() throws Throwable {\n        for (int i=0; i<10000000; i++) {\n          VirtualFilePointer pointer = myVirtualFilePointerManager.create(url, disposable, listener);\n          assertSame(pointer, thePointer);\n        }\n      }\n    }).assertTiming();\n  }","commit_id":"b1dd065aa3c33bee9c96ff221d71a80f9d5731f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n            \n                \n                Set<OnmsLocationSpecificStatus> selectedStatuses =\n                    filterStatus(statusesPeriod, monitors, memberServices);\n                \n                String percentage;\n                if (selectedStatuses.size() > 0) {\n                    percentage =\n                        calculatePercentageUptime(memberServices,\n                                                  statusesPeriod,\n                                                  startDate, endDate);\n                    table.addCell(percentage, status,\n                                  createHistoryPageUrl(locationDefinition,\n                                                       application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        return table;\n    }","id":45903,"modified_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n            \n                \n                Set<OnmsLocationSpecificStatus> selectedStatuses =\n                    filterStatus(statusesPeriod, monitors, memberServices);\n                \n                if (selectedStatuses.size() > 0) {\n                    String percentage =\n                        calculatePercentageUptime(memberServices,\n                                                  selectedStatuses,\n                                                  startDate, endDate);\n                    table.addCell(percentage, status,\n                                  createHistoryPageUrl(locationDefinition,\n                                                       application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        return table;\n    }","commit_id":"bd477dbfb9fe6d120c6b0328497baa9d8670cb33","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        resetEverything();\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n\n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n\n        assertEquals(\"Number of errors\", 1, errors.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errors.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errors.getFieldErrorCount());\n        ObjectError e = (ObjectError) errors.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        verifyEverything();\n\n        /*\n        \n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 2 from Columbus location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response Time\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Critical\");\n        expectedTable.addCell(\"Node 1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n        */\n    }","id":45904,"modified_method":"public void runTestCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        resetEverything();\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n\n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n\n        Errors errorsOut = table.getErrors();\n        assertEquals(\"Number of errors\", 1, errorsOut.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errorsOut.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errorsOut.getFieldErrorCount());\n        ObjectError e = (ObjectError) errorsOut.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        verifyEverything();\n    }","commit_id":"bd477dbfb9fe6d120c6b0328497baa9d8670cb33","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPercentageCalculation() {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","id":45905,"modified_method":"public void testPercentageCalculation() throws ParseException {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","commit_id":"bd477dbfb9fe6d120c6b0328497baa9d8670cb33","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateFacilityStatusTable() {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        /*\n        System.out.print(\"Expected: \" + expectedTable.toString());\n        System.out.print(\"Actual: \" + table.toString());\n        */\n\n        assertTableEquals(expectedTable, table);\n    }","id":45906,"modified_method":"public void runTestCreateFacilityStatusTable() throws ParseException {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"bd477dbfb9fe6d120c6b0328497baa9d8670cb33","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        Date timeOut = new Date(System.currentTimeMillis() - 300000);\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null || monitor.getLastCheckInTime() == null\n                    || monitor.getLastCheckInTime().before(timeOut)) {\n                continue;\n            }\n            \n            String status = calculateCurrentStatus(monitor,\n                                                   applicationServices,\n                                                   statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (\"Normal\".equals(status)) {\n                goodMonitors++;\n            } else {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return \"Indeterminate\"; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return \"Normal\"; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return \"Critical\"; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return \"Warning\"; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","id":45907,"modified_method":"public String calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null\n                    || monitor.getStatus() != MonitorStatus.STARTED) {\n                continue;\n            }\n            \n            String status = calculateCurrentStatus(monitor,\n                                                   applicationServices,\n                                                   statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (\"Normal\".equals(status)) {\n                goodMonitors++;\n            } else {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return \"Indeterminate\"; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return \"Normal\"; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return \"Critical\"; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return \"Warning\"; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param monitor remote monitor to report on\n     * @param applicationServices services to report on\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal places\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n        \n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new ArrayList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        String lastStatus = \"Critical\";\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            if (!monitors.contains(status.getLocationMonitor())) {\n                continue;\n            }\n            \n            if (!applicationServices.contains(status.getMonitoredService())) {\n                continue;\n            }\n\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            String currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (\"Normal\".equals(lastStatus)) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (\"Normal\".equals(lastStatus)) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","id":45908,"modified_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param applicationServices services to report on\n     * @param statuses status entries to use for report\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal\n     * places.  Null is returned if there is no data.\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n\n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        String lastStatus = \"Critical\";\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            String currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (\"Normal\".equals(lastStatus)) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (\"Normal\".equals(lastStatus)) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"simpleWebTableRowLabel\");\n        table.addColumn(\"Location\", \"simpleWebTableRowLabel\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"simpleWebTableRowLabel\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"simpleWebTableRowLabel\");\n            table.addCell(locationDefinition.getName(), \"simpleWebTableRowLabel\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                /*\n                 *  XXX this is totally wrong.... we need to add a single cell\n                 *  for each application composed of the status for all\n                 *  monitors\n                 */\n                //for (OnmsLocationMonitor monitor : monitors) {\n                //}\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n\n                String percentage =\n                    calculatePercentageUptime(monitors,\n                                              memberServices,\n                                              statusesPeriod,\n                                              startDate, endDate);\n                \n                table.addCell(percentage, status,\n                              createHistoryPageUrl(locationDefinition, application));\n            }\n        }\n        \n        return table;\n    }","id":45909,"modified_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n            \n                \n                Set<OnmsLocationSpecificStatus> selectedStatuses =\n                    filterStatus(statusesPeriod, monitors, memberServices);\n                \n                String percentage;\n                if (selectedStatuses.size() > 0) {\n                    percentage =\n                        calculatePercentageUptime(memberServices,\n                                                  statusesPeriod,\n                                                  startDate, endDate);\n                    table.addCell(percentage, status,\n                                  createHistoryPageUrl(locationDefinition,\n                                                       application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        return table;\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyEverything() {\n        verify(m_pollerConfig);\n        verify(m_monitoredServiceDao);\n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n    }","id":45910,"modified_method":"public void verifyEverything() {\n        verify(m_monitoredServiceDao);\n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindLocationSpecificStatusNullApplication() {\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"applicationLabel cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(m_locationDefinition1.getName(), null);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","id":45911,"modified_method":"public void testFindLocationSpecificStatusNullApplication() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n        \n        command.setLocation(m_locationDefinition1.getName());\n        \n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"application cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void assertTableEquals(SimpleWebTable expectedTable, SimpleWebTable table) {\n        assertEquals(\"table title\", expectedTable.getTitle(), table.getTitle());\n        \n        assertEquals(\"number of table columns headers\", expectedTable.getColumnHeaders().size(), table.getColumnHeaders().size());\n        ListIterator<Cell> columnHeaderIterator = expectedTable.getColumnHeaders().listIterator();\n        for (Cell tableColumnHeader : table.getColumnHeaders()) {\n            assertEquals(\"column header \" + (columnHeaderIterator.nextIndex() + 1), columnHeaderIterator.next(), tableColumnHeader);\n        }\n        \n        assertEquals(\"number of rows\", expectedTable.getRows().size(), table.getRows().size());\n        \n        ListIterator<List<Cell>> expectedRowIterator = expectedTable.getRows().listIterator();\n        for (List<Cell> row : table.getRows()) {\n            List<Cell> expectedRow = expectedRowIterator.next();\n\n            assertEquals(\"row \" + (expectedRowIterator.previousIndex() + 1) + \" column count\", expectedRow.size(), row.size());\n\n            ListIterator<Cell> expectedColumnIterator = expectedRow.listIterator();\n            for (Cell column : row) {\n                Cell expectedColumn = expectedColumnIterator.next();\n                \n                String rowColumn = \"row \"\n                    + (expectedRowIterator.previousIndex() + 1) + \" column \"\n                    + (expectedColumnIterator.previousIndex() + 1) + \" \"; \n                \n                assertEquals(rowColumn + \"content\",\n                             expectedColumn.getContent(),\n                             column.getContent());\n                assertEquals(rowColumn + \"styleClass\",\n                             expectedColumn.getStyleClass(),\n                             column.getStyleClass());\n                assertEquals(rowColumn + \"link\",\n                             expectedColumn.getLink(),\n                             column.getLink());\n\n            }\n        }\n    }","id":45912,"modified_method":"public void assertTableEquals(SimpleWebTable expectedTable, SimpleWebTable table) {\n        assertEquals(\"table title\", expectedTable.getTitle(), table.getTitle());\n        \n        assertEquals(\"number of table columns headers\", expectedTable.getColumnHeaders().size(), table.getColumnHeaders().size());\n        ListIterator<Cell> columnHeaderIterator = expectedTable.getColumnHeaders().listIterator();\n        for (Cell tableColumnHeader : table.getColumnHeaders()) {\n            assertEquals(\"column header \" + (columnHeaderIterator.nextIndex() + 1), columnHeaderIterator.next(), tableColumnHeader);\n        }\n        \n        assertEquals(\"number of rows\", expectedTable.getRows().size(), table.getRows().size());\n        \n        ListIterator<List<Cell>> expectedRowIterator = expectedTable.getRows().listIterator();\n        for (List<Cell> row : table.getRows()) {\n            List<Cell> expectedRow = expectedRowIterator.next();\n\n            assertEquals(\"row \" + (expectedRowIterator.previousIndex() + 1) + \" column count\", expectedRow.size(), row.size());\n\n            ListIterator<Cell> expectedColumnIterator = expectedRow.listIterator();\n            for (Cell column : row) {\n                Cell expectedColumn = expectedColumnIterator.next();\n                \n                String rowColumn = \"row \"\n                    + (expectedRowIterator.previousIndex() + 1) + \" column \"\n                    + (expectedColumnIterator.previousIndex() + 1) + \" \"; \n                \n                if (!IGNORE_MATCH.equals(expectedColumn.getContent())) {\n                    assertEquals(rowColumn + \"content\",\n                                 expectedColumn.getContent(),\n                                 column.getContent());\n                }\n                if (!IGNORE_MATCH.equals(expectedColumn.getStyleClass())) {\n                    assertEquals(rowColumn + \"styleClass\",\n                                 expectedColumn.getStyleClass(),\n                                   column.getStyleClass());\n                }\n                if (!IGNORE_MATCH.equals(expectedColumn.getLink())) {\n                    assertEquals(rowColumn + \"link\",\n                                 expectedColumn.getLink(),\n                                 column.getLink());\n                }\n            }\n        }\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestFindLocationSpecificStatusInvalidApplication() {\n        m_service.findLocationSpecificStatus(m_locationDefinition1.getName(), \"invalid application\");\n    }","id":45913,"modified_method":"public void testFindLocationSpecificStatusInvalidApplication() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition1.getName());\n        command.setApplication(\"invalid application\");\n        \n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition1.getName())).andReturn(m_locationDefinition1);\n        expect(m_applicationDao.findByName(command.getApplication())).andReturn(null);\n\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"Could not find application for application name \\\"\" + command.getApplication() + \"\\\"\"));\n        \n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n        \n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        \n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n        \n        ta.verifyAnticipated();\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindLocationSpecificStatusNullLocation() {\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"locationName cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(null, m_application1.getName());\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","id":45914,"modified_method":"public void testFindLocationSpecificStatusNullLocation() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n        \n        command.setApplication(m_application1.getName());\n        \n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"location cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateStatus() {\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(m_locationDefinition1.getName(),\n                                        m_application1.getName());\n        \n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 1 from Raleigh location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Normal\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTP\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Up\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        expectedTable.newRow();\n        \n        expectedTable.addCell(\"Node 1\", \"Critical\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"No status recorded for this service from this location\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n    }","id":45915,"modified_method":"public void runTestCreateStatus() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition1.getName());\n        command.setApplication(m_application1.getName());\n\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n        \n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 1 from Raleigh location\");\n        \n        expectedTable.addColumn(\"Node\", \"\");\n        expectedTable.addColumn(\"Monitor\", \"\");\n        expectedTable.addColumn(\"Service\", \"\");\n        expectedTable.addColumn(\"Status\", \"\");\n        expectedTable.addColumn(\"Response\", \"\");\n        expectedTable.addColumn(\"Last Update\", \"\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Normal\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTP\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Up\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        expectedTable.addCell(IGNORE_MATCH, \"\");\n        expectedTable.newRow();\n        \n        expectedTable.addCell(\"Node 1\", \"Critical\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"No status recorded for this service from this location\", \"\");\n        expectedTable.addCell(IGNORE_MATCH, \"\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateStatusNoLocationMonitor() {\n        //expectEverything();\n        resetEverything();\n        \n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n        //expect(m_pollerConfig.getPackage(\"columbus\")).andReturn(m_pkg);\n        //expect(m_pollerConfig.getServiceSelectorForPackage(m_pkg)).andReturn(m_selector);\n        //expect(m_monitoredServiceDao.findMatchingServices(m_selector)).andReturn(m_services);\n        \n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"No location monitors have registered for location \\\"Columbus\\\"\"));\n        \n        replayEverything();\n        try {\n            SimpleWebTable table =\n                m_service.createStatusTable(m_locationDefinition3.getName(),\n                                            m_application2.getName());\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n\n        verifyEverything();\n\n        /*\n        \n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 2 from Columbus location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response Time\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Critical\");\n        expectedTable.addCell(\"Node 1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n        */\n    }","id":45916,"modified_method":"public void runTestCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        resetEverything();\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n\n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n\n        assertEquals(\"Number of errors\", 1, errors.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errors.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errors.getFieldErrorCount());\n        ObjectError e = (ObjectError) errors.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        verifyEverything();\n\n        /*\n        \n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 2 from Columbus location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response Time\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Critical\");\n        expectedTable.addCell(\"Node 1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n        */\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void replayEverything() {\n        replay(m_pollerConfig);\n        replay(m_monitoredServiceDao);\n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n    }","id":45917,"modified_method":"public void replayEverything() {\n        replay(m_monitoredServiceDao);\n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestFindLocationSpecificStatusInvalidLocation() {\n        m_service.findLocationSpecificStatus(\"invalid location\", m_application1.getName());\n    }","id":45918,"modified_method":"public void testFindLocationSpecificStatusInvalidLocation() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n        \n        command.setLocation(\"invalid location\");\n        command.setApplication(m_application1.getName());\n        \n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(command.getLocation())).andReturn(null);\n\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"Could not find location for location name \\\"\" + command.getLocation() + \"\\\"\"));\n        \n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n        \n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        \n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n\n        ta.verifyAnticipated();\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() {\n        m_service.setPollerConfig(m_pollerConfig);\n        m_service.setMonitoredServiceDao(m_monitoredServiceDao);\n        m_service.setLocationMonitorDao(m_locationMonitorDao);\n        m_service.setApplicationDao(m_applicationDao);\n        \n        m_locationDefinition1 = new OnmsMonitoringLocationDefinition(\"Raleigh\", \"raleigh\", \"OpenNMS NC\");\n        m_locationDefinition2 = new OnmsMonitoringLocationDefinition(\"Durham\", \"durham\", \"OpenNMS NC\");\n        m_locationDefinition3 = new OnmsMonitoringLocationDefinition(\"Columbus\", \"columbus\", \"OpenNMS OH\");\n\n        m_application1 = new OnmsApplication();\n        m_application1.setName(\"Application 1\");\n        \n        m_application2 = new OnmsApplication();\n        m_application2.setName(\"Application 2\");\n\n        m_locationMonitor1_1 = new OnmsLocationMonitor();\n        m_locationMonitor1_1.setId(1);\n        m_locationMonitor1_1.setLastCheckInTime(new Date());\n        m_locationMonitor1_1.setDefinitionName(\"Raleigh\");\n        \n        m_locationMonitor2_1 = new OnmsLocationMonitor();\n        m_locationMonitor2_1.setId(2);\n        m_locationMonitor2_1.setLastCheckInTime(new Date());\n        m_locationMonitor2_1.setDefinitionName(\"Durham\");\n        \n        m_locationMonitor2_2 = new OnmsLocationMonitor();\n        m_locationMonitor2_2.setId(3);\n        m_locationMonitor2_2.setDefinitionName(\"Durham\");\n        \n        m_pkg = new Package();\n\n        List<String> serviceNames = new ArrayList<String>();\n        serviceNames.add(\"ICMP\");\n        serviceNames.add(\"DNS\");\n        serviceNames.add(\"HTTP\");\n        serviceNames.add(\"HTTPS\");\n        Collections.shuffle(serviceNames); // shuffle to test sorting\n\n        m_selector = new ServiceSelector(\"IPADDR IPLIKE *.*.*.*\", serviceNames);\n        \n        m_node = new OnmsNode();\n        m_ip = \"1.1.1.1\";\n        m_node.setLabel(\"Node 1\");\n        m_node.setId(1);\n        \n        // Can't shuffle since it's a set\n        m_services = new HashSet<OnmsMonitoredService>();\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"ICMP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"DNS\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTPS\")));\n\n        // Can't shuffle since these since they are sets\n        m_applicationServices1 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTP\"));\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application1.setMemberServices(applicationServices1);\n        \n        m_applicationServices2 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices2.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application2.setMemberServices(applicationServices2);\n\n\n        /*\n        m_application2 = new OnmsApplication();\n        m_application2.setLabel(\"Application 2\");\n        // XXX shuffle to verify sorting? create new list and do: Collections.shuffle(applicationServices2)\n        m_application2.setMemberServices(applicationServices1);\n        */\n\n        \n    }","id":45919,"modified_method":"protected void setUp() {\n        m_service.setMonitoredServiceDao(m_monitoredServiceDao);\n        m_service.setLocationMonitorDao(m_locationMonitorDao);\n        m_service.setApplicationDao(m_applicationDao);\n        \n        m_locationDefinition1 = new OnmsMonitoringLocationDefinition(\"Raleigh\", \"raleigh\", \"OpenNMS NC\");\n        m_locationDefinition2 = new OnmsMonitoringLocationDefinition(\"Durham\", \"durham\", \"OpenNMS NC\");\n        m_locationDefinition3 = new OnmsMonitoringLocationDefinition(\"Columbus\", \"columbus\", \"OpenNMS OH\");\n\n        m_application1 = new OnmsApplication();\n        m_application1.setName(\"Application 1\");\n        \n        m_application2 = new OnmsApplication();\n        m_application2.setName(\"Application 2\");\n\n        m_locationMonitor1_1 = new OnmsLocationMonitor();\n        m_locationMonitor1_1.setId(1);\n        m_locationMonitor1_1.setLastCheckInTime(new Date());\n        m_locationMonitor1_1.setDefinitionName(\"Raleigh\");\n        m_locationMonitor1_1.setStatus(MonitorStatus.STARTED);\n        assertEquals(\"location monitor 1.1 status\", MonitorStatus.STARTED,\n                     m_locationMonitor1_1.getStatus());\n        \n        m_locationMonitor2_1 = new OnmsLocationMonitor();\n        m_locationMonitor2_1.setId(2);\n        m_locationMonitor2_1.setLastCheckInTime(new Date());\n        m_locationMonitor2_1.setDefinitionName(\"Durham\");\n        m_locationMonitor2_1.setStatus(MonitorStatus.STARTED);\n        assertEquals(\"location monitor 2.1 status\", MonitorStatus.STARTED,\n                     m_locationMonitor2_1.getStatus());\n        \n        m_locationMonitor2_2 = new OnmsLocationMonitor();\n        m_locationMonitor2_2.setId(3);\n        m_locationMonitor2_2.setDefinitionName(\"Durham\");\n        m_locationMonitor2_2.setStatus(MonitorStatus.STARTED);\n        assertEquals(\"location monitor 2.2 status\", MonitorStatus.STARTED,\n                     m_locationMonitor2_2.getStatus());\n        \n        List<String> serviceNames = new ArrayList<String>();\n        serviceNames.add(\"ICMP\");\n        serviceNames.add(\"DNS\");\n        serviceNames.add(\"HTTP\");\n        serviceNames.add(\"HTTPS\");\n        Collections.shuffle(serviceNames); // shuffle to test sorting\n        \n        m_node = new OnmsNode();\n        m_ip = \"1.1.1.1\";\n        m_node.setLabel(\"Node 1\");\n        m_node.setId(1);\n        \n        // Can't shuffle since it's a set\n        m_services = new HashSet<OnmsMonitoredService>();\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"ICMP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"DNS\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTPS\")));\n\n        // Can't shuffle since these since they are sets\n        m_applicationServices1 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTP\"));\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application1.setMemberServices(applicationServices1);\n        \n        m_applicationServices2 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices2.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application2.setMemberServices(applicationServices2);\n\n\n        /*\n        m_application2 = new OnmsApplication();\n        m_application2.setLabel(\"Application 2\");\n        // XXX shuffle to verify sorting? create new list and do: Collections.shuffle(applicationServices2)\n        m_application2.setMemberServices(applicationServices1);\n        */\n\n        \n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPercentageCalculation() {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n//        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statuses);\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(Collections.singleton(m_locationMonitor1_1),\n                                                m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","id":45920,"modified_method":"public void testPercentageCalculation() {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void expectEverything() {\n        resetEverything();\n        \n        expect(m_applicationDao.findByName(\"Application 1\")).andReturn(m_application1);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition1.getName())).andReturn(m_locationDefinition1);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition1)).andReturn(Collections.singleton(m_locationMonitor1_1));\n        expect(m_pollerConfig.getPackage(\"raleigh\")).andReturn(m_pkg);\n        expect(m_pollerConfig.getServiceSelectorForPackage(m_pkg)).andReturn(m_selector);\n        expect(m_monitoredServiceDao.findMatchingServices(m_selector)).andReturn(m_services);\n\n\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpService)).andReturn(new OnmsLocationSpecificStatus(m_locationMonitor1_1, httpService, PollStatus.available()));\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpsService)).andReturn(null);\n    }","id":45921,"modified_method":"public void expectEverything() {\n        resetEverything();\n        \n        expect(m_applicationDao.findByName(\"Application 1\")).andReturn(m_application1);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition1.getName())).andReturn(m_locationDefinition1);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition1)).andReturn(Collections.singleton(m_locationMonitor1_1));\n\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpService)).andReturn(new OnmsLocationSpecificStatus(m_locationMonitor1_1, httpService, PollStatus.available()));\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpsService)).andReturn(null);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindLocationSpecificStatus() {\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        \n        List<OnmsLocationSpecificStatus> status =\n            m_service.findLocationSpecificStatus(m_locationDefinition1.getName(),\n                                                 m_application1.getName());\n\n        verifyEverything();\n        \n        assertEquals(\"status list size\", 2, status.size());\n    }","id":45922,"modified_method":"public void testFindLocationSpecificStatus() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition1.getName());\n        command.setApplication(m_application1.getName());\n\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        \n        List<OnmsLocationSpecificStatus> status =\n            m_service.findLocationSpecificStatus(command, errors);\n\n        verifyEverything();\n        \n        assertEquals(\"status list size\", 2, status.size());\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateFacilityStatusTable() {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"simpleWebTableRowLabel\");\n        expectedTable.addColumn(\"Location\", \"simpleWebTableRowLabel\");\n        expectedTable.addColumn(\"Application 1\", \"simpleWebTableRowLabel\");\n        expectedTable.addColumn(\"Application 2\", \"simpleWebTableRowLabel\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"Raleigh\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"Durham\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"0.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Durham&application=Application+1\");\n        expectedTable.addCell(\"0.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Durham&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"Columbus\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"0.000%\", \"Indeterminate\", \"distributedStatusHistory.htm?location=Columbus&application=Application+1\");\n        expectedTable.addCell(\"0.000%\", \"Indeterminate\", \"distributedStatusHistory.htm?location=Columbus&application=Application+2\");\n\n        assertTableEquals(expectedTable, table);\n    }","id":45923,"modified_method":"public void runTestCreateFacilityStatusTable() {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        /*\n        System.out.print(\"Expected: \" + expectedTable.toString());\n        System.out.print(\"Actual: \" + table.toString());\n        */\n\n        assertTableEquals(expectedTable, table);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void resetEverything() {\n        reset(m_applicationDao);\n        reset(m_locationMonitorDao);\n        reset(m_pollerConfig);\n        reset(m_monitoredServiceDao);\n    }","id":45924,"modified_method":"public void resetEverything() {\n        reset(m_applicationDao);\n        reset(m_locationMonitorDao);\n        reset(m_monitoredServiceDao);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String applicationName = request.getParameter(\"application\");\n        String locationName = request.getParameter(\"location\");\n        SimpleWebTable table = m_distributedStatusService.createStatusTable(locationName, applicationName);\n        return new ModelAndView(\"distributedStatusDetails\", \"webTable\", table);\n    }","id":45925,"modified_method":"@Override\n    protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException errors) throws Exception {\n        DistributedStatusDetailsCommand cmd = (DistributedStatusDetailsCommand) command;\n        SimpleWebTable table = m_distributedStatusService.createStatusTable(cmd, errors);\n        return new ModelAndView(getSuccessView(), \"webTable\", table);\n    }","commit_id":"7ddf45bdb18260e122da6fe90dd2a1a270a2ee0d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n            \n                \n                Set<OnmsLocationSpecificStatus> selectedStatuses =\n                    filterStatus(statusesPeriod, monitors, memberServices);\n                \n                String percentage;\n                if (selectedStatuses.size() > 0) {\n                    percentage =\n                        calculatePercentageUptime(memberServices,\n                                                  statusesPeriod,\n                                                  startDate, endDate);\n                    table.addCell(percentage, status,\n                                  createHistoryPageUrl(locationDefinition,\n                                                       application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        return table;\n    }","id":45926,"modified_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n            \n                \n                Set<OnmsLocationSpecificStatus> selectedStatuses =\n                    filterStatus(statusesPeriod, monitors, memberServices);\n                \n                if (selectedStatuses.size() > 0) {\n                    String percentage =\n                        calculatePercentageUptime(memberServices,\n                                                  selectedStatuses,\n                                                  startDate, endDate);\n                    table.addCell(percentage, status,\n                                  createHistoryPageUrl(locationDefinition,\n                                                       application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        return table;\n    }","commit_id":"fb1212b5a412ed04a727729e8e2e1b20a0875ace","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPercentageCalculation() {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","id":45927,"modified_method":"public void testPercentageCalculation() throws ParseException {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","commit_id":"fb1212b5a412ed04a727729e8e2e1b20a0875ace","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateFacilityStatusTable() {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        /*\n        System.out.print(\"Expected: \" + expectedTable.toString());\n        System.out.print(\"Actual: \" + table.toString());\n        */\n\n        assertTableEquals(expectedTable, table);\n    }","id":45928,"modified_method":"public void runTestCreateFacilityStatusTable() throws ParseException {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"fb1212b5a412ed04a727729e8e2e1b20a0875ace","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        resetEverything();\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n\n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n\n        assertEquals(\"Number of errors\", 1, errors.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errors.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errors.getFieldErrorCount());\n        ObjectError e = (ObjectError) errors.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        verifyEverything();\n\n        /*\n        \n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 2 from Columbus location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response Time\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Critical\");\n        expectedTable.addCell(\"Node 1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n        */\n    }","id":45929,"modified_method":"public void runTestCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        resetEverything();\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n\n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n\n        Errors errorsOut = table.getErrors();\n        assertEquals(\"Number of errors\", 1, errorsOut.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errorsOut.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errorsOut.getFieldErrorCount());\n        ObjectError e = (ObjectError) errorsOut.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        verifyEverything();\n    }","commit_id":"fb1212b5a412ed04a727729e8e2e1b20a0875ace","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        Date timeOut = new Date(System.currentTimeMillis() - 300000);\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null || monitor.getLastCheckInTime() == null\n                    || monitor.getLastCheckInTime().before(timeOut)) {\n                continue;\n            }\n            \n            String status = calculateCurrentStatus(monitor,\n                                                   applicationServices,\n                                                   statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (\"Normal\".equals(status)) {\n                goodMonitors++;\n            } else {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return \"Indeterminate\"; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return \"Normal\"; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return \"Critical\"; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return \"Warning\"; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","id":45930,"modified_method":"public String calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null\n                    || monitor.getStatus() != MonitorStatus.STARTED) {\n                continue;\n            }\n            \n            String status = calculateCurrentStatus(monitor,\n                                                   applicationServices,\n                                                   statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (\"Normal\".equals(status)) {\n                goodMonitors++;\n            } else {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return \"Indeterminate\"; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return \"Normal\"; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return \"Critical\"; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return \"Warning\"; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"simpleWebTableRowLabel\");\n        table.addColumn(\"Location\", \"simpleWebTableRowLabel\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"simpleWebTableRowLabel\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"simpleWebTableRowLabel\");\n            table.addCell(locationDefinition.getName(), \"simpleWebTableRowLabel\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                /*\n                 *  XXX this is totally wrong.... we need to add a single cell\n                 *  for each application composed of the status for all\n                 *  monitors\n                 */\n                //for (OnmsLocationMonitor monitor : monitors) {\n                //}\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n\n                String percentage =\n                    calculatePercentageUptime(monitors,\n                                              memberServices,\n                                              statusesPeriod,\n                                              startDate, endDate);\n                \n                table.addCell(percentage, status,\n                              createHistoryPageUrl(locationDefinition, application));\n            }\n        }\n        \n        return table;\n    }","id":45931,"modified_method":"public SimpleWebTable createFacilityStatusTable(Date startDate,\n            Date endDate) {\n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications =\n            new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications,\n                         new Comparator<OnmsApplication>(){\n            public int compare(OnmsApplication o1, OnmsApplication o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            m_locationMonitorDao.getAllMostRecentStatusChanges();\n        \n        Collection<OnmsLocationSpecificStatus> statusesWithinPeriod =\n            m_locationMonitorDao.getStatusChangesBetween(startDate, endDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesBeforePeriod =\n            m_locationMonitorDao.getAllStatusChangesAt(startDate);\n        \n        Collection<OnmsLocationSpecificStatus> statusesPeriod =\n            new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(statusesBeforePeriod);\n        statusesPeriod.addAll(statusesWithinPeriod);\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices =\n                    m_monitoredServiceDao.findByApplication(application);\n                String status =\n                    calculateCurrentStatus(monitors,\n                                           memberServices,\n                                           mostRecentStatuses);\n            \n                \n                Set<OnmsLocationSpecificStatus> selectedStatuses =\n                    filterStatus(statusesPeriod, monitors, memberServices);\n                \n                String percentage;\n                if (selectedStatuses.size() > 0) {\n                    percentage =\n                        calculatePercentageUptime(memberServices,\n                                                  statusesPeriod,\n                                                  startDate, endDate);\n                    table.addCell(percentage, status,\n                                  createHistoryPageUrl(locationDefinition,\n                                                       application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        return table;\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param monitor remote monitor to report on\n     * @param applicationServices services to report on\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal places\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n        \n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new ArrayList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        String lastStatus = \"Critical\";\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            if (!monitors.contains(status.getLocationMonitor())) {\n                continue;\n            }\n            \n            if (!applicationServices.contains(status.getMonitoredService())) {\n                continue;\n            }\n\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            String currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (\"Normal\".equals(lastStatus)) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (\"Normal\".equals(lastStatus)) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","id":45932,"modified_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param applicationServices services to report on\n     * @param statuses status entries to use for report\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal\n     * places.  Null is returned if there is no data.\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n\n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        String lastStatus = \"Critical\";\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            String currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (\"Normal\".equals(lastStatus)) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (\"Normal\".equals(lastStatus)) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyEverything() {\n        verify(m_pollerConfig);\n        verify(m_monitoredServiceDao);\n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n    }","id":45933,"modified_method":"public void verifyEverything() {\n        verify(m_monitoredServiceDao);\n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestFindLocationSpecificStatusInvalidApplication() {\n        m_service.findLocationSpecificStatus(m_locationDefinition1.getName(), \"invalid application\");\n    }","id":45934,"modified_method":"public void testFindLocationSpecificStatusInvalidApplication() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition1.getName());\n        command.setApplication(\"invalid application\");\n        \n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition1.getName())).andReturn(m_locationDefinition1);\n        expect(m_applicationDao.findByName(command.getApplication())).andReturn(null);\n\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"Could not find application for application name \\\"\" + command.getApplication() + \"\\\"\"));\n        \n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n        \n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        \n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n        \n        ta.verifyAnticipated();\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindLocationSpecificStatusNullApplication() {\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"applicationLabel cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(m_locationDefinition1.getName(), null);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","id":45935,"modified_method":"public void testFindLocationSpecificStatusNullApplication() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n        \n        command.setLocation(m_locationDefinition1.getName());\n        \n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"application cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void assertTableEquals(SimpleWebTable expectedTable, SimpleWebTable table) {\n        assertEquals(\"table title\", expectedTable.getTitle(), table.getTitle());\n        \n        assertEquals(\"number of table columns headers\", expectedTable.getColumnHeaders().size(), table.getColumnHeaders().size());\n        ListIterator<Cell> columnHeaderIterator = expectedTable.getColumnHeaders().listIterator();\n        for (Cell tableColumnHeader : table.getColumnHeaders()) {\n            assertEquals(\"column header \" + (columnHeaderIterator.nextIndex() + 1), columnHeaderIterator.next(), tableColumnHeader);\n        }\n        \n        assertEquals(\"number of rows\", expectedTable.getRows().size(), table.getRows().size());\n        \n        ListIterator<List<Cell>> expectedRowIterator = expectedTable.getRows().listIterator();\n        for (List<Cell> row : table.getRows()) {\n            List<Cell> expectedRow = expectedRowIterator.next();\n\n            assertEquals(\"row \" + (expectedRowIterator.previousIndex() + 1) + \" column count\", expectedRow.size(), row.size());\n\n            ListIterator<Cell> expectedColumnIterator = expectedRow.listIterator();\n            for (Cell column : row) {\n                Cell expectedColumn = expectedColumnIterator.next();\n                \n                String rowColumn = \"row \"\n                    + (expectedRowIterator.previousIndex() + 1) + \" column \"\n                    + (expectedColumnIterator.previousIndex() + 1) + \" \"; \n                \n                assertEquals(rowColumn + \"content\",\n                             expectedColumn.getContent(),\n                             column.getContent());\n                assertEquals(rowColumn + \"styleClass\",\n                             expectedColumn.getStyleClass(),\n                             column.getStyleClass());\n                assertEquals(rowColumn + \"link\",\n                             expectedColumn.getLink(),\n                             column.getLink());\n\n            }\n        }\n    }","id":45936,"modified_method":"public void assertTableEquals(SimpleWebTable expectedTable, SimpleWebTable table) {\n        assertEquals(\"table title\", expectedTable.getTitle(), table.getTitle());\n        \n        assertEquals(\"number of table columns headers\", expectedTable.getColumnHeaders().size(), table.getColumnHeaders().size());\n        ListIterator<Cell> columnHeaderIterator = expectedTable.getColumnHeaders().listIterator();\n        for (Cell tableColumnHeader : table.getColumnHeaders()) {\n            assertEquals(\"column header \" + (columnHeaderIterator.nextIndex() + 1), columnHeaderIterator.next(), tableColumnHeader);\n        }\n        \n        assertEquals(\"number of rows\", expectedTable.getRows().size(), table.getRows().size());\n        \n        ListIterator<List<Cell>> expectedRowIterator = expectedTable.getRows().listIterator();\n        for (List<Cell> row : table.getRows()) {\n            List<Cell> expectedRow = expectedRowIterator.next();\n\n            assertEquals(\"row \" + (expectedRowIterator.previousIndex() + 1) + \" column count\", expectedRow.size(), row.size());\n\n            ListIterator<Cell> expectedColumnIterator = expectedRow.listIterator();\n            for (Cell column : row) {\n                Cell expectedColumn = expectedColumnIterator.next();\n                \n                String rowColumn = \"row \"\n                    + (expectedRowIterator.previousIndex() + 1) + \" column \"\n                    + (expectedColumnIterator.previousIndex() + 1) + \" \"; \n                \n                if (!IGNORE_MATCH.equals(expectedColumn.getContent())) {\n                    assertEquals(rowColumn + \"content\",\n                                 expectedColumn.getContent(),\n                                 column.getContent());\n                }\n                if (!IGNORE_MATCH.equals(expectedColumn.getStyleClass())) {\n                    assertEquals(rowColumn + \"styleClass\",\n                                 expectedColumn.getStyleClass(),\n                                   column.getStyleClass());\n                }\n                if (!IGNORE_MATCH.equals(expectedColumn.getLink())) {\n                    assertEquals(rowColumn + \"link\",\n                                 expectedColumn.getLink(),\n                                 column.getLink());\n                }\n            }\n        }\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void replayEverything() {\n        replay(m_pollerConfig);\n        replay(m_monitoredServiceDao);\n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n    }","id":45937,"modified_method":"public void replayEverything() {\n        replay(m_monitoredServiceDao);\n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateStatus() {\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(m_locationDefinition1.getName(),\n                                        m_application1.getName());\n        \n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 1 from Raleigh location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Normal\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTP\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Up\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        expectedTable.newRow();\n        \n        expectedTable.addCell(\"Node 1\", \"Critical\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"No status recorded for this service from this location\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n    }","id":45938,"modified_method":"public void runTestCreateStatus() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition1.getName());\n        command.setApplication(m_application1.getName());\n\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n        \n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 1 from Raleigh location\");\n        \n        expectedTable.addColumn(\"Node\", \"\");\n        expectedTable.addColumn(\"Monitor\", \"\");\n        expectedTable.addColumn(\"Service\", \"\");\n        expectedTable.addColumn(\"Status\", \"\");\n        expectedTable.addColumn(\"Response\", \"\");\n        expectedTable.addColumn(\"Last Update\", \"\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Normal\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTP\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Up\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        expectedTable.addCell(IGNORE_MATCH, \"\");\n        expectedTable.newRow();\n        \n        expectedTable.addCell(\"Node 1\", \"Critical\", \"element/node.jsp?node=1\");\n        expectedTable.addCell(\"Raleigh-1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\", \"element/service.jsp?ifserviceid=null\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"No status recorded for this service from this location\", \"\");\n        expectedTable.addCell(IGNORE_MATCH, \"\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindLocationSpecificStatusNullLocation() {\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"locationName cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(null, m_application1.getName());\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","id":45939,"modified_method":"public void testFindLocationSpecificStatusNullLocation() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n        \n        command.setApplication(m_application1.getName());\n        \n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"location cannot be null\"));\n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPercentageCalculation() {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n//        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statuses);\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(Collections.singleton(m_locationMonitor1_1),\n                                                m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","id":45940,"modified_method":"public void testPercentageCalculation() {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        replayEverything();\n        String percentage =\n            m_service.calculatePercentageUptime(m_applicationServices1,\n                                                statuses,\n                                                startDate,\n                                                endDate);\n        verifyEverything();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindLocationSpecificStatus() {\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        \n        List<OnmsLocationSpecificStatus> status =\n            m_service.findLocationSpecificStatus(m_locationDefinition1.getName(),\n                                                 m_application1.getName());\n\n        verifyEverything();\n        \n        assertEquals(\"status list size\", 2, status.size());\n    }","id":45941,"modified_method":"public void testFindLocationSpecificStatus() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition1.getName());\n        command.setApplication(m_application1.getName());\n\n        expectEverything();\n        \n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1);\n        \n        replayEverything();\n        \n        List<OnmsLocationSpecificStatus> status =\n            m_service.findLocationSpecificStatus(command, errors);\n\n        verifyEverything();\n        \n        assertEquals(\"status list size\", 2, status.size());\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() {\n        m_service.setPollerConfig(m_pollerConfig);\n        m_service.setMonitoredServiceDao(m_monitoredServiceDao);\n        m_service.setLocationMonitorDao(m_locationMonitorDao);\n        m_service.setApplicationDao(m_applicationDao);\n        \n        m_locationDefinition1 = new OnmsMonitoringLocationDefinition(\"Raleigh\", \"raleigh\", \"OpenNMS NC\");\n        m_locationDefinition2 = new OnmsMonitoringLocationDefinition(\"Durham\", \"durham\", \"OpenNMS NC\");\n        m_locationDefinition3 = new OnmsMonitoringLocationDefinition(\"Columbus\", \"columbus\", \"OpenNMS OH\");\n\n        m_application1 = new OnmsApplication();\n        m_application1.setName(\"Application 1\");\n        \n        m_application2 = new OnmsApplication();\n        m_application2.setName(\"Application 2\");\n\n        m_locationMonitor1_1 = new OnmsLocationMonitor();\n        m_locationMonitor1_1.setId(1);\n        m_locationMonitor1_1.setLastCheckInTime(new Date());\n        m_locationMonitor1_1.setDefinitionName(\"Raleigh\");\n        \n        m_locationMonitor2_1 = new OnmsLocationMonitor();\n        m_locationMonitor2_1.setId(2);\n        m_locationMonitor2_1.setLastCheckInTime(new Date());\n        m_locationMonitor2_1.setDefinitionName(\"Durham\");\n        \n        m_locationMonitor2_2 = new OnmsLocationMonitor();\n        m_locationMonitor2_2.setId(3);\n        m_locationMonitor2_2.setDefinitionName(\"Durham\");\n        \n        m_pkg = new Package();\n\n        List<String> serviceNames = new ArrayList<String>();\n        serviceNames.add(\"ICMP\");\n        serviceNames.add(\"DNS\");\n        serviceNames.add(\"HTTP\");\n        serviceNames.add(\"HTTPS\");\n        Collections.shuffle(serviceNames); // shuffle to test sorting\n\n        m_selector = new ServiceSelector(\"IPADDR IPLIKE *.*.*.*\", serviceNames);\n        \n        m_node = new OnmsNode();\n        m_ip = \"1.1.1.1\";\n        m_node.setLabel(\"Node 1\");\n        m_node.setId(1);\n        \n        // Can't shuffle since it's a set\n        m_services = new HashSet<OnmsMonitoredService>();\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"ICMP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"DNS\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTPS\")));\n\n        // Can't shuffle since these since they are sets\n        m_applicationServices1 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTP\"));\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application1.setMemberServices(applicationServices1);\n        \n        m_applicationServices2 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices2.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application2.setMemberServices(applicationServices2);\n\n\n        /*\n        m_application2 = new OnmsApplication();\n        m_application2.setLabel(\"Application 2\");\n        // XXX shuffle to verify sorting? create new list and do: Collections.shuffle(applicationServices2)\n        m_application2.setMemberServices(applicationServices1);\n        */\n\n        \n    }","id":45942,"modified_method":"protected void setUp() {\n        m_service.setMonitoredServiceDao(m_monitoredServiceDao);\n        m_service.setLocationMonitorDao(m_locationMonitorDao);\n        m_service.setApplicationDao(m_applicationDao);\n        \n        m_locationDefinition1 = new OnmsMonitoringLocationDefinition(\"Raleigh\", \"raleigh\", \"OpenNMS NC\");\n        m_locationDefinition2 = new OnmsMonitoringLocationDefinition(\"Durham\", \"durham\", \"OpenNMS NC\");\n        m_locationDefinition3 = new OnmsMonitoringLocationDefinition(\"Columbus\", \"columbus\", \"OpenNMS OH\");\n\n        m_application1 = new OnmsApplication();\n        m_application1.setName(\"Application 1\");\n        \n        m_application2 = new OnmsApplication();\n        m_application2.setName(\"Application 2\");\n\n        m_locationMonitor1_1 = new OnmsLocationMonitor();\n        m_locationMonitor1_1.setId(1);\n        m_locationMonitor1_1.setLastCheckInTime(new Date());\n        m_locationMonitor1_1.setDefinitionName(\"Raleigh\");\n        m_locationMonitor1_1.setStatus(MonitorStatus.STARTED);\n        assertEquals(\"location monitor 1.1 status\", MonitorStatus.STARTED,\n                     m_locationMonitor1_1.getStatus());\n        \n        m_locationMonitor2_1 = new OnmsLocationMonitor();\n        m_locationMonitor2_1.setId(2);\n        m_locationMonitor2_1.setLastCheckInTime(new Date());\n        m_locationMonitor2_1.setDefinitionName(\"Durham\");\n        m_locationMonitor2_1.setStatus(MonitorStatus.STARTED);\n        assertEquals(\"location monitor 2.1 status\", MonitorStatus.STARTED,\n                     m_locationMonitor2_1.getStatus());\n        \n        m_locationMonitor2_2 = new OnmsLocationMonitor();\n        m_locationMonitor2_2.setId(3);\n        m_locationMonitor2_2.setDefinitionName(\"Durham\");\n        m_locationMonitor2_2.setStatus(MonitorStatus.STARTED);\n        assertEquals(\"location monitor 2.2 status\", MonitorStatus.STARTED,\n                     m_locationMonitor2_2.getStatus());\n        \n        List<String> serviceNames = new ArrayList<String>();\n        serviceNames.add(\"ICMP\");\n        serviceNames.add(\"DNS\");\n        serviceNames.add(\"HTTP\");\n        serviceNames.add(\"HTTPS\");\n        Collections.shuffle(serviceNames); // shuffle to test sorting\n        \n        m_node = new OnmsNode();\n        m_ip = \"1.1.1.1\";\n        m_node.setLabel(\"Node 1\");\n        m_node.setId(1);\n        \n        // Can't shuffle since it's a set\n        m_services = new HashSet<OnmsMonitoredService>();\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"ICMP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"DNS\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTP\")));\n        m_services.add(new OnmsMonitoredService(new OnmsIpInterface(m_ip, m_node), new OnmsServiceType(\"HTTPS\")));\n\n        // Can't shuffle since these since they are sets\n        m_applicationServices1 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTP\"));\n        m_applicationServices1.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application1.setMemberServices(applicationServices1);\n        \n        m_applicationServices2 = new HashSet<OnmsMonitoredService>();\n        m_applicationServices2.add(findMonitoredService(m_services, m_ip, \"HTTPS\"));\n//        m_application2.setMemberServices(applicationServices2);\n\n\n        /*\n        m_application2 = new OnmsApplication();\n        m_application2.setLabel(\"Application 2\");\n        // XXX shuffle to verify sorting? create new list and do: Collections.shuffle(applicationServices2)\n        m_application2.setMemberServices(applicationServices1);\n        */\n\n        \n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void expectEverything() {\n        resetEverything();\n        \n        expect(m_applicationDao.findByName(\"Application 1\")).andReturn(m_application1);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition1.getName())).andReturn(m_locationDefinition1);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition1)).andReturn(Collections.singleton(m_locationMonitor1_1));\n        expect(m_pollerConfig.getPackage(\"raleigh\")).andReturn(m_pkg);\n        expect(m_pollerConfig.getServiceSelectorForPackage(m_pkg)).andReturn(m_selector);\n        expect(m_monitoredServiceDao.findMatchingServices(m_selector)).andReturn(m_services);\n\n\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpService)).andReturn(new OnmsLocationSpecificStatus(m_locationMonitor1_1, httpService, PollStatus.available()));\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpsService)).andReturn(null);\n    }","id":45943,"modified_method":"public void expectEverything() {\n        resetEverything();\n        \n        expect(m_applicationDao.findByName(\"Application 1\")).andReturn(m_application1);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition1.getName())).andReturn(m_locationDefinition1);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition1)).andReturn(Collections.singleton(m_locationMonitor1_1));\n\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpService)).andReturn(new OnmsLocationSpecificStatus(m_locationMonitor1_1, httpService, PollStatus.available()));\n        expect(m_locationMonitorDao.getMostRecentStatusChange(m_locationMonitor1_1, httpsService)).andReturn(null);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateFacilityStatusTable() {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"simpleWebTableRowLabel\");\n        expectedTable.addColumn(\"Location\", \"simpleWebTableRowLabel\");\n        expectedTable.addColumn(\"Application 1\", \"simpleWebTableRowLabel\");\n        expectedTable.addColumn(\"Application 2\", \"simpleWebTableRowLabel\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"Raleigh\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"Durham\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"0.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Durham&application=Application+1\");\n        expectedTable.addCell(\"0.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Durham&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"Columbus\", \"simpleWebTableRowLabel\");\n        expectedTable.addCell(\"0.000%\", \"Indeterminate\", \"distributedStatusHistory.htm?location=Columbus&application=Application+1\");\n        expectedTable.addCell(\"0.000%\", \"Indeterminate\", \"distributedStatusHistory.htm?location=Columbus&application=Application+2\");\n\n        assertTableEquals(expectedTable, table);\n    }","id":45944,"modified_method":"public void runTestCreateFacilityStatusTable() {\n        resetEverything();\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions =\n            new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications =\n            new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges =\n            new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n\n        Date startDate = new Date(2006 - 1900, 10 - 1, 12, 0, 0, 0);\n        Date endDate = new Date(2006 - 1900, 10 - 1, 13, 0, 0, 0);\n\n        \n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(Collections.EMPTY_SET);\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(Collections.EMPTY_SET);\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        replayEverything();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate,\n                                                                   endDate);\n        verifyEverything();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        /*\n        System.out.print(\"Expected: \" + expectedTable.toString());\n        System.out.print(\"Actual: \" + table.toString());\n        */\n\n        assertTableEquals(expectedTable, table);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestFindLocationSpecificStatusInvalidLocation() {\n        m_service.findLocationSpecificStatus(\"invalid location\", m_application1.getName());\n    }","id":45945,"modified_method":"public void testFindLocationSpecificStatusInvalidLocation() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n        \n        command.setLocation(\"invalid location\");\n        command.setApplication(m_application1.getName());\n        \n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(command.getLocation())).andReturn(null);\n\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"Could not find location for location name \\\"\" + command.getLocation() + \"\\\"\"));\n        \n        replay(m_locationMonitorDao);\n        replay(m_applicationDao);\n        \n        try {\n            m_service.findLocationSpecificStatus(command, errors);\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        \n        verify(m_locationMonitorDao);\n        verify(m_applicationDao);\n\n        ta.verifyAnticipated();\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void resetEverything() {\n        reset(m_applicationDao);\n        reset(m_locationMonitorDao);\n        reset(m_pollerConfig);\n        reset(m_monitoredServiceDao);\n    }","id":45946,"modified_method":"public void resetEverything() {\n        reset(m_applicationDao);\n        reset(m_locationMonitorDao);\n        reset(m_monitoredServiceDao);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateStatusNoLocationMonitor() {\n        //expectEverything();\n        resetEverything();\n        \n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n        //expect(m_pollerConfig.getPackage(\"columbus\")).andReturn(m_pkg);\n        //expect(m_pollerConfig.getServiceSelectorForPackage(m_pkg)).andReturn(m_selector);\n        //expect(m_monitoredServiceDao.findMatchingServices(m_selector)).andReturn(m_services);\n        \n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new IllegalArgumentException(\"No location monitors have registered for location \\\"Columbus\\\"\"));\n        \n        replayEverything();\n        try {\n            SimpleWebTable table =\n                m_service.createStatusTable(m_locationDefinition3.getName(),\n                                            m_application2.getName());\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n\n        verifyEverything();\n\n        /*\n        \n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 2 from Columbus location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response Time\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Critical\");\n        expectedTable.addCell(\"Node 1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n        */\n    }","id":45947,"modified_method":"public void runTestCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command =\n            new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        resetEverything();\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(Collections.EMPTY_LIST);\n\n        replayEverything();\n        SimpleWebTable table =\n            m_service.createStatusTable(command, errors);\n\n        assertEquals(\"Number of errors\", 1, errors.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errors.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errors.getFieldErrorCount());\n        ObjectError e = (ObjectError) errors.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        verifyEverything();\n\n        /*\n        \n        \n        //System.out.print(table.toString());\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed poller view for Application 2 from Columbus location\");\n        \n        expectedTable.addColumn(\"Node\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Monitor\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Service\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Status\", \"simpleWebTableHeader\");\n        expectedTable.addColumn(\"Response Time\", \"simpleWebTableHeader\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Node 1\", \"Critical\");\n        expectedTable.addCell(\"Node 1\", \"\");\n        expectedTable.addCell(\"HTTPS\", \"\");\n        expectedTable.addCell(\"Unknown\", \"bright\");\n        expectedTable.addCell(\"\", \"\");\n        \n        assertTableEquals(expectedTable, table);\n        */\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String applicationName = request.getParameter(\"application\");\n        String locationName = request.getParameter(\"location\");\n        SimpleWebTable table = m_distributedStatusService.createStatusTable(locationName, applicationName);\n        return new ModelAndView(\"distributedStatusDetails\", \"webTable\", table);\n    }","id":45948,"modified_method":"@Override\n    protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException errors) throws Exception {\n        DistributedStatusDetailsCommand cmd = (DistributedStatusDetailsCommand) command;\n        SimpleWebTable table = m_distributedStatusService.createStatusTable(cmd, errors);\n        return new ModelAndView(getSuccessView(), \"webTable\", table);\n    }","commit_id":"4207fc7362a956da70bef8da05e2505855c3a9e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static ArrayList<String> parseCompatibleModesList(String unparsedModes) {\n    ArrayList<String> modesList = new ArrayList<String>();\n    if (unparsedModes == null || unparsedModes.isEmpty())\n      return modesList;\n    String[] splitStr = unparsedModes.split(\",\");\n    for (String mode : splitStr)\n      modesList.add(mode.trim());\n    return modesList;\n  }","id":45949,"modified_method":"private static ArrayList<String> parseCompatibleModesList(String unparsedModes) {\n    ArrayList<String> modesList = new ArrayList<String>();\n    if (unparsedModes == null || unparsedModes.isEmpty())\n      return modesList;\n    String[] splitStr = PApplet.trim(PApplet.split(unparsedModes, ','));//unparsedModes.split(\",\");\n    for (String mode : splitStr)\n      modesList.add(mode.trim());\n    return modesList;\n  }","commit_id":"6a0aed8a6218bc756d97a6cd934190bcdedd05b2","url":"https://github.com/processing/processing"},{"original_method":"public JTree buildExamplesTree() {\n    DefaultMutableTreeNode node = new DefaultMutableTreeNode(\"Examples\");\n\n    JTree examplesTree = new JTree(node);\n//    rebuildExamplesTree(node);\n//  }\n\n    //DefaultTreeCellRenderer renderer = tree.\n//    TreeCellRenderer tcr = examplesTree.getCellRenderer();\n\n    //\n//\n//  public void rebuildExamplesTree(DefaultMutableTreeNode node) {\n    try {\n      // break down the examples folder for examples\n//      File[] subfolders = examplesFolder.listFiles(new FilenameFilter() {\n//        public boolean accept(File dir, String name) {\n//          return dir.isDirectory() && name.charAt(0) != '.';\n//        }\n//      });\n      File[] subfolders = getExampleCategoryFolders();\n\n//      DefaultMutableTreeNode examplesParent = new DefaultMutableTreeNode(\"Examples\");\n      for (File sub : subfolders) {\n        DefaultMutableTreeNode subNode = new DefaultMutableTreeNode(sub.getName());\n        if (base.addSketches(subNode, sub)) {\n//          examplesParent.add(subNode);\n          node.add(subNode);\n        }\n      }\n//      node.add(examplesParent);\n//      examplesTree.expandPath(new TreePath(examplesParent));\n\n      // get library examples\n      boolean any = false;\n      DefaultMutableTreeNode libParent = new DefaultMutableTreeNode(\"Libraries\");\n      for (Library lib : coreLibraries) {\n        if (lib.hasExamples()) {\n          DefaultMutableTreeNode libNode = new DefaultMutableTreeNode(lib.getName());\n          any |= base.addSketches(libNode, lib.getExamplesFolder());\n          libParent.add(libNode);\n        }\n      }\n      if (any) {\n        node.add(libParent);\n      }\n\n      // get contrib library examples\n      any = false;\n      for (Library lib : contribLibraries) {\n        if (lib.hasExamples()) {\n          any = true;\n        }\n      }\n      if (any) {\n//        menu.addSeparator();\n        DefaultMutableTreeNode contribParent = new DefaultMutableTreeNode(\"Contributed Libraries\");\n//        Base.addDisabledItem(menu, \"Contributed\");\n        for (Library lib : contribLibraries) {\n          if (lib.hasExamples()) {\n//            JMenu libMenu = new JMenu(lib.getName());\n            DefaultMutableTreeNode libNode = new DefaultMutableTreeNode(lib.getName());\n//            base.addSketches(libMenu, lib.getExamplesFolder(), replace);\n            base.addSketches(libNode, lib.getExamplesFolder());\n//            menu.add(libMenu);\n            contribParent.add(libNode);\n          }\n        }\n        node.add(contribParent);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return examplesTree;\n  }","id":45950,"modified_method":"public DefaultMutableTreeNode buildExamplesTree() {\n    DefaultMutableTreeNode node = new DefaultMutableTreeNode(\"Examples\");\n\n//    JTree examplesTree = new JTree(node);\n//    rebuildExamplesTree(node);\n//  }\n\n    //DefaultTreeCellRenderer renderer = tree.\n//    TreeCellRenderer tcr = examplesTree.getCellRenderer();\n\n    //\n//\n//  public void rebuildExamplesTree(DefaultMutableTreeNode node) {\n    try {\n      // break down the examples folder for examples\n//      File[] subfolders = examplesFolder.listFiles(new FilenameFilter() {\n//        public boolean accept(File dir, String name) {\n//          return dir.isDirectory() && name.charAt(0) != '.';\n//        }\n//      });\n      File[] subfolders = getExampleCategoryFolders();\n\n      DefaultMutableTreeNode modeExParent = new DefaultMutableTreeNode(\"Mode Examples\");\n      \n      for (File sub : subfolders) {\n        DefaultMutableTreeNode subNode = new DefaultMutableTreeNode(sub.getName());\n        if (base.addSketches(subNode, sub)) {\n//          examplesParent.add(subNode);\n          modeExParent.add(subNode);\n        }\n      }\n \n      // get library examples\n      boolean any = false;\n      for (Library lib : coreLibraries) {\n        if (lib.hasExamples()) {\n          DefaultMutableTreeNode libNode = new DefaultMutableTreeNode(lib.getName());\n          if (base.addSketches(libNode, lib.getExamplesFolder()))\n            modeExParent.add(libNode);\n        }\n      }\n      \n      if (modeExParent.getChildCount() > 0)\n        node.add(modeExParent);\n\n      // get contrib library examples\n      any = false;\n      for (Library lib : contribLibraries) {\n        if (lib.hasExamples()) {\n          any = true;\n        }\n      }\n      if (any) {\n//        menu.addSeparator();\n        DefaultMutableTreeNode contribParent = new DefaultMutableTreeNode(\"Library Examples\");\n//        Base.addDisabledItem(menu, \"Contributed\");\n        for (Library lib : contribLibraries) {\n          if (lib.hasExamples()) {\n//            JMenu libMenu = new JMenu(lib.getName());\n            DefaultMutableTreeNode libNode = new DefaultMutableTreeNode(lib.getName());\n//            base.addSketches(libMenu, lib.getExamplesFolder(), replace);\n            base.addSketches(libNode, lib.getExamplesFolder());\n//            menu.add(libMenu);\n            contribParent.add(libNode);\n          }\n        }\n        node.add(contribParent);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    \n    DefaultMutableTreeNode contribExampleNode = buildContributedExamplesTrees();\n    if (contribExampleNode.getChildCount() > 0)\n      node.add(contribExampleNode);\n    return node;\n  }","commit_id":"6a0aed8a6218bc756d97a6cd934190bcdedd05b2","url":"https://github.com/processing/processing"},{"original_method":"public JTree buildContributedExamplesTrees() {\n    DefaultMutableTreeNode node = new DefaultMutableTreeNode(\"Contributed Examples\");\n\n    JTree examplesTree = new JTree(node);\n\n    try {\n      File[] subfolders = ContributionType.EXAMPLE.listCandidates(examplesContribFolder);\n      if (subfolders == null) {\n        subfolders = new File[0]; //empty array\n      }\n      for (File sub : subfolders) {\n        if (!ExampleContribution.isExampleCompatible(base, sub))\n          continue;\n        DefaultMutableTreeNode subNode = new DefaultMutableTreeNode(sub.getName());\n        if (base.addSketches(subNode, sub)) {\n          node.add(subNode);\n          int exampleNodeNumber = -1;\n          for (int y = 0; y < subNode.getChildCount(); y++)\n            if (subNode.getChildAt(y).toString().equals(\"example\"))\n              exampleNodeNumber = y;\n          if (exampleNodeNumber == -1)\n            continue;\n          TreeNode exampleNode = subNode.getChildAt(exampleNodeNumber);\n          subNode.remove(exampleNodeNumber);\n          int count = exampleNode.getChildCount();\n          for (int x = 0; x < count; x++) {\n            subNode.add((DefaultMutableTreeNode) exampleNode.getChildAt(0));\n          }\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return examplesTree;\n  }","id":45951,"modified_method":"public DefaultMutableTreeNode buildContributedExamplesTrees() {\n    DefaultMutableTreeNode node = new DefaultMutableTreeNode(\"Contributed Examples\");\n\n    try {\n      File[] subfolders = ContributionType.EXAMPLE.listCandidates(examplesContribFolder);\n      if (subfolders == null) {\n        subfolders = new File[0]; //empty array\n      }\n      for (File sub : subfolders) {\n        if (!ExampleContribution.isExampleCompatible(base, sub))\n          continue;\n        DefaultMutableTreeNode subNode = new DefaultMutableTreeNode(sub.getName());\n        if (base.addSketches(subNode, sub)) {\n          node.add(subNode);\n          System.out.println(subNode);\n          int exampleNodeNumber = -1;\n          for (int y = 0; y < subNode.getChildCount(); y++)\n            if (subNode.getChildAt(y).toString().equals(\"example\"))\n              exampleNodeNumber = y;\n          if (exampleNodeNumber == -1)\n            continue;\n          TreeNode exampleNode = subNode.getChildAt(exampleNodeNumber);\n          subNode.remove(exampleNodeNumber);\n          int count = exampleNode.getChildCount();\n          for (int x = 0; x < count; x++) {\n            subNode.add((DefaultMutableTreeNode) exampleNode.getChildAt(0));\n            System.out.println(subNode);\n          }\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return node;//examplesTree;\n  }","commit_id":"6a0aed8a6218bc756d97a6cd934190bcdedd05b2","url":"https://github.com/processing/processing"},{"original_method":"public void showExamplesFrame() {\n    if (examplesFrame == null) {\n      examplesFrame = new JFrame(getTitle() + \" \" + Language.text(\"examples\"));\n      Toolkit.setIcon(examplesFrame);\n      Toolkit.registerWindowCloseKeys(examplesFrame.getRootPane(), new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          examplesFrame.setVisible(false);\n        }\n      });\n      \n      JPanel examplesPanel = new JPanel();\n      examplesPanel.setLayout(new BoxLayout(examplesPanel, BoxLayout.PAGE_AXIS));\n      examplesPanel.setBackground(Color.WHITE);\n      \n      final JLabel openExamplesManagerLabel = new JLabel(\"<html><u>Add Example...<\/u><\/html>\");\n      openExamplesManagerLabel.setOpaque(false);\n      openExamplesManagerLabel.setBorder(new EmptyBorder(10, 6, 1, 5));\n      openExamplesManagerLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n      openExamplesManagerLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));\n      openExamplesManagerLabel.setForeground(new Color(0, 0, 238));\n      openExamplesManagerLabel.addMouseListener(new MouseListener() {\n        \n        @Override\n        public void mouseReleased(MouseEvent e) {}\n        \n        @Override\n        public void mousePressed(MouseEvent e) {}\n        \n        @Override\n        public void mouseExited(MouseEvent e) {}\n        \n        @Override\n        public void mouseEntered(MouseEvent e) {}\n        \n        @Override\n        public void mouseClicked(MouseEvent e) {\n          base.handleOpenExampleManager();\n          openExamplesManagerLabel.setForeground(new Color(85, 26, 139));\n        }\n      });\n      \n      final JTree tree = buildExamplesTree();\n      setupExamplesTree(tree);\n  \n      JScrollPane treePane = new JScrollPane(tree);\n      treePane.setPreferredSize(new Dimension(250, 300));\n      treePane.setBorder(new EmptyBorder(5, 0, 0, 0));\n      treePane.setOpaque(true);\n      treePane.setBackground(Color.WHITE);\n      treePane.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      JLabel contribExLabel = new JLabel(\"Contributed Examples\");\n      contribExLabel.setOpaque(false);\n      contribExLabel.setBorder(new EmptyBorder(10, 6, 1, 5));\n      contribExLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      final JTree tree2 = buildContributedExamplesTrees();\n      setupExamplesTree(tree2);\n      \n      JScrollPane treePane2 = new JScrollPane(tree2);\n      treePane2.setPreferredSize(new Dimension(250, 300));\n      treePane2.setBorder(new EmptyBorder(0, 0, 10, 0));\n      treePane2.setOpaque(true);\n      treePane2.setBackground(Color.WHITE);\n      treePane2.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      examplesPanel.add(openExamplesManagerLabel);\n      examplesPanel.add(treePane);\n      examplesPanel.add(contribExLabel);\n      examplesPanel.add(treePane2);\n      examplesFrame.getContentPane().add(examplesPanel);\n      examplesFrame.pack();\n\n      restoreExpanded(tree);\n    }\n\n    // Space for the editor plus a li'l gap\n    int roughWidth = examplesFrame.getWidth() + 20;\n    Point p = null;\n    // If no window open, or the editor is at the edge of the screen\n    if (base.activeEditor == null ||\n        (p = base.activeEditor.getLocation()).x < roughWidth) {\n      // Center the window on the screen\n      examplesFrame.setLocationRelativeTo(null);\n    } else {\n      // Open the window relative to the editor\n      examplesFrame.setLocation(p.x - roughWidth, p.y);\n    }\n    examplesFrame.setVisible(true);\n  }","id":45952,"modified_method":"public void showExamplesFrame() {\n    if (examplesFrame == null) {\n      examplesFrame = new JFrame(getTitle() + \" \" + Language.text(\"examples\"));\n      Toolkit.setIcon(examplesFrame);\n      Toolkit.registerWindowCloseKeys(examplesFrame.getRootPane(), new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          examplesFrame.setVisible(false);\n        }\n      });\n      \n      JPanel examplesPanel = new JPanel();\n      examplesPanel.setLayout(new BoxLayout(examplesPanel, BoxLayout.PAGE_AXIS));\n      examplesPanel.setBackground(Color.WHITE);\n      \n      final JLabel openExamplesManagerLabel = new JLabel(\"<html><u>Add Example...<\/u><\/html>\");\n      openExamplesManagerLabel.setOpaque(false);\n      openExamplesManagerLabel.setBorder(new EmptyBorder(10, 6, 1, 5));\n      openExamplesManagerLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n      openExamplesManagerLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));\n      openExamplesManagerLabel.setForeground(new Color(0, 0, 238));\n      openExamplesManagerLabel.addMouseListener(new MouseListener() {\n        \n        @Override\n        public void mouseReleased(MouseEvent e) {}\n        \n        @Override\n        public void mousePressed(MouseEvent e) {}\n        \n        @Override\n        public void mouseExited(MouseEvent e) {}\n        \n        @Override\n        public void mouseEntered(MouseEvent e) {}\n        \n        @Override\n        public void mouseClicked(MouseEvent e) {\n          base.handleOpenExampleManager();\n          openExamplesManagerLabel.setForeground(new Color(85, 26, 139));\n        }\n      });\n      \n      final JTree tree = new JTree(buildExamplesTree());\n      \n      \n      tree.setOpaque(true);\n      tree.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n      tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n      tree.setShowsRootHandles(true);\n//      tree.setToggleClickCount(2);\n      // expand the root\n      tree.expandRow(0);\n      // now hide the root\n      tree.setRootVisible(false);\n\n      // After 2.0a7, no longer expanding each of the categories at Casey's\n      // request. He felt that the window was too complicated too quickly.\n//      for (int row = tree.getRowCount()-1; row >= 0; --row) {\n//        tree.expandRow(row);\n//      }\n\n      tree.addMouseListener(new MouseAdapter() {\n        public void mouseClicked(MouseEvent e) {\n          if (e.getClickCount() == 2) {\n            DefaultMutableTreeNode node =\n              (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();\n\n            int selRow = tree.getRowForLocation(e.getX(), e.getY());\n            //TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());\n            //if (node != null && node.isLeaf() && node.getPath().equals(selPath)) {\n            if (node != null && node.isLeaf() && selRow != -1) {\n              SketchReference sketch = (SketchReference) node.getUserObject();\n              base.handleOpen(sketch.getPath());\n            }\n          }\n        }\n      });\n      tree.addKeyListener(new KeyAdapter() {\n        public void keyPressed(KeyEvent e) {\n          if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {  // doesn't fire keyTyped()\n            examplesFrame.setVisible(false);\n          }\n        }\n        public void keyTyped(KeyEvent e) {\n          if (e.getKeyChar() == KeyEvent.VK_ENTER) {\n            DefaultMutableTreeNode node =\n              (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();\n            if (node != null && node.isLeaf()) {\n              SketchReference sketch = (SketchReference) node.getUserObject();\n              base.handleOpen(sketch.getPath());\n            }\n          }\n        }\n      });\n\n      tree.addTreeExpansionListener(new TreeExpansionListener() {\n        @Override\n        public void treeExpanded(TreeExpansionEvent event) {\n          updateExpanded(tree);\n        }\n\n        @Override\n        public void treeCollapsed(TreeExpansionEvent event) {\n          updateExpanded(tree);\n        }\n      });\n\n      tree.setBorder(new EmptyBorder(5, 5, 5, 5));\n      if (Base.isMacOS()) {\n        tree.setToggleClickCount(2);\n      } else {\n        tree.setToggleClickCount(1);\n      }\n  \n      JScrollPane treePane = new JScrollPane(tree);\n      treePane.setPreferredSize(new Dimension(250, 300));\n      treePane.setBorder(new EmptyBorder(5, 0, 0, 0));\n      treePane.setOpaque(true);\n      treePane.setBackground(Color.WHITE);\n      treePane.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      examplesPanel.add(openExamplesManagerLabel);\n      examplesPanel.add(treePane);\n      examplesFrame.getContentPane().add(examplesPanel);\n      examplesFrame.pack();\n\n      restoreExpanded(tree);\n    }\n\n    // Space for the editor plus a li'l gap\n    int roughWidth = examplesFrame.getWidth() + 20;\n    Point p = null;\n    // If no window open, or the editor is at the edge of the screen\n    if (base.activeEditor == null ||\n        (p = base.activeEditor.getLocation()).x < roughWidth) {\n      // Center the window on the screen\n      examplesFrame.setLocationRelativeTo(null);\n    } else {\n      // Open the window relative to the editor\n      examplesFrame.setLocation(p.x - roughWidth, p.y);\n    }\n    examplesFrame.setVisible(true);\n  }","commit_id":"6a0aed8a6218bc756d97a6cd934190bcdedd05b2","url":"https://github.com/processing/processing"},{"original_method":"@Override\n  public void valueChanged(@Nullable ListSelectionEvent event) {\n    if (event != null && event.getValueIsAdjusting()) return;\n\n    Set<VcsFullCommitDetails> newCommitDetails = ContainerUtil.newHashSet();\n\n    int[] rows = myGraphTable.getSelectedRows();\n\n    myLoadingPanel.stopLoading();\n    if (rows.length < 1) {\n      myEmptyText.setText(\"No commits selected\");\n      myMainContentPanel.removeAll();\n      return;\n    }\n\n    int MAX_ROWS = 50;\n    myEmptyText.setText(\"\");\n    GraphTableModel tableModel = myGraphTable.getModel();\n    int count = 0;\n    for (int i = 0; i < Math.min(rows.length, MAX_ROWS); i++) {\n      int row = rows[i];\n      boolean reuseExisting = count + 1 < myMainContentPanel.getComponentCount();\n      ReferencesPanel referencesPanel;\n      DataPanel dataPanel;\n      if (!reuseExisting) {\n        referencesPanel = new ReferencesPanel(myColorManager);\n        dataPanel = new DataPanel(myLogData.getProject(), myLogData.isMultiRoot());\n        if (i > 0) {\n          myMainContentPanel.add(new SeparatorComponent(8, OnePixelDivider.BACKGROUND, null));\n          count ++;\n        }\n        referencesPanel.setAlignmentX(LEFT_ALIGNMENT);\n        myMainContentPanel.add(referencesPanel);\n        count++;\n        dataPanel.setAlignmentX(LEFT_ALIGNMENT);\n        myMainContentPanel.add(dataPanel);\n        count++;\n      }\n      else {\n        if (i > 0) count ++; // separator\n        referencesPanel = (ReferencesPanel)myMainContentPanel.getComponent(count++);\n        dataPanel = (DataPanel)myMainContentPanel.getComponent(count++);\n      }\n\n      VcsFullCommitDetails commitData = tableModel.getFullDetails(row);\n      if (commitData instanceof LoadingDetails) {\n        myLoadingPanel.startLoading();\n        dataPanel.setData(null);\n        referencesPanel.setReferences(Collections.emptyList());\n        updateDetailsBorder(null);\n      }\n      else {\n        dataPanel.setData(commitData);\n        referencesPanel.setReferences(sortRefs(commitData.getId(), commitData.getRoot()));\n        updateDetailsBorder(commitData);\n        newCommitDetails.add(commitData);\n      }\n      List<String> branches = null;\n      if (!(commitData instanceof LoadingDetails)) {\n        branches = myLogData.getContainingBranchesGetter().requestContainingBranches(commitData.getRoot(), commitData.getId());\n      }\n      dataPanel.setBranches(branches);\n      dataPanel.update();\n    }\n\n    // clear superfluous items\n    while (count < myMainContentPanel.getComponentCount()) {\n      myMainContentPanel.remove(count);\n    }\n\n    if (rows.length > MAX_ROWS) {\n      myMainContentPanel.add(new SeparatorComponent(8, OnePixelDivider.BACKGROUND, null));\n      JBLabel label = new JBLabel(\"(showing \" + MAX_ROWS + \" of \" + rows.length + \" selected commits)\");\n      label.setFont(getDataPanelFont());\n      label.setAlignmentX(LEFT_ALIGNMENT);\n      myMainContentPanel.add(label);\n    }\n\n    if (!ContainerUtil.intersects(myCurrentCommitDetails, newCommitDetails)) {\n      myScrollPane.getVerticalScrollBar().setValue(0);\n    }\n    myCurrentCommitDetails = newCommitDetails;\n  }","id":45953,"modified_method":"@Override\n  public void valueChanged(@Nullable ListSelectionEvent event) {\n    if (event != null && event.getValueIsAdjusting()) return;\n\n    Set<VcsFullCommitDetails> newCommitDetails = ContainerUtil.newHashSet();\n\n    int[] rows = myGraphTable.getSelectedRows();\n\n    myLoadingPanel.stopLoading();\n    if (rows.length < 1) {\n      myEmptyText.setText(\"No commits selected\");\n      myMainContentPanel.removeAll();\n      return;\n    }\n\n    int MAX_ROWS = 50;\n    myEmptyText.setText(\"\");\n    GraphTableModel tableModel = myGraphTable.getModel();\n    int count = 0;\n    for (int i = 0; i < Math.min(rows.length, MAX_ROWS); i++) {\n      int row = rows[i];\n      boolean reuseExisting = count < myMainContentPanel.getComponentCount();\n      CommitPanel commitPanel;\n      if (!reuseExisting) {\n        commitPanel = new CommitPanel();\n        if (i > 0) {\n          myMainContentPanel.add(new SeparatorComponent(8, OnePixelDivider.BACKGROUND, null));\n          count++;\n        }\n        commitPanel.setAlignmentX(LEFT_ALIGNMENT);\n        myMainContentPanel.add(commitPanel);\n        count++;\n      }\n      else {\n        if (i > 0) count++; // separator\n        commitPanel = (CommitPanel)myMainContentPanel.getComponent(count++);\n      }\n\n      VcsFullCommitDetails commitData = tableModel.getFullDetails(row);\n      commitPanel.setCommit(commitData);\n      if (!(commitData instanceof LoadingDetails)) {\n        newCommitDetails.add(commitData);\n      }\n    }\n\n    // clear superfluous items\n    while (count < myMainContentPanel.getComponentCount()) {\n      myMainContentPanel.remove(count);\n    }\n\n    if (rows.length > MAX_ROWS) {\n      myMainContentPanel.add(new SeparatorComponent(8, OnePixelDivider.BACKGROUND, null));\n      JBLabel label = new JBLabel(\"(showing \" + MAX_ROWS + \" of \" + rows.length + \" selected commits)\");\n      label.setFont(getDataPanelFont());\n      label.setAlignmentX(LEFT_ALIGNMENT);\n      myMainContentPanel.add(label);\n    }\n\n    if (!ContainerUtil.intersects(myCurrentCommitDetails, newCommitDetails)) {\n      myScrollPane.getVerticalScrollBar().setValue(0);\n    }\n    myCurrentCommitDetails = newCommitDetails;\n  }","commit_id":"79d06dfbfb5271d5793fcb280f9379495e3fa79f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"DetailsPanel(@NotNull VcsLogData logData,\n               @NotNull VcsLogGraphTable graphTable,\n               @NotNull VcsLogColorManager colorManager,\n               @NotNull VisiblePack initialDataPack,\n               @NotNull Disposable parent) {\n    myLogData = logData;\n    myGraphTable = graphTable;\n    myColorManager = colorManager;\n    myDataPack = initialDataPack;\n\n    myScrollPane = new JBScrollPane(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.getVerticalScrollBar().setUnitIncrement(JBUI.scale(10));\n    myScrollPane.getHorizontalScrollBar().setUnitIncrement(JBUI.scale(10));\n    myMainContentPanel = new JPanel() {\n      @Override\n      public Dimension getPreferredSize() {\n        Dimension size = super.getPreferredSize();\n        boolean expanded = false;\n        for (Component c : getComponents()) {\n          if (c instanceof DataPanel && ((DataPanel)c).isExpanded()) {\n            expanded = true;\n            break;\n          }\n        }\n        if (expanded) {\n          return size;\n        }\n        size.width = myScrollPane.getViewport().getWidth() - 5;\n        return size;\n      }\n\n      @Override\n      public Color getBackground() {\n        return getDetailsBackground();\n      }\n\n      @Override\n      protected void paintChildren(Graphics g) {\n        if (StringUtil.isNotEmpty(myEmptyText.getText())) {\n          myEmptyText.paint(this, g);\n        }\n        else {\n          super.paintChildren(g);\n        }\n      }\n\n    };\n    myMainContentPanel.setLayout(new BoxLayout(myMainContentPanel, BoxLayout.Y_AXIS));\n    myEmptyText = new StatusText(myMainContentPanel) {\n      @Override\n      protected boolean isStatusVisible() {\n        return StringUtil.isNotEmpty(getText());\n      }\n    };\n\n    myMainContentPanel.setOpaque(false);\n    myScrollPane.setViewportView(myMainContentPanel);\n    myScrollPane.setBorder(IdeBorderFactory.createEmptyBorder());\n    myScrollPane.setViewportBorder(IdeBorderFactory.createEmptyBorder());\n\n    myLoadingPanel = new JBLoadingPanel(new BorderLayout(), parent, ProgressWindow.DEFAULT_PROGRESS_DIALOG_POSTPONE_TIME_MILLIS) {\n      @Override\n      public Color getBackground() {\n        return getDetailsBackground();\n      }\n    };\n    myLoadingPanel.add(myScrollPane);\n\n    setLayout(new BorderLayout());\n    add(myLoadingPanel, BorderLayout.CENTER);\n\n    myEmptyText.setText(\"Commit details\");\n  }","id":45954,"modified_method":"DetailsPanel(@NotNull VcsLogData logData,\n               @NotNull VcsLogGraphTable graphTable,\n               @NotNull VcsLogColorManager colorManager,\n               @NotNull VisiblePack initialDataPack,\n               @NotNull Disposable parent) {\n    myLogData = logData;\n    myGraphTable = graphTable;\n    myColorManager = colorManager;\n    myDataPack = initialDataPack;\n\n    myScrollPane = new JBScrollPane(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    myScrollPane.getVerticalScrollBar().setUnitIncrement(JBUI.scale(10));\n    myScrollPane.getHorizontalScrollBar().setUnitIncrement(JBUI.scale(10));\n    myMainContentPanel = new JPanel() {\n      @Override\n      public Dimension getPreferredSize() {\n        Dimension size = super.getPreferredSize();\n        boolean expanded = false;\n        for (Component c : getComponents()) {\n          if (c instanceof CommitPanel && ((CommitPanel)c).isExpanded()) {\n            expanded = true;\n            break;\n          }\n        }\n        if (expanded) {\n          return size;\n        }\n        size.width = myScrollPane.getViewport().getWidth() - 5;\n        return size;\n      }\n\n      @Override\n      public Color getBackground() {\n        return getDetailsBackground();\n      }\n\n      @Override\n      protected void paintChildren(Graphics g) {\n        if (StringUtil.isNotEmpty(myEmptyText.getText())) {\n          myEmptyText.paint(this, g);\n        }\n        else {\n          super.paintChildren(g);\n        }\n      }\n    };\n    myMainContentPanel.setLayout(new BoxLayout(myMainContentPanel, BoxLayout.Y_AXIS));\n    myEmptyText = new StatusText(myMainContentPanel) {\n      @Override\n      protected boolean isStatusVisible() {\n        return StringUtil.isNotEmpty(getText());\n      }\n    };\n\n    myMainContentPanel.setOpaque(false);\n    myScrollPane.setViewportView(myMainContentPanel);\n    myScrollPane.setBorder(IdeBorderFactory.createEmptyBorder());\n    myScrollPane.setViewportBorder(IdeBorderFactory.createEmptyBorder());\n\n    myLoadingPanel = new JBLoadingPanel(new BorderLayout(), parent, ProgressWindow.DEFAULT_PROGRESS_DIALOG_POSTPONE_TIME_MILLIS) {\n      @Override\n      public Color getBackground() {\n        return getDetailsBackground();\n      }\n    };\n    myLoadingPanel.add(myScrollPane);\n\n    setLayout(new BorderLayout());\n    add(myLoadingPanel, BorderLayout.CENTER);\n\n    myEmptyText.setText(\"Commit details\");\n  }","commit_id":"79d06dfbfb5271d5793fcb280f9379495e3fa79f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showExamplesFrame() {\n    if (examplesFrame == null) {\n      examplesFrame = new JFrame(getTitle() + \" \" + Language.text(\"examples\"));\n      Toolkit.setIcon(examplesFrame);\n      Toolkit.registerWindowCloseKeys(examplesFrame.getRootPane(), new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          examplesFrame.setVisible(false);\n        }\n      });\n      \n      JPanel examplesPanel = new JPanel();\n      examplesPanel.setLayout(new BoxLayout(examplesPanel, BoxLayout.PAGE_AXIS));\n      examplesPanel.setBackground(Color.WHITE);\n      \n      final JLabel openExamplesManagerLabel = new JLabel(\"<html><u>Add Example...<\/u><\/html>\");\n      openExamplesManagerLabel.setOpaque(false);\n      openExamplesManagerLabel.setBorder(new EmptyBorder(10, 6, 1, 5));\n      openExamplesManagerLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n      openExamplesManagerLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));\n      openExamplesManagerLabel.setForeground(new Color(0, 0, 238));\n      openExamplesManagerLabel.addMouseListener(new MouseListener() {\n        \n        @Override\n        public void mouseReleased(MouseEvent e) {}\n        \n        @Override\n        public void mousePressed(MouseEvent e) {}\n        \n        @Override\n        public void mouseExited(MouseEvent e) {}\n        \n        @Override\n        public void mouseEntered(MouseEvent e) {}\n        \n        @Override\n        public void mouseClicked(MouseEvent e) {\n          base.handleOpenExampleManager();\n          openExamplesManagerLabel.setForeground(new Color(85, 26, 139));\n        }\n      });\n      \n      final JTree tree = buildExamplesTree();\n      tree.setOpaque(true);\n      tree.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n      tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n      tree.setShowsRootHandles(true);\n//      tree.setToggleClickCount(2);\n      // expand the root\n      tree.expandRow(0);\n      // now hide the root\n      tree.setRootVisible(false);\n\n      // After 2.0a7, no longer expanding each of the categories at Casey's\n      // request. He felt that the window was too complicated too quickly.\n//      for (int row = tree.getRowCount()-1; row >= 0; --row) {\n//        tree.expandRow(row);\n//      }\n\n      tree.addMouseListener(new MouseAdapter() {\n        public void mouseClicked(MouseEvent e) {\n          if (e.getClickCount() == 2) {\n            DefaultMutableTreeNode node =\n              (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();\n\n            int selRow = tree.getRowForLocation(e.getX(), e.getY());\n            //TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());\n            //if (node != null && node.isLeaf() && node.getPath().equals(selPath)) {\n            if (node != null && node.isLeaf() && selRow != -1) {\n              SketchReference sketch = (SketchReference) node.getUserObject();\n              base.handleOpen(sketch.getPath());\n            }\n          }\n        }\n      });\n      tree.addKeyListener(new KeyAdapter() {\n        public void keyPressed(KeyEvent e) {\n          if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {  // doesn't fire keyTyped()\n            examplesFrame.setVisible(false);\n          }\n        }\n        public void keyTyped(KeyEvent e) {\n          if (e.getKeyChar() == KeyEvent.VK_ENTER) {\n            DefaultMutableTreeNode node =\n              (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();\n            if (node != null && node.isLeaf()) {\n              SketchReference sketch = (SketchReference) node.getUserObject();\n              base.handleOpen(sketch.getPath());\n            }\n          }\n        }\n      });\n\n      tree.addTreeExpansionListener(new TreeExpansionListener() {\n        @Override\n        public void treeExpanded(TreeExpansionEvent event) {\n          updateExpanded(tree);\n        }\n\n        @Override\n        public void treeCollapsed(TreeExpansionEvent event) {\n          updateExpanded(tree);\n        }\n      });\n\n      tree.setBorder(new EmptyBorder(5, 5, 5, 5));\n      if (Base.isMacOS()) {\n        tree.setToggleClickCount(2);\n      } else {\n        tree.setToggleClickCount(1);\n      }\n      JScrollPane treePane = new JScrollPane(tree);\n      treePane.setPreferredSize(new Dimension(250, 450));\n      treePane.setBorder(new EmptyBorder(0, 0, 0, 0));\n      treePane.setOpaque(true);\n      treePane.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      examplesPanel.add(openExamplesManagerLabel);\n      examplesPanel.add(treePane);\n      examplesFrame.getContentPane().add(examplesPanel);\n      examplesFrame.pack();\n\n      restoreExpanded(tree);\n    }\n\n    // Space for the editor plus a li'l gap\n    int roughWidth = examplesFrame.getWidth() + 20;\n    Point p = null;\n    // If no window open, or the editor is at the edge of the screen\n    if (base.activeEditor == null ||\n        (p = base.activeEditor.getLocation()).x < roughWidth) {\n      // Center the window on the screen\n      examplesFrame.setLocationRelativeTo(null);\n    } else {\n      // Open the window relative to the editor\n      examplesFrame.setLocation(p.x - roughWidth, p.y);\n    }\n    examplesFrame.setVisible(true);\n  }","id":45955,"modified_method":"public void showExamplesFrame() {\n    if (examplesFrame == null) {\n      examplesFrame = new JFrame(getTitle() + \" \" + Language.text(\"examples\"));\n      Toolkit.setIcon(examplesFrame);\n      Toolkit.registerWindowCloseKeys(examplesFrame.getRootPane(), new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          examplesFrame.setVisible(false);\n        }\n      });\n      \n      JPanel examplesPanel = new JPanel();\n      examplesPanel.setLayout(new BoxLayout(examplesPanel, BoxLayout.PAGE_AXIS));\n      examplesPanel.setBackground(Color.WHITE);\n      \n      final JLabel openExamplesManagerLabel = new JLabel(\"<html><u>Add Example...<\/u><\/html>\");\n      openExamplesManagerLabel.setOpaque(false);\n      openExamplesManagerLabel.setBorder(new EmptyBorder(10, 6, 1, 5));\n      openExamplesManagerLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n      openExamplesManagerLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));\n      openExamplesManagerLabel.setForeground(new Color(0, 0, 238));\n      openExamplesManagerLabel.addMouseListener(new MouseListener() {\n        \n        @Override\n        public void mouseReleased(MouseEvent e) {}\n        \n        @Override\n        public void mousePressed(MouseEvent e) {}\n        \n        @Override\n        public void mouseExited(MouseEvent e) {}\n        \n        @Override\n        public void mouseEntered(MouseEvent e) {}\n        \n        @Override\n        public void mouseClicked(MouseEvent e) {\n          base.handleOpenExampleManager();\n          openExamplesManagerLabel.setForeground(new Color(85, 26, 139));\n        }\n      });\n      \n      final JTree tree = buildExamplesTree();\n      setupExamplesTree(tree);\n  \n      JScrollPane treePane = new JScrollPane(tree);\n      treePane.setPreferredSize(new Dimension(250, 300));\n      treePane.setBorder(new EmptyBorder(5, 0, 0, 0));\n      treePane.setOpaque(true);\n      treePane.setBackground(Color.WHITE);\n      treePane.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      JLabel contribExLabel = new JLabel(\"Contributed Examples\");\n      contribExLabel.setOpaque(false);\n      contribExLabel.setBorder(new EmptyBorder(10, 6, 1, 5));\n      contribExLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      final JTree tree2 = buildContributedExamplesTrees();\n      setupExamplesTree(tree2);\n      \n      JScrollPane treePane2 = new JScrollPane(tree2);\n      treePane2.setPreferredSize(new Dimension(250, 300));\n      treePane2.setBorder(new EmptyBorder(0, 0, 10, 0));\n      treePane2.setOpaque(true);\n      treePane2.setBackground(Color.WHITE);\n      treePane2.setAlignmentX(Component.LEFT_ALIGNMENT);\n      \n      examplesPanel.add(openExamplesManagerLabel);\n      examplesPanel.add(treePane);\n      examplesPanel.add(contribExLabel);\n      examplesPanel.add(treePane2);\n      examplesFrame.getContentPane().add(examplesPanel);\n      examplesFrame.pack();\n\n      restoreExpanded(tree);\n    }\n\n    // Space for the editor plus a li'l gap\n    int roughWidth = examplesFrame.getWidth() + 20;\n    Point p = null;\n    // If no window open, or the editor is at the edge of the screen\n    if (base.activeEditor == null ||\n        (p = base.activeEditor.getLocation()).x < roughWidth) {\n      // Center the window on the screen\n      examplesFrame.setLocationRelativeTo(null);\n    } else {\n      // Open the window relative to the editor\n      examplesFrame.setLocation(p.x - roughWidth, p.y);\n    }\n    examplesFrame.setVisible(true);\n  }","commit_id":"9e80a30e2d08d5061c95f7ee8307e5ff281abfcd","url":"https://github.com/processing/processing"},{"original_method":"public Mode(Base base, File folder) {\n    this.base = base;\n    this.folder = folder;\n    tokenMarker = createTokenMarker();\n\n    // Get paths for the libraries and examples in the mode folder\n    examplesFolder = new File(folder, \"examples\");\n    librariesFolder = new File(folder, \"libraries\");\n    referenceFolder = new File(folder, \"reference\");\n\n//    rebuildToolbarMenu();\n    rebuildLibraryList();\n//    rebuildExamplesMenu();\n    \n    try {\n      for (File file : getKeywordFiles()) {\n        loadKeywords(file);\n      }\n    } catch (IOException e) {\n      Base.showWarning(\"Problem loading keywords\",\n                       \"Could not load keywords file for \" + getTitle() + \" mode.\", e);\n    }\n  }","id":45956,"modified_method":"public Mode(Base base, File folder) {\n    this.base = base;\n    this.folder = folder;\n    tokenMarker = createTokenMarker();\n\n    // Get paths for the libraries and examples in the mode folder\n    examplesFolder = new File(folder, \"examples\");\n    librariesFolder = new File(folder, \"libraries\");\n    referenceFolder = new File(folder, \"reference\");\n    \n    // Get path to the contributed examples compatible with this mode\n    examplesContribFolder = Base.getSketchbookExamplesFolder();\n\n//    rebuildToolbarMenu();\n    rebuildLibraryList();\n//    rebuildExamplesMenu();\n    \n    try {\n      for (File file : getKeywordFiles()) {\n        loadKeywords(file);\n      }\n    } catch (IOException e) {\n      Base.showWarning(\"Problem loading keywords\",\n                       \"Could not load keywords file for \" + getTitle() + \" mode.\", e);\n    }\n  }","commit_id":"9e80a30e2d08d5061c95f7ee8307e5ff281abfcd","url":"https://github.com/processing/processing"},{"original_method":"/**\n     * Write test target in the writer depending the packaging of the project.\n     *\n     * @param writer\n     * @param testCompileSourceRoots\n     */\n    private void writeTestTargets( XMLWriter writer, List testCompileSourceRoots )\n        throws IOException\n    {\n        AntBuildWriterUtil.writeCommentText( writer, \"Run all tests\", 1 );\n\n        if ( AntBuildWriterUtil.isPomPackaging( project ) )\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test\" );\n            writer.addAttribute( \"description\", \"Run the test cases\" );\n            if ( project.getModules() != null )\n            {\n                for ( Iterator it = project.getModules().iterator(); it.hasNext(); )\n                {\n                    String moduleSubPath = (String) it.next();\n                    AntBuildWriterUtil.writeAntTask( writer, project, moduleSubPath, \"test\" );\n                }\n            }\n            writer.endElement(); // target\n        }\n        else\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"junit-present, compile-tests\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"if\", \"junit.present\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"description\", \"Run the test cases\", 2 );\n\n            if ( !testCompileSourceRoots.isEmpty() )\n            {\n                writer.startElement( \"mkdir\" );\n                writer.addAttribute( \"dir\", \"${maven.test.reports}\" );\n                writer.endElement(); //mkdir\n\n                writer.startElement( \"junit\" );\n                writer.addAttribute( \"printSummary\", \"yes\" );\n                writer.addAttribute( \"haltonerror\", \"true\" );\n                writer.addAttribute( \"haltonfailure\", \"true\" );\n                writer.addAttribute( \"fork\", \"true\" );\n                writer.addAttribute( \"dir\", \".\" );\n\n                writer.startElement( \"sysproperty\" );\n                writer.addAttribute( \"key\", \"basedir\" );\n                writer.addAttribute( \"value\", \".\" );\n                writer.endElement(); // sysproperty\n\n                writer.startElement( \"formatter\" );\n                writer.addAttribute( \"type\", \"xml\" );\n                writer.endElement(); // formatter\n\n                writer.startElement( \"formatter\" );\n                writer.addAttribute( \"type\", \"plain\" );\n                writer.addAttribute( \"usefile\", \"false\" );\n                writer.endElement(); // formatter\n\n                writer.startElement( \"classpath\" );\n                writer.startElement( \"path\" );\n                writer.addAttribute( \"refid\", \"build.test.classpath\" );\n                writer.endElement(); // path\n                writer.startElement( \"pathelement\" );\n                writer.addAttribute( \"location\", \"${maven.build.outputDir}\" );\n                writer.endElement(); // pathelement\n                writer.startElement( \"pathelement\" );\n                writer.addAttribute( \"location\", \"${maven.build.testOutputDir}\" );\n                writer.endElement(); // pathelement\n                writer.endElement(); // classpath\n\n                writer.startElement( \"batchtest\" );\n                writer.addAttribute( \"todir\", \"${maven.test.reports}\" );\n                writer.addAttribute( \"unless\", \"test\" );\n\n                List includes = getTestIncludes();\n                List excludes = getTestExcludes();\n\n                writeTestFilesets( writer, testCompileSourceRoots, includes, excludes );\n\n                writer.endElement(); // batchtest\n\n                writer.startElement( \"batchtest\" );\n                writer.addAttribute( \"todir\", \"${maven.test.reports}\" );\n                writer.addAttribute( \"if\", \"test\" );\n\n                includes = Arrays.asList( new String[] { \"**/${test}.java\" } );\n\n                writeTestFilesets( writer, testCompileSourceRoots, includes, excludes );\n\n                writer.endElement(); // batchtest\n\n                writer.endElement(); // junit\n            }\n            writer.endElement(); // target\n\n            AntBuildWriterUtil.writeLineBreak( writer, 2, 1 );\n\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test-junit-present\" );\n\n            writer.startElement( \"available\" );\n            writer.addAttribute( \"classname\", \"junit.framework.Test\" );\n            writer.addAttribute( \"property\", \"junit.present\" );\n            writer.endElement(); // available\n\n            writer.endElement(); // target\n\n            AntBuildWriterUtil.writeLineBreak( writer, 2, 1 );\n\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"junit-present\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"test-junit-present\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"unless\", \"junit.present\", 2 );\n\n            writer.startElement( \"echo\" );\n            writer.writeText( StringUtils.repeat( \"=\", 35 ) + \" WARNING \" + StringUtils.repeat( \"=\", 35 ) );\n            writer.endElement(); // echo\n\n            writer.startElement( \"echo\" );\n            writer.writeText( \" JUnit is not present in your $ANT_HOME/lib directory. Tests not executed.\" );\n            writer.endElement(); // echo\n\n            writer.startElement( \"echo\" );\n            writer.writeText( StringUtils.repeat( \"=\", 79 ) );\n            writer.endElement(); // echo\n\n            writer.endElement(); // target\n        }\n\n        AntBuildWriterUtil.writeLineBreak( writer );\n    }","id":45957,"modified_method":"/**\n     * Write test target in the writer depending the packaging of the project.\n     *\n     * @param writer\n     * @param testCompileSourceRoots\n     */\n    private void writeTestTargets( XMLWriter writer, List testCompileSourceRoots )\n        throws IOException\n    {\n        AntBuildWriterUtil.writeCommentText( writer, \"Run all tests\", 1 );\n\n        if ( AntBuildWriterUtil.isPomPackaging( project ) )\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test\" );\n            writer.addAttribute( \"description\", \"Run the test cases\" );\n            if ( project.getModules() != null )\n            {\n                for ( Iterator it = project.getModules().iterator(); it.hasNext(); )\n                {\n                    String moduleSubPath = (String) it.next();\n                    AntBuildWriterUtil.writeAntTask( writer, project, moduleSubPath, \"test\" );\n                }\n            }\n            writer.endElement(); // target\n        }\n        else\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"compile-tests, junit-missing\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"unless\", \"junit.skipped\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"description\", \"Run the test cases\", 2 );\n\n            if ( !testCompileSourceRoots.isEmpty() )\n            {\n                writer.startElement( \"mkdir\" );\n                writer.addAttribute( \"dir\", \"${maven.test.reports}\" );\n                writer.endElement(); // mkdir\n\n                writer.startElement( \"junit\" );\n                writer.addAttribute( \"printSummary\", \"yes\" );\n                writer.addAttribute( \"haltonerror\", \"true\" );\n                writer.addAttribute( \"haltonfailure\", \"true\" );\n                writer.addAttribute( \"fork\", \"true\" );\n                writer.addAttribute( \"dir\", \".\" );\n\n                writer.startElement( \"sysproperty\" );\n                writer.addAttribute( \"key\", \"basedir\" );\n                writer.addAttribute( \"value\", \".\" );\n                writer.endElement(); // sysproperty\n\n                writer.startElement( \"formatter\" );\n                writer.addAttribute( \"type\", \"xml\" );\n                writer.endElement(); // formatter\n\n                writer.startElement( \"formatter\" );\n                writer.addAttribute( \"type\", \"plain\" );\n                writer.addAttribute( \"usefile\", \"false\" );\n                writer.endElement(); // formatter\n\n                writer.startElement( \"classpath\" );\n                writer.startElement( \"path\" );\n                writer.addAttribute( \"refid\", \"build.test.classpath\" );\n                writer.endElement(); // path\n                writer.startElement( \"pathelement\" );\n                writer.addAttribute( \"location\", \"${maven.build.outputDir}\" );\n                writer.endElement(); // pathelement\n                writer.startElement( \"pathelement\" );\n                writer.addAttribute( \"location\", \"${maven.build.testOutputDir}\" );\n                writer.endElement(); // pathelement\n                writer.endElement(); // classpath\n\n                writer.startElement( \"batchtest\" );\n                writer.addAttribute( \"todir\", \"${maven.test.reports}\" );\n                writer.addAttribute( \"unless\", \"test\" );\n\n                List includes = getTestIncludes();\n                List excludes = getTestExcludes();\n\n                writeTestFilesets( writer, testCompileSourceRoots, includes, excludes );\n\n                writer.endElement(); // batchtest\n\n                writer.startElement( \"batchtest\" );\n                writer.addAttribute( \"todir\", \"${maven.test.reports}\" );\n                writer.addAttribute( \"if\", \"test\" );\n\n                includes = Arrays.asList( new String[] { \"**/${test}.java\" } );\n\n                writeTestFilesets( writer, testCompileSourceRoots, includes, excludes );\n\n                writer.endElement(); // batchtest\n\n                writer.endElement(); // junit\n            }\n            writer.endElement(); // target\n\n            AntBuildWriterUtil.writeLineBreak( writer, 2, 1 );\n\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test-junit-present\" );\n\n            writer.startElement( \"available\" );\n            writer.addAttribute( \"classname\", \"junit.framework.Test\" );\n            writer.addAttribute( \"property\", \"junit.present\" );\n            writer.endElement(); // available\n\n            writer.endElement(); // target\n\n            AntBuildWriterUtil.writeLineBreak( writer, 2, 1 );\n\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"test-junit-status\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"test-junit-present\", 2 );\n            writer.startElement( \"condition\" );\n            writer.addAttribute( \"property\", \"junit.missing\" );\n            writer.startElement( \"and\" );\n            writer.startElement( \"isfalse\" );\n            writer.addAttribute( \"value\", \"${junit.present}\" );\n            writer.endElement(); // isfalse\n            writer.startElement( \"isfalse\" );\n            writer.addAttribute( \"value\", \"${maven.test.skip}\" );\n            writer.endElement(); // isfalse\n            writer.endElement(); // and\n            writer.endElement(); // condition\n            writer.startElement( \"condition\" );\n            writer.addAttribute( \"property\", \"junit.skipped\" );\n            writer.startElement( \"or\" );\n            writer.startElement( \"isfalse\" );\n            writer.addAttribute( \"value\", \"${junit.present}\" );\n            writer.endElement(); // isfalse\n            writer.startElement( \"istrue\" );\n            writer.addAttribute( \"value\", \"${maven.test.skip}\" );\n            writer.endElement(); // istrue\n            writer.endElement(); // or\n            writer.endElement(); // condition\n            writer.endElement(); // target\n\n            AntBuildWriterUtil.writeLineBreak( writer, 2, 1 );\n\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"junit-missing\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"test-junit-status\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"if\", \"junit.missing\", 2 );\n\n            writer.startElement( \"echo\" );\n            writer.writeText( StringUtils.repeat( \"=\", 35 ) + \" WARNING \" + StringUtils.repeat( \"=\", 35 ) );\n            writer.endElement(); // echo\n\n            writer.startElement( \"echo\" );\n            writer.writeText( \" JUnit is not present in your $ANT_HOME/lib directory. Tests not executed.\" );\n            writer.endElement(); // echo\n\n            writer.startElement( \"echo\" );\n            writer.writeText( StringUtils.repeat( \"=\", 79 ) );\n            writer.endElement(); // echo\n\n            writer.endElement(); // target\n        }\n\n        AntBuildWriterUtil.writeLineBreak( writer );\n    }","commit_id":"7000377acaee41a149f8234822d42b69239c955f","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write compile-test target in the writer depending the packaging of the project.\n     *\n     * @param writer\n     * @param testCompileSourceRoots\n     * @throws IOException if any\n     */\n    private void writeCompileTestsTarget( XMLWriter writer, List testCompileSourceRoots )\n        throws IOException\n    {\n        AntBuildWriterUtil.writeCommentText( writer, \"Test-compilation target\", 1 );\n\n        if ( AntBuildWriterUtil.isPomPackaging( project ) )\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"compile-tests\" );\n            writer.addAttribute( \"description\", \"Compile the test code\" );\n            if ( project.getModules() != null )\n            {\n                for ( Iterator it = project.getModules().iterator(); it.hasNext(); )\n                {\n                    String moduleSubPath = (String) it.next();\n                    AntBuildWriterUtil.writeAntTask( writer, project, moduleSubPath, \"compile-tests\" );\n                }\n            }\n            writer.endElement(); // target\n        }\n        else\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"compile-tests\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"junit-present, compile\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"description\", \"Compile the test code\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"if\", \"junit.present\", 2 );\n\n            writeCompileTasks( writer, project.getBasedir(), \"${maven.build.testOutputDir}\", testCompileSourceRoots,\n                               project.getBuild().getTestResources(), \"${maven.build.outputDir}\", true );\n\n            writer.endElement(); // target\n        }\n\n        AntBuildWriterUtil.writeLineBreak( writer );\n    }","id":45958,"modified_method":"/**\n     * Write compile-test target in the writer depending the packaging of the project.\n     *\n     * @param writer\n     * @param testCompileSourceRoots\n     * @throws IOException if any\n     */\n    private void writeCompileTestsTarget( XMLWriter writer, List testCompileSourceRoots )\n        throws IOException\n    {\n        AntBuildWriterUtil.writeCommentText( writer, \"Test-compilation target\", 1 );\n\n        if ( AntBuildWriterUtil.isPomPackaging( project ) )\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"compile-tests\" );\n            writer.addAttribute( \"description\", \"Compile the test code\" );\n            if ( project.getModules() != null )\n            {\n                for ( Iterator it = project.getModules().iterator(); it.hasNext(); )\n                {\n                    String moduleSubPath = (String) it.next();\n                    AntBuildWriterUtil.writeAntTask( writer, project, moduleSubPath, \"compile-tests\" );\n                }\n            }\n            writer.endElement(); // target\n        }\n        else\n        {\n            writer.startElement( \"target\" );\n            writer.addAttribute( \"name\", \"compile-tests\" );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"depends\", \"compile\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"description\", \"Compile the test code\", 2 );\n            AntBuildWriterUtil.addWrapAttribute( writer, \"target\", \"unless\", \"maven.test.skip\", 2 );\n\n            writeCompileTasks( writer, project.getBasedir(), \"${maven.build.testOutputDir}\", testCompileSourceRoots,\n                               project.getBuild().getTestResources(), \"${maven.build.outputDir}\", true );\n\n            writer.endElement(); // target\n        }\n\n        AntBuildWriterUtil.writeLineBreak( writer );\n    }","commit_id":"7000377acaee41a149f8234822d42b69239c955f","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method to write XML Ant war task\n     *\n     * @param writer not null\n     * @param project not null\n     * @param localRepository not null\n     * @throws IOException if any\n     */\n    public static void writeWarTask( XMLWriter writer, MavenProject project, File localRepository )\n        throws IOException\n    {\n        writeCopyLib( writer, project, \"${maven.build.dir}/${maven.build.finalName}/WEB-INF/lib\" );\n\n        writer.startElement( \"war\" );\n        writer.addAttribute( \"destfile\", \"${maven.build.dir}/${maven.build.finalName}.war\" );\n        addWrapAttribute( writer, \"war\", \"basedir\", \"${maven.build.outputDir}\", 3 );\n        addWrapAttribute( writer, \"war\", \"compress\",\n                          getMavenWarPluginBasicOption( project, \"archive//compress\", \"true\" ), 3 );\n        if ( getMavenWarPluginBasicOption( project, \"webXml\", null ) != null )\n        {\n            addWrapAttribute( writer, \"war\", \"webxml\", getMavenWarPluginBasicOption( project, \"webXml\", null ), 3 );\n        }\n        else\n        {\n            // Default\n            addWrapAttribute( writer, \"war\", \"webxml\", \"${basedir}/src/main/webapp/WEB-INF/web.xml\", 3 );\n        }\n        if ( getMavenWarPluginBasicOption( project, \"manifestFile\", null ) != null )\n        {\n            addWrapAttribute( writer, \"war\", \"manifest\", getMavenWarPluginBasicOption( project, \"manifestFile\", null ),\n                              3 );\n        }\n        writer.startElement( \"lib\" );\n        writer.addAttribute( \"dir\", \"${maven.build.dir}/${maven.build.finalName}/WEB-INF/lib\" );\n        writer.endElement(); // lib\n        writer.startElement( \"classes\" );\n        writer.addAttribute( \"dir\", \"${maven.build.outputDir}\" );\n        writer.endElement(); // classes\n        writer.startElement( \"webinf\" );\n        writer.addAttribute( \"dir\", \"${basedir}/src/main/webapp/WEB-INF\" );\n        addWrapAttribute( writer, \"webinf\", \"excludes\", \"web.xml\", 4 );\n        writer.endElement(); // webinf\n        writer.startElement( \"fileset\" );\n        writer.addAttribute( \"dir\", \"${basedir}/src/main/webapp\" );\n        writer.endElement(); // fileset\n        writer.endElement(); // war\n    }","id":45959,"modified_method":"/**\n     * Convenience method to write XML Ant war task\n     *\n     * @param writer not null\n     * @param project not null\n     * @param localRepository not null\n     * @throws IOException if any\n     */\n    public static void writeWarTask( XMLWriter writer, MavenProject project, File localRepository )\n        throws IOException\n    {\n        String webXml =\n            getMavenWarPluginBasicOption( project, \"webXml\", \"${basedir}/src/main/webapp/WEB-INF/web.xml\" );\n        if ( webXml.startsWith( \"${basedir}/\" ) )\n        {\n            webXml = webXml.substring( \"${basedir}/\".length() );\n        }\n        \n        writeCopyLib( writer, project, \"${maven.build.dir}/${maven.build.finalName}/WEB-INF/lib\" );\n\n        writer.startElement( \"war\" );\n        writer.addAttribute( \"destfile\", \"${maven.build.dir}/${maven.build.finalName}.war\" );\n        addWrapAttribute( writer, \"war\", \"compress\",\n                          getMavenWarPluginBasicOption( project, \"archive//compress\", \"true\" ), 3 );\n        addWrapAttribute( writer, \"war\", \"webxml\", webXml, 3 );\n        if ( getMavenWarPluginBasicOption( project, \"manifestFile\", null ) != null )\n        {\n            addWrapAttribute( writer, \"war\", \"manifest\", getMavenWarPluginBasicOption( project, \"manifestFile\", null ),\n                              3 );\n        }\n        writer.startElement( \"lib\" );\n        writer.addAttribute( \"dir\", \"${maven.build.dir}/${maven.build.finalName}/WEB-INF/lib\" );\n        writer.endElement(); // lib\n        writer.startElement( \"classes\" );\n        writer.addAttribute( \"dir\", \"${maven.build.outputDir}\" );\n        writer.endElement(); // classes\n        writer.startElement( \"fileset\" );\n        writer.addAttribute( \"dir\", \"src/main/webapp\" );\n        addWrapAttribute( writer, \"fileset\", \"excludes\", \"WEB-INF/web.xml\", 4 );\n        writer.endElement(); // fileset\n        writer.endElement(); // war\n    }","commit_id":"86bab3a0e5266e3fa0c7e6e93f4a3c6c182f180b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** Pre-processes the mail before it gets sent.\n        @see ERMailDelivery#prepareMail */\n    protected DataHandler prepareMail () throws MessagingException {\n        MimeMultipart multipart = null;\n        MimeBodyPart textPart = null;\n        MimeBodyPart htmlPart = null;\n\n\tthis.mimeMessage ().setSentDate (new Date ());\n\tmultipart = new MimeMultipart (\"alternative\");\n\t\t\n\t// set the plain text part\n\tif (_hasHiddenPlainTextContent) {\n\t    textPart = new MimeBodyPart ();\n\t    textPart.setText (_hiddenPlainTextContent, charset());\n\t    multipart.addBodyPart (textPart);\n\t}\n\n\t// create and fill the html message part\n\thtmlPart = new MimeBodyPart ();\n\n\t// Set the content of the html part\n\thtmlPart.setContent (this.htmlContent (), \"text/html; charset=\\\"\"  + charset () + \"\\\"\");\n\n\tmultipart.addBodyPart (htmlPart);\n\n\t// Inline attachements\n\tif (this.inlineAttachments ().count () > 0) {\n\t    // Create a \"related\" MimeMultipart\n\t    MimeMultipart relatedMultiparts = new MimeMultipart (\"related\");\n\t\t\t\n\t    // add each inline attachments to the message\n\t    Enumeration en = this.inlineAttachments ().objectEnumerator ();\n\t    while (en.hasMoreElements ()) {\n\t\tERMailAttachment attachment = (ERMailAttachment)en.nextElement ();\n\t\tBodyPart bp = attachment.getBodyPart ();\n\t\trelatedMultiparts.addBodyPart (bp);\n\t    }\n\t    \n\t    // Add this multipart to the main multipart as a compound BodyPart\n\t    BodyPart relatedAttachmentsBodyPart = new MimeBodyPart ();\n\t    relatedAttachmentsBodyPart.setDataHandler (new DataHandler (relatedMultiparts, relatedMultiparts.getContentType ()));\n\t    multipart.addBodyPart (relatedAttachmentsBodyPart);\n\t}\n\n        return new DataHandler (multipart, multipart.getContentType ());\n    }","id":45960,"modified_method":"/** Pre-processes the mail before it gets sent.\n        @see ERMailDelivery#prepareMail */\n    protected DataHandler prepareMail () throws MessagingException {\n        MimeMultipart multipart = null;\n        MimeBodyPart textPart = null;\n        MimeBodyPart htmlPart = null;\n\n\tthis.mimeMessage ().setSentDate (new Date ());\n\tmultipart = new MimeMultipart (\"alternative\");\n\t\t\n\t// set the plain text part\n\tif (_hasHiddenPlainTextContent) {\n\t    textPart = new MimeBodyPart ();\n\t    textPart.setText (_hiddenPlainTextContent, charset());\n\t    multipart.addBodyPart (textPart);\n\t}\n\n\t// create and fill the html message part\n\thtmlPart = new MimeBodyPart ();\n\n\t// Set the content of the html part\n\thtmlPart.setContent (this.htmlContent (), \"text/html; charset=\\\"\"  + charset () + \"\\\"\");\n\n    // Inline attachements\n    if (inlineAttachments().count() == 0) {\n        multipart.addBodyPart(htmlPart);\n    } else {\n        // Create a \"related\" MimeMultipart\n        MimeMultipart relatedMultiparts = new MimeMultipart(\"related\");\n        relatedMultiparts.addBodyPart(htmlPart);\n        \n        // add each inline attachments to the message\n        Enumeration en = this.inlineAttachments ().objectEnumerator ();\n        while (en.hasMoreElements ()) {\n        ERMailAttachment attachment = (ERMailAttachment)en.nextElement ();\n        BodyPart bp = attachment.getBodyPart();\n        relatedMultiparts.addBodyPart(bp);\n        }\n\n        // Add this multipart to the main multipart as a compound BodyPart\n        BodyPart relatedAttachmentsBodyPart = new MimeBodyPart();\n\t    relatedAttachmentsBodyPart.setDataHandler (new DataHandler (relatedMultiparts, relatedMultiparts.getContentType ()));\n        multipart.addBodyPart(relatedAttachmentsBodyPart);\n    }\n\n        return new DataHandler (multipart, multipart.getContentType ());\n    }","commit_id":"c595fbf44bafc98ba680e2db6c26326d664c7c3f","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * @return Multipart part of the email, define the html as a multipart/related in case there are images\n     */\n    private MimeMultipart createRelatedBodyPart(String content, List<Attachment> embeddedImages)\n            throws MessagingException\n    {\n        MimeMultipart htmlMultipart = new MimeMultipart(\"related\");\n\n        htmlMultipart.addBodyPart(createRelatedHtmlPart(content));\n\n        // Add the images to the HTML multipart\n        addAttachments(htmlMultipart, embeddedImages);\n        return htmlMultipart;\n    }","id":45961,"modified_method":"private MimeMultipart createHTMLMultipart(String content, List<Attachment> embeddedImages)\n        throws MessagingException\n    {\n        MimeMultipart htmlMultipart = new MimeMultipart(\"related\");\n        htmlMultipart.addBodyPart(createHTMLBodyPart(content, true));\n        handleAttachments(htmlMultipart, embeddedImages);\n        return htmlMultipart;\n    }","commit_id":"b82e133508581e0bbfe590d00d85e7816cd10029","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override public MimeBodyPart create(String content, Map<String, Object> parameters) throws MessagingException\n    {\n\n        MimeMultipart multipart = new MimeMultipart(\"mixed\");\n\n        List<Attachment> attachments = (List<Attachment>) parameters.<String, Object>get(\"attachments\");\n        List<Attachment> embeddedImages = new ArrayList<>();\n\n        MimeBodyPart htmlBodyPart = new MimeBodyPart();\n\n        if (attachments != null) {\n            // separate attachment and embedded images\n            Map<String, List> attachmentsMap = handleAttachments(content, attachments);\n\n            embeddedImages = attachmentsMap.get(\"embeddedImages\");\n            attachments = attachmentsMap.get(\"attachments\");\n\n            htmlBodyPart.setContent(createRelatedBodyPart(content, embeddedImages));\n        } else {\n            // Create the HTML body part of the email\n            htmlBodyPart.setContent(content, \"text/plain; charset=\" + StandardCharsets.UTF_8.name());\n            htmlBodyPart.setHeader(\"Content-Type\", \"text/html\");\n        }\n\n        //\n        String alternaniveText = (String) parameters.get(\"alternate\");\n        if (alternaniveText != null) {\n            multipart.addBodyPart(createAlternativePart(htmlBodyPart, defaultPartFactory.create(alternaniveText)));\n        } else {\n            multipart.addBodyPart(htmlBodyPart);\n        }\n        addAttachments(multipart, attachments);\n\n        MimeBodyPart bodyPart = new MimeBodyPart();\n        bodyPart.setContent(multipart);\n\n        // Handle headers passed as parameter\n        addHeaders(bodyPart, parameters);\n        return bodyPart;\n    }","id":45962,"modified_method":"@Override\n    public MimeBodyPart create(String content, Map<String, Object> parameters) throws MessagingException\n    {\n        MimeBodyPart resultBodyPart;\n\n        // Separate normal attachment from embedded image attachments\n        List<Attachment> allAttachments = (List<Attachment>) parameters.get(\"attachments\");\n        Pair<List<Attachment>, List<Attachment>> attachmentPairs = separateAttachments(content, allAttachments);\n        List<Attachment> embeddedImageAttachments = attachmentPairs.getLeft();\n        List<Attachment> normalAttachments = attachmentPairs.getRight();\n\n        // Step 1: Handle the HTML section of the mail.\n        MimeBodyPart htmlBodyPart;\n        if (!embeddedImageAttachments.isEmpty()) {\n            htmlBodyPart = new MimeBodyPart();\n            htmlBodyPart.setContent(createHTMLMultipart(content, embeddedImageAttachments));\n        } else {\n            // Create the HTML body part of the email\n            htmlBodyPart = createHTMLBodyPart(content, false);\n        }\n\n        // Step 2: Handle the optional alternative text\n        String alternativeText = (String) parameters.get(\"alternate\");\n        if (alternativeText != null) {\n            resultBodyPart = createAlternativePart(htmlBodyPart, this.defaultPartFactory.create(alternativeText));\n        } else {\n            // No alternative text, just add the HTML body part to the Multipart\n            resultBodyPart = htmlBodyPart;\n        }\n\n        // Step 3 Add the normal attachments (if any). Any embedded images have already been handled in the HTML body\n        // part. Note: If there are attachments we need to wrap our body part inside a \"mixed\" Multipart.\n        if (!normalAttachments.isEmpty()) {\n            MimeMultipart multipart = new MimeMultipart(\"mixed\");\n            multipart.addBodyPart(resultBodyPart);\n            handleAttachments(multipart, normalAttachments);\n            resultBodyPart = new MimeBodyPart();\n            resultBodyPart.setContent(multipart);\n        }\n\n        // Handle headers passed as parameter\n        addHeaders(resultBodyPart, parameters);\n\n        return resultBodyPart;\n    }","commit_id":"b82e133508581e0bbfe590d00d85e7816cd10029","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void addAttachments(MimeMultipart multipart, List<Attachment> attachments) throws MessagingException\n    {\n        // Add attachments part to multipart\n        if (attachments != null) {\n            for (Attachment attachment : attachments) {\n                multipart.addBodyPart(attachmentPartFactory.create(attachment));\n            }\n        }\n    }","id":45963,"modified_method":"private void handleAttachments(MimeMultipart multipart, List<Attachment> attachments) throws MessagingException\n    {\n        for (Attachment attachment : attachments) {\n            multipart.addBodyPart(this.attachmentPartFactory.create(attachment));\n        }\n    }","commit_id":"b82e133508581e0bbfe590d00d85e7816cd10029","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Separate embedded images from attachments list\n     */\n    private Map<String, List> handleAttachments(String content, List<Attachment> attachments)\n    {\n        List<Attachment> embeddedImages = new ArrayList<>();\n\n        // Find images used with src=\"cid:\" in the email HTML part\n        Matcher matcher = CID_PATTERN.matcher(content);\n        List<String> foundEmbeddedImages = new ArrayList<String>();\n        while (matcher.find()) {\n            foundEmbeddedImages.add(matcher.group(2));\n        }\n\n        // Loop over the attachments of the email, add images used from the HTML to the list of attachments to be\n        // embedded with the HTML part, add the other attachements to the list of attachments to be attached to the\n        // email.\n        for (Attachment attachment : attachments) {\n            if (foundEmbeddedImages.contains(attachment.getFilename())) {\n                embeddedImages.add(attachment);\n                attachments.remove(attachment);\n            }\n        }\n\n        Map<String, List> attachmentsMap = new HashMap<>();\n\n        attachmentsMap.put(\"attachments\", attachments);\n        attachmentsMap.put(\"embeddedImages\", embeddedImages);\n\n        return attachmentsMap;\n    }","id":45964,"modified_method":"/**\n     * Separate embedded images from attachments list\n     *\n     * @return the embedded attachments on the left and the normal attachments on the right of the Pair\n     */\n    private Pair<List<Attachment>, List<Attachment>> separateAttachments(String content, List<Attachment> attachments)\n    {\n        if (attachments == null) {\n            return new ImmutablePair<>(Collections.<Attachment>emptyList(), Collections.<Attachment>emptyList());\n        }\n\n        // Copy all attachments in the list of attachments to add to the email. We'll then remove the attachments\n        // that are embedded from the list below.\n        List<Attachment> normalAttachments = new ArrayList<>(attachments);\n\n        // Find images used with src=\"cid:\" in the email HTML part\n        Matcher matcher = CID_PATTERN.matcher(content);\n        List<String> embeddedImageNames = new ArrayList<>();\n        while (matcher.find()) {\n            embeddedImageNames.add(matcher.group(2));\n        }\n\n        // Loop over the attachments of the email, add images used from the HTML to the list of attachments to be\n        // embedded with the HTML part, add the other attachments to the list of attachments to be attached to the\n        // email.\n        List<Attachment> embeddedImageAttachments = new ArrayList<>();\n        for (Attachment attachment : attachments) {\n            if (embeddedImageNames.contains(attachment.getFilename())) {\n                embeddedImageAttachments.add(attachment);\n                normalAttachments.remove(attachment);\n            }\n        }\n\n        return new ImmutablePair<>(embeddedImageAttachments, normalAttachments);\n    }","commit_id":"b82e133508581e0bbfe590d00d85e7816cd10029","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getRawContent(MimeBodyPart htmlBodyPart) throws IOException, MessagingException\n    {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        htmlBodyPart.writeTo(baos);\n        baos.close();\n        return baos.toString();\n    }","id":45965,"modified_method":"private String getRawContent(MimeBodyPart htmlBodyPart) throws Exception\n    {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        htmlBodyPart.writeTo(baos);\n        baos.close();\n        return baos.toString();\n    }","commit_id":"b82e133508581e0bbfe590d00d85e7816cd10029","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void start(org.orbeon.oxf.pipeline.api.PipelineContext context) {\n        try {\n            Document dataDocument = readInputAsDOM4J(context, INPUT_DATA);\n            Element messageElement = dataDocument.getRootElement();\n\n            // Create message\n            Properties properties = new Properties();\n            String propHost = getPropertySet().getString(EMAIL_HOST);\n            // SMTP Host from OXFProperties override the local configuration\n            if (propHost != null)\n                properties.setProperty(\"mail.smtp.host\", propHost);\n            else {\n                String host = messageElement.element(\"smtp-host\").getTextTrim();\n                if (host != null)\n                    properties.setProperty(\"mail.smtp.host\", host);\n            }\n            Session session = Session.getInstance(properties);\n            Message message = new MimeMessage(session);\n\n            // Set from/to\n            message.setFrom(createAddress(messageElement.element(\"from\")));\n            for (Iterator i = messageElement.elements(\"to\").iterator(); i.hasNext();) {\n                Element toElement = (Element) i.next();\n                InternetAddress address = createAddress(toElement);\n                String forceToEMail = getPropertySet().getString(EMAIL_FORCE_TO);\n                if (forceToEMail != null)\n                    address.setAddress(forceToEMail);\n                message.addRecipient(Message.RecipientType.TO, address);\n            }\n\n            // Set subject\n            message.setSubject(messageElement.element(\"subject\").getStringValue());\n\n            Element textElement = messageElement.element(\"text\");\n            Element bodyElement = messageElement.element(\"body\");\n            // simple body\n            if(textElement != null)\n                message.setText(textElement.getStringValue());\n            else if(bodyElement != null){\n                // MIME parts\n                String multipart = bodyElement.attributeValue(\"mime-multipart\");\n                if(multipart ==null)\n                    multipart = DEFAULT_MULTIPART;\n                MimeMultipart mimeMultipart = new MimeMultipart(multipart);\n                for(Iterator i = bodyElement.elementIterator(\"part\"); i.hasNext();) {\n                    Element partElement = (Element)i.next();\n                    String name = partElement.attributeValue(\"name\");\n                    String contentType = partElement.attributeValue(\"content-type\");\n\n                    final String content;\n                    if (\"text/html\".equals(contentType)) {\n                        if (partElement.elements().size() != 1)\n                            throw new ValidationException(\"<part> must contain one element\",\n                                    (LocationData) partElement.getData());\n                        final StringWriter writer;\n                        {\n                            writer = new StringWriter();\n                            TransformerHandler identity = TransformerUtils.getIdentityTransformerHandler();\n                            identity.getTransformer().setOutputProperty(OutputKeys.METHOD, \"html\");\n                            identity.setResult(new StreamResult(writer));\n                            LocationSAXWriter saxw = new LocationSAXWriter();\n                            saxw.setContentHandler(identity);\n                            Document partDocument = DocumentHelper.createDocument();\n                            partDocument.setRootElement((Element) Dom4jUtils.cloneNode((Element) partElement.elements().get(0)));\n                            saxw.write(partDocument);\n                        }\n                        content = writer.toString();\n                    } else {\n                        content = partElement.getStringValue();\n                    }\n\n                    MimeBodyPart part = new MimeBodyPart();\n                    part.setDataHandler(new DataHandler(new SimpleDataSource(name, contentType, content)));\n                    mimeMultipart.addBodyPart(part);\n                }\n                message.setContent(mimeMultipart);\n            } else {\n                throw new OXFException(\"text or body element not found\");\n            }\n\n            // Send message\n            Transport transport = session.getTransport(\"smtp\");\n            Transport.send(message);\n            transport.close();\n        } catch (MessagingException e) {\n            throw new OXFException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OXFException(e);\n        } catch (SAXException e) {\n            throw new OXFException(e);\n        }\n    }","id":45966,"modified_method":"public void start(org.orbeon.oxf.pipeline.api.PipelineContext context) {\n        try {\n            Document dataDocument = readInputAsDOM4J(context, INPUT_DATA);\n            Element messageElement = dataDocument.getRootElement();\n\n            // Create message\n            Properties properties = new Properties();\n            String propHost = getPropertySet().getString(EMAIL_HOST);\n            // SMTP Host from OXFProperties override the local configuration\n            if (propHost != null)\n                properties.setProperty(\"mail.smtp.host\", propHost);\n            else {\n                String host = messageElement.element(\"smtp-host\").getTextTrim();\n                if (host != null)\n                    properties.setProperty(\"mail.smtp.host\", host);\n            }\n            Session session = Session.getInstance(properties);\n            Message message = new MimeMessage(session);\n\n            // Set from/to\n            message.setFrom(createAddress(messageElement.element(\"from\")));\n            for (Iterator i = messageElement.elements(\"to\").iterator(); i.hasNext();) {\n                Element toElement = (Element) i.next();\n                InternetAddress address = createAddress(toElement);\n                String forceToEMail = getPropertySet().getString(EMAIL_FORCE_TO);\n                if (forceToEMail != null)\n                    address.setAddress(forceToEMail);\n                message.addRecipient(Message.RecipientType.TO, address);\n            }\n\n            // Set subject\n            message.setSubject(messageElement.element(\"subject\").getStringValue());\n\n            Element textElement = messageElement.element(\"text\");\n            Element bodyElement = messageElement.element(\"body\");\n            // simple body\n            if (textElement != null)\n                message.setText(textElement.getStringValue());\n            else if (bodyElement != null) {\n                // MIME parts\n                String multipart = bodyElement.attributeValue(\"mime-multipart\");\n                if (multipart == null)\n                    multipart = DEFAULT_MULTIPART;\n                MimeMultipart mimeMultipart = new MimeMultipart(multipart);\n                for (Iterator i = bodyElement.elementIterator(\"part\"); i.hasNext();) {\n                    Element partElement = (Element) i.next();\n                    String name = partElement.attributeValue(\"name\");\n                    String contentType = partElement.attributeValue(\"content-type\");\n\n                    final String content;\n                    if (\"text/html\".equals(contentType)) {\n                        if (partElement.elements().size() != 1)\n                            throw new ValidationException(\"<part> must contain one element\",\n                                    (LocationData) partElement.getData());\n                        final StringWriter writer;\n                        {\n                            writer = new StringWriter();\n                            TransformerHandler identity = TransformerUtils.getIdentityTransformerHandler();\n                            identity.getTransformer().setOutputProperty(OutputKeys.METHOD, \"html\");\n                            identity.setResult(new StreamResult(writer));\n                            LocationSAXWriter saxw = new LocationSAXWriter();\n                            saxw.setContentHandler(identity);\n                            Document partDocument = DocumentHelper.createDocument();\n                            partDocument.setRootElement((Element) Dom4jUtils.cloneNode((Element) partElement.elements().get(0)));\n                            saxw.write(partDocument);\n                        }\n                        content = writer.toString();\n                    } else {\n                        content = partElement.getStringValue();\n                    }\n\n                    MimeBodyPart part = new MimeBodyPart();\n                    if (contentType != null && !contentType.startsWith(\"text/\")) {\n                        // This is not text content\n                        byte[] data = XMLUtils.base64StringToByteArray(content);\n                        part.setDataHandler(new DataHandler(new SimpleBinaryDataSource(name, contentType, data)));\n                        mimeMultipart.addBodyPart(part);\n                    } else {\n                        // This is text content\n                        part.setDataHandler(new DataHandler(new SimpleTextDataSource(name, contentType, content)));\n                        mimeMultipart.addBodyPart(part);\n                    }\n\n                    // Set content-disposition header\n                    String contentDisposition = partElement.attributeValue(\"content-disposition\");\n                    if (contentDisposition != null)\n                        part.setDisposition(contentDisposition);\n                }\n                message.setContent(mimeMultipart);\n            } else {\n                throw new OXFException(\"text or body element not found\");\n            }\n\n            // Send message\n            Transport transport = session.getTransport(\"smtp\");\n            Transport.send(message);\n            transport.close();\n        } catch (MessagingException e) {\n            throw new OXFException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OXFException(e);\n        } catch (SAXException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"c827ce1c8e19f9122b384cf10066b805267ced34","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void respondToModalDialog(final WebDriver driver, \n                                           String response) {\n      // Wait for the dialog to appear\n      WebElement dialog = (new WebDriverWait(driver, 2))\n        .until(ExpectedConditions.presenceOfElementLocated(\n              By.className(\"gwt-DialogBox-ModalDialog\")));\n      \n      // Find the button requested and invoke it\n      List<WebElement> buttons = \n            dialog.findElements(By.className(\"gwt-Button-DialogAction\"));\n      for (WebElement button: buttons) {\n         if (button.getText().equals(response)) {\n            button.click();\n            break;\n         }\n      }\n      \n      // Wait for the dialog to disappear\n      (new WebDriverWait(driver, 5)).until(new ExpectedCondition<Boolean>() {\n         public Boolean apply(WebDriver d) {\n            List<WebElement>elements = driver.findElements(By.className(\n                  \"gwt-DialogBox-ModalDialog\"));\n            return elements.size() == 0;\n         }\n      });\n   }","id":45967,"modified_method":"public static void respondToModalDialog(WebDriver driver, \n                                           String response) {\n      WebElement dialog = waitForModalToAppear(driver);\n      \n      // Find the button requested and invoke it\n      List<WebElement> buttons = \n            dialog.findElements(By.className(\"gwt-Button-DialogAction\"));\n      for (WebElement button: buttons) {\n         if (button.getText().equals(response)) {\n            button.click();\n            break;\n         }\n      }\n      \n      (new WebDriverWait(driver, 5)).until(\n            ExpectedConditions.stalenessOf(dialog));\n   }","commit_id":"283c74625d00b182ff022bc10aa0f4152acb0f3c","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Test\n   public void testPlotGeneration() {\n      ConsoleTestUtils.resumeConsoleInteraction(driver_);\n\n      Actions plotCars = new Actions(driver_);\n      plotCars.sendKeys(Keys.ESCAPE + \"plot(cars)\" + Keys.ENTER);\n      plotCars.perform();\n      \n      // Wait for the Plot window to activate\n      final WebElement plotWindow = (new WebDriverWait(driver_, 5))\n        .until(ExpectedConditions.presenceOfElementLocated(\n              By.id(ElementIds.getElementId(ElementIds.PLOT_IMAGE_FRAME))));\n      \n      // Wait for a plot to appear in the window\n      Assert.assertEquals(plotWindow.getTagName(), \"iframe\");\n      driver_.switchTo().frame(plotWindow);\n\n      WebElement plotImg = (new WebDriverWait(driver_, 5))\n        .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\"img\")));\n      \n      // Switch back to document context\n      driver_.switchTo().defaultContent();\n   }","id":45968,"modified_method":"@Test\n   public void testPlotGeneration() {\n      ConsoleTestUtils.resumeConsoleInteraction(driver_);\n\n      Actions plotCars = new Actions(driver_);\n      plotCars.sendKeys(Keys.ESCAPE + \"plot(cars)\" + Keys.ENTER);\n      plotCars.perform();\n      \n      // Wait for the Plot window to activate\n      final WebElement plotWindow = (new WebDriverWait(driver_, 5))\n        .until(ExpectedConditions.presenceOfElementLocated(\n              By.id(ElementIds.getElementId(ElementIds.PLOT_IMAGE_FRAME))));\n      \n      // Wait for a plot to appear in the window\n      Assert.assertEquals(plotWindow.getTagName(), \"iframe\");\n      driver_.switchTo().frame(plotWindow);\n\n      (new WebDriverWait(driver_, 5))\n        .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\"img\")));\n      \n      // Switch back to document context\n      driver_.switchTo().defaultContent();\n   }","commit_id":"283c74625d00b182ff022bc10aa0f4152acb0f3c","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\n     * In some cases, Vaadin doesn't register our clicks,\n     * so this method keeps click until the given element\n     * is no longer found.\n     *\n     * @param by selector\n     */\n    private void clickElementUntilItDisappears(By by) {\n        // click once to make sure the element *ever* existed\n        waitForElement(by).click();\n\n        try {\n            setImplicitWait(100, TimeUnit.MILLISECONDS);\n            wait.until(new ExpectedCondition<Boolean>() {\n                @Override\n                public Boolean apply(final WebDriver driver) {\n                    try {\n                        driver.findElement(by).click();\n                        return false;\n                    } catch (NullPointerException|NoSuchElementException|StaleElementReferenceException e) {\n                        return true;\n                    }\n                }\n            });\n        } finally {\n            setImplicitWait();\n        }\n    }","id":45969,"modified_method":"/**\n     * In some cases, Vaadin doesn't register our clicks,\n     * so this method keeps click until the given element\n     * is no longer found.\n     *\n     * @param by selector\n     */\n    private void clickElementUntilItDisappears(By by) {\n        scrollToElement(by);\n\n        // click once to make sure the element *ever* existed\n        waitForElement(by).click();\n\n        try {\n            setImplicitWait(200, TimeUnit.MILLISECONDS);\n            wait.until(new ExpectedCondition<Boolean>() {\n                @Override\n                public Boolean apply(final WebDriver driver) {\n                    try {\n                        driver.findElement(by).click();\n                        LOG.debug(\"clickElementUntilItDisappears: element still exists: {}\", by);\n                        return false;\n                    } catch (NullPointerException|NoSuchElementException|StaleElementReferenceException e) {\n                        return true;\n                    }\n                }\n            });\n        } finally {\n            setImplicitWait();\n        }\n    }","commit_id":"93913fb0fdbc8786d6055a7b31ac2a7034dc01de","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Verifies that the provided element is not present.\n     * @param by\n     */\n    private void verifyElementNotPresent(final By by) {\n        new WebDriverWait(m_driver, 5 /* seconds */).until(\n                ExpectedConditions.not(new ExpectedCondition<Boolean>() {\n                    @Nullable\n                    @Override\n                    public Boolean apply(@Nullable WebDriver input) {\n                        try {\n                            // the default implicit wait timeout is too long, make it shorter\n                            input.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);\n                            WebElement elementFound = input.findElement(by);\n                            return elementFound != null;\n                        } catch (NoSuchElementException|StaleElementReferenceException ex) {\n                            return false;\n                        } finally {\n                            // set the implicit wait timeout back to the value it has been before\n                            input.manage().timeouts().implicitlyWait(LOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n                        }\n                    }\n                })\n        );\n    }","id":45970,"modified_method":"/**\n     * Verifies that the provided element is not present.\n     * @param by\n     */\n    private void verifyElementNotPresent(final By by) {\n        new WebDriverWait(m_driver, 5 /* seconds */).until(getElementNotPresentCondition(by));\n    }","commit_id":"93913fb0fdbc8786d6055a7b31ac2a7034dc01de","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageAttributeEditWindow value(String value) {\n            LOG.debug(\"BsmAdminPageAttributeEditWindow().value({})\", value);\n            findElementById(\"valueField\").clear();\n            findElementById(\"valueField\").sendKeys(value);\n            return this;\n        }","id":45971,"modified_method":"public BsmAdminPageAttributeEditWindow value(String value) {\n            LOG.debug(\"BsmAdminPageAttributeEditWindow().value({})\", value);\n            enterText(By.id(\"valueField\"), value);\n            //findElementById(\"valueField\").clear();\n            //findElementById(\"valueField\").sendKeys(value);\n            return this;\n        }","commit_id":"93913fb0fdbc8786d6055a7b31ac2a7034dc01de","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageEdgeEditWindow confirm() {\n            LOG.debug(\"BsmAdminPageAttributeEditWindow().confirm({})\");\n            findElementById(\"okBtn\").click();\n            wait.until(pageContainsText(\"Business Service Edit\"));\n            return new BsmAdminPageEdgeEditWindow();\n        }","id":45972,"modified_method":"public BsmAdminPageEdgeEditWindow confirm() {\n            LOG.debug(\"BsmAdminPageAttributeEditWindow().confirm({})\");\n            waitForElement(By.id(\"okBtn\")).click();\n            wait.until(pageContainsText(\"Business Service Edit\"));\n            return new BsmAdminPageEdgeEditWindow();\n        }","commit_id":"93913fb0fdbc8786d6055a7b31ac2a7034dc01de","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageEdgeEditWindow selectIpService(String ipServiceText) {\n            LOG.debug(\"BsmAdminPageEdgeEditWindow().selectIpService({})\", ipServiceText);\n            selectEdgeType(\"IP Service\");\n            enterText(By.xpath(\"//div[@id='ipServiceList']/input[1]\"), ipServiceText);\n            // Click on the item that appears\n            waitForElement(By.xpath(\"//span[text()='\" + ipServiceText + \"']\")).click();\n            return this;\n        }","id":45973,"modified_method":"public BsmAdminPageEdgeEditWindow selectIpService(String ipServiceText) {\n            LOG.debug(\"BsmAdminPageEdgeEditWindow().selectIpService({})\", ipServiceText);\n            selectEdgeType(\"IP Service\");\n            enterText(By.xpath(\"//div[@id='ipServiceList']/input[1]\"), ipServiceText).sendKeys(Keys.ENTER);\n            // Click on the item that appears\n            waitForElement(By.xpath(\"//span[text()='\" + ipServiceText + \"']\")).click();\n            return this;\n        }","commit_id":"93913fb0fdbc8786d6055a7b31ac2a7034dc01de","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Vaadin usually wraps the select elements around a div element.\n     * This method considers this.\n     *\n     * @param id\n     * @return\n     */\n    private Select getSelectWebElement(String id) {\n        return new Select(findElementByXpath(\"//*[@id=\\\"\" + id + \"\\\"]/select\"));\n    }","id":45974,"modified_method":"/**\n     * Vaadin usually wraps the select elements around a div element.\n     * This method considers this.\n     *\n     * @param id\n     * @return\n     */\n    private Select getSelectWebElement(String id) {\n        return new Select(waitForElement(By.xpath(\"//*[@id=\\\"\" + id + \"\\\"]/select\")));\n    }","commit_id":"93913fb0fdbc8786d6055a7b31ac2a7034dc01de","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Feature(summary = \"The administrator can edit the project languages\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void editProjectLanguages() throws Exception {\n        ProjectLanguagesTab projectLanguagesTab = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .expectEnabledLocaleListCount(3);\n\n        List<String> enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"fr\", \"hi\", \"pl\")\n                .as(\"The enabled list contains three languages\");\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"en-US\")\n                .as(\"The enabled list does not contain \" +\n                        \"'English (United States)[en-US]'\");\n\n        projectLanguagesTab = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .removeLocale(\"pl\")\n                .expectEnabledLocaleListCount(2);\n\n        enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"en-US\")\n                .doesNotContain(\"pl\")\n                .as(\"The enabled list does not contain 'US English' or Polish\");\n\n        projectLanguagesTab = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .enterSearchLanguage(\"en-US\");\n                // count doesn't account for filtered search results:\n//                .expectAvailableLocaleListCount(1);\n        projectLanguagesTab = projectLanguagesTab\n                .addLanguage(\"en-US\")\n                .expectEnabledLocaleListCount(3);\n        enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        Assertions.assertThat(enabledLocaleList)\n                .contains(\"en-US\", \"fr\", \"hi\")\n                .as(\"The enabled language list contains en-US, fr and hi\");\n    }","id":45975,"modified_method":"@Feature(summary = \"The administrator can edit the project languages\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void editProjectLanguages() throws Exception {\n        ProjectLanguagesTab projectLanguagesTab = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .expectEnabledLocaleListCount(3);\n\n        List<String> enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"fr\", \"hi\", \"pl\")\n                .as(\"The enabled list contains three languages\");\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"en-US\")\n                .as(\"The enabled list does not contain \" +\n                        \"'English (United States)[en-US]'\");\n\n        projectLanguagesTab = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .removeLocale(\"pl\")\n                .expectEnabledLocaleListCount(2);\n\n        enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"en-US\")\n                .doesNotContain(\"pl\")\n                .as(\"The enabled list does not contain 'US English' or Polish\");\n\n        projectLanguagesTab = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .filterDisabledLanguages(\"nonexistentLocale\")\n                .expectAvailableLocaleListCount(0)\n                .filterDisabledLanguages(\"en-US\")\n                .expectAvailableLocaleListCount(1);\n        projectLanguagesTab = projectLanguagesTab\n                .addLanguage(\"en-US\")\n                .expectEnabledLocaleListCount(3);\n        enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        Assertions.assertThat(enabledLocaleList)\n                .contains(\"en-US\", \"fr\", \"hi\")\n                .as(\"The enabled language list contains en-US, fr and hi\");\n        projectLanguagesTab.filterEnabledLanguages(\"en-US\")\n                .expectEnabledLocaleListCount(1);\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The maintainer can override the available languages \" +\n            \"for a project version\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void changeVersionLanguages() throws Exception {\n        assertThat(new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .loggedInAs())\n                .isEqualTo(\"admin\")\n                .as(\"Admin user has logged in\");\n\n        VersionLanguagesTab versionLanguagesTab = new ProjectWorkFlow()\n                .goToProjectByName(\"langoverride\")\n                .gotoVersion(\"overridelangtest\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .expectLocaleListVisible();\n\n        List<String> enabledLocaleList = versionLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"fr\", \"hi\", \"pl\")\n                .as(\"The enabled list contains no languages\");\n\n        versionLanguagesTab = versionLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .enterSearchLanguage(\"en-US\")\n                .addLocale(\"en-US\");\n        versionLanguagesTab.expectNotification(\"Language \\\"en-US\\\" has been \" +\n                \"enabled.\");\n        versionLanguagesTab = versionLanguagesTab\n                .expectLanguagesContains(\"en-US\");\n\n        enabledLocaleList = versionLanguagesTab.getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"en-US\", \"fr\", \"hi\", \"pl\")\n                .as(\"The languages are available to translate\");\n    }","id":45976,"modified_method":"@Feature(summary = \"The maintainer can override the available languages \" +\n            \"for a project version\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void changeVersionLanguages() throws Exception {\n        assertThat(new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .loggedInAs())\n                .isEqualTo(\"admin\")\n                .as(\"Admin user has logged in\");\n\n        VersionLanguagesTab versionLanguagesTab = new ProjectWorkFlow()\n                .goToProjectByName(\"langoverride\")\n                .gotoVersion(\"overridelangtest\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .expectLocaleListVisible();\n\n        List<String> enabledLocaleList = versionLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"fr\", \"hi\", \"pl\")\n                .as(\"The enabled list contains no languages\");\n\n        versionLanguagesTab = versionLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .filterDisabledLanguages(\"nonexistentLocale\")\n                .expectAvailableLocaleListCount(0)\n                .filterDisabledLanguages(\"en-US\")\n                .expectAvailableLocaleListCount(1)\n                .addLocale(\"en-US\");\n        versionLanguagesTab.expectNotification(\"Language \\\"en-US\\\" has been \" +\n                \"enabled.\");\n        versionLanguagesTab = versionLanguagesTab\n                .expectLanguagesContains(\"en-US\");\n\n        enabledLocaleList = versionLanguagesTab.getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"en-US\", \"fr\", \"hi\", \"pl\")\n                .as(\"The languages are available to translate\");\n        versionLanguagesTab.filterEnabledLanguages(\"en-US\")\n                .expectEnabledLocaleListCount(1);\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static List<String> getListedLocales(WebElement localeList) {\n        return Lists.transform(getListElements(localeList),\n                li -> li.findElement(localeId).getText());\n    }","id":45977,"modified_method":"public static List<String> getListedLocales(WebElement localeList) {\n        return getListElements(localeList)\n                .stream()\n                .filter(WebElement::isDisplayed)\n                .map(li -> li.findElement(localeId).getText())\n                .collect(Collectors.toList());\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Get a list of locales enabled in this project\n     *\n     * @return String list of language/locale names\n     */\n    public List<String> getEnabledLocaleList() {\n        log.info(\"Query enabled locales\");\n        return LanguageList.getListedLocales(readyElement(activeLocales));\n    }","id":45978,"modified_method":"/**\n     * Get a list of locales enabled in this project\n     *\n     * @return String list of language/locale names\n     */\n    public List<String> getEnabledLocaleList() {\n        log.info(\"Query enabled locales\");\n        return LanguageList.getListedLocales(existingElement(activeLocales));\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Add a language to the languages list.\n     *\n     * @param searchLocaleId language to select\n     * @return new language settings, anticipating the language has been added.\n     */\n    public ProjectLanguagesTab addLanguage(final String searchLocaleId) {\n        log.info(\"Click Enable on {}\", searchLocaleId);\n        String message = \"can not find locale - \" + searchLocaleId;\n        waitForAMoment().withMessage(message).until(\n                (Predicate<WebDriver>) driver -> {\n                    return LanguageList.toggleLanguageInList(\n                            getDriver().findElement(inactiveLocales),\n                            searchLocaleId);\n                });\n        refreshPageUntil(this, (Predicate<WebDriver>) driver -> {\n            return getEnabledLocaleList().contains(searchLocaleId);\n        }, \"Wait for the locale list to contain \" + searchLocaleId);\n\n        return new ProjectLanguagesTab(getDriver());\n    }","id":45979,"modified_method":"/**\n     * Add a language to the languages list.\n     *\n     * @param searchLocaleId language to select\n     * @return new language settings, anticipating the language has been added.\n     */\n    public ProjectLanguagesTab addLanguage(final String searchLocaleId) {\n        log.info(\"Click Enable on {}\", searchLocaleId);\n        String message = \"can not find locale - \" + searchLocaleId;\n        waitForAMoment().withMessage(message).until(\n                (Predicate<WebDriver>) driver -> {\n                    return LanguageList.toggleLanguageInList(\n                            getDriver().findElement(disabledLocales),\n                            searchLocaleId);\n                });\n        refreshPageUntil(this, (Predicate<WebDriver>) driver -> {\n            return getEnabledLocaleList().contains(searchLocaleId);\n        }, \"Wait for the locale list to contain \" + searchLocaleId);\n\n        return new ProjectLanguagesTab(getDriver());\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Get a list of locales available for this project\n     *\n     * @return String list of language/locale names\n     */\n    public List<String> getAvailableLocaleList() {\n        log.info(\"Query available locales\");\n        return LanguageList.getListedLocales(readyElement(inactiveLocales));\n    }","id":45980,"modified_method":"/**\n     * Get a list of locales available for this project\n     *\n     * @return String list of language/locale names\n     */\n    public List<String> getAvailableLocaleList() {\n        log.info(\"Query available locales\");\n        return LanguageList.getListedLocales(existingElement(disabledLocales));\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectLanguagesTab expectEnabledLocaleListCount(final int count) {\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getEnabledLocaleList().size() == count;\n            }\n        });\n        return new ProjectLanguagesTab(getDriver());\n    }","id":45981,"modified_method":"public ProjectLanguagesTab expectEnabledLocaleListCount(final int count) {\n        waitForAMoment().until(\n                (Predicate<WebDriver>) input -> getEnabledLocaleList().size() == count);\n        return new ProjectLanguagesTab(getDriver());\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"public VersionLanguagesTab addLocale(final String localeId) {\n        log.info(\"Click Enable on {}\", localeId);\n        String message = \"can not find locale - \" + localeId;\n        waitForAMoment().withMessage(message).until(\n                (Predicate<WebDriver>) driver -> LanguageList.toggleLanguageInList(\n                        getDriver().findElement(inactiveLocales), localeId));\n\n        refreshPageUntil(this, (Predicate<WebDriver>) driver ->\n                getEnabledLocaleList().contains(localeId), \"Wait for the locale list to contain \" + localeId);\n\n        return new VersionLanguagesTab(getDriver());\n    }","id":45982,"modified_method":"public VersionLanguagesTab addLocale(final String localeId) {\n        log.info(\"Click Enable on {}\", localeId);\n        String message = \"can not find locale - \" + localeId;\n        waitForAMoment().withMessage(message).until(\n                (Predicate<WebDriver>) driver -> LanguageList.toggleLanguageInList(\n                        getDriver().findElement(disabledLocales), localeId));\n\n        refreshPageUntil(this, (Predicate<WebDriver>) driver ->\n                getEnabledLocaleList().contains(localeId), \"Wait for the locale list to contain \" + localeId);\n\n        return new VersionLanguagesTab(getDriver());\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Get a list of locales enabled in this version\n     *\n     * @return String list of language/locale names\n     */\n    public List<String> getEnabledLocaleList() {\n        log.info(\"Query enabled locales list\");\n        return LanguageList.getListedLocales(readyElement(activeLocales));\n    }","id":45983,"modified_method":"/**\n     * Get a list of locales enabled in this version\n     *\n     * @return String list of language/locale names\n     */\n    public List<String> getEnabledLocaleList() {\n        log.info(\"Query enabled locales list\");\n        return LanguageList.getListedLocales(existingElement(activeLocales));\n    }","commit_id":"978ecb39e556ffa05c68bc7f9f8f7845a459c81a","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void connectionStatusChange(RouterStub stub, RouterStub.ConnectionStatus state) {\n        if(log.isDebugEnabled())\n            log.debug(\"connection changed to \" + state);\n        if(state == RouterStub.ConnectionStatus.CONNECTION_ESTABLISHED) {\n            stopReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.CONNECTION_BROKEN){            \n            stub.destroy();\n            startReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.DISCONNECTED) {\n            //wait for disconnect ack;\n            try {\n                stub.getReceiver().getThread().join(reconnect_interval);\n            } catch (InterruptedException e) {\n            }\n        }\n    }","id":45984,"modified_method":"public void connectionStatusChange(RouterStub stub, RouterStub.ConnectionStatus state) {\n        if(log.isDebugEnabled())\n            log.debug(\"connection changed to \" + state);\n        if(state == RouterStub.ConnectionStatus.CONNECTION_ESTABLISHED) {\n            stopReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.CONNECTION_BROKEN){            \n            stub.destroy();\n            startReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.DISCONNECTED) {\n            //wait for disconnect ack;\n            try {\n                TUNNEL.StubReceiver receiver=stub != null? stub.getReceiver() : null;\n                if(receiver != null) {\n                    Thread thread=receiver.getThread();\n                    if(thread != null)\n                        thread.join(reconnect_interval);\n                }\n            } catch (InterruptedException e) {\n            }\n        }\n    }","commit_id":"b2ff4d8d7195f38ccadb8f55c9fe809d41e98c61","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean start()\n\t{\n\t\ttry {\n\t\t\t//TODO: brokers must FIND EACH OTHER here...\n\t\t\tbroker.startup();\n\t\t\tlog.info(\"Queue broker started\");\n\t\t\tQueueFactory queueFactory = QueueFactory.getInstance();\n\t\t\tfinal StorageEventPoller poller = new StorageEventPoller(queueFactory.getReceiver(QueueIdentifier.STORAGE));\n\t\t\ttimer.schedule(new TimerTask() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run()\n\t\t\t\t{\n\t\t\t\t\tpoller.writeEvents();\n\t\t\t\t}\n\t\t\t}, POLLER_DELAY_MS);\n\t\t\tthis.storagePoller = poller;\n\t\t\tlog.info(\"Storage queue poller started\");\n\t\t\tthis.instanceListener = new InstanceEventListener();\n\t\t\tlog.info(\"ReportingBootstrapper started\");\n\t\t\treturn true;\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"ReportingBootstrapper failed to start\", ex);\n\t\t\treturn false;\n\t\t}\n\t}","id":45985,"modified_method":"@Override\n\tpublic boolean start()\n\t{\n\t\ttry {\n\t\t\t//TODO: brokers must FIND EACH OTHER here...\n\n\t\t\t/* Start queue broker\n\t\t\t */\n\t\t\tqueueFactory = QueueFactory.getInstance();\n\t\t\t//QueueFactory has been started in SystemBootstrapper.init()\n\t\t\t\n\t\t\t/* Start storage receiver and storage queue poller thread\n\t\t\t */\n\t\t\tQueueReceiver storageReceiver = queueFactory.getReceiver(QueueIdentifier.STORAGE);\n\t\t\tfinal StorageEventPoller poller = new StorageEventPoller(storageReceiver);\n\t\t\ttimer = new Timer(true);\n\t\t\ttimer.schedule(new TimerTask() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run()\n\t\t\t\t{\n\t\t\t\t\tpoller.writeEvents();\n\t\t\t\t}\n\t\t\t}, 0, POLLER_DELAY_MS);\n\t\t\tthis.storagePoller = poller;\n\t\t\tlog.info(\"Storage queue poller started\");\n\t\t\t\n\t\t\t/* Start instance receiver and instance listener\n\t\t\t */\n\t\t\tQueueReceiver instanceReceiver =\n\t\t\t\tqueueFactory.getReceiver(QueueIdentifier.INSTANCE);\n\t\t\tinstanceListener = new InstanceEventListener();\n\t\t\tinstanceReceiver.addEventListener(instanceListener);\n\t\t\t\n\t\t\tlog.info(\"ReportingBootstrapper started\");\n\t\t\treturn true;\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tlog.error(\"ReportingBootstrapper failed to start\", ex);\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"250bf734444e71f376985eb986865da6bb3a2b69","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public boolean stop()\n\t{\n\t\ttry {\n\t\t\tlog.info(\"ReportingBootstrapper stopped\");\n\t\t\tinstanceListener.flush();\n\t\t\ttimer.cancel();\n\t\t\tstoragePoller.writeEvents();\n\t\t\tbroker.shutdown();\n\t\t\treturn true;\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"ReportingBootstrapper failed to stop\", ex);\n\t\t\treturn false;\n\t\t}\n\t}","id":45986,"modified_method":"@Override\n\tpublic boolean stop()\n\t{\n\t\ttry {\n\t\t\tlog.info(\"ReportingBootstrapper stopped\");\n\t\t\tinstanceListener.flush();\n\t\t\ttimer.cancel();\n\t\t\tstoragePoller.writeEvents();\n\t\t\tqueueFactory.shutdown();\n\t\t\treturn true;\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"ReportingBootstrapper failed to stop\", ex);\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"250bf734444e71f376985eb986865da6bb3a2b69","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public boolean load()\n\t{\n\t\ttry {\n\t\t\tbroker = QueueBroker.getInstance();\n\t\t\ttimer = new Timer(true);\n\t\t\treturn true;\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"ReportingBootstrapper failed to load\", ex);\n\t\t\treturn false;\n\t\t}\n\t}","id":45987,"modified_method":"@Override\n\tpublic boolean load()\n\t{\n\t\ttry {\n\t\t\treturn true;\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"ReportingBootstrapper failed to load\", ex);\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"250bf734444e71f376985eb986865da6bb3a2b69","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void connectionStatusChange(RouterStub stub, RouterStub.ConnectionStatus state) {\n        if(log.isDebugEnabled())\n            log.debug(\"connection changed to \" + state);\n        if(state == RouterStub.ConnectionStatus.CONNECTION_ESTABLISHED) {\n            stopReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.CONNECTION_BROKEN){            \n            stub.destroy();\n            startReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.DISCONNECTED) {\n            //wait for disconnect ack;\n            try {\n                stub.getReceiver().getThread().join(reconnect_interval);\n            } catch (InterruptedException e) {\n            }\n        }\n    }","id":45988,"modified_method":"public void connectionStatusChange(RouterStub stub, RouterStub.ConnectionStatus state) {\n        if(log.isDebugEnabled())\n            log.debug(\"connection changed to \" + state);\n        if(state == RouterStub.ConnectionStatus.CONNECTION_ESTABLISHED) {\n            stopReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.CONNECTION_BROKEN){            \n            stub.destroy();\n            startReconnector();\n        }\n        else if (state == RouterStub.ConnectionStatus.DISCONNECTED) {\n            //wait for disconnect ack;\n            try {\n                TUNNEL.StubReceiver receiver=stub != null? stub.getReceiver() : null;\n                if(receiver != null) {\n                    Thread thread=receiver.getThread();\n                    if(thread != null)\n                        thread.join(reconnect_interval);\n                }\n            } catch (InterruptedException e) {\n            }\n        }\n    }","commit_id":"32c533eca4bf464a92025ff58fc4565d5fff59da","url":"https://github.com/belaban/JGroups"},{"original_method":"public static Object fromStream(final ODocument iRecord, final Object iPojo, final OEntityManager iEntityManager,\r\n      final OUserObject2RecordHandler iObj2RecHandler, final String iFetchPlan) {\r\n    final long timer = OProfiler.getInstance().startChrono();\r\n\r\n    final Class<?> c = iPojo.getClass();\r\n\r\n    List<Field> properties = classes.get(c.getName());\r\n    if (properties == null)\r\n      properties = registerClass(c);\r\n\r\n    String fieldName;\r\n    Object fieldValue;\r\n\r\n    if (iRecord.getInternalStatus() == STATUS.NOT_LOADED)\r\n      iRecord.load();\r\n\r\n    // CALL BEFORE UNMARSHALLING\r\n    invokeCallback(iPojo, iRecord, OBeforeDeserialization.class);\r\n\r\n    // BIND BASIC FIELDS, LINKS WILL BE BOUND BY THE FETCH API\r\n    for (Field p : properties) {\r\n      fieldName = p.getName();\r\n\r\n      if (iRecord.containsField(fieldName)) {\r\n        // BIND ONLY THE SPECIFIED FIELDS\r\n        fieldValue = iRecord.field(fieldName);\r\n\r\n        if (fieldValue == null\r\n            || !(fieldValue instanceof ODocument)\r\n            || (fieldValue instanceof Collection<?> && (((Collection<?>) fieldValue).size() == 0 || !(((Collection<?>) fieldValue)\r\n                .iterator().next() instanceof ODocument))))\r\n          setFieldValue(iPojo, fieldName, fieldValue);\r\n      }\r\n    }\r\n\r\n    // BIND LINKS FOLLOWING THE FETCHING PLAN\r\n    final Map<String, Integer> fetchPlan = OFetchHelper.buildFetchPlan(iFetchPlan);\r\n    OFetchHelper.fetch(iRecord, iPojo, fetchPlan, null, 0, -1, new OFetchListener() {\r\n      /***\r\n       * Doesn't matter size.\r\n       */\r\n      public int size() {\r\n        return 0;\r\n      }\r\n\r\n      public Object fetchLinked(final ODocument iRoot, final Object iUserObject, final String iFieldName, final Object iLinked) {\r\n        final Class<?> type = getFieldType(iUserObject, iFieldName);\r\n\r\n        Object fieldValue = null;\r\n        Class<?> fieldClass;\r\n        boolean propagate = false;\r\n\r\n        if (type.isAssignableFrom(List.class)) {\r\n\r\n          final Collection<ODocument> list = (Collection<ODocument>) iLinked;\r\n          final List<Object> targetList = new OLazyObjectList<Object>((ODatabaseObjectTx) iRecord.getDatabase().getDatabaseOwner())\r\n              .setFetchPlan(iFetchPlan);\r\n          fieldValue = targetList;\r\n\r\n          if (list != null && list.size() > 0) {\r\n            targetList.addAll(list);\r\n          }\r\n\r\n        } else if (type.isAssignableFrom(Set.class)) {\r\n\r\n          final Collection<Object> set = (Collection<Object>) iLinked;\r\n          final Set<Object> target = new OLazyObjectSet<Object>((ODatabaseObjectTx) iRecord.getDatabase().getDatabaseOwner(), set)\r\n              .setFetchPlan(iFetchPlan);\r\n\r\n          fieldValue = target;\r\n        } else if (type.isEnum()) {\r\n\r\n          String enumName = ((ODocument) iLinked).field(iFieldName);\r\n          @SuppressWarnings(\"rawtypes\")\r\n          Class<Enum> enumClass = (Class<Enum>) type;\r\n          fieldValue = Enum.valueOf(enumClass, enumName);\r\n\r\n        } else {\r\n\r\n          fieldClass = iEntityManager.getEntityClass(type.getSimpleName());\r\n          if (fieldClass != null) {\r\n            // RECOGNIZED TYPE\r\n            propagate = !iObj2RecHandler.existsUserObjectByRecord((ODocument) iLinked);\r\n\r\n            fieldValue = iObj2RecHandler.getUserObjectByRecord((ODocument) iLinked, iFetchPlan);\r\n          }\r\n        }\r\n\r\n        setFieldValue(iUserObject, iFieldName, fieldValue);\r\n\r\n        return propagate ? fieldValue : null;\r\n      }\r\n    });\r\n\r\n    // CALL AFTER UNMARSHALLING\r\n    invokeCallback(iPojo, iRecord, OAfterDeserialization.class);\r\n\r\n    OProfiler.getInstance().stopChrono(\"Object.fromStream\", timer);\r\n\r\n    return iPojo;\r\n  }","id":45989,"modified_method":"public static Object fromStream(final ODocument iRecord, final Object iPojo, final OEntityManager iEntityManager,\r\n      final OUserObject2RecordHandler iObj2RecHandler, final String iFetchPlan) {\r\n    final long timer = OProfiler.getInstance().startChrono();\r\n\r\n    final Class<?> c = iPojo.getClass();\r\n\r\n    final List<Field> properties = getClassFields(c);\r\n\r\n    String fieldName;\r\n    Object fieldValue;\r\n\r\n    if (iRecord.getInternalStatus() == STATUS.NOT_LOADED)\r\n      iRecord.load();\r\n\r\n    // CALL BEFORE UNMARSHALLING\r\n    invokeCallback(iPojo, iRecord, OBeforeDeserialization.class);\r\n\r\n    // BIND BASIC FIELDS, LINKS WILL BE BOUND BY THE FETCH API\r\n    for (Field p : properties) {\r\n      fieldName = p.getName();\r\n\r\n      if (iRecord.containsField(fieldName)) {\r\n        // BIND ONLY THE SPECIFIED FIELDS\r\n        fieldValue = iRecord.field(fieldName);\r\n\r\n        if (fieldValue == null\r\n            || !(fieldValue instanceof ODocument)\r\n            || (fieldValue instanceof Collection<?> && (((Collection<?>) fieldValue).size() == 0 || !(((Collection<?>) fieldValue)\r\n                .iterator().next() instanceof ODocument))))\r\n          setFieldValue(iPojo, fieldName, fieldValue);\r\n      }\r\n    }\r\n\r\n    // BIND LINKS FOLLOWING THE FETCHING PLAN\r\n    final Map<String, Integer> fetchPlan = OFetchHelper.buildFetchPlan(iFetchPlan);\r\n    OFetchHelper.fetch(iRecord, iPojo, fetchPlan, null, 0, -1, new OFetchListener() {\r\n      /***\r\n       * Doesn't matter size.\r\n       */\r\n      public int size() {\r\n        return 0;\r\n      }\r\n\r\n      public Object fetchLinked(final ODocument iRoot, final Object iUserObject, final String iFieldName, final Object iLinked) {\r\n        final Class<?> type = getFieldType(iUserObject, iFieldName);\r\n\r\n        Object fieldValue = null;\r\n        Class<?> fieldClass;\r\n        boolean propagate = false;\r\n\r\n        if (type.isAssignableFrom(List.class)) {\r\n\r\n          final Collection<ODocument> list = (Collection<ODocument>) iLinked;\r\n          final List<Object> targetList = new OLazyObjectList<Object>((ODatabaseObjectTx) iRecord.getDatabase().getDatabaseOwner())\r\n              .setFetchPlan(iFetchPlan);\r\n          fieldValue = targetList;\r\n\r\n          if (list != null && list.size() > 0) {\r\n            targetList.addAll(list);\r\n          }\r\n\r\n        } else if (type.isAssignableFrom(Set.class)) {\r\n\r\n          final Collection<Object> set = (Collection<Object>) iLinked;\r\n          final Set<Object> target = new OLazyObjectSet<Object>((ODatabaseObjectTx) iRecord.getDatabase().getDatabaseOwner(), set)\r\n              .setFetchPlan(iFetchPlan);\r\n\r\n          fieldValue = target;\r\n        } else if (type.isEnum()) {\r\n\r\n          String enumName = ((ODocument) iLinked).field(iFieldName);\r\n          @SuppressWarnings(\"rawtypes\")\r\n          Class<Enum> enumClass = (Class<Enum>) type;\r\n          fieldValue = Enum.valueOf(enumClass, enumName);\r\n\r\n        } else {\r\n\r\n          fieldClass = iEntityManager.getEntityClass(type.getSimpleName());\r\n          if (fieldClass != null) {\r\n            // RECOGNIZED TYPE\r\n            propagate = !iObj2RecHandler.existsUserObjectByRecord((ODocument) iLinked);\r\n\r\n            fieldValue = iObj2RecHandler.getUserObjectByRecord((ODocument) iLinked, iFetchPlan);\r\n          }\r\n        }\r\n\r\n        setFieldValue(iUserObject, iFieldName, fieldValue);\r\n\r\n        return propagate ? fieldValue : null;\r\n      }\r\n    });\r\n\r\n    // CALL AFTER UNMARSHALLING\r\n    invokeCallback(iPojo, iRecord, OAfterDeserialization.class);\r\n\r\n    OProfiler.getInstance().stopChrono(\"Object.fromStream\", timer);\r\n\r\n    return iPojo;\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static Class<?> getFieldType(final Object iPojo, final String iProperty) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    if (!classes.containsKey(className))\r\n      registerClass(c);\r\n\r\n    try {\r\n      Object o = getters.get(className + \".\" + iProperty);\r\n\r\n      if (o == null)\r\n        return null;\r\n      else if (o instanceof Field)\r\n        return ((Field) o).getType();\r\n      else\r\n        return ((Method) o).getReturnType();\r\n    } catch (Exception e) {\r\n      throw new OSchemaException(\"Can't get the value of the property: \" + iProperty, e);\r\n    }\r\n  }","id":45990,"modified_method":"public static Class<?> getFieldType(final Object iPojo, final String iProperty) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    getClassFields(c);\r\n\r\n    try {\r\n      Object o = getters.get(className + \".\" + iProperty);\r\n\r\n      if (o == null)\r\n        return null;\r\n      else if (o instanceof Field)\r\n        return ((Field) o).getType();\r\n      else\r\n        return ((Method) o).getReturnType();\r\n    } catch (Exception e) {\r\n      throw new OSchemaException(\"Can't get the value of the property: \" + iProperty, e);\r\n    }\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static boolean hasField(final Object iPojo, final String iProperty) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    if (!classes.containsKey(className))\r\n      registerClass(c);\r\n\r\n    return getters.get(className + \".\" + iProperty) != null;\r\n  }","id":45991,"modified_method":"public static boolean hasField(final Object iPojo, final String iProperty) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    getClassFields(c);\r\n\r\n    return getters.get(className + \".\" + iProperty) != null;\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static void setFieldValue(final Object iPojo, final String iProperty, Object iValue) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    if (!classes.containsKey(className))\r\n      registerClass(c);\r\n\r\n    try {\r\n      Object o = setters.get(className + \".\" + iProperty);\r\n\r\n      if (o instanceof Method) {\r\n        ((Method) o).invoke(iPojo, OType.convert(iValue, ((Method) o).getParameterTypes()[0]));\r\n      } else if (o instanceof Field) {\r\n        ((Field) o).set(iPojo, OType.convert(iValue, ((Field) o).getType()));\r\n      }\r\n\r\n    } catch (Exception e) {\r\n\r\n      throw new OSchemaException(\"Can't set the value '\" + iValue + \"' to the property '\" + iProperty + \"' for the pojo: \" + iPojo,\r\n          e);\r\n    }\r\n  }","id":45992,"modified_method":"public static void setFieldValue(final Object iPojo, final String iProperty, Object iValue) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    getClassFields(c);\r\n\r\n    try {\r\n      Object o = setters.get(className + \".\" + iProperty);\r\n\r\n      if (o instanceof Method) {\r\n        ((Method) o).invoke(iPojo, OType.convert(iValue, ((Method) o).getParameterTypes()[0]));\r\n      } else if (o instanceof Field) {\r\n        ((Field) o).set(iPojo, OType.convert(iValue, ((Field) o).getType()));\r\n      }\r\n\r\n    } catch (Exception e) {\r\n\r\n      throw new OSchemaException(\"Can't set the value '\" + iValue + \"' to the property '\" + iProperty + \"' for the pojo: \" + iPojo,\r\n          e);\r\n    }\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static Object getFieldValue(final Object iPojo, final String iProperty) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    if (!classes.containsKey(className))\r\n      registerClass(c);\r\n\r\n    try {\r\n      Object o = getters.get(className + \".\" + iProperty);\r\n\r\n      if (o instanceof Method)\r\n        return ((Method) o).invoke(iPojo);\r\n      else if (o instanceof Field)\r\n        return ((Field) o).get(iPojo);\r\n      return null;\r\n    } catch (Exception e) {\r\n      throw new OSchemaException(\"Can't get the value of the property: \" + iProperty, e);\r\n    }\r\n  }","id":45993,"modified_method":"public static Object getFieldValue(final Object iPojo, final String iProperty) {\r\n    final Class<?> c = iPojo.getClass();\r\n    final String className = c.getName();\r\n\r\n    getClassFields(c);\r\n\r\n    try {\r\n      Object o = getters.get(className + \".\" + iProperty);\r\n\r\n      if (o instanceof Method)\r\n        return ((Method) o).invoke(iPojo);\r\n      else if (o instanceof Field)\r\n        return ((Field) o).get(iPojo);\r\n      return null;\r\n    } catch (Exception e) {\r\n      throw new OSchemaException(\"Can't get the value of the property: \" + iProperty, e);\r\n    }\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Serialize the user POJO to a ORecordDocument instance.\r\n   * \r\n   * @param iPojo\r\n   *          User pojo to serialize\r\n   * @param iRecord\r\n   *          Record where to update\r\n   * @param iObj2RecHandler\r\n   */\r\n  public static ODocument toStream(final Object iPojo, final ODocument iRecord, final OEntityManager iEntityManager,\r\n      final OClass schemaClass, final OUserObject2RecordHandler iObj2RecHandler) {\r\n    long timer = OProfiler.getInstance().startChrono();\r\n\r\n    if (OSerializationThreadLocal.INSTANCE.get().containsKey(iRecord))\r\n      return iRecord;\r\n\r\n    OSerializationThreadLocal.INSTANCE.get().put(iRecord, (ORecordId) iRecord.getIdentity());\r\n\r\n    OProperty schemaProperty;\r\n\r\n    Class<?> c = iPojo.getClass();\r\n\r\n    List<Field> properties = classes.get(c.getName());\r\n    if (properties == null)\r\n      properties = registerClass(c);\r\n\r\n    String fieldName;\r\n    Object fieldValue;\r\n\r\n    // CALL BEFORE MARSHALLING\r\n    invokeCallback(iPojo, iRecord, OBeforeSerialization.class);\r\n\r\n    for (Field p : properties) {\r\n      fieldName = p.getName();\r\n      fieldValue = getFieldValue(iPojo, fieldName);\r\n\r\n      schemaProperty = schemaClass != null ? schemaClass.getProperty(fieldName) : null;\r\n\r\n      fieldValue = typeToStream(fieldValue, schemaProperty != null ? schemaProperty.getType() : null, iEntityManager,\r\n          iObj2RecHandler);\r\n\r\n      iRecord.field(fieldName, fieldValue);\r\n    }\r\n\r\n    // CALL AFTER MARSHALLING\r\n    invokeCallback(iPojo, iRecord, OAfterSerialization.class);\r\n\r\n    OSerializationThreadLocal.INSTANCE.get().remove(iRecord);\r\n\r\n    OProfiler.getInstance().stopChrono(\"Object.toStream\", timer);\r\n\r\n    return iRecord;\r\n  }","id":45994,"modified_method":"/**\r\n   * Serialize the user POJO to a ORecordDocument instance.\r\n   * \r\n   * @param iPojo\r\n   *          User pojo to serialize\r\n   * @param iRecord\r\n   *          Record where to update\r\n   * @param iObj2RecHandler\r\n   */\r\n  public static ODocument toStream(final Object iPojo, final ODocument iRecord, final OEntityManager iEntityManager,\r\n      final OClass schemaClass, final OUserObject2RecordHandler iObj2RecHandler) {\r\n    long timer = OProfiler.getInstance().startChrono();\r\n\r\n    if (OSerializationThreadLocal.INSTANCE.get().containsKey(iRecord))\r\n      return iRecord;\r\n\r\n    OSerializationThreadLocal.INSTANCE.get().put(iRecord, (ORecordId) iRecord.getIdentity());\r\n\r\n    OProperty schemaProperty;\r\n\r\n    Class<?> c = iPojo.getClass();\r\n\r\n    final List<Field> properties = getClassFields(c);\r\n\r\n    String fieldName;\r\n    Object fieldValue;\r\n\r\n    // CALL BEFORE MARSHALLING\r\n    invokeCallback(iPojo, iRecord, OBeforeSerialization.class);\r\n\r\n    for (Field p : properties) {\r\n      fieldName = p.getName();\r\n      fieldValue = getFieldValue(iPojo, fieldName);\r\n\r\n      schemaProperty = schemaClass != null ? schemaClass.getProperty(fieldName) : null;\r\n\r\n      fieldValue = typeToStream(fieldValue, schemaProperty != null ? schemaProperty.getType() : null, iEntityManager,\r\n          iObj2RecHandler);\r\n\r\n      iRecord.field(fieldName, fieldValue);\r\n    }\r\n\r\n    // CALL AFTER MARSHALLING\r\n    invokeCallback(iPojo, iRecord, OAfterSerialization.class);\r\n\r\n    OSerializationThreadLocal.INSTANCE.get().remove(iRecord);\r\n\r\n    OProfiler.getInstance().stopChrono(\"Object.toStream\", timer);\r\n\r\n    return iRecord;\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static String getDocumentBoundField(final Class<?> iClass) {\r\n    if (!classes.containsKey(iClass.getName()))\r\n      registerClass(iClass);\r\n\r\n    return boundDocumentFields.get(iClass.getName());\r\n  }","id":45995,"modified_method":"public static String getDocumentBoundField(final Class<?> iClass) {\r\n    getClassFields(iClass);\r\n    return boundDocumentFields.get(iClass.getName());\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void recoverTransactionEntry(byte status, byte operation, int reqId, int txId, int clusterId, long clusterOffset,\r\n\t\t\tlong oldDataOffset, OPhysicalPosition ppos) throws IOException {\r\n\r\n\t\tfinal OClusterLocal cluster = (OClusterLocal) storage.getClusterById(clusterId);\r\n\r\n\t\tOLogManager.instance().info(this,\r\n\t\t\t\t\"Recovering tx <%d> by req <%d>. Operation <%d> was in status <%d> on record %d:%d in data space %d...\", txId, reqId,\r\n\t\t\t\toperation, status, clusterId, clusterOffset, oldDataOffset);\r\n\r\n\t\tswitch (operation) {\r\n\t\tcase OPERATION_CREATE:\r\n\t\t\t// JUST DELETE THE RECORD\r\n\t\t\tstorage.deleteRecord(-1, clusterId, clusterOffset, -1);\r\n\t\t\tbreak;\r\n\r\n\t\tcase OPERATION_UPDATE:\r\n\t\t\t// RETRIEVE THE OLD RECORD\r\n\t\t\tstorage.getDataSegment(ppos.dataSegment).getRecordSize(oldDataOffset);\r\n\r\n\t\t\t// RETRIEVE THE CURRENT PPOS\r\n\t\t\tcluster.getPhysicalPosition(clusterOffset, ppos);\r\n\r\n\t\t\tlong newPosition = ppos.dataPosition;\r\n\t\t\tint newSize = ppos.recordSize;\r\n\r\n\t\t\t// REPLACE THE POSITION OF THE OLD RECORD\r\n\t\t\tppos.dataPosition = oldDataOffset;\r\n\r\n\t\t\t// UPDATE THE PPOS WITH THE COORDS OF THE OLD RECORD\r\n\t\t\tstorage.getClusterById(clusterId).setPhysicalPosition(clusterOffset, ppos.dataSegment, oldDataOffset, ppos.type);\r\n\r\n\t\t\t// CREATE A HOLE\r\n\t\t\tstorage.getDataSegment(ppos.dataSegment).createHole(newPosition, newSize);\r\n\t\t\tbreak;\r\n\r\n\t\tcase OPERATION_DELETE:\r\n\t\t\t// GET THE PPOS\r\n\t\t\tcluster.getPhysicalPosition(clusterOffset, ppos);\r\n\r\n\t\t\t// SAVE THE PPOS WITH THE VERSION TO 0 (VALID IF >-1)\r\n\t\t\tcluster.updateVersion(clusterOffset, 0);\r\n\r\n\t\t\t// REMOVE THE HOLE\r\n\t\t\tcluster.removeHole(clusterOffset);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}","id":45996,"modified_method":"private void recoverTransactionEntry(byte status, byte operation, int reqId, int txId, int clusterId, long clusterOffset,\r\n      long oldDataOffset, OPhysicalPosition ppos) throws IOException {\r\n\r\n    final OCluster cluster = storage.getClusterById(clusterId);\r\n\r\n    if (!(cluster instanceof OClusterLocal))\r\n      return;\r\n\r\n    final OClusterLocal logCluster = (OClusterLocal) cluster;\r\n\r\n    OLogManager.instance().info(this,\r\n        \"Recovering tx <%d> by req <%d>. Operation <%d> was in status <%d> on record %d:%d in data space %d...\", txId, reqId,\r\n        operation, status, clusterId, clusterOffset, oldDataOffset);\r\n\r\n    switch (operation) {\r\n    case OPERATION_CREATE:\r\n      // JUST DELETE THE RECORD\r\n      storage.deleteRecord(-1, clusterId, clusterOffset, -1);\r\n      break;\r\n\r\n    case OPERATION_UPDATE:\r\n      // RETRIEVE THE OLD RECORD\r\n      storage.getDataSegment(ppos.dataSegment).getRecordSize(oldDataOffset);\r\n\r\n      // RETRIEVE THE CURRENT PPOS\r\n      cluster.getPhysicalPosition(clusterOffset, ppos);\r\n\r\n      long newPosition = ppos.dataPosition;\r\n      int newSize = ppos.recordSize;\r\n\r\n      // REPLACE THE POSITION OF THE OLD RECORD\r\n      ppos.dataPosition = oldDataOffset;\r\n\r\n      // UPDATE THE PPOS WITH THE COORDS OF THE OLD RECORD\r\n      storage.getClusterById(clusterId).setPhysicalPosition(clusterOffset, ppos.dataSegment, oldDataOffset, ppos.type);\r\n\r\n      // CREATE A HOLE\r\n      storage.getDataSegment(ppos.dataSegment).createHole(newPosition, newSize);\r\n      break;\r\n\r\n    case OPERATION_DELETE:\r\n      // GET THE PPOS\r\n      cluster.getPhysicalPosition(clusterOffset, ppos);\r\n\r\n      // SAVE THE PPOS WITH THE VERSION TO 0 (VALID IF >-1)\r\n      cluster.updateVersion(clusterOffset, 0);\r\n\r\n      // REMOVE THE HOLE\r\n      logCluster.removeHole(clusterOffset);\r\n      break;\r\n    }\r\n  }","commit_id":"4496c59ed48ac1623f5299860f682c020d01e850","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void release(int clusterId) {\n\n    final OLocalPaginatedCluster cluster = (OLocalPaginatedCluster) getClusterById(clusterId);\n\n    final String name = cluster.getName();\n    if (OMetadata.CLUSTER_INDEX_NAME.equals(name) || OMetadata.CLUSTER_MANUAL_INDEX_NAME.equals(name)) {\n      throw new IllegalArgumentException(\"It is impossible to freeze and release index or manualindex cluster!\");\n    }\n\n    try {\n      cluster.setSoftlyClosed(false);\n    } catch (IOException e) {\n      throw new OStorageException(\"Error on unfreeze storage '\" + name + \"'\", e);\n    }\n\n    cluster.getExternalModificationLock().allowModifications();\n\n  }","id":45997,"modified_method":"public void release(int clusterId) {\n    final OLocalPaginatedCluster cluster = getClusterById(clusterId);\n\n    final String name = cluster.getName();\n    if (OMetadata.CLUSTER_INDEX_NAME.equals(name) || OMetadata.CLUSTER_MANUAL_INDEX_NAME.equals(name)) {\n      throw new IllegalArgumentException(\"It is impossible to freeze and release index or manualindex cluster!\");\n    }\n\n    try {\n      cluster.setSoftlyClosed(false);\n    } catch (IOException e) {\n      throw new OStorageException(\"Error on unfreeze storage '\" + name + \"'\", e);\n    }\n\n    cluster.getExternalModificationLock().allowModifications();\n\n  }","commit_id":"75585374a245a55aaf7a923c9ea4092f695db9b1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void freeze(boolean throwException, int clusterId) {\n    final OLocalPaginatedCluster cluster = (OLocalPaginatedCluster) getClusterById(clusterId);\n\n    final String name = cluster.getName();\n    if (OMetadata.CLUSTER_INDEX_NAME.equals(name) || OMetadata.CLUSTER_MANUAL_INDEX_NAME.equals(name)) {\n      throw new IllegalArgumentException(\"It is impossible to freeze and release index or manual index cluster!\");\n    }\n\n    cluster.getExternalModificationLock().prohibitModifications(throwException);\n\n    try {\n      //TODO synchronize shared resources\n      cluster.synch();\n      cluster.setSoftlyClosed(true);\n    } catch (IOException e) {\n      throw new OStorageException(\"Error on synch storage '\" + name + \"'\", e);\n    }\n  }","id":45998,"modified_method":"public void freeze(boolean throwException, int clusterId) {\n    final OLocalPaginatedCluster cluster = getClusterById(clusterId);\n\n    final String name = cluster.getName();\n    if (OMetadata.CLUSTER_INDEX_NAME.equals(name) || OMetadata.CLUSTER_MANUAL_INDEX_NAME.equals(name)) {\n      throw new IllegalArgumentException(\"It is impossible to freeze and release index or manual index cluster!\");\n    }\n\n    cluster.getExternalModificationLock().prohibitModifications(throwException);\n\n    try {\n      cluster.synch();\n      cluster.setSoftlyClosed(true);\n    } catch (IOException e) {\n      throw new OStorageException(\"Error on synch cluster '\" + name + \"'\", e);\n    }\n  }","commit_id":"75585374a245a55aaf7a923c9ea4092f695db9b1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OStorageOperationResult<ORecordVersion> updateRecord(final ORecordId rid, final byte[] content,\n      final ORecordVersion version, final byte recordType, final int mode, ORecordCallback<ORecordVersion> callback) {\n    checkOpeness();\n\n    final OCluster cluster = getClusterById(rid.clusterId);\n    final OLocalPaginatedCluster localPaginatedCluster = (OLocalPaginatedCluster) cluster;\n\n    localPaginatedCluster.getExternalModificationLock().requestModificationLock();\n    try {\n      modificationLock.requestModificationLock();\n      try {\n        if (cluster == null)\n          throw new OStorageException(\"Cluster not defined for record: \" + rid);\n\n        lock.acquireSharedLock();\n        try {\n          // GET THE SHARED LOCK AND GET AN EXCLUSIVE LOCK AGAINST THE RECORD\n          lockManager.acquireLock(Thread.currentThread(), rid, OLockManager.LOCK.EXCLUSIVE);\n          try {\n            // UPDATE IT\n            final OPhysicalPosition ppos = cluster.getPhysicalPosition(new OPhysicalPosition(rid.clusterPosition));\n            if (!checkForRecordValidity(ppos)) {\n              final ORecordVersion recordVersion = OVersionFactory.instance().createUntrackedVersion();\n              if (callback != null)\n                callback.call(rid, recordVersion);\n\n              return new OStorageOperationResult<ORecordVersion>(recordVersion);\n            }\n\n            // VERSION CONTROL CHECK\n            switch (version.getCounter()) {\n              // DOCUMENT UPDATE, NO VERSION CONTROL\n              case -1:\n                ppos.recordVersion.increment();\n                break;\n\n              // DOCUMENT UPDATE, NO VERSION CONTROL, NO VERSION UPDATE\n              case -2:\n                break;\n\n              default:\n                // MVCC CONTROL AND RECORD UPDATE OR WRONG VERSION VALUE\n                // MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\n                if (!version.equals(ppos.recordVersion))\n                  if (OFastConcurrentModificationException.enabled())\n                    throw OFastConcurrentModificationException.instance();\n                  else\n                    throw new OConcurrentModificationException(rid, ppos.recordVersion, version, ORecordOperation.UPDATED);\n                ppos.recordVersion.increment();\n            }\n\n            localPaginatedCluster.updateRecord(rid.clusterPosition, content, ppos.recordVersion, recordType);\n\n            if (callback != null)\n              callback.call(rid, ppos.recordVersion);\n\n            return new OStorageOperationResult<ORecordVersion>(ppos.recordVersion);\n\n          } finally {\n            lockManager.releaseLock(Thread.currentThread(), rid, OLockManager.LOCK.EXCLUSIVE);\n          }\n        } catch (IOException e) {\n          OLogManager.instance().error(this, \"Error on updating record \" + rid + \" (cluster: \" + cluster + \")\", e);\n\n          final ORecordVersion recordVersion = OVersionFactory.instance().createUntrackedVersion();\n          if (callback != null)\n            callback.call(rid, recordVersion);\n\n          return new OStorageOperationResult<ORecordVersion>(recordVersion);\n        } finally {\n          lock.releaseSharedLock();\n        }\n      } finally {\n        modificationLock.releaseModificationLock();\n      }\n    } finally {\n      localPaginatedCluster.getExternalModificationLock().releaseModificationLock();\n    }\n  }","id":45999,"modified_method":"public OStorageOperationResult<ORecordVersion> updateRecord(final ORecordId rid, final byte[] content,\n      final ORecordVersion version, final byte recordType, final int mode, ORecordCallback<ORecordVersion> callback) {\n    checkOpeness();\n\n    final OLocalPaginatedCluster cluster = getClusterById(rid.clusterId);\n\n    cluster.getExternalModificationLock().requestModificationLock();\n    try {\n      modificationLock.requestModificationLock();\n      try {\n        if (cluster == null)\n          throw new OStorageException(\"Cluster not defined for record: \" + rid);\n\n        lock.acquireSharedLock();\n        try {\n          // GET THE SHARED LOCK AND GET AN EXCLUSIVE LOCK AGAINST THE RECORD\n          lockManager.acquireLock(Thread.currentThread(), rid, OLockManager.LOCK.EXCLUSIVE);\n          try {\n            // UPDATE IT\n            final OPhysicalPosition ppos = cluster.getPhysicalPosition(new OPhysicalPosition(rid.clusterPosition));\n            if (!checkForRecordValidity(ppos)) {\n              final ORecordVersion recordVersion = OVersionFactory.instance().createUntrackedVersion();\n              if (callback != null)\n                callback.call(rid, recordVersion);\n\n              return new OStorageOperationResult<ORecordVersion>(recordVersion);\n            }\n\n            // VERSION CONTROL CHECK\n            switch (version.getCounter()) {\n            // DOCUMENT UPDATE, NO VERSION CONTROL\n            case -1:\n              ppos.recordVersion.increment();\n              break;\n\n            // DOCUMENT UPDATE, NO VERSION CONTROL, NO VERSION UPDATE\n            case -2:\n              break;\n\n            default:\n              // MVCC CONTROL AND RECORD UPDATE OR WRONG VERSION VALUE\n              // MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\n              if (!version.equals(ppos.recordVersion))\n                if (OFastConcurrentModificationException.enabled())\n                  throw OFastConcurrentModificationException.instance();\n                else\n                  throw new OConcurrentModificationException(rid, ppos.recordVersion, version, ORecordOperation.UPDATED);\n              ppos.recordVersion.increment();\n            }\n\n            cluster.updateRecord(rid.clusterPosition, content, ppos.recordVersion, recordType);\n\n            if (callback != null)\n              callback.call(rid, ppos.recordVersion);\n\n            return new OStorageOperationResult<ORecordVersion>(ppos.recordVersion);\n\n          } finally {\n            lockManager.releaseLock(Thread.currentThread(), rid, OLockManager.LOCK.EXCLUSIVE);\n          }\n        } catch (IOException e) {\n          OLogManager.instance().error(this, \"Error on updating record \" + rid + \" (cluster: \" + cluster + \")\", e);\n\n          final ORecordVersion recordVersion = OVersionFactory.instance().createUntrackedVersion();\n          if (callback != null)\n            callback.call(rid, recordVersion);\n\n          return new OStorageOperationResult<ORecordVersion>(recordVersion);\n        } finally {\n          lock.releaseSharedLock();\n        }\n      } finally {\n        modificationLock.releaseModificationLock();\n      }\n    } finally {\n      cluster.getExternalModificationLock().releaseModificationLock();\n    }\n  }","commit_id":"75585374a245a55aaf7a923c9ea4092f695db9b1","url":"https://github.com/orientechnologies/orientdb"}]